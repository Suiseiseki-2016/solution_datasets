{
  "metadata": {
    "batch_number": 49,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 5000,
    "created_at": "2025-08-28T20:48:42.059473",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "538/A",
      "title": "A. Cutting Banner",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains the word written on the banner. The word only consists of upper-case English letters. The word is non-empty and its length doesn't exceed 100 characters. It is guaranteed that the word isn't word CODEFORCES.",
      "output_spec": "OutputPrint 'YES', if there exists a way to cut out the substring, and 'NO' otherwise (without the quotes).",
      "sample_tests": "ExamplesInputCopyCODEWAITFORITFORCESOutputCopyYESInputCopyBOTTOMCODEROutputCopyNOInputCopyDECODEFORCESOutputCopyYESInputCopyDOGEFORCESOutputCopyNO",
      "description": "A. Cutting Banner\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line of the input contains the word written on the banner. The word only consists of upper-case English letters. The word is non-empty and its length doesn't exceed 100 characters. It is guaranteed that the word isn't word CODEFORCES.\n\nOutputPrint 'YES', if there exists a way to cut out the substring, and 'NO' otherwise (without the quotes).\n\nInputCopyCODEWAITFORITFORCESOutputCopyYESInputCopyBOTTOMCODEROutputCopyNOInputCopyDECODEFORCESOutputCopyYESInputCopyDOGEFORCESOutputCopyNO\n\nInputCopyCODEWAITFORITFORCES\n\nOutputCopyYES\n\nInputCopyBOTTOMCODER\n\nOutputCopyNO\n\nInputCopyDECODEFORCES\n\nOutputCopyYES\n\nInputCopyDOGEFORCES\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*A"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]{1,100}\", \"s\");\n    ensuref(s != \"CODEFORCES\", \"Input cannot be 'CODEFORCES'\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]{1,100}\", \"s\");\n    ensuref(s != \"CODEFORCES\", \"Input cannot be 'CODEFORCES'\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]{1,100}\", \"s\");\n    ensuref(s != \"CODEFORCES\", \"Input cannot be 'CODEFORCES'\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring CODEFORCES = \"CODEFORCES\";\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    string word;\n\n    if (type == \"possible\") {\n        // Generate a word where it's possible to get 'CODEFORCES' by removing a substring.\n        int len = CODEFORCES.length(); // len = 10\n        int k = rnd.next(0, len); // k from 0 to len\n        string prefix = CODEFORCES.substr(0, k);\n        string suffix = CODEFORCES.substr(k);\n\n        int extraLen = n - len; // n - 10 letters to fill\n        if (extraLen < 0) extraLen = 0; // Ensure non-negative\n        string middle = \"\";\n        for (int i = 0; i < extraLen; i++) {\n            char ch = 'A' + rnd.next(26); // Random uppercase letter\n            middle += ch;\n        }\n        word = prefix + middle + suffix;\n    } else if (type == \"impossible\") {\n        // Generate a word where it's impossible to get 'CODEFORCES' by removing a substring.\n        word = \"\";\n        for (int i = 0; i < n; i++) {\n            char ch = 'A' + rnd.next(26);\n            word += ch;\n        }\n        // Ensure that 'CODEFORCES' cannot be formed\n        // Remove occurrences of 'CODEFORCES' in any way possible\n        for (int k = 0; k <= CODEFORCES.length(); ++k) {\n            string prefix = CODEFORCES.substr(0, k);\n            string suffix = CODEFORCES.substr(k);\n            if (word.substr(0, k) == prefix && word.substr(word.length() - suffix.length()) == suffix) {\n                // Modify word to break the match\n                word[k % word.length()] = 'A' + (word[k % word.length()] - 'A' + 1) % 26;\n            }\n        }\n    } else if (type == \"special\") {\n        // Generate special edge cases, e.g., maximal length with same character\n        word = string(n, 'C'); // Fill with 'C's\n        if (word.find(CODEFORCES) != string::npos) {\n            word[0] = 'D'; // Modify to avoid 'CODEFORCES'\n        }\n    } else if (type == \"manual\") {\n        int casenum = opt<int>(\"case\");\n        if (casenum == 1) {\n            word = \"ACODEFORCES\";\n        } else if (casenum == 2) {\n            word = \"CODEFORCESB\";\n        } else if (casenum == 3) {\n            word = \"COXDEFORCES\";\n        } else if (casenum == 4) {\n            word = \"CODEFXORCES\";\n        } else if (casenum == 5) {\n            word = \"COD\";\n        } else if (casenum == 6) {\n            word = \"CODEFORCEX\";\n        } else if (casenum == 7) {\n            word = \"XCODEFORCESX\";\n        } else if (casenum == 8) {\n            word = string(100, 'A');\n        } else if (casenum == 9) {\n            word = \"SCODEFORCESY\";\n        } else if (casenum == 10) {\n            word = CODEFORCES + \"EXTRA\";\n        }\n    } else {\n        // Random word of length n\n        word = \"\";\n        for (int i = 0; i < n; i++) {\n            char ch = 'A' + rnd.next(26);\n            word += ch;\n        }\n        // Ensure word is not 'CODEFORCES'\n        if (word == CODEFORCES) {\n            word[0] = 'A' + (word[0] - 'A' + 1) % 26;\n        }\n    }\n\n    // Ensure word length is within constraints\n    if ((int)word.length() > 100) {\n        word = word.substr(0, 100);\n    }\n    if (word == CODEFORCES) {\n        // Modify to meet problem constraint (input is not 'CODEFORCES')\n        word[0] = 'A' + (word[0] - 'A' + 1) % 26;\n    }\n\n    cout << word << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring CODEFORCES = \"CODEFORCES\";\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    string word;\n\n    if (type == \"possible\") {\n        // Generate a word where it's possible to get 'CODEFORCES' by removing a substring.\n        int len = CODEFORCES.length(); // len = 10\n        int k = rnd.next(0, len); // k from 0 to len\n        string prefix = CODEFORCES.substr(0, k);\n        string suffix = CODEFORCES.substr(k);\n\n        int extraLen = n - len; // n - 10 letters to fill\n        if (extraLen < 0) extraLen = 0; // Ensure non-negative\n        string middle = \"\";\n        for (int i = 0; i < extraLen; i++) {\n            char ch = 'A' + rnd.next(26); // Random uppercase letter\n            middle += ch;\n        }\n        word = prefix + middle + suffix;\n    } else if (type == \"impossible\") {\n        // Generate a word where it's impossible to get 'CODEFORCES' by removing a substring.\n        word = \"\";\n        for (int i = 0; i < n; i++) {\n            char ch = 'A' + rnd.next(26);\n            word += ch;\n        }\n        // Ensure that 'CODEFORCES' cannot be formed\n        // Remove occurrences of 'CODEFORCES' in any way possible\n        for (int k = 0; k <= CODEFORCES.length(); ++k) {\n            string prefix = CODEFORCES.substr(0, k);\n            string suffix = CODEFORCES.substr(k);\n            if (word.substr(0, k) == prefix && word.substr(word.length() - suffix.length()) == suffix) {\n                // Modify word to break the match\n                word[k % word.length()] = 'A' + (word[k % word.length()] - 'A' + 1) % 26;\n            }\n        }\n    } else if (type == \"special\") {\n        // Generate special edge cases, e.g., maximal length with same character\n        word = string(n, 'C'); // Fill with 'C's\n        if (word.find(CODEFORCES) != string::npos) {\n            word[0] = 'D'; // Modify to avoid 'CODEFORCES'\n        }\n    } else if (type == \"manual\") {\n        int casenum = opt<int>(\"case\");\n        if (casenum == 1) {\n            word = \"ACODEFORCES\";\n        } else if (casenum == 2) {\n            word = \"CODEFORCESB\";\n        } else if (casenum == 3) {\n            word = \"COXDEFORCES\";\n        } else if (casenum == 4) {\n            word = \"CODEFXORCES\";\n        } else if (casenum == 5) {\n            word = \"COD\";\n        } else if (casenum == 6) {\n            word = \"CODEFORCEX\";\n        } else if (casenum == 7) {\n            word = \"XCODEFORCESX\";\n        } else if (casenum == 8) {\n            word = string(100, 'A');\n        } else if (casenum == 9) {\n            word = \"SCODEFORCESY\";\n        } else if (casenum == 10) {\n            word = CODEFORCES + \"EXTRA\";\n        }\n    } else {\n        // Random word of length n\n        word = \"\";\n        for (int i = 0; i < n; i++) {\n            char ch = 'A' + rnd.next(26);\n            word += ch;\n        }\n        // Ensure word is not 'CODEFORCES'\n        if (word == CODEFORCES) {\n            word[0] = 'A' + (word[0] - 'A' + 1) % 26;\n        }\n    }\n\n    // Ensure word length is within constraints\n    if ((int)word.length() > 100) {\n        word = word.substr(0, 100);\n    }\n    if (word == CODEFORCES) {\n        // Modify to meet problem constraint (input is not 'CODEFORCES')\n        word[0] = 'A' + (word[0] - 'A' + 1) % 26;\n    }\n\n    cout << word << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 15 -type possible\n./gen -n 20 -type possible\n./gen -n 25 -type possible\n./gen -n 30 -type possible\n./gen -n 35 -type possible\n\n./gen -n 15 -type impossible\n./gen -n 20 -type impossible\n./gen -n 25 -type impossible\n./gen -n 30 -type impossible\n./gen -n 35 -type impossible\n\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 10 -type random\n./gen -n 99 -type random\n\n./gen -n 100 -type special\n\n./gen -n 100 -type possible\n./gen -n 100 -type impossible\n./gen -n 100 -type random\n\n./gen -type manual -case 1\n./gen -type manual -case 2\n./gen -type manual -case 3\n./gen -type manual -case 4\n./gen -type manual -case 5\n./gen -type manual -case 6\n./gen -type manual -case 7\n./gen -type manual -case 8\n./gen -type manual -case 9\n./gen -type manual -case 10\n\n./gen -n 10 -type possible\n./gen -n 10 -type impossible\n./gen -n 10 -type random\n\n./gen -n 8 -type possible\n./gen -n 11 -type impossible\n./gen -n 12 -type possible\n./gen -n 100 -type possible\n./gen -n 100 -type impossible\n./gen -n 99 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:17.056122",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/B",
      "title": "B. Quasi Binary",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 106).",
      "output_spec": "OutputIn the first line print a single integer k — the minimum number of numbers in the representation of number n as a sum of quasibinary numbers.In the second line print k numbers — the elements of the sum. All these numbers should be quasibinary according to the definition above, their sum should equal n. Do not have to print the leading zeroes in the numbers. The order of numbers doesn't matter. If there are multiple possible representations, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy9OutputCopy91 1 1 1 1 1 1 1 1 InputCopy32OutputCopy310 11 11",
      "description": "B. Quasi Binary\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 106).\n\nOutputIn the first line print a single integer k — the minimum number of numbers in the representation of number n as a sum of quasibinary numbers.In the second line print k numbers — the elements of the sum. All these numbers should be quasibinary according to the definition above, their sum should equal n. Do not have to print the leading zeroes in the numbers. The order of numbers doesn't matter. If there are multiple possible representations, you are allowed to print any of them.\n\nInputCopy9OutputCopy91 1 1 1 1 1 1 1 1 InputCopy32OutputCopy310 11 11\n\nOutputCopy91 1 1 1 1 1 1 1 1\n\nInputCopy32\n\nOutputCopy310 11 11",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*B"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool isQuasibinary(int num) {\n    if (num == 0) return true; // 0 is considered quasibinary\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit != 0 && digit != 1)\n            return false;\n        num /= 10;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 1000000);\n\n    int temp_n = n;\n    int max_digit = 0;\n    while (temp_n > 0) {\n        int digit = temp_n % 10;\n        if (digit > max_digit)\n            max_digit = digit;\n        temp_n /= 10;\n    }\n\n    int minimal_k = max_digit;\n\n    int k = ouf.readInt(1, n, \"k\");\n    if (k != minimal_k) {\n        quitf(_wa, \"Incorrect number of terms k: expected %d, found %d\", minimal_k, k);\n    }\n\n    vector<int> numbers = ouf.readInts(k, 1, n, \"numbers\");\n    long long sum = 0;\n    for (int i = 0; i < k; i++) {\n        int num = numbers[i];\n        if (!isQuasibinary(num)) {\n            quitf(_wa, \"Number %d at position %d is not quasibinary\", num, i + 1);\n        }\n        sum += num;\n    }\n\n    if (sum != n) {\n        quitf(_wa, \"Sum of quasibinary numbers is incorrect: expected %d, found %lld\", n, sum);\n    }\n\n    quitf(_ok, \"Correct representation with k=%d quasibinary numbers\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int n;\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000000);\n    } else if (type == \"all_ones\") {\n        // Generate a number consisting of digit '1's up to 6 digits\n        n = 0;\n        for(int i = 0; i < 6; ++i) {\n            n = n * 10 + 1;\n        }\n    } else if (type == \"all_nines\") {\n        // Generate a number consisting of digit '9's up to 6 digits\n        n = 0;\n        for(int i = 0; i < 6; ++i) {\n            n = n * 10 + 9;\n        }\n    } else if (type == \"zeros_in_between\") {\n        // Create a number like 909090\n        n = 0;\n        for(int i = 0; i < 6; ++i) {\n            n = n * 10 + (i % 2 == 0 ? 9 : 0);\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a random palindrome number within [1, 1000000]\n        int halfLength = rnd.next(1, 3); // Since total length max 6\n        int firstHalf = rnd.next(static_cast<int>(pow(10, halfLength - 1)), static_cast<int>(pow(10, halfLength)) - 1);\n        string s = to_string(firstHalf);\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        s += rev_s;\n        n = stoi(s);\n        if (n > 1000000) n = n % 1000000 + 1; // Ensure n ≤ 1000000\n    } else if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        if (n < 1 || n > 1000000) {\n            // Invalid n, default to random\n            n = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_digit\") {\n        // Generate a number with the maximum digit possible\n        int maxDigit = rnd.next(5, 9);\n        int length = rnd.next(1, 6);\n        string s(length, '0' + maxDigit);\n        n = stoi(s);\n        if (n > 1000000) n %= 1000000; // Ensure n ≤ 1000000\n        if (n < 1) n = 1;\n    } else if (type == \"min_digit\") {\n        // Generate a number with the minimum digit possible (except 0)\n        int minDigit = rnd.next(1, 4);\n        int length = rnd.next(1, 6);\n        string s(length, '0' + minDigit);\n        n = stoi(s);\n        if (n > 1000000) n %= 1000000; // Ensure n ≤ 1000000\n        if (n < 1) n = 1;\n    } else {\n        // Default to random if unknown type\n        n = rnd.next(1, 1000000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    int n;\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000000);\n    } else if (type == \"all_ones\") {\n        // Generate a number consisting of digit '1's up to 6 digits\n        n = 0;\n        for(int i = 0; i < 6; ++i) {\n            n = n * 10 + 1;\n        }\n    } else if (type == \"all_nines\") {\n        // Generate a number consisting of digit '9's up to 6 digits\n        n = 0;\n        for(int i = 0; i < 6; ++i) {\n            n = n * 10 + 9;\n        }\n    } else if (type == \"zeros_in_between\") {\n        // Create a number like 909090\n        n = 0;\n        for(int i = 0; i < 6; ++i) {\n            n = n * 10 + (i % 2 == 0 ? 9 : 0);\n        }\n    } else if (type == \"palindrome\") {\n        // Generate a random palindrome number within [1, 1000000]\n        int halfLength = rnd.next(1, 3); // Since total length max 6\n        int firstHalf = rnd.next(static_cast<int>(pow(10, halfLength - 1)), static_cast<int>(pow(10, halfLength)) - 1);\n        string s = to_string(firstHalf);\n        string rev_s = s;\n        reverse(rev_s.begin(), rev_s.end());\n        s += rev_s;\n        n = stoi(s);\n        if (n > 1000000) n = n % 1000000 + 1; // Ensure n ≤ 1000000\n    } else if (type == \"custom\") {\n        n = opt<int>(\"n\");\n        if (n < 1 || n > 1000000) {\n            // Invalid n, default to random\n            n = rnd.next(1, 1000000);\n        }\n    } else if (type == \"max_digit\") {\n        // Generate a number with the maximum digit possible\n        int maxDigit = rnd.next(5, 9);\n        int length = rnd.next(1, 6);\n        string s(length, '0' + maxDigit);\n        n = stoi(s);\n        if (n > 1000000) n %= 1000000; // Ensure n ≤ 1000000\n        if (n < 1) n = 1;\n    } else if (type == \"min_digit\") {\n        // Generate a number with the minimum digit possible (except 0)\n        int minDigit = rnd.next(1, 4);\n        int length = rnd.next(1, 6);\n        string s(length, '0' + minDigit);\n        n = stoi(s);\n        if (n > 1000000) n %= 1000000; // Ensure n ≤ 1000000\n        if (n < 1) n = 1;\n    } else {\n        // Default to random if unknown type\n        n = rnd.next(1, 1000000);\n    }\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type custom -n 2\n./gen -type custom -n 3\n./gen -type custom -n 4\n./gen -type custom -n 5\n\n./gen -type max\n./gen -type custom -n 1000000\n\n./gen -type all_nines\n./gen -type custom -n 999999\n\n./gen -type min_digit\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type palindrome\n./gen -type palindrome\n./gen -type palindrome\n\n./gen -type zeros_in_between\n./gen -type custom -n 101010\n./gen -type custom -n 202020\n\n./gen -type all_ones\n\n./gen -type custom -n 123456\n./gen -type custom -n 654321\n\n./gen -type custom -n 121212\n./gen -type custom -n 989898\n\n./gen -type custom -n 555555\n./gen -type custom -n 666666\n./gen -type custom -n 777777\n./gen -type custom -n 888888\n\n./gen -type custom -n 333333\n\n./gen -type custom -n 7\n./gen -type custom -n 9\n\n./gen -type custom -n 987654\n./gen -type custom -n 876543\n\n./gen -type custom -n 234567\n./gen -type custom -n 345678\n\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:19.006435",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/C",
      "title": "C. Tourist's Notes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated numbers, n and m (1 ≤ n ≤ 108, 1 ≤ m ≤ 105) — the number of days of the hike and the number of notes left in the journal.Next m lines contain two space-separated integers di and hdi (1 ≤ di ≤ n, 0 ≤ hdi ≤ 108) — the number of the day when the i-th note was made and height on the di-th day. It is guaranteed that the notes are given in the chronological order, i.e. for all i from 1 to m - 1 the following condition holds: di < di + 1.",
      "output_spec": "OutputIf the notes aren't contradictory, print a single integer — the maximum possible height value throughout the whole route.If the notes do not correspond to any set of heights, print a single word 'IMPOSSIBLE' (without the quotes).",
      "sample_tests": "ExamplesInputCopy8 22 07 0OutputCopy2InputCopy8 32 07 08 3OutputCopyIMPOSSIBLE",
      "description": "C. Tourist's Notes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated numbers, n and m (1 ≤ n ≤ 108, 1 ≤ m ≤ 105) — the number of days of the hike and the number of notes left in the journal.Next m lines contain two space-separated integers di and hdi (1 ≤ di ≤ n, 0 ≤ hdi ≤ 108) — the number of the day when the i-th note was made and height on the di-th day. It is guaranteed that the notes are given in the chronological order, i.e. for all i from 1 to m - 1 the following condition holds: di < di + 1.\n\nOutputIf the notes aren't contradictory, print a single integer — the maximum possible height value throughout the whole route.If the notes do not correspond to any set of heights, print a single word 'IMPOSSIBLE' (without the quotes).\n\nInputCopy8 22 07 0OutputCopy2InputCopy8 32 07 08 3OutputCopyIMPOSSIBLE\n\nInputCopy8 22 07 0\n\nOutputCopy2\n\nInputCopy8 32 07 08 3\n\nOutputCopyIMPOSSIBLE\n\nNoteFor the first sample, an example of a correct height sequence with a maximum of 2: (0, 0, 1, 2, 1, 1, 0, 1).In the second sample the inequality between h7 and h8 does not hold, thus the information is inconsistent.",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*C"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= n, \"m (%d) must be less than or equal to n (%d)\", m, n);\n\n    int prev_d = 0;\n    for (int i = 0; i < m; ++i) {\n        int di = inf.readInt(1, n, \"d_i\");\n        ensuref(di > prev_d, \"di (%d) should be greater than previous di (%d)\", di, prev_d);\n        prev_d = di;\n\n        inf.readSpace();\n\n        int hdi = inf.readInt(0, 100000000, \"h_d_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= n, \"m (%d) must be less than or equal to n (%d)\", m, n);\n\n    int prev_d = 0;\n    for (int i = 0; i < m; ++i) {\n        int di = inf.readInt(1, n, \"d_i\");\n        ensuref(di > prev_d, \"di (%d) should be greater than previous di (%d)\", di, prev_d);\n        prev_d = di;\n\n        inf.readSpace();\n\n        int hdi = inf.readInt(0, 100000000, \"h_d_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(m <= n, \"m (%d) must be less than or equal to n (%d)\", m, n);\n\n    int prev_d = 0;\n    for (int i = 0; i < m; ++i) {\n        int di = inf.readInt(1, n, \"d_i\");\n        ensuref(di > prev_d, \"di (%d) should be greater than previous di (%d)\", di, prev_d);\n        prev_d = di;\n\n        inf.readSpace();\n\n        int hdi = inf.readInt(0, 100000000, \"h_d_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    vector<int> di(m);\n    vector<int> hdi(m);\n\n    int hmax = (int)1e8;\n\n    if (type == \"random_valid\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    } else if (type == \"random_invalid\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n        // Introduce an impossible condition\n        int i = rnd.next(1, m - 1);\n        int delta_days = di[i] - di[i - 1];\n        hdi[i] = hdi[i - 1] + delta_days + 1; // Makes it impossible\n    } else if (type == \"max_height\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi with maximum possible heights\n        hdi[0] = hmax;\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = min(hmax, hdi[i - 1] + delta_days);\n            hdi[i] = maxHeight; // Try to keep height as high as possible\n        }\n    } else if (type == \"zero_height\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi with zero heights\n        hdi[0] = 0;\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = minHeight; // Keep height as low as possible\n        }\n    } else if (type == \"adjacent_notes\") {\n        // Generate di with adjacent days\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            di[i] = di[i - 1] + 1;\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int minHeight = max(0, hdi[i - 1] - 1);\n            int maxHeight = hdi[i - 1] + 1;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    } else if (type == \"large_gap\") {\n        // Generate di with large gaps\n        di[0] = 1;\n        for (int i = 1; i < m; ++i) {\n            di[i] = di[i - 1] + (n - di[i - 1]) / (m - i + 1);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    } else if (type == \"impossible_sequence\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi with impossible sequence\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n        // Introduce an impossible condition\n        int i = m / 2;\n        int delta_days = di[i] - di[i - 1];\n        hdi[i] = hdi[i - 1] + delta_days + 1; // Makes it impossible\n    } else if (type == \"single_day\") {\n        // n = 1, m = 1\n        di[0] = 1;\n        hdi[0] = rnd.next(0, hmax);\n    } else {\n        // Default is random_valid\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output di and hdi\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", di[i], hdi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random_valid\");\n\n    vector<int> di(m);\n    vector<int> hdi(m);\n\n    int hmax = (int)1e8;\n\n    if (type == \"random_valid\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    } else if (type == \"random_invalid\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n        // Introduce an impossible condition\n        int i = rnd.next(1, m - 1);\n        int delta_days = di[i] - di[i - 1];\n        hdi[i] = hdi[i - 1] + delta_days + 1; // Makes it impossible\n    } else if (type == \"max_height\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi with maximum possible heights\n        hdi[0] = hmax;\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = min(hmax, hdi[i - 1] + delta_days);\n            hdi[i] = maxHeight; // Try to keep height as high as possible\n        }\n    } else if (type == \"zero_height\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi with zero heights\n        hdi[0] = 0;\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = minHeight; // Keep height as low as possible\n        }\n    } else if (type == \"adjacent_notes\") {\n        // Generate di with adjacent days\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            di[i] = di[i - 1] + 1;\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int minHeight = max(0, hdi[i - 1] - 1);\n            int maxHeight = hdi[i - 1] + 1;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    } else if (type == \"large_gap\") {\n        // Generate di with large gaps\n        di[0] = 1;\n        for (int i = 1; i < m; ++i) {\n            di[i] = di[i - 1] + (n - di[i - 1]) / (m - i + 1);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    } else if (type == \"impossible_sequence\") {\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi with impossible sequence\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n        // Introduce an impossible condition\n        int i = m / 2;\n        int delta_days = di[i] - di[i - 1];\n        hdi[i] = hdi[i - 1] + delta_days + 1; // Makes it impossible\n    } else if (type == \"single_day\") {\n        // n = 1, m = 1\n        di[0] = 1;\n        hdi[0] = rnd.next(0, hmax);\n    } else {\n        // Default is random_valid\n        // Generate di\n        di[0] = rnd.next(1, n - m + 1);\n        for (int i = 1; i < m; ++i) {\n            int minIncrement = 1;\n            int maxIncrement = (n - di[i - 1]) - (m - i);\n            di[i] = di[i - 1] + rnd.next(minIncrement, maxIncrement);\n        }\n        // Generate hdi\n        hdi[0] = rnd.next(0, hmax);\n        for (int i = 1; i < m; ++i) {\n            int delta_days = di[i] - di[i - 1];\n            int minHeight = max(0, hdi[i - 1] - delta_days);\n            int maxHeight = hdi[i - 1] + delta_days;\n            hdi[i] = rnd.next(minHeight, maxHeight);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output di and hdi\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", di[i], hdi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type single_day\n./gen -n 10 -m 1 -type single_day\n\n./gen -n 10 -m 2 -type random_valid\n./gen -n 10 -m 2 -type random_invalid\n./gen -n 10 -m 5 -type max_height\n./gen -n 10 -m 5 -type zero_height\n./gen -n 10 -m 9 -type adjacent_notes\n./gen -n 10 -m 2 -type large_gap\n./gen -n 10 -m 5 -type impossible_sequence\n\n./gen -n 100 -m 10 -type random_valid\n./gen -n 100 -m 10 -type random_invalid\n./gen -n 100 -m 50 -type adjacent_notes\n./gen -n 100 -m 10 -type large_gap\n./gen -n 100 -m 50 -type impossible_sequence\n\n./gen -n 1000 -m 100 -type random_valid\n./gen -n 1000 -m 100 -type random_invalid\n./gen -n 1000 -m 500 -type adjacent_notes\n./gen -n 1000 -m 100 -type large_gap\n\n./gen -n 10000 -m 1000 -type random_valid\n./gen -n 10000 -m 1000 -type random_invalid\n./gen -n 10000 -m 5000 -type adjacent_notes\n./gen -n 10000 -m 1000 -type large_gap\n\n./gen -n 100000 -m 10000 -type random_valid\n./gen -n 100000 -m 10000 -type random_invalid\n./gen -n 100000 -m 50000 -type adjacent_notes\n./gen -n 100000 -m 10000 -type large_gap\n\n./gen -n 1000000 -m 100000 -type random_valid\n./gen -n 1000000 -m 100000 -type random_invalid\n./gen -n 1000000 -m 100000 -type impossible_sequence\n\n./gen -n 100000000 -m 100000 -type random_valid\n./gen -n 100000000 -m 100000 -type random_invalid\n./gen -n 100000000 -m 100000 -type max_height\n./gen -n 100000000 -m 100000 -type zero_height\n./gen -n 100000000 -m 100000 -type large_gap\n./gen -n 100000000 -m 100000 -type impossible_sequence\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:21.113632",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/D",
      "title": "D. Weird Chess",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 50).The next n lines contain n characters each describing the position offered by Igor. The j-th character of the i-th string can have the following values: o — in this case the field (i, j) is occupied by a piece and the field may or may not be attacked by some other piece; x — in this case field (i, j) is attacked by some piece; . — in this case field (i, j) isn't attacked by any piece.It is guaranteed that there is at least one piece on the board.",
      "output_spec": "OutputIf there is a valid set of moves, in the first line print a single word 'YES' (without the quotes). Next, print the description of the set of moves of a piece in the form of a (2n - 1) × (2n - 1) board, the center of the board has a piece and symbols 'x' mark cells that are attacked by it, in a format similar to the input. See examples of the output for a full understanding of the format. If there are several possible answers, print any of them.If a valid set of moves does not exist, print a single word 'NO'.",
      "sample_tests": "ExamplesInputCopy5oxxxxx...xx...xx...xxxxxoOutputCopyYES....x........x........x........x....xxxxoxxxx....x........x........x........x....InputCopy6.x.x..x.x.x..xo..xx..ox..x.x.x..x.x.OutputCopyYES.....................................x.x.......x...x........o........x...x.......x.x.....................................InputCopy3o.xoxxo.xOutputCopyNO",
      "description": "D. Weird Chess\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 50).The next n lines contain n characters each describing the position offered by Igor. The j-th character of the i-th string can have the following values: o — in this case the field (i, j) is occupied by a piece and the field may or may not be attacked by some other piece; x — in this case field (i, j) is attacked by some piece; . — in this case field (i, j) isn't attacked by any piece.It is guaranteed that there is at least one piece on the board.\n\nOutputIf there is a valid set of moves, in the first line print a single word 'YES' (without the quotes). Next, print the description of the set of moves of a piece in the form of a (2n - 1) × (2n - 1) board, the center of the board has a piece and symbols 'x' mark cells that are attacked by it, in a format similar to the input. See examples of the output for a full understanding of the format. If there are several possible answers, print any of them.If a valid set of moves does not exist, print a single word 'NO'.\n\nInputCopy5oxxxxx...xx...xx...xxxxxoOutputCopyYES....x........x........x........x....xxxxoxxxx....x........x........x........x....InputCopy6.x.x..x.x.x..xo..xx..ox..x.x.x..x.x.OutputCopyYES.....................................x.x.......x...x........o........x...x.......x.x.....................................InputCopy3o.xoxxo.xOutputCopyNO\n\nInputCopy5oxxxxx...xx...xx...xxxxxo\n\nOutputCopyYES....x........x........x........x....xxxxoxxxx....x........x........x........x....\n\nInputCopy6.x.x..x.x.x..xo..xx..ox..x.x.x..x.x.\n\nOutputCopyYES.....................................x.x.......x...x........o........x...x.......x.x.....................................\n\nInputCopy3o.xoxxo.x\n\nOutputCopyNO\n\nNoteIn the first sample test the piece is a usual chess rook, and in the second sample test the piece is a usual chess knight.",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*D"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    int total_o = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == n, \"Line %d should have length %d\", i + 1, n);\n        for (int j = 0; j < n; j++) {\n            char c = s[j];\n            ensuref(c == 'o' || c == 'x' || c == '.', \"Line %d column %d contains invalid character '%c'\", i + 1, j + 1, c);\n            if (c == 'o') {\n                total_o++;\n            }\n        }\n    }\n    ensuref(total_o >= 1, \"At least one 'o' character must be present on the board\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    int total_o = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == n, \"Line %d should have length %d\", i + 1, n);\n        for (int j = 0; j < n; j++) {\n            char c = s[j];\n            ensuref(c == 'o' || c == 'x' || c == '.', \"Line %d column %d contains invalid character '%c'\", i + 1, j + 1, c);\n            if (c == 'o') {\n                total_o++;\n            }\n        }\n    }\n    ensuref(total_o >= 1, \"At least one 'o' character must be present on the board\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readEoln();\n    int total_o = 0;\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.size()) == n, \"Line %d should have length %d\", i + 1, n);\n        for (int j = 0; j < n; j++) {\n            char c = s[j];\n            ensuref(c == 'o' || c == 'x' || c == '.', \"Line %d column %d contains invalid character '%c'\", i + 1, j + 1, c);\n            if (c == 'o') {\n                total_o++;\n            }\n        }\n    }\n    ensuref(total_o >= 1, \"At least one 'o' character must be present on the board\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    vector<string> board(n);\n    for (int i = 0; i < n; ++i) {\n        board[i] = inf.readToken(format(\"[ox.]{%d}\", n).c_str(), format(\"board line #%d\", i+1).c_str());\n    }\n\n    string ans_opt = ans.readToken();\n    string con_opt = ouf.readToken();\n\n    if (ans_opt != \"YES\" && ans_opt != \"NO\") {\n        quitf(_fail, \"Jury output should be YES or NO, but found '%s'\", ans_opt.c_str());\n    }\n    if (con_opt != \"YES\" && con_opt != \"NO\") {\n        quitf(_pe, \"Participant output should be YES or NO, but found '%s'\", con_opt.c_str());\n    }\n\n    if (ans_opt == \"NO\") {\n        if (con_opt != \"NO\") {\n            quitf(_wa, \"Participant's answer is '%s', but the correct answer is 'NO'\", con_opt.c_str());\n        } else {\n            quitf(_ok, \"Correct answer: NO\");\n        }\n    } else {\n        // ans_opt == \"YES\"\n        if (con_opt != \"YES\") {\n            quitf(_wa, \"Participant's answer is 'NO', but the correct answer is 'YES'\");\n        }\n\n        int m = 2 * n - 1;\n        vector<string> shift_pattern(m);\n        for (int i = 0; i < m; ++i) {\n            shift_pattern[i] = ouf.readToken(format(\"[x.o]{%d}\", m).c_str(), format(\"shift pattern line #%d\", i+1).c_str());\n            if ((int)shift_pattern[i].length() != m) {\n                quitf(_pe, \"Length of shift pattern line #%d should be %d, but found %d\", i+1, m, (int)shift_pattern[i].length());\n            }\n        }\n\n        if (shift_pattern[n - 1][n - 1] != 'o') {\n            quitf(_wa, \"Center of shift pattern at position (%d, %d) should be 'o'\", n, n);\n        }\n\n        set<pair<int, int>> shifts;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (i == n - 1 && j == n - 1) continue; // Skip center\n                char ch = shift_pattern[i][j];\n                if (ch == 'x') {\n                    int dx = j - (n - 1);\n                    int dy = i - (n - 1);\n                    shifts.insert(make_pair(dx, dy));\n                } else if (ch != '.') {\n                    quitf(_wa, \"Invalid character '%c' in shift pattern at position (%d, %d)\", ch, i + 1, j + 1);\n                }\n            }\n        }\n\n        int N = n;\n        vector<vector<bool>> attacked(N, vector<bool>(N, false));\n\n        for (int y = 0; y < N; ++y) {\n            for (int x = 0; x < N; ++x) {\n                if (board[y][x] == 'o') {\n                    for (auto shift : shifts) {\n                        int dx = shift.first;\n                        int dy = shift.second;\n                        int nx = x + dx;\n                        int ny = y + dy;\n                        if (0 <= nx && nx < N && 0 <= ny && ny < N) {\n                            if (board[ny][nx] != 'o') {\n                                attacked[ny][nx] = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int y = 0; y < N; ++y) {\n            for (int x = 0; x < N; ++x) {\n                if (board[y][x] == 'x') {\n                    if (!attacked[y][x]) {\n                        quitf(_wa, \"Cell (%d, %d) should be attacked, but it is not\", y + 1, x + 1);\n                    }\n                } else if (board[y][x] == '.') {\n                    if (attacked[y][x]) {\n                        quitf(_wa, \"Cell (%d, %d) should not be attacked, but it is\", y + 1, x + 1);\n                    }\n                }\n                // We don't care about 'o' cells\n            }\n        }\n\n        quitf(_ok, \"Correct answer: YES\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize the empty board\n    vector<string> board(n, string(n, '.'));\n\n    if (type == \"rook\") {\n        // Place 'o's and 'x's according to rook moves\n        int num_pieces = rnd.next(1, n); // At least one piece\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        // Now, for each 'o' (piece), mark the 'x's along the rows and columns\n        for (auto [x, y] : pieces) {\n            // Rook moves: horizontal and vertical\n            int dx[] = {1, -1, 0, 0};\n            int dy[] = {0, 0, 1, -1};\n\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                    if (board[nx][ny] == 'o') {\n                        // Cannot attack through or to another piece\n                        break;\n                    }\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                    nx += dx[dir];\n                    ny += dy[dir];\n                }\n            }\n        }\n    } else if (type == \"knight\") {\n        // Knight moves\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n        int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n        for (auto [x, y] : pieces) {\n            for (int i = 0; i < 8; ++i) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && board[nx][ny] != 'o') {\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                }\n            }\n        }\n    } else if (type == \"bishop\") {\n        // Bishop moves\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        int d[] = {-1, 1};\n        for (auto [x, y] : pieces) {\n            for (int dx_dir : d) {\n                for (int dy_dir : d) {\n                    int nx = x + dx_dir;\n                    int ny = y + dy_dir;\n                    while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                        if (board[nx][ny] == 'o') {\n                            break;\n                        }\n                        if (board[nx][ny] == '.') {\n                            board[nx][ny] = 'x';\n                        }\n                        nx += dx_dir;\n                        ny += dy_dir;\n                    }\n                }\n            }\n        }\n    } else if (type == \"queen\") {\n        // Queen moves\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        int dx[] = {1, -1, 0, 0, 1, 1, -1, -1};\n        int dy[] = {0, 0, 1, -1, 1, -1, 1, -1};\n\n        for (auto [x, y] : pieces) {\n            for (int dir = 0; dir < 8; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                    if (board[nx][ny] == 'o') {\n                        break;\n                    }\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                    nx += dx[dir];\n                    ny += dy[dir];\n                }\n            }\n        }\n    } else if (type == \"random_yes\") {\n        // Random 'YES' case\n        int num_shifts = rnd.next(1, n);\n        set<pair<int,int>> shifts;\n        while (shifts.size() < num_shifts) {\n            int dx = rnd.next(-n+1, n-1);\n            int dy = rnd.next(-n+1, n-1);\n            if (dx == 0 && dy == 0) continue;\n            shifts.insert({dx, dy});\n        }\n\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n-1);\n                y = rnd.next(0, n-1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n        \n        for (auto [x, y] : pieces) {\n            for (auto [dx, dy] : shifts) {\n                int nx = x + dx;\n                int ny = y + dy;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && board[nx][ny] != 'o') {\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                }\n            }\n        }\n    } else if (type == \"random_no\") {\n        // Random 'NO' case\n        if (n < 2) n = 2;\n        board.resize(n, string(n, '.'));\n        int cx = n / 2;\n        int cy = n / 2;\n        board[cx][cy] = 'o';\n\n        board[0][0] = 'x';\n        board[0][n - 1] = 'x';\n        board[n - 1][0] = 'x';\n        board[n - 1][n - 1] = 'x';\n    } else if (type == \"minimal_yes\") {\n        n = (n >= 1 && n <= 2) ? n : 1;\n        board.resize(n, string(n, '.'));\n        board[0][0] = 'o';\n    } else if (type == \"minimal_no\") {\n        n = (n >= 1 && n <= 2) ? n : 1;\n        board.resize(n, string(n, '.'));\n        board[0][0] = 'o';\n        if (n > 1) {\n            board[0][1] = 'x';\n            board[1][1] = 'x';\n        }\n    } else if (type == \"edge_yes\") {\n        n = 50;\n        board.resize(n, string(n, '.'));\n        int cx = n / 2;\n        int cy = n / 2;\n        board[cx][cy] = 'o';\n\n        int dx[] = {1,-1,0,0,1,1,-1,-1};\n        int dy[] = {0,0,1,-1,1,-1,1,-1};\n        for (int dir = 0; dir < 8; ++dir) {\n            int nx = cx + dx[dir];\n            int ny = cy + dy[dir];\n            while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                if (board[nx][ny] == '.') {\n                    board[nx][ny] = 'x';\n                }\n                nx += dx[dir];\n                ny += dy[dir];\n            }\n        }\n    } else if (type == \"edge_no\") {\n        n = 50;\n        board.resize(n, string(n, '.'));\n        board[0][0] = 'o';\n        board[0][1] = 'o';\n        board[n-1][n-1] = 'x';\n    } else {\n        n = rnd.next(1, 50);\n        board.resize(n, string(n, '.'));\n        int num_pieces = rnd.next(1, n);\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            x = rnd.next(0, n-1);\n            y = rnd.next(0, n-1);\n            board[x][y] = 'o';\n        }\n    }\n\n    // Output the board\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", board[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize the empty board\n    vector<string> board(n, string(n, '.'));\n\n    if (type == \"rook\") {\n        // Place 'o's and 'x's according to rook moves\n        int num_pieces = rnd.next(1, n); // At least one piece\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        // Now, for each 'o' (piece), mark the 'x's along the rows and columns\n        for (auto [x, y] : pieces) {\n            // Rook moves: horizontal and vertical\n            int dx[] = {1, -1, 0, 0};\n            int dy[] = {0, 0, 1, -1};\n\n            for (int dir = 0; dir < 4; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                    if (board[nx][ny] == 'o') {\n                        // Cannot attack through or to another piece\n                        break;\n                    }\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                    nx += dx[dir];\n                    ny += dy[dir];\n                }\n            }\n        }\n    } else if (type == \"knight\") {\n        // Knight moves\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        int dx[] = {-2, -1, 1, 2, 2, 1, -1, -2};\n        int dy[] = {1, 2, 2, 1, -1, -2, -2, -1};\n        for (auto [x, y] : pieces) {\n            for (int i = 0; i < 8; ++i) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && board[nx][ny] != 'o') {\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                }\n            }\n        }\n    } else if (type == \"bishop\") {\n        // Bishop moves\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        int d[] = {-1, 1};\n        for (auto [x, y] : pieces) {\n            for (int dx_dir : d) {\n                for (int dy_dir : d) {\n                    int nx = x + dx_dir;\n                    int ny = y + dy_dir;\n                    while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                        if (board[nx][ny] == 'o') {\n                            break;\n                        }\n                        if (board[nx][ny] == '.') {\n                            board[nx][ny] = 'x';\n                        }\n                        nx += dx_dir;\n                        ny += dy_dir;\n                    }\n                }\n            }\n        }\n    } else if (type == \"queen\") {\n        // Queen moves\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n - 1);\n                y = rnd.next(0, n - 1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n\n        int dx[] = {1, -1, 0, 0, 1, 1, -1, -1};\n        int dy[] = {0, 0, 1, -1, 1, -1, 1, -1};\n\n        for (auto [x, y] : pieces) {\n            for (int dir = 0; dir < 8; ++dir) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n                while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                    if (board[nx][ny] == 'o') {\n                        break;\n                    }\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                    nx += dx[dir];\n                    ny += dy[dir];\n                }\n            }\n        }\n    } else if (type == \"random_yes\") {\n        // Random 'YES' case\n        int num_shifts = rnd.next(1, n);\n        set<pair<int,int>> shifts;\n        while (shifts.size() < num_shifts) {\n            int dx = rnd.next(-n+1, n-1);\n            int dy = rnd.next(-n+1, n-1);\n            if (dx == 0 && dy == 0) continue;\n            shifts.insert({dx, dy});\n        }\n\n        int num_pieces = rnd.next(1, n);\n        vector<pair<int, int>> pieces;\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            do {\n                x = rnd.next(0, n-1);\n                y = rnd.next(0, n-1);\n            } while (board[x][y] == 'o');\n            board[x][y] = 'o';\n            pieces.push_back({x, y});\n        }\n        \n        for (auto [x, y] : pieces) {\n            for (auto [dx, dy] : shifts) {\n                int nx = x + dx;\n                int ny = y + dy;\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && board[nx][ny] != 'o') {\n                    if (board[nx][ny] == '.') {\n                        board[nx][ny] = 'x';\n                    }\n                }\n            }\n        }\n    } else if (type == \"random_no\") {\n        // Random 'NO' case\n        if (n < 2) n = 2;\n        board.resize(n, string(n, '.'));\n        int cx = n / 2;\n        int cy = n / 2;\n        board[cx][cy] = 'o';\n\n        board[0][0] = 'x';\n        board[0][n - 1] = 'x';\n        board[n - 1][0] = 'x';\n        board[n - 1][n - 1] = 'x';\n    } else if (type == \"minimal_yes\") {\n        n = (n >= 1 && n <= 2) ? n : 1;\n        board.resize(n, string(n, '.'));\n        board[0][0] = 'o';\n    } else if (type == \"minimal_no\") {\n        n = (n >= 1 && n <= 2) ? n : 1;\n        board.resize(n, string(n, '.'));\n        board[0][0] = 'o';\n        if (n > 1) {\n            board[0][1] = 'x';\n            board[1][1] = 'x';\n        }\n    } else if (type == \"edge_yes\") {\n        n = 50;\n        board.resize(n, string(n, '.'));\n        int cx = n / 2;\n        int cy = n / 2;\n        board[cx][cy] = 'o';\n\n        int dx[] = {1,-1,0,0,1,1,-1,-1};\n        int dy[] = {0,0,1,-1,1,-1,1,-1};\n        for (int dir = 0; dir < 8; ++dir) {\n            int nx = cx + dx[dir];\n            int ny = cy + dy[dir];\n            while (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                if (board[nx][ny] == '.') {\n                    board[nx][ny] = 'x';\n                }\n                nx += dx[dir];\n                ny += dy[dir];\n            }\n        }\n    } else if (type == \"edge_no\") {\n        n = 50;\n        board.resize(n, string(n, '.'));\n        board[0][0] = 'o';\n        board[0][1] = 'o';\n        board[n-1][n-1] = 'x';\n    } else {\n        n = rnd.next(1, 50);\n        board.resize(n, string(n, '.'));\n        int num_pieces = rnd.next(1, n);\n        for (int k = 0; k < num_pieces; ++k) {\n            int x, y;\n            x = rnd.next(0, n-1);\n            y = rnd.next(0, n-1);\n            board[x][y] = 'o';\n        }\n    }\n\n    // Output the board\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", board[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal_yes\n./gen -n 2 -type minimal_yes\n./gen -n 1 -type minimal_no\n./gen -n 2 -type minimal_no\n./gen -n 5 -type rook\n./gen -n 5 -type bishop\n./gen -n 5 -type knight\n./gen -n 5 -type queen\n./gen -n 10 -type rook\n./gen -n 10 -type bishop\n./gen -n 10 -type knight\n./gen -n 10 -type queen\n./gen -n 15 -type rook\n./gen -n 15 -type bishop\n./gen -n 15 -type knight\n./gen -n 15 -type queen\n./gen -n 20 -type random_yes\n./gen -n 20 -type random_no\n./gen -n 25 -type random_yes\n./gen -n 25 -type random_no\n./gen -n 30 -type random_yes\n./gen -n 30 -type random_no\n./gen -n 40 -type rook\n./gen -n 40 -type bishop\n./gen -n 40 -type knight\n./gen -n 40 -type queen\n./gen -n 50 -type edge_yes\n./gen -n 50 -type edge_no\n./gen -n 50 -type random_yes\n./gen -n 50 -type random_no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:23.224330",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/E",
      "title": "E. Demiurges Play Again",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n — the number of nodes in the tree (1 ≤ n ≤ 2·105).Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n) — the ends of the edge of the tree; the edge leads from node ui to node vi. It is guaranteed that the described graph is a rooted tree, and the root is the node 1.",
      "output_spec": "OutputPrint two space-separated integers — the maximum possible and the minimum possible result of the game.",
      "sample_tests": "ExamplesInputCopy51 21 32 42 5OutputCopy3 2InputCopy61 21 33 41 55 6OutputCopy3 3",
      "description": "E. Demiurges Play Again\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n — the number of nodes in the tree (1 ≤ n ≤ 2·105).Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n) — the ends of the edge of the tree; the edge leads from node ui to node vi. It is guaranteed that the described graph is a rooted tree, and the root is the node 1.\n\nOutputPrint two space-separated integers — the maximum possible and the minimum possible result of the game.\n\nInputCopy51 21 32 42 5OutputCopy3 2InputCopy61 21 33 41 55 6OutputCopy3 3\n\nInputCopy51 21 32 42 5\n\nOutputCopy3 2\n\nInputCopy61 21 33 41 55 6\n\nOutputCopy3 3\n\nNoteConsider the first sample. The tree contains three leaves: 3, 4 and 5. If we put the maximum number 3 at node 3, then the first player moves there and the result will be 3. On the other hand, it is easy to see that for any rearrangement the first player can guarantee the result of at least 2.In the second sample no matter what the arragment is the first player can go along the path that ends with a leaf with number 3.",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*E"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000;\n\nvector<int> graph[MAXN + 1];\nbool visited[MAXN + 1];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int child : graph[node]) {\n        if (visited[child]) {\n            ensuref(false, \"Cycle detected at node %d\", child);\n        }\n        dfs(child);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> parent(n + 1, -1);\n    for (int i = 0; i < n - 1; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(parent[vi] == -1, \"Node %d has more than one parent\", vi);\n        parent[vi] = ui;\n        graph[ui].push_back(vi);\n    }\n    ensuref(parent[1] == -1, \"Node 1 should be the root\");\n    for (int i = 2; i <= n; i++) {\n        ensuref(parent[i] != -1, \"Node %d does not have a parent\", i);\n    }\n    memset(visited, false, sizeof(visited));\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Node %d is not reachable from the root\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000;\n\nvector<int> graph[MAXN + 1];\nbool visited[MAXN + 1];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int child : graph[node]) {\n        if (visited[child]) {\n            ensuref(false, \"Cycle detected at node %d\", child);\n        }\n        dfs(child);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> parent(n + 1, -1);\n    for (int i = 0; i < n - 1; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(parent[vi] == -1, \"Node %d has more than one parent\", vi);\n        parent[vi] = ui;\n        graph[ui].push_back(vi);\n    }\n    ensuref(parent[1] == -1, \"Node 1 should be the root\");\n    for (int i = 2; i <= n; i++) {\n        ensuref(parent[i] != -1, \"Node %d does not have a parent\", i);\n    }\n    memset(visited, false, sizeof(visited));\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Node %d is not reachable from the root\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200000;\n\nvector<int> graph[MAXN + 1];\nbool visited[MAXN + 1];\n\nvoid dfs(int node) {\n    visited[node] = true;\n    for (int child : graph[node]) {\n        if (visited[child]) {\n            ensuref(false, \"Cycle detected at node %d\", child);\n        }\n        dfs(child);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> parent(n + 1, -1);\n    for (int i = 0; i < n - 1; i++) {\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readEoln();\n        ensuref(parent[vi] == -1, \"Node %d has more than one parent\", vi);\n        parent[vi] = ui;\n        graph[ui].push_back(vi);\n    }\n    ensuref(parent[1] == -1, \"Node 1 should be the root\");\n    for (int i = 2; i <= n; i++) {\n        ensuref(parent[i] != -1, \"Node %d does not have a parent\", i);\n    }\n    memset(visited, false, sizeof(visited));\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Node %d is not reachable from the root\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Tree that has degenerated into a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Tree that has degenerated into a star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Complete binary tree\n        int cnt = 2;\n        queue<int> q;\n        q.push(1);\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < 2 && cnt <= n; ++i) {\n                edges.push_back({u, cnt});\n                q.push(cnt);\n                ++cnt;\n            }\n        }\n    } else if (type == \"complete\") {\n        // Complete k-ary tree\n        int k = opt<int>(\"k\", 2); // default to binary tree\n        int cnt = 2;\n        queue<int> q;\n        q.push(1);\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < k && cnt <= n; ++i) {\n                edges.push_back({u, cnt});\n                q.push(cnt);\n                ++cnt;\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Left-skewed tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        // Optionally add branches\n        int numBranches = opt<int>(\"branches\", 0);\n        for (int i = 0; i < numBranches && i + 2 <= n; ++i) {\n            int parent = rnd.next(1, n - 1);\n            edges.push_back({parent, n++});\n        }\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle node labels, except for root node 1\n    vector<int> perm(n + 1); // Node labels from 1 to n\n    perm[0] = 0; // Unused\n    perm[1] = 1; // Root remains as 1\n    for (int i = 2; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n\n    // Relabel edges\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Tree that has degenerated into a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Tree that has degenerated into a star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Complete binary tree\n        int cnt = 2;\n        queue<int> q;\n        q.push(1);\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < 2 && cnt <= n; ++i) {\n                edges.push_back({u, cnt});\n                q.push(cnt);\n                ++cnt;\n            }\n        }\n    } else if (type == \"complete\") {\n        // Complete k-ary tree\n        int k = opt<int>(\"k\", 2); // default to binary tree\n        int cnt = 2;\n        queue<int> q;\n        q.push(1);\n        while (cnt <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = 0; i < k && cnt <= n; ++i) {\n                edges.push_back({u, cnt});\n                q.push(cnt);\n                ++cnt;\n            }\n        }\n    } else if (type == \"skewed\") {\n        // Left-skewed tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        // Optionally add branches\n        int numBranches = opt<int>(\"branches\", 0);\n        for (int i = 0; i < numBranches && i + 2 <= n; ++i) {\n            int parent = rnd.next(1, n - 1);\n            edges.push_back({parent, n++});\n        }\n    } else if (type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    } else {\n        // Default to random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({parent, i});\n        }\n    }\n\n    // Shuffle node labels, except for root node 1\n    vector<int> perm(n + 1); // Node labels from 1 to n\n    perm[0] = 0; // Unused\n    perm[1] = 1; // Root remains as 1\n    for (int i = 2; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 2, perm.end());\n\n    // Relabel edges\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n\n./gen -n 2 -type chain\n./gen -n 2 -type star\n./gen -n 2 -type random\n\n./gen -n 10 -type chain\n./gen -n 10 -type star\n./gen -n 10 -type binary\n./gen -n 10 -type random\n\n./gen -n 100 -type chain\n./gen -n 100 -type star\n./gen -n 100 -type binary\n./gen -n 100 -type random\n\n./gen -n 1000 -type chain\n./gen -n 1000 -type star\n./gen -n 1000 -type binary\n./gen -n 1000 -type random\n\n./gen -n 10000 -type chain\n./gen -n 10000 -type star\n./gen -n 10000 -type binary\n./gen -n 10000 -type random\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type binary\n./gen -n 100000 -type random\n\n./gen -n 200000 -type chain\n./gen -n 200000 -type star\n./gen -n 200000 -type binary\n./gen -n 200000 -type random\n\n# Additional test cases with varying tree types\n\n# Complete ternary tree\n./gen -n 100000 -type complete -k 3\n\n# Left-skewed tree with no branches\n./gen -n 50000 -type skewed\n\n# Left-skewed tree with branches\n./gen -n 50000 -type skewed -branches 1000\n\n# Random tree with maximal depth\n./gen -n 50000 -type chain\n\n# Random tree with minimal depth\n./gen -n 50000 -type star\n\n# Balanced binary tree\n./gen -n 65536 -type binary\n\n# Large random tree\n./gen -n 200000 -type random\n\n# Test case with minimal number of leaves\n./gen -n 100 -type chain\n\n# Test case with maximal number of leaves\n./gen -n 100 -type star\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:25.190676",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/F",
      "title": "F. A Heap of Heaps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 2·105).The second line contains n space-separated integers a1, ..., an ( - 109 ≤ ai ≤ 109).",
      "output_spec": "Outputin a single line print n - 1 integers, separate the consecutive numbers with a single space — the number of elements for which the property of the k-ary heap is violated, for k = 1, 2, ..., n - 1.",
      "sample_tests": "ExamplesInputCopy51 5 4 3 2OutputCopy3 2 1 0InputCopy62 2 2 2 2 2OutputCopy0 0 0 0 0",
      "description": "F. A Heap of Heaps\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 2·105).The second line contains n space-separated integers a1, ..., an ( - 109 ≤ ai ≤ 109).\n\nOutputin a single line print n - 1 integers, separate the consecutive numbers with a single space — the number of elements for which the property of the k-ary heap is violated, for k = 1, 2, ..., n - 1.\n\nInputCopy51 5 4 3 2OutputCopy3 2 1 0InputCopy62 2 2 2 2 2OutputCopy0 0 0 0 0\n\nInputCopy51 5 4 3 2\n\nOutputCopy3 2 1 0\n\nInputCopy62 2 2 2 2 2\n\nOutputCopy0 0 0 0 0\n\nNotePictures with the heaps for the first sample are given below; elements for which the property of the heap is violated are marked with red.     In the second sample all elements are equal, so the property holds for all pairs.",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*F"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000000000, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"value\", 0);\n        ensure(-1000000000 <= val && val <= 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int start = opt<int>(\"start\", -1000000000);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + 1LL * i * step;\n            if (a[i] > 1000000000) a[i] = 1000000000;\n            if (a[i] < -1000000000) a[i] = -1000000000;\n        }\n    } else if (type == \"decreasing\") {\n        int start = opt<int>(\"start\", 1000000000);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - 1LL * i * step;\n            if (a[i] > 1000000000) a[i] = 1000000000;\n            if (a[i] < -1000000000) a[i] = -1000000000;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = -1000000000;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"alternating\") {\n        int high = opt<int>(\"high\", 1000000000);\n        int low = opt<int>(\"low\", -1000000000);\n        ensure(-1000000000 <= low && low <= 1000000000);\n        ensure(-1000000000 <= high && high <= 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } else if (type == \"worst_case\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100, 100);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-1000000000, 1000000000);\n        }\n    } else if (type == \"equal\") {\n        int val = opt<int>(\"value\", 0);\n        ensure(-1000000000 <= val && val <= 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        int start = opt<int>(\"start\", -1000000000);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start + 1LL * i * step;\n            if (a[i] > 1000000000) a[i] = 1000000000;\n            if (a[i] < -1000000000) a[i] = -1000000000;\n        }\n    } else if (type == \"decreasing\") {\n        int start = opt<int>(\"start\", 1000000000);\n        int step = opt<int>(\"step\", 1);\n        for (int i = 0; i < n; ++i) {\n            a[i] = start - 1LL * i * step;\n            if (a[i] > 1000000000) a[i] = 1000000000;\n            if (a[i] < -1000000000) a[i] = -1000000000;\n        }\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = -1000000000;\n        }\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000;\n        }\n    } else if (type == \"alternating\") {\n        int high = opt<int>(\"high\", 1000000000);\n        int low = opt<int>(\"low\", -1000000000);\n        ensure(-1000000000 <= low && low <= 1000000000);\n        ensure(-1000000000 <= high && high <= 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? high : low;\n        }\n    } else if (type == \"worst_case\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-100, 100);\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i + 1 < n ? ' ' : '\\n');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test with n = 2\n./gen -n 2 -type random\n./gen -n 2 -type equal -value 0\n./gen -n 2 -type min\n./gen -n 2 -type max\n\n# Test with n = 10\n./gen -n 10 -type random\n./gen -n 10 -type increasing -start -10 -step 1\n./gen -n 10 -type decreasing -start 10 -step 1\n./gen -n 10 -type alternating -high 1000 -low -1000\n./gen -n 10 -type worst_case\n\n# Test with n = 1000\n./gen -n 1000 -type random\n./gen -n 1000 -type increasing -start -500 -step 1\n./gen -n 1000 -type decreasing -start 500 -step 1\n./gen -n 1000 -type alternating -high 1000000 -low -1000000\n./gen -n 1000 -type worst_case\n\n# Test with n = 100000\n./gen -n 100000 -type random\n./gen -n 100000 -type increasing -start -1000000 -step 10\n./gen -n 100000 -type decreasing -start 1000000 -step 10\n./gen -n 100000 -type alternating -high 999999999 -low -999999999\n./gen -n 100000 -type worst_case\n\n# Test with n = 200000 (maximum n)\n./gen -n 200000 -type random\n./gen -n 200000 -type increasing -start -1000000000 -step 10\n./gen -n 200000 -type decreasing -start 1000000000 -step 10\n./gen -n 200000 -type alternating -high 500000000 -low -500000000\n./gen -n 200000 -type worst_case\n\n# Additional test cases\n./gen -n 200000 -type min\n./gen -n 200000 -type max\n./gen -n 200000 -type equal -value 42\n./gen -n 200000 -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:27.175886",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/G",
      "title": "G. Осатаневший робот",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода через пробел записано два целых числа n и l (1 ≤ n ≤ 2·105, 1 ≤ l ≤ 2·106).В следующих n строках записано по три целых числа, разделенных пробелами — ti, xi, yi (1 ≤ ti ≤ 1018,  - 1018 ≤ xi, yi ≤ 1018). Показания радаров перечислены в хронологическом порядке, т.е. ti < ti + 1 для всех i от 1 до n - 1.",
      "output_spec": "Выходные данныеВыведите любую из возможных программ, согласующихся с данными. Если никакая программа не согласуется с данными, выведите одно слово «NO» (без кавычек).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 31 1 02 1 -13 0 -1Выходные данныеСкопироватьRDLВходные данныеСкопировать2 21 1 0999 1 0Выходные данныеСкопироватьRLВходные данныеСкопировать2 510 10 020 0 0Выходные данныеСкопироватьNO",
      "description": "G. Осатаневший робот\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода через пробел записано два целых числа n и l (1 ≤ n ≤ 2·105, 1 ≤ l ≤ 2·106).В следующих n строках записано по три целых числа, разделенных пробелами — ti, xi, yi (1 ≤ ti ≤ 1018,  - 1018 ≤ xi, yi ≤ 1018). Показания радаров перечислены в хронологическом порядке, т.е. ti < ti + 1 для всех i от 1 до n - 1.\n\nВходные данные\n\nВыходные данныеВыведите любую из возможных программ, согласующихся с данными. Если никакая программа не согласуется с данными, выведите одно слово «NO» (без кавычек).\n\nВыходные данные\n\nВходные данныеСкопировать3 31 1 02 1 -13 0 -1Выходные данныеСкопироватьRDLВходные данныеСкопировать2 21 1 0999 1 0Выходные данныеСкопироватьRLВходные данныеСкопировать2 510 10 020 0 0Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать3 31 1 02 1 -13 0 -1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьRDL\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 21 1 0999 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьRL\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 510 10 020 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces",
          "content": "Привет, Codeforces!В воскресенье, 26-го апреля в 19:00 MSK состоится 300-ый регулярный раунд Codeforces.Я поздравляю всех членов и администрацию Codeforces с этой замечательной цифрой. С момента создания платформа стала гораздо больше и круче, провела множество соревнований и предоставила возможность любому интересующемуся человеку прокачаться в знании алгоритмов и решении сложных задач. За это мы благодарим создателя платформы Codeforces MikeMirzayanov и всю команду Codeforces. Жгите дальше!Я рад объявить, что задачи трехсотого юбилейного раунда составил я, Михаил Тихомиров (Endagorion). Возможно, вы помните прошлые раунды на моих задачах: #99, #109, #265, #283 и (частично) #295. Хочу поблагодарить координатора задач Codeforces Макса Ахмедова (Zlobober) за помощь в подготовке этого раунда и Марии Беловой (Delinur) за перевод условия на английский. Отдельное спасибо Владиславу Исенбаеву (winger), Александру Фетисову (AlexFetisov) и Павлу Кунявскому (PavelKunyavskiy) за тестирование задач и помощь в подготовке.Раунд будет общим для обоих дивизионов и продлится два с половиной часа (как видно на странице Соревнования). В раунде будет несколько ( ≥ 6) задач, разнообразных по сложности и направленности. Надеюсь, каждый найдет задачу как раз для себя! Разбалловка будет объявлена позже.В раунде будет разыграно 30 эксклюзивных футболок Codeforces. Футболки получат первые 15 участников по результатам раунда; кроме этого, среди остальных участников, вошедших в первые 300, мы выберем 15 случайным образом и наградим их тоже. Так что даже если вы слабо верите в то, что попадете в число самых лучших, ваши шансы на получение слонов все равно не так уж и плохи. =)Такие дела. Приходите посоревноваться ради призов и ради удовольствия!UPD: в контесте будет 8 задач. Разбалловка стандартная (не динамическая): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. Для определения людей, получающих футболки, будет использован следующий код на python3.4, который вы можете самостоятельно запустить во вкладке \"запуск\" на Codeforces. В качестве сида для инициализации генератора случайных чисел используется число, которое будет равно номеру последнего сданного во время контеста решения. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Спасибо за участие!Поздравляем победителей: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul Список мест, которые выигрывают футболки: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. Вот счастливчики, занявшие эти места: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (поделили 40-е место, поэтому каждый получает по футболке), piob, Leo_Yu, matrix & Nerevar (поделили 75-ое место), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (поделили 243-е место) и Solaris (пишите мне, если найдете ошибки). Поздравляем!UPD4: и наконец-то появился разбор (пока что только на английском, перевод будет позже).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3301
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*G"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 6",
          "code": "long long a = (Days[i].second - Days[i - 1].second + ...) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 7",
          "code": "long long a = (Days[i].second - Days[i - 1].second + ...) / 2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 8",
          "code": "if (a + Days[i - 1].second > ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 9",
          "code": "if (a + Days[i - 1].second > ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 10",
          "code": "if (Days.back().second + n - Days.back().first > ans)\n        ans = Days.back().second + n - Days.back().first > ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 11",
          "code": "if (Days.back().second + n - Days.back().first > ans)\n        ans = Days.back().second + n - Days.back().first > ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 12",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 13",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 14",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 15",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 16",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 17",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 18",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 19",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 20",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 21",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 22",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 23",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 24",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 25",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (с призами!) - Codeforces - Code 26",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 2000000, \"l\");\n    inf.readEoln();\n\n    long long last_ti = 0;\n    for (int i = 0; i < n; i++) {\n        long long ti = inf.readLong(1LL, 1000000000000000000LL, \"ti\");\n        ensuref(ti > last_ti, \"ti[%d]=%lld must be greater than previous ti=%lld\", i + 1, ti, last_ti);\n        last_ti = ti;\n\n        inf.readSpace();\n\n        long long xi = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"xi\");\n\n        inf.readSpace();\n\n        long long yi = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"yi\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 2000000, \"l\");\n    inf.readEoln();\n\n    long long last_ti = 0;\n    for (int i = 0; i < n; i++) {\n        long long ti = inf.readLong(1LL, 1000000000000000000LL, \"ti\");\n        ensuref(ti > last_ti, \"ti[%d]=%lld must be greater than previous ti=%lld\", i + 1, ti, last_ti);\n        last_ti = ti;\n\n        inf.readSpace();\n\n        long long xi = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"xi\");\n\n        inf.readSpace();\n\n        long long yi = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"yi\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int l = inf.readInt(1, 2000000, \"l\");\n    inf.readEoln();\n\n    long long last_ti = 0;\n    for (int i = 0; i < n; i++) {\n        long long ti = inf.readLong(1LL, 1000000000000000000LL, \"ti\");\n        ensuref(ti > last_ti, \"ti[%d]=%lld must be greater than previous ti=%lld\", i + 1, ti, last_ti);\n        last_ti = ti;\n\n        inf.readSpace();\n\n        long long xi = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"xi\");\n\n        inf.readSpace();\n\n        long long yi = inf.readLong(-1000000000000000000LL, 1000000000000000000LL, \"yi\");\n\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We will implement a custom checker because there can be multiple valid programs.\n//\n// The official solution (\"ans\") may be either \"NO\" or a string of length l (with characters in {U, D, L, R}).\n// The participant's solution (\"ouf\") must either be \"NO\" or a similar string.\n//\n// If the official solution is \"NO\" but the participant's solution is valid, we must report _fail\n// (because that means the jury's solution was incorrect).\n// If the official solution is a valid program but the participant writes \"NO\" or an incorrect program,\n// we report _wa.\n// If both solutions are valid (or both say \"NO\"), we report _ok.\n//\n// We check a given program by simulating (in O(l)) the single cycle's net displacement and\n// partial prefix displacements, and then validating that for each time t_i, the position matches (x_i, y_i).\n// We must handle big times (up to 1e18) carefully, using 128-bit intermediate arithmetic to avoid overflow.\n\nstatic const long long INF64 = (long long)1e18;\nstatic const __int128 LIMIT = 2LL * 1000000000000000000LL; // safety bound, somewhat above 1e18\n\n// Store the radar data\nstatic int n;\nstatic long long l;\nstatic vector<long long> T, X, Y; // times and positions\n\n// Read the problem input from the checker input stream.\nvoid readProblemInput() {\n    n = inf.readInt();\n    l = inf.readLong();\n    T.resize(n);\n    X.resize(n);\n    Y.resize(n);\n    for(int i = 0; i < n; i++){\n        T[i] = inf.readLong();  // t_i\n        X[i] = inf.readLong();  // x_i\n        Y[i] = inf.readLong();  // y_i\n    }\n}\n\n// Compute the displacement for a single character command.\npair<long long, long long> moveDelta(char c) {\n    switch(c) {\n        case 'U': return make_pair(0LL, 1LL);\n        case 'D': return make_pair(0LL, -1LL);\n        case 'L': return make_pair(-1LL, 0LL);\n        case 'R': return make_pair(1LL, 0LL);\n    }\n    // If invalid character (shouldn't happen if we are checking carefully),\n    // we'll handle in the checker logic before calling this function.\n    return make_pair(0LL, 0LL);\n}\n\n// Safely compute net * cycleCount + partialPrefix, returning a sentinel if it overflows\n// beyond a large safe bound. We only need to check correctness relative to the needed data\n// (which must match up to +/-1e18), but we'll use a bigger bound to detect overflow.\nlong long safeCompute(long long net, long long cycleCount, long long prefix) {\n    __int128 tmp = ( __int128 ) net * ( __int128 ) cycleCount + ( __int128 ) prefix;\n    // If out of some \"safe\" range, return a sentinel\n    if (tmp < -LIMIT || tmp > LIMIT) {\n        // This is effectively an overflow or out-of-range sentinel\n        return LLONG_MIN; \n    }\n    return (long long) tmp;\n}\n\n// Check if a claimed program of length l is valid: for each (t_i, x_i, y_i),\n// we must ensure that if the robot repeats this program starting at (0,0) at time=0,\n// it arrives at (x_i, y_i) at time t_i.\nbool checkSolution(const string &sol) {\n    // Must have length == l\n    if ((long long)sol.size() != l) return false;\n    // Must contain only {U, D, L, R}\n    for (char c: sol) {\n        if (c != 'U' && c != 'D' && c != 'L' && c != 'R') {\n            return false;\n        }\n    }\n\n    // Precompute prefix displacements for one cycle\n    // prefix[i] = position after i moves (i from 0..l), prefix[0] = (0,0).\n    vector<long long> px(l+1, 0LL), py(l+1, 0LL);\n    for(int i = 0; i < (int)l; i++){\n        auto d = moveDelta(sol[i]);\n        px[i+1] = px[i] + d.first;\n        py[i+1] = py[i] + d.second;\n    }\n    // net displacement after one full cycle\n    long long netX = px[l];\n    long long netY = py[l];\n\n    // Check all radar data\n    for(int i = 0; i < n; i++) {\n        long long timeVal = T[i];\n        long long xVal = X[i];\n        long long yVal = Y[i];\n\n        // The robot's position at timeVal is:\n        // (netX * (timeVal // l) + px[timeVal % l],\n        //  netY * (timeVal // l) + py[timeVal % l])\n        long long cycles = (long long)(timeVal / l);\n        long long r = (long long)(timeVal % l);\n\n        // compute xPos\n        long long computedX = safeCompute(netX, cycles, px[r]);\n        if (computedX == LLONG_MIN) return false; // overflow sentinel\n        // compute yPos\n        long long computedY = safeCompute(netY, cycles, py[r]);\n        if (computedY == LLONG_MIN) return false; // overflow sentinel\n\n        // compare\n        if (computedX != xVal || computedY != yVal) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main(int argc, char* argv[]){\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read problem input from the test file\n    readProblemInput();\n\n    // 2) Read the official solution from ans\n    //    It is either \"NO\" or a single token representing the program\n    string jurySol = ans.readToken();\n\n    bool juryNo = (jurySol == \"NO\");\n    bool jurySolValid = false; // will store if the jury's solution string is valid\n\n    if (!juryNo) {\n        // The jury's solution claims to be a program, check it:\n        jurySolValid = checkSolution(jurySol);\n        if (!jurySolValid) {\n            ans.quitf(_fail, \"Jury's solution is invalid.\");\n        }\n    }\n\n    // 3) Read participant's solution from ouf\n    string partSol = ouf.readToken();\n    bool partNo = (partSol == \"NO\");\n    bool partSolValid = false;\n\n    if (!partNo) {\n        // The participant solution claims to be a program\n        partSolValid = checkSolution(partSol);\n    }\n\n    // 4) Compare solutions and decide verdict\n    // If jury says \"NO\" but participant has a valid solution -> _fail\n    if (juryNo) {\n        if (partNo) {\n            // Both say NO -> OK\n            quitf(_ok, \"Both solutions say NO.\");\n        } else {\n            // Jury says NO, participant has a program\n            if (partSolValid) {\n                // participant found a valid solution => jury is wrong\n                quitf(_fail, \"Jury's solution is NO, but participant's solution is valid.\");\n            } else {\n                // participant's solution is invalid -> WA\n                quitf(_wa, \"Jury's solution is NO, participant's solution is invalid anyway.\");\n            }\n        }\n    } else {\n        // Jury's solution is valid program\n        if (partNo) {\n            // participant says NO => WA\n            quitf(_wa, \"Jury has a valid solution but participant says NO.\");\n        } else {\n            // participant has a program\n            if (!partSolValid) {\n                // invalid => WA\n                quitf(_wa, \"Participant's program does not match the given data.\");\n            } else {\n                // valid => OK\n                quitf(_ok, \"Participant's program is valid.\");\n            }\n        }\n    }\n\n    // We should never get here\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    long long max_t = opt<long long>(\"max_t\", 1e18);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random S of length l\n        string S = \"\";\n        for(int i = 0; i < l; ++i) {\n            int dir = rnd.next(4);\n            switch(dir) {\n                case 0: S += 'U'; break;\n                case 1: S += 'D'; break;\n                case 2: S += 'L'; break;\n                case 3: S += 'R'; break;\n            }\n        }\n\n        // Precompute cumulative sums\n        vector<long long> cum_dx(l+1, 0);\n        vector<long long> cum_dy(l+1, 0);\n        long long sum_dx = 0;\n        long long sum_dy = 0;\n\n        for(int i = 0; i < l; ++i) {\n            char c = S[i];\n            int dx = 0, dy = 0;\n            if (c == 'U') dy = 1;\n            else if (c == 'D') dy = -1;\n            else if (c == 'L') dx = -1;\n            else if (c == 'R') dx = 1;\n            cum_dx[i+1] = cum_dx[i] + dx;\n            cum_dy[i+1] = cum_dy[i] + dy;\n            sum_dx += dx;\n            sum_dy += dy;\n        }\n\n        // Generate n random times t_i\n        vector<long long> t(n);\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1LL, max_t);\n        }\n        sort(t.begin(), t.end());\n\n        // For each t_i, compute x_i, y_i\n        vector<long long> x(n), y(n);\n        for(int i = 0; i < n; ++i) {\n            long long k = t[i] / l;\n            int m = t[i] % l;\n            x[i] = k * sum_dx + cum_dx[m];\n            y[i] = k * sum_dy + cum_dy[m];\n        }\n\n        // Output n and l\n        printf(\"%d %d\\n\", n, l);\n        // Output n lines of t_i x_i y_i\n        for(int i = 0; i < n; ++i) {\n            printf(\"%lld %lld %lld\\n\", t[i], x[i], y[i]);\n        }\n    } else if (type == \"no_solution\") {\n        // Output a test case where there is no solution\n        // Let's pick n=2, l=2\n        int n_no = 2;\n        int l_no = 2;\n        printf(\"%d %d\\n\", n_no, l_no);\n        printf(\"1 1 0\\n\"); // At time 1, position (1,0)\n        printf(\"2 0 1\\n\"); // At time 2, position (0,1)\n    } else if (type == \"max_size\") {\n        n = 200000;\n        l = 2000000;\n        // Generate random S of length l\n        string S = \"\";\n        for(int i = 0; i < l; ++i) {\n            int dir = rnd.next(4);\n            switch(dir) {\n                case 0: S += 'U'; break;\n                case 1: S += 'D'; break;\n                case 2: S += 'L'; break;\n                case 3: S += 'R'; break;\n            }\n        }\n\n        // Precompute cumulative sums\n        vector<long long> cum_dx(l+1, 0);\n        vector<long long> cum_dy(l+1, 0);\n        long long sum_dx = 0;\n        long long sum_dy = 0;\n\n        for(int i = 0; i < l; ++i) {\n            char c = S[i];\n            int dx = 0, dy = 0;\n            if (c == 'U') dy = 1;\n            else if (c == 'D') dy = -1;\n            else if (c == 'L') dx = -1;\n            else if (c == 'R') dx = 1;\n            cum_dx[i+1] = cum_dx[i] + dx;\n            cum_dy[i+1] = cum_dy[i] + dy;\n            sum_dx += dx;\n            sum_dy += dy;\n        }\n\n        // Generate n random times t_i\n        vector<long long> t(n);\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1LL, max_t);\n        }\n        sort(t.begin(), t.end());\n\n        // For each t_i, compute x_i, y_i\n        vector<long long> x(n), y(n);\n        for(int i = 0; i < n; ++i) {\n            long long k = t[i] / l;\n            int m = t[i] % l;\n            x[i] = k * sum_dx + cum_dx[m];\n            y[i] = k * sum_dy + cum_dy[m];\n        }\n\n        // Output n and l\n        printf(\"%d %d\\n\", n, l);\n        // Output n lines of t_i x_i y_i\n        for(int i = 0; i < n; ++i) {\n            printf(\"%lld %lld %lld\\n\", t[i], x[i], y[i]);\n        }\n    } else {\n        // Default to random\n        // You can add other types if needed\n        n = n;\n        l = l;\n        string S = \"\";\n        for(int i = 0; i < l; ++i) {\n            int dir = rnd.next(4);\n            switch(dir) {\n                case 0: S += 'U'; break;\n                case 1: S += 'D'; break;\n                case 2: S += 'L'; break;\n                case 3: S += 'R'; break;\n            }\n        }\n\n        // Precompute cumulative sums\n        vector<long long> cum_dx(l+1, 0);\n        vector<long long> cum_dy(l+1, 0);\n        long long sum_dx = 0;\n        long long sum_dy = 0;\n\n        for(int i = 0; i < l; ++i) {\n            char c = S[i];\n            int dx = 0, dy = 0;\n            if (c == 'U') dy = 1;\n            else if (c == 'D') dy = -1;\n            else if (c == 'L') dx = -1;\n            else if (c == 'R') dx = 1;\n            cum_dx[i+1] = cum_dx[i] + dx;\n            cum_dy[i+1] = cum_dy[i] + dy;\n            sum_dx += dx;\n            sum_dy += dy;\n        }\n\n        // Generate n random times t_i\n        vector<long long> t(n);\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1LL, max_t);\n        }\n        sort(t.begin(), t.end());\n\n        // For each t_i, compute x_i, y_i\n        vector<long long> x(n), y(n);\n        for(int i = 0; i < n; ++i) {\n            long long k = t[i] / l;\n            int m = t[i] % l;\n            x[i] = k * sum_dx + cum_dx[m];\n            y[i] = k * sum_dy + cum_dy[m];\n        }\n\n        // Output n and l\n        printf(\"%d %d\\n\", n, l);\n        // Output n lines of t_i x_i y_i\n        for(int i = 0; i < n; ++i) {\n            printf(\"%lld %lld %lld\\n\", t[i], x[i], y[i]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    long long max_t = opt<long long>(\"max_t\", 1e18);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        // Generate random S of length l\n        string S = \"\";\n        for(int i = 0; i < l; ++i) {\n            int dir = rnd.next(4);\n            switch(dir) {\n                case 0: S += 'U'; break;\n                case 1: S += 'D'; break;\n                case 2: S += 'L'; break;\n                case 3: S += 'R'; break;\n            }\n        }\n\n        // Precompute cumulative sums\n        vector<long long> cum_dx(l+1, 0);\n        vector<long long> cum_dy(l+1, 0);\n        long long sum_dx = 0;\n        long long sum_dy = 0;\n\n        for(int i = 0; i < l; ++i) {\n            char c = S[i];\n            int dx = 0, dy = 0;\n            if (c == 'U') dy = 1;\n            else if (c == 'D') dy = -1;\n            else if (c == 'L') dx = -1;\n            else if (c == 'R') dx = 1;\n            cum_dx[i+1] = cum_dx[i] + dx;\n            cum_dy[i+1] = cum_dy[i] + dy;\n            sum_dx += dx;\n            sum_dy += dy;\n        }\n\n        // Generate n random times t_i\n        vector<long long> t(n);\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1LL, max_t);\n        }\n        sort(t.begin(), t.end());\n\n        // For each t_i, compute x_i, y_i\n        vector<long long> x(n), y(n);\n        for(int i = 0; i < n; ++i) {\n            long long k = t[i] / l;\n            int m = t[i] % l;\n            x[i] = k * sum_dx + cum_dx[m];\n            y[i] = k * sum_dy + cum_dy[m];\n        }\n\n        // Output n and l\n        printf(\"%d %d\\n\", n, l);\n        // Output n lines of t_i x_i y_i\n        for(int i = 0; i < n; ++i) {\n            printf(\"%lld %lld %lld\\n\", t[i], x[i], y[i]);\n        }\n    } else if (type == \"no_solution\") {\n        // Output a test case where there is no solution\n        // Let's pick n=2, l=2\n        int n_no = 2;\n        int l_no = 2;\n        printf(\"%d %d\\n\", n_no, l_no);\n        printf(\"1 1 0\\n\"); // At time 1, position (1,0)\n        printf(\"2 0 1\\n\"); // At time 2, position (0,1)\n    } else if (type == \"max_size\") {\n        n = 200000;\n        l = 2000000;\n        // Generate random S of length l\n        string S = \"\";\n        for(int i = 0; i < l; ++i) {\n            int dir = rnd.next(4);\n            switch(dir) {\n                case 0: S += 'U'; break;\n                case 1: S += 'D'; break;\n                case 2: S += 'L'; break;\n                case 3: S += 'R'; break;\n            }\n        }\n\n        // Precompute cumulative sums\n        vector<long long> cum_dx(l+1, 0);\n        vector<long long> cum_dy(l+1, 0);\n        long long sum_dx = 0;\n        long long sum_dy = 0;\n\n        for(int i = 0; i < l; ++i) {\n            char c = S[i];\n            int dx = 0, dy = 0;\n            if (c == 'U') dy = 1;\n            else if (c == 'D') dy = -1;\n            else if (c == 'L') dx = -1;\n            else if (c == 'R') dx = 1;\n            cum_dx[i+1] = cum_dx[i] + dx;\n            cum_dy[i+1] = cum_dy[i] + dy;\n            sum_dx += dx;\n            sum_dy += dy;\n        }\n\n        // Generate n random times t_i\n        vector<long long> t(n);\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1LL, max_t);\n        }\n        sort(t.begin(), t.end());\n\n        // For each t_i, compute x_i, y_i\n        vector<long long> x(n), y(n);\n        for(int i = 0; i < n; ++i) {\n            long long k = t[i] / l;\n            int m = t[i] % l;\n            x[i] = k * sum_dx + cum_dx[m];\n            y[i] = k * sum_dy + cum_dy[m];\n        }\n\n        // Output n and l\n        printf(\"%d %d\\n\", n, l);\n        // Output n lines of t_i x_i y_i\n        for(int i = 0; i < n; ++i) {\n            printf(\"%lld %lld %lld\\n\", t[i], x[i], y[i]);\n        }\n    } else {\n        // Default to random\n        // You can add other types if needed\n        n = n;\n        l = l;\n        string S = \"\";\n        for(int i = 0; i < l; ++i) {\n            int dir = rnd.next(4);\n            switch(dir) {\n                case 0: S += 'U'; break;\n                case 1: S += 'D'; break;\n                case 2: S += 'L'; break;\n                case 3: S += 'R'; break;\n            }\n        }\n\n        // Precompute cumulative sums\n        vector<long long> cum_dx(l+1, 0);\n        vector<long long> cum_dy(l+1, 0);\n        long long sum_dx = 0;\n        long long sum_dy = 0;\n\n        for(int i = 0; i < l; ++i) {\n            char c = S[i];\n            int dx = 0, dy = 0;\n            if (c == 'U') dy = 1;\n            else if (c == 'D') dy = -1;\n            else if (c == 'L') dx = -1;\n            else if (c == 'R') dx = 1;\n            cum_dx[i+1] = cum_dx[i] + dx;\n            cum_dy[i+1] = cum_dy[i] + dy;\n            sum_dx += dx;\n            sum_dy += dy;\n        }\n\n        // Generate n random times t_i\n        vector<long long> t(n);\n        for(int i = 0; i < n; ++i) {\n            t[i] = rnd.next(1LL, max_t);\n        }\n        sort(t.begin(), t.end());\n\n        // For each t_i, compute x_i, y_i\n        vector<long long> x(n), y(n);\n        for(int i = 0; i < n; ++i) {\n            long long k = t[i] / l;\n            int m = t[i] % l;\n            x[i] = k * sum_dx + cum_dx[m];\n            y[i] = k * sum_dy + cum_dy[m];\n        }\n\n        // Output n and l\n        printf(\"%d %d\\n\", n, l);\n        // Output n lines of t_i x_i y_i\n        for(int i = 0; i < n; ++i) {\n            printf(\"%lld %lld %lld\\n\", t[i], x[i], y[i]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -l 1 -type random\n./gen -n 2 -l 2 -type random\n./gen -n 10 -l 10 -type random\n./gen -n 100 -l 1000 -type random\n./gen -n 1000 -l 10000 -type random\n./gen -n 10000 -l 100000 -type random\n./gen -n 100000 -l 1000000 -type random\n./gen -n 200000 -l 2000000 -type random\n\n./gen -n 5 -l 5 -type no_solution\n\n./gen -n 1000 -l 1 -type random\n./gen -n 1000 -l 2000000 -type random\n\n./gen -n 2 -l 2 -type no_solution\n\n./gen -n 1000 -l 1000 -type random -max_t 1000\n\n./gen -n 1000 -l 1000 -type random -max_t 1000000000\n\n./gen -n 1000 -l 1000 -type random -max_t 1000000000000000000\n\n./gen -n 1000 -l 1000 -type random -max_t 1000000000000\n\n./gen -n 1 -l 1 -type random\n\n./gen -n 1 -l 2000000 -type random\n\n./gen -n 200000 -l 2000000 -type random\n\n./gen -n 200000 -l 2000000 -type max_size\n\n./gen -n 200000 -l 1 -type random\n\n./gen -n 200000 -l 100000 -type random\n\n./gen -n 2 -l 1000000 -type random -max_t 1000000000000000000\n\n./gen -n 2 -l 1000000 -type random -max_t 1\n\n./gen -n 10 -l 100 -type random\n\n./gen -n 10 -l 1000000 -type random\n\n./gen -n 100000 -l 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:29.573119",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "538/H",
      "title": "H. Summer Dichotomy",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers, t and T (1 ≤ t ≤ T ≤ 109).The second line contains two space-separated integers n and m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105).The i-th of the next n lines contain integers li and ri (0 ≤ li ≤ ri ≤ 109).The next m lines describe the pairs of conflicting teachers. Each of these lines contain two space-separated integers — the indices of teachers in the pair. The teachers are indexed starting from one. It is guaranteed that no teacher has a conflict with himself and no pair of conflicting teachers occurs in the list more than once.",
      "output_spec": "OutputIf the distribution is possible, print in the first line a single word 'POSSIBLE' (without the quotes). In the second line print two space-separated integers n1 and n2 — the number of students in the first and second group, correspondingly, the contstraint t ≤ n1 + n2 ≤ T should be met. In the third line print n characters, the i-th of which should be 1 or 2, if the i-th teacher should be assigned to the first or second group, correspondingly. If there are multiple possible distributions of students and teachers in groups, you can print any of them.If the sought distribution doesn't exist, print a single word 'IMPOSSIBLE' (without the quotes).",
      "sample_tests": "ExamplesInputCopy10 203 03 64 916 25OutputCopyPOSSIBLE4 16112InputCopy1 103 30 100 100 101 21 32 3OutputCopyIMPOSSIBLE",
      "description": "H. Summer Dichotomy\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers, t and T (1 ≤ t ≤ T ≤ 109).The second line contains two space-separated integers n and m (1 ≤ n ≤ 105, 0 ≤ m ≤ 105).The i-th of the next n lines contain integers li and ri (0 ≤ li ≤ ri ≤ 109).The next m lines describe the pairs of conflicting teachers. Each of these lines contain two space-separated integers — the indices of teachers in the pair. The teachers are indexed starting from one. It is guaranteed that no teacher has a conflict with himself and no pair of conflicting teachers occurs in the list more than once.\n\nOutputIf the distribution is possible, print in the first line a single word 'POSSIBLE' (without the quotes). In the second line print two space-separated integers n1 and n2 — the number of students in the first and second group, correspondingly, the contstraint t ≤ n1 + n2 ≤ T should be met. In the third line print n characters, the i-th of which should be 1 or 2, if the i-th teacher should be assigned to the first or second group, correspondingly. If there are multiple possible distributions of students and teachers in groups, you can print any of them.If the sought distribution doesn't exist, print a single word 'IMPOSSIBLE' (without the quotes).\n\nInputCopy10 203 03 64 916 25OutputCopyPOSSIBLE4 16112InputCopy1 103 30 100 100 101 21 32 3OutputCopyIMPOSSIBLE\n\nInputCopy10 203 03 64 916 25\n\nOutputCopyPOSSIBLE4 16112\n\nInputCopy1 103 30 100 100 101 21 32 3\n\nOutputCopyIMPOSSIBLE",
      "solutions": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces",
          "content": "Hello, Codeforces!On Sunday, April 26th at 19:00 MSK the 300'th regular Codeforces Round will take place.I would like to congratulate all Codeforces members and administration on this remarkable milestone. The platform has grown hugely in size and quality since its foundation, has hosted lots of exciting competitions, and has been providing the opportunity to everyone to hone their problem solving and algorithmic mastery. For this we thank the Codeforces platform creator MikeMirzayanov and all the Codeforces crew. Keep up the incredible job, guys!That being said, I'm excited to announce that the problems on the jubilee three-hundredth Codeforces Round will be set by me, Mikhail Tikhomirov (Endagorion). You may remember the past rounds with my problems: #99, #109, #265, #283, and (in part) #295. I thank the Codeforces problems coordinator Max Akhmedov (Zlobober) for helping me in preparing this round, and Maria Belova Delinur for translating the statements in English. Also, special gratitude to Vladislav Isenbaev (winger), Alex Fetisov (AlexFetisov) and Pavel Kunyavskiy (PavelKunyavskiy) for testing the problemset and help with preparation.This round will be shared for both divisions and will last two hours and a half (as you can see at the Contests page). The round will feature several ( ≥ 6) problems, varying in difficulty and topics involved. I hope that everyone will find an interesting and satisfying problem just for themselves! The scoring will be announced later.To add up to the excitement, there are 30 exclusive Codeforces T-shirts to compete for in this round! The top 15 participants will get their T-shirts right away; another 15 will be randomly distributed among those who place in the top 300. Even if you think your chances on being the very best are weak, there are still good odds you will get a treat! =)That's it. Mark your calendars and come back to compete for the prizes and for the fun!UPD: there will be 8 problems. The scoring is standard (i.e. not dynamic): 500-1000-1500-1500-2000-2500-3000-3000.UPD2. In order to choose people getting T-Shirts we will use the following python3.4 code that you can manually run in \"custom invocation\" tab on Codeforces. It uses an integer as a seed for random generator, this integer should be equal to the last submission number that happened during the contest. import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n print(x)\nUPD3: Thanks for participating!The winners are: bmerry Egor Petr rng_58 scott_wu jqdai0815 eatmore atetubou qwerty787788 niyaznigmatul The list of places getting the T-shirts are 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269. The lucky participants are as follows: bmerry, Egor, Petr, rng_58, scott_wu, jqdai0815, eatmore, atetubou, qwerty787788, niyaznigmatul, gs12117, W4yneb0t, JoeyWheeler, zxqfl, yeputons, kcm1700 & HYPERHYPERHYPERCUBELOVER (sharing the 40-th place, so both get a T-shirt), piob, Leo_Yu, matrix & Nerevar (sharing the 75-th place), Haghani, ACube, DemiGuo, etal, Emarci15, hlwt, Salvare001, dzy97, FatalEagle, gchebanov & Jimanbanashi (sharing the 243-rd place), and Solaris (please let me know about any mistakes). Congratulations!UPD4: At long last, the editorial is up! Enjoy, and sorry for the waiting.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17548",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3459
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces",
          "content": "As usual, a challenge comes with every problem. I tried not to repeat the mistakes of my previous editorials and made sure that all challenges have a solution =) (except for the italics parts that are open questions, at least for me). Go ahead and discuss them in the comments! General questions about problems and clarification requests are welcomed too.UPD: I added codes of my solutions for all the problems. I didn't try to make them readable, but I believe most part of them should be clear. Feel free to ask questions.538A - Cutting BannerLet me first clarify the statement (I really wish I didn't have to do that but it seems many participants had trouble with the correct understanding). You had to erase exactly one substring from the given string so that the rest part would form the word CODEFORCES. The (somewhat vague) wording some substring in the English translation may be the case many people thought that many substrings can be erased; still, it is beyond my understanding how to interpret that as 'more than one substring'. Anyway, I'm sorry for the inconvenience.Right, back to the problem. The most straightforward approach is to try over all substrings (i.e. all starting and ending positions) to erase them and check if the rest is the wanted word. When doing this, you have to be careful not to forget any corner cases, such as: erase few first letters, erase few last letters, erase a single letter, and so on. A popular question was if an empty substring may be erased or not. While it is not clarified explicitly in the statement, the question is irrelevant to the solution, for it is guaranteed in the statement that the initial string is not CODEFORCES, so erasing nothing will not make us happy. From the technical point of view, you could erase a substring from the string using standard functions like substr in C++ or similar, or do some bare-hands work and perform conditional iterating over all symbols. Depending on the implementation, this would be either O(n2) or O(n3) solution; both of these fit nicely.One way of solving this in linear time is to compute the longest common prefix and suffix for the given string and the string CODEFORCES. If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good. If the total length is less than 10, no such way exists. This is clearly O(n) solution (rather O(n) for reading the input, and O(|t|) for comparisons where t is CODEFORCES in our case).Sample solution: 10973831Challenge (easy). A somewhat traditional question: how many (modulo some prime number) large Latin letter strings of length n have the property that a (non-empty) substring may be cut out to leave a given string t? Can you solve it in O(n + |t|2) time? In O(n + |t|) time? Maybe even faster? =)538B - Quasi Binaryn is up to 106. We may note that there are only 26 + 1 = 65 quasi-binary numbers not exceeding 106, so we could find them all and implement a DP solution that counts the optimal representation for all numbers up to n, or even a brute-force recursive solution (which is not guaranteed to pass, but has a good odds).Are there more effective solutions? Sure enough. First of all, one can notice that the number of summands in a representation can not be less than d — the largest digit in decimal representation of n. That is true because upon adding a quasi-binary number to any number the largest digit may not increase by more than 1 (easy enough to prove using the standard algorithm for adding numbers). On the other hand, d quasi-binary numbers are always enough. To see that, construct a number m as follows: for every digit of n that is not 0, place 1 in the corresponding digit of m, and for all the other digits place 0. Clearly, m is quasi-binary. If we subtract m from n, all non-zero digits will decrease by 1 (clearly, no carrying will take place), thus the largest digit of n - m will be equal to d - 1. Proceeding this way, we end up with the representation of n as a sum of d quasi-binary numbers. This solution is good for every numeric base, and works in where d is the base.Sample solution: 10973842Challenge (easy). Let us call a number pseudo-binary if its decimal representation contains at most two different digits (e.g., 1, 555, 23, 9099 are pseudo-binary, while 103, 908 and 12345 are not). Represent an integer n as a sum of pseudo-binary numbers; minimize the number of summands. n ≤ 1018.538C - Tourist's NotesWe want to make the maximum height as large as possible. Consider the part of the chain that was travelled between di and di + 1; we can arrange it in any valid way independently of any other parts of the chain, thus we consider all these parts separately. There also parts before d1 and after dn, but it is fairly easy to analyze them: make them monotonously decreasing (respectively, increasing), as this maximizes the top point.Without the loss of generality consider di = 0 and di + 1 = t (they may be increased of decreased simultaneously without changing the answer), and hdi = a, hdi + 1 = b. Clearly, in consistent data |a - b| ≤ t, so if this condition fails for a single pair of adjacent entries, we conclude the data is flawed.If the condition holds, it is fairly easy to construct a valid way to move between the days under the |hi - hi + 1| ≤ 1 condition: increase or decrease the height while it differs from b, than stay on the same height. That does not make the optimal way, but at least we are sure that the data is not inconsistent.How to construct the optimal arrangement? From the adjacent difference inequality if follows that for any i between 0 and t the inequalities hi ≤ a + i and hi ≤ b + (t - i) hold. Let hi = min(a + i, b + (t - i)) on the [0; t] segment; clearly, every hi accomodates the largest possible value, therefore the value of maximum is also the largest possible. It suffices to show that these hi satisfy the difference condition. Basically, two cases should be considered: if for hi = a + i and hi + 1 = a + i + 1, or hi = b + (t - i) and hi + 1 = b + (t - i - 1), the statement is obvious. Else, hi = a + i but hi < b + (t - i) = hi + 1 + 1, and hi + 1 = b - (t - i - 1) but hi + 1 < a + (i + 1) = hi + 1. Thus, |hi - hi + 1| < 1, and hi = hi + 1.To find the maximum value of maximum height (I really struggle not to use 'maximum maximum') we may either use ternary search on the h function, or find the point where lines a + i and b + (t - i) intersect and try integer points besides the intersection. If we use this approach analytically, we arrive at the formula (t + a + b) / 2 (try to prove that yourself!).Sample solution: 10973854Challenge (medium). Given the same data (that is, a subsequence hdi for a sequence hi), determine how many (modulo a prime number) integer sequences of length n with the property |hi - hi + 1| ≤ 1 agree with the subsequence and have global maximum equal to H? Can you solve the problem in O(n2) time? In time? Maybe even faster?538D - Weird ChessInstead of trying to find out where the piece may go, let's try to find out where it can not go. Initially mark all the moves as possible; if there is a field (x1, y1) containing a piece, and a field (x2, y2) not containing a piece and not being attacked, clearly a move (x2 - x1, y2 - y1) is not possible. Let us iterate over all pieces and over all non-attacked fields and mark the corresponding moves as impossible.Suppose we let our piece make all the rest moves (that are not yet marked as impossible), and recreate the position with all the pieces in the same places. If a field was not attacked in the initial position, it will not be attacked in the newly-crafted position: indeed, we have carefully removed all the moves that could take a piece to this field. Thus, the only possible problem with the new position is that some field that was attacked before is not attacked now. But our set of moves is maximal in the sense that adding any other move to it will cause the position to be incorrect. Thus, if the new position doesn't coincide with the initial position, the reconstruction is impossible. Else, we have already obtained a correct set of moves. This solution has complexity of O(n4) for iterating over all pieces and non-attacked fields. No optimizations were needed to make solution this pass.Sample solution: 10973859Challenge (medium). Solve the same problem in time.538E - Demiurges Play AgainWith such large constraints our only hope is the subtree dynamic programming. Let us analyze the situation and how the subtrees are involved.Denote w(v) the number of leaves in the subtree of v. Suppose that a non-leaf vertex v has children u1, ..., uk, and the numbers to arrange in the leaves are 1, ..., w(v). We are not yet sure how to arrange the numbers but we assume for now that we know everything we need about the children's subtrees.Okay, what is the maximal number we can achieve if the maximizing player moves first? Clearly, he will choose the subtree optimally for himself, and we are eager to help him. Thus, it makes sense to put all the maximal numbers in a single subtree; indeed, if any of the maximal numbers is not in the subtree where the first player will go, we swap it with some of the not-so-maximal numbers and make the situation even better. If we place w(ui) maximal numbers (that is, w(v) - w(ui) + 1, ..., w(v)) in the subtree of w(ui), we must also arrange them optimally; this task is basically the same as arranging the numbers from 1 to w(ui) in the subtree of w(ui), but now the minimizing player goes first. Introduce the notation for the maximal possible result if the maximizing/minimizing (depending on the lower index) player starts. From the previous discussion we obtain . Thus, if we know for all children, the value of can be determined.How does the situation change when the minimizing player goes first? Suppose that for each i we assign numbers n1, 1, ..., n1, w(ui) to the leaves of the subtree of ui in some order; the numbers in the subtree of ui will be arranged so that the result is maximal when the maximizing player starts in ui. Suppose that numbers ni, j are sorted by increasing of j for every i; the minimizing player will then choose the subtree ui in such a way that is minimal. For every arrangement, the minimizing player can guarantee himself the result of at most . Indeed, if all the numbers are greater than r, all the numbers ni, j for should also be greater than r; but there are numbers ni, j that should be greater than r, while there are only w(v) - r possible numbers from 1 to w(v) to place; a contradiction (pigeonhole principle). On the other hand, the value of r is easily reachable: place all the numbers less than r as ni, j with , and r as, say, n1, dpmax(u1); the first player will have to move to u1 to achieve r. Thus, .The previous, rather formal argument can be intuitively restated as follows: suppose we put the numbers from 1 to w(v) in that order to different subtrees of v. Once a subtree of ui contains dpmax(ui) numbers, the minimizing player can go to ui and grab the current result. It follows that we may safely put dpmax(ui) - 1 numbers to the subtree of u(i) for each i, and the next number (exactly r) will be grabbed regardless of what we do (if we do not fail and let the minimizing player grab a smaller number).That DP scheme makes for an O(n) solution, as processing the k children of each node is done in O(k) (provided their results are already there). As an easy exercise, think about how the optimal arrangement of number in the leaves can be constructed; try to make implementation as simple as possible.Sample solution: 10973864Challenge (medium). Suppose that we are given numbers n, a, b, and we want to construct a tree with n leaves such that dpmax(root) = a and dpmin(root) = b. For which numbers n, a, b is this possible? (I'm sure you will like the answer for this one. =)) Can you propose an algorithm that constructs such a tree?538F - A Heap of HeapsThe first approach. For a given k and an element v, how do we count the number of children of v that violate the property? This is basically a range query 'how many numbers in the range are greater than v' (because, evidently, children of any element occupy a subsegment of the array); the answers for every k are exactly the sums of results for queries at all non-leaf vertices. Online data structures for this query type are rather involved; however, we may process the queries offline by decreasing v, with a structure that is able to support an array, change its elements and take sum over a range (e.g., Fenwick tree or segment tree). This can be done as follows: for every element of the initial array store 1 in the same place of the structure array if the element has already been processed, and 0 otherwise. Now, if we sum over the range for the element v, only processed elements will have impact on the sum, and the result of the query will be exactly the number of elements greater than v. After all the queries for v, we put 1 in the corresponding element so that queries for smaller elements would take it into account. That makes for an solution. Estimate q: notice that for a given k there are only non-leaf vertices, thus the total number of queries will be (harmonic sum estimation). To sum up, this solution works in time.Sample solution (first approach): 10973867The second approach. Let us index the elements of the array starting from 0. It is easy to check that for a given k the parent of the element av is the element . One can show that there are only different elements that can be the parent of av for some k. Indeed, if , the index of the parent is less that , and all produce no more than different parents too. Moreover, each possible parent corresponds to a range of values of k. To show that, solve the equality for k. Transform: , pk ≤ v - 1 < (p + 1)k, , . For every k in the range above the property is either violated or not (that depends only on av and ap); if it's violated we should add 1 to all the answers for k's in the range. That can be done in O(1) offline using delta-encoding (storing differences between adjacent elements in the process and prefix-summing them in the end). There will be only queries to the delta array (as this is the number of different child-parent pairs for all k). This makes for a simple solution which barely uses any heavy algorithmic knowledge at all.Sample solution (second approach): 10973868Challenge 1 (medium). Denote ck the minimal number of elements that should be changed (each to a value of your choice) so that the array becomes a valid k-ary heap. Can you find a single ck (for a given k) in time? Can you find all ck (for 1 ≤ k ≤ n - 1) at once in O(n2) time? Can you do better than these estimates?Challenge 2 (hard). Solve the problem from Challenge 1 if an arbitrary rooted tree with numbers in vertices is given (that is, change the minimal number of elements so that no element is greater than its parent). Can you do it in O(n2)? In ? In ? (I'm pretty certain my approach should work, but I would be glad if anyone could check me on this one. That being said, I'm eagerly waiting for your comments.) Not likely, but maybe you could do even better?538G - Berserk Robot First of all, we'll simplify the problem a bit. Note that after every command the values of x + y and x - y are altered by  ± 1 independently. Suppose we have a one-dimensional problem: given a sequence of x's and t's, provide a looped program of length l with commands  ± 1 which agrees with the data. If we are able to solve this problem for numbers xi + yi and xi - yi separately, we can combine the answers to obtain a correct program for the original problem; if one of the subproblems fails, no answer exists. (Most — if not all — participants who solved this problem during the contest did not use this trick and went straight ahead to the two-dimensional problem. While the idea is basically the same, I'm not going into details for their approach, but you can view the submitted codes of contestants for more info on this one.)Ok, now to solve the one-dimensional problem. Let us change the command set from  ± 1 to  + 0 /  + 1: set . If the division fails to produce an integer for some entry, we must conclude that the data is inconsistent (because xi and ti should have the same parity). Now it is clear to see that the operation  - 1 becomes operation 0, and the operation  + 1 stays as it is.A program now is a string of length l that consists of 0's and 1's. Denote si the number of 1's among the first i commands, and s = sl for simplicity. Evidently, an equation holds, because the full cycle is executed ⌊ ti / l⌋ times, and after that more first commands. From this, we deduce .Suppose that we know what s is equal to. Using this, we can compute all ; they are fixed from now on. One more important fixed value is sl = s. In any correct program si ≤ si + 1 ≤ si + 1, but not all values of si are known to us. When is it possible to fill out the rest of si to match a correct program? If sa and sb are adjacent entries that are fixed (that is, every sc under a < c < b is not fixed), the inequality 0 ≤ sb - sa ≤ b - a must hold (a and b may coincide if for different i several values of coincide). Furthermore, if the inequality holds for every pair of adjacent fixed entries, a correct program can be restored easily: move over the fixed values, and place sb - sa 1's between positions a and b in any possible way, fill with 0's all the other positions in between.The trouble is that we don't know s in advance. However, we know the positions and the order in which fixed values of sa come! Sort them by non-decreasing of a. All fixed sa can be expressed as linear functions of s; if we substitute these expressions in the 0 ≤ sb - sa ≤ b - a, from each pair of adjacent fixed values we obtain an inequality of general form 0 ≤ p·s + q ≤ d, where p, q, d are known values. If the obtained system of inequalities has a solution, we can get ourselves a valid s and restore the program as discussed above.It suffices to notice that every inequality of the system has a set of solutions of general form l ≤ s ≤ r (if the set is not empty), where l and r should be calculated carefully depending on the sign of p. All the intervals should be intersected, and the resulting interval provides a range of valid values of s.Overall, the solution works in , or even in O(n + l) if we use bucketing instead of sorting. Note that the l summand in the complexity is only there for the actual program reconstruction; if we were only to check the existence of a program, an O(n) solution would be possible.Sample solution: 10973870Challenge (kinda hard). Under the same statement, how many (modulo a prime number) different programs agree with the given data? Assume that all elementary modulo operations (including division) take O(1) time. Can you solve this problem in O(nl)? In O(n + l)? Maybe even better (in , for example?)538H - Summer DichotomyThe problem has several possible approaches.The first approach. More popular one. Forget about t and T for a moment; we have to separate teachers into two groups so that no conflicting teachers are in the same group, and the number of students in each group can be chosen to satisfy all the teachers.Consider a connected component via the edges which correspong to conflicting pairs. If the component is not bipartite, there is clearly no valid distribution. Else, the teachers in the component can be separated into two sets such that each set should be in the same group, and the groups for the sets should be different. The teachers in the same set will always go together in the same group, so we may as well make them into a single teacher whose interval is the intersection of all the intervals for the teachers we just compressed. Now, the graph is the set of disjoint edges (for simplicity, if a teacher does not conflict with anyone, connect him with a 'fake' teacher whose interval is [0;∞]).Consider all possible distributions of students; they are given by a pair (n1, n2). Provided this distribution, in what cases a pair of conflicting teachers can be arranged correctly? If the teachers' segments are [l1, r1] and [l2, r2], either l1 ≤ n1 ≤ r1 and l2 ≤ n2 ≤ r2, or l2 ≤ n1 ≤ r2 and l1 ≤ n2 ≤ r1 must hold. Consider a coordinate plane, where a point (x, y) corresponds to a possible distribution of students. For a pair of conflicting teachers the valid configurations lie in the union of two rectangles which are given by the inequalities above. Valid configurations that satisfy all pairs of teachers lie exactly in the intersection of all these figures. Thus, the problem transformed to a (kinda) geometrical one.A classical approach to this kind of problems is to perform line-sweeping. Note that any 'union of two rectangles' figure (we'll shorten it to UOTR) is symmetrical with respect to the diagonal line x = y. It follows that for any x the intersection of the vertical line given by x with any UOTR is a subsegment of y's. When x sweeps from left to right, for any UOTR there are O(1) events when a subsegment changes. Sort the events altogether and perform the sweeping while updating the sets of subsegments' left and right ends and the subsegments intersection (which is easy to find, given the sets). Once the intersection becomes non-empty, we obtain a pair (x, y) that satisfies all the pairs of teachers; to restore the distribution is now fairly easy (don't forget that every teacher may actually be a compressed set of teachers!).Didn't we forget something? Right, there are bounds t and T to consider! Consider an adjacent set of events which occurs when x = x1 and x = x2 respectively. The intersection of subsegments for UOTRs obtained after the first event will stay the same while x1 ≤ x < x2. Suppose the y's subsegmen intersection is equal to [l;r]. If we stay within x1 ≤ x < x2, for a satisfying pair of (x, y) the minimal value of x + y is equal to x1 + l, and the maximal value is x2 + r - 1. If this range does not intersect with [t;T], no answer is produced this turn. In the other case, choose x and y while satisfying all boundaries upon x, y and x + y (consider all cases the rectangle can intersect with a 45-angle diagonal strip). Thus, the requirement of t and T does not make our life much harder.This solution can be implemented in using an efficient data structure like std::set or any self-balancing BST for sets of subsegments' ends. The very same solution can be implemented in the flavour of rectangles union problem canonical solution: represent a query 'add 1 to all the points inside UORT' with queries 'add x to all the points inside a rectangle', and find a point with the value m.Sample solution (first approach): 10973887The second approach. Less popular, and probably much more surprising.Imagine that the values of t and T are small. Introduce the set of boolean variables zi, j which correspond to the event 'ni does not exceed j' (i is either 1 or 2, j ranges from 0 to T). There are fairly obvious implication relations between them: . As t ≤ n1 + n2 ≤ T, we must also introduce implications (here i' is 1 or 2 not equal to i) because if a + b ≥ t and a ≤ j, b must be at least t - j, and for a similar reason. In this, zi, j for j < 0 clearly must be considered automatically false, and zi, j for j ≥ T must be considered automatically true (to avoid boundary fails).The last thing to consider is the teachers. For every teacher introduce a binary variable wj which corresponds to the event 'teacher j tutors the first group'. The implications and are pretty much self-explanating. A conflicting pair of teachers j and k is resolved in a straightforward way: , .If a set of values for all the boolean variables described satisfies all the restrictions, a valid distribution can be restored explicitly: n1 and n2 are maximal so that z1, n1 and z2, n2 hold, and the teachers are distributed unequivocally by values of wj. It suffices to notice that the boolean system is a 2-SAT instance, and can be solved in linear time. If we count carefully, we obtain that the whole solution has linear complexity as well: O(n + m + T).Didn't we forget something? Right! The value of T may be too much to handle Ω(T) variables explicitly. To avoid that, one may notice that the set of possible values of n1 and n2 may be reduced to 0, t, li, t - li, ri, t - ri. We can prove that by starting from any valid values of n1 and n2 and trying to make them as small as possible; the listed values are the ones we may end up with. Thus, we can only use O(n) variables instead of Ω(T). The implications can be built similarily, but using lower/upper bound on the list of possible values instead of exact values (much care is advised!). Finally, this solution can be made to work in , with the logarithmic factor from all the sorting and lower/upperbounding.Sample solution (second approach): 10973881Challenge (easy, for a change) Don't you think it's wrong that a group may be without a teacher altogether? Come up with an algorithm that finds a distribution that places at least one teacher in each group. The complexity should not become worse. How about at least k teachers in each group?Whew, wasn't it a long run! I tried to be verbose and elaborate where it was possible, hope it was worth the wait. Let me know what you think of this write-up!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17612",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 538\\s*H"
          },
          "content_length": 25490
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 1",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 2",
          "code": "import random\nseed = int(input())\nrnd = random.Random(seed)\n# all contestants except top-15\ncontestants = list(range(16, 301))\nrnd.shuffle(contestants)\ntshirts = list(range(1, 16)) + contestants[:15]\nfor x in sorted(tshirts):\n    print(x)",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 3",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 4",
          "code": "Candidate Master",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 5",
          "code": "Wrong Answer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 6",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 7",
          "code": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 40 46 67 75 80 102 103 144 152 161 169 198 233 243 269",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 8",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 9",
          "code": "ans=max(ans,h[n]+(m-x[n]-1));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 10",
          "code": "hei[i] > hei[i-1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 11",
          "code": "int ans=hei[i]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 12",
          "code": "int ans=hei[i-1]+(k-index[i-1])/2;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 13",
          "code": "ans[i] += pow(10, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 14",
          "code": "ans[i] += pow(10, cur)+0.01",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 15",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 16",
          "code": "#include <bits/stdc++.h>\n#include <ext/numeric>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ncout << power(10, 7); // this function is fast power that works in O(log n)",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 17",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 18",
          "code": "const int mod = (int) 1e9 + 7;\nstruct mul {\n   long long operator()(const long long &n1, const long long &n2) const {\n      return (n1 * n2) % mod;\n   }\n};\nlong long identity_element(const mul& m) {\n   return 1LL;\n}\ncout << power(1LL, 100000, mul());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 19",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 (with prizes!) - Codeforces - Code 20",
          "code": "static int n;\n...\nint n = sc.nextInt();",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17548",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 1",
          "code": "some substring",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 2",
          "code": "We may note that there are only 26 + 1 = 33 quasi-binary numbers not exceeding 106",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 3",
          "code": "Ilya decided to make a rectangle from the sticks.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 4",
          "code": "Do not have to print the leading zeros",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 5",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #300 Editorial (+challenges) - Codeforces - Code 6",
          "code": "> If their total length is at least 10 (the length of CODEFORCES), it is possible to leave only some parts of the common prefix and suffix, thus the rest part (being a substring, of course) may be removed for good",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17612",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read t and T\n    long long t = inf.readLong(1LL, 1000000000LL, \"t\");\n    inf.readSpace();\n    long long T = inf.readLong(t, 1000000000LL, \"T\"); // T ≥ t\n    inf.readEoln();\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    // For each of the next n lines, read li and ri\n    for (int i = 0; i < n; ++i) {\n        long long li = inf.readLong(0LL, 1000000000LL, \"li\");\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000LL, \"ri\"); // ri ≥ li\n        inf.readEoln();\n    }\n\n    // For the next m lines, read pairs of conflicting teachers\n    set<pair<int, int>> conflict_pairs;\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        // Ensure u != v (no teacher has a conflict with himself)\n        ensuref(u != v, \"Teacher cannot conflict with self: u = v = %d\", u);\n\n        // Ensure the pair hasn't occurred before\n        int a = min(u, v);\n        int b = max(u, v); // ensure ordering to prevent duplicates\n        pair<int, int> p = make_pair(a, b);\n        ensuref(conflict_pairs.count(p) == 0, \"Duplicate conflict pair: (%d, %d)\", a, b);\n        conflict_pairs.insert(p);\n    }\n\n    // Ensure EOF\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read t and T\n    long long t = inf.readLong(1LL, 1000000000LL, \"t\");\n    inf.readSpace();\n    long long T = inf.readLong(t, 1000000000LL, \"T\"); // T ≥ t\n    inf.readEoln();\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    // For each of the next n lines, read li and ri\n    for (int i = 0; i < n; ++i) {\n        long long li = inf.readLong(0LL, 1000000000LL, \"li\");\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000LL, \"ri\"); // ri ≥ li\n        inf.readEoln();\n    }\n\n    // For the next m lines, read pairs of conflicting teachers\n    set<pair<int, int>> conflict_pairs;\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        // Ensure u != v (no teacher has a conflict with himself)\n        ensuref(u != v, \"Teacher cannot conflict with self: u = v = %d\", u);\n\n        // Ensure the pair hasn't occurred before\n        int a = min(u, v);\n        int b = max(u, v); // ensure ordering to prevent duplicates\n        pair<int, int> p = make_pair(a, b);\n        ensuref(conflict_pairs.count(p) == 0, \"Duplicate conflict pair: (%d, %d)\", a, b);\n        conflict_pairs.insert(p);\n    }\n\n    // Ensure EOF\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read t and T\n    long long t = inf.readLong(1LL, 1000000000LL, \"t\");\n    inf.readSpace();\n    long long T = inf.readLong(t, 1000000000LL, \"T\"); // T ≥ t\n    inf.readEoln();\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    // For each of the next n lines, read li and ri\n    for (int i = 0; i < n; ++i) {\n        long long li = inf.readLong(0LL, 1000000000LL, \"li\");\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000LL, \"ri\"); // ri ≥ li\n        inf.readEoln();\n    }\n\n    // For the next m lines, read pairs of conflicting teachers\n    set<pair<int, int>> conflict_pairs;\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        // Ensure u != v (no teacher has a conflict with himself)\n        ensuref(u != v, \"Teacher cannot conflict with self: u = v = %d\", u);\n\n        // Ensure the pair hasn't occurred before\n        int a = min(u, v);\n        int b = max(u, v); // ensure ordering to prevent duplicates\n        pair<int, int> p = make_pair(a, b);\n        ensuref(conflict_pairs.count(p) == 0, \"Duplicate conflict pair: (%d, %d)\", a, b);\n        conflict_pairs.insert(p);\n    }\n\n    // Ensure EOF\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    long long t = inf.readLong();\n    long long T = inf.readLong();\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    vector<long long> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        l[i] = inf.readLong();\n        r[i] = inf.readLong();\n    }\n\n    map<pair<int, int>, bool> conflict;\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt() - 1;\n        int b = inf.readInt() - 1;\n        conflict[minmax(a, b)] = true;\n    }\n\n    // Read judge's answer\n    string jans = ans.readToken();\n\n    // Read participant's answer\n    string pans = ouf.readToken();\n    if (pans != \"POSSIBLE\" && pans != \"IMPOSSIBLE\") {\n        quitf(_pe, \"First word must be 'POSSIBLE' or 'IMPOSSIBLE'\");\n    }\n\n    if (pans == \"IMPOSSIBLE\") {\n        if (jans == \"POSSIBLE\") {\n            quitf(_wa, \"Participant claimed 'IMPOSSIBLE', but a solution exists\");\n        } else {\n            quitf(_ok, \"Both participant and judge output 'IMPOSSIBLE'\");\n        }\n    } else {\n        // Participant claims 'POSSIBLE'\n        // Read n1 and n2\n        long long n1 = ouf.readLong(0, T, \"n1\");\n        long long n2 = ouf.readLong(0, T, \"n2\");\n        if (n1 + n2 < t || n1 + n2 > T) {\n            quitf(_wa, \"Total number of students not in range t..T\");\n        }\n\n        string assignment = ouf.readToken();\n        if ((int)assignment.length() != n) {\n            quitf(_wa, \"Assignment string length is not n\");\n        }\n\n        vector<int> group(n);\n        for (int i = 0; i < n; ++i) {\n            char c = assignment[i];\n            if (c != '1' && c != '2') {\n                quitf(_wa, \"Assignment[%d]=%c is not '1' or '2'\", i + 1, c);\n            }\n            group[i] = c - '1'; // 0 or 1\n        }\n\n        vector<long long> n_students = {n1, n2};\n\n        for (int i = 0; i < n; ++i) {\n            int g = group[i];\n            if (n_students[g] < l[i] || n_students[g] > r[i]) {\n                quitf(_wa, \"Teacher %d assigned to group %d with %lld students, which is not in [%lld,%lld]\",\n                      i + 1, g + 1, n_students[g], l[i], r[i]);\n            }\n        }\n\n        // Check conflicts\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (conflict.count(minmax(i, j)) && group[i] == group[j]) {\n                    quitf(_wa, \"Conflicting teachers %d and %d assigned to the same group %d\",\n                          i + 1, j + 1, group[i] + 1);\n                }\n            }\n        }\n\n        quitf(_ok, \"Participant output correct solution\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    int T = opt<int>(\"T\");\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= t && t <= T && T <= 1000000000);\n    ensure(1 <= n && n <= 100000);\n\n    // Adjust m if necessary\n    long long max_m = 1LL * n * (n - 1) / 2;\n    if (m > max_m) m = max_m;\n\n    vector<pair<int, int>> lr(n);\n    set<pair<int, int>> conflicts;\n\n    if (type == \"random\") {\n        // Generate random l_i and r_i\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n\n        // Generate m unique conflict pairs\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        t = T;\n        for (int i = 0; i < n; ++i) {\n            int l_i = T + 1 + rnd.next(0, 1000);\n            int r_i = l_i + rnd.next(0, 1000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n        m = 0; // No conflicts required\n\n    } else if (type == \"no_conflicts\") {\n        // Generate case with no conflicts\n        m = 0;\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n\n    } else if (type == \"max_conflicts\") {\n        // Generate maximum number of conflicts up to 1e5\n        m = min(m, 100000);\n        // Generate random l_i and r_i\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n        // Generate m unique conflict pairs\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"tight_ranges\") {\n        // Generate tight l_i and r_i\n        int total_students = rnd.next(t, T);\n        int group1_size = rnd.next(0, total_students);\n        int group2_size = total_students - group1_size;\n\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                lr[i] = make_pair(group1_size, group1_size);\n            } else {\n                lr[i] = make_pair(group2_size, group2_size);\n            }\n        }\n        m = min(m, 100000);\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"conflicting_preferences\") {\n        // Generate conflicting group size preferences\n        int group_size = rnd.next(t, T / 2);\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                lr[i] = make_pair(group_size, group_size + rnd.next(0, 10));\n            } else {\n                lr[i] = make_pair(group_size + rnd.next(0, 10), group_size + rnd.next(10, 20));\n            }\n        }\n        m = min(m, 100000);\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n    }\n\n    // Output t and T\n    printf(\"%d %d\\n\", t, T);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)conflicts.size());\n\n    // Output l_i and r_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", lr[i].first, lr[i].second);\n    }\n\n    // Output conflicts\n    for (auto p : conflicts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t = opt<int>(\"t\");\n    int T = opt<int>(\"T\");\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= t && t <= T && T <= 1000000000);\n    ensure(1 <= n && n <= 100000);\n\n    // Adjust m if necessary\n    long long max_m = 1LL * n * (n - 1) / 2;\n    if (m > max_m) m = max_m;\n\n    vector<pair<int, int>> lr(n);\n    set<pair<int, int>> conflicts;\n\n    if (type == \"random\") {\n        // Generate random l_i and r_i\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n\n        // Generate m unique conflict pairs\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        t = T;\n        for (int i = 0; i < n; ++i) {\n            int l_i = T + 1 + rnd.next(0, 1000);\n            int r_i = l_i + rnd.next(0, 1000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n        m = 0; // No conflicts required\n\n    } else if (type == \"no_conflicts\") {\n        // Generate case with no conflicts\n        m = 0;\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n\n    } else if (type == \"max_conflicts\") {\n        // Generate maximum number of conflicts up to 1e5\n        m = min(m, 100000);\n        // Generate random l_i and r_i\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n        // Generate m unique conflict pairs\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"tight_ranges\") {\n        // Generate tight l_i and r_i\n        int total_students = rnd.next(t, T);\n        int group1_size = rnd.next(0, total_students);\n        int group2_size = total_students - group1_size;\n\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                lr[i] = make_pair(group1_size, group1_size);\n            } else {\n                lr[i] = make_pair(group2_size, group2_size);\n            }\n        }\n        m = min(m, 100000);\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else if (type == \"conflicting_preferences\") {\n        // Generate conflicting group size preferences\n        int group_size = rnd.next(t, T / 2);\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2)) {\n                lr[i] = make_pair(group_size, group_size + rnd.next(0, 10));\n            } else {\n                lr[i] = make_pair(group_size + rnd.next(0, 10), group_size + rnd.next(10, 20));\n            }\n        }\n        m = min(m, 100000);\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int l_i = rnd.next(0, 1000000000);\n            int r_i = rnd.next(l_i, 1000000000);\n            lr[i] = make_pair(l_i, r_i);\n        }\n        while ((int)conflicts.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            conflicts.insert(make_pair(u, v));\n        }\n    }\n\n    // Output t and T\n    printf(\"%d %d\\n\", t, T);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)conflicts.size());\n\n    // Output l_i and r_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", lr[i].first, lr[i].second);\n    }\n\n    // Output conflicts\n    for (auto p : conflicts) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random cases\n./gen -t 1 -T 2 -n 2 -m 1 -type random\n./gen -t 5 -T 10 -n 5 -m 5 -type random\n./gen -t 1 -T 10 -n 3 -m 0 -type random\n\n# Random cases with maximum sizes\n./gen -t 1000000000 -T 1000000000 -n 100000 -m 100000 -type random\n./gen -t 500000000 -T 1000000000 -n 100000 -m 100000 -type random\n\n# Impossible cases\n./gen -t 100 -T 100 -n 5 -type impossible\n./gen -t 1000 -T 1000 -n 1000 -type impossible\n\n# Cases with no conflicts\n./gen -t 10 -T 20 -n 50 -type no_conflicts\n./gen -t 1 -T 1 -n 1 -type no_conflicts\n\n# Cases with maximum conflicts\n./gen -t 1000000000 -T 1000000000 -n 100000 -m 100000 -type max_conflicts\n./gen -t 500000000 -T 1000000000 -n 50000 -m 100000 -type max_conflicts\n\n# Cases with tight ranges\n./gen -t 10 -T 10 -n 10 -m 0 -type tight_ranges\n./gen -t 1000 -T 1000 -n 1000 -m 100000 -type tight_ranges\n\n# Cases with conflicting preferences\n./gen -t 15 -T 50 -n 20 -m 50 -type conflicting_preferences\n\n# Edge cases\n./gen -t 1 -T 1000000000 -n 1 -type random\n./gen -t 1000000000 -T 1000000000 -n 100000 -m 100000 -type random\n\n# Small impossible case\n./gen -t 1 -T 1 -n 2 -type impossible\n\n# Random cases with varying m\n./gen -t 10 -T 1000 -n 100 -m 0 -type random\n./gen -t 10 -T 1000 -n 100 -m 50 -type random\n./gen -t 10 -T 1000 -n 100 -m 1000 -type random\n\n# Various m values\n./gen -t 10 -T 1000 -n 500 -m 1000 -type random\n./gen -t 10 -T 1000 -n 500 -m 0 -type random\n./gen -t 10 -T 1000 -n 500 -m 5000 -type random\n\n# Maximum sizes with no conflicts\n./gen -t 1 -T 1000000000 -n 100000 -type no_conflicts\n\n# Large conflicting preferences\n./gen -t 500000000 -T 1000000000 -n 100000 -m 100000 -type conflicting_preferences\n\n# Tight ranges with large n\n./gen -t 50000 -T 50000 -n 100000 -m 100000 -type tight_ranges\n\n# Cases with conflicts equal to m\n./gen -t 1000 -T 2000 -n 2000 -m 100000 -type max_conflicts\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:31.898864",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "54/A",
      "title": "A. Presents",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers N and K (1 ≤ N ≤ 365, 1 ≤ K ≤ N).The second line contains a number C which represents the number of holidays (0 ≤ C ≤ N). Then in the same line follow C numbers ranging from 1 to N which are the numbers of holiday days. The numbers are given in the increasing order, without repeating numbers among them.",
      "output_spec": "OutputPrint a single number — the minimal number of presents the Hedgehog will receive over the following N days.",
      "sample_tests": "ExamplesInputCopy5 21 3OutputCopy3InputCopy10 13 6 7 8OutputCopy10",
      "description": "A. Presents\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers N and K (1 ≤ N ≤ 365, 1 ≤ K ≤ N).The second line contains a number C which represents the number of holidays (0 ≤ C ≤ N). Then in the same line follow C numbers ranging from 1 to N which are the numbers of holiday days. The numbers are given in the increasing order, without repeating numbers among them.\n\nOutputPrint a single number — the minimal number of presents the Hedgehog will receive over the following N days.\n\nInputCopy5 21 3OutputCopy3InputCopy10 13 6 7 8OutputCopy10\n\nInputCopy5 21 3\n\nOutputCopy3\n\nInputCopy10 13 6 7 8\n\nOutputCopy10",
      "solutions": [
        {
          "title": "Codeforces Beta Round #50 - Codeforces",
          "content": "Hello, CodeForceans!This CodeForces Round, 50-th already, will be carried out by me, Max Ivanov (e-maxx).I invite to this round all schoolchildren who have just returned from their training camp \"LKSH.Winter\" - not to give their brains an excess respite, and all students - to distract from all the troubles caused by such a fearful phenomenon as the Examinations :)The contest is over, congratulations for the winner - RAVEman!Problem editorials:problem Cproblem Dproblem EProblem Statements:Russian Statements in PDFEnglish Statements in PDFThe problems in this round will be five stories from a life of one Hedgehog (don't be surprised - hedgehogs are my loved creatures :) ).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 679
        },
        {
          "title": "Codeforces Beta Round #50: Editorial for problem E - Codeforces",
          "content": "The most important step on the way to solve this problem - is to understand that it's enough to consider only such rotations of the polygon, that one of its sides lies on the side of the room.Let's try to understand this fact. Suppose that the fact is wrong, and there exists such a position of vacuum cleaner, that neither of its sides lies on the side of the room. Denote as i and j the numbers of vertices that lie on the room sides. It's easy to understand that the polygon form between vertices i and j doesn't make any sense itself: for each rotation we can see that from the area of triangle OP[i]P[j] some constant area is subtracted, while the concrete value of this constant depends on the polygon form.That's why we see that the polygon form doesn't influence on anything (if we have fixed numbers i and j), and we have just to minimize the area of right-angled triangle OP[i]P[j]. But, taking into account that its hypotenuse is a constant, it's easy to see that the minimum is reached in borderline cases: i.e. when one of the polygon sides lies on the room side.So, we've proved the fact. Then we have to invent fast enough solution. We have already obtained an O(n2) solution: iterate over all sides of the polygon (i.e. iterating over all possible i), mentally push it to one side of the room, then find the threshold point j, then calculate answer for given i and j. Let's learn how to do these both things in O(1).In order to do the first thing (finding j) we can use a method of moving pointer: if we iterate over i in the same order as in the input file, then we can just maintain the right value of j (i.e. when we move from i to i + 1 we have to increase j several times, while it is getting further and further).In order to do the second thing (the area calculation) we have to do some precalculation. For example, we can find the mass center Q of the vacuum cleaner, and pre-calculate all partial sums S[i] - sums of all triangles QP[j - 1]P[j] for all j ≤ i. After this precalculation we can get the answer for every i and j in O(1) as a combination of difference of two values from S[] and two triangles' areas: QP[i]P[j] and OP[i]P[j].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1085",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2162
        },
        {
          "title": "Codeforces Beta Round #50: Разбор задачи D - Codeforces",
          "content": "I'll describe here an author's solution for this problem.The solution is by a method of dynamic programming: the state is a pair (pos, pref), where pos - the position in the string built (it is between 0 and n), and pref - the current prefix of pattern P (i.e. this is a number between 0 and length(P)). The value pref will help us to control all occurences of pattern P: if pref = length(P) then it means that here is an ending of occurence of pattern P (the beginning of the occurence was at pos - length(P)).The value D[pos][pref] of the dynamic is true, if the state is reachable. We start from the state (0, 0) and want to get to any state with pos = n.How to make moves in the dynamic? We iterate over all possible characters C and try to add it to the current answer. That's why we get into a stage (pos + 1, newpref), where newpref is a new length of prefix of P. The problem constraints permitted to calculate this value newpref easily, i.e. just by searching for substrings of form P[length(P) - oldpref..length(P)] + C in the pattern P.For example, if P = ab and pref = 1, then with the character C = a we will get into newpref = 1 (because we added character a to the string a, - we got string aa, but its longest suffix matching with the prefix of string P equals to a). If we took C = b then we would get into state newpref = 2. Any other character would move us into the state with newprefix = 0.But in reality, of course, an algorithm for calculating prefix-function can be guessed here. Really, in fact, we answer the following query: \"we had some prefix of pattern P and added character C by its end - so what will be the new prefix?\". These queries are answered exactly by prefix-function algorithm. Moreover, we can pre-calculate answers to all of these queries in some table and get answers for them in O(1) from the table. This is called an automaton built over the prefix-function.One way or another, if we've taught how to calculate newpref, then everything is quite simple: we know how to make movements in dynamics from one state to another. After getting the solution we'll have just to restore the answer-string itself.The solution's asymptotics depends on the way we chose to calculate newpref. The fastest way is using the prefix-function automaton, and the asymptotics in this case is O(kn2). But, I remind, the problem's constraints allowed to choose some simpler way with worse asymptotics.P.S. This problem was additionally interesting by the fact that one can invent many strange simple solutions, which are very difficult to prove (and most of them will have counter-examples, but very rare ones). Some of these tricky solutions passed all systests in the round. I have also created one relatively simple solution that looks rather unlike to be right, but we didn't manage to create counter-example even after several hours of stress :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2872
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read N and K\n    int N = inf.readInt(1, 365, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, N, \"K\");\n    inf.readEoln();\n\n    // Read C, then read C holiday days if C > 0\n    int C = inf.readInt(0, N, \"C\");\n    if (C > 0) {\n        inf.readSpace();\n        vector<int> holidays = inf.readInts(C, 1, N);\n        // Ensure the holiday days are strictly increasing\n        for (int i = 1; i < C; i++) {\n            ensuref(holidays[i] > holidays[i - 1], \"Holiday days must be strictly increasing and without duplicates\");\n        }\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read N and K\n    int N = inf.readInt(1, 365, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, N, \"K\");\n    inf.readEoln();\n\n    // Read C, then read C holiday days if C > 0\n    int C = inf.readInt(0, N, \"C\");\n    if (C > 0) {\n        inf.readSpace();\n        vector<int> holidays = inf.readInts(C, 1, N);\n        // Ensure the holiday days are strictly increasing\n        for (int i = 1; i < C; i++) {\n            ensuref(holidays[i] > holidays[i - 1], \"Holiday days must be strictly increasing and without duplicates\");\n        }\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read N and K\n    int N = inf.readInt(1, 365, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(1, N, \"K\");\n    inf.readEoln();\n\n    // Read C, then read C holiday days if C > 0\n    int C = inf.readInt(0, N, \"C\");\n    if (C > 0) {\n        inf.readSpace();\n        vector<int> holidays = inf.readInts(C, 1, N);\n        // Ensure the holiday days are strictly increasing\n        for (int i = 1; i < C; i++) {\n            ensuref(holidays[i] > holidays[i - 1], \"Holiday days must be strictly increasing and without duplicates\");\n        }\n    }\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters N, K, and a \"type\" string\n    int N = opt<int>(\"N\");\n    int K = opt<int>(\"K\");\n    string type = opt<string>(\"type\", \"random\"); \n\n    // Make sure we respect the constraints: 1 <= K <= N <= 365.\n    // (Any further checks are optional but recommended.)\n    // We'll generate holidays in the range [1..N], ensuring ascending order and no duplicates.\n\n    // Prepare a vector for holiday days\n    vector<int> holidays;\n\n    if (type == \"none\") {\n        // No holidays at all\n        // C = 0\n        // Output is just 0 after N, K lines\n    }\n    else if (type == \"all\") {\n        // All days are holidays\n        // C = N, holidays = [1..N]\n        holidays.resize(N);\n        iota(holidays.begin(), holidays.end(), 1);\n    }\n    else if (type == \"some\") {\n        // A \"some\" pattern, e.g. half of the days are holidays\n        // We'll pick those deterministically or in a small pattern\n        // for demonstration, let's put every second day as a holiday\n        for (int i = 2; i <= N; i += 2) {\n            holidays.push_back(i);\n        }\n    }\n    else {\n        // \"random\" or any other type => random holiday set\n        // We'll pick c from [0..N], then choose c distinct days\n        int c = rnd.next(0, N);  \n        // We'll create a candidate list [1..N]\n        vector<int> candidates(N);\n        iota(candidates.begin(), candidates.end(), 1);\n        shuffle(candidates.begin(), candidates.end());\n        // Take the first c\n        holidays.assign(candidates.begin(), candidates.begin() + c);\n        // Sort them ascending\n        sort(holidays.begin(), holidays.end());\n    }\n\n    // Output the test in the specified format:\n    // 1) N and K on the same line\n    // 2) C followed by the C holidays in ascending order on the next line.\n\n    cout << N << \" \" << K << \"\\n\";\n    cout << holidays.size();\n    for (auto h : holidays) {\n        cout << \" \" << h;\n    }\n    cout << \"\\n\";\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters N, K, and a \"type\" string\n    int N = opt<int>(\"N\");\n    int K = opt<int>(\"K\");\n    string type = opt<string>(\"type\", \"random\"); \n\n    // Make sure we respect the constraints: 1 <= K <= N <= 365.\n    // (Any further checks are optional but recommended.)\n    // We'll generate holidays in the range [1..N], ensuring ascending order and no duplicates.\n\n    // Prepare a vector for holiday days\n    vector<int> holidays;\n\n    if (type == \"none\") {\n        // No holidays at all\n        // C = 0\n        // Output is just 0 after N, K lines\n    }\n    else if (type == \"all\") {\n        // All days are holidays\n        // C = N, holidays = [1..N]\n        holidays.resize(N);\n        iota(holidays.begin(), holidays.end(), 1);\n    }\n    else if (type == \"some\") {\n        // A \"some\" pattern, e.g. half of the days are holidays\n        // We'll pick those deterministically or in a small pattern\n        // for demonstration, let's put every second day as a holiday\n        for (int i = 2; i <= N; i += 2) {\n            holidays.push_back(i);\n        }\n    }\n    else {\n        // \"random\" or any other type => random holiday set\n        // We'll pick c from [0..N], then choose c distinct days\n        int c = rnd.next(0, N);  \n        // We'll create a candidate list [1..N]\n        vector<int> candidates(N);\n        iota(candidates.begin(), candidates.end(), 1);\n        shuffle(candidates.begin(), candidates.end());\n        // Take the first c\n        holidays.assign(candidates.begin(), candidates.begin() + c);\n        // Sort them ascending\n        sort(holidays.begin(), holidays.end());\n    }\n\n    // Output the test in the specified format:\n    // 1) N and K on the same line\n    // 2) C followed by the C holidays in ascending order on the next line.\n\n    cout << N << \" \" << K << \"\\n\";\n    cout << holidays.size();\n    for (auto h : holidays) {\n        cout << \" \" << h;\n    }\n    cout << \"\\n\";\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -N 1 -K 1 -type none\n./gen -N 1 -K 1 -type all\n./gen -N 5 -K 1 -type none\n./gen -N 5 -K 5 -type all\n./gen -N 5 -K 2 -type random\n./gen -N 5 -K 3 -type random\n./gen -N 5 -K 5 -type random\n./gen -N 10 -K 1 -type random\n./gen -N 10 -K 5 -type random\n./gen -N 10 -K 10 -type random\n./gen -N 15 -K 1 -type some\n./gen -N 15 -K 7 -type some\n./gen -N 15 -K 15 -type some\n./gen -N 365 -K 1 -type none\n./gen -N 365 -K 1 -type all\n./gen -N 365 -K 1 -type random\n./gen -N 365 -K 365 -type none\n./gen -N 365 -K 365 -type random\n./gen -N 365 -K 182 -type some\n./gen -N 365 -K 183 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:33.655195",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "54/B",
      "title": "B. Cutting Jigsaw Puzzle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers A and B which are the sizes of the picture. They are positive integers not exceeding 20.Then follow A lines containing B symbols each, describing the actual picture. The lines only contain uppercase English letters.",
      "output_spec": "OutputIn the first line print the number of possible good puzzles (in other words, the number of pairs (X, Y) such that the puzzle with the corresponding element sizes will be good). This number should always be positive, because the whole picture is a good puzzle itself. In the second line print two numbers — the sizes X and Y of the smallest possible element among all good puzzles. The comparison is made firstly by the area XY of one element and secondly — by the length X.",
      "sample_tests": "ExamplesInputCopy2 4ABDCABDCOutputCopy32 1InputCopy2 6ABCCBAABCCBAOutputCopy12 6",
      "description": "B. Cutting Jigsaw Puzzle\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two numbers A and B which are the sizes of the picture. They are positive integers not exceeding 20.Then follow A lines containing B symbols each, describing the actual picture. The lines only contain uppercase English letters.\n\nOutputIn the first line print the number of possible good puzzles (in other words, the number of pairs (X, Y) such that the puzzle with the corresponding element sizes will be good). This number should always be positive, because the whole picture is a good puzzle itself. In the second line print two numbers — the sizes X and Y of the smallest possible element among all good puzzles. The comparison is made firstly by the area XY of one element and secondly — by the length X.\n\nInputCopy2 4ABDCABDCOutputCopy32 1InputCopy2 6ABCCBAABCCBAOutputCopy12 6\n\nInputCopy2 4ABDCABDC\n\nOutputCopy32 1\n\nInputCopy2 6ABCCBAABCCBA\n\nOutputCopy12 6\n\nNoteThe picture in the first sample test has the following good puzzles: (2, 1), (2, 2), (2, 4).",
      "solutions": [
        {
          "title": "Codeforces Beta Round #50 - Codeforces",
          "content": "Hello, CodeForceans!This CodeForces Round, 50-th already, will be carried out by me, Max Ivanov (e-maxx).I invite to this round all schoolchildren who have just returned from their training camp \"LKSH.Winter\" - not to give their brains an excess respite, and all students - to distract from all the troubles caused by such a fearful phenomenon as the Examinations :)The contest is over, congratulations for the winner - RAVEman!Problem editorials:problem Cproblem Dproblem EProblem Statements:Russian Statements in PDFEnglish Statements in PDFThe problems in this round will be five stories from a life of one Hedgehog (don't be surprised - hedgehogs are my loved creatures :) ).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 679
        },
        {
          "title": "Codeforces Beta Round #50: Editorial for problem E - Codeforces",
          "content": "The most important step on the way to solve this problem - is to understand that it's enough to consider only such rotations of the polygon, that one of its sides lies on the side of the room.Let's try to understand this fact. Suppose that the fact is wrong, and there exists such a position of vacuum cleaner, that neither of its sides lies on the side of the room. Denote as i and j the numbers of vertices that lie on the room sides. It's easy to understand that the polygon form between vertices i and j doesn't make any sense itself: for each rotation we can see that from the area of triangle OP[i]P[j] some constant area is subtracted, while the concrete value of this constant depends on the polygon form.That's why we see that the polygon form doesn't influence on anything (if we have fixed numbers i and j), and we have just to minimize the area of right-angled triangle OP[i]P[j]. But, taking into account that its hypotenuse is a constant, it's easy to see that the minimum is reached in borderline cases: i.e. when one of the polygon sides lies on the room side.So, we've proved the fact. Then we have to invent fast enough solution. We have already obtained an O(n2) solution: iterate over all sides of the polygon (i.e. iterating over all possible i), mentally push it to one side of the room, then find the threshold point j, then calculate answer for given i and j. Let's learn how to do these both things in O(1).In order to do the first thing (finding j) we can use a method of moving pointer: if we iterate over i in the same order as in the input file, then we can just maintain the right value of j (i.e. when we move from i to i + 1 we have to increase j several times, while it is getting further and further).In order to do the second thing (the area calculation) we have to do some precalculation. For example, we can find the mass center Q of the vacuum cleaner, and pre-calculate all partial sums S[i] - sums of all triangles QP[j - 1]P[j] for all j ≤ i. After this precalculation we can get the answer for every i and j in O(1) as a combination of difference of two values from S[] and two triangles' areas: QP[i]P[j] and OP[i]P[j].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1085",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2162
        },
        {
          "title": "Codeforces Beta Round #50: Разбор задачи D - Codeforces",
          "content": "I'll describe here an author's solution for this problem.The solution is by a method of dynamic programming: the state is a pair (pos, pref), where pos - the position in the string built (it is between 0 and n), and pref - the current prefix of pattern P (i.e. this is a number between 0 and length(P)). The value pref will help us to control all occurences of pattern P: if pref = length(P) then it means that here is an ending of occurence of pattern P (the beginning of the occurence was at pos - length(P)).The value D[pos][pref] of the dynamic is true, if the state is reachable. We start from the state (0, 0) and want to get to any state with pos = n.How to make moves in the dynamic? We iterate over all possible characters C and try to add it to the current answer. That's why we get into a stage (pos + 1, newpref), where newpref is a new length of prefix of P. The problem constraints permitted to calculate this value newpref easily, i.e. just by searching for substrings of form P[length(P) - oldpref..length(P)] + C in the pattern P.For example, if P = ab and pref = 1, then with the character C = a we will get into newpref = 1 (because we added character a to the string a, - we got string aa, but its longest suffix matching with the prefix of string P equals to a). If we took C = b then we would get into state newpref = 2. Any other character would move us into the state with newprefix = 0.But in reality, of course, an algorithm for calculating prefix-function can be guessed here. Really, in fact, we answer the following query: \"we had some prefix of pattern P and added character C by its end - so what will be the new prefix?\". These queries are answered exactly by prefix-function algorithm. Moreover, we can pre-calculate answers to all of these queries in some table and get answers for them in O(1) from the table. This is called an automaton built over the prefix-function.One way or another, if we've taught how to calculate newpref, then everything is quite simple: we know how to make movements in dynamics from one state to another. After getting the solution we'll have just to restore the answer-string itself.The solution's asymptotics depends on the way we chose to calculate newpref. The fastest way is using the prefix-function automaton, and the asymptotics in this case is O(kn2). But, I remind, the problem's constraints allowed to choose some simpler way with worse asymptotics.P.S. This problem was additionally interesting by the fact that one can invent many strange simple solutions, which are very difficult to prove (and most of them will have counter-examples, but very rare ones). Some of these tricky solutions passed all systests in the round. I have also created one relatively simple solution that looks rather unlike to be right, but we didn't manage to create counter-example even after several hours of stress :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2872
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 20, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 20, \"B\");\n    inf.readEoln();\n    string line_pattern = \"[A-Z]{\" + to_string(B) + \"}\";\n    for (int i = 0; i < A; ++i) {\n        inf.readLine(line_pattern, \"line_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 20, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 20, \"B\");\n    inf.readEoln();\n    string line_pattern = \"[A-Z]{\" + to_string(B) + \"}\";\n    for (int i = 0; i < A; ++i) {\n        inf.readLine(line_pattern, \"line_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 20, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 20, \"B\");\n    inf.readEoln();\n    string line_pattern = \"[A-Z]{\" + to_string(B) + \"}\";\n    for (int i = 0; i < A; ++i) {\n        inf.readLine(line_pattern, \"line_\" + to_string(i + 1));\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int A = opt<int>(\"A\");\n    int B = opt<int>(\"B\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> picture(A, string(B, 'A'));\n\n    if (type == \"all_same\") {\n        // Fill with 'A'\n        for (int i = 0; i < A; ++i)\n            for (int j = 0; j < B; ++j)\n                picture[i][j] = 'A';\n\n    } else if (type == \"random\") {\n        // Fill with random uppercase letters\n        for (int i = 0; i < A; ++i)\n            for (int j = 0; j < B; ++j)\n                picture[i][j] = 'A' + rnd.next(26);\n\n    } else if (type == \"min_puzzles\") {\n        // Fill with 'A' to minimize the number of good puzzles\n        for (int i = 0; i < A; ++i)\n            for (int j = 0; j < B; ++j)\n                picture[i][j] = 'A';\n\n    } else if (type == \"max_puzzles\") {\n        // Try to maximize the number of good puzzles\n        // Fill the picture with unique letters as much as possible\n        char currLetter = 'A';\n        for (int i = 0; i < A; ++i) {\n            for (int j = 0; j < B; ++j) {\n                picture[i][j] = currLetter;\n                currLetter++;\n                if (currLetter > 'Z') currLetter = 'A';\n            }\n        }\n\n    } else if (type == \"rotation_test\") {\n        // Construct a pattern to test rotation handling\n        // Create a pattern where pieces become identical after rotation\n        for (int i = 0; i < A; i += 2) {\n            for (int j = 0; j < B; j += 2) {\n                char c1 = 'A' + rnd.next(26);\n                char c2 = 'A' + rnd.next(26);\n                char c3 = 'A' + rnd.next(26);\n                char c4 = 'A' + rnd.next(26);\n                if (i + 1 < A && j + 1 < B) {\n                    picture[i][j] = c1;\n                    picture[i][j+1] = c2;\n                    picture[i+1][j] = c3;\n                    picture[i+1][j+1] = c4;\n                }\n            }\n        }\n\n    } else if (type == \"symmetry_test\") {\n        // Construct a symmetrical picture\n        for (int i = 0; i < A; ++i) {\n            for (int j = 0; j < B / 2; ++j) {\n                picture[i][j] = 'A' + rnd.next(26);\n                picture[i][B - j - 1] = picture[i][j];\n            }\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output A and B\n    printf(\"%d %d\\n\", A, B);\n\n    // Output the picture\n    for (int i = 0; i < A; ++i)\n        printf(\"%s\\n\", picture[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int A = opt<int>(\"A\");\n    int B = opt<int>(\"B\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> picture(A, string(B, 'A'));\n\n    if (type == \"all_same\") {\n        // Fill with 'A'\n        for (int i = 0; i < A; ++i)\n            for (int j = 0; j < B; ++j)\n                picture[i][j] = 'A';\n\n    } else if (type == \"random\") {\n        // Fill with random uppercase letters\n        for (int i = 0; i < A; ++i)\n            for (int j = 0; j < B; ++j)\n                picture[i][j] = 'A' + rnd.next(26);\n\n    } else if (type == \"min_puzzles\") {\n        // Fill with 'A' to minimize the number of good puzzles\n        for (int i = 0; i < A; ++i)\n            for (int j = 0; j < B; ++j)\n                picture[i][j] = 'A';\n\n    } else if (type == \"max_puzzles\") {\n        // Try to maximize the number of good puzzles\n        // Fill the picture with unique letters as much as possible\n        char currLetter = 'A';\n        for (int i = 0; i < A; ++i) {\n            for (int j = 0; j < B; ++j) {\n                picture[i][j] = currLetter;\n                currLetter++;\n                if (currLetter > 'Z') currLetter = 'A';\n            }\n        }\n\n    } else if (type == \"rotation_test\") {\n        // Construct a pattern to test rotation handling\n        // Create a pattern where pieces become identical after rotation\n        for (int i = 0; i < A; i += 2) {\n            for (int j = 0; j < B; j += 2) {\n                char c1 = 'A' + rnd.next(26);\n                char c2 = 'A' + rnd.next(26);\n                char c3 = 'A' + rnd.next(26);\n                char c4 = 'A' + rnd.next(26);\n                if (i + 1 < A && j + 1 < B) {\n                    picture[i][j] = c1;\n                    picture[i][j+1] = c2;\n                    picture[i+1][j] = c3;\n                    picture[i+1][j+1] = c4;\n                }\n            }\n        }\n\n    } else if (type == \"symmetry_test\") {\n        // Construct a symmetrical picture\n        for (int i = 0; i < A; ++i) {\n            for (int j = 0; j < B / 2; ++j) {\n                picture[i][j] = 'A' + rnd.next(26);\n                picture[i][B - j - 1] = picture[i][j];\n            }\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output A and B\n    printf(\"%d %d\\n\", A, B);\n\n    // Output the picture\n    for (int i = 0; i < A; ++i)\n        printf(\"%s\\n\", picture[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# All same letter test cases\n./gen -A 1 -B 1 -type all_same\n./gen -A 1 -B 20 -type all_same\n./gen -A 20 -B 1 -type all_same\n./gen -A 20 -B 20 -type all_same\n\n# Random letters test cases\n./gen -A 1 -B 1 -type random\n./gen -A 1 -B 20 -type random\n./gen -A 20 -B 1 -type random\n./gen -A 20 -B 20 -type random\n\n# Maximize number of good puzzles\n./gen -A 2 -B 2 -type max_puzzles\n./gen -A 3 -B 3 -type max_puzzles\n./gen -A 4 -B 4 -type max_puzzles\n./gen -A 5 -B 5 -type max_puzzles\n./gen -A 10 -B 10 -type max_puzzles\n\n# Minimize number of good puzzles\n./gen -A 2 -B 2 -type min_puzzles\n./gen -A 3 -B 3 -type min_puzzles\n./gen -A 4 -B 4 -type min_puzzles\n./gen -A 5 -B 5 -type min_puzzles\n./gen -A 20 -B 20 -type min_puzzles\n\n# Rotation test cases\n./gen -A 2 -B 2 -type rotation_test\n./gen -A 4 -B 4 -type rotation_test\n./gen -A 6 -B 6 -type rotation_test\n./gen -A 8 -B 8 -type rotation_test\n./gen -A 10 -B 10 -type rotation_test\n\n# Symmetry test cases\n./gen -A 2 -B 4 -type symmetry_test\n./gen -A 4 -B 4 -type symmetry_test\n./gen -A 6 -B 6 -type symmetry_test\n./gen -A 8 -B 8 -type symmetry_test\n./gen -A 10 -B 10 -type symmetry_test\n\n# Edge cases\n./gen -A 1 -B 20 -type random\n./gen -A 20 -B 1 -type random\n\n# Large inputs\n./gen -A 20 -B 20 -type random\n./gen -A 20 -B 20 -type all_same\n./gen -A 20 -B 20 -type max_puzzles\n./gen -A 20 -B 20 -type min_puzzles\n\n# Mixed size inputs\n./gen -A 5 -B 10 -type random\n./gen -A 10 -B 5 -type random\n./gen -A 15 -B 10 -type random\n./gen -A 10 -B 15 -type random\n\n# Small inputs\n./gen -A 1 -B 1 -type random\n./gen -A 2 -B 2 -type random\n./gen -A 3 -B 3 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:35.905334",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "54/C",
      "title": "C. First Digit Law",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number N which is the number of random variables (1 ≤ N ≤ 1000). Then follow N lines containing pairs of numbers Li, Ri, each of whom is a description of a random variable. It is guaranteed that 1 ≤ Li ≤ Ri ≤ 1018.The last line contains an integer K (0 ≤ K ≤ 100).All the numbers in the input file are integers.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).",
      "output_spec": "OutputPrint the required probability. Print the fractional number with such a precision that the relative or absolute error of the result won't exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopy11 250OutputCopy0.500000000000000InputCopy21 29 1150OutputCopy0.833333333333333",
      "description": "C. First Digit Law\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number N which is the number of random variables (1 ≤ N ≤ 1000). Then follow N lines containing pairs of numbers Li, Ri, each of whom is a description of a random variable. It is guaranteed that 1 ≤ Li ≤ Ri ≤ 1018.The last line contains an integer K (0 ≤ K ≤ 100).All the numbers in the input file are integers.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n\nOutputPrint the required probability. Print the fractional number with such a precision that the relative or absolute error of the result won't exceed 10 - 9.\n\nInputCopy11 250OutputCopy0.500000000000000InputCopy21 29 1150OutputCopy0.833333333333333\n\nInputCopy11 250\n\nOutputCopy0.500000000000000\n\nInputCopy21 29 1150\n\nOutputCopy0.833333333333333",
      "solutions": [
        {
          "title": "Codeforces Beta Round #50 - Codeforces",
          "content": "Hello, CodeForceans!This CodeForces Round, 50-th already, will be carried out by me, Max Ivanov (e-maxx).I invite to this round all schoolchildren who have just returned from their training camp \"LKSH.Winter\" - not to give their brains an excess respite, and all students - to distract from all the troubles caused by such a fearful phenomenon as the Examinations :)The contest is over, congratulations for the winner - RAVEman!Problem editorials:problem Cproblem Dproblem EProblem Statements:Russian Statements in PDFEnglish Statements in PDFThe problems in this round will be five stories from a life of one Hedgehog (don't be surprised - hedgehogs are my loved creatures :) ).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 679
        },
        {
          "title": "Codeforces Beta Round #50: Editorial for problem E - Codeforces",
          "content": "The most important step on the way to solve this problem - is to understand that it's enough to consider only such rotations of the polygon, that one of its sides lies on the side of the room.Let's try to understand this fact. Suppose that the fact is wrong, and there exists such a position of vacuum cleaner, that neither of its sides lies on the side of the room. Denote as i and j the numbers of vertices that lie on the room sides. It's easy to understand that the polygon form between vertices i and j doesn't make any sense itself: for each rotation we can see that from the area of triangle OP[i]P[j] some constant area is subtracted, while the concrete value of this constant depends on the polygon form.That's why we see that the polygon form doesn't influence on anything (if we have fixed numbers i and j), and we have just to minimize the area of right-angled triangle OP[i]P[j]. But, taking into account that its hypotenuse is a constant, it's easy to see that the minimum is reached in borderline cases: i.e. when one of the polygon sides lies on the room side.So, we've proved the fact. Then we have to invent fast enough solution. We have already obtained an O(n2) solution: iterate over all sides of the polygon (i.e. iterating over all possible i), mentally push it to one side of the room, then find the threshold point j, then calculate answer for given i and j. Let's learn how to do these both things in O(1).In order to do the first thing (finding j) we can use a method of moving pointer: if we iterate over i in the same order as in the input file, then we can just maintain the right value of j (i.e. when we move from i to i + 1 we have to increase j several times, while it is getting further and further).In order to do the second thing (the area calculation) we have to do some precalculation. For example, we can find the mass center Q of the vacuum cleaner, and pre-calculate all partial sums S[i] - sums of all triangles QP[j - 1]P[j] for all j ≤ i. After this precalculation we can get the answer for every i and j in O(1) as a combination of difference of two values from S[] and two triangles' areas: QP[i]P[j] and OP[i]P[j].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1085",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2162
        },
        {
          "title": "Codeforces Beta Round #50: Разбор задачи D - Codeforces",
          "content": "I'll describe here an author's solution for this problem.The solution is by a method of dynamic programming: the state is a pair (pos, pref), where pos - the position in the string built (it is between 0 and n), and pref - the current prefix of pattern P (i.e. this is a number between 0 and length(P)). The value pref will help us to control all occurences of pattern P: if pref = length(P) then it means that here is an ending of occurence of pattern P (the beginning of the occurence was at pos - length(P)).The value D[pos][pref] of the dynamic is true, if the state is reachable. We start from the state (0, 0) and want to get to any state with pos = n.How to make moves in the dynamic? We iterate over all possible characters C and try to add it to the current answer. That's why we get into a stage (pos + 1, newpref), where newpref is a new length of prefix of P. The problem constraints permitted to calculate this value newpref easily, i.e. just by searching for substrings of form P[length(P) - oldpref..length(P)] + C in the pattern P.For example, if P = ab and pref = 1, then with the character C = a we will get into newpref = 1 (because we added character a to the string a, - we got string aa, but its longest suffix matching with the prefix of string P equals to a). If we took C = b then we would get into state newpref = 2. Any other character would move us into the state with newprefix = 0.But in reality, of course, an algorithm for calculating prefix-function can be guessed here. Really, in fact, we answer the following query: \"we had some prefix of pattern P and added character C by its end - so what will be the new prefix?\". These queries are answered exactly by prefix-function algorithm. Moreover, we can pre-calculate answers to all of these queries in some table and get answers for them in O(1) from the table. This is called an automaton built over the prefix-function.One way or another, if we've taught how to calculate newpref, then everything is quite simple: we know how to make movements in dynamics from one state to another. After getting the solution we'll have just to restore the answer-string itself.The solution's asymptotics depends on the way we chose to calculate newpref. The fastest way is using the prefix-function automaton, and the asymptotics in this case is O(kn2). But, I remind, the problem's constraints allowed to choose some simpler way with worse asymptotics.P.S. This problem was additionally interesting by the fact that one can invent many strange simple solutions, which are very difficult to prove (and most of them will have counter-examples, but very rare ones). Some of these tricky solutions passed all systests in the round. I have also created one relatively simple solution that looks rather unlike to be right, but we didn't manage to create counter-example even after several hours of stress :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2872
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n    for (int i = 0; i < N; i++) {\n        long long Li = inf.readLong(1LL, 1000000000000000000LL, \"Li\");\n        inf.readSpace();\n        long long Ri = inf.readLong(Li, 1000000000000000000LL, \"Ri\");\n        inf.readEoln();\n    }\n    int K = inf.readInt(0, 100, \"K\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n    for (int i = 0; i < N; i++) {\n        long long Li = inf.readLong(1LL, 1000000000000000000LL, \"Li\");\n        inf.readSpace();\n        long long Ri = inf.readLong(Li, 1000000000000000000LL, \"Ri\");\n        inf.readEoln();\n    }\n    int K = inf.readInt(0, 100, \"K\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(1, 1000, \"N\");\n    inf.readEoln();\n    for (int i = 0; i < N; i++) {\n        long long Li = inf.readLong(1LL, 1000000000000000000LL, \"Li\");\n        inf.readSpace();\n        long long Ri = inf.readLong(Li, 1000000000000000000LL, \"Ri\");\n        inf.readEoln();\n    }\n    int K = inf.readInt(0, 100, \"K\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long pow10[19];\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    pow10[0] = 1LL;\n    for(int i=1; i<19; ++i)\n        pow10[i] = pow10[i-1] * 10LL;\n\n    int n = opt<int>(\"n\");\n    int K = opt<int>(\"k\", 50);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Now generate based on type\n\n    vector<pair<long long, long long>> ranges(n); // Pair of Li, Ri\n\n    if (type == \"random\") {\n        // Generate random Li and Ri within [1, 1e18]\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            long long Ri = rnd.next(Li, (long long)1e18);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"ones\") {\n        // Generate ranges where first digit is 1\n        for(int i = 0; i < n; ++i) {\n            int numDigits = rnd.next(1, 18);\n            long long Li = pow10[numDigits - 1];\n            long long Ri = pow10[numDigits] - 1;\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"non-ones\") {\n        // Generate ranges where first digit is not 1\n        for(int i = 0; i < n; ++i) {\n            int firstDigit = rnd.next(2,9);\n            int numDigits = rnd.next(1,17);\n            long long Li = firstDigit * pow10[numDigits - 1];\n            long long Ri = (firstDigit+1) * pow10[numDigits -1] - 1;\n            if(Ri > (long long)1e18) Ri = (long long)1e18;\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"singles\") {\n        // Li = Ri\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            ranges[i] = make_pair(Li, Li);\n        }\n    } else if (type == \"large\") {\n        // Li = 1, Ri = 1e18\n        for(int i = 0; i < n; ++i) {\n            ranges[i] = make_pair(1LL, (long long)1e18);\n        }\n    } else if (type == \"small\") {\n        // Li and Ri small numbers\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, 1000LL);\n            long long Ri = rnd.next(Li, 1000LL);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"edgeLiRiEqual\") {\n        // Li equals Ri at boundary values\n        for(int i = 0; i < n; ++i){\n            long long Li = (i%2 == 0) ? 1LL : (long long)1e18;\n            ranges[i] = make_pair(Li, Li);\n        }\n    } else if (type == \"edgeK\") {\n        // K = 0 or K = 100\n        // Do nothing special; K will be passed as 0 or 100\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            long long Ri = rnd.next(Li, (long long)1e18);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else {\n        // Default, same as random\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            long long Ri = rnd.next(Li, (long long)1e18);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    }\n\n    // Output N\n    printf(\"%d\\n\", n);\n    // Print Li Ri\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", ranges[i].first, ranges[i].second);\n    }\n    // Output K\n    printf(\"%d\\n\", K);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long pow10[19];\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    pow10[0] = 1LL;\n    for(int i=1; i<19; ++i)\n        pow10[i] = pow10[i-1] * 10LL;\n\n    int n = opt<int>(\"n\");\n    int K = opt<int>(\"k\", 50);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Now generate based on type\n\n    vector<pair<long long, long long>> ranges(n); // Pair of Li, Ri\n\n    if (type == \"random\") {\n        // Generate random Li and Ri within [1, 1e18]\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            long long Ri = rnd.next(Li, (long long)1e18);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"ones\") {\n        // Generate ranges where first digit is 1\n        for(int i = 0; i < n; ++i) {\n            int numDigits = rnd.next(1, 18);\n            long long Li = pow10[numDigits - 1];\n            long long Ri = pow10[numDigits] - 1;\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"non-ones\") {\n        // Generate ranges where first digit is not 1\n        for(int i = 0; i < n; ++i) {\n            int firstDigit = rnd.next(2,9);\n            int numDigits = rnd.next(1,17);\n            long long Li = firstDigit * pow10[numDigits - 1];\n            long long Ri = (firstDigit+1) * pow10[numDigits -1] - 1;\n            if(Ri > (long long)1e18) Ri = (long long)1e18;\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"singles\") {\n        // Li = Ri\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            ranges[i] = make_pair(Li, Li);\n        }\n    } else if (type == \"large\") {\n        // Li = 1, Ri = 1e18\n        for(int i = 0; i < n; ++i) {\n            ranges[i] = make_pair(1LL, (long long)1e18);\n        }\n    } else if (type == \"small\") {\n        // Li and Ri small numbers\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, 1000LL);\n            long long Ri = rnd.next(Li, 1000LL);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else if (type == \"edgeLiRiEqual\") {\n        // Li equals Ri at boundary values\n        for(int i = 0; i < n; ++i){\n            long long Li = (i%2 == 0) ? 1LL : (long long)1e18;\n            ranges[i] = make_pair(Li, Li);\n        }\n    } else if (type == \"edgeK\") {\n        // K = 0 or K = 100\n        // Do nothing special; K will be passed as 0 or 100\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            long long Ri = rnd.next(Li, (long long)1e18);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    } else {\n        // Default, same as random\n        for(int i = 0; i < n; ++i) {\n            long long Li = rnd.next(1LL, (long long)1e18);\n            long long Ri = rnd.next(Li, (long long)1e18);\n            ranges[i] = make_pair(Li, Ri);\n        }\n    }\n\n    // Output N\n    printf(\"%d\\n\", n);\n    // Print Li Ri\n    for(int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", ranges[i].first, ranges[i].second);\n    }\n    // Output K\n    printf(\"%d\\n\", K);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 50 -type random\n./gen -n 1 -k 100 -type random\n\n./gen -n 1 -k 50 -type ones\n./gen -n 1 -k 50 -type non-ones\n./gen -n 1 -k 50 -type singles\n\n./gen -n 2 -k 0 -type random\n./gen -n 2 -k 50 -type random\n./gen -n 2 -k 100 -type random\n\n./gen -n 3 -k 33 -type random\n\n./gen -n 500 -k 25 -type random\n./gen -n 500 -k 50 -type ones\n./gen -n 500 -k 75 -type non-ones\n\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 1 -type random\n./gen -n 1000 -k 33 -type random\n./gen -n 1000 -k 50 -type random\n./gen -n 1000 -k 67 -type random\n./gen -n 1000 -k 99 -type random\n./gen -n 1000 -k 100 -type random\n\n./gen -n 1000 -k 0 -type edgeK\n./gen -n 1000 -k 100 -type edgeK\n\n./gen -n 1000 -k 50 -type ones\n./gen -n 1000 -k 50 -type non-ones\n./gen -n 1000 -k 50 -type singles\n./gen -n 1000 -k 50 -type large\n./gen -n 1000 -k 50 -type small\n\n./gen -n 1000 -k 50 -type edgeLiRiEqual\n\n./gen -n 1000 -k 0 -type non-ones\n./gen -n 1000 -k 100 -type ones\n\n./gen -n 1000 -k 50 -type random\n./gen -n 1000 -k 0 -type random\n./gen -n 1000 -k 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:38.157687",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "54/D",
      "title": "D. Сочинение песни",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записаны числа N и K — соответственно длина искомой строки и размер алфавита. Ограничения: 1 ≤ N ≤ 100, 2 ≤ K ≤ 26.Во второй строке записано имя P — непустая строка длиной не более N символов, состоящая только из первых K символов английского алфавита (в нижнем регистре).В третьей строке находится строка длины N - length(P) + 1, состоящая только из нулей и единиц. Единица в i-ой позиции означает, что в этом месте должно начинаться вхождение имени P, ноль — что вхождения в этой позиции быть не должно.",
      "output_spec": "Выходные данныеВыведите искомое слово S. Если ответов несколько, выведите любой.Если решение не существует, выведите «No solution».",
      "sample_tests": "ПримерыВходные данныеСкопировать5 2aba101Выходные данныеСкопироватьababaВходные данныеСкопировать5 2a10001Выходные данныеСкопироватьabbbaВходные данныеСкопировать6 2abba101Выходные данныеСкопироватьNo solution",
      "description": "D. Сочинение песни\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны числа N и K — соответственно длина искомой строки и размер алфавита. Ограничения: 1 ≤ N ≤ 100, 2 ≤ K ≤ 26.Во второй строке записано имя P — непустая строка длиной не более N символов, состоящая только из первых K символов английского алфавита (в нижнем регистре).В третьей строке находится строка длины N - length(P) + 1, состоящая только из нулей и единиц. Единица в i-ой позиции означает, что в этом месте должно начинаться вхождение имени P, ноль — что вхождения в этой позиции быть не должно.\n\nВходные данные\n\nВыходные данныеВыведите искомое слово S. Если ответов несколько, выведите любой.Если решение не существует, выведите «No solution».\n\nВыходные данные\n\nВходные данныеСкопировать5 2aba101Выходные данныеСкопироватьababaВходные данныеСкопировать5 2a10001Выходные данныеСкопироватьabbbaВходные данныеСкопировать6 2abba101Выходные данныеСкопироватьNo solution\n\nВходные данныеСкопировать5 2aba101\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьababa\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 2a10001\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьabbba\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 2abba101\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNo solution\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #50 - Codeforces",
          "content": "Привет, кодефорсчане!Этот очередной, 50-й по счёту, раунд Codeforces провожу я, Макс Иванов (e-maxx).Приглашаю на него всех школьников, только что вернувшихся из ЛКШ.Зима - чтобы не давать лишней передышки своим мозгам, а студентов - чтобы отвлечься от всех забот-хлопот, связанных с таким страшным явлением как Сессия :)Контест окончен, в этот раз никому не удалось сдать все задачи.Поздравляем победителя RAVEman!Разборы задач:задача Cзадача Dзадача E Условия:Русские условия в PDFАнглийские условия в PDFЗадачи этого раунда - это пять историй из жизни одного Ёжика (не удивляйтесь, просто ёжики - мои самые любимые существа :) ).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 632
        },
        {
          "title": "codeforces.com | 502: Bad gateway",
          "content": "codeforces.com | 502: Bad gateway Bad gateway Error code 502 Visit cloudflare.com for more information. 2025-08-24 18:45:07 UTC You Browser Working Singapore Cloudflare Working codeforces.com Host Error What happened? The web server reported a bad gateway error. What can I do? Please try again in a few minutes. Cloudflare Ray ID: 97450134d88f9de7 • Your IP: Click to reveal 137.132.214.135 • Performance &amp; security by Cloudflare",
          "author": "Unknown",
          "url": "https://codeforces.com/blog/entry/1085",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 434
        },
        {
          "title": "Codeforces Beta Round #50: Разбор задачи D - Codeforces",
          "content": "Расскажу авторское решение этой задачи.Решение методом динамического программирования: состояние - это пара (pos, pref), где pos - позиция в набираемой нами строке-ответе (т.е. от 0 до n), а pref - текущий набранный префикс образца P (т.е. это число от 0 до length(P)). Значение pref будет помогать нам контролировать вхождения образца P: если pref = length(P), то это означает, что в этом месте оканчивается очередное вхождение образца P (а начиналось это вхождение в позиции pos - length(P)).Значение динамики равно true, если это состояние достижимо. Мы стартуем из состояния (0, 0) и хотим прийти в состояние с pos = n.При этом в самой динамике мы делаем такие переходы: мы перебираем очередной приписываемый к ответу символ C, и переходим в состояние (pos + 1, newpref), где newpref - это новая подсчитанная длина набранного префикса. Ограничения позволяли пересчитывать это значение newpref втупую, т.е. просто ища в строке P подстроки вида P[length(P) - oldpref..length(P)] + C.Например, если P = ab, и pref = 1, то при переходе по C = a мы перейдём в newpref = 1 (т.к. к строке a приписали букву a - и получилась aa, но у неё наидлиннейший суффикс, совпадающий с префиксом P, равен a. А вот при переходе по букве C = b мы перейдём в состояние newpref = 2. При переходе по любой другой букве мы перейдём в состояние newpref = 0.Но на самом деле, конечно, здесь угадывается алгоритм префикс-функции: мы фактически отвечаем на запрос \"у нас был набран какой-то префикс образца P, и к нему добавили один символ C - какой будет новый префикс\"? На такие запросы как раз и отвечает префикс-функция, и более того, ответы на все такие запросы (запрос - это пара (pref, C)) можно посчитать заранее и брать из таблички (это называется автоматом по префикс-функции).Так или иначе, если мы смогли посчитать значение newpref, то дальше всё становится просто: мы умеем делать переходы в динамике, потом нужно будет только восстановить по динамике ответ.Если искать newpref самым кошерным способом - с помощью автомата по префикс-функции, то решение получается за асимптотику O(kn2), но, повторюсь, в задаче проходили решения и с худшими асимпотиками (чтобы не усложнять эту задачу чрезмерно).P.S. Эта задача интересна тем, что по ней можно придумать всякие нечёткие решения, которые наверняка прошли у участников этого контеста. Одно из таких простых решений, которое не удалось завалить даже спустя пару суток стресса, я напишу чуть позже в комментах.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2445
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Beta Round #50 - Codeforces - Code 1",
          "code": "if (bestX == -1 || bestX * bestY > x * y || bestX * bestY == x * y && x > y)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #50 - Codeforces - Code 2",
          "code": "Должно быть:",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #50 - Codeforces - Code 3",
          "code": "if (bestX == -1 || bestX * bestY > x * y || bestX * bestY == x * y && bestX > x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1083",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Beta Round #50 - Codeforces - Code 4",
          "code": "if (bestX == -1 || bestX * bestY > x * y || bestX * bestY == x * y && bestX > x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/1083",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(2, 26, \"K\");\n    inf.readEoln();\n\n    string P = inf.readToken();\n\n    ensuref(!P.empty(), \"P must be non-empty\");\n    ensuref((int)P.size() <= N, \"P length must be ≤ N\");\n\n    for (char c : P) {\n        ensuref('a' <= c && c <= 'a' + K - 1, \"P contains invalid character '%c'\", c);\n    }\n\n    inf.readEoln();\n\n    int s_len = N - (int)P.size() + 1;\n    string S = inf.readToken();\n\n    ensuref((int)S.size() == s_len, \"Third line must be of length N - length(P) + 1\");\n\n    for (char c : S) {\n        ensuref(c == '0' || c == '1', \"Third line must consist of '0' and '1'\");\n    }\n\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(2, 26, \"K\");\n    inf.readEoln();\n\n    string P = inf.readToken();\n\n    ensuref(!P.empty(), \"P must be non-empty\");\n    ensuref((int)P.size() <= N, \"P length must be ≤ N\");\n\n    for (char c : P) {\n        ensuref('a' <= c && c <= 'a' + K - 1, \"P contains invalid character '%c'\", c);\n    }\n\n    inf.readEoln();\n\n    int s_len = N - (int)P.size() + 1;\n    string S = inf.readToken();\n\n    ensuref((int)S.size() == s_len, \"Third line must be of length N - length(P) + 1\");\n\n    for (char c : S) {\n        ensuref(c == '0' || c == '1', \"Third line must consist of '0' and '1'\");\n    }\n\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int N = inf.readInt(1, 100, \"N\");\n    inf.readSpace();\n    int K = inf.readInt(2, 26, \"K\");\n    inf.readEoln();\n\n    string P = inf.readToken();\n\n    ensuref(!P.empty(), \"P must be non-empty\");\n    ensuref((int)P.size() <= N, \"P length must be ≤ N\");\n\n    for (char c : P) {\n        ensuref('a' <= c && c <= 'a' + K - 1, \"P contains invalid character '%c'\", c);\n    }\n\n    inf.readEoln();\n\n    int s_len = N - (int)P.size() + 1;\n    string S = inf.readToken();\n\n    ensuref((int)S.size() == s_len, \"Third line must be of length N - length(P) + 1\");\n\n    for (char c : S) {\n        ensuref(c == '0' || c == '1', \"Third line must consist of '0' and '1'\");\n    }\n\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint N, K;\nstring P, positions;\n\nbool isValid(const string& S) {\n    if (int(S.length()) != N)\n        return false;\n    // Check letters\n    for(char c : S) {\n        if (c < 'a' || c >= 'a' + K)\n            return false;\n    }\n    int lenP = P.length();\n    int pos_len = N - lenP + 1;\n    if (int(positions.length()) != pos_len)\n        return false;\n\n    for (int i = 0; i <= N - lenP; ++i) {\n        if (positions[i] == '1') {\n            if (S.substr(i, lenP) != P)\n                return false;\n        } else if (positions[i] == '0') {\n            if (S.substr(i, lenP) == P)\n                return false;\n        } else {\n            return false; // positions[i] is invalid character\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read N and K\n    N = inf.readInt();\n    K = inf.readInt();\n\n    // Read P\n    P = inf.readToken();\n\n    // Read positions string\n    positions = inf.readToken();\n\n    // Read judge's answer\n    string ans_s = ans.readLine();\n\n    // Read participant's answer\n    string contestant_s = ouf.readLine();\n\n    if (ans_s == \"No solution\") {\n        if (contestant_s == \"No solution\") {\n            quitf(_ok, \"Correct: No solution\");\n        } else {\n            if (isValid(contestant_s)) {\n                quitf(_fail, \"Participant found a solution but jury says No solution\");\n            } else {\n                quitf(_wa, \"Participant's solution is invalid\");\n            }\n        }\n    } else {\n        if (contestant_s == \"No solution\") {\n            quitf(_wa, \"Participant failed to find a solution\");\n        } else {\n            if (isValid(contestant_s)) {\n                quitf(_ok, \"Correct solution\");\n            } else {\n                quitf(_wa, \"Participant's solution is invalid\");\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\");\n    int K = opt<int>(\"k\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    int len_p;\n    string P;\n    int M;\n    string T;\n\n    // Ensure N and K are within acceptable limits\n    N = max(1, min(N, 100)); // 1 ≤ N ≤ 100\n    K = max(2, min(K, 26));  // 2 ≤ K ≤ 26\n\n    // Prepare the alphabet letters from 'a' to 'a' + K - 1\n    vector<char> letters;\n    for (int i = 0; i < K; ++i) {\n        letters.push_back('a' + i);\n    }\n\n    // Determine the length of P based on the test case type\n    if (type == \"small\") {\n        N = rnd.next(1, 5);\n        len_p = rnd.next(1, N);\n    } else if (type == \"max_size\") {\n        N = 100;\n        len_p = N;\n    } else if (type == \"overlapping\") {\n        len_p = rnd.next(2, min(N, 10)); // Small len_p to illustrate overlapping\n    } else if (type == \"impossible\") {\n        len_p = rnd.next(1, N);\n    } else if (type == \"non_overlapping\") {\n        len_p = rnd.next(1, N / 2);\n    } else {\n        // Random test case\n        len_p = rnd.next(1, N);\n    }\n    M = N - len_p + 1;\n\n    // Generate the friend's name P\n    P = \"\";\n    for (int i = 0; i < len_p; ++i) {\n        P += letters[rnd.next(0, K - 1)];\n    }\n\n    // Generate the occurrence positions T based on the test case type\n    if (type == \"random\" || type == \"small\") {\n        T = \"\";\n        for (int i = 0; i < M; ++i) {\n            T += rnd.next(0, 1) ? '1' : '0';\n        }\n    } else if (type == \"overlapping\") {\n        T = string(M, '0');\n        // Set '1's to create overlapping occurrences\n        for (int i = 0; i < M; i += len_p - 1) {\n            T[i] = '1';\n        }\n    } else if (type == \"non_overlapping\") {\n        T = string(M, '0');\n        // Set '1's to create non-overlapping occurrences\n        for (int i = 0; i < M; i += len_p) {\n            T[i] = '1';\n        }\n    } else if (type == \"impossible\") {\n        // Construct an impossible case\n        P = string(len_p, letters[0]); // P consists of the same character\n        T = string(M, '1');\n        if (M > 1) {\n            T[1] = '0'; // Making it impossible to place P without overlapping into a '0'\n        }\n    } else if (type == \"max_size\") {\n        T = string(M, '1');\n    } else {\n        // Default random case\n        T = \"\";\n        for (int i = 0; i < M; ++i) {\n            T += rnd.next(0, 1) ? '1' : '0';\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", N, K);\n    printf(\"%s\\n\", P.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt<int>(\"n\");\n    int K = opt<int>(\"k\", 2);\n    string type = opt<string>(\"type\", \"random\");\n\n    int len_p;\n    string P;\n    int M;\n    string T;\n\n    // Ensure N and K are within acceptable limits\n    N = max(1, min(N, 100)); // 1 ≤ N ≤ 100\n    K = max(2, min(K, 26));  // 2 ≤ K ≤ 26\n\n    // Prepare the alphabet letters from 'a' to 'a' + K - 1\n    vector<char> letters;\n    for (int i = 0; i < K; ++i) {\n        letters.push_back('a' + i);\n    }\n\n    // Determine the length of P based on the test case type\n    if (type == \"small\") {\n        N = rnd.next(1, 5);\n        len_p = rnd.next(1, N);\n    } else if (type == \"max_size\") {\n        N = 100;\n        len_p = N;\n    } else if (type == \"overlapping\") {\n        len_p = rnd.next(2, min(N, 10)); // Small len_p to illustrate overlapping\n    } else if (type == \"impossible\") {\n        len_p = rnd.next(1, N);\n    } else if (type == \"non_overlapping\") {\n        len_p = rnd.next(1, N / 2);\n    } else {\n        // Random test case\n        len_p = rnd.next(1, N);\n    }\n    M = N - len_p + 1;\n\n    // Generate the friend's name P\n    P = \"\";\n    for (int i = 0; i < len_p; ++i) {\n        P += letters[rnd.next(0, K - 1)];\n    }\n\n    // Generate the occurrence positions T based on the test case type\n    if (type == \"random\" || type == \"small\") {\n        T = \"\";\n        for (int i = 0; i < M; ++i) {\n            T += rnd.next(0, 1) ? '1' : '0';\n        }\n    } else if (type == \"overlapping\") {\n        T = string(M, '0');\n        // Set '1's to create overlapping occurrences\n        for (int i = 0; i < M; i += len_p - 1) {\n            T[i] = '1';\n        }\n    } else if (type == \"non_overlapping\") {\n        T = string(M, '0');\n        // Set '1's to create non-overlapping occurrences\n        for (int i = 0; i < M; i += len_p) {\n            T[i] = '1';\n        }\n    } else if (type == \"impossible\") {\n        // Construct an impossible case\n        P = string(len_p, letters[0]); // P consists of the same character\n        T = string(M, '1');\n        if (M > 1) {\n            T[1] = '0'; // Making it impossible to place P without overlapping into a '0'\n        }\n    } else if (type == \"max_size\") {\n        T = string(M, '1');\n    } else {\n        // Default random case\n        T = \"\";\n        for (int i = 0; i < M; ++i) {\n            T += rnd.next(0, 1) ? '1' : '0';\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", N, K);\n    printf(\"%s\\n\", P.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 2 -type small\n./gen -n 5 -k 2 -type random\n./gen -n 10 -k 3 -type overlapping\n./gen -n 10 -k 3 -type non_overlapping\n./gen -n 20 -k 4 -type overlapping\n./gen -n 20 -k 4 -type impossible\n./gen -n 30 -k 5 -type random\n./gen -n 50 -k 6 -type random\n./gen -n 100 -k 10 -type random\n./gen -n 100 -k 26 -type random\n./gen -n 100 -k 26 -type overlapping\n./gen -n 100 -k 2 -type overlapping\n./gen -n 25 -k 26 -type impossible\n./gen -n 25 -k 2 -type impossible\n./gen -n 100 -k 2 -type non_overlapping\n./gen -n 99 -k 3 -type non_overlapping\n./gen -n 5 -k 2 -type max_size\n./gen -n 100 -k 2 -type max_size\n./gen -n 1 -k 2 -type small\n./gen -n 2 -k 2 -type small\n./gen -n 10 -k 2 -type small\n./gen -n 10 -k 2 -type random\n./gen -n 5 -k 2 -type random\n./gen -n 5 -k 2 -type impossible\n./gen -n 20 -k 5 -type overlapping\n./gen -n 20 -k 5 -type non_overlapping\n./gen -n 50 -k 10 -type overlapping\n./gen -n 50 -k 10 -type random\n./gen -n 80 -k 26 -type impossible\n./gen -n 80 -k 26 -type non_overlapping\n./gen -n 100 -k 26 -type max_size\n./gen -n 100 -k 2 -type max_size\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:40.282152",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "54/E",
      "title": "E. Vacuum Сleaner",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer N which represents the number of vertices of the vacuum cleaner's polygon (3 ≤ N ≤ 4·104). Then follow N lines each containing two numbers — the coordinates of a vertex of the polygon. All the coordinates are integer and their absolute values do not exceed 106.It is guaranteed that the given polygon is nondegenerate and convex (no three points lie on the same line). The polygon vertices are given in a clockwise or counter-clockwise direction.",
      "output_spec": "OutputPrint the minimum possible uncovered area. The answer will be accepted if it is within 10 - 6 of absolute or relative error from the correct answer.",
      "sample_tests": "ExamplesInputCopy40 01 01 10 1OutputCopy0.00000000000000000000InputCopy81 22 12 -11 -2-1 -2-2 -1-2 1-1 2OutputCopy0.50000000000000000000",
      "description": "E. Vacuum Сleaner\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer N which represents the number of vertices of the vacuum cleaner's polygon (3 ≤ N ≤ 4·104). Then follow N lines each containing two numbers — the coordinates of a vertex of the polygon. All the coordinates are integer and their absolute values do not exceed 106.It is guaranteed that the given polygon is nondegenerate and convex (no three points lie on the same line). The polygon vertices are given in a clockwise or counter-clockwise direction.\n\nOutputPrint the minimum possible uncovered area. The answer will be accepted if it is within 10 - 6 of absolute or relative error from the correct answer.\n\nInputCopy40 01 01 10 1OutputCopy0.00000000000000000000InputCopy81 22 12 -11 -2-1 -2-2 -1-2 1-1 2OutputCopy0.50000000000000000000\n\nInputCopy40 01 01 10 1\n\nOutputCopy0.00000000000000000000\n\nInputCopy81 22 12 -11 -2-1 -2-2 -1-2 1-1 2\n\nOutputCopy0.50000000000000000000",
      "solutions": [
        {
          "title": "Codeforces Beta Round #50 - Codeforces",
          "content": "Hello, CodeForceans!This CodeForces Round, 50-th already, will be carried out by me, Max Ivanov (e-maxx).I invite to this round all schoolchildren who have just returned from their training camp \"LKSH.Winter\" - not to give their brains an excess respite, and all students - to distract from all the troubles caused by such a fearful phenomenon as the Examinations :)The contest is over, congratulations for the winner - RAVEman!Problem editorials:problem Cproblem Dproblem EProblem Statements:Russian Statements in PDFEnglish Statements in PDFThe problems in this round will be five stories from a life of one Hedgehog (don't be surprised - hedgehogs are my loved creatures :) ).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1083",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 679
        },
        {
          "title": "Codeforces Beta Round #50: Editorial for problem E - Codeforces",
          "content": "The most important step on the way to solve this problem - is to understand that it's enough to consider only such rotations of the polygon, that one of its sides lies on the side of the room.Let's try to understand this fact. Suppose that the fact is wrong, and there exists such a position of vacuum cleaner, that neither of its sides lies on the side of the room. Denote as i and j the numbers of vertices that lie on the room sides. It's easy to understand that the polygon form between vertices i and j doesn't make any sense itself: for each rotation we can see that from the area of triangle OP[i]P[j] some constant area is subtracted, while the concrete value of this constant depends on the polygon form.That's why we see that the polygon form doesn't influence on anything (if we have fixed numbers i and j), and we have just to minimize the area of right-angled triangle OP[i]P[j]. But, taking into account that its hypotenuse is a constant, it's easy to see that the minimum is reached in borderline cases: i.e. when one of the polygon sides lies on the room side.So, we've proved the fact. Then we have to invent fast enough solution. We have already obtained an O(n2) solution: iterate over all sides of the polygon (i.e. iterating over all possible i), mentally push it to one side of the room, then find the threshold point j, then calculate answer for given i and j. Let's learn how to do these both things in O(1).In order to do the first thing (finding j) we can use a method of moving pointer: if we iterate over i in the same order as in the input file, then we can just maintain the right value of j (i.e. when we move from i to i + 1 we have to increase j several times, while it is getting further and further).In order to do the second thing (the area calculation) we have to do some precalculation. For example, we can find the mass center Q of the vacuum cleaner, and pre-calculate all partial sums S[i] - sums of all triangles QP[j - 1]P[j] for all j ≤ i. After this precalculation we can get the answer for every i and j in O(1) as a combination of difference of two values from S[] and two triangles' areas: QP[i]P[j] and OP[i]P[j].",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1085",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2162
        },
        {
          "title": "Codeforces Beta Round #50: Разбор задачи D - Codeforces",
          "content": "I'll describe here an author's solution for this problem.The solution is by a method of dynamic programming: the state is a pair (pos, pref), where pos - the position in the string built (it is between 0 and n), and pref - the current prefix of pattern P (i.e. this is a number between 0 and length(P)). The value pref will help us to control all occurences of pattern P: if pref = length(P) then it means that here is an ending of occurence of pattern P (the beginning of the occurence was at pos - length(P)).The value D[pos][pref] of the dynamic is true, if the state is reachable. We start from the state (0, 0) and want to get to any state with pos = n.How to make moves in the dynamic? We iterate over all possible characters C and try to add it to the current answer. That's why we get into a stage (pos + 1, newpref), where newpref is a new length of prefix of P. The problem constraints permitted to calculate this value newpref easily, i.e. just by searching for substrings of form P[length(P) - oldpref..length(P)] + C in the pattern P.For example, if P = ab and pref = 1, then with the character C = a we will get into newpref = 1 (because we added character a to the string a, - we got string aa, but its longest suffix matching with the prefix of string P equals to a). If we took C = b then we would get into state newpref = 2. Any other character would move us into the state with newprefix = 0.But in reality, of course, an algorithm for calculating prefix-function can be guessed here. Really, in fact, we answer the following query: \"we had some prefix of pattern P and added character C by its end - so what will be the new prefix?\". These queries are answered exactly by prefix-function algorithm. Moreover, we can pre-calculate answers to all of these queries in some table and get answers for them in O(1) from the table. This is called an automaton built over the prefix-function.One way or another, if we've taught how to calculate newpref, then everything is quite simple: we know how to make movements in dynamics from one state to another. After getting the solution we'll have just to restore the answer-string itself.The solution's asymptotics depends on the way we chose to calculate newpref. The fastest way is using the prefix-function automaton, and the asymptotics in this case is O(kn2). But, I remind, the problem's constraints allowed to choose some simpler way with worse asymptotics.P.S. This problem was additionally interesting by the fact that one can invent many strange simple solutions, which are very difficult to prove (and most of them will have counter-examples, but very rare ones). Some of these tricky solutions passed all systests in the round. I have also created one relatively simple solution that looks rather unlike to be right, but we didn't manage to create counter-example even after several hours of stress :)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1087",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2872
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 40000, \"N\");\n    inf.readEoln();\n    vector<Point> points;\n    set<pair<int,int>> pointSet;\n    for (int i = 0; i < N; ++i) {\n        int x = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n        ensuref(pointSet.insert({x, y}).second, \"Duplicate point at position %d : (%d, %d)\", i+1, x, y);\n        points.push_back({x, y});\n    }\n    // Check that the polygon is convex and nondegenerate (no three colinear points)\n    int orientation = 0; // 0: not yet determined, 1: positive, -1: negative\n    for (int i = 0; i < N; ++i) {\n        Point a = points[i];\n        Point b = points[(i+1)%N];\n        Point c = points[(i+2)%N];\n        ll dx1 = b.x - a.x;\n        ll dy1 = b.y - a.y;\n        ll dx2 = c.x - b.x;\n        ll dy2 = c.y - b.y;\n        ll cross = dx1 * dy2 - dy1 * dx2;\n        ensuref(cross != 0, \"Three consecutive points are colinear at positions %d, %d, %d\", i+1, (i+2)%N+1, (i+3)%N+1);\n        int sign = (cross > 0) ? 1 : -1;\n        if (orientation == 0) {\n            orientation = sign;\n        } else {\n            ensuref(sign == orientation, \"Polygon is not convex at positions %d, %d, %d\", i+1, (i+2)%N+1, (i+3)%N+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 40000, \"N\");\n    inf.readEoln();\n    vector<Point> points;\n    set<pair<int,int>> pointSet;\n    for (int i = 0; i < N; ++i) {\n        int x = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n        ensuref(pointSet.insert({x, y}).second, \"Duplicate point at position %d : (%d, %d)\", i+1, x, y);\n        points.push_back({x, y});\n    }\n    // Check that the polygon is convex and nondegenerate (no three colinear points)\n    int orientation = 0; // 0: not yet determined, 1: positive, -1: negative\n    for (int i = 0; i < N; ++i) {\n        Point a = points[i];\n        Point b = points[(i+1)%N];\n        Point c = points[(i+2)%N];\n        ll dx1 = b.x - a.x;\n        ll dy1 = b.y - a.y;\n        ll dx2 = c.x - b.x;\n        ll dy2 = c.y - b.y;\n        ll cross = dx1 * dy2 - dy1 * dx2;\n        ensuref(cross != 0, \"Three consecutive points are colinear at positions %d, %d, %d\", i+1, (i+2)%N+1, (i+3)%N+1);\n        int sign = (cross > 0) ? 1 : -1;\n        if (orientation == 0) {\n            orientation = sign;\n        } else {\n            ensuref(sign == orientation, \"Polygon is not convex at positions %d, %d, %d\", i+1, (i+2)%N+1, (i+3)%N+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    int x, y;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 40000, \"N\");\n    inf.readEoln();\n    vector<Point> points;\n    set<pair<int,int>> pointSet;\n    for (int i = 0; i < N; ++i) {\n        int x = inf.readInt(-1000000, 1000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-1000000, 1000000, \"y_i\");\n        inf.readEoln();\n        ensuref(pointSet.insert({x, y}).second, \"Duplicate point at position %d : (%d, %d)\", i+1, x, y);\n        points.push_back({x, y});\n    }\n    // Check that the polygon is convex and nondegenerate (no three colinear points)\n    int orientation = 0; // 0: not yet determined, 1: positive, -1: negative\n    for (int i = 0; i < N; ++i) {\n        Point a = points[i];\n        Point b = points[(i+1)%N];\n        Point c = points[(i+2)%N];\n        ll dx1 = b.x - a.x;\n        ll dy1 = b.y - a.y;\n        ll dx2 = c.x - b.x;\n        ll dy2 = c.y - b.y;\n        ll cross = dx1 * dy2 - dy1 * dx2;\n        ensuref(cross != 0, \"Three consecutive points are colinear at positions %d, %d, %d\", i+1, (i+2)%N+1, (i+3)%N+1);\n        int sign = (cross > 0) ? 1 : -1;\n        if (orientation == 0) {\n            orientation = sign;\n        } else {\n            ensuref(sign == orientation, \"Polygon is not convex at positions %d, %d, %d\", i+1, (i+2)%N+1, (i+3)%N+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1e6;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"triangle\") {\n        // Generate a triangle\n        if (n != 3) {\n            cerr << \"n must be 3 for type triangle\" << endl;\n            exit(1);\n        }\n        points.push_back({0, 0});\n        points.push_back({M, 0});\n        points.push_back({0, M});\n    } else if (type == \"square\") {\n        // Generate a square\n        if (n != 4) {\n            cerr << \"n must be 4 for type square\" << endl;\n            exit(1);\n        }\n        points.push_back({0, 0});\n        points.push_back({M, 0});\n        points.push_back({M, M});\n        points.push_back({0, M});\n    } else if (type == \"regular\") {\n        // Generate a regular polygon\n        double R = 1e6 * 0.8;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * M_PI * i / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int)(x + 0.5); // Round to nearest integer\n            int yi = (int)(y + 0.5);\n            points.push_back({xi, yi});\n        }\n    } else if (type == \"random\") {\n        // Generate a random convex polygon\n        vector<int> x_coords, y_coords;\n        for (int i = 0; i < n; ++i) {\n            x_coords.push_back(rnd.next(-M/2, M/2));\n            y_coords.push_back(rnd.next(-M/2, M/2));\n        }\n        sort(x_coords.begin(), x_coords.end());\n        sort(y_coords.begin(), y_coords.end());\n\n        vector<int> x_diffs, y_diffs;\n        for (int i = 1; i < n; ++i) {\n            x_diffs.push_back(x_coords[i] - x_coords[i-1]);\n            y_diffs.push_back(y_coords[i] - y_coords[i-1]);\n        }\n\n        // Randomly assign signs and shuffle the differences\n        for (int& dx : x_diffs) {\n            if (rnd.next(0, 1)) dx = -dx;\n        }\n        for (int& dy : y_diffs) {\n            if (rnd.next(0, 1)) dy = -dy;\n        }\n        shuffle(x_diffs.begin(), x_diffs.end());\n        shuffle(y_diffs.begin(), y_diffs.end());\n\n        vector<int> x_vec(n), y_vec(n);\n        x_vec[0] = x_coords[0];\n        y_vec[0] = y_coords[0];\n        for (int i = 1; i < n; ++i) {\n            x_vec[i] = x_vec[i-1] + x_diffs[i-1];\n            y_vec[i] = y_vec[i-1] + y_diffs[i-1];\n        }\n\n        // Compute centroid and sort points by angle\n        long long x_mean = 0;\n        long long y_mean = 0;\n        for (int i = 0; i < n; ++i) {\n            x_mean += x_vec[i];\n            y_mean += y_vec[i];\n        }\n        x_mean /= n;\n        y_mean /= n;\n\n        vector<pair<double, pair<int, int>>> angles_points;\n        for (int i = 0; i < n; ++i) {\n            double angle = atan2(y_vec[i] - y_mean, x_vec[i] - x_mean);\n            angles_points.push_back({angle, {x_vec[i], y_vec[i]}});\n        }\n        sort(angles_points.begin(), angles_points.end());\n        points.clear();\n        for (int i = 0; i < n; ++i) {\n            points.push_back(angles_points[i].second);\n        }\n\n        // Check for colinear points and adjust if necessary\n        bool has_colinear = false;\n        for (int i = 0; i < n; ++i) {\n            int i1 = i;\n            int i2 = (i+1)%n;\n            int i3 = (i+2)%n;\n            int x1 = points[i1].first;\n            int y1 = points[i1].second;\n            int x2 = points[i2].first;\n            int y2 = points[i2].second;\n            int x3 = points[i3].first;\n            int y3 = points[i3].second;\n            long long dx1 = x2 - x1;\n            long long dy1 = y2 - y1;\n            long long dx2 = x3 - x2;\n            long long dy2 = y3 - y2;\n            long long cross = dx1 * dy2 - dy1 * dx2;\n            if (cross == 0) {\n                has_colinear = true;\n                break;\n            }\n        }\n        if (has_colinear) {\n            // Adjust points slightly\n            for (int i = 0; i < n; ++i) {\n                points[i].first += rnd.next(-1,1);\n                points[i].second += rnd.next(-1,1);\n                if (points[i].first < -M) points[i].first = -M;\n                if (points[i].first > M) points[i].first = M;\n                if (points[i].second < -M) points[i].second = -M;\n                if (points[i].second > M) points[i].second = M;\n            }\n        }\n    } else if (type == \"maxcoord\") {\n        // Generate a polygon with maximum coordinate values\n        if (n != 4) {\n            cerr << \"n must be 4 for type maxcoord\" << endl;\n            exit(1);\n        }\n        points.push_back({-M, -M});\n        points.push_back({M, -M});\n        points.push_back({M, M});\n        points.push_back({-M, M});\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the points\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int M = 1e6;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"triangle\") {\n        // Generate a triangle\n        if (n != 3) {\n            cerr << \"n must be 3 for type triangle\" << endl;\n            exit(1);\n        }\n        points.push_back({0, 0});\n        points.push_back({M, 0});\n        points.push_back({0, M});\n    } else if (type == \"square\") {\n        // Generate a square\n        if (n != 4) {\n            cerr << \"n must be 4 for type square\" << endl;\n            exit(1);\n        }\n        points.push_back({0, 0});\n        points.push_back({M, 0});\n        points.push_back({M, M});\n        points.push_back({0, M});\n    } else if (type == \"regular\") {\n        // Generate a regular polygon\n        double R = 1e6 * 0.8;\n        for (int i = 0; i < n; ++i) {\n            double angle = 2.0 * M_PI * i / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int)(x + 0.5); // Round to nearest integer\n            int yi = (int)(y + 0.5);\n            points.push_back({xi, yi});\n        }\n    } else if (type == \"random\") {\n        // Generate a random convex polygon\n        vector<int> x_coords, y_coords;\n        for (int i = 0; i < n; ++i) {\n            x_coords.push_back(rnd.next(-M/2, M/2));\n            y_coords.push_back(rnd.next(-M/2, M/2));\n        }\n        sort(x_coords.begin(), x_coords.end());\n        sort(y_coords.begin(), y_coords.end());\n\n        vector<int> x_diffs, y_diffs;\n        for (int i = 1; i < n; ++i) {\n            x_diffs.push_back(x_coords[i] - x_coords[i-1]);\n            y_diffs.push_back(y_coords[i] - y_coords[i-1]);\n        }\n\n        // Randomly assign signs and shuffle the differences\n        for (int& dx : x_diffs) {\n            if (rnd.next(0, 1)) dx = -dx;\n        }\n        for (int& dy : y_diffs) {\n            if (rnd.next(0, 1)) dy = -dy;\n        }\n        shuffle(x_diffs.begin(), x_diffs.end());\n        shuffle(y_diffs.begin(), y_diffs.end());\n\n        vector<int> x_vec(n), y_vec(n);\n        x_vec[0] = x_coords[0];\n        y_vec[0] = y_coords[0];\n        for (int i = 1; i < n; ++i) {\n            x_vec[i] = x_vec[i-1] + x_diffs[i-1];\n            y_vec[i] = y_vec[i-1] + y_diffs[i-1];\n        }\n\n        // Compute centroid and sort points by angle\n        long long x_mean = 0;\n        long long y_mean = 0;\n        for (int i = 0; i < n; ++i) {\n            x_mean += x_vec[i];\n            y_mean += y_vec[i];\n        }\n        x_mean /= n;\n        y_mean /= n;\n\n        vector<pair<double, pair<int, int>>> angles_points;\n        for (int i = 0; i < n; ++i) {\n            double angle = atan2(y_vec[i] - y_mean, x_vec[i] - x_mean);\n            angles_points.push_back({angle, {x_vec[i], y_vec[i]}});\n        }\n        sort(angles_points.begin(), angles_points.end());\n        points.clear();\n        for (int i = 0; i < n; ++i) {\n            points.push_back(angles_points[i].second);\n        }\n\n        // Check for colinear points and adjust if necessary\n        bool has_colinear = false;\n        for (int i = 0; i < n; ++i) {\n            int i1 = i;\n            int i2 = (i+1)%n;\n            int i3 = (i+2)%n;\n            int x1 = points[i1].first;\n            int y1 = points[i1].second;\n            int x2 = points[i2].first;\n            int y2 = points[i2].second;\n            int x3 = points[i3].first;\n            int y3 = points[i3].second;\n            long long dx1 = x2 - x1;\n            long long dy1 = y2 - y1;\n            long long dx2 = x3 - x2;\n            long long dy2 = y3 - y2;\n            long long cross = dx1 * dy2 - dy1 * dx2;\n            if (cross == 0) {\n                has_colinear = true;\n                break;\n            }\n        }\n        if (has_colinear) {\n            // Adjust points slightly\n            for (int i = 0; i < n; ++i) {\n                points[i].first += rnd.next(-1,1);\n                points[i].second += rnd.next(-1,1);\n                if (points[i].first < -M) points[i].first = -M;\n                if (points[i].first > M) points[i].first = M;\n                if (points[i].second < -M) points[i].second = -M;\n                if (points[i].second > M) points[i].second = M;\n            }\n        }\n    } else if (type == \"maxcoord\") {\n        // Generate a polygon with maximum coordinate values\n        if (n != 4) {\n            cerr << \"n must be 4 for type maxcoord\" << endl;\n            exit(1);\n        }\n        points.push_back({-M, -M});\n        points.push_back({M, -M});\n        points.push_back({M, M});\n        points.push_back({-M, M});\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the points\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, triangle\n./gen -n 3 -type triangle\n\n# Square\n./gen -n 4 -type square\n\n# Regular polygons with various n\n./gen -n 5 -type regular\n./gen -n 10 -type regular\n./gen -n 100 -type regular\n./gen -n 1000 -type regular\n./gen -n 10000 -type regular\n./gen -n 39999 -type regular\n\n# Random convex polygons with small n\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n\n# Random convex polygons with large n\n./gen -n 40000 -type random\n\n# Max coordinate polygon\n./gen -n 4 -type maxcoord\n\n# Edge cases with n = 3 and random type\n./gen -n 3 -type random\n\n# Random convex polygons with mid-size n\n./gen -n 20000 -type random\n./gen -n 30000 -type random\n\n# Regular polygons with mid-size n\n./gen -n 20000 -type regular\n./gen -n 30000 -type regular\n\n# Random convex polygons to test precision\n./gen -n 10000 -type random\n\n# Additional small random polygons\n./gen -n 6 -type random\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 9 -type random\n./gen -n 10 -type random\n\n# Regular polygons with minimal n\n./gen -n 3 -type regular\n./gen -n 4 -type regular\n\n# Random convex polygons with n close to 4e4\n./gen -n 39998 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:42.167162",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "540/A",
      "title": "A. Combination Lock",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of disks on the combination lock.The second line contains a string of n digits — the original state of the disks.The third line contains a string of n digits — Scrooge McDuck's combination that opens the lock.",
      "output_spec": "OutputPrint a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.",
      "sample_tests": "ExamplesInputCopy58219564723OutputCopy13",
      "description": "A. Combination Lock\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 1000) — the number of disks on the combination lock.The second line contains a string of n digits — the original state of the disks.The third line contains a string of n digits — Scrooge McDuck's combination that opens the lock.\n\nOutputPrint a single integer — the minimum number of moves Scrooge McDuck needs to open the lock.\n\nInputCopy58219564723OutputCopy13\n\nInputCopy58219564723\n\nOutputCopy13\n\nNoteIn the sample he needs 13 moves:  1 disk:   2 disk:   3 disk:   4 disk:   5 disk:",
      "solutions": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "Hi all,I was honored to open the fourth hundred of Codeforces Rounds. Unfornunately, neither I nor my friends couldn't invent any hard problems, so it's only a Div. 2 Round. But we'll definitely prepare a full round in the future! As always, I thank Zlobober for his help in preparing the problems, Delinur for English translations and MikeMirzayanov for the Codeforces itself.The problems must be pretty easy for Div. 1 guys, so let's start a challenge: reds should solve everything in 30 minutes, yellows — in 1 hour, and violets — in 1 hour and a half. How many people will be able to make a success?The score distribution will be standard. Wish you accepted solutions and successful hacks!UPD 1. Congratulations to the winners in Div. 2: PauGra cuvwqe496 tgehr and in Div. 1: niyaznigmatul I_love_Tanya_Romanova dreamoon_love_AA UPD 2. This is the editorial: /blog/entry/17643.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17636",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 881
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "540A - Combination LockFor every symbol we should determine how to rotate the disk. This can be done either by formula: min(abs(a[i] - b[i]), 10 - abs(a[i] - b[i])) or even by the two for cycles: in both directions.540B - School MarksFirst count the number of marks that are less than y. If there are more than such marks, we can't satisfy the second condition (about the median), and the answer is -1. Otherwise we can get exactly such number of y marks so that the total number of marks greater than or equal to y is at least (maybe it's already satisfied). This is the required action for satisfying the second condition.Now, in order not to break the first condition, get the remaining marks as lower as possible — all ones — and check the sum of the marks. If it is greater than x, the answer is -1, otherwise the correct answer is found.540C - Ice CaveThere are three cases here, though some of them can be merged. If the start and finish cells are equal, let's count the intact neighbours of this cell. If there is one, move there and instantly move back — the answer is YES. Otherwise it's NO. If the start and finish cells are neighbours, the solution depends on the type of the destination cell. If it's cracked, the answer is YES — we can just move there and fall down. Otherwise it must have at least one intact neighbour to get the positive answer — we can move to the finish cell, then to this intact neighbour, and then return to the finish cell. In the general case, check if the path from the start cell to the finish cell exists. If it doesn't, the answer is NO. Otherwise check the type of the destination cell. If it's cracked, it must have at least one intact neighbour, and if it's intact, it must have two intact neighbours. 540D - Bad Luck Island (my code: http://pastebin.com/3s6dRK3A)Let's count the values dp[r][s][p] — the probability of the situation when r rocks, s scissors and p papers are alive. The initial probability is 1, and in order to calculate the others we should perform the transitions.Imagine we have r rocks, s scissors and p papers. Let's find the probability of the rock killing scissors (the other probabilities are calculated in the same way). The total number of the possible pairs where one species kills the other one is rs + rp + sp, and the number of possible pairs (rock, scissors) is rs. As all meetings are equiprobable, the probability we want to find is . This is the probability with which we go the the state dp[r][s — 1][p], with the number of scissors less by one.In the end, for example, to get the probability of the event that the rocks are alive, we should sum all values dp[i][0][0] for i from 1 to r (the same goes to the other species).540E - Infinite Inversions (my code: http://pastebin.com/QFEMRbNP)At first find the position of each element which is used in swap (using map). Now let's find the answer. It consists of the two parts. First part is the number of inversions formed by only whose elements which took part in the swaps. They can be counted by one of the standard ways: mergesort or Fenwick tree. The second part is the number of inversions formed by pairs of elements where one element has been swapped even once, and the other element stayed at his position. Let's consider the following test: 2\n2 6\n4 8The global sequence will look as follows: [1 6 3 8 5 2 7 4 9 ...], and here is the array of swapped elements: [6 8 2 4].Let's understand with which numbers the number 8 forms the inversions. The only elements that could do that are the elements between the initial position of the number 8 (where the number 4 is now) and its current position: [5 2 7]. There are two numbers on this segment which didn't take part in swaps: 5 and 7. The number 2 should not be counted as it took part in the swaps and we have already counted it in the first part of the solution.So we should take the count of numbers between 8's indices in the global sequence (8 - 4 - 1 = 3) and subtract the count of numbers between its indices in the swaps array (4 - 2 - 1 = 1). We'll get the number of inversions formed by the element 8 and the elements which haven't moved at all, it's 2. Counting this value for all elements which have been swapped at least once, we get the second part of the answer. All operations in the second part of the solution can be performed using sorts and binary searches.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17643",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 540\\s*A"
          },
          "content_length": 4366
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "violets solve everything in 1 hour and a half",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "I will solve these problems in 2 hour",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "Until the contest over, I still haven't finished all problems",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 4",
          "code": "I am Stupid-Dog",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 5",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 6",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 7",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 8",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 9",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 10",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 11",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 12",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 14",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 15",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 16",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 17",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 18",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 19",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 20",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 21",
          "code": "RR, SS or PP",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 22",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 23",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 24",
          "code": "reds should solve everything in 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 25",
          "code": "pretest pass",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 26",
          "code": "33 minutes > 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 27",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 28",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 29",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 30",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 31",
          "code": "int rs = r*s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 32",
          "code": "int pr = p*r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 33",
          "code": "int sp = s*p;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 34",
          "code": "int tot = rs + pr + sp;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 35",
          "code": "if (s) dp[r][s][p] += getdp(r, s-1, p) * rs / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 36",
          "code": "if (r) dp[r][s][p] += getdp(r-1, s, p) * pr / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 37",
          "code": "if (p) dp[r][s][p] += getdp(r, s, p-1) * sp / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 38",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 39",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 40",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 41",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[0-9]{\" + to_string(n) + \"}\";\n\n    string s = inf.readToken(pattern, \"original_state\");\n    inf.readEoln();\n\n    string t = inf.readToken(pattern, \"target_combination\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[0-9]{\" + to_string(n) + \"}\";\n\n    string s = inf.readToken(pattern, \"original_state\");\n    inf.readEoln();\n\n    string t = inf.readToken(pattern, \"target_combination\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[0-9]{\" + to_string(n) + \"}\";\n\n    string s = inf.readToken(pattern, \"original_state\");\n    inf.readEoln();\n\n    string t = inf.readToken(pattern, \"target_combination\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string initial_state, target_state;\n\n    if (type == \"random\") {\n        // Generate random initial and target states\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            target_state += char('0' + d);\n        }\n    } else if (type == \"identical\") {\n        // Initial and target states are identical\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        target_state = initial_state;\n    } else if (type == \"max_move\") {\n        // Maximum moves: initial is all '0's, target is all '9's\n        initial_state = string(n, '0');\n        target_state = string(n, '9');\n    } else if (type == \"wrap_around\") {\n        // Test wrap-around cases\n        initial_state = string(n, '0');\n        target_state = initial_state;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                target_state[i] = '9';\n            }\n        }\n    } else if (type == \"max_diff\") {\n        // Difference per disk is always 5\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n            int target_digit = (d + 5) % 10;\n            target_state += char('0' + target_digit);\n        }\n    } else if (type == \"min_moves\") {\n        // Minimal moves: differences per disk are 0 or 1\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n            int offset = rnd.next(-1, 1);\n            int target_digit = (d + offset + 10) % 10;\n            target_state += char('0' + target_digit);\n        }\n    } else if (type == \"alternating\") {\n        // Alternating differences between +5 and -5\n        int d = rnd.next(0, 9);\n        initial_state += char('0' + d);\n        for (int i = 1; i < n; ++i) {\n            d = (d + 1) % 10;\n            initial_state += char('0' + d);\n        }\n        for (int i = 0; i < n; ++i) {\n            int digit = initial_state[i] - '0';\n            int target_digit;\n            if (i % 2 == 0) {\n                target_digit = (digit + 5) % 10;\n            } else {\n                target_digit = (digit - 5 + 10) % 10;\n            }\n            target_state += char('0' + target_digit);\n        }\n    } else if (type == \"single_digit_diff\") {\n        // Only one disk differs\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        target_state = initial_state;\n        int idx = rnd.next(0, n - 1);\n        int digit = initial_state[idx] - '0';\n        int target_digit = rnd.next(0, 9);\n        while (target_digit == digit) {\n            target_digit = rnd.next(0, 9);\n        }\n        target_state[idx] = char('0' + target_digit);\n    } else if (type == \"zeros_to_nines\") {\n        // Initial is all '0's, target is all '9's\n        initial_state = string(n, '0');\n        target_state = string(n, '9');\n    } else if (type == \"random_pairs\") {\n        // Random pairs with various differences\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n            int diff = rnd.next(0, 9);\n            int direction = rnd.next(0, 1) ? 1 : -1;\n            int target_digit = (d + direction * diff + 10) % 10;\n            target_state += char('0' + target_digit);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            target_state += char('0' + d);\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", initial_state.c_str());\n    printf(\"%s\\n\", target_state.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string initial_state, target_state;\n\n    if (type == \"random\") {\n        // Generate random initial and target states\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            target_state += char('0' + d);\n        }\n    } else if (type == \"identical\") {\n        // Initial and target states are identical\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        target_state = initial_state;\n    } else if (type == \"max_move\") {\n        // Maximum moves: initial is all '0's, target is all '9's\n        initial_state = string(n, '0');\n        target_state = string(n, '9');\n    } else if (type == \"wrap_around\") {\n        // Test wrap-around cases\n        initial_state = string(n, '0');\n        target_state = initial_state;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                target_state[i] = '9';\n            }\n        }\n    } else if (type == \"max_diff\") {\n        // Difference per disk is always 5\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n            int target_digit = (d + 5) % 10;\n            target_state += char('0' + target_digit);\n        }\n    } else if (type == \"min_moves\") {\n        // Minimal moves: differences per disk are 0 or 1\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n            int offset = rnd.next(-1, 1);\n            int target_digit = (d + offset + 10) % 10;\n            target_state += char('0' + target_digit);\n        }\n    } else if (type == \"alternating\") {\n        // Alternating differences between +5 and -5\n        int d = rnd.next(0, 9);\n        initial_state += char('0' + d);\n        for (int i = 1; i < n; ++i) {\n            d = (d + 1) % 10;\n            initial_state += char('0' + d);\n        }\n        for (int i = 0; i < n; ++i) {\n            int digit = initial_state[i] - '0';\n            int target_digit;\n            if (i % 2 == 0) {\n                target_digit = (digit + 5) % 10;\n            } else {\n                target_digit = (digit - 5 + 10) % 10;\n            }\n            target_state += char('0' + target_digit);\n        }\n    } else if (type == \"single_digit_diff\") {\n        // Only one disk differs\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        target_state = initial_state;\n        int idx = rnd.next(0, n - 1);\n        int digit = initial_state[idx] - '0';\n        int target_digit = rnd.next(0, 9);\n        while (target_digit == digit) {\n            target_digit = rnd.next(0, 9);\n        }\n        target_state[idx] = char('0' + target_digit);\n    } else if (type == \"zeros_to_nines\") {\n        // Initial is all '0's, target is all '9's\n        initial_state = string(n, '0');\n        target_state = string(n, '9');\n    } else if (type == \"random_pairs\") {\n        // Random pairs with various differences\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n            int diff = rnd.next(0, 9);\n            int direction = rnd.next(0, 1) ? 1 : -1;\n            int target_digit = (d + direction * diff + 10) % 10;\n            target_state += char('0' + target_digit);\n        }\n    } else {\n        // Default to random if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            initial_state += char('0' + d);\n        }\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0, 9);\n            target_state += char('0' + d);\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", initial_state.c_str());\n    printf(\"%s\\n\", target_state.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type identical\n./gen -n 1 -type max_move\n./gen -n 1 -type wrap_around\n./gen -n 1 -type max_diff\n./gen -n 1 -type min_moves\n./gen -n 1 -type alternating\n./gen -n 1 -type single_digit_diff\n./gen -n 1 -type zeros_to_nines\n./gen -n 1 -type random_pairs\n\n./gen -n 10 -type random\n./gen -n 10 -type identical\n./gen -n 10 -type max_move\n./gen -n 10 -type wrap_around\n./gen -n 10 -type max_diff\n./gen -n 10 -type min_moves\n./gen -n 10 -type alternating\n./gen -n 10 -type single_digit_diff\n./gen -n 10 -type zeros_to_nines\n./gen -n 10 -type random_pairs\n\n./gen -n 100 -type random\n./gen -n 100 -type identical\n./gen -n 100 -type max_move\n./gen -n 100 -type wrap_around\n./gen -n 100 -type max_diff\n./gen -n 100 -type min_moves\n./gen -n 100 -type alternating\n./gen -n 100 -type single_digit_diff\n./gen -n 100 -type zeros_to_nines\n./gen -n 100 -type random_pairs\n\n./gen -n 999 -type random\n./gen -n 999 -type min_moves\n\n./gen -n 1000 -type random\n./gen -n 1000 -type identical\n./gen -n 1000 -type max_move\n./gen -n 1000 -type wrap_around\n./gen -n 1000 -type max_diff\n./gen -n 1000 -type min_moves\n./gen -n 1000 -type alternating\n./gen -n 1000 -type single_digit_diff\n./gen -n 1000 -type zeros_to_nines\n./gen -n 1000 -type random_pairs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:44.316263",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "540/B",
      "title": "Problem 540/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 999, \"n\");\n    inf.readSpace();\n\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readSpace();\n    \n    int p = inf.readInt(1, 1000, \"p\");\n    inf.readSpace();\n    \n    int x = inf.readInt(n, n * p, \"x\");\n    inf.readSpace();\n    \n    int y = inf.readInt(1, p, \"y\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be odd but n=%d\", n);\n\n    vector<int> a = inf.readInts(k, 1, p, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    \n    return 0;\n}\n\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 999, \"n\");\n    inf.readSpace();\n\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readSpace();\n    \n    int p = inf.readInt(1, 1000, \"p\");\n    inf.readSpace();\n    \n    int x = inf.readInt(n, n * p, \"x\");\n    inf.readSpace();\n    \n    int y = inf.readInt(1, p, \"y\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be odd but n=%d\", n);\n\n    vector<int> a = inf.readInts(k, 1, p, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    \n    return 0;\n}\n\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h> \nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 999, \"n\");\n    inf.readSpace();\n\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readSpace();\n    \n    int p = inf.readInt(1, 1000, \"p\");\n    inf.readSpace();\n    \n    int x = inf.readInt(n, n * p, \"x\");\n    inf.readSpace();\n    \n    int y = inf.readInt(1, p, \"y\");\n    inf.readEoln();\n\n    ensuref(n % 2 == 1, \"n must be odd but n=%d\", n);\n\n    vector<int> a = inf.readInts(k, 1, p, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    \n    return 0;\n}\n\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to determine whether problem is impossible\nbool isImpossible(int n, int k, int p, int x, int y, vector<int> a) {\n    // We need at least (n + 1) / 2 marks >= y to ensure median >= y\n    int need_at_least_y = (n + 1) / 2;\n\n    int num_y_or_more = 0;\n    for (int i = 0; i < k; ++i) {\n        if (a[i] >= y) num_y_or_more++;\n    }\n\n    int num_more_needed = max(0, need_at_least_y - num_y_or_more);\n\n    int num_remaining = n - k;\n\n    if (num_more_needed > num_remaining) {\n        // Not enough marks can be set to y or more\n        return true; // Impossible\n    }\n\n    // Now, let's compute minimal total sum\n    int total_sum = accumulate(a.begin(), a.end(), 0);\n    total_sum += num_more_needed * y;\n\n    int num_to_set_1 = n - k - num_more_needed;\n    total_sum += num_to_set_1 * 1;\n\n    if (total_sum > x) {\n        return true; // Impossible\n    }\n\n    // So, possible\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    int n = inf.readInt();\n    int k = inf.readInt();\n    int p = inf.readInt();\n    int x = inf.readInt();\n    int y = inf.readInt();\n\n    vector<int> a(k);\n    for (int i = 0; i < k; ++i) {\n        a[i] = inf.readInt(1, p, format(\"a[%d]\", i+1).c_str());\n    }\n\n    // Read participant's output\n    if (ouf.seekEof()) {\n        quitf(_wa, \"No output\");\n    }\n\n    int firstInt = ouf.readInt(-1, p, \"first output integer\");\n\n    if (firstInt == -1) {\n        // Participant claims impossible\n        if (isImpossible(n, k, p, x, y, a)) {\n            if (!ouf.seekEof()) {\n                quitf(_wa, \"Extra output after -1\");\n            }\n            quitf(_ok, \"Correctly stated impossible\");\n        } else {\n            quitf(_wa, \"Participant says impossible, but solution exists\");\n        }\n    } else {\n        // Participant provides a solution\n        vector<int> b(n - k);\n        b[0] = firstInt;\n        if (b[0] < 1 || b[0] > p) {\n            quitf(_wa, \"First mark is not between 1 and p\");\n        }\n        for (int i = 1; i < n - k; ++i) {\n            b[i] = ouf.readInt(1, p, format(\"b[%d]\", i+1).c_str());\n        }\n\n        if (!ouf.seekEof()) {\n            quitf(_wa, \"Extra output after expected marks\");\n        }\n\n        // Now, we can proceed to check whether the given marks satisfy the constraints\n\n        vector<int> marks = a;\n        marks.insert(marks.end(), b.begin(), b.end());\n\n        if ((int)marks.size() != n) {\n            quitf(_wa, \"Total number of marks is not equal to n\");\n        }\n\n        // Check total sum\n        int total_sum = accumulate(marks.begin(), marks.end(), 0);\n        if (total_sum > x) {\n            quitf(_wa, \"Total sum of marks %d exceeds x = %d\", total_sum, x);\n        }\n\n        // Check median\n        sort(marks.begin(), marks.end());\n        int median = marks[n / 2]; // since n is odd\n        if (median < y) {\n            quitf(_wa, \"Median %d is less than y = %d\", median, y);\n        }\n\n        quitf(_ok, \"Found valid solution\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    int p = opt<int>(\"p\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"default\");\n    \n    // Validate parameters\n    ensure(n >= 1 && n <= 999 && n % 2 == 1); // n is odd\n    ensure(k >= 0 && k < n);\n    ensure(p >=1 && p <=1000);\n    ensure(x >= n && x <= (long long)n * p);\n    ensure(y >= 1 && y <= p);\n\n    vector<int> marks(k);\n\n    if (type == \"sample1\") {\n        // Hardcoded sample test case 1\n        n = 5; k = 3; p = 5; x = 18; y = 4;\n        marks = {3, 5, 4};\n    } else if (type == \"sample2\") {\n        // Hardcoded sample test case 2\n        n = 5; k = 3; p = 5; x = 16; y = 4;\n        marks = {5, 5, 5};\n    } else if (type == \"impossible_total\") {\n        // Generate a test case where total sum exceeds x no matter what\n        if (k == 0) k = rnd.next(1, n - 1);\n        int min_remaining_sum = (n - k) * 1;\n        int sum_marks = x - min_remaining_sum + 1;\n        if (sum_marks > k * p) sum_marks = k * p;\n        int avg_mark = sum_marks / k;\n        for (int i = 0; i < k; ++i) marks[i] = avg_mark;\n        int rem = sum_marks - avg_mark * k;\n        for (int i = 0; i < rem; ++i) marks[i]++;\n    } else if (type == \"impossible_median\") {\n        // Generate a test case where median cannot reach y\n        k = n - 1;\n        marks.resize(k);\n        if (y == 1) y = 2;\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, y - 1);\n    } else if (type == \"maximum_n\") {\n        n = 999;\n        if (n % 2 == 0) n--;\n        if (k >= n) k = n - 1;\n        marks.resize(k);\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"minimum_n\") {\n        n = 1; k = 0;\n        marks.clear();\n    } else if (type == \"k_zero\") {\n        k = 0;\n        marks.clear();\n    } else if (type == \"k_n_minus_one\") {\n        k = n - 1;\n        marks.resize(k);\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"median_at_max\") {\n        y = p;\n        if (k == 0) k = rnd.next(1, n - 1);\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p - 1);\n    } else if (type == \"median_at_min\") {\n        y = 1;\n        // Any marks are acceptable\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"p_one\") {\n        p = 1;\n        for (int i = 0; i < k; ++i) marks[i] = 1;\n    } else if (type == \"maximum_p\") {\n        p = 1000;\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"high_existing_marks\") {\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(y, p);\n    } else if (type == \"low_existing_marks\") {\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, y - 1);\n    } else {\n        // Default random test case\n        for (int i = 0; i < k; ++i)\n            marks[i] = rnd.next(1, p);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", n, k, p, x, y);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d\", marks[i]);\n        if (i + 1 < k) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", 0);\n    int p = opt<int>(\"p\");\n    int x = opt<int>(\"x\");\n    int y = opt<int>(\"y\");\n    string type = opt<string>(\"type\", \"default\");\n    \n    // Validate parameters\n    ensure(n >= 1 && n <= 999 && n % 2 == 1); // n is odd\n    ensure(k >= 0 && k < n);\n    ensure(p >=1 && p <=1000);\n    ensure(x >= n && x <= (long long)n * p);\n    ensure(y >= 1 && y <= p);\n\n    vector<int> marks(k);\n\n    if (type == \"sample1\") {\n        // Hardcoded sample test case 1\n        n = 5; k = 3; p = 5; x = 18; y = 4;\n        marks = {3, 5, 4};\n    } else if (type == \"sample2\") {\n        // Hardcoded sample test case 2\n        n = 5; k = 3; p = 5; x = 16; y = 4;\n        marks = {5, 5, 5};\n    } else if (type == \"impossible_total\") {\n        // Generate a test case where total sum exceeds x no matter what\n        if (k == 0) k = rnd.next(1, n - 1);\n        int min_remaining_sum = (n - k) * 1;\n        int sum_marks = x - min_remaining_sum + 1;\n        if (sum_marks > k * p) sum_marks = k * p;\n        int avg_mark = sum_marks / k;\n        for (int i = 0; i < k; ++i) marks[i] = avg_mark;\n        int rem = sum_marks - avg_mark * k;\n        for (int i = 0; i < rem; ++i) marks[i]++;\n    } else if (type == \"impossible_median\") {\n        // Generate a test case where median cannot reach y\n        k = n - 1;\n        marks.resize(k);\n        if (y == 1) y = 2;\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, y - 1);\n    } else if (type == \"maximum_n\") {\n        n = 999;\n        if (n % 2 == 0) n--;\n        if (k >= n) k = n - 1;\n        marks.resize(k);\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"minimum_n\") {\n        n = 1; k = 0;\n        marks.clear();\n    } else if (type == \"k_zero\") {\n        k = 0;\n        marks.clear();\n    } else if (type == \"k_n_minus_one\") {\n        k = n - 1;\n        marks.resize(k);\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"median_at_max\") {\n        y = p;\n        if (k == 0) k = rnd.next(1, n - 1);\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p - 1);\n    } else if (type == \"median_at_min\") {\n        y = 1;\n        // Any marks are acceptable\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"p_one\") {\n        p = 1;\n        for (int i = 0; i < k; ++i) marks[i] = 1;\n    } else if (type == \"maximum_p\") {\n        p = 1000;\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, p);\n    } else if (type == \"high_existing_marks\") {\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(y, p);\n    } else if (type == \"low_existing_marks\") {\n        for (int i = 0; i < k; ++i) marks[i] = rnd.next(1, y - 1);\n    } else {\n        // Default random test case\n        for (int i = 0; i < k; ++i)\n            marks[i] = rnd.next(1, p);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d %d\\n\", n, k, p, x, y);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d\", marks[i]);\n        if (i + 1 < k) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -p 1 -x 1 -y 1 -type minimum_n\n./gen -n 999 -k 0 -p 1000 -x 999000 -y 500 -type maximum_n\n./gen -n 999 -k 998 -p 1000 -x 999000 -y 999 -type impossible_median\n./gen -n 9 -k 4 -p 5 -x 20 -y 3 -type impossible_total\n./gen -n 101 -k 0 -p 10 -x 505 -y 5 -type k_zero\n./gen -n 101 -k 100 -p 10 -x 1000 -y 8 -type k_n_minus_one\n./gen -n 9 -k 3 -p 5 -x 12 -y 3 -type impossible_total\n./gen -n 11 -k 5 -p 10 -x 80 -y 10 -type median_at_max\n./gen -n 11 -k 5 -p 10 -x 80 -y 1 -type median_at_min\n./gen -n 15 -k 7 -p 5 -x 50 -y 3 -type default\n./gen -n 5 -k 3 -p 5 -x 18 -y 4 -type sample1\n./gen -n 5 -k 3 -p 5 -x 16 -y 4 -type sample2\n./gen -n 7 -k 3 -p 1 -x 7 -y 1 -type p_one\n./gen -n 7 -k 3 -p 1000 -x 7000 -y 500 -type maximum_p\n./gen -n 9 -k 4 -p 10 -x 50 -y 8 -type high_existing_marks\n./gen -n 9 -k 4 -p 10 -x 50 -y 3 -type low_existing_marks\n./gen -n 9 -k 0 -p 10 -x 9 -y 1 -type min_total_sum\n./gen -n 9 -k 0 -p 10 -x 90 -y 5 -type max_total_sum\n./gen -n 201 -k 100 -p 100 -x 15000 -y 50 -type default\n./gen -n 401 -k 200 -p 1000 -x 200000 -y 600 -type default\n./gen -n 999 -k 500 -p 1000 -x 500000 -y 500 -type default\n./gen -n 99 -k 49 -p 500 -x 25000 -y 250 -type default\n./gen -n 49 -k 24 -p 50 -x 2000 -y 20 -type default\n./gen -n 9 -k 4 -p 5 -x 45 -y 5 -type impossible_median\n./gen -n 5 -k 0 -p 5 -x 5 -y 1 -type default\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:46.596854",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "540/C",
      "title": "C. Ледяная пещера",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 500) — количество строк и столбцов в описании пещеры.Каждая из следующих n строк описывает начальное состояние уровня пещеры, где находится ваш персонаж, и состоит из m символов «.» (что означает цельный лед) и «X» (треснувший лед).В следующей строке записаны два целых числа r1 и c1 (1 ≤ r1 ≤ n, 1 ≤ c1 ≤ m) — ваши начальные координаты. Гарантируется, что в описании пещеры в клетке (r1, c1) стоит символ «X», то есть, лёд на стартовой клетке — треснувший.В следующей строке записаны два целых числа r2 и c2 (1 ≤ r2 ≤ n, 1 ≤ c2 ≤ m) — координаты клетки, под которую вам надо провалиться. Конечная клетка может совпадать со стартовой.",
      "output_spec": "Выходные данныеЕсли вы можете достигнуть цели, выведите «YES», иначе выведите «NO».",
      "sample_tests": "ПримерыВходные данныеСкопировать4 6X...XX...XX..X..X.......1 62 2Выходные данныеСкопироватьYESВходные данныеСкопировать5 4.X.....XX.X......XX.5 31 1Выходные данныеСкопироватьNOВходные данныеСкопировать4 7..X.XX..XX..X.X...X..X......2 21 6Выходные данныеСкопироватьYES",
      "description": "C. Ледяная пещера\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 500) — количество строк и столбцов в описании пещеры.Каждая из следующих n строк описывает начальное состояние уровня пещеры, где находится ваш персонаж, и состоит из m символов «.» (что означает цельный лед) и «X» (треснувший лед).В следующей строке записаны два целых числа r1 и c1 (1 ≤ r1 ≤ n, 1 ≤ c1 ≤ m) — ваши начальные координаты. Гарантируется, что в описании пещеры в клетке (r1, c1) стоит символ «X», то есть, лёд на стартовой клетке — треснувший.В следующей строке записаны два целых числа r2 и c2 (1 ≤ r2 ≤ n, 1 ≤ c2 ≤ m) — координаты клетки, под которую вам надо провалиться. Конечная клетка может совпадать со стартовой.\n\nВходные данные\n\nВыходные данныеЕсли вы можете достигнуть цели, выведите «YES», иначе выведите «NO».\n\nВыходные данные\n\nВходные данныеСкопировать4 6X...XX...XX..X..X.......1 62 2Выходные данныеСкопироватьYESВходные данныеСкопировать5 4.X.....XX.X......XX.5 31 1Выходные данныеСкопироватьNOВходные данныеСкопировать4 7..X.XX..XX..X.X...X..X......2 21 6Выходные данныеСкопироватьYES\n\nВходные данныеСкопировать4 6X...XX...XX..X..X.......1 62 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 4.X.....XX.X......XX.5 31 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 7..X.XX..XX..X.X...X..X......2 21 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере существует, например, такой маршрут:После первого посещения клетки (2, 2) лед на ней треснет, а, наступив туда во второй раз, ваш персонаж провалится под нее, что и было нужно.",
      "solutions": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "Всем привет!Мне выпала честь открыть четвертую сотню раундов на Codeforces. К сожалению, мы с друзьями пока что не смогли придумать сложных задач, так это всего лишь Div. 2 раунд. Но мы обязательно сделаем общий раунд когда-нибудь в будущем! Как всегда, благодарю Zlobober за помощь в подготовке задач, Delinur за перевод и MikeMirzayanov за сам Codeforces.Для участников из первого дивизиона задачи должны быть совсем простыми, поэтому давайте поставим челлендж: красные должны все решить за 30 минут, желтые — за час, а фиолетовые — за полтора часа. Интересно, как много народу сможет управиться?Разбалловка будет стандартная. Всем полных решений и успешных взломов!UPD 1. Поздравляю победителей в официальном зачете: PauGra cuvwqe496 tgehr и в неофициальном: niyaznigmatul I_love_Tanya_Romanova dreamoon_love_AA UPD 2. Разбор лежит тут: /blog/entry/17643.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17636",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 858
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "540A - Кодовый замокДля каждого символа посчитаем, в какую сторону выгоднее вращать диск. Это можно сделать либо формулой: min(abs(a[i] - b[i]), 10 - abs(a[i] - b[i])), либо даже двумя циклами for: в прямом или обратном направлении.540B - Школьные оценкиПосчитаем количество оценок, меньших y. Если таких больше штук, то мы не сможем удовлетворить второму условию (про медиану), и ответ -1. Иначе получим ровно столько оценок y, чтобы количество оценок, больших или равных y, было как минимум штук (возможно, это уже выполняется). Это минимальное необходимое действие для удовлетворения второго условия.Теперь, чтобы не нарушить первое условие, сделаем оставшиеся неизвестные оценки как можно меньше — единицами, и проверим сумму. Если она больше x, то ответ снова -1, иначе требуемые оценки найдены.540C - Ледяная пещераЯ выделил здесь три случая, хотя некоторые из них можно объединить. Если начальная и конечная клетка совпадают, посмотрим на количество целых соседей этой клетки. Если есть хотя бы один целый сосед, то пойдем туда и сразу же вернемся обратно, выполнив задачу — в этом случае ответ YES. Если начальная и конечная клетка являются соседями, то посмотрим на тип конечной клетки. Если конечная клетка треснувшая, то ответ YES. Иначе для положительного ответа необходимо, чтобы у нее был хотя бы один целый сосед — пойдем на конечную клетку, затем на этого целого соседа, а потом вернемся обратно. В наиболее общем случае проверим, существует ли путь по целым клеткам от начальной клетки до конечной. Если нет, то ответ NO. Иначе посмотрим на тип конечной клетки. Если она целая, то для существования ответа необходимо наличие у нее двух целых соседей — по одному мы придем в нее, а второй используем как промежуточную точку, а если конечная клетка треснувшая, то у нее должен существовать один целый сосед. 540D - Остров невезения (мой код: http://pastebin.com/3s6dRK3A)Будем считать величину dp[r][s][p] — вероятность возникновения ситуации, когда в живых осталось r камней, s ножниц и p бумаг — для всех возможных значений r, s, p. Начальная вероятность равна 1, а для подсчета остальных необходимо сделать переходы.Пусть у нас имеется r камней, s ножниц и p бумаг. Найдем для примера вероятность того, что в этой ситуации камень убьет ножницы — остальные две вероятности считаются симметрично. Количество случаев, в которых кто-нибудь умрет, равно rs + rp + sp, а количество случаев, в которых умрут ножницы, равно rs. Так как все случаи равновероятны, нужная нам вероятность равна . Именно с этой вероятностью мы перейдем в состояние dp[r][s — 1][p], где ножниц станет на 1 меньше.В конце, чтобы получить вероятность, что, например, камень выживет, надо просуммировать все величины dp[i][0][0] для i от 1 до r (аналогично для остальных видов).540E - Бесконечные инверсии (мой код: http://pastebin.com/QFEMRbNP)Запомним, на какой позиции какое число будет стоять после выполнения всех swap-ов. Теперь будем считать ответ. Ответ состоит из двух частей. Первая часть — это инверсии, образованные исключительно теми элементами, которые поучаствовали в swap-ах. Их можно посчитать одним из двух стандартных способов: mergesort-ом или с помощью сжатия координат и дерева Фенвика. Вторая часть — это инверсии, в которых один из элементов пары участвовал в swap-ах, а второй — нет. Для простоты рассмотрим тест: 2\n2 6\n4 8Перестановка будет выглядеть так: [1 6 3 8 5 2 7 4 9 ...], а массив swap-нутых элементов так: [6 8 2 4].Давайте поймем, с какими элементами будет образовывать инверсии число 8. Очевидно, такими элементами могут быть лишь те элементы, которые находятся между начальной позицией числа 8 (где сейчас число 4), и текущей его позицией. Вот этот подотрезок: [5 2 7]. Чисел на этом подотрезке, которые не участвовали в swap-ах, две штуки: 5 и 7. Число 2 учитывать не надо — ведь оно участвовало в swap-ах, и мы его посчитали на первом шаге решения.Таким образом, надо взять количество чисел между начальной и конечной позицией числа 8 в глобальной перестановке (т.е. 8 - 4 - 1 = 3), и вычесть из него количество чисел между позициями числа 8 в массиве swap-ов (т.е. 4 - 2 - 1 = 1). Чтобы избавиться от дополнительного вычитания единицы, можно просто из правого индекса вычитать левый. Так мы получим количество инверсий, образованные элементом 8 и элементами глобальной перестановки, не участвовавших в swap-ах. Для завершения второго шага надо лишь посчитать эту величину для всех чисел, участвовавших в swap-ах. Все операции второго шага можно выполнить при помощи сортировок и бинарного поиска.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17643",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 540\\s*C"
          },
          "content_length": 4523
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "violets solve everything in 1 hour and a half",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "I will solve these problems in 2 hour",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "Until the contest over, I still haven't finished all problems",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 4",
          "code": "I am Stupid-Dog",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 5",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 6",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 7",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 8",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 9",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 10",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 11",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 12",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 13",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 15",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 16",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 17",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 18",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 19",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 20",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 21",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 22",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 23",
          "code": "RR, SS or PP",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 24",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 25",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 26",
          "code": "reds should solve everything in 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 27",
          "code": "pretest pass",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 28",
          "code": "33 minutes > 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 29",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 30",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 31",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 32",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 33",
          "code": "int rs = r*s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 34",
          "code": "int pr = p*r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 35",
          "code": "int sp = s*p;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 36",
          "code": "int tot = rs + pr + sp;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 37",
          "code": "if (s) dp[r][s][p] += getdp(r, s-1, p) * rs / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 38",
          "code": "if (r) dp[r][s][p] += getdp(r-1, s, p) * pr / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 39",
          "code": "if (p) dp[r][s][p] += getdp(r, s, p-1) * sp / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 40",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 41",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 42",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 43",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine(\"[\\\\.X]{\" + to_string(m) + \"}\", \"row \" + to_string(i + 1));\n    }\n    \n    int r1 = inf.readInt(1, n, \"r1\");\n    inf.readSpace();\n    int c1 = inf.readInt(1, m, \"c1\");\n    inf.readEoln();\n    \n    ensuref(grid[r1 - 1][c1 - 1] == 'X', \"Starting cell (%d, %d) must contain 'X'\", r1, c1);\n    \n    int r2 = inf.readInt(1, n, \"r2\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, m, \"c2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine(\"[\\\\.X]{\" + to_string(m) + \"}\", \"row \" + to_string(i + 1));\n    }\n    \n    int r1 = inf.readInt(1, n, \"r1\");\n    inf.readSpace();\n    int c1 = inf.readInt(1, m, \"c1\");\n    inf.readEoln();\n    \n    ensuref(grid[r1 - 1][c1 - 1] == 'X', \"Starting cell (%d, %d) must contain 'X'\", r1, c1);\n    \n    int r2 = inf.readInt(1, n, \"r2\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, m, \"c2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readEoln();\n    \n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        grid[i] = inf.readLine(\"[\\\\.X]{\" + to_string(m) + \"}\", \"row \" + to_string(i + 1));\n    }\n    \n    int r1 = inf.readInt(1, n, \"r1\");\n    inf.readSpace();\n    int c1 = inf.readInt(1, m, \"c1\");\n    inf.readEoln();\n    \n    ensuref(grid[r1 - 1][c1 - 1] == 'X', \"Starting cell (%d, %d) must contain 'X'\", r1, c1);\n    \n    int r2 = inf.readInt(1, n, \"r2\");\n    inf.readSpace();\n    int c2 = inf.readInt(1, m, \"c2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printGrid(const vector<string>& grid, int r1, int c1, int r2, int c2) {\n    int n = grid.size();\n    int m = grid[0].size();\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n    printf(\"%d %d\\n\", r1, c1);\n    printf(\"%d %d\\n\", r2, c2);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int r1, c1, r2, c2; // starting and ending positions\n    vector<string> grid(n, string(m, '.')); // Initialize grid with '.' (intact ice)\n\n    if (type == \"random\") {\n        // Randomly generate the grid\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0, 1))\n                    grid[i][j] = 'X';\n                else\n                    grid[i][j] = '.';\n            }\n        }\n\n        // Choose a random cracked cell as starting position\n        vector<pair<int,int>> cracked_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == 'X')\n                    cracked_cells.push_back(make_pair(i, j));\n\n        if (cracked_cells.empty()) {\n            // Ensure at least one cracked cell for the starting position\n            int si = rnd.next(0, n - 1);\n            int sj = rnd.next(0, m - 1);\n            grid[si][sj] = 'X';\n            cracked_cells.push_back(make_pair(si, sj));\n        }\n        int start_idx = rnd.next(0, int(cracked_cells.size()) - 1);\n        r1 = cracked_cells[start_idx].first + 1;\n        c1 = cracked_cells[start_idx].second + 1;\n\n        // Choose a random cell as ending position (could be the same as starting)\n        r2 = rnd.next(1, n);\n        c2 = rnd.next(1, m);\n\n    } else if (type == \"path_exists\") {\n        // Create an empty grid (all '.'), and make a path between start and end\n        r1 = 1;\n        c1 = 1;\n        r2 = n;\n        c2 = m;\n\n        // Set starting cell to 'X'\n        grid[r1 - 1][c1 - 1] = 'X';\n\n        // Now, create a path between (r1, c1) and (r2, c2)\n        // For simplicity, let's make a path along the first row and last column\n\n        for (int j = c1 - 1; j < m; ++j)\n            grid[r1 - 1][j] = '.';\n        for (int i = r1 - 1; i < n; ++i)\n            grid[i][c2 - 1] = '.';\n\n        // The starting cell is cracked\n        grid[r1 - 1][c1 - 1] = 'X';\n\n    } else if (type == \"no_path\") {\n        // Create a grid where the start and end are completely blocked from each other\n        r1 = 1;\n        c1 = 1;\n        r2 = n;\n        c2 = m;\n\n        // Set starting cell to 'X'\n        grid[r1 - 1][c1 - 1] = 'X';\n\n        // Surround the starting cell with 'X' so that any move causes a fall\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = r1 - 1 + dx[dir];\n            int nj = c1 - 1 + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                grid[ni][nj] = 'X';\n            }\n        }\n        // Set ending cell\n        grid[r2 - 1][c2 - 1] = '.';\n\n    } else if (type == \"starting_equals_ending\") {\n        // Starting and ending positions are the same\n        r1 = rnd.next(1, n);\n        c1 = rnd.next(1, m);\n        r2 = r1;\n        c2 = c1;\n\n        grid[r1 - 1][c1 - 1] = 'X'; // Ensure starting cell is cracked\n\n        // Randomly fill the grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (i != r1 - 1 || j != c1 -1) // Skip starting cell\n                    grid[i][j] = rnd.next(0, 1) ? 'X' : '.';\n\n    } else if (type == \"maximum_size\") {\n        // Grid of maximum size (n=500, m=500)\n        n = 500;\n        m = 500;\n        grid.resize(n, string(m, '.'));\n\n        // Set starting and ending positions\n        r1 = 1;\n        c1 = 1;\n        r2 = n;\n        c2 = m;\n\n        // Starting cell is cracked\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        // Make a path from start to end\n        // For simplicity, along the top row and right column\n        for (int j = c1 - 1; j < m; ++j)\n            grid[r1 - 1][j] = '.';\n        for (int i = r1 - 1; i < n; ++i)\n            grid[i][c2 - 1] = '.';\n\n    } else if (type == \"revisit_required\") {\n        // Create a grid where you must revisit a cell to fall through\n        r1 = 1;\n        c1 = 1;\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        r2 = 1;\n        c2 = 3;\n        grid[r2 - 1][c2 -1 ] = '.';\n\n        // Create a loop path: (1,1) -> (1,2) -> (1,3) -> (1,2) -> (1,3)\n        grid[0][1] = '.'; // (1,2)\n        grid[0][2] = '.'; // (1,3)\n\n    } else if (type == \"minimal_size\") {\n        // n and m are minimal\n        n = opt<int>(\"n\", 1);\n        m = opt<int>(\"m\", 1);\n        grid.resize(n, string(m, '.'));\n        r1 = 1;\n        c1 = 1;\n        r2 = 1;\n        c2 = 1;\n\n        grid[0][0] = 'X'; // Starting cell is cracked\n\n    } else if (type == \"starting_surrounded\") {\n        // Starting cell is surrounded by cracked ice\n        r1 = rnd.next(2, n - 1);\n        c1 = rnd.next(2, m - 1);\n        r2 = n;\n        c2 = m;\n\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        // Surround starting cell with 'X'\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = r1 - 1 + dx[dir];\n            int nj = c1 - 1 + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                grid[ni][nj] = 'X';\n            }\n        }\n\n    } else if (type == \"ending_surrounded\") {\n        // Ending cell is surrounded by intact ice\n        r1 = 1;\n        c1 = 1;\n        r2 = n - 1;\n        c2 = m - 1;\n\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        // Surround ending cell with '.'\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = r2 - 1 + dx[dir];\n            int nj = c2 - 1 + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                grid[ni][nj] = '.';\n            }\n        }\n        grid[r2 - 1][c2 - 1] = '.';\n\n        // Create a path from start to end\n        for (int i = 0; i <= r2 - 1; ++i)\n            grid[i][0] = '.';\n        for (int j = 0; j <= c2 - 1; ++j)\n            grid[r2 - 1][j] = '.';\n\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(0, 1) ? 'X' : '.';\n\n        vector<pair<int,int>> cracked_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == 'X')\n                    cracked_cells.push_back(make_pair(i, j));\n\n        if (cracked_cells.empty()) {\n            int si = rnd.next(0, n - 1);\n            int sj = rnd.next(0, m - 1);\n            grid[si][sj] = 'X';\n            cracked_cells.push_back(make_pair(si, sj));\n        }\n        int start_idx = rnd.next(0, int(cracked_cells.size()) - 1);\n        r1 = cracked_cells[start_idx].first + 1;\n        c1 = cracked_cells[start_idx].second + 1;\n        r2 = rnd.next(1, n);\n        c2 = rnd.next(1, m);\n    }\n\n    printGrid(grid, r1, c1, r2, c2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid printGrid(const vector<string>& grid, int r1, int c1, int r2, int c2) {\n    int n = grid.size();\n    int m = grid[0].size();\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n    printf(\"%d %d\\n\", r1, c1);\n    printf(\"%d %d\\n\", r2, c2);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int r1, c1, r2, c2; // starting and ending positions\n    vector<string> grid(n, string(m, '.')); // Initialize grid with '.' (intact ice)\n\n    if (type == \"random\") {\n        // Randomly generate the grid\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0, 1))\n                    grid[i][j] = 'X';\n                else\n                    grid[i][j] = '.';\n            }\n        }\n\n        // Choose a random cracked cell as starting position\n        vector<pair<int,int>> cracked_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == 'X')\n                    cracked_cells.push_back(make_pair(i, j));\n\n        if (cracked_cells.empty()) {\n            // Ensure at least one cracked cell for the starting position\n            int si = rnd.next(0, n - 1);\n            int sj = rnd.next(0, m - 1);\n            grid[si][sj] = 'X';\n            cracked_cells.push_back(make_pair(si, sj));\n        }\n        int start_idx = rnd.next(0, int(cracked_cells.size()) - 1);\n        r1 = cracked_cells[start_idx].first + 1;\n        c1 = cracked_cells[start_idx].second + 1;\n\n        // Choose a random cell as ending position (could be the same as starting)\n        r2 = rnd.next(1, n);\n        c2 = rnd.next(1, m);\n\n    } else if (type == \"path_exists\") {\n        // Create an empty grid (all '.'), and make a path between start and end\n        r1 = 1;\n        c1 = 1;\n        r2 = n;\n        c2 = m;\n\n        // Set starting cell to 'X'\n        grid[r1 - 1][c1 - 1] = 'X';\n\n        // Now, create a path between (r1, c1) and (r2, c2)\n        // For simplicity, let's make a path along the first row and last column\n\n        for (int j = c1 - 1; j < m; ++j)\n            grid[r1 - 1][j] = '.';\n        for (int i = r1 - 1; i < n; ++i)\n            grid[i][c2 - 1] = '.';\n\n        // The starting cell is cracked\n        grid[r1 - 1][c1 - 1] = 'X';\n\n    } else if (type == \"no_path\") {\n        // Create a grid where the start and end are completely blocked from each other\n        r1 = 1;\n        c1 = 1;\n        r2 = n;\n        c2 = m;\n\n        // Set starting cell to 'X'\n        grid[r1 - 1][c1 - 1] = 'X';\n\n        // Surround the starting cell with 'X' so that any move causes a fall\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = r1 - 1 + dx[dir];\n            int nj = c1 - 1 + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                grid[ni][nj] = 'X';\n            }\n        }\n        // Set ending cell\n        grid[r2 - 1][c2 - 1] = '.';\n\n    } else if (type == \"starting_equals_ending\") {\n        // Starting and ending positions are the same\n        r1 = rnd.next(1, n);\n        c1 = rnd.next(1, m);\n        r2 = r1;\n        c2 = c1;\n\n        grid[r1 - 1][c1 - 1] = 'X'; // Ensure starting cell is cracked\n\n        // Randomly fill the grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (i != r1 - 1 || j != c1 -1) // Skip starting cell\n                    grid[i][j] = rnd.next(0, 1) ? 'X' : '.';\n\n    } else if (type == \"maximum_size\") {\n        // Grid of maximum size (n=500, m=500)\n        n = 500;\n        m = 500;\n        grid.resize(n, string(m, '.'));\n\n        // Set starting and ending positions\n        r1 = 1;\n        c1 = 1;\n        r2 = n;\n        c2 = m;\n\n        // Starting cell is cracked\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        // Make a path from start to end\n        // For simplicity, along the top row and right column\n        for (int j = c1 - 1; j < m; ++j)\n            grid[r1 - 1][j] = '.';\n        for (int i = r1 - 1; i < n; ++i)\n            grid[i][c2 - 1] = '.';\n\n    } else if (type == \"revisit_required\") {\n        // Create a grid where you must revisit a cell to fall through\n        r1 = 1;\n        c1 = 1;\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        r2 = 1;\n        c2 = 3;\n        grid[r2 - 1][c2 -1 ] = '.';\n\n        // Create a loop path: (1,1) -> (1,2) -> (1,3) -> (1,2) -> (1,3)\n        grid[0][1] = '.'; // (1,2)\n        grid[0][2] = '.'; // (1,3)\n\n    } else if (type == \"minimal_size\") {\n        // n and m are minimal\n        n = opt<int>(\"n\", 1);\n        m = opt<int>(\"m\", 1);\n        grid.resize(n, string(m, '.'));\n        r1 = 1;\n        c1 = 1;\n        r2 = 1;\n        c2 = 1;\n\n        grid[0][0] = 'X'; // Starting cell is cracked\n\n    } else if (type == \"starting_surrounded\") {\n        // Starting cell is surrounded by cracked ice\n        r1 = rnd.next(2, n - 1);\n        c1 = rnd.next(2, m - 1);\n        r2 = n;\n        c2 = m;\n\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        // Surround starting cell with 'X'\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = r1 - 1 + dx[dir];\n            int nj = c1 - 1 + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                grid[ni][nj] = 'X';\n            }\n        }\n\n    } else if (type == \"ending_surrounded\") {\n        // Ending cell is surrounded by intact ice\n        r1 = 1;\n        c1 = 1;\n        r2 = n - 1;\n        c2 = m - 1;\n\n        grid[r1 - 1][c1 -1 ] = 'X';\n\n        // Surround ending cell with '.'\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        for (int dir = 0; dir < 4; ++dir) {\n            int ni = r2 - 1 + dx[dir];\n            int nj = c2 - 1 + dy[dir];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                grid[ni][nj] = '.';\n            }\n        }\n        grid[r2 - 1][c2 - 1] = '.';\n\n        // Create a path from start to end\n        for (int i = 0; i <= r2 - 1; ++i)\n            grid[i][0] = '.';\n        for (int j = 0; j <= c2 - 1; ++j)\n            grid[r2 - 1][j] = '.';\n\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(0, 1) ? 'X' : '.';\n\n        vector<pair<int,int>> cracked_cells;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == 'X')\n                    cracked_cells.push_back(make_pair(i, j));\n\n        if (cracked_cells.empty()) {\n            int si = rnd.next(0, n - 1);\n            int sj = rnd.next(0, m - 1);\n            grid[si][sj] = 'X';\n            cracked_cells.push_back(make_pair(si, sj));\n        }\n        int start_idx = rnd.next(0, int(cracked_cells.size()) - 1);\n        r1 = cracked_cells[start_idx].first + 1;\n        c1 = cracked_cells[start_idx].second + 1;\n        r2 = rnd.next(1, n);\n        c2 = rnd.next(1, m);\n    }\n\n    printGrid(grid, r1, c1, r2, c2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random tests with small size\n./gen -n 10 -m 10 -type random\n./gen -n 15 -m 15 -type random\n\n# Random tests with medium size\n./gen -n 100 -m 100 -type random\n./gen -n 200 -m 150 -type random\n\n# Random tests with large size\n./gen -n 500 -m 500 -type random\n\n# Path exists tests\n./gen -n 50 -m 50 -type path_exists\n./gen -n 100 -m 100 -type path_exists\n./gen -n 500 -m 500 -type path_exists\n\n# No path tests\n./gen -n 50 -m 50 -type no_path\n./gen -n 100 -m 100 -type no_path\n./gen -n 500 -m 500 -type no_path\n\n# Starting equals ending tests\n./gen -n 10 -m 10 -type starting_equals_ending\n./gen -n 20 -m 20 -type starting_equals_ending\n\n# Maximum size tests\n./gen -n 500 -m 500 -type maximum_size\n\n# Minimal size tests\n./gen -n 1 -m 1 -type minimal_size\n./gen -n 1 -m 10 -type minimal_size\n./gen -n 10 -m 1 -type minimal_size\n\n# Revisit required tests\n./gen -n 5 -m 5 -type revisit_required\n./gen -n 10 -m 10 -type revisit_required\n\n# Starting and ending positions adjacent (edge cases)\n./gen -n 2 -m 2 -type path_exists\n./gen -n 3 -m 3 -type path_exists\n\n# Starting cell surrounded by cracked ice\n./gen -n 5 -m 5 -type starting_surrounded\n./gen -n 10 -m 10 -type starting_surrounded\n\n# Ending cell surrounded by intact ice\n./gen -n 5 -m 5 -type ending_surrounded\n./gen -n 10 -m 10 -type ending_surrounded\n\n# Additional varied tests\n./gen -n 100 -m 200 -type random\n./gen -n 200 -m 50 -type random\n./gen -n 300 -m 300 -type path_exists\n./gen -n 300 -m 300 -type no_path\n./gen -n 500 -m 1 -type path_exists\n./gen -n 1 -m 500 -type path_exists\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:48.349740",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "540/D",
      "title": "D. Bad Luck Island",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains three integers r, s and p (1 ≤ r, s, p ≤ 100) — the original number of individuals in the species of rock, scissors and paper, respectively.",
      "output_spec": "OutputPrint three space-separated real numbers: the probabilities, at which the rocks, the scissors and the paper will be the only surviving species, respectively. The answer will be considered correct if the relative or absolute error of each number doesn't exceed 10 - 9.",
      "sample_tests": "ExamplesInputCopy2 2 2OutputCopy0.333333333333 0.333333333333 0.333333333333InputCopy2 1 2OutputCopy0.150000000000 0.300000000000 0.550000000000InputCopy1 1 3OutputCopy0.057142857143 0.657142857143 0.285714285714",
      "description": "D. Bad Luck Island\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line contains three integers r, s and p (1 ≤ r, s, p ≤ 100) — the original number of individuals in the species of rock, scissors and paper, respectively.\n\nOutputPrint three space-separated real numbers: the probabilities, at which the rocks, the scissors and the paper will be the only surviving species, respectively. The answer will be considered correct if the relative or absolute error of each number doesn't exceed 10 - 9.\n\nInputCopy2 2 2OutputCopy0.333333333333 0.333333333333 0.333333333333InputCopy2 1 2OutputCopy0.150000000000 0.300000000000 0.550000000000InputCopy1 1 3OutputCopy0.057142857143 0.657142857143 0.285714285714\n\nInputCopy2 2 2\n\nOutputCopy0.333333333333 0.333333333333 0.333333333333\n\nInputCopy2 1 2\n\nOutputCopy0.150000000000 0.300000000000 0.550000000000\n\nInputCopy1 1 3\n\nOutputCopy0.057142857143 0.657142857143 0.285714285714",
      "solutions": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "Hi all,I was honored to open the fourth hundred of Codeforces Rounds. Unfornunately, neither I nor my friends couldn't invent any hard problems, so it's only a Div. 2 Round. But we'll definitely prepare a full round in the future! As always, I thank Zlobober for his help in preparing the problems, Delinur for English translations and MikeMirzayanov for the Codeforces itself.The problems must be pretty easy for Div. 1 guys, so let's start a challenge: reds should solve everything in 30 minutes, yellows — in 1 hour, and violets — in 1 hour and a half. How many people will be able to make a success?The score distribution will be standard. Wish you accepted solutions and successful hacks!UPD 1. Congratulations to the winners in Div. 2: PauGra cuvwqe496 tgehr and in Div. 1: niyaznigmatul I_love_Tanya_Romanova dreamoon_love_AA UPD 2. This is the editorial: /blog/entry/17643.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17636",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 881
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "540A - Combination LockFor every symbol we should determine how to rotate the disk. This can be done either by formula: min(abs(a[i] - b[i]), 10 - abs(a[i] - b[i])) or even by the two for cycles: in both directions.540B - School MarksFirst count the number of marks that are less than y. If there are more than such marks, we can't satisfy the second condition (about the median), and the answer is -1. Otherwise we can get exactly such number of y marks so that the total number of marks greater than or equal to y is at least (maybe it's already satisfied). This is the required action for satisfying the second condition.Now, in order not to break the first condition, get the remaining marks as lower as possible — all ones — and check the sum of the marks. If it is greater than x, the answer is -1, otherwise the correct answer is found.540C - Ice CaveThere are three cases here, though some of them can be merged. If the start and finish cells are equal, let's count the intact neighbours of this cell. If there is one, move there and instantly move back — the answer is YES. Otherwise it's NO. If the start and finish cells are neighbours, the solution depends on the type of the destination cell. If it's cracked, the answer is YES — we can just move there and fall down. Otherwise it must have at least one intact neighbour to get the positive answer — we can move to the finish cell, then to this intact neighbour, and then return to the finish cell. In the general case, check if the path from the start cell to the finish cell exists. If it doesn't, the answer is NO. Otherwise check the type of the destination cell. If it's cracked, it must have at least one intact neighbour, and if it's intact, it must have two intact neighbours. 540D - Bad Luck Island (my code: http://pastebin.com/3s6dRK3A)Let's count the values dp[r][s][p] — the probability of the situation when r rocks, s scissors and p papers are alive. The initial probability is 1, and in order to calculate the others we should perform the transitions.Imagine we have r rocks, s scissors and p papers. Let's find the probability of the rock killing scissors (the other probabilities are calculated in the same way). The total number of the possible pairs where one species kills the other one is rs + rp + sp, and the number of possible pairs (rock, scissors) is rs. As all meetings are equiprobable, the probability we want to find is . This is the probability with which we go the the state dp[r][s — 1][p], with the number of scissors less by one.In the end, for example, to get the probability of the event that the rocks are alive, we should sum all values dp[i][0][0] for i from 1 to r (the same goes to the other species).540E - Infinite Inversions (my code: http://pastebin.com/QFEMRbNP)At first find the position of each element which is used in swap (using map). Now let's find the answer. It consists of the two parts. First part is the number of inversions formed by only whose elements which took part in the swaps. They can be counted by one of the standard ways: mergesort or Fenwick tree. The second part is the number of inversions formed by pairs of elements where one element has been swapped even once, and the other element stayed at his position. Let's consider the following test: 2\n2 6\n4 8The global sequence will look as follows: [1 6 3 8 5 2 7 4 9 ...], and here is the array of swapped elements: [6 8 2 4].Let's understand with which numbers the number 8 forms the inversions. The only elements that could do that are the elements between the initial position of the number 8 (where the number 4 is now) and its current position: [5 2 7]. There are two numbers on this segment which didn't take part in swaps: 5 and 7. The number 2 should not be counted as it took part in the swaps and we have already counted it in the first part of the solution.So we should take the count of numbers between 8's indices in the global sequence (8 - 4 - 1 = 3) and subtract the count of numbers between its indices in the swaps array (4 - 2 - 1 = 1). We'll get the number of inversions formed by the element 8 and the elements which haven't moved at all, it's 2. Counting this value for all elements which have been swapped at least once, we get the second part of the answer. All operations in the second part of the solution can be performed using sorts and binary searches.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17643",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 540\\s*D"
          },
          "content_length": 4366
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "violets solve everything in 1 hour and a half",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "I will solve these problems in 2 hour",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "Until the contest over, I still haven't finished all problems",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 4",
          "code": "I am Stupid-Dog",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 5",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 6",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 7",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 8",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 9",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 10",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 11",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 12",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 13",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 14",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 15",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 16",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 17",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 18",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 19",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 20",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 21",
          "code": "RR, SS or PP",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 22",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 23",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 24",
          "code": "reds should solve everything in 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 25",
          "code": "pretest pass",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 26",
          "code": "33 minutes > 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 27",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 28",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 29",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 30",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 31",
          "code": "int rs = r*s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 32",
          "code": "int pr = p*r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 33",
          "code": "int sp = s*p;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 34",
          "code": "int tot = rs + pr + sp;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 35",
          "code": "if (s) dp[r][s][p] += getdp(r, s-1, p) * rs / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 36",
          "code": "if (r) dp[r][s][p] += getdp(r-1, s, p) * pr / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 37",
          "code": "if (p) dp[r][s][p] += getdp(r, s, p-1) * sp / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 38",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 39",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 40",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 41",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int s = inf.readInt(1, 100, \"s\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int s = inf.readInt(1, 100, \"s\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    int r = inf.readInt(1, 100, \"r\");\n    inf.readSpace();\n    int s = inf.readInt(1, 100, \"s\");\n    inf.readSpace();\n    int p = inf.readInt(1, 100, \"p\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int r, s, p;\n\n    if (type == \"fixed\") {\n        r = opt<int>(\"r\");\n        s = opt<int>(\"s\");\n        p = opt<int>(\"p\");\n    } else if (type == \"random\") {\n        r = rnd.next(1, 100);\n        s = rnd.next(1, 100);\n        p = rnd.next(1, 100);\n    } else if (type == \"max\") {\n        r = s = p = 100;\n    } else if (type == \"min\") {\n        r = s = p = 1;\n    } else if (type == \"large_r\") {\n        r = 100;\n        s = rnd.next(1, 10);\n        p = rnd.next(1, 10);\n    } else if (type == \"large_s\") {\n        s = 100;\n        r = rnd.next(1, 10);\n        p = rnd.next(1, 10);\n    } else if (type == \"large_p\") {\n        p = 100;\n        r = rnd.next(1, 10);\n        s = rnd.next(1, 10);\n    } else if (type == \"equal\") {\n        int x = rnd.next(1, 100);\n        r = s = p = x;\n    } else if (type == \"small_diffs\") {\n        int x = rnd.next(1, 100);\n        int delta = rnd.next(0, 5);\n        r = x;\n        s = x + delta;\n        p = x - delta;\n        r = max(1, min(100, r));\n        s = max(1, min(100, s));\n        p = max(1, min(100, p));\n    } else if (type == \"ascending\") {\n        r = rnd.next(1, 33);\n        s = rnd.next(r, 66);\n        p = rnd.next(s, 100);\n    } else if (type == \"descending\") {\n        p = rnd.next(1, 33);\n        s = rnd.next(p, 66);\n        r = rnd.next(s, 100);\n    } else {\n        // Default to random\n        r = rnd.next(1, 100);\n        s = rnd.next(1, 100);\n        p = rnd.next(1, 100);\n    }\n\n    // Ensure r, s, p are within bounds\n    r = max(1, min(100, r));\n    s = max(1, min(100, s));\n    p = max(1, min(100, p));\n\n    printf(\"%d %d %d\\n\", r, s, p);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int r, s, p;\n\n    if (type == \"fixed\") {\n        r = opt<int>(\"r\");\n        s = opt<int>(\"s\");\n        p = opt<int>(\"p\");\n    } else if (type == \"random\") {\n        r = rnd.next(1, 100);\n        s = rnd.next(1, 100);\n        p = rnd.next(1, 100);\n    } else if (type == \"max\") {\n        r = s = p = 100;\n    } else if (type == \"min\") {\n        r = s = p = 1;\n    } else if (type == \"large_r\") {\n        r = 100;\n        s = rnd.next(1, 10);\n        p = rnd.next(1, 10);\n    } else if (type == \"large_s\") {\n        s = 100;\n        r = rnd.next(1, 10);\n        p = rnd.next(1, 10);\n    } else if (type == \"large_p\") {\n        p = 100;\n        r = rnd.next(1, 10);\n        s = rnd.next(1, 10);\n    } else if (type == \"equal\") {\n        int x = rnd.next(1, 100);\n        r = s = p = x;\n    } else if (type == \"small_diffs\") {\n        int x = rnd.next(1, 100);\n        int delta = rnd.next(0, 5);\n        r = x;\n        s = x + delta;\n        p = x - delta;\n        r = max(1, min(100, r));\n        s = max(1, min(100, s));\n        p = max(1, min(100, p));\n    } else if (type == \"ascending\") {\n        r = rnd.next(1, 33);\n        s = rnd.next(r, 66);\n        p = rnd.next(s, 100);\n    } else if (type == \"descending\") {\n        p = rnd.next(1, 33);\n        s = rnd.next(p, 66);\n        r = rnd.next(s, 100);\n    } else {\n        // Default to random\n        r = rnd.next(1, 100);\n        s = rnd.next(1, 100);\n        p = rnd.next(1, 100);\n    }\n\n    // Ensure r, s, p are within bounds\n    r = max(1, min(100, r));\n    s = max(1, min(100, s));\n    p = max(1, min(100, p));\n\n    printf(\"%d %d %d\\n\", r, s, p);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type fixed -r 1 -s 1 -p 1\n./gen -type fixed -r 100 -s 100 -p 100\n./gen -type fixed -r 1 -s 1 -p 100\n./gen -type fixed -r 1 -s 100 -p 1\n./gen -type fixed -r 100 -s 1 -p 1\n./gen -type fixed -r 50 -s 50 -p 1\n./gen -type fixed -r 1 -s 50 -p 50\n./gen -type fixed -r 50 -s 1 -p 50\n./gen -type fixed -r 34 -s 33 -p 33\n./gen -type fixed -r 33 -s 34 -p 33\n./gen -type fixed -r 33 -s 33 -p 34\n\n./gen -type equal\n./gen -type equal\n./gen -type equal\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type large_r\n./gen -type large_s\n./gen -type large_p\n\n./gen -type small_diffs\n./gen -type small_diffs\n./gen -type small_diffs\n\n./gen -type max\n./gen -type min\n\n./gen -type ascending\n./gen -type ascending\n./gen -type ascending\n\n./gen -type descending\n./gen -type descending\n./gen -type descending\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:50.727553",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "540/E",
      "title": "E. Бесконечные инверсии",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105) — количество операций swap, примененных к последовательности.В каждой из следующих n строк записано по два числа ai и bi (1 ≤ ai, bi ≤ 109, ai ≠ bi) — аргументы операций swap.",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество инверсий в получившейся последовательности.",
      "sample_tests": "ПримерыВходные данныеСкопировать24 21 4Выходные данныеСкопировать4Входные данныеСкопировать31 63 42 5Выходные данныеСкопировать15",
      "description": "E. Бесконечные инверсии\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано единственное целое число n (1 ≤ n ≤ 105) — количество операций swap, примененных к последовательности.В каждой из следующих n строк записано по два числа ai и bi (1 ≤ ai, bi ≤ 109, ai ≠ bi) — аргументы операций swap.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество инверсий в получившейся последовательности.\n\nВыходные данные\n\nВходные данныеСкопировать24 21 4Выходные данныеСкопировать4Входные данныеСкопировать31 63 42 5Выходные данныеСкопировать15\n\nВходные данныеСкопировать24 21 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 63 42 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать15\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере последовательность меняется следующим образом: . В ней 4 инверсии, их образуют пары индексов (1, 4), (2, 3), (2, 4) и (3, 4).",
      "solutions": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "Всем привет!Мне выпала честь открыть четвертую сотню раундов на Codeforces. К сожалению, мы с друзьями пока что не смогли придумать сложных задач, так это всего лишь Div. 2 раунд. Но мы обязательно сделаем общий раунд когда-нибудь в будущем! Как всегда, благодарю Zlobober за помощь в подготовке задач, Delinur за перевод и MikeMirzayanov за сам Codeforces.Для участников из первого дивизиона задачи должны быть совсем простыми, поэтому давайте поставим челлендж: красные должны все решить за 30 минут, желтые — за час, а фиолетовые — за полтора часа. Интересно, как много народу сможет управиться?Разбалловка будет стандартная. Всем полных решений и успешных взломов!UPD 1. Поздравляю победителей в официальном зачете: PauGra cuvwqe496 tgehr и в неофициальном: niyaznigmatul I_love_Tanya_Romanova dreamoon_love_AA UPD 2. Разбор лежит тут: /blog/entry/17643.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17636",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 858
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces",
          "content": "540A - Кодовый замокДля каждого символа посчитаем, в какую сторону выгоднее вращать диск. Это можно сделать либо формулой: min(abs(a[i] - b[i]), 10 - abs(a[i] - b[i])), либо даже двумя циклами for: в прямом или обратном направлении.540B - Школьные оценкиПосчитаем количество оценок, меньших y. Если таких больше штук, то мы не сможем удовлетворить второму условию (про медиану), и ответ -1. Иначе получим ровно столько оценок y, чтобы количество оценок, больших или равных y, было как минимум штук (возможно, это уже выполняется). Это минимальное необходимое действие для удовлетворения второго условия.Теперь, чтобы не нарушить первое условие, сделаем оставшиеся неизвестные оценки как можно меньше — единицами, и проверим сумму. Если она больше x, то ответ снова -1, иначе требуемые оценки найдены.540C - Ледяная пещераЯ выделил здесь три случая, хотя некоторые из них можно объединить. Если начальная и конечная клетка совпадают, посмотрим на количество целых соседей этой клетки. Если есть хотя бы один целый сосед, то пойдем туда и сразу же вернемся обратно, выполнив задачу — в этом случае ответ YES. Если начальная и конечная клетка являются соседями, то посмотрим на тип конечной клетки. Если конечная клетка треснувшая, то ответ YES. Иначе для положительного ответа необходимо, чтобы у нее был хотя бы один целый сосед — пойдем на конечную клетку, затем на этого целого соседа, а потом вернемся обратно. В наиболее общем случае проверим, существует ли путь по целым клеткам от начальной клетки до конечной. Если нет, то ответ NO. Иначе посмотрим на тип конечной клетки. Если она целая, то для существования ответа необходимо наличие у нее двух целых соседей — по одному мы придем в нее, а второй используем как промежуточную точку, а если конечная клетка треснувшая, то у нее должен существовать один целый сосед. 540D - Остров невезения (мой код: http://pastebin.com/3s6dRK3A)Будем считать величину dp[r][s][p] — вероятность возникновения ситуации, когда в живых осталось r камней, s ножниц и p бумаг — для всех возможных значений r, s, p. Начальная вероятность равна 1, а для подсчета остальных необходимо сделать переходы.Пусть у нас имеется r камней, s ножниц и p бумаг. Найдем для примера вероятность того, что в этой ситуации камень убьет ножницы — остальные две вероятности считаются симметрично. Количество случаев, в которых кто-нибудь умрет, равно rs + rp + sp, а количество случаев, в которых умрут ножницы, равно rs. Так как все случаи равновероятны, нужная нам вероятность равна . Именно с этой вероятностью мы перейдем в состояние dp[r][s — 1][p], где ножниц станет на 1 меньше.В конце, чтобы получить вероятность, что, например, камень выживет, надо просуммировать все величины dp[i][0][0] для i от 1 до r (аналогично для остальных видов).540E - Бесконечные инверсии (мой код: http://pastebin.com/QFEMRbNP)Запомним, на какой позиции какое число будет стоять после выполнения всех swap-ов. Теперь будем считать ответ. Ответ состоит из двух частей. Первая часть — это инверсии, образованные исключительно теми элементами, которые поучаствовали в swap-ах. Их можно посчитать одним из двух стандартных способов: mergesort-ом или с помощью сжатия координат и дерева Фенвика. Вторая часть — это инверсии, в которых один из элементов пары участвовал в swap-ах, а второй — нет. Для простоты рассмотрим тест: 2\n2 6\n4 8Перестановка будет выглядеть так: [1 6 3 8 5 2 7 4 9 ...], а массив swap-нутых элементов так: [6 8 2 4].Давайте поймем, с какими элементами будет образовывать инверсии число 8. Очевидно, такими элементами могут быть лишь те элементы, которые находятся между начальной позицией числа 8 (где сейчас число 4), и текущей его позицией. Вот этот подотрезок: [5 2 7]. Чисел на этом подотрезке, которые не участвовали в swap-ах, две штуки: 5 и 7. Число 2 учитывать не надо — ведь оно участвовало в swap-ах, и мы его посчитали на первом шаге решения.Таким образом, надо взять количество чисел между начальной и конечной позицией числа 8 в глобальной перестановке (т.е. 8 - 4 - 1 = 3), и вычесть из него количество чисел между позициями числа 8 в массиве swap-ов (т.е. 4 - 2 - 1 = 1). Чтобы избавиться от дополнительного вычитания единицы, можно просто из правого индекса вычитать левый. Так мы получим количество инверсий, образованные элементом 8 и элементами глобальной перестановки, не участвовавших в swap-ах. Для завершения второго шага надо лишь посчитать эту величину для всех чисел, участвовавших в swap-ах. Все операции второго шага можно выполнить при помощи сортировок и бинарного поиска.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17643",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 540\\s*E"
          },
          "content_length": 4523
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "violets solve everything in 1 hour and a half",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "I will solve these problems in 2 hour",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "Until the contest over, I still haven't finished all problems",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 4",
          "code": "I am Stupid-Dog",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 5",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 6",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 7",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 8",
          "code": "2 2\n..\nX.\n2 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 9",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 10",
          "code": "9 8 10 90 2\n1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 11",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 12",
          "code": "dp[i-1][j][k] = dp[i][j][k] * ((i*k)/(i*j + j*k + k*i));\n\ndp[i][j-1][k] = dp[i][j][k] * ((i*j)/(i*j + j*k + k*i));\n\ndp[i][j][k-1] = dp[i][j][k] * ((j*k)/(i*j + j*k + k*i));",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 13",
          "code": "binary indexed tree",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 14",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 15",
          "code": "vector<int> a;\n...\nint dist = upper_bound(a.begin(), a.end(), x) - lower_bound(a.begin(), a.end(), x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 16",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 17",
          "code": "if len(arr) > n:\n    print \"first\"\n    print -1\n    quit()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 18",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 19",
          "code": "total = r + s + p\n// rock loses against paper\nrock(r, s, p) += ((r / total) * (p / (total - 1)) + (p / total) * (r / (total - 1))) * rock(r - 1, s, p)\n// scissor loses against rock\nrock(r, s, p) += (r / total) * (s / (total - 1)) + (s / total) * (r / (total - 1)) * rock(r, s - 1, p)\n// paper loses against scissor.\nrock(r, s, p) += (s / total) * (p / (total - 1)) + (p / total) * (s / (total - 1)) * rock(r, s, p - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 20",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 21",
          "code": "r = 0 return 0\ns = 0 return 0\np = 0 return 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 22",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 23",
          "code": "RR, SS or PP",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 24",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 25",
          "code": "rock(r, s, p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 26",
          "code": "reds should solve everything in 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 27",
          "code": "pretest pass",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 28",
          "code": "33 minutes > 30 minutes",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 29",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 30",
          "code": "else if(!cracked[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 31",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 32",
          "code": "else if(!cracked[r][c] && visit_count[r][c] >= 2) return false;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 33",
          "code": "int rs = r*s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 34",
          "code": "int pr = p*r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 35",
          "code": "int sp = s*p;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 36",
          "code": "int tot = rs + pr + sp;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 37",
          "code": "if (s) dp[r][s][p] += getdp(r, s-1, p) * rs / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 38",
          "code": "if (r) dp[r][s][p] += getdp(r-1, s, p) * pr / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 39",
          "code": "if (p) dp[r][s][p] += getdp(r, s, p-1) * sp / tot;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 40",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 41",
          "code": "if(grid[i][j-1]==c && condition(i,j-1))\n        DFS(i,j-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 42",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #301 (Div. 2) - Codeforces - Code 43",
          "code": "1 1\nX\n1 1\n1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17636",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 1",
          "code": "lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 2",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #301 (Div. 2) - Codeforces - Code 3",
          "code": "for (int i = 0; i < m; i++)\n{\n    int x = a[i];\n    int pos = mapchik[x];\n    ans += abs(b[i] - x) - abs(pos - i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17643",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        long long ai = inf.readLong(1LL, 1000000000LL, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, 1000000000LL, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi must not be equal on line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        long long ai = inf.readLong(1LL, 1000000000LL, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, 1000000000LL, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi must not be equal on line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        long long ai = inf.readLong(1LL, 1000000000LL, \"ai\");\n        inf.readSpace();\n        long long bi = inf.readLong(1LL, 1000000000LL, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai and bi must not be equal on line %d\", i + 2);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> swaps;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, (int)1e9);\n            int b;\n            do {\n                b = rnd.next(1, (int)1e9);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000);\n            int b;\n            do {\n                b = rnd.next(1, 1000);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next((int)1e9 - 1000, (int)1e9);\n            int b;\n            do {\n                b = rnd.next((int)1e9 - 1000, (int)1e9);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"repeated_swaps\") {\n        int a = rnd.next(1, (int)1e9);\n        int b;\n        do {\n            b = rnd.next(1, (int)1e9);\n        } while (b == a);\n        for (int i = 0; i < n; ++i) {\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"increasing_positions\") {\n        int pos = 1;\n        for (int i = 0; i < n; ++i) {\n            int a = pos++;\n            int b = pos++;\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"decreasing_positions\") {\n        int pos = (int)1e9;\n        for (int i = 0; i < n; ++i) {\n            int a = pos--;\n            int b = pos--;\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"max_inversions\") {\n        int m = 2 * n;\n        for (int i = 1; i <= n; ++i) {\n            swaps.emplace_back(i, m - i + 1);\n        }\n    } else if (type == \"no_inversions\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, (int)1e9);\n            int b;\n            do {\n                b = rnd.next(1, (int)1e9);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n            ++i;\n            if (i >= n) break;\n            swaps.emplace_back(a, b); // Swap back\n        }\n        if ((int)swaps.size() > n) swaps.resize(n);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& swap : swaps) {\n        printf(\"%d %d\\n\", swap.first, swap.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> swaps;\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, (int)1e9);\n            int b;\n            do {\n                b = rnd.next(1, (int)1e9);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"small_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, 1000);\n            int b;\n            do {\n                b = rnd.next(1, 1000);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"large_numbers\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next((int)1e9 - 1000, (int)1e9);\n            int b;\n            do {\n                b = rnd.next((int)1e9 - 1000, (int)1e9);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"repeated_swaps\") {\n        int a = rnd.next(1, (int)1e9);\n        int b;\n        do {\n            b = rnd.next(1, (int)1e9);\n        } while (b == a);\n        for (int i = 0; i < n; ++i) {\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"increasing_positions\") {\n        int pos = 1;\n        for (int i = 0; i < n; ++i) {\n            int a = pos++;\n            int b = pos++;\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"decreasing_positions\") {\n        int pos = (int)1e9;\n        for (int i = 0; i < n; ++i) {\n            int a = pos--;\n            int b = pos--;\n            swaps.emplace_back(a, b);\n        }\n    } else if (type == \"max_inversions\") {\n        int m = 2 * n;\n        for (int i = 1; i <= n; ++i) {\n            swaps.emplace_back(i, m - i + 1);\n        }\n    } else if (type == \"no_inversions\") {\n        for (int i = 0; i < n; ++i) {\n            int a = rnd.next(1, (int)1e9);\n            int b;\n            do {\n                b = rnd.next(1, (int)1e9);\n            } while (b == a);\n            swaps.emplace_back(a, b);\n            ++i;\n            if (i >= n) break;\n            swaps.emplace_back(a, b); // Swap back\n        }\n        if ((int)swaps.size() > n) swaps.resize(n);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (const auto& swap : swaps) {\n        printf(\"%d %d\\n\", swap.first, swap.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen --n 1 --type random\n./gen --n 1 --type small_numbers\n./gen --n 1 --type large_numbers\n./gen --n 1 --type repeated_swaps\n./gen --n 1 --type increasing_positions\n./gen --n 1 --type decreasing_positions\n./gen --n 1 --type max_inversions\n./gen --n 1 --type no_inversions\n\n./gen --n 10 --type random\n./gen --n 10 --type max_inversions\n\n./gen --n 100 --type small_numbers\n./gen --n 100 --type large_numbers\n\n./gen --n 500 --type repeated_swaps\n./gen --n 500 --type increasing_positions\n\n./gen --n 1000 --type decreasing_positions\n./gen --n 1000 --type no_inversions\n\n./gen --n 10000 --type random\n./gen --n 10000 --type max_inversions\n\n./gen --n 100000 --type random\n./gen --n 100000 --type small_numbers\n./gen --n 100000 --type large_numbers\n./gen --n 100000 --type repeated_swaps\n./gen --n 100000 --type increasing_positions\n./gen --n 100000 --type decreasing_positions\n./gen --n 100000 --type max_inversions\n./gen --n 100000 --type no_inversions\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:52.830442",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "542/A",
      "title": "A. Place Your Ad Here",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 2·105) — the number of commercial videos and channels, respectively.Each of the following n lines contains two integers li, ri (0 ≤ li ≤ ri ≤ 109) — the segment of time when it is possible to show the corresponding video.Each of the following m lines contains three integers aj, bj, cj (0 ≤ aj ≤ bj ≤ 109, 1 ≤ cj ≤ 109), characterizing the TV channel.",
      "output_spec": "OutputIn the first line print an integer — the maximum possible efficiency of the broadcast. If there is no correct way to get a strictly positive efficiency, print a zero.If the maximum efficiency is strictly positive, in the second line also print the number of the video i (1 ≤ i ≤ n) and the number of the TV channel j (1 ≤ j ≤ m) in the most effective broadcast.If there are multiple optimal answers, you can print any of them.",
      "sample_tests": "ExamplesInputCopy2 37 91 42 8 20 4 18 9 3OutputCopy42 1InputCopy1 10 01 1 10OutputCopy0",
      "description": "A. Place Your Ad Here\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 2·105) — the number of commercial videos and channels, respectively.Each of the following n lines contains two integers li, ri (0 ≤ li ≤ ri ≤ 109) — the segment of time when it is possible to show the corresponding video.Each of the following m lines contains three integers aj, bj, cj (0 ≤ aj ≤ bj ≤ 109, 1 ≤ cj ≤ 109), characterizing the TV channel.\n\nOutputIn the first line print an integer — the maximum possible efficiency of the broadcast. If there is no correct way to get a strictly positive efficiency, print a zero.If the maximum efficiency is strictly positive, in the second line also print the number of the video i (1 ≤ i ≤ n) and the number of the TV channel j (1 ≤ j ≤ m) in the most effective broadcast.If there are multiple optimal answers, you can print any of them.\n\nInputCopy2 37 91 42 8 20 4 18 9 3OutputCopy42 1InputCopy1 10 01 1 10OutputCopy0\n\nInputCopy2 37 91 42 8 20 4 18 9 3\n\nOutputCopy42 1\n\nInputCopy1 10 01 1 10\n\nOutputCopy0\n\nNoteIn the first sample test the most optimal solution is to show the second commercial using the first TV channel at time [2, 4]. The efficiency of such solution is equal to (4 - 2)·2 = 4.In the second sample test Ivan Anatolievich's wish does not meet the options of the TV channel, the segments do not intersect, so the answer is zero.",
      "solutions": [
        {
          "title": "VK Cup Round 3 online mirror - Codeforces",
          "content": "This Sunday, May 3-rd, 19:00 Moscow Time there will be Round 3 of VK Cup 2015 Championship!As in Round 2, there will also be an online mirror that is rated round available only for Div1-contestants. There will be 6 task in random order and a smooth dynamic scoring system.Round was brought to you by Codeforces team, VK team and yeputons. As usual, we want to thank winger and AlexFetisov for a great testing help.Top-50 participants of online mirror will get a nice VK Cup T-Shirt! Good luck and have fun!UPD1 The round is over! Congratulations to all contestants in top-50, you will get a nice VK Cup 2015 Championship T-Shirt soon! There will be an editorial soon, stay tuned...UPD2 Finally, the editorial is ready!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17690",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 718
        },
        {
          "title": "VK Cup Round 3 editorial - Codeforces",
          "content": "542A - Place Your Ad HereLet's fix the TV channel window and look for a commerical having the largest intersection with it. There are four types of commercials: lying inside the window, overlapping the window and partially intersecting the window from the left and from the right.It's easy to determine if there is overlapping commercial: it's enough to sort commercials in increasing order of the left end and then while iterating over them from left to right, keep the minimum value of a right end of a commercial. If when we pass the window j and see that current value of the maximum right end is no less than bj then there exists a commercial overlapping our window and the value is equal to the (ri - li)·ci.Among all commercials that lie inside our window we need the longest one. It can be done by similar but a bit harder manner. Let's use sweepline method. While passing through the end of the commercial ri, let's assign in some data structure (like segment tree) the value ri - li in point li. While passing through the end of a window, let's calculate answer for it as a maximum on segment [aj, bj]. By doing this, we consider all commercials inside the window.We can process partially intersecting commercials in the similar way. While passing the right end of the commercial ri let's put the value ri in the point li in our data structure. While passing through the right end of a window bj let's calculate the answer for it as a maximum on the segment [aj, bj] minus aj.Among all answers for all commercials we need to choose the largest one. So we have the solution in . Challenge. What if there are weights not only on windows, but on commercials also, and those weights are multiplied with the intersection length? You can solve this task in and get a virtual medal!542B - Duck HuntFirst of all, let's say that ducks stay still and the one that moves is the hunter. Let's define the value F[x][s] as the minimum number of ducks among having the right end no further than x, that we can't shot if the last shot was in the point s. In particular, the value F[x][s] includes all ducks located inside the segment [s + 1, x]. Values F[x][s] for s > x let's consider as undefined.Let's look on F[x] as on a function of s. This function is defined on all s from 0 to x inclusive. The key idea is in investigating how F[x + 1][·] differs from F[x][·].Let's first suppose that in point x + 1 there is no end of the duck. Then in definition of F[x + 1][·] we consider the same set of the ducks as for the definition f F[x][·]. That means that all values F[x][s] for s ≤ x are the same for F[x + 1]. Let's understand what happens with F[x + 1][x + 1]. It's easy to see that the shot in point x + 1 can't kill any of the ducks that end no further than x + 1 (since we just supposed that there are no ducks ending in exactly x + 1). So, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Now let's suppose that in point x + 1 the duck [l, x + 1] ends. In this case we can say that all values of F[x + 1][0... l - 1] should be increased by 1 (since at the moment of shot in point s < l the duck [l, x + 1] can't be killed yet). From the other hand, all values F[x + 1][l... x + 1] remain the same since the last shot kills the newly added duck.Now let's understand how to implement all this stuff. Function F[x][·] is piecewise constant, so it can be stored in a Cartesian tree as a sequence of pairs (beginning of segment, value on segment). Such storage allows us to easily add 1 on prefix and take minimum on prefix of a function.Now let's think that F[x][·] is defined on all posistive values but the values F[x][s] for s > x do not satisfy the definition of F[x][s] above. In other words, let's just suppose that the lats segment in structure F[x] is infinite in right direction.Let's sweep with the variable x. The function F[x + 1][·] changes in comparsion to F[x][·] very rarely For example, the value F[x + 1][x + 1] is almost always the same as F[x][x + 1] (that is equal to F[x][x] as said above). Indeed, if we suppose that there is no duck ending in x + 1 then F[x][x] = min(F[x][0... x - r]) and F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). So, there is an interesting event only if value F[x][x - r + 1] is smaller than the whole prefix before it. On the other hand, the value min(F[x][0... x - r]) can't increase more than n times by 1 (each time when we pass through the right end of the duck) and so, it also can't decrease more then n times (since it is a non-negative value).So, the events \"we passed through the right end of the duck\" and \"we should non-trivially calculate F[x][x]\" are in total linear. Each of them can be processed in O(1) operation with Cartesian tree, that gives as totally an solution. Whooray! 542C - Idempotent functionsIn order to solve this task it's good to understand how does the graph corresponding the function from {1, ..., n} to itself looks. Let's consider a graph on vertices 1, ..., n with edges from vertex i to the vertex f(i). Such graph always looks like a set of cycles with several trees leading to that cycles. How should the graph look like for function to be the idempotent? It's easy to see that in such graph all cycles should be of length 1 and all vertex that are not cycles of length 1 (i. e. all not fixed points) should immediatly lead to some fixed point.So, we should satisfy two conditions. First, all cycles should become of length 1 — in order to do that k should be divisible by lcm(c1, c2, ..., cm) where ci are the lengths of all cycles. Second, all vertices not lying on cycles should become leading to the vertices lying on cycles. In other words, k should be no less than the distance from any vertex x to the cycle it goes into (or, that the same, the length of pre-period in the sequence f(x), f(f(x)), f(f(f(x))), ...).So, are task is about finding the smallest number k divisible by A that is no less than B, it is not hard at all.Challenge. What is the maximum possible answer for this task? (Answer: first second)542D - Superhero's JobFirst step is to understand the properties of a Joker function. It's important property is that it is multiplicative: J(ab) = J(a)J(b) for (a, b) = 1, so we can write the value of function knowing the factorization of an argument: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Let's use this knowledge in order to solve the task with dynamic programming. Let's denote as P the set of prime p such that the multiple including it may appear in A = J(x). There are not that many such primes: each divisor d of number A can correspond no more than one such prime, namely, the one whose power the number d - 1 is (if it is a prime power at all). Let's calculate the set P and also remember for each prime number p in it in which powers k the value (pk + 1) divides A. Now we can calculate value D[p][d] that is equal to the number of ways to get a divisor d of a number A as a product of brackets of first p primes in set P. Such value can be caluclated by using dynamic programming in time where is the number of divisors of A (as it was shown above that ). So, overall complexity of the solution is .Challenge. How the behaves when A increases? What is the maximum values of over all A ≤ 1012? (The answer: . Nice estimate that is not an exact asymptotic, though, is that )Challenge. What is the maximum answer in this task? If you are able to create a test with answer larger than million, a great respect from me!542E - Playing on GraphFirst, if the original graph isn't bipartite then the answer is (-1). Indeed, any odd cycle, while being contracted by the pair of vertices, always produces an odd cycle of smaller size, so at some point we will get a triangle that blocks us from doing anything.From the other way, each bipartite component can be contracted in order to get a chain whose length is a diameter of the component. Suppose that the pair of vertices (a, b) is a diamater of some connected component. Then, by contracting all vertices located on the same distance from a we can achieve the chain we want.The last step is that the answer fror the original graph is the sum of the answers for all the connected components since we can attach all of them together. So, the answer is the sum of diameters of all connected components if all of them are bipartite, otherwise answer is -1. Solution has the complexity O(E + VE) (The first summand is checking for being bipartite, the second one is calculation diameters by running BFS from each vertex).542F - QuestThis task can be solved in lot of ways. The most straightforward is DP. The task can be seen in the following way. We want some set of vertices as leaves and for each potential leaf we know the upper bound for its depth and its cost.Let's sweep over the tree from down to up. Let's calculate the value D[h][c] that is the maximum possible cost that we can achieve if we stay on the level h and have c vertices on it. For transition let's fix how many leaves of the deepness exactly h we will take (it's easy to see that among them we should task several greatest). Suppose we will take k of them. Then from this state we can move to D[h - 1][⌈(c + k) / 2⌉]. The answer will be located in D[0][1] because when we are on the level 0 we should have the only vertex that is the root of the tree.The complexity of such solution is O(n2T). Challenge Improve the solution above to and then to",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*A"
          },
          "content_length": 9504
        },
        {
          "title": "VK Cup Round 3 editorial - Codeforces",
          "content": "542A - Place Your Ad HereLet's fix the TV channel window and look for a commerical having the largest intersection with it. There are four types of commercials: lying inside the window, overlapping the window and partially intersecting the window from the left and from the right.It's easy to determine if there is overlapping commercial: it's enough to sort commercials in increasing order of the left end and then while iterating over them from left to right, keep the minimum value of a right end of a commercial. If when we pass the window j and see that current value of the maximum right end is no less than bj then there exists a commercial overlapping our window and the value is equal to the (ri - li)·ci.Among all commercials that lie inside our window we need the longest one. It can be done by similar but a bit harder manner. Let's use sweepline method. While passing through the end of the commercial ri, let's assign in some data structure (like segment tree) the value ri - li in point li. While passing through the end of a window, let's calculate answer for it as a maximum on segment [aj, bj]. By doing this, we consider all commercials inside the window.We can process partially intersecting commercials in the similar way. While passing the right end of the commercial ri let's put the value ri in the point li in our data structure. While passing through the right end of a window bj let's calculate the answer for it as a maximum on the segment [aj, bj] minus aj.Among all answers for all commercials we need to choose the largest one. So we have the solution in . Challenge. What if there are weights not only on windows, but on commercials also, and those weights are multiplied with the intersection length? You can solve this task in and get a virtual medal!542B - Duck HuntFirst of all, let's say that ducks stay still and the one that moves is the hunter. Let's define the value F[x][s] as the minimum number of ducks among having the right end no further than x, that we can't shot if the last shot was in the point s. In particular, the value F[x][s] includes all ducks located inside the segment [s + 1, x]. Values F[x][s] for s > x let's consider as undefined.Let's look on F[x] as on a function of s. This function is defined on all s from 0 to x inclusive. The key idea is in investigating how F[x + 1][·] differs from F[x][·].Let's first suppose that in point x + 1 there is no end of the duck. Then in definition of F[x + 1][·] we consider the same set of the ducks as for the definition f F[x][·]. That means that all values F[x][s] for s ≤ x are the same for F[x + 1]. Let's understand what happens with F[x + 1][x + 1]. It's easy to see that the shot in point x + 1 can't kill any of the ducks that end no further than x + 1 (since we just supposed that there are no ducks ending in exactly x + 1). So, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Now let's suppose that in point x + 1 the duck [l, x + 1] ends. In this case we can say that all values of F[x + 1][0... l - 1] should be increased by 1 (since at the moment of shot in point s < l the duck [l, x + 1] can't be killed yet). From the other hand, all values F[x + 1][l... x + 1] remain the same since the last shot kills the newly added duck.Now let's understand how to implement all this stuff. Function F[x][·] is piecewise constant, so it can be stored in a Cartesian tree as a sequence of pairs (beginning of segment, value on segment). Such storage allows us to easily add 1 on prefix and take minimum on prefix of a function.Now let's think that F[x][·] is defined on all posistive values but the values F[x][s] for s > x do not satisfy the definition of F[x][s] above. In other words, let's just suppose that the lats segment in structure F[x] is infinite in right direction.Let's sweep with the variable x. The function F[x + 1][·] changes in comparsion to F[x][·] very rarely For example, the value F[x + 1][x + 1] is almost always the same as F[x][x + 1] (that is equal to F[x][x] as said above). Indeed, if we suppose that there is no duck ending in x + 1 then F[x][x] = min(F[x][0... x - r]) and F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). So, there is an interesting event only if value F[x][x - r + 1] is smaller than the whole prefix before it. On the other hand, the value min(F[x][0... x - r]) can't increase more than n times by 1 (each time when we pass through the right end of the duck) and so, it also can't decrease more then n times (since it is a non-negative value).So, the events \"we passed through the right end of the duck\" and \"we should non-trivially calculate F[x][x]\" are in total linear. Each of them can be processed in O(1) operation with Cartesian tree, that gives as totally an solution. Whooray! 542C - Idempotent functionsIn order to solve this task it's good to understand how does the graph corresponding the function from {1, ..., n} to itself looks. Let's consider a graph on vertices 1, ..., n with edges from vertex i to the vertex f(i). Such graph always looks like a set of cycles with several trees leading to that cycles. How should the graph look like for function to be the idempotent? It's easy to see that in such graph all cycles should be of length 1 and all vertex that are not cycles of length 1 (i. e. all not fixed points) should immediatly lead to some fixed point.So, we should satisfy two conditions. First, all cycles should become of length 1 — in order to do that k should be divisible by lcm(c1, c2, ..., cm) where ci are the lengths of all cycles. Second, all vertices not lying on cycles should become leading to the vertices lying on cycles. In other words, k should be no less than the distance from any vertex x to the cycle it goes into (or, that the same, the length of pre-period in the sequence f(x), f(f(x)), f(f(f(x))), ...).So, are task is about finding the smallest number k divisible by A that is no less than B, it is not hard at all.Challenge. What is the maximum possible answer for this task? (Answer: first second)542D - Superhero's JobFirst step is to understand the properties of a Joker function. It's important property is that it is multiplicative: J(ab) = J(a)J(b) for (a, b) = 1, so we can write the value of function knowing the factorization of an argument: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Let's use this knowledge in order to solve the task with dynamic programming. Let's denote as P the set of prime p such that the multiple including it may appear in A = J(x). There are not that many such primes: each divisor d of number A can correspond no more than one such prime, namely, the one whose power the number d - 1 is (if it is a prime power at all). Let's calculate the set P and also remember for each prime number p in it in which powers k the value (pk + 1) divides A. Now we can calculate value D[p][d] that is equal to the number of ways to get a divisor d of a number A as a product of brackets of first p primes in set P. Such value can be caluclated by using dynamic programming in time where is the number of divisors of A (as it was shown above that ). So, overall complexity of the solution is .Challenge. How the behaves when A increases? What is the maximum values of over all A ≤ 1012? (The answer: . Nice estimate that is not an exact asymptotic, though, is that )Challenge. What is the maximum answer in this task? If you are able to create a test with answer larger than million, a great respect from me!542E - Playing on GraphFirst, if the original graph isn't bipartite then the answer is (-1). Indeed, any odd cycle, while being contracted by the pair of vertices, always produces an odd cycle of smaller size, so at some point we will get a triangle that blocks us from doing anything.From the other way, each bipartite component can be contracted in order to get a chain whose length is a diameter of the component. Suppose that the pair of vertices (a, b) is a diamater of some connected component. Then, by contracting all vertices located on the same distance from a we can achieve the chain we want.The last step is that the answer fror the original graph is the sum of the answers for all the connected components since we can attach all of them together. So, the answer is the sum of diameters of all connected components if all of them are bipartite, otherwise answer is -1. Solution has the complexity O(E + VE) (The first summand is checking for being bipartite, the second one is calculation diameters by running BFS from each vertex).542F - QuestThis task can be solved in lot of ways. The most straightforward is DP. The task can be seen in the following way. We want some set of vertices as leaves and for each potential leaf we know the upper bound for its depth and its cost.Let's sweep over the tree from down to up. Let's calculate the value D[h][c] that is the maximum possible cost that we can achieve if we stay on the level h and have c vertices on it. For transition let's fix how many leaves of the deepness exactly h we will take (it's easy to see that among them we should task several greatest). Suppose we will take k of them. Then from this state we can move to D[h - 1][⌈(c + k) / 2⌉]. The answer will be located in D[0][1] because when we are on the level 0 we should have the only vertex that is the root of the tree.The complexity of such solution is O(n2T). Challenge Improve the solution above to and then to",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*A"
          },
          "content_length": 9504
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 1",
          "code": "Div1-contestants",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 2",
          "code": "Wrong Anser on test 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 3",
          "code": "int dp[N][T]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 4",
          "code": "int dp[T][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 5",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 6",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 200000;\n    const int MAXV = 1000000000;\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXN, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(0, MAXV);\n        inf.readSpace();\n        int ri = inf.readInt(li, MAXV);\n        inf.readEoln();\n    }\n    for (int j = 0; j < m; j++) {\n        int aj = inf.readInt(0, MAXV);\n        inf.readSpace();\n        int bj = inf.readInt(aj, MAXV);\n        inf.readSpace();\n        int cj = inf.readInt(1, MAXV);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 200000;\n    const int MAXV = 1000000000;\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXN, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(0, MAXV);\n        inf.readSpace();\n        int ri = inf.readInt(li, MAXV);\n        inf.readEoln();\n    }\n    for (int j = 0; j < m; j++) {\n        int aj = inf.readInt(0, MAXV);\n        inf.readSpace();\n        int bj = inf.readInt(aj, MAXV);\n        inf.readSpace();\n        int cj = inf.readInt(1, MAXV);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAXN = 200000;\n    const int MAXV = 1000000000;\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAXN, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int li = inf.readInt(0, MAXV);\n        inf.readSpace();\n        int ri = inf.readInt(li, MAXV);\n        inf.readEoln();\n    }\n    for (int j = 0; j < m; j++) {\n        int aj = inf.readInt(0, MAXV);\n        inf.readSpace();\n        int bj = inf.readInt(aj, MAXV);\n        inf.readSpace();\n        int cj = inf.readInt(1, MAXV);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<int> l, r;\nvector<int> a, b, c;\n\nlong long readAns(InStream& stream) {\n    long long claimed_efficiency = stream.readLong(0, (long long)1e18, \"claimed efficiency\");\n\n    if (claimed_efficiency == 0) {\n        return 0;\n    } else {\n        int i = stream.readInt(1, n, \"video index\");\n        int j = stream.readInt(1, m, \"channel index\");\n\n        int li = l[i - 1];\n        int ri = r[i - 1];\n        int aj = a[j - 1];\n        int bj = b[j - 1];\n        int cj = c[j - 1];\n\n        int x = max(li, aj);\n        int y = min(ri, bj);\n\n        if (x >= y) {\n            stream.quitf(_wa, \"No overlapping time ranges between video %d and channel %d\", i, j);\n        }\n\n        long long actual_efficiency = (long long)(y - x) * cj;\n\n        if (actual_efficiency != claimed_efficiency) {\n            stream.quitf(_wa, \"Claimed efficiency %lld does not match actual efficiency %lld for video %d and channel %d\",\n                         claimed_efficiency, actual_efficiency, i, j);\n        }\n\n        return claimed_efficiency;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    m = inf.readInt();\n\n    l.resize(n);\n    r.resize(n);\n    for (int i = 0; i < n; i++) {\n        l[i] = inf.readInt();\n        r[i] = inf.readInt();\n        if (l[i] > r[i]) {\n            inf.quitf(_fail, \"Invalid input: l[%d] > r[%d]\", i + 1, i + 1);\n        }\n    }\n\n    a.resize(m);\n    b.resize(m);\n    c.resize(m);\n    for (int j = 0; j < m; j++) {\n        a[j] = inf.readInt();\n        b[j] = inf.readInt();\n        c[j] = inf.readInt();\n        if (a[j] > b[j]) {\n            inf.quitf(_fail, \"Invalid input: a[%d] > b[%d]\", j + 1, j + 1);\n        }\n    }\n\n    long long jans = readAns(ans);\n    long long pans = readAns(ouf);\n\n    if (pans > jans)\n        quitf(_fail, \"Participant's answer is better than jury's: pans = %lld, jans = %lld\", pans, jans);\n    else if (pans < jans)\n        quitf(_wa, \"Participant's answer is worse than jury's: pans = %lld, jans = %lld\", pans, jans);\n    else // pans == jans\n        quitf(_ok, \"Correct, maximum efficiency is %lld\", pans);\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            int r = rnd.next(l, int(1e9));\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(0, int(1e9));\n            int b = rnd.next(a, int(1e9));\n            int c = rnd.next(1, int(1e9));\n            channels[i] = make_tuple(a, b, c);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"no_overlap\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(5e8 - 1));\n            int r = rnd.next(l, int(5e8 - 1));\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(int(5e8 + 1), int(1e9));\n            int b = rnd.next(a, int(1e9));\n            int c = rnd.next(1, int(1e9));\n            channels[i] = make_tuple(a, b, c);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"overlapping_at_single_point\") {\n        int point = rnd.next(0, int(1e9));\n\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, point);\n            int r = point;\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int a = point;\n            int b = point;\n            int c = rnd.next(1, int(1e9));\n            channels[i] = make_tuple(a, b, c);\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"max_efficiency_large_cj\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9 - 1));\n            int r = l + 1; // length 1\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, n-1);\n            int a = videos[idx].first;\n            int b = videos[idx].second;\n\n            // Shift a bit to make sure overlapping interval exists\n            int shift = rnd.next(-1, 1);\n            a = max(0, a + shift);\n            b = min(int(1e9), b + shift);\n\n            int c = rnd.next(int(1e9/2), int(1e9)); // large cj\n\n            channels[i] = make_tuple(a, b, c);\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"max_efficiency_large_interval\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            videos[i] = {0, int(1e9)};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            channels[i] = make_tuple(0, int(1e9), rnd.next(1, 10)); // small cj\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"zero_length_intervals\") {\n        int point = rnd.next(0, int(1e9));\n\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            videos[i] = {point, point};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            channels[i] = make_tuple(point, point, rnd.next(1, int(1e9)));\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9));\n            int r = rnd.next(l, int(1e9));\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(0, int(1e9));\n            int b = rnd.next(a, int(1e9));\n            int c = rnd.next(1, int(1e9));\n            channels[i] = make_tuple(a, b, c);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"no_overlap\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(5e8 - 1));\n            int r = rnd.next(l, int(5e8 - 1));\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(int(5e8 + 1), int(1e9));\n            int b = rnd.next(a, int(1e9));\n            int c = rnd.next(1, int(1e9));\n            channels[i] = make_tuple(a, b, c);\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"overlapping_at_single_point\") {\n        int point = rnd.next(0, int(1e9));\n\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, point);\n            int r = point;\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int a = point;\n            int b = point;\n            int c = rnd.next(1, int(1e9));\n            channels[i] = make_tuple(a, b, c);\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"max_efficiency_large_cj\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(0, int(1e9 - 1));\n            int r = l + 1; // length 1\n            videos[i] = {l, r};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, n-1);\n            int a = videos[idx].first;\n            int b = videos[idx].second;\n\n            // Shift a bit to make sure overlapping interval exists\n            int shift = rnd.next(-1, 1);\n            a = max(0, a + shift);\n            b = min(int(1e9), b + shift);\n\n            int c = rnd.next(int(1e9/2), int(1e9)); // large cj\n\n            channels[i] = make_tuple(a, b, c);\n        }\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"max_efficiency_large_interval\") {\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            videos[i] = {0, int(1e9)};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            channels[i] = make_tuple(0, int(1e9), rnd.next(1, 10)); // small cj\n        }\n\n        // Output\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else if (type == \"zero_length_intervals\") {\n        int point = rnd.next(0, int(1e9));\n\n        vector<pair<int,int>> videos(n);\n        vector<tuple<int,int,int>> channels(m);\n\n        for (int i = 0; i < n; ++i) {\n            videos[i] = {point, point};\n        }\n\n        for (int i = 0; i < m; ++i) {\n            channels[i] = make_tuple(point, point, rnd.next(1, int(1e9)));\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (auto v : videos) {\n            printf(\"%d %d\\n\", v.first, v.second);\n        }\n        for (auto c : channels) {\n            printf(\"%d %d %d\\n\", get<0>(c), get<1>(c), get<2>(c));\n        }\n    }\n    else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n./gen -n 1 -m 1 -type no_overlap\n./gen -n 100 -m 100 -type random\n./gen -n 1000 -m 1000 -type overlapping_at_single_point\n./gen -n 100000 -m 100000 -type random\n./gen -n 200000 -m 200000 -type max_efficiency_large_cj\n./gen -n 200000 -m 200000 -type max_efficiency_large_interval\n./gen -n 200000 -m 200000 -type zero_length_intervals\n./gen -n 2 -m 2 -type no_overlap\n./gen -n 5 -m 5 -type overlapping_at_single_point\n./gen -n 10 -m 10 -type max_efficiency_large_cj\n./gen -n 10 -m 10 -type max_efficiency_large_interval\n./gen -n 200000 -m 200000 -type no_overlap\n./gen -n 200000 -m 200000 -type overlapping_at_single_point\n./gen -n 200000 -m 200000 -type random\n./gen -n 50 -m 50 -type zero_length_intervals\n./gen -n 1 -m 1 -type zero_length_intervals\n./gen -n 1 -m 1 -type overlapping_at_single_point\n./gen -n 1 -m 200000 -type random\n./gen -n 200000 -m 1 -type random\n./gen -n 1 -m 1 -type max_efficiency_large_cj\n./gen -n 1 -m 1 -type max_efficiency_large_interval\n./gen -n 50000 -m 50000 -type random\n./gen -n 1000 -m 1000 -type zero_length_intervals\n./gen -n 200000 -m 200000 -type max_efficiency_large_cj\n./gen -n 200000 -m 200000 -type zero_length_intervals\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:54.834833",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "542/B",
      "title": "B. Охота на уток",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных записаны целые числа n, r (1 ≤ n ≤ 200 000, 1 ≤ r ≤ 109) — количество уток и минимальное время в секундах между выстрелами. Далее следуют n строк, каждая из которых содержит два целых числа hi, ti ( - 109 ≤ hi < ti ≤ 109) — абсцисса головы и хвоста i-й утки в момент времени 0.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальное количество уток, которые могут быть подстрелены охотником.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3-3 01 3-1 2Выходные данныеСкопировать3Входные данныеСкопировать4 5-1 12 45 96 8Выходные данныеСкопировать3",
      "description": "B. Охота на уток\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных записаны целые числа n, r (1 ≤ n ≤ 200 000, 1 ≤ r ≤ 109) — количество уток и минимальное время в секундах между выстрелами. Далее следуют n строк, каждая из которых содержит два целых числа hi, ti ( - 109 ≤ hi < ti ≤ 109) — абсцисса головы и хвоста i-й утки в момент времени 0.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальное количество уток, которые могут быть подстрелены охотником.\n\nВыходные данные\n\nВходные данныеСкопировать3 3-3 01 3-1 2Выходные данныеСкопировать3Входные данныеСкопировать4 5-1 12 45 96 8Выходные данныеСкопировать3\n\nВходные данныеСкопировать3 3-3 01 3-1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 5-1 12 45 96 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере охотник должен выстрелить в момент времени 0, этим выстрелом он собьёт уток 1 и 3. Затем ему надо перезарядить ружьё и выстрелить опять в момент времени 3. Вторым выстрелом он попадет в хвост утки 2.Во втором примере охотник может произвести выстрелы в моменты времени 0 и 6, чтобы сбить трёх уток.",
      "solutions": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces",
          "content": "В воскресенье, 3-го мая, в 19:00 начнётся Раунд 3 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять участие все те команды, которые отобрались в Раунде 2 или в Уайлд-кард раунде 2. Напомним, что из второго раунда допущены все те команды, что набрали не менее 928 баллов. В уайлд-кард раунде 2 было достаточно набрать 1827 баллов. Таким образом, принять участие в Раунде 2 могут 100 + 20 = 120 команд!Участников ждет соревнование по правилам классических раундов Codeforces. Раунд 3 пройдёт в таком же формате, как и Раунд 2 — с онлайн-трансляцией, рейтинговой и доступной только для див-1 участников. Будет использована плавная динамическая система оценки задач, но сами задачи будут расположены в случайном порядке. Участникам будет предложено 6 задач.Раунд подготовлен силами команды Codeforces, команды VK и пользователя yeputons. Как всегда, неоценимую помощь в тестировании задач оказали winger и AlexFetisov.Напомним, что в Финал VK Cup пройдут все те команды, которые наберут положительный балл, не меньший, чем у команды на 20-м месте. Также обращаем ваше внимание, что участники всех команд, прошедших в Раунд 3 (независимо от их участия или неучастия в Раунде 3 или в его трансляции), получат фирменную футболку Чемпионата. Помимо этого, фирменной футболкой будут награждены топ-50 участников интернет-трансляции Раунда 3.Желаем удачи и интересной борьбы!UPD1 Раунд 3 завершён! Поздравляем топ-20 команд, которые отправятся в июле на Финал VK Cup 2015! Следите за объявлениями на сайте, точная информация о финальном раунде появится позднее.UPD2 Тем временем появился разбор.",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17690",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1709
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*B"
          },
          "content_length": 9762
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*B"
          },
          "content_length": 9762
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 1",
          "code": "несовершеннолетние участники",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 2",
          "code": "Div1-contestants",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 3",
          "code": "Wrong Anser on test 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 4",
          "code": "int dp[N][T]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 5",
          "code": "int dp[T][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 6",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 7",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(-1000000000, 1000000000, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(-1000000000, 1000000000, \"ti\");\n        ensuref(hi <= ti, \"For duck %d, hi (%d) should be <= ti (%d)\", i+1, hi, ti);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(-1000000000, 1000000000, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(-1000000000, 1000000000, \"ti\");\n        ensuref(hi <= ti, \"For duck %d, hi (%d) should be <= ti (%d)\", i+1, hi, ti);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int r = inf.readInt(1, 1000000000, \"r\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int hi = inf.readInt(-1000000000, 1000000000, \"hi\");\n        inf.readSpace();\n        int ti = inf.readInt(-1000000000, 1000000000, \"ti\");\n        ensuref(hi <= ti, \"For duck %d, hi (%d) should be <= ti (%d)\", i+1, hi, ti);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, r);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(-1000000000, 999999999);\n            int min_ti = hi + 1;\n            int max_ti = 1000000000;\n            if (min_ti > max_ti) min_ti = max_ti; // Adjust if necessary\n            int ti = rnd.next(min_ti, max_ti);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"allAtZero\") {\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(-1000000000, -1);\n            int min_ti = max(hi + 1, 0);\n            int max_ti = 1000000000;\n            if (min_ti > max_ti) min_ti = max_ti;\n            int ti = rnd.next(min_ti, max_ti);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"farAway\") {\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(1, 999999999);\n            int min_ti = hi + 1;\n            int max_ti = 1000000000;\n            int ti = rnd.next(min_ti, max_ti);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"negativeFar\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(-1000000000, -1);\n            int max_hi = ti - 1; // Ensure hi < ti\n            int hi = rnd.next(-1000000000, max_hi);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"edgeCases\") {\n        int hi_values[] = {-1000000000, -1, 0, 1};\n        int ti_values[] = {0, 1, 999999999, 1000000000};\n        for (int i = 0; i < n; ++i) {\n            int hi = hi_values[rnd.next(0, 3)];\n            int ti = ti_values[rnd.next(0, 3)];\n            if (hi >= ti) {\n                ti = hi + 1;\n                if (ti > 1000000000) ti = 1000000000;\n            }\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"overlap\") {\n        int start = rnd.next(-1000000, 999999000);\n        int duration = rnd.next(1, 1000);\n        int end = start + duration;\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(start - 1000, start);\n            int ti = rnd.next(end, end + 1000);\n            if (hi >= ti) ti = hi + 1;\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"nonoverlap\") {\n        int t = 0;\n        for (int i = 0; i < n; ++i) {\n            int hi = t;\n            int ti = t + rnd.next(1, 10);\n            printf(\"%d %d\\n\", hi, ti);\n            t += rnd.next(20, 100); // Ensure non-overlapping intervals\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int r = opt<int>(\"r\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, r);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(-1000000000, 999999999);\n            int min_ti = hi + 1;\n            int max_ti = 1000000000;\n            if (min_ti > max_ti) min_ti = max_ti; // Adjust if necessary\n            int ti = rnd.next(min_ti, max_ti);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"allAtZero\") {\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(-1000000000, -1);\n            int min_ti = max(hi + 1, 0);\n            int max_ti = 1000000000;\n            if (min_ti > max_ti) min_ti = max_ti;\n            int ti = rnd.next(min_ti, max_ti);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"farAway\") {\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(1, 999999999);\n            int min_ti = hi + 1;\n            int max_ti = 1000000000;\n            int ti = rnd.next(min_ti, max_ti);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"negativeFar\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(-1000000000, -1);\n            int max_hi = ti - 1; // Ensure hi < ti\n            int hi = rnd.next(-1000000000, max_hi);\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"edgeCases\") {\n        int hi_values[] = {-1000000000, -1, 0, 1};\n        int ti_values[] = {0, 1, 999999999, 1000000000};\n        for (int i = 0; i < n; ++i) {\n            int hi = hi_values[rnd.next(0, 3)];\n            int ti = ti_values[rnd.next(0, 3)];\n            if (hi >= ti) {\n                ti = hi + 1;\n                if (ti > 1000000000) ti = 1000000000;\n            }\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"overlap\") {\n        int start = rnd.next(-1000000, 999999000);\n        int duration = rnd.next(1, 1000);\n        int end = start + duration;\n        for (int i = 0; i < n; ++i) {\n            int hi = rnd.next(start - 1000, start);\n            int ti = rnd.next(end, end + 1000);\n            if (hi >= ti) ti = hi + 1;\n            printf(\"%d %d\\n\", hi, ti);\n        }\n    } else if (type == \"nonoverlap\") {\n        int t = 0;\n        for (int i = 0; i < n; ++i) {\n            int hi = t;\n            int ti = t + rnd.next(1, 10);\n            printf(\"%d %d\\n\", hi, ti);\n            t += rnd.next(20, 100); // Ensure non-overlapping intervals\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -r 1 -type random\n./gen -n 2 -r 1 -type random\n./gen -n 10 -r 3 -type random\n./gen -n 100 -r 5 -type random\n./gen -n 1000 -r 10 -type random\n./gen -n 10000 -r 100 -type random\n./gen -n 100000 -r 1000 -type random\n./gen -n 200000 -r 1000000000 -type random\n\n./gen -n 1 -r 1 -type allAtZero\n./gen -n 10 -r 1 -type allAtZero\n./gen -n 100 -r 1 -type allAtZero\n./gen -n 1000 -r 1 -type allAtZero\n./gen -n 10000 -r 1 -type allAtZero\n./gen -n 100000 -r 1 -type allAtZero\n./gen -n 200000 -r 1 -type allAtZero\n\n./gen -n 1 -r 1 -type farAway\n./gen -n 10 -r 1 -type farAway\n./gen -n 100 -r 1 -type farAway\n./gen -n 1000 -r 1 -type negativeFar\n\n./gen -n 1000 -r 1 -type edgeCases\n./gen -n 10000 -r 1 -type edgeCases\n./gen -n 100000 -r 1 -type edgeCases\n./gen -n 1 -r 1 -type edgeCases\n./gen -n 1 -r 1000000000 -type edgeCases\n./gen -n 200000 -r 1000000000 -type edgeCases\n\n./gen -n 1000 -r 1 -type overlap\n./gen -n 10000 -r 1 -type overlap\n./gen -n 100000 -r 1 -type overlap\n\n./gen -n 1000 -r 1 -type nonoverlap\n./gen -n 10000 -r 1 -type nonoverlap\n./gen -n 100000 -r 1 -type nonoverlap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:56.655231",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "542/C",
      "title": "C. Идемпотентная функция",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных следует целое число n (1 ≤ n ≤ 200) — количество элементов в области определения функции f.Во второй строке следуют через пробел числа f(1), f(2), ..., f(n) (1 ≤ f(i) ≤ n для всех 1 ≤ i ≤ n) — значения функции.",
      "output_spec": "Выходные данныеВыведите такое минимальное k, что функция f(k)(x) — идемпотентная.",
      "sample_tests": "ПримерыВходные данныеСкопировать41 2 2 4Выходные данныеСкопировать1Входные данныеСкопировать32 3 3Выходные данныеСкопировать2Входные данныеСкопировать32 3 1Выходные данныеСкопировать3",
      "description": "C. Идемпотентная функция\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных следует целое число n (1 ≤ n ≤ 200) — количество элементов в области определения функции f.Во второй строке следуют через пробел числа f(1), f(2), ..., f(n) (1 ≤ f(i) ≤ n для всех 1 ≤ i ≤ n) — значения функции.\n\nВходные данные\n\nВыходные данныеВыведите такое минимальное k, что функция f(k)(x) — идемпотентная.\n\nВыходные данные\n\nВходные данныеСкопировать41 2 2 4Выходные данныеСкопировать1Входные данныеСкопировать32 3 3Выходные данныеСкопировать2Входные данныеСкопировать32 3 1Выходные данныеСкопировать3\n\nВходные данныеСкопировать41 2 2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать32 3 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать32 3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия функция f(x) = f(1)(x) уже является идемпотентной, так как f(f(1)) = f(1) = 1, f(f(2)) = f(2) = 2, f(f(3)) = f(3) = 2, f(f(4)) = f(4) = 4.Второй тест из условия устроен следующим образом:   функция f(x) = f(1)(x) не является идемпотентной, так как, например, f(f(1)) = 3, при этом f(1) = 2;  функция f(x) = f(2)(x) является идемпотентной, так как для неё выполнено тождество f(2)(x) = 3, а значит и f(2)(f(2)(x)) = 3. Третий тест из условия устроен следующим образом:   функция f(x) = f(1)(x) не является идемпотентной, так как, например, f(f(1)) = 3, при этом f(1) = 2;  функция f(f(x)) = f(2)(x) не является идемпотентной, так как, например, f(2)(f(2)(1)) = 2, при этом f(2)(1) = 3;  функция f(f(f(x))) = f(3)(x) является идемпотентной, так как она тождественная: f(3)(x) = x для любого , а значит тождество f(3)(f(3)(x)) = f(3)(x) также выполнено.",
      "solutions": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces",
          "content": "В воскресенье, 3-го мая, в 19:00 начнётся Раунд 3 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять участие все те команды, которые отобрались в Раунде 2 или в Уайлд-кард раунде 2. Напомним, что из второго раунда допущены все те команды, что набрали не менее 928 баллов. В уайлд-кард раунде 2 было достаточно набрать 1827 баллов. Таким образом, принять участие в Раунде 2 могут 100 + 20 = 120 команд!Участников ждет соревнование по правилам классических раундов Codeforces. Раунд 3 пройдёт в таком же формате, как и Раунд 2 — с онлайн-трансляцией, рейтинговой и доступной только для див-1 участников. Будет использована плавная динамическая система оценки задач, но сами задачи будут расположены в случайном порядке. Участникам будет предложено 6 задач.Раунд подготовлен силами команды Codeforces, команды VK и пользователя yeputons. Как всегда, неоценимую помощь в тестировании задач оказали winger и AlexFetisov.Напомним, что в Финал VK Cup пройдут все те команды, которые наберут положительный балл, не меньший, чем у команды на 20-м месте. Также обращаем ваше внимание, что участники всех команд, прошедших в Раунд 3 (независимо от их участия или неучастия в Раунде 3 или в его трансляции), получат фирменную футболку Чемпионата. Помимо этого, фирменной футболкой будут награждены топ-50 участников интернет-трансляции Раунда 3.Желаем удачи и интересной борьбы!UPD1 Раунд 3 завершён! Поздравляем топ-20 команд, которые отправятся в июле на Финал VK Cup 2015! Следите за объявлениями на сайте, точная информация о финальном раунде появится позднее.UPD2 Тем временем появился разбор.",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17690",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1709
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*C"
          },
          "content_length": 9762
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*C"
          },
          "content_length": 9762
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 1",
          "code": "несовершеннолетние участники",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 2",
          "code": "Div1-contestants",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 3",
          "code": "Wrong Anser on test 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 4",
          "code": "int dp[N][T]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 5",
          "code": "int dp[T][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 6",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 7",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1,200,\"n\");\n    inf.readEoln();\n    vector<int> f = inf.readInts(n,1,n,\"f\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1,200,\"n\");\n    inf.readEoln();\n    vector<int> f = inf.readInts(n,1,n,\"f\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1,200,\"n\");\n    inf.readEoln();\n    vector<int> f = inf.readInts(n,1,n,\"f\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // Default k=1\n    int c = opt<int>(\"c\", -1); // Used in 'fixed_point' type\n\n    vector<int> f(n);\n    if (type == \"idempotent\") {\n        // Identity function: f(i) = i\n        for (int i = 0; i < n; i++) {\n            f[i] = i + 1;\n        }\n    } else if (type == \"fixed_point\") {\n        // All elements map to a fixed point c\n        if (c == -1) {\n            c = rnd.next(1, n);\n        }\n        ensure(1 <= c && c <= n);\n        for (int i = 0; i < n; i++) {\n            f[i] = c;\n        }\n    } else if (type == \"cycle\") {\n        // Single cycle of length n\n        vector<int> perm(n);\n        for (int i = 0; i < n; i++) {\n            perm[i] = i + 1;\n        }\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 0; i < n; i++) {\n            f[perm[i] - 1] = perm[(i + 1) % n];\n        }\n    } else if (type == \"random\") {\n        // Random mapping f(i) ∈ [1, n]\n        for (int i = 0; i < n; i++) {\n            f[i] = rnd.next(1, n);\n        }\n    } else if (type == \"cycles_with_k\") {\n        // Create cycles whose LCM of lengths is k\n        vector<int> cycle_lengths;\n        int remaining_n = n;\n\n        if (k == 1) {\n            // All cycles of length 1\n            for (int i = 0; i < n; i++) {\n                f[i] = i + 1;\n            }\n        } else {\n            // Decompose k into prime factors to create cycles\n            int temp_k = k;\n            vector<int> factors;\n            for (int i = 2; i <= temp_k && temp_k > 1; i++) {\n                if (temp_k % i == 0) {\n                    int cnt = 0;\n                    while (temp_k % i == 0) {\n                        cnt++;\n                        temp_k /= i;\n                    }\n                    // Add cycles of length i\n                    for (int j = 0; j < cnt; j++) {\n                        factors.push_back(i);\n                    }\n                }\n            }\n            int total_length = accumulate(factors.begin(), factors.end(), 0);\n            if (total_length > n) {\n                // Not possible to fit cycles into n\n                fprintf(stderr, \"Cannot create cycles with LCM %d in n=%d elements\\n\", k, n);\n                exit(1);\n            }\n            // Pad with cycles of length 1\n            int ones = n - total_length;\n            cycle_lengths.insert(cycle_lengths.end(), ones, 1);\n            cycle_lengths.insert(cycle_lengths.end(), factors.begin(), factors.end());\n            shuffle(cycle_lengths.begin(), cycle_lengths.end());\n\n            // Create cycles\n            vector<int> nodes(n);\n            for (int i = 0; i < n; i++) nodes[i] = i + 1;\n            shuffle(nodes.begin(), nodes.end());\n\n            int idx = 0;\n            for (int len : cycle_lengths) {\n                if (len == 1) {\n                    f[nodes[idx] - 1] = nodes[idx];\n                    idx++;\n                } else {\n                    for (int i = 0; i < len; i++) {\n                        f[nodes[idx + i] - 1] = nodes[idx + (i + 1) % len];\n                    }\n                    idx += len;\n                }\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the function\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", f[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", 1); // Default k=1\n    int c = opt<int>(\"c\", -1); // Used in 'fixed_point' type\n\n    vector<int> f(n);\n    if (type == \"idempotent\") {\n        // Identity function: f(i) = i\n        for (int i = 0; i < n; i++) {\n            f[i] = i + 1;\n        }\n    } else if (type == \"fixed_point\") {\n        // All elements map to a fixed point c\n        if (c == -1) {\n            c = rnd.next(1, n);\n        }\n        ensure(1 <= c && c <= n);\n        for (int i = 0; i < n; i++) {\n            f[i] = c;\n        }\n    } else if (type == \"cycle\") {\n        // Single cycle of length n\n        vector<int> perm(n);\n        for (int i = 0; i < n; i++) {\n            perm[i] = i + 1;\n        }\n        shuffle(perm.begin(), perm.end());\n\n        for (int i = 0; i < n; i++) {\n            f[perm[i] - 1] = perm[(i + 1) % n];\n        }\n    } else if (type == \"random\") {\n        // Random mapping f(i) ∈ [1, n]\n        for (int i = 0; i < n; i++) {\n            f[i] = rnd.next(1, n);\n        }\n    } else if (type == \"cycles_with_k\") {\n        // Create cycles whose LCM of lengths is k\n        vector<int> cycle_lengths;\n        int remaining_n = n;\n\n        if (k == 1) {\n            // All cycles of length 1\n            for (int i = 0; i < n; i++) {\n                f[i] = i + 1;\n            }\n        } else {\n            // Decompose k into prime factors to create cycles\n            int temp_k = k;\n            vector<int> factors;\n            for (int i = 2; i <= temp_k && temp_k > 1; i++) {\n                if (temp_k % i == 0) {\n                    int cnt = 0;\n                    while (temp_k % i == 0) {\n                        cnt++;\n                        temp_k /= i;\n                    }\n                    // Add cycles of length i\n                    for (int j = 0; j < cnt; j++) {\n                        factors.push_back(i);\n                    }\n                }\n            }\n            int total_length = accumulate(factors.begin(), factors.end(), 0);\n            if (total_length > n) {\n                // Not possible to fit cycles into n\n                fprintf(stderr, \"Cannot create cycles with LCM %d in n=%d elements\\n\", k, n);\n                exit(1);\n            }\n            // Pad with cycles of length 1\n            int ones = n - total_length;\n            cycle_lengths.insert(cycle_lengths.end(), ones, 1);\n            cycle_lengths.insert(cycle_lengths.end(), factors.begin(), factors.end());\n            shuffle(cycle_lengths.begin(), cycle_lengths.end());\n\n            // Create cycles\n            vector<int> nodes(n);\n            for (int i = 0; i < n; i++) nodes[i] = i + 1;\n            shuffle(nodes.begin(), nodes.end());\n\n            int idx = 0;\n            for (int len : cycle_lengths) {\n                if (len == 1) {\n                    f[nodes[idx] - 1] = nodes[idx];\n                    idx++;\n                } else {\n                    for (int i = 0; i < len; i++) {\n                        f[nodes[idx + i] - 1] = nodes[idx + (i + 1) % len];\n                    }\n                    idx += len;\n                }\n            }\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the function\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", f[i], (i + 1 == n) ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type idempotent\n\n./gen -n 1 -type fixed_point -c 1\n\n./gen -n 1 -type random\n\n./gen -n 2 -type idempotent\n\n./gen -n 2 -type fixed_point -c 1\n\n./gen -n 2 -type fixed_point -c 2\n\n./gen -n 2 -type random\n\n./gen -n 3 -type idempotent\n\n./gen -n 3 -type fixed_point -c 1\n\n./gen -n 3 -type fixed_point -c 2\n\n./gen -n 3 -type fixed_point -c 3\n\n./gen -n 3 -type random\n\n./gen -n 3 -type cycles_with_k -k 3\n\n./gen -n 3 -type cycles_with_k -k 2\n\n./gen -n 5 -type cycles_with_k -k 6\n\n./gen -n 5 -type cycles_with_k -k 3\n\n./gen -n 7 -type cycles_with_k -k 7\n\n./gen -n 7 -type cycles_with_k -k 5\n\n./gen -n 10 -type idempotent\n\n./gen -n 10 -type fixed_point -c 5\n\n./gen -n 10 -type cycle\n\n./gen -n 10 -type random\n\n./gen -n 10 -type cycles_with_k -k 4\n\n./gen -n 10 -type cycles_with_k -k 10\n\n./gen -n 15 -type cycles_with_k -k 6\n\n./gen -n 20 -type cycles_with_k -k 15\n\n./gen -n 50 -type idempotent\n\n./gen -n 50 -type fixed_point -c 25\n\n./gen -n 50 -type cycle\n\n./gen -n 50 -type random\n\n./gen -n 50 -type cycles_with_k -k 12\n\n./gen -n 50 -type cycles_with_k -k 18\n\n./gen -n 50 -type cycles_with_k -k 30\n\n./gen -n 100 -type cycles_with_k -k 15\n\n./gen -n 100 -type cycles_with_k -k 20\n\n./gen -n 100 -type cycles_with_k -k 60\n\n./gen -n 200 -type cycles_with_k -k 100\n\n./gen -n 200 -type cycles_with_k -k 150\n\n./gen -n 200 -type cycles_with_k -k 200\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:58.579384",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "542/D",
      "title": "D. Супергеройская работа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке ввода задано единственное целое число A (1 ≤ A ≤ 1012).",
      "output_spec": "Выходные данныеВыведите количество решений уравнения J(x) = A.",
      "sample_tests": "ПримерыВходные данныеСкопировать3Выходные данныеСкопировать1Входные данныеСкопировать24Выходные данныеСкопировать3",
      "description": "D. Супергеройская работа\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке ввода задано единственное целое число A (1 ≤ A ≤ 1012).\n\nВходные данные\n\nВыходные данныеВыведите количество решений уравнения J(x) = A.\n\nВыходные данные\n\nВходные данныеСкопировать3Выходные данныеСкопировать1Входные данныеСкопировать24Выходные данныеСкопировать3\n\nВходные данныеСкопировать3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать24\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЗапись x|n означает, что число n делится на число x без остатка.Под  следует понимать наибольшее целое положительное число, на которое делится без остатка как a, так и b.В первом тесте из условия единственное подходящее значение x это 2. Тогда J(2) = 1 + 2.Во втором тесте из условия подходят следующие значения x:  x = 14, J(14) = 1 + 2 + 7 + 14 = 24  x = 15, J(15) = 1 + 3 + 5 + 15 = 24  x = 23, J(23) = 1 + 23 = 24",
      "solutions": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces",
          "content": "В воскресенье, 3-го мая, в 19:00 начнётся Раунд 3 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять участие все те команды, которые отобрались в Раунде 2 или в Уайлд-кард раунде 2. Напомним, что из второго раунда допущены все те команды, что набрали не менее 928 баллов. В уайлд-кард раунде 2 было достаточно набрать 1827 баллов. Таким образом, принять участие в Раунде 2 могут 100 + 20 = 120 команд!Участников ждет соревнование по правилам классических раундов Codeforces. Раунд 3 пройдёт в таком же формате, как и Раунд 2 — с онлайн-трансляцией, рейтинговой и доступной только для див-1 участников. Будет использована плавная динамическая система оценки задач, но сами задачи будут расположены в случайном порядке. Участникам будет предложено 6 задач.Раунд подготовлен силами команды Codeforces, команды VK и пользователя yeputons. Как всегда, неоценимую помощь в тестировании задач оказали winger и AlexFetisov.Напомним, что в Финал VK Cup пройдут все те команды, которые наберут положительный балл, не меньший, чем у команды на 20-м месте. Также обращаем ваше внимание, что участники всех команд, прошедших в Раунд 3 (независимо от их участия или неучастия в Раунде 3 или в его трансляции), получат фирменную футболку Чемпионата. Помимо этого, фирменной футболкой будут награждены топ-50 участников интернет-трансляции Раунда 3.Желаем удачи и интересной борьбы!UPD1 Раунд 3 завершён! Поздравляем топ-20 команд, которые отправятся в июле на Финал VK Cup 2015! Следите за объявлениями на сайте, точная информация о финальном раунде появится позднее.UPD2 Тем временем появился разбор.",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17690",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1709
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*D"
          },
          "content_length": 9762
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*D"
          },
          "content_length": 9762
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 1",
          "code": "несовершеннолетние участники",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 2",
          "code": "Div1-contestants",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 3",
          "code": "Wrong Anser on test 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 4",
          "code": "int dp[N][T]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 5",
          "code": "int dp[T][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 6",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 7",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long A = inf.readLong(1, 1000000000000LL, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long A = inf.readLong(1, 1000000000000LL, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long A = inf.readLong(1, 1000000000000LL, \"A\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long A = opt<long long>(\"A\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (A != -1) {\n        if (A < 1LL || A > 1000000000000LL) {\n            fprintf(stderr, \"Invalid A value\\n\");\n            return 1;\n        }\n    } else {\n        if (type == \"random\") {\n            A = rnd.next(1LL, 1000000000000LL);\n        } else if (type == \"small\") {\n            A = rnd.next(1LL, 1000LL);\n        } else if (type == \"large\") {\n            A = rnd.next(1000000000000LL - 1000LL, 1000000000000LL);\n        } else if (type == \"min\") {\n            A = 1LL;\n        } else if (type == \"max\") {\n            A = 1000000000000LL;\n        } else if (type == \"special\") {\n            vector<long long> special_numbers = {\n                1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 28LL, 496LL,\n                8128LL, 33550336LL, 8589869056LL, 137438691328LL\n            };\n            A = special_numbers[rnd.next(0, (int)special_numbers.size() - 1)];\n        } else if (type == \"perfect\") {\n            vector<long long> perfect_numbers = {\n                6LL, 28LL, 496LL, 8128LL, 33550336LL, 8589869056LL, 137438691328LL\n            };\n            A = perfect_numbers[rnd.next(0, (int)perfect_numbers.size() - 1)];\n        } else if (type == \"prime\") {\n            vector<long long> primes = {\n                999999937LL, 999999929LL, 999999883LL, 1000000007LL, 1000000009LL\n            };\n            A = primes[rnd.next(0, (int)primes.size() - 1)];\n        } else {\n            fprintf(stderr, \"Invalid type or A not specified\\n\");\n            return 1;\n        }\n    }\n\n    printf(\"%lld\\n\", A);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long A = opt<long long>(\"A\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (A != -1) {\n        if (A < 1LL || A > 1000000000000LL) {\n            fprintf(stderr, \"Invalid A value\\n\");\n            return 1;\n        }\n    } else {\n        if (type == \"random\") {\n            A = rnd.next(1LL, 1000000000000LL);\n        } else if (type == \"small\") {\n            A = rnd.next(1LL, 1000LL);\n        } else if (type == \"large\") {\n            A = rnd.next(1000000000000LL - 1000LL, 1000000000000LL);\n        } else if (type == \"min\") {\n            A = 1LL;\n        } else if (type == \"max\") {\n            A = 1000000000000LL;\n        } else if (type == \"special\") {\n            vector<long long> special_numbers = {\n                1LL, 2LL, 3LL, 4LL, 5LL, 6LL, 28LL, 496LL,\n                8128LL, 33550336LL, 8589869056LL, 137438691328LL\n            };\n            A = special_numbers[rnd.next(0, (int)special_numbers.size() - 1)];\n        } else if (type == \"perfect\") {\n            vector<long long> perfect_numbers = {\n                6LL, 28LL, 496LL, 8128LL, 33550336LL, 8589869056LL, 137438691328LL\n            };\n            A = perfect_numbers[rnd.next(0, (int)perfect_numbers.size() - 1)];\n        } else if (type == \"prime\") {\n            vector<long long> primes = {\n                999999937LL, 999999929LL, 999999883LL, 1000000007LL, 1000000009LL\n            };\n            A = primes[rnd.next(0, (int)primes.size() - 1)];\n        } else {\n            fprintf(stderr, \"Invalid type or A not specified\\n\");\n            return 1;\n        }\n    }\n\n    printf(\"%lld\\n\", A);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -A 1\n./gen -A 2\n./gen -A 3\n./gen -A 4\n./gen -A 5\n./gen -A 6\n./gen -A 28\n./gen -A 496\n./gen -A 8128\n./gen -A 33550336\n./gen -A 8589869056\n\n./gen -A 1000\n./gen -A 1000000\n./gen -A 999999\n./gen -A 1000000000000\n./gen -A 999999999999\n\n./gen -type min\n./gen -type max\n\n./gen -type small\n./gen -type small\n./gen -type small\n\n./gen -type large\n./gen -type large\n./gen -type large\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type special\n./gen -type special\n./gen -type special\n\n./gen -type perfect\n./gen -type perfect\n./gen -type perfect\n\n./gen -type prime\n./gen -type prime\n./gen -type prime\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:00.948697",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "542/E",
      "title": "E. Playing on Graph",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 100 000) — the number of vertices and the number of edges in the original graph.Next m lines contain the descriptions of edges in the format ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which means that there is an edge between vertices ai and bi. It is guaranteed that there is at most one edge between each pair of vertexes.",
      "output_spec": "OutputIf it is impossible to obtain a chain from the given graph, print  - 1. Otherwise, print the maximum possible number of edges in the resulting chain.",
      "sample_tests": "ExamplesInputCopy5 41 22 33 43 5OutputCopy3InputCopy4 61 22 31 33 42 41 4OutputCopy-1InputCopy4 21 32 4OutputCopy2",
      "description": "E. Playing on Graph\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n ≤ 1000, 0 ≤ m ≤ 100 000) — the number of vertices and the number of edges in the original graph.Next m lines contain the descriptions of edges in the format ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), which means that there is an edge between vertices ai and bi. It is guaranteed that there is at most one edge between each pair of vertexes.\n\nOutputIf it is impossible to obtain a chain from the given graph, print  - 1. Otherwise, print the maximum possible number of edges in the resulting chain.\n\nInputCopy5 41 22 33 43 5OutputCopy3InputCopy4 61 22 31 33 42 41 4OutputCopy-1InputCopy4 21 32 4OutputCopy2\n\nInputCopy5 41 22 33 43 5\n\nOutputCopy3\n\nInputCopy4 61 22 31 33 42 41 4\n\nOutputCopy-1\n\nInputCopy4 21 32 4\n\nOutputCopy2\n\nNoteIn the first sample test you can contract vertices 4 and 5 and obtain a chain of length 3.In the second sample test it is initially impossible to contract any pair of vertexes, so it is impossible to achieve the desired result.In the third sample test you can contract vertices 1 and 2 and obtain a chain of length 2.",
      "solutions": [
        {
          "title": "VK Cup Round 3 online mirror - Codeforces",
          "content": "This Sunday, May 3-rd, 19:00 Moscow Time there will be Round 3 of VK Cup 2015 Championship!As in Round 2, there will also be an online mirror that is rated round available only for Div1-contestants. There will be 6 task in random order and a smooth dynamic scoring system.Round was brought to you by Codeforces team, VK team and yeputons. As usual, we want to thank winger and AlexFetisov for a great testing help.Top-50 participants of online mirror will get a nice VK Cup T-Shirt! Good luck and have fun!UPD1 The round is over! Congratulations to all contestants in top-50, you will get a nice VK Cup 2015 Championship T-Shirt soon! There will be an editorial soon, stay tuned...UPD2 Finally, the editorial is ready!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17690",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 718
        },
        {
          "title": "VK Cup Round 3 editorial - Codeforces",
          "content": "542A - Place Your Ad HereLet's fix the TV channel window and look for a commerical having the largest intersection with it. There are four types of commercials: lying inside the window, overlapping the window and partially intersecting the window from the left and from the right.It's easy to determine if there is overlapping commercial: it's enough to sort commercials in increasing order of the left end and then while iterating over them from left to right, keep the minimum value of a right end of a commercial. If when we pass the window j and see that current value of the maximum right end is no less than bj then there exists a commercial overlapping our window and the value is equal to the (ri - li)·ci.Among all commercials that lie inside our window we need the longest one. It can be done by similar but a bit harder manner. Let's use sweepline method. While passing through the end of the commercial ri, let's assign in some data structure (like segment tree) the value ri - li in point li. While passing through the end of a window, let's calculate answer for it as a maximum on segment [aj, bj]. By doing this, we consider all commercials inside the window.We can process partially intersecting commercials in the similar way. While passing the right end of the commercial ri let's put the value ri in the point li in our data structure. While passing through the right end of a window bj let's calculate the answer for it as a maximum on the segment [aj, bj] minus aj.Among all answers for all commercials we need to choose the largest one. So we have the solution in . Challenge. What if there are weights not only on windows, but on commercials also, and those weights are multiplied with the intersection length? You can solve this task in and get a virtual medal!542B - Duck HuntFirst of all, let's say that ducks stay still and the one that moves is the hunter. Let's define the value F[x][s] as the minimum number of ducks among having the right end no further than x, that we can't shot if the last shot was in the point s. In particular, the value F[x][s] includes all ducks located inside the segment [s + 1, x]. Values F[x][s] for s > x let's consider as undefined.Let's look on F[x] as on a function of s. This function is defined on all s from 0 to x inclusive. The key idea is in investigating how F[x + 1][·] differs from F[x][·].Let's first suppose that in point x + 1 there is no end of the duck. Then in definition of F[x + 1][·] we consider the same set of the ducks as for the definition f F[x][·]. That means that all values F[x][s] for s ≤ x are the same for F[x + 1]. Let's understand what happens with F[x + 1][x + 1]. It's easy to see that the shot in point x + 1 can't kill any of the ducks that end no further than x + 1 (since we just supposed that there are no ducks ending in exactly x + 1). So, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Now let's suppose that in point x + 1 the duck [l, x + 1] ends. In this case we can say that all values of F[x + 1][0... l - 1] should be increased by 1 (since at the moment of shot in point s < l the duck [l, x + 1] can't be killed yet). From the other hand, all values F[x + 1][l... x + 1] remain the same since the last shot kills the newly added duck.Now let's understand how to implement all this stuff. Function F[x][·] is piecewise constant, so it can be stored in a Cartesian tree as a sequence of pairs (beginning of segment, value on segment). Such storage allows us to easily add 1 on prefix and take minimum on prefix of a function.Now let's think that F[x][·] is defined on all posistive values but the values F[x][s] for s > x do not satisfy the definition of F[x][s] above. In other words, let's just suppose that the lats segment in structure F[x] is infinite in right direction.Let's sweep with the variable x. The function F[x + 1][·] changes in comparsion to F[x][·] very rarely For example, the value F[x + 1][x + 1] is almost always the same as F[x][x + 1] (that is equal to F[x][x] as said above). Indeed, if we suppose that there is no duck ending in x + 1 then F[x][x] = min(F[x][0... x - r]) and F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). So, there is an interesting event only if value F[x][x - r + 1] is smaller than the whole prefix before it. On the other hand, the value min(F[x][0... x - r]) can't increase more than n times by 1 (each time when we pass through the right end of the duck) and so, it also can't decrease more then n times (since it is a non-negative value).So, the events \"we passed through the right end of the duck\" and \"we should non-trivially calculate F[x][x]\" are in total linear. Each of them can be processed in O(1) operation with Cartesian tree, that gives as totally an solution. Whooray! 542C - Idempotent functionsIn order to solve this task it's good to understand how does the graph corresponding the function from {1, ..., n} to itself looks. Let's consider a graph on vertices 1, ..., n with edges from vertex i to the vertex f(i). Such graph always looks like a set of cycles with several trees leading to that cycles. How should the graph look like for function to be the idempotent? It's easy to see that in such graph all cycles should be of length 1 and all vertex that are not cycles of length 1 (i. e. all not fixed points) should immediatly lead to some fixed point.So, we should satisfy two conditions. First, all cycles should become of length 1 — in order to do that k should be divisible by lcm(c1, c2, ..., cm) where ci are the lengths of all cycles. Second, all vertices not lying on cycles should become leading to the vertices lying on cycles. In other words, k should be no less than the distance from any vertex x to the cycle it goes into (or, that the same, the length of pre-period in the sequence f(x), f(f(x)), f(f(f(x))), ...).So, are task is about finding the smallest number k divisible by A that is no less than B, it is not hard at all.Challenge. What is the maximum possible answer for this task? (Answer: first second)542D - Superhero's JobFirst step is to understand the properties of a Joker function. It's important property is that it is multiplicative: J(ab) = J(a)J(b) for (a, b) = 1, so we can write the value of function knowing the factorization of an argument: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Let's use this knowledge in order to solve the task with dynamic programming. Let's denote as P the set of prime p such that the multiple including it may appear in A = J(x). There are not that many such primes: each divisor d of number A can correspond no more than one such prime, namely, the one whose power the number d - 1 is (if it is a prime power at all). Let's calculate the set P and also remember for each prime number p in it in which powers k the value (pk + 1) divides A. Now we can calculate value D[p][d] that is equal to the number of ways to get a divisor d of a number A as a product of brackets of first p primes in set P. Such value can be caluclated by using dynamic programming in time where is the number of divisors of A (as it was shown above that ). So, overall complexity of the solution is .Challenge. How the behaves when A increases? What is the maximum values of over all A ≤ 1012? (The answer: . Nice estimate that is not an exact asymptotic, though, is that )Challenge. What is the maximum answer in this task? If you are able to create a test with answer larger than million, a great respect from me!542E - Playing on GraphFirst, if the original graph isn't bipartite then the answer is (-1). Indeed, any odd cycle, while being contracted by the pair of vertices, always produces an odd cycle of smaller size, so at some point we will get a triangle that blocks us from doing anything.From the other way, each bipartite component can be contracted in order to get a chain whose length is a diameter of the component. Suppose that the pair of vertices (a, b) is a diamater of some connected component. Then, by contracting all vertices located on the same distance from a we can achieve the chain we want.The last step is that the answer fror the original graph is the sum of the answers for all the connected components since we can attach all of them together. So, the answer is the sum of diameters of all connected components if all of them are bipartite, otherwise answer is -1. Solution has the complexity O(E + VE) (The first summand is checking for being bipartite, the second one is calculation diameters by running BFS from each vertex).542F - QuestThis task can be solved in lot of ways. The most straightforward is DP. The task can be seen in the following way. We want some set of vertices as leaves and for each potential leaf we know the upper bound for its depth and its cost.Let's sweep over the tree from down to up. Let's calculate the value D[h][c] that is the maximum possible cost that we can achieve if we stay on the level h and have c vertices on it. For transition let's fix how many leaves of the deepness exactly h we will take (it's easy to see that among them we should task several greatest). Suppose we will take k of them. Then from this state we can move to D[h - 1][⌈(c + k) / 2⌉]. The answer will be located in D[0][1] because when we are on the level 0 we should have the only vertex that is the root of the tree.The complexity of such solution is O(n2T). Challenge Improve the solution above to and then to",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*E"
          },
          "content_length": 9504
        },
        {
          "title": "VK Cup Round 3 editorial - Codeforces",
          "content": "542A - Place Your Ad HereLet's fix the TV channel window and look for a commerical having the largest intersection with it. There are four types of commercials: lying inside the window, overlapping the window and partially intersecting the window from the left and from the right.It's easy to determine if there is overlapping commercial: it's enough to sort commercials in increasing order of the left end and then while iterating over them from left to right, keep the minimum value of a right end of a commercial. If when we pass the window j and see that current value of the maximum right end is no less than bj then there exists a commercial overlapping our window and the value is equal to the (ri - li)·ci.Among all commercials that lie inside our window we need the longest one. It can be done by similar but a bit harder manner. Let's use sweepline method. While passing through the end of the commercial ri, let's assign in some data structure (like segment tree) the value ri - li in point li. While passing through the end of a window, let's calculate answer for it as a maximum on segment [aj, bj]. By doing this, we consider all commercials inside the window.We can process partially intersecting commercials in the similar way. While passing the right end of the commercial ri let's put the value ri in the point li in our data structure. While passing through the right end of a window bj let's calculate the answer for it as a maximum on the segment [aj, bj] minus aj.Among all answers for all commercials we need to choose the largest one. So we have the solution in . Challenge. What if there are weights not only on windows, but on commercials also, and those weights are multiplied with the intersection length? You can solve this task in and get a virtual medal!542B - Duck HuntFirst of all, let's say that ducks stay still and the one that moves is the hunter. Let's define the value F[x][s] as the minimum number of ducks among having the right end no further than x, that we can't shot if the last shot was in the point s. In particular, the value F[x][s] includes all ducks located inside the segment [s + 1, x]. Values F[x][s] for s > x let's consider as undefined.Let's look on F[x] as on a function of s. This function is defined on all s from 0 to x inclusive. The key idea is in investigating how F[x + 1][·] differs from F[x][·].Let's first suppose that in point x + 1 there is no end of the duck. Then in definition of F[x + 1][·] we consider the same set of the ducks as for the definition f F[x][·]. That means that all values F[x][s] for s ≤ x are the same for F[x + 1]. Let's understand what happens with F[x + 1][x + 1]. It's easy to see that the shot in point x + 1 can't kill any of the ducks that end no further than x + 1 (since we just supposed that there are no ducks ending in exactly x + 1). So, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Now let's suppose that in point x + 1 the duck [l, x + 1] ends. In this case we can say that all values of F[x + 1][0... l - 1] should be increased by 1 (since at the moment of shot in point s < l the duck [l, x + 1] can't be killed yet). From the other hand, all values F[x + 1][l... x + 1] remain the same since the last shot kills the newly added duck.Now let's understand how to implement all this stuff. Function F[x][·] is piecewise constant, so it can be stored in a Cartesian tree as a sequence of pairs (beginning of segment, value on segment). Such storage allows us to easily add 1 on prefix and take minimum on prefix of a function.Now let's think that F[x][·] is defined on all posistive values but the values F[x][s] for s > x do not satisfy the definition of F[x][s] above. In other words, let's just suppose that the lats segment in structure F[x] is infinite in right direction.Let's sweep with the variable x. The function F[x + 1][·] changes in comparsion to F[x][·] very rarely For example, the value F[x + 1][x + 1] is almost always the same as F[x][x + 1] (that is equal to F[x][x] as said above). Indeed, if we suppose that there is no duck ending in x + 1 then F[x][x] = min(F[x][0... x - r]) and F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). So, there is an interesting event only if value F[x][x - r + 1] is smaller than the whole prefix before it. On the other hand, the value min(F[x][0... x - r]) can't increase more than n times by 1 (each time when we pass through the right end of the duck) and so, it also can't decrease more then n times (since it is a non-negative value).So, the events \"we passed through the right end of the duck\" and \"we should non-trivially calculate F[x][x]\" are in total linear. Each of them can be processed in O(1) operation with Cartesian tree, that gives as totally an solution. Whooray! 542C - Idempotent functionsIn order to solve this task it's good to understand how does the graph corresponding the function from {1, ..., n} to itself looks. Let's consider a graph on vertices 1, ..., n with edges from vertex i to the vertex f(i). Such graph always looks like a set of cycles with several trees leading to that cycles. How should the graph look like for function to be the idempotent? It's easy to see that in such graph all cycles should be of length 1 and all vertex that are not cycles of length 1 (i. e. all not fixed points) should immediatly lead to some fixed point.So, we should satisfy two conditions. First, all cycles should become of length 1 — in order to do that k should be divisible by lcm(c1, c2, ..., cm) where ci are the lengths of all cycles. Second, all vertices not lying on cycles should become leading to the vertices lying on cycles. In other words, k should be no less than the distance from any vertex x to the cycle it goes into (or, that the same, the length of pre-period in the sequence f(x), f(f(x)), f(f(f(x))), ...).So, are task is about finding the smallest number k divisible by A that is no less than B, it is not hard at all.Challenge. What is the maximum possible answer for this task? (Answer: first second)542D - Superhero's JobFirst step is to understand the properties of a Joker function. It's important property is that it is multiplicative: J(ab) = J(a)J(b) for (a, b) = 1, so we can write the value of function knowing the factorization of an argument: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Let's use this knowledge in order to solve the task with dynamic programming. Let's denote as P the set of prime p such that the multiple including it may appear in A = J(x). There are not that many such primes: each divisor d of number A can correspond no more than one such prime, namely, the one whose power the number d - 1 is (if it is a prime power at all). Let's calculate the set P and also remember for each prime number p in it in which powers k the value (pk + 1) divides A. Now we can calculate value D[p][d] that is equal to the number of ways to get a divisor d of a number A as a product of brackets of first p primes in set P. Such value can be caluclated by using dynamic programming in time where is the number of divisors of A (as it was shown above that ). So, overall complexity of the solution is .Challenge. How the behaves when A increases? What is the maximum values of over all A ≤ 1012? (The answer: . Nice estimate that is not an exact asymptotic, though, is that )Challenge. What is the maximum answer in this task? If you are able to create a test with answer larger than million, a great respect from me!542E - Playing on GraphFirst, if the original graph isn't bipartite then the answer is (-1). Indeed, any odd cycle, while being contracted by the pair of vertices, always produces an odd cycle of smaller size, so at some point we will get a triangle that blocks us from doing anything.From the other way, each bipartite component can be contracted in order to get a chain whose length is a diameter of the component. Suppose that the pair of vertices (a, b) is a diamater of some connected component. Then, by contracting all vertices located on the same distance from a we can achieve the chain we want.The last step is that the answer fror the original graph is the sum of the answers for all the connected components since we can attach all of them together. So, the answer is the sum of diameters of all connected components if all of them are bipartite, otherwise answer is -1. Solution has the complexity O(E + VE) (The first summand is checking for being bipartite, the second one is calculation diameters by running BFS from each vertex).542F - QuestThis task can be solved in lot of ways. The most straightforward is DP. The task can be seen in the following way. We want some set of vertices as leaves and for each potential leaf we know the upper bound for its depth and its cost.Let's sweep over the tree from down to up. Let's calculate the value D[h][c] that is the maximum possible cost that we can achieve if we stay on the level h and have c vertices on it. For transition let's fix how many leaves of the deepness exactly h we will take (it's easy to see that among them we should task several greatest). Suppose we will take k of them. Then from this state we can move to D[h - 1][⌈(c + k) / 2⌉]. The answer will be located in D[0][1] because when we are on the level 0 we should have the only vertex that is the root of the tree.The complexity of such solution is O(n2T). Challenge Improve the solution above to and then to",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*E"
          },
          "content_length": 9504
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 1",
          "code": "Div1-contestants",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 2",
          "code": "Wrong Anser on test 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 3",
          "code": "int dp[N][T]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 4",
          "code": "int dp[T][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 5",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 online mirror - Codeforces - Code 6",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxEdges = min(100000, n * (n - 1) / 2);\n    int m = inf.readInt(0, maxEdges, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Self loops are not allowed: a_i (%d) == b_i (%d)\", a, b);\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(!edges.count(edge), \"Multiple edges between same pair of vertices (%d, %d)\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxEdges = min(100000, n * (n - 1) / 2);\n    int m = inf.readInt(0, maxEdges, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Self loops are not allowed: a_i (%d) == b_i (%d)\", a, b);\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(!edges.count(edge), \"Multiple edges between same pair of vertices (%d, %d)\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int maxEdges = min(100000, n * (n - 1) / 2);\n    int m = inf.readInt(0, maxEdges, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n        ensuref(a != b, \"Self loops are not allowed: a_i (%d) == b_i (%d)\", a, b);\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(!edges.count(edge), \"Multiple edges between same pair of vertices (%d, %d)\", u, v);\n        edges.insert(edge);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generator for the problem \"Vova and Marina\"\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    if (type == \"random_sparse\") {\n        if (m == -1) {\n            int maxEdges = min(100000, n * (n - 1) / 4);\n            int minEdges = n - 1; // Ensure connectedness\n            m = rnd.next(minEdges, maxEdges);\n        }\n        // Generate a random connected sparse graph with m edges\n\n        vector<pair<int, int>> edges;\n\n        // Generate a tree to ensure connectedness\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n\n        set<pair<int,int>> edgeSet;\n        for (auto e : edges) {\n            int a = e.first;\n            int b = e.second;\n            if (a > b) swap(a, b);\n            edgeSet.insert({a, b});\n        }\n\n        int totalPossibleEdges = n * (n - 1) / 2;\n        int remainingEdges = min(m - (n - 1), totalPossibleEdges - (n - 1));\n\n        while ((int)edgeSet.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int,int> e = {a, b};\n            if (edgeSet.count(e)) continue;\n            edgeSet.insert(e);\n            edges.push_back(e);\n        }\n\n        shuffle(edges.begin(), edges.end());\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"random_dense\") {\n        int maxPossibleEdges = n * (n - 1)/2;\n        if (m == -1) {\n            m = min(100000, maxPossibleEdges);\n        }\n        if (m > maxPossibleEdges) m = maxPossibleEdges;\n        vector<pair<int, int>> allEdges;\n\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                allEdges.push_back({i, j});\n\n        shuffle(allEdges.begin(), allEdges.end());\n\n        allEdges.resize(m);\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : allEdges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"chain\") {\n        vector<pair<int, int>> edges;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, n - 1);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"complete\") {\n        int maxPossibleEdges = n * (n - 1)/2;\n        m = min(100000, maxPossibleEdges);\n        vector<pair<int, int>> edges;\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i)\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"star\") {\n        vector<pair<int, int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, n - 1);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"tree\") {\n        vector<pair<int, int>> edges;\n        for(int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n\n        shuffle(edges.begin(), edges.end());\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, n - 1);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"two_components\") {\n        int compSize = n / 2;\n        if (compSize < 1) compSize = 1;\n\n        vector<pair<int, int>> edges;\n        // First component from 1 to compSize\n        for (int i = 1; i < compSize; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Second component from compSize + 1 to n\n        for (int i = compSize + 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"line_and_clique\") {\n        int cliqueSize = n / 2;\n        if (cliqueSize < 2) cliqueSize = 2; // At least size 2\n        int chainStart = cliqueSize + 1;\n\n        vector<pair<int, int>> edges;\n        // Create clique\n        for (int i = 1; i <= cliqueSize; ++i)\n            for (int j = i + 1; j <= cliqueSize; ++j)\n                edges.push_back({i, j});\n        // Create chain\n        for (int i = chainStart; i < n; ++i)\n            edges.push_back({i, i + 1});\n        if (n > cliqueSize) {\n            // Connect chain to clique\n            edges.push_back({rnd.next(1, cliqueSize), chainStart});\n        }\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"no_contractions_possible\") {\n        // Generate a complete graph\n        int maxPossibleEdges = n * (n - 1)/2;\n        m = min(100000, maxPossibleEdges);\n        vector<pair<int, int>> edges;\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i)\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"isolated_vertex\") {\n        int numEdges = n - 2;\n        if (numEdges < 0) numEdges = 0;\n        vector<pair<int, int>> edges;\n        for (int i = 2; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"empty_graph\") {\n        // No edges\n        printf(\"%d %d\\n\", n, 0);\n\n    } else if (type == \"special_case\") {\n        // Handle special cases based on \"case\" parameter\n        string s_case = opt<string>(\"case\", \"none\");\n        if (s_case == \"single_node\") {\n            printf(\"1 0\\n\");\n        } else if (s_case == \"max_edges\") {\n            int maxPossibleEdges = n * (n - 1)/2;\n            m = min(100000, maxPossibleEdges);\n            vector<pair<int, int>> edges;\n            for (int i = 1; i <= n && (int)edges.size() < m; ++i)\n                for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                    edges.push_back({i, j});\n                }\n            // Output n, m\n            printf(\"%d %d\\n\", n, m);\n            for (auto e : edges) {\n                printf(\"%d %d\\n\", e.first, e.second);\n            }\n        } else {\n            // Output empty graph by default\n            printf(\"%d %d\\n\", n, 0);\n        }\n    } else {\n        // Default: generate a random graph\n        if (m == -1) {\n            int maxPossibleEdges = n * (n - 1)/2;\n            m = rnd.next(0, min(100000, maxPossibleEdges));\n        }\n\n        m = min(m, n * (n - 1)/2);\n\n        set<pair<int,int>> edgeSet;\n\n        while ((int)edgeSet.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int,int> e = {a, b};\n            if (edgeSet.count(e)) continue;\n            edgeSet.insert(e);\n        }\n\n        vector<pair<int,int>> edges(edgeSet.begin(), edgeSet.end());\n\n        shuffle(edges.begin(), edges.end());\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Generator for the problem \"Vova and Marina\"\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\"); // Default type is \"random\"\n\n    if (type == \"random_sparse\") {\n        if (m == -1) {\n            int maxEdges = min(100000, n * (n - 1) / 4);\n            int minEdges = n - 1; // Ensure connectedness\n            m = rnd.next(minEdges, maxEdges);\n        }\n        // Generate a random connected sparse graph with m edges\n\n        vector<pair<int, int>> edges;\n\n        // Generate a tree to ensure connectedness\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n\n        set<pair<int,int>> edgeSet;\n        for (auto e : edges) {\n            int a = e.first;\n            int b = e.second;\n            if (a > b) swap(a, b);\n            edgeSet.insert({a, b});\n        }\n\n        int totalPossibleEdges = n * (n - 1) / 2;\n        int remainingEdges = min(m - (n - 1), totalPossibleEdges - (n - 1));\n\n        while ((int)edgeSet.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int,int> e = {a, b};\n            if (edgeSet.count(e)) continue;\n            edgeSet.insert(e);\n            edges.push_back(e);\n        }\n\n        shuffle(edges.begin(), edges.end());\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"random_dense\") {\n        int maxPossibleEdges = n * (n - 1)/2;\n        if (m == -1) {\n            m = min(100000, maxPossibleEdges);\n        }\n        if (m > maxPossibleEdges) m = maxPossibleEdges;\n        vector<pair<int, int>> allEdges;\n\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                allEdges.push_back({i, j});\n\n        shuffle(allEdges.begin(), allEdges.end());\n\n        allEdges.resize(m);\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : allEdges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"chain\") {\n        vector<pair<int, int>> edges;\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, n - 1);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"complete\") {\n        int maxPossibleEdges = n * (n - 1)/2;\n        m = min(100000, maxPossibleEdges);\n        vector<pair<int, int>> edges;\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i)\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"star\") {\n        vector<pair<int, int>> edges;\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, n - 1);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"tree\") {\n        vector<pair<int, int>> edges;\n        for(int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n\n        shuffle(edges.begin(), edges.end());\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, n - 1);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"two_components\") {\n        int compSize = n / 2;\n        if (compSize < 1) compSize = 1;\n\n        vector<pair<int, int>> edges;\n        // First component from 1 to compSize\n        for (int i = 1; i < compSize; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Second component from compSize + 1 to n\n        for (int i = compSize + 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"line_and_clique\") {\n        int cliqueSize = n / 2;\n        if (cliqueSize < 2) cliqueSize = 2; // At least size 2\n        int chainStart = cliqueSize + 1;\n\n        vector<pair<int, int>> edges;\n        // Create clique\n        for (int i = 1; i <= cliqueSize; ++i)\n            for (int j = i + 1; j <= cliqueSize; ++j)\n                edges.push_back({i, j});\n        // Create chain\n        for (int i = chainStart; i < n; ++i)\n            edges.push_back({i, i + 1});\n        if (n > cliqueSize) {\n            // Connect chain to clique\n            edges.push_back({rnd.next(1, cliqueSize), chainStart});\n        }\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"no_contractions_possible\") {\n        // Generate a complete graph\n        int maxPossibleEdges = n * (n - 1)/2;\n        m = min(100000, maxPossibleEdges);\n        vector<pair<int, int>> edges;\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i)\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"isolated_vertex\") {\n        int numEdges = n - 2;\n        if (numEdges < 0) numEdges = 0;\n        vector<pair<int, int>> edges;\n        for (int i = 2; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Output n, m\n        printf(\"%d %d\\n\", n, (int)edges.size());\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n\n    } else if (type == \"empty_graph\") {\n        // No edges\n        printf(\"%d %d\\n\", n, 0);\n\n    } else if (type == \"special_case\") {\n        // Handle special cases based on \"case\" parameter\n        string s_case = opt<string>(\"case\", \"none\");\n        if (s_case == \"single_node\") {\n            printf(\"1 0\\n\");\n        } else if (s_case == \"max_edges\") {\n            int maxPossibleEdges = n * (n - 1)/2;\n            m = min(100000, maxPossibleEdges);\n            vector<pair<int, int>> edges;\n            for (int i = 1; i <= n && (int)edges.size() < m; ++i)\n                for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                    edges.push_back({i, j});\n                }\n            // Output n, m\n            printf(\"%d %d\\n\", n, m);\n            for (auto e : edges) {\n                printf(\"%d %d\\n\", e.first, e.second);\n            }\n        } else {\n            // Output empty graph by default\n            printf(\"%d %d\\n\", n, 0);\n        }\n    } else {\n        // Default: generate a random graph\n        if (m == -1) {\n            int maxPossibleEdges = n * (n - 1)/2;\n            m = rnd.next(0, min(100000, maxPossibleEdges));\n        }\n\n        m = min(m, n * (n - 1)/2);\n\n        set<pair<int,int>> edgeSet;\n\n        while ((int)edgeSet.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int,int> e = {a, b};\n            if (edgeSet.count(e)) continue;\n            edgeSet.insert(e);\n        }\n\n        vector<pair<int,int>> edges(edgeSet.begin(), edgeSet.end());\n\n        shuffle(edges.begin(), edges.end());\n\n        // Output n, m\n        printf(\"%d %d\\n\", n, m);\n        for (auto e : edges) {\n            printf(\"%d %d\\n\", e.first, e.second);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random sparse graphs\n./gen -n 10 -type random_sparse\n./gen -n 10 -type random_dense\n\n# Chains of different sizes\n./gen -n 5 -type chain\n./gen -n 100 -type chain\n./gen -n 1000 -type chain\n\n# Complete graphs of different sizes\n./gen -n 5 -type complete\n./gen -n 50 -type complete\n./gen -n 100 -type complete\n\n# Star graphs\n./gen -n 10 -type star\n./gen -n 100 -type star\n./gen -n 1000 -type star\n\n# Random trees\n./gen -n 10 -type tree\n./gen -n 100 -type tree\n./gen -n 1000 -type tree\n\n# Graphs with two components\n./gen -n 10 -type two_components\n./gen -n 100 -type two_components\n\n# Line connected to a clique\n./gen -n 10 -type line_and_clique\n./gen -n 100 -type line_and_clique\n\n# Graphs where no contractions are possible\n./gen -n 5 -type no_contractions_possible\n./gen -n 100 -type no_contractions_possible\n./gen -n 1000 -type no_contractions_possible\n\n# Graphs with isolated vertices\n./gen -n 10 -type isolated_vertex\n./gen -n 100 -type isolated_vertex\n\n# Empty graphs\n./gen -n 1 -type empty_graph\n./gen -n 100 -type empty_graph\n\n# Special cases\n./gen -n 1 -type special_case -case single_node\n./gen -n 1000 -type special_case -case max_edges\n\n# Random graphs with m specified\n./gen -n 1000 -m 50000 -type random_sparse\n./gen -n 1000 -m 100000 -type random_dense\n\n# Maximum size random graph\n./gen -n 1000 -type random_dense\n\n# Small graphs to test minimal cases\n./gen -n 2 -type chain\n./gen -n 2 -type complete\n./gen -n 2 -type star\n\n# Edge cases\n./gen -n 1 -type chain\n./gen -n 0 -type empty_graph\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:03.143549",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "542/F",
      "title": "F. Квест",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа n и T (1 ≤ n ≤ 1000, 1 ≤ T ≤ 100) — количество заданий, подготовленных Поликарпом, и максимальное время, в которое должен укладываться человек, решающий квест.В последующих n строках находятся по два целых числа ti, qi (1 ≤ ti ≤ T, 1 ≤ qi ≤ 1000) — время в минутах, требуемое на выполнение i-го задания, и его интересность.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальную возможную суммарную интересность всех заданий в квесте.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 51 11 12 23 34 4Выходные данныеСкопировать11Входные данныеСкопировать5 54 14 24 34 44 5Выходные данныеСкопировать9Входные данныеСкопировать2 21 12 10Выходные данныеСкопировать10",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся два целых числа n и T (1 ≤ n ≤ 1000, 1 ≤ T ≤ 100) — количество заданий, подготовленных Поликарпом, и максимальное время, в которое должен укладываться человек, решающий квест.В последующих n строках находятся по два целых числа ti, qi (1 ≤ ti ≤ T, 1 ≤ qi ≤ 1000) — время в минутах, требуемое на выполнение i-го задания, и его интересность.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальную возможную суммарную интересность всех заданий в квесте.\n\nВыходные данные\n\nВходные данныеСкопировать5 51 11 12 23 34 4Выходные данныеСкопировать11Входные данныеСкопировать5 54 14 24 34 44 5Выходные данныеСкопировать9Входные данныеСкопировать2 21 12 10Выходные данныеСкопировать10\n\nВходные данныеСкопировать5 51 11 12 23 34 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 54 14 24 34 44 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 21 12 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия все пять заданий можно дополнить четырьмя вопросами и объединить в один квест.Во втором тесте из условия все пять заданий использовать невозможно, но можно взять два самых интересных из них.В третьем тесте из условия оптимальный выбор — это включить в квест второе задание и только его.Картинка, иллюстрирующая ответы на тесты из условия. Синие кружки обозначают вопросы, а две стрелки, выходящие из каждого кружка обозначают, к чему переходит человек, дав тот или иной ответ на вопрос. Задания — красные овалы.",
      "solutions": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces",
          "content": "В воскресенье, 3-го мая, в 19:00 начнётся Раунд 3 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять участие все те команды, которые отобрались в Раунде 2 или в Уайлд-кард раунде 2. Напомним, что из второго раунда допущены все те команды, что набрали не менее 928 баллов. В уайлд-кард раунде 2 было достаточно набрать 1827 баллов. Таким образом, принять участие в Раунде 2 могут 100 + 20 = 120 команд!Участников ждет соревнование по правилам классических раундов Codeforces. Раунд 3 пройдёт в таком же формате, как и Раунд 2 — с онлайн-трансляцией, рейтинговой и доступной только для див-1 участников. Будет использована плавная динамическая система оценки задач, но сами задачи будут расположены в случайном порядке. Участникам будет предложено 6 задач.Раунд подготовлен силами команды Codeforces, команды VK и пользователя yeputons. Как всегда, неоценимую помощь в тестировании задач оказали winger и AlexFetisov.Напомним, что в Финал VK Cup пройдут все те команды, которые наберут положительный балл, не меньший, чем у команды на 20-м месте. Также обращаем ваше внимание, что участники всех команд, прошедших в Раунд 3 (независимо от их участия или неучастия в Раунде 3 или в его трансляции), получат фирменную футболку Чемпионата. Помимо этого, фирменной футболкой будут награждены топ-50 участников интернет-трансляции Раунда 3.Желаем удачи и интересной борьбы!UPD1 Раунд 3 завершён! Поздравляем топ-20 команд, которые отправятся в июле на Финал VK Cup 2015! Следите за объявлениями на сайте, точная информация о финальном раунде появится позднее.UPD2 Тем временем появился разбор.",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17690",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1709
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*F"
          },
          "content_length": 9762
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces",
          "content": "542A - Здесь могла быть ваша рекламаЗафиксируем окно на телеканале и поймём, какой ролик имеет с ним наибольшее пересечение. Ролики бывают четырёх видов: вкладывающиеся в окно, накрывающие окно, частично пересекающие его слева и частично пересекающие справа. Научимся разбирать каждый вид.Определить наличие накрывающего ролика просто — достаточно отсортировать ролики в порядке возрастания левой границы, и, идя по ним слева направо, поддерживать минимальную правую границу, достигнутую к текущему моменту. Если, проходя через окно j, мы видим, что текущее значение максимума не меньше, чем bj, то есть ролик, накрывающий наше окно, а значит ответ для данного окна можно установить равным (ri - li)·ci.Среди всех вкладывающихся роликов надо найти тот, который имеет максимальную длину. Это можно сделать похожим образом, но чуть-чуть сложнее. Воспользуемся методом сканирующей прямой. Проходя через правую границу ролика ri, будем присваивать в некоторой структуре данных (например, дереве отрезков), значение ri - li в точку li. Проходя через правую границу окна, будем считать ответ для него как максимум на отрезке [aj, bj]. Таким образом мы учтём вложенные ролики.Также можно определить наличие частично накрывающего ролика слева. Проходя через правую границу ролика ri, будем писать в точку li значение ri. Проходя через правую границу телеканала bj, посчитаем для него ответ как максимум на отрезке [aj, bj] минус aj.Среди всех ответов для всех роликов выберем наиболее выгодный. Таким образом, выходит решение за .Упражнение А если веса есть не только на окнах, но и на роликах, и они перемножаются? Решите задачу за , получите виртуальную медаль!542B - Охота на утокБудем приближаться к решению задачи постепенно. Во-первых, скажем, что у нас утки неподвижны, а охотник топает вправо со скоростью 1. Определим величину F[x][s] как минимальное количество уток среди тех, правые концы которых расположены не позже x, которых мы не сможем подстрелить, если последний выстрел был сделан ровно в точку s. В частности, в величину F[x][s] включены все утки, расположенные в отрезке [s + 1, x]. Значения F[x][s] для s > x будем считать неопределёнными.Будем смотреть на F[x] как на функцию от s. Эта функция определена на всех s от 0 до x включительно. Ключевая идея заключается в исследовании того, как отличается F[x + 1][·] от F[x][·].Давайте сначала предположим, что если в точке x + 1 не заканчивается ни одна утка, то в определении F[x + 1][·] фигурируют те же самые утки, что и в определении F[x][·]. Это значит, что все значения F[x][s] для s ≤ x остаются теми же. Интереснее дело обстоит с F[x + 1][x + 1]. Нетрудно видеть, что выстрел в точку x + 1 не может подбить ни одну из уток, заканчивающихся не правее x + 1 (так как мы только что предположили, что таких уток нет). Значит, F[x + 1][x + 1] = min F[x + 1][0... x + 1 - r] = min F[x][0... x + 1 - r].Теперь давайте предположим, что в точке x + 1 заканчивается утка [l, x + 1]. В таком случае, можно смело сказать, что ко всем значениям D[x + 1][0... l - 1] можно прибавить 1 (потому что к моменту выстрела в точку s < l утку [l, x + 1] подбить ещё никак не возможно). В то же время, все значения D[x + 1][l... x + 1] останутся прежними, потому как последний выстрел и подобьёт новодобавленную утку.Теперь давайте постепенно понимать реализационную сторону вопроса. Функция F[x][·] является кусочно-постоянной, а значит, её можно хранить в декартовом дереве в виде набора пар (начало отрезка, значение на отрезке). Такое хранение позволит нам легко прибавлять 1 на отрезке и брать минимум на префиксе функции.Теперь будем считать, что функция F[x][·], определена на всей положительной полуоси, просто значения F[x][s] для s > x не удовлетворяют определению функции F[x][s]. Можно мысленно представить, что последний отрезок в структуре F[x] просто продляется до бесконечности вправо.Будем идти сканирующей прямой по переменной x. Заметим, что функция F[x + 1][·] по сравнению с функцией F[x][·] меняется очень редко. Например, значение F[x + 1][x + 1] практически всегда совпадает с F[x][x + 1] (которое, в свою очередь, совпадает с F[x][x], о чём сказано абзацем выше). Действительно, в предположении, что в x + 1 не заканчивается ни одна утка, F[x][x] = min(F[x][0... x - r]) и F[x + 1][x + 1] = min(F[x + 1][0... x + 1 - r]) = min(F[x][0... x + 1 - r]) ≤ min(F[x][0... x - r]). Таким образом, интересное для нас событие возникает, когда значение F[x][x - r + 1] меньше всего префикса перед ним. Однако, величина min(F[x][0... x - r]) может не более n раз увеличиться на 1 (каждый раз, когда x проходит через правый конец утки), а значит, и уменьшиться может не более n раз (так как это неотрицательная величина).Значит, событий вида \"мы прошли через правый конец утки\" и \"нам надо нетривиально посчитать F[x][x] в сумме линейное количество. Каждое из них обрабатывается с помощью обращения к декартову дереву, которое происходит за . А значит, мы получили решение, работающее за . Ура! 542C - Идемпотентная функцияДля решения этой задачи полезно разобраться, как выглядит граф, отвечающий функции из множества {1, ..., n} в себя. Рассмотрим граф на вершинах 1, ..., n, где из вершины i ведёт ребро в вершину f(i). Такой граф всегда выглядит как набор циклов, в которые ведут деревья. Как же должен выглядеть граф, отвечающий инволюции? Нетрудно понять, что в таком графе все циклы должны быть длины 1, а все вершины, которые не являются циклами длины 1 (т. е. неподвижными точками), должны сразу вести в какую-то неподвижную точку.Значит, мы должны соблюсти два условия. Во-первых, все циклы должны стать длины 1 — для этого, как нетрудно понять, k должно делиться на [c1, c2, ..., cm], где ci — длины всех циклов. Во-вторых, все вершины, не лежащие на циклах, должны стать переходящими в вершины, лежащие на циклах. Иными словами, k должно быть не меньше, чем расстояние от любой вершины x до цикла, в которую она попадает (или, что то же самое, длины предпериода в последовательности f(x), f(f(x)), f(f(f(x))), ...).Значит, наша задача свелась к тому, чтобы найти минимальное число k, делящееся на A, и не меньшее, чем B, что совсем несложно сделать.Упражнение Какой максимальный ответ достигается в этой задаче? (Ответ: раз два)542D - Супергеройская работаПервым делом в этой задаче стоит разобраться, что из себя представляет функция Джокера. Одним из главных её свойств является мультипликативность: J(ab) = J(a)J(b) для (a, b) = 1, что даёт нам возможность записать значение функции, зная её значение на простых множителях аргумента: J(p1k1p2k2... pmkm) = J(p1k1)J(p2k2)... J(pmkm) = (p1k1 + 1)(p2k2 + 1)... (pmkm + 1). Воспользуемся этим знанием, чтобы решить задачу методом динамического программирования. Обозначим за P множество тех простых чисел p, что скобка с их участием может встретиться в A = J(x). Таких простых немного — для каждого делителя d числа A он может соответствовать не более, чем одному простому, а именно, тому, чьей степенью является число d - 1 (если вообще является). Составим множество P, запомнив также для каждого простого числа p в нём, в каких степенях k скобка (pk + 1) делит A. Теперь можно посчитать величину D[p][d], которая равна количеству способов получить делитель d числа A в виде произведения скобок от первых p простых чисел в множестве P. Такую величину можно посчитать методом динамического программирования за , где — количество делителей числа A (так как выше было показано, что ). Значит, общая сложность решения — .Упражнение Как себя ведёт с ростом A? Например, какое максимальное значение по всем A ≤ 1012? (Ответ: . Полезная оценка, не являющаяся, тем не менее, точной асимптотикой, заключается в том, что )Упражнение А какой максимальный ответ достигается в этой задаче? Если получится сгенерировать тест, в котором ответ больше миллиона, с меня большой респект!542E - Игра на графеЗаметим, что если исходный граф — недвудольный, то ответ — (-1). Действительно, любой нечётный цикл, будучи стянутым по паре вершин, всегда порождает нечётный цикл меньшего размера, в результате чего мы получим треугольник, с которым уже никак справиться нельзя.С другой стороны, любую двудольную компоненту можно привести к виду цепочки, длина которой равна диаметру компоненты. Предположим, пара вершин (a, b) — диаметр некоторой компоненты связности. Тогда, стягивая все пары вершин, находящихся на одном расстоянии от a, как нетрудно видеть, мы получим требуемую цепочку.Последним шагом остаётся заметить, что ответ — сумма ответов для отдельных компонент, которые можно по очереди подцепить друг другу. Таким образом, ответ — сумма диаметров компонент связности, если они все двудольные, иначе — (-1). Решение имеет сложность O(E + VE) (первое слагаемое — проверка на двудольность, второе слагаемое — подсчёт диаметра путём запуска BFS из каждой компоненты связности).542F - КвестЭту задачу можно было решать массой способов. Самый прямолинейный — динамическое программирование. Условие задачи можно переформулировать таким образом, что мы хотим выбрать какое-то множество вершин в качестве листов, для каждого потенциального листа известно верхнее ограничение на его глубину, и также известны стоимости каждого листа.Будем идти по дереву снизу вверх. Посчитаем величину D[h][c] — максимальная возможная стоимость, которую можно получить, если, находясь на уровне h, мы имеем c вершин. Для перехода переберём, сколько листов именно имеющейся глубины мы возьмём (понятно, что из них выгоднее всего взять несколько максимальных), пусть, мы возьмём k. Тогда из этого состояния можно сделать переход в состояние D[h - 1][⌈(c + k) / 2⌉]. Ответ будет находиться в величине D[0][1] — действительно, придя на глубину 0, мы должны остаться с одной-единственной вершиной — корнем.Сложность решения — O(n2T). Упражнение Прокачайте решение выше до . А потом до",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17697",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 542\\s*F"
          },
          "content_length": 9762
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 1",
          "code": "несовершеннолетние участники",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 2",
          "code": "Div1-contestants",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 3",
          "code": "Wrong Anser on test 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 4",
          "code": "int dp[N][T]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 5",
          "code": "int dp[T][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 6",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 3 + неофициальная интернет-трансляция - Codeforces - Code 7",
          "code": "bool cmp(rec a, rec b){\n\treturn a.r > b.r;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17690",
          "author": "Zlobober"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 1",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 2",
          "code": "while (res < ma) res += nok;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 3 - Codeforces - Code 3",
          "code": "uint_least16_t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17697",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 100, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, T, \"ti\");\n        inf.readSpace();\n        int qi = inf.readInt(1, 1000, \"qi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 100, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, T, \"ti\");\n        inf.readSpace();\n        int qi = inf.readInt(1, 1000, \"qi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int T = inf.readInt(1, 100, \"T\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        int ti = inf.readInt(1, T, \"ti\");\n        inf.readSpace();\n        int qi = inf.readInt(1, 1000, \"qi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    int tMin = opt<int>(\"tMin\", 1);\n    int tMax = opt<int>(\"tMax\", T);\n    int qMin = opt<int>(\"qMin\", 1);\n    int qMax = opt<int>(\"qMax\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> tasks(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(tMin, tMax);\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"small_ti\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMin;\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"large_ti\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMax;\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"same_qi\") {\n        int qi = rnd.next(qMin, qMax);\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(tMin, tMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"ascending_ti\") {\n        vector<int> ti_values(n);\n        for (int i = 0; i < n; ++i) {\n            ti_values[i] = rnd.next(tMin, tMax);\n        }\n        sort(ti_values.begin(), ti_values.end());\n        for (int i = 0; i < n; ++i) {\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti_values[i], qi);\n        }\n    } else if (type == \"descending_ti\") {\n        vector<int> ti_values(n);\n        for (int i = 0; i < n; ++i) {\n            ti_values[i] = rnd.next(tMin, tMax);\n        }\n        sort(ti_values.rbegin(), ti_values.rend());\n        for (int i = 0; i < n; ++i) {\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti_values[i], qi);\n        }\n    } else if (type == \"edge_case\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = T;\n            int qi = 1000;\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"maximize_interest\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMin;\n            int qi = qMax;\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"minimize_interest\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMax;\n            int qi = qMin;\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"exact_T\") {\n        int max_depth = T - tMin;\n        int h = min((int)log2(n), max_depth);\n        if (h < 0) h = 0;\n        int depth = h;\n        for (int i = 0; i < n; ++i) {\n            int ti = T - depth;\n            if (ti < tMin || ti > tMax) {\n                ti = rnd.next(tMin, tMax);\n            }\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"one_large_qi\") {\n        int large_qi = qMax;\n        int small_qi = qMin;\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(tMin, tMax);\n            int qi = small_qi;\n            tasks[i] = make_pair(ti, qi);\n        }\n        int index = rnd.next(0, n-1);\n        tasks[index].second = large_qi;\n    } else if (type == \"tasks_with_ti_equal_T\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = T;\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, T);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", tasks[i].first, tasks[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int T = opt<int>(\"T\");\n    int tMin = opt<int>(\"tMin\", 1);\n    int tMax = opt<int>(\"tMax\", T);\n    int qMin = opt<int>(\"qMin\", 1);\n    int qMax = opt<int>(\"qMax\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> tasks(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(tMin, tMax);\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"small_ti\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMin;\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"large_ti\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMax;\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"same_qi\") {\n        int qi = rnd.next(qMin, qMax);\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(tMin, tMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"ascending_ti\") {\n        vector<int> ti_values(n);\n        for (int i = 0; i < n; ++i) {\n            ti_values[i] = rnd.next(tMin, tMax);\n        }\n        sort(ti_values.begin(), ti_values.end());\n        for (int i = 0; i < n; ++i) {\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti_values[i], qi);\n        }\n    } else if (type == \"descending_ti\") {\n        vector<int> ti_values(n);\n        for (int i = 0; i < n; ++i) {\n            ti_values[i] = rnd.next(tMin, tMax);\n        }\n        sort(ti_values.rbegin(), ti_values.rend());\n        for (int i = 0; i < n; ++i) {\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti_values[i], qi);\n        }\n    } else if (type == \"edge_case\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = T;\n            int qi = 1000;\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"maximize_interest\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMin;\n            int qi = qMax;\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"minimize_interest\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = tMax;\n            int qi = qMin;\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"exact_T\") {\n        int max_depth = T - tMin;\n        int h = min((int)log2(n), max_depth);\n        if (h < 0) h = 0;\n        int depth = h;\n        for (int i = 0; i < n; ++i) {\n            int ti = T - depth;\n            if (ti < tMin || ti > tMax) {\n                ti = rnd.next(tMin, tMax);\n            }\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    } else if (type == \"one_large_qi\") {\n        int large_qi = qMax;\n        int small_qi = qMin;\n        for (int i = 0; i < n; ++i) {\n            int ti = rnd.next(tMin, tMax);\n            int qi = small_qi;\n            tasks[i] = make_pair(ti, qi);\n        }\n        int index = rnd.next(0, n-1);\n        tasks[index].second = large_qi;\n    } else if (type == \"tasks_with_ti_equal_T\") {\n        for (int i = 0; i < n; ++i) {\n            int ti = T;\n            int qi = rnd.next(qMin, qMax);\n            tasks[i] = make_pair(ti, qi);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, T);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", tasks[i].first, tasks[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -T 1 -type random\n./gen -n 1 -T 100 -type random\n./gen -n 2 -T 2 -type small_ti\n./gen -n 2 -T 2 -type large_ti\n./gen -n 10 -T 5 -type exact_T\n./gen -n 10 -T 10 -type random\n./gen -n 100 -T 50 -type random\n./gen -n 500 -T 50 -type ascending_ti\n./gen -n 500 -T 50 -type descending_ti\n./gen -n 500 -T 100 -type ascending_ti -tMin 1 -tMax 100\n./gen -n 500 -T 100 -type descending_ti -tMin 1 -tMax 100\n./gen -n 500 -T 100 -type one_large_qi\n./gen -n 500 -T 100 -type tasks_with_ti_equal_T\n./gen -n 1000 -T 1 -type small_ti\n./gen -n 1000 -T 1 -type tasks_with_ti_equal_T\n./gen -n 1000 -T 100 -type random\n./gen -n 1000 -T 100 -type large_ti\n./gen -n 1000 -T 100 -type same_qi\n./gen -n 1000 -T 100 -type edge_case\n./gen -n 1000 -T 100 -type maximize_interest\n./gen -n 1000 -T 100 -type minimize_interest\n./gen -n 1000 -T 100 -type exact_T\n./gen -n 1000 -T 100 -type random -tMin 50 -tMax 100\n./gen -n 1000 -T 50 -type random -tMin 1 -tMax 50\n./gen -n 1000 -T 100 -type ascending_ti -tMin 1 -tMax 100\n./gen -n 999 -T 99 -type one_large_qi\n./gen -n 1000 -T 100 -type descending_ti -tMin 1 -tMax 100\n./gen -n 1000 -T 100 -type tasks_with_ti_equal_T\n./gen -n 1000 -T 100 -type random -qMin 900 -qMax 1000\n./gen -n 1000 -T 100 -type random -qMin 1 -qMax 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:04.811378",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "543/A",
      "title": "A. Writing Code",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n, m, b, mod (1 ≤ n, m ≤ 500, 0 ≤ b ≤ 500; 1 ≤ mod ≤ 109 + 7) — the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer.The next line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 500) — the number of bugs per line for each programmer.",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo mod.",
      "sample_tests": "ExamplesInputCopy3 3 3 1001 1 1OutputCopy10InputCopy3 6 5 10000000071 2 3OutputCopy0InputCopy3 5 6 111 2 1OutputCopy0",
      "description": "A. Writing Code\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers n, m, b, mod (1 ≤ n, m ≤ 500, 0 ≤ b ≤ 500; 1 ≤ mod ≤ 109 + 7) — the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer.The next line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 500) — the number of bugs per line for each programmer.\n\nOutputPrint a single integer — the answer to the problem modulo mod.\n\nInputCopy3 3 3 1001 1 1OutputCopy10InputCopy3 6 5 10000000071 2 3OutputCopy0InputCopy3 5 6 111 2 1OutputCopy0\n\nInputCopy3 3 3 1001 1 1\n\nOutputCopy10\n\nInputCopy3 6 5 10000000071 2 3\n\nOutputCopy0\n\nInputCopy3 5 6 111 2 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 543\\s*A"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(0, 500, \"b\");\n    inf.readSpace();\n    int mod = inf.readInt(1, 1000000007, \"mod\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 500, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(0, 500, \"b\");\n    inf.readSpace();\n    int mod = inf.readInt(1, 1000000007, \"mod\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 500, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(0, 500, \"b\");\n    inf.readSpace();\n    int mod = inf.readInt(1, 1000000007, \"mod\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 500, \"a\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    int mod = opt<int>(\"mod\", 1000000007); // default mod is 1e9+7\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 500); // Ensure the constraints\n    ensure(1 <= m && m <= 500);\n    ensure(0 <= b && b <= 500);\n    ensure(1 <= mod && mod <= 1000000007);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random a_i between 0 and 500\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 500);\n        }\n    } else if (type == \"ai_zero\") {\n        // All a_i are zero\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"ai_max\") {\n        // All a_i are maximum (500)\n        fill(a.begin(), a.end(), 500);\n    } else if (type == \"ai_random_small\") {\n        // All a_i are small random numbers between 0 and 10\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"ai_random_large\") {\n        // All a_i are large random numbers between 490 and 500\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(490, 500);\n        }\n    } else if (type == \"some_zero_ai\") {\n        // Some a_i are zero, some are random positive numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1) == 0 ? 0 : rnd.next(1, 500);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 500);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", n, m, b, mod);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    int mod = opt<int>(\"mod\", 1000000007); // default mod is 1e9+7\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 500); // Ensure the constraints\n    ensure(1 <= m && m <= 500);\n    ensure(0 <= b && b <= 500);\n    ensure(1 <= mod && mod <= 1000000007);\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random a_i between 0 and 500\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 500);\n        }\n    } else if (type == \"ai_zero\") {\n        // All a_i are zero\n        fill(a.begin(), a.end(), 0);\n    } else if (type == \"ai_max\") {\n        // All a_i are maximum (500)\n        fill(a.begin(), a.end(), 500);\n    } else if (type == \"ai_random_small\") {\n        // All a_i are small random numbers between 0 and 10\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 10);\n        }\n    } else if (type == \"ai_random_large\") {\n        // All a_i are large random numbers between 490 and 500\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(490, 500);\n        }\n    } else if (type == \"some_zero_ai\") {\n        // Some a_i are zero, some are random positive numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 1) == 0 ? 0 : rnd.next(1, 500);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, 500);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d %d\\n\", n, m, b, mod);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -b 0 -mod 1 -type ai_zero\n./gen -n 1 -m 1 -b 0 -mod 1000000007 -type ai_max\n./gen -n 2 -m 2 -b 1 -mod 1000 -type random\n./gen -n 10 -m 10 -b 5 -mod 100 -type ai_random_small\n./gen -n 50 -m 50 -b 50 -mod 100000 -type ai_random_large\n./gen -n 100 -m 100 -b 100 -mod 1000000007 -type some_zero_ai\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type random\n./gen -n 500 -m 500 -b 0 -mod 1000000007 -type ai_zero\n./gen -n 500 -m 500 -b 250 -mod 1000000007 -type ai_random_large\n./gen -n 500 -m 500 -b 500 -mod 1 -type random\n./gen -n 100 -m 250 -b 100 -mod 123456789 -type ai_random_small\n./gen -n 250 -m 250 -b 400 -mod 987654321 -type ai_random_large\n./gen -n 500 -m 50 -b 100 -mod 1000 -type random\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type ai_max\n./gen -n 300 -m 400 -b 500 -mod 1000000007 -type ai_zero\n./gen -n 400 -m 400 -b 0 -mod 1000000007 -type ai_zero\n./gen -n 500 -m 500 -b 250 -mod 1 -type some_zero_ai\n./gen -n 5 -m 5 -b 10 -mod 1000000007 -type random\n./gen -n 500 -m 1 -b 500 -mod 1000000007 -type random\n./gen -n 1 -m 500 -b 250 -mod 1000000007 -type random\n./gen -n 250 -m 400 -b 300 -mod 1 -type ai_zero\n./gen -n 100 -m 500 -b 0 -mod 1000000007 -type ai_zero\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type ai_random_large\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type ai_random_small\n./gen -n 50 -m 50 -b 0 -mod 1000000007 -type ai_zero\n./gen -n 500 -m 250 -b 500 -mod 1000000007 -type some_zero_ai\n./gen -n 500 -m 500 -b 1 -mod 1000000007 -type ai_max\n./gen -n 500 -m 499 -b 500 -mod 1000000007 -type random\n./gen -n 1 -m 1 -b 500 -mod 2 -type ai_random_large\n./gen -n 10 -m 100 -b 50 -mod 1 -type ai_random_small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:06.737721",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "543/B",
      "title": "B. Destroying Roads",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n ≤ 3000, ) — the number of cities and roads in the country, respectively. Next m lines contain the descriptions of the roads as pairs of integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). It is guaranteed that the roads that are given in the description can transport you from any city to any other one. It is guaranteed that each pair of cities has at most one road between them.The last two lines contains three integers each, s1, t1, l1 and s2, t2, l2, respectively (1 ≤ si, ti ≤ n, 0 ≤ li ≤ n).",
      "output_spec": "OutputPrint a single number — the answer to the problem. If the it is impossible to meet the conditions, print -1.",
      "sample_tests": "ExamplesInputCopy5 41 22 33 44 51 3 23 5 2OutputCopy0InputCopy5 41 22 33 44 51 3 22 4 2OutputCopy1InputCopy5 41 22 33 44 51 3 23 5 1OutputCopy-1",
      "description": "B. Destroying Roads\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n ≤ 3000, ) — the number of cities and roads in the country, respectively. Next m lines contain the descriptions of the roads as pairs of integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). It is guaranteed that the roads that are given in the description can transport you from any city to any other one. It is guaranteed that each pair of cities has at most one road between them.The last two lines contains three integers each, s1, t1, l1 and s2, t2, l2, respectively (1 ≤ si, ti ≤ n, 0 ≤ li ≤ n).\n\nOutputPrint a single number — the answer to the problem. If the it is impossible to meet the conditions, print -1.\n\nInputCopy5 41 22 33 44 51 3 23 5 2OutputCopy0InputCopy5 41 22 33 44 51 3 22 4 2OutputCopy1InputCopy5 41 22 33 44 51 3 23 5 1OutputCopy-1\n\nInputCopy5 41 22 33 44 51 3 23 5 2\n\nOutputCopy0\n\nInputCopy5 41 22 33 44 51 3 22 4 2\n\nOutputCopy1\n\nInputCopy5 41 22 33 44 51 3 23 5 1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 543\\s*B"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform DFS to check connectivity\nvoid dfs(int u, vector<vector<int>> &adj, vector<bool> &visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v, adj, visited);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 3000;\n    const int MAX_M = 4500;\n\n    // Read n and m\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\");\n    inf.readEoln();\n\n    // Prepare adjacency list and set for edges\n    vector<vector<int>> adj(n + 1); // Nodes are numbered from 1 to n\n    set<pair<int, int>> edges;\n\n    // Read m edges\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        // Ensure no loops\n        ensuref(a != b, \"Edge connects node to itself: a_i = b_i = %d\", a);\n\n        // Ensure no duplicate edges\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between nodes %d and %d\", u, v);\n        edges.insert(edge);\n\n        // Add to adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check if the graph is connected\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited);\n    for (int u = 1; u <= n; ++u) {\n        ensuref(visited[u], \"Graph is not connected, node %d is unreachable\", u);\n    }\n\n    // Read s1, t1, l1\n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, n, \"t1\");\n    inf.readSpace();\n    int l1 = inf.readInt(0, n, \"l1\");\n    inf.readEoln();\n\n    // Read s2, t2, l2\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, n, \"t2\");\n    inf.readSpace();\n    int l2 = inf.readInt(0, n, \"l2\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform DFS to check connectivity\nvoid dfs(int u, vector<vector<int>> &adj, vector<bool> &visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v, adj, visited);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 3000;\n    const int MAX_M = 4500;\n\n    // Read n and m\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\");\n    inf.readEoln();\n\n    // Prepare adjacency list and set for edges\n    vector<vector<int>> adj(n + 1); // Nodes are numbered from 1 to n\n    set<pair<int, int>> edges;\n\n    // Read m edges\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        // Ensure no loops\n        ensuref(a != b, \"Edge connects node to itself: a_i = b_i = %d\", a);\n\n        // Ensure no duplicate edges\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between nodes %d and %d\", u, v);\n        edges.insert(edge);\n\n        // Add to adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check if the graph is connected\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited);\n    for (int u = 1; u <= n; ++u) {\n        ensuref(visited[u], \"Graph is not connected, node %d is unreachable\", u);\n    }\n\n    // Read s1, t1, l1\n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, n, \"t1\");\n    inf.readSpace();\n    int l1 = inf.readInt(0, n, \"l1\");\n    inf.readEoln();\n\n    // Read s2, t2, l2\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, n, \"t2\");\n    inf.readSpace();\n    int l2 = inf.readInt(0, n, \"l2\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to perform DFS to check connectivity\nvoid dfs(int u, vector<vector<int>> &adj, vector<bool> &visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v, adj, visited);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const int MAX_N = 3000;\n    const int MAX_M = 4500;\n\n    // Read n and m\n    int n = inf.readInt(1, MAX_N, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, MAX_M, \"m\");\n    inf.readEoln();\n\n    // Prepare adjacency list and set for edges\n    vector<vector<int>> adj(n + 1); // Nodes are numbered from 1 to n\n    set<pair<int, int>> edges;\n\n    // Read m edges\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        // Ensure no loops\n        ensuref(a != b, \"Edge connects node to itself: a_i = b_i = %d\", a);\n\n        // Ensure no duplicate edges\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between nodes %d and %d\", u, v);\n        edges.insert(edge);\n\n        // Add to adjacency list\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check if the graph is connected\n    vector<bool> visited(n + 1, false);\n    dfs(1, adj, visited);\n    for (int u = 1; u <= n; ++u) {\n        ensuref(visited[u], \"Graph is not connected, node %d is unreachable\", u);\n    }\n\n    // Read s1, t1, l1\n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, n, \"t1\");\n    inf.readSpace();\n    int l1 = inf.readInt(0, n, \"l1\");\n    inf.readEoln();\n\n    // Read s2, t2, l2\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, n, \"t2\");\n    inf.readSpace();\n    int l2 = inf.readInt(0, n, \"l2\");\n    inf.readEoln();\n\n    // Ensure end of file\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int s1 = opt<int>(\"s1\", -1);\n    int t1 = opt<int>(\"t1\", -1);\n    int l1 = opt<int>(\"l1\", -1);\n    int s2 = opt<int>(\"s2\", -1);\n    int t2 = opt<int>(\"t2\", -1);\n    int l2 = opt<int>(\"l2\", -1);\n\n    if (n < 1 || n > 3000) {\n        fprintf(stderr, \"Invalid n value: n must be between 1 and 3000\\n\");\n        exit(1);\n    }\n    if (m < n -1 || m > n * (n - 1) / 2) {\n        fprintf(stderr, \"Invalid m value: m must be between n-1 and n(n-1)/2\\n\");\n        exit(1);\n    }\n    \n    vector<pair<int,int> > edges;\n    set<pair<int,int> > edgeSet;\n\n    if (type == \"path\") {\n        // Build a path from 1 to n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        for (const auto& e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edgeSet.insert({u, v});\n        }\n        // Add extra edges if needed\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (!edgeSet.count({a, b})) {\n                edgeSet.insert({a, b});\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"star\") {\n        // Build a star with node 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        for (const auto& e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edgeSet.insert({u, v});\n        }\n        // Add extra edges if needed\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (!edgeSet.count({a, b})) {\n                edgeSet.insert({a, b});\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"complete\") {\n        // Build a complete graph\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n        if ((int)edges.size() > m) {\n            shuffle(edges.begin(), edges.end());\n            edges.resize(m);\n        }\n    } else { // random\n        // Random connected graph\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            parent[i] = p;\n            edges.push_back({i, p});\n        }\n        for (const auto& e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edgeSet.insert({u, v});\n        }\n        // Add extra edges if needed\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (!edgeSet.count({a, b})) {\n                edgeSet.insert({a, b});\n                edges.push_back({u, v});\n            }\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Determine s1, t1, l1, s2, t2, l2\n    if (s1 == -1) s1 = rnd.next(1, n);\n    if (t1 == -1) {\n        do {\n            t1 = rnd.next(1, n);\n        } while (t1 == s1 && n > 1);\n    }\n    if (l1 == -1) l1 = rnd.next(0, n - 1);\n\n    if (s2 == -1) s2 = rnd.next(1, n);\n    if (t2 == -1) {\n        do {\n            t2 = rnd.next(1, n);\n        } while (t2 == s2 && n > 1);\n    }\n    if (l2 == -1) l2 = rnd.next(0, n - 1);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (const auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d %d %d\\n\", s1, t1, l1);\n    printf(\"%d %d %d\\n\", s2, t2, l2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int s1 = opt<int>(\"s1\", -1);\n    int t1 = opt<int>(\"t1\", -1);\n    int l1 = opt<int>(\"l1\", -1);\n    int s2 = opt<int>(\"s2\", -1);\n    int t2 = opt<int>(\"t2\", -1);\n    int l2 = opt<int>(\"l2\", -1);\n\n    if (n < 1 || n > 3000) {\n        fprintf(stderr, \"Invalid n value: n must be between 1 and 3000\\n\");\n        exit(1);\n    }\n    if (m < n -1 || m > n * (n - 1) / 2) {\n        fprintf(stderr, \"Invalid m value: m must be between n-1 and n(n-1)/2\\n\");\n        exit(1);\n    }\n    \n    vector<pair<int,int> > edges;\n    set<pair<int,int> > edgeSet;\n\n    if (type == \"path\") {\n        // Build a path from 1 to n\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        for (const auto& e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edgeSet.insert({u, v});\n        }\n        // Add extra edges if needed\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (!edgeSet.count({a, b})) {\n                edgeSet.insert({a, b});\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"star\") {\n        // Build a star with node 1\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        for (const auto& e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edgeSet.insert({u, v});\n        }\n        // Add extra edges if needed\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (!edgeSet.count({a, b})) {\n                edgeSet.insert({a, b});\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"complete\") {\n        // Build a complete graph\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n        if ((int)edges.size() > m) {\n            shuffle(edges.begin(), edges.end());\n            edges.resize(m);\n        }\n    } else { // random\n        // Random connected graph\n        vector<int> parent(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            parent[i] = p;\n            edges.push_back({i, p});\n        }\n        for (const auto& e : edges) {\n            int u = min(e.first, e.second);\n            int v = max(e.first, e.second);\n            edgeSet.insert({u, v});\n        }\n        // Add extra edges if needed\n        while ((int)edgeSet.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int a = min(u, v);\n            int b = max(u, v);\n            if (!edgeSet.count({a, b})) {\n                edgeSet.insert({a, b});\n                edges.push_back({u, v});\n            }\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Determine s1, t1, l1, s2, t2, l2\n    if (s1 == -1) s1 = rnd.next(1, n);\n    if (t1 == -1) {\n        do {\n            t1 = rnd.next(1, n);\n        } while (t1 == s1 && n > 1);\n    }\n    if (l1 == -1) l1 = rnd.next(0, n - 1);\n\n    if (s2 == -1) s2 = rnd.next(1, n);\n    if (t2 == -1) {\n        do {\n            t2 = rnd.next(1, n);\n        } while (t2 == s2 && n > 1);\n    }\n    if (l2 == -1) l2 = rnd.next(0, n - 1);\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (const auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    printf(\"%d %d %d\\n\", s1, t1, l1);\n    printf(\"%d %d %d\\n\", s2, t2, l2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 4 -type path -s1 1 -t1 5 -l1 4 -s2 2 -t2 4 -l2 2\n./gen -n 5 -m 4 -type star\n./gen -n 5 -m 4 -type random\n./gen -n 5 -m 10 -type complete\n\n./gen -n 10 -m 9 -type path\n./gen -n 10 -m 15 -type random\n./gen -n 10 -m 45 -type complete\n\n./gen -n 100 -m 99 -type path\n./gen -n 100 -m 150 -type random\n./gen -n 100 -m 4950 -type complete\n\n./gen -n 3000 -m 2999 -type path\n./gen -n 3000 -m 4500 -type random\n./gen -n 3000 -m 4498500 -type complete\n\n# Edge cases\n./gen -n 2 -m 1 -type path -s1 1 -t1 2 -l1 1 -s2 1 -t2 1 -l2 0\n./gen -n 2 -m 1 -type star -s1 1 -t1 1 -l1 0 -s2 2 -t2 2 -l2 0\n./gen -n 2 -m 1 -type random -s1 1 -t1 2 -l1 1 -s2 1 -t2 2 -l2 0\n\n# Test with maximal m\n./gen -n 50 -m 1225 -type complete\n./gen -n 50 -m 500 -type random\n./gen -n 50 -m 49 -type path\n\n# Tests with big l1 and l2\n./gen -n 1000 -m 2000 -type random -l1 0 -l2 0\n./gen -n 1000 -m 2000 -type random -l1 1000 -l2 1000\n./gen -n 500 -m 1000 -type random -s1 1 -t1 500 -l1 250\n./gen -n 500 -m 1000 -type random -s2 1 -t2 500 -l2 250\n\n# Tests with s1 == t1 and l1 == 0\n./gen -n 100 -m 200 -type random -s1 10 -t1 10 -l1 0\n./gen -n 100 -m 200 -type random -s2 20 -t2 20 -l2 0\n\n# Max n with minimal m\n./gen -n 3000 -m 2999 -type path -s1 1 -t1 3000 -l1 2999 -s2 1500 -t2 3000 -l2 1499\n\n# Max n with maximal m\n./gen -n 3000 -m 4498500 -type complete -s1 1 -t1 3000 -l1 1 -s2 1500 -t2 3000 -l2 1\n\n# Random tests with random l1 and l2\n./gen -n 1000 -m 2000 -type random\n./gen -n 2000 -m 4000 -type random\n\n# Stress tests\n./gen -n 3000 -m 4500 -type random\n./gen -n 3000 -m 10000 -type random\n\n# Tests for impossible conditions\n./gen -n 10 -m 9 -type path -s1 1 -t1 10 -l1 2 -s2 1 -t2 10 -l2 1\n./gen -n 10 -m 45 -type complete -s1 1 -t1 10 -l1 0 -s2 5 -t2 6 -l2 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:08.796772",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "543/C",
      "title": "C. Remembering Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 20) — the number of strings in the multiset and the length of the strings respectively. Next n lines contain the strings of the multiset, consisting only of lowercase English letters, each string's length is m.Next n lines contain m integers each, the i-th of them contains integers ai1, ai2, ..., aim (0 ≤ aij ≤ 106).",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy4 5abcdeabcdeabcdeabcde1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1OutputCopy3InputCopy4 3abcabaadcada10 10 1010 1 1010 10 1010 1 10OutputCopy2InputCopy3 3abcadassa1 1 11 1 11 1 1OutputCopy0",
      "description": "C. Remembering Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 20) — the number of strings in the multiset and the length of the strings respectively. Next n lines contain the strings of the multiset, consisting only of lowercase English letters, each string's length is m.Next n lines contain m integers each, the i-th of them contains integers ai1, ai2, ..., aim (0 ≤ aij ≤ 106).\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopy4 5abcdeabcdeabcdeabcde1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1OutputCopy3InputCopy4 3abcabaadcada10 10 1010 1 1010 10 1010 1 10OutputCopy2InputCopy3 3abcadassa1 1 11 1 11 1 1OutputCopy0\n\nInputCopy4 5abcdeabcdeabcdeabcde1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1\n\nOutputCopy3\n\nInputCopy4 3abcabaadcada10 10 1010 1 1010 10 1010 1 10\n\nOutputCopy2\n\nInputCopy3 3abcadassa1 1 11 1 11 1 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 543\\s*C"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n    vector<string> s(n);\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        s[i] = inf.readToken(pattern, \"s[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n    for (int i = 0; i < n; ++i) {\n        vector<int> a = inf.readInts(m, 0, 1000000, \"a[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n    vector<string> s(n);\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        s[i] = inf.readToken(pattern, \"s[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n    for (int i = 0; i < n; ++i) {\n        vector<int> a = inf.readInts(m, 0, 1000000, \"a[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n    vector<string> s(n);\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 0; i < n; ++i) {\n        s[i] = inf.readToken(pattern, \"s[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n    for (int i = 0; i < n; ++i) {\n        vector<int> a = inf.readInts(m, 0, 1000000, \"a[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> strings(n);\n    vector<vector<int>> costs(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random strings\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"same_strings\") {\n        // All strings are the same\n        string s;\n        for (int j = 0; j < m; ++j) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"distinct_strings\") {\n        // All strings are distinct\n        set<string> used_strings;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            do {\n                s.clear();\n                for (int j = 0; j < m; ++j) {\n                    char c = rnd.next('a', 'z');\n                    s += c;\n                }\n            } while (used_strings.count(s));\n            used_strings.insert(s);\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"minimal_cost_zero\") {\n        // Strings are already easy to remember\n        // Generate base string\n        string base_string(m, 'a');\n        // Generate list of (position, character) pairs\n        vector<pair<int, char>> positions;\n        for (int pos = 0; pos < m; ++pos) {\n            for (char c = 'a'; c <= 'z'; ++c) {\n                positions.push_back(make_pair(pos, c));\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; ++i) {\n            string s = base_string;\n            int pos = positions[i].first;\n            char c = positions[i].second;\n            s[pos] = c;\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"maximal_cost\") {\n        // Generate random strings\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Set costs to maximum\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 1000000);\n    } else if (type == \"zero_costs\") {\n        // Generate random strings\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Set costs to zero\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 0);\n    } else if (type == \"same_strings_maxcost\") {\n        // All strings are the same, costs are maximum\n        string s;\n        for (int j = 0; j < m; ++j) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n        }\n        // Set costs to maximum\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 1000000);\n    } else if (type == \"distinct_strings_zerocost\") {\n        // All strings are distinct, costs are zero\n        set<string> used_strings;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            do {\n                s.clear();\n                for (int j = 0; j < m; ++j) {\n                    char c = rnd.next('a', 'z');\n                    s += c;\n                }\n            } while (used_strings.count(s));\n            used_strings.insert(s);\n            strings[i] = s;\n        }\n        // Set costs to zero\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 0);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n\n    // Output strings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", strings[i].c_str());\n    }\n\n    // Output costs\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", costs[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> strings(n);\n    vector<vector<int>> costs(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random strings\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"same_strings\") {\n        // All strings are the same\n        string s;\n        for (int j = 0; j < m; ++j) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"distinct_strings\") {\n        // All strings are distinct\n        set<string> used_strings;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            do {\n                s.clear();\n                for (int j = 0; j < m; ++j) {\n                    char c = rnd.next('a', 'z');\n                    s += c;\n                }\n            } while (used_strings.count(s));\n            used_strings.insert(s);\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"minimal_cost_zero\") {\n        // Strings are already easy to remember\n        // Generate base string\n        string base_string(m, 'a');\n        // Generate list of (position, character) pairs\n        vector<pair<int, char>> positions;\n        for (int pos = 0; pos < m; ++pos) {\n            for (char c = 'a'; c <= 'z'; ++c) {\n                positions.push_back(make_pair(pos, c));\n            }\n        }\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; ++i) {\n            string s = base_string;\n            int pos = positions[i].first;\n            char c = positions[i].second;\n            s[pos] = c;\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"maximal_cost\") {\n        // Generate random strings\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Set costs to maximum\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 1000000);\n    } else if (type == \"zero_costs\") {\n        // Generate random strings\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Set costs to zero\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 0);\n    } else if (type == \"same_strings_maxcost\") {\n        // All strings are the same, costs are maximum\n        string s;\n        for (int j = 0; j < m; ++j) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n        }\n        // Set costs to maximum\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 1000000);\n    } else if (type == \"distinct_strings_zerocost\") {\n        // All strings are distinct, costs are zero\n        set<string> used_strings;\n        for (int i = 0; i < n; ++i) {\n            string s;\n            do {\n                s.clear();\n                for (int j = 0; j < m; ++j) {\n                    char c = rnd.next('a', 'z');\n                    s += c;\n                }\n            } while (used_strings.count(s));\n            used_strings.insert(s);\n            strings[i] = s;\n        }\n        // Set costs to zero\n        for (int i = 0; i < n; ++i)\n            fill(costs[i].begin(), costs[i].end(), 0);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < m; ++j) {\n                char c = rnd.next('a', 'z');\n                s += c;\n            }\n            strings[i] = s;\n        }\n        // Generate random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n\n    // Output strings\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", strings[i].c_str());\n    }\n\n    // Output costs\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", costs[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type same_strings\n./gen -n 1 -m 1 -type distinct_strings\n./gen -n 1 -m 1 -type minimal_cost_zero\n./gen -n 1 -m 1 -type maximal_cost\n./gen -n 1 -m 1 -type zero_costs\n\n./gen -n 1 -m 20 -type random\n./gen -n 1 -m 20 -type same_strings\n./gen -n 1 -m 20 -type minimal_cost_zero\n\n./gen -n 20 -m 1 -type random\n./gen -n 20 -m 1 -type same_strings\n./gen -n 20 -m 1 -type minimal_cost_zero\n\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type same_strings\n./gen -n 5 -m 5 -type distinct_strings\n./gen -n 5 -m 5 -type minimal_cost_zero\n./gen -n 5 -m 5 -type maximal_cost\n./gen -n 5 -m 5 -type zero_costs\n./gen -n 5 -m 5 -type same_strings_maxcost\n./gen -n 5 -m 5 -type distinct_strings_zerocost\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type same_strings\n./gen -n 10 -m 10 -type distinct_strings\n./gen -n 10 -m 10 -type minimal_cost_zero\n./gen -n 10 -m 10 -type maximal_cost\n./gen -n 10 -m 10 -type zero_costs\n./gen -n 10 -m 10 -type same_strings_maxcost\n./gen -n 10 -m 10 -type distinct_strings_zerocost\n\n./gen -n 20 -m 20 -type random\n./gen -n 20 -m 20 -type same_strings\n./gen -n 20 -m 20 -type distinct_strings\n./gen -n 20 -m 20 -type minimal_cost_zero\n./gen -n 20 -m 20 -type maximal_cost\n./gen -n 20 -m 20 -type zero_costs\n./gen -n 20 -m 20 -type same_strings_maxcost\n./gen -n 20 -m 20 -type distinct_strings_zerocost\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:10.763818",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "543/D",
      "title": "D. Road Improvement",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a single integer n (2 ≤ n ≤ 2·105) — the number of cities in the country. Next line contains n - 1 positive integers p2, p3, p4, ..., pn (1 ≤ pi ≤ i - 1) — the description of the roads in the country. Number pi means that the country has a road connecting city pi and city i.",
      "output_spec": "OutputPrint n integers a1, a2, ..., an, where ai is the sought number of ways to improve the quality of the roads modulo 1 000 000 007 (109 + 7), if the capital of the country is at city number i.",
      "sample_tests": "ExamplesInputCopy31 1OutputCopy4 3 3InputCopy51 2 3 4OutputCopy5 8 9 8 5",
      "description": "D. Road Improvement\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a single integer n (2 ≤ n ≤ 2·105) — the number of cities in the country. Next line contains n - 1 positive integers p2, p3, p4, ..., pn (1 ≤ pi ≤ i - 1) — the description of the roads in the country. Number pi means that the country has a road connecting city pi and city i.\n\nOutputPrint n integers a1, a2, ..., an, where ai is the sought number of ways to improve the quality of the roads modulo 1 000 000 007 (109 + 7), if the capital of the country is at city number i.\n\nInputCopy31 1OutputCopy4 3 3InputCopy51 2 3 4OutputCopy5 8 9 8 5\n\nInputCopy31 1\n\nOutputCopy4 3 3\n\nInputCopy51 2 3 4\n\nOutputCopy5 8 9 8 5",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 543\\s*D"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;    \n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<vector<int>> adj(n +1);\n    vector<bool> visited(n + 1, false);\n    for (int i = 2; i <= n; ++i) {\n        int pi = inf.readInt(1, i -1, \"pi\");\n        adj[pi].push_back(i);\n        adj[i].push_back(pi);\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    // BFS to check connectivity\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;    \n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<vector<int>> adj(n +1);\n    vector<bool> visited(n + 1, false);\n    for (int i = 2; i <= n; ++i) {\n        int pi = inf.readInt(1, i -1, \"pi\");\n        adj[pi].push_back(i);\n        adj[i].push_back(pi);\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    // BFS to check connectivity\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;    \n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n    vector<vector<int>> adj(n +1);\n    vector<bool> visited(n + 1, false);\n    for (int i = 2; i <= n; ++i) {\n        int pi = inf.readInt(1, i -1, \"pi\");\n        adj[pi].push_back(i);\n        adj[i].push_back(pi);\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n    // BFS to check connectivity\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n); // p[0] unused; p[1..n-1] is pi for i from 2 to n\n\n    if (type == \"chain\" || type == \"bamboo\") {\n        // Chain or Bamboo tree (same structure)\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = i - 1;\n    } else if (type == \"star\") {\n        // Star tree\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = 1;\n    } else if (type == \"random\") {\n        // Random tree\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = rnd.next(1, i-1);\n    } else if (type == \"skewed\") {\n        // Skewed tree\n        for(int i = 2; i <= n; ++i) {\n            int r = rnd.next(100);\n            if (r < 90)\n                p[i-1] = i - 1; // High probability to be a chain\n            else\n                p[i-1] = rnd.next(1, i-1); // Occasionally branch\n        }\n    } else if (type == \"complete\") {\n        // Complete binary tree\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = i / 2;\n    } else if (type == \"broom\") {\n        // Broom tree: A star attached to a chain\n        int k = min(n/2, 1000);\n        for(int i = 2; i <= k + 1; ++i)\n            p[i-1] = 1;\n        for(int i = k + 2; i <= n; ++i)\n            p[i-1] = i - 1;\n    } else if (type == \"caterpillar\") {\n        // Caterpillar tree: A central path with leaves\n        for(int i = 2; i <= n; ++i) {\n            if (i % 2 == 0)\n                p[i-1] = i - 1; // Main path\n            else\n                p[i-1] = i - 2; // Leaf\n        }\n    } else {\n        // Default to random tree if unknown type\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = rnd.next(1, i-1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output p2 to pn\n    for(int i = 2; i <= n; ++i)\n        printf(\"%d%c\", p[i-1], i == n ? '\\n' : ' ');\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n); // p[0] unused; p[1..n-1] is pi for i from 2 to n\n\n    if (type == \"chain\" || type == \"bamboo\") {\n        // Chain or Bamboo tree (same structure)\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = i - 1;\n    } else if (type == \"star\") {\n        // Star tree\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = 1;\n    } else if (type == \"random\") {\n        // Random tree\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = rnd.next(1, i-1);\n    } else if (type == \"skewed\") {\n        // Skewed tree\n        for(int i = 2; i <= n; ++i) {\n            int r = rnd.next(100);\n            if (r < 90)\n                p[i-1] = i - 1; // High probability to be a chain\n            else\n                p[i-1] = rnd.next(1, i-1); // Occasionally branch\n        }\n    } else if (type == \"complete\") {\n        // Complete binary tree\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = i / 2;\n    } else if (type == \"broom\") {\n        // Broom tree: A star attached to a chain\n        int k = min(n/2, 1000);\n        for(int i = 2; i <= k + 1; ++i)\n            p[i-1] = 1;\n        for(int i = k + 2; i <= n; ++i)\n            p[i-1] = i - 1;\n    } else if (type == \"caterpillar\") {\n        // Caterpillar tree: A central path with leaves\n        for(int i = 2; i <= n; ++i) {\n            if (i % 2 == 0)\n                p[i-1] = i - 1; // Main path\n            else\n                p[i-1] = i - 2; // Leaf\n        }\n    } else {\n        // Default to random tree if unknown type\n        for(int i = 2; i <= n; ++i)\n            p[i-1] = rnd.next(1, i-1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output p2 to pn\n    for(int i = 2; i <= n; ++i)\n        printf(\"%d%c\", p[i-1], i == n ? '\\n' : ' ');\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type chain\n./gen -n 10 -type chain\n./gen -n 1000 -type chain\n./gen -n 100000 -type chain\n\n./gen -n 2 -type star\n./gen -n 10 -type star\n./gen -n 1000 -type star\n./gen -n 100000 -type star\n\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 2 -type skewed\n./gen -n 10 -type skewed\n./gen -n 1000 -type skewed\n./gen -n 100000 -type skewed\n\n./gen -n 3 -type complete\n./gen -n 7 -type complete\n./gen -n 15 -type complete\n./gen -n 31 -type complete\n./gen -n 1000 -type complete\n\n./gen -n 2 -type broom\n./gen -n 10 -type broom\n./gen -n 1000 -type broom\n./gen -n 100000 -type broom\n\n./gen -n 2 -type caterpillar\n./gen -n 10 -type caterpillar\n./gen -n 1000 -type caterpillar\n./gen -n 100000 -type caterpillar\n\n./gen -n 2 -type bamboo\n./gen -n 10 -type bamboo\n./gen -n 1000 -type bamboo\n./gen -n 100000 -type bamboo\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:12.567476",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "543/E",
      "title": "E. Listening to Music",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test7 seconds",
      "memory_limit": "memory limit per test64 megabytes",
      "input_spec": "InputThe first line contains two positive integers n, m (1 ≤ m ≤ n ≤ 2·105). The second line contains n positive integers a1, a2, ..., an (0 ≤ ai < 230) — the description of songs from the playlist. The next line contains a single number s (1 ≤ s ≤ 2·105) — the number of days that you consider.The next s lines contain three integers each li, ri, xi (1 ≤ li ≤ ri ≤ n - m + 1; 0 ≤ xi < 230) — the description of the parameters for the i-th day. In order to calculate value qi, you need to use formula: , where ansi is the answer to the problem for day i. Assume that ans0 = 0.",
      "output_spec": "OutputPrint exactly s integers ans1, ans2, ..., anss, where ansi is the minimum displeasure that you can get on day i.",
      "sample_tests": "ExamplesInputCopy5 31 2 1 2 351 1 21 3 21 3 31 3 51 3 1OutputCopy20231",
      "description": "E. Listening to Music\n\ntime limit per test7 seconds\n\ntime limit per test\n\nmemory limit per test64 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two positive integers n, m (1 ≤ m ≤ n ≤ 2·105). The second line contains n positive integers a1, a2, ..., an (0 ≤ ai < 230) — the description of songs from the playlist. The next line contains a single number s (1 ≤ s ≤ 2·105) — the number of days that you consider.The next s lines contain three integers each li, ri, xi (1 ≤ li ≤ ri ≤ n - m + 1; 0 ≤ xi < 230) — the description of the parameters for the i-th day. In order to calculate value qi, you need to use formula: , where ansi is the answer to the problem for day i. Assume that ans0 = 0.\n\nOutputPrint exactly s integers ans1, ans2, ..., anss, where ansi is the minimum displeasure that you can get on day i.\n\nInputCopy5 31 2 1 2 351 1 21 3 21 3 31 3 51 3 1OutputCopy20231\n\nInputCopy5 31 2 1 2 351 1 21 3 21 3 31 3 51 3 1\n\nOutputCopy20231",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 543\\s*E"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, (1LL << 30) - 1LL);\n    inf.readEoln();\n\n    int s = inf.readInt(1, 200000, \"s\");\n    inf.readEoln();\n\n    int max_li_ri = n - m + 1;\n\n    for(int i = 0; i < s; ++i) {\n        int li = inf.readInt(1, max_li_ri, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, max_li_ri, \"ri\");\n        inf.readSpace();\n        long long xi = inf.readLong(0LL, (1LL << 30) -1, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, (1LL << 30) - 1LL);\n    inf.readEoln();\n\n    int s = inf.readInt(1, 200000, \"s\");\n    inf.readEoln();\n\n    int max_li_ri = n - m + 1;\n\n    for(int i = 0; i < s; ++i) {\n        int li = inf.readInt(1, max_li_ri, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, max_li_ri, \"ri\");\n        inf.readSpace();\n        long long xi = inf.readLong(0LL, (1LL << 30) -1, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, n, \"m\");\n    inf.readEoln();\n\n    vector<long long> a = inf.readLongs(n, 0LL, (1LL << 30) - 1LL);\n    inf.readEoln();\n\n    int s = inf.readInt(1, 200000, \"s\");\n    inf.readEoln();\n\n    int max_li_ri = n - m + 1;\n\n    for(int i = 0; i < s; ++i) {\n        int li = inf.readInt(1, max_li_ri, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, max_li_ri, \"ri\");\n        inf.readSpace();\n        long long xi = inf.readLong(0LL, (1LL << 30) -1, \"xi\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\");\n\n    ensure(1 <= m && m <= n && n <= 200000);\n    ensure(1 <= s && s <= 200000);\n\n    int n_minus_m_plus_1 = n - m + 1;\n    ensure(n_minus_m_plus_1 >= 1);\n\n    string a_type = opt<string>(\"a_type\", \"random\");\n    int a_max = opt<int>(\"a_max\", (1 << 30) - 1);\n    ensure(0 <= a_max && a_max < (1 << 30));\n\n    string li_type = opt<string>(\"li_type\", \"random\");\n    int li_value = opt<int>(\"li_value\", 1);\n\n    string ri_type = opt<string>(\"ri_type\", \"random\");\n    int ri_value = opt<int>(\"ri_value\", n_minus_m_plus_1);\n\n    string xi_type = opt<string>(\"xi_type\", \"random\");\n    int xi_max = opt<int>(\"xi_max\", (1 << 30) - 1);\n    ensure(0 <= xi_max && xi_max < (1 << 30));\n    int xi_value = opt<int>(\"xi_value\", 0);\n    ensure(0 <= xi_value && xi_value < (1 << 30));\n\n    // Generate ai according to a_type\n    vector<int> a(n);\n\n    if (a_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, a_max);\n        }\n    } else if (a_type == \"constant\") {\n        int a_value = opt<int>(\"a_value\", a_max);\n        ensure(0 <= a_value && a_value < (1 << 30));\n        for (int i = 0; i < n; ++i) {\n            a[i] = a_value;\n        }\n    } else if (a_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = a_max;\n        }\n    } else if (a_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (a_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)((long long)i * a_max / (n - 1));\n            ensure(0 <= a[i] && a[i] < (1 << 30));\n        }\n    } else if (a_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)((long long)(n - 1 - i) * a_max / (n - 1));\n            ensure(0 <= a[i] && a[i] < (1 << 30));\n        }\n    } else {\n        // Unknown a_type\n        cerr << \"Unknown a_type \" << a_type << endl;\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output s\n    printf(\"%d\\n\", s);\n\n    for (int i = 1; i <= s; ++i) {\n        int li, ri, xi;\n\n        // Generate li\n        if (li_type == \"random\") {\n            li = rnd.next(1, n_minus_m_plus_1);\n        } else if (li_type == \"fixed\") {\n            li = li_value;\n            ensure(1 <= li && li <= n_minus_m_plus_1);\n        } else {\n            cerr << \"Unknown li_type \" << li_type << endl;\n            return 1;\n        }\n\n        // Generate ri\n        if (ri_type == \"random\") {\n            ri = rnd.next(li, n_minus_m_plus_1);\n        } else if (ri_type == \"fixed\") {\n            ri = ri_value;\n            ensure(li <= ri && ri <= n_minus_m_plus_1);\n        } else {\n            cerr << \"Unknown ri_type \" << ri_type << endl;\n            return 1;\n        }\n\n        // Generate xi\n        if (xi_type == \"random\") {\n            xi = rnd.next(0, xi_max);\n        } else if (xi_type == \"fixed\") {\n            xi = xi_value;\n            ensure(0 <= xi && xi < (1 << 30));\n        } else {\n            cerr << \"Unknown xi_type \" << xi_type << endl;\n            return 1;\n        }\n\n        // Output li, ri, xi\n        printf(\"%d %d %d\\n\", li, ri, xi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\");\n\n    ensure(1 <= m && m <= n && n <= 200000);\n    ensure(1 <= s && s <= 200000);\n\n    int n_minus_m_plus_1 = n - m + 1;\n    ensure(n_minus_m_plus_1 >= 1);\n\n    string a_type = opt<string>(\"a_type\", \"random\");\n    int a_max = opt<int>(\"a_max\", (1 << 30) - 1);\n    ensure(0 <= a_max && a_max < (1 << 30));\n\n    string li_type = opt<string>(\"li_type\", \"random\");\n    int li_value = opt<int>(\"li_value\", 1);\n\n    string ri_type = opt<string>(\"ri_type\", \"random\");\n    int ri_value = opt<int>(\"ri_value\", n_minus_m_plus_1);\n\n    string xi_type = opt<string>(\"xi_type\", \"random\");\n    int xi_max = opt<int>(\"xi_max\", (1 << 30) - 1);\n    ensure(0 <= xi_max && xi_max < (1 << 30));\n    int xi_value = opt<int>(\"xi_value\", 0);\n    ensure(0 <= xi_value && xi_value < (1 << 30));\n\n    // Generate ai according to a_type\n    vector<int> a(n);\n\n    if (a_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, a_max);\n        }\n    } else if (a_type == \"constant\") {\n        int a_value = opt<int>(\"a_value\", a_max);\n        ensure(0 <= a_value && a_value < (1 << 30));\n        for (int i = 0; i < n; ++i) {\n            a[i] = a_value;\n        }\n    } else if (a_type == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = a_max;\n        }\n    } else if (a_type == \"min\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (a_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)((long long)i * a_max / (n - 1));\n            ensure(0 <= a[i] && a[i] < (1 << 30));\n        }\n    } else if (a_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = (int)((long long)(n - 1 - i) * a_max / (n - 1));\n            ensure(0 <= a[i] && a[i] < (1 << 30));\n        }\n    } else {\n        // Unknown a_type\n        cerr << \"Unknown a_type \" << a_type << endl;\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output s\n    printf(\"%d\\n\", s);\n\n    for (int i = 1; i <= s; ++i) {\n        int li, ri, xi;\n\n        // Generate li\n        if (li_type == \"random\") {\n            li = rnd.next(1, n_minus_m_plus_1);\n        } else if (li_type == \"fixed\") {\n            li = li_value;\n            ensure(1 <= li && li <= n_minus_m_plus_1);\n        } else {\n            cerr << \"Unknown li_type \" << li_type << endl;\n            return 1;\n        }\n\n        // Generate ri\n        if (ri_type == \"random\") {\n            ri = rnd.next(li, n_minus_m_plus_1);\n        } else if (ri_type == \"fixed\") {\n            ri = ri_value;\n            ensure(li <= ri && ri <= n_minus_m_plus_1);\n        } else {\n            cerr << \"Unknown ri_type \" << ri_type << endl;\n            return 1;\n        }\n\n        // Generate xi\n        if (xi_type == \"random\") {\n            xi = rnd.next(0, xi_max);\n        } else if (xi_type == \"fixed\") {\n            xi = xi_value;\n            ensure(0 <= xi && xi < (1 << 30));\n        } else {\n            cerr << \"Unknown xi_type \" << xi_type << endl;\n            return 1;\n        }\n\n        // Output li, ri, xi\n        printf(\"%d %d %d\\n\", li, ri, xi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 3 -s 5 -a_type random -a_max 10 -xi_type random -xi_max 10\n\n./gen -n 1 -m 1 -s 1 -a_type random -a_max 0 -xi_type random -xi_max 0\n\n./gen -n 200000 -m 1 -s 200000 -a_type max -li_type fixed -li_value 1 -ri_type fixed -ri_value 1 -xi_type fixed -xi_value 1073741823\n\n./gen -n 200000 -m 200000 -s 1 -a_type random -a_max 1073741823 -xi_type random\n\n./gen -n 200000 -m 100000 -s 200000 -a_type increasing -xi_type fixed -xi_value 0\n\n./gen -n 200000 -m 1 -s 200000 -a_type decreasing -xi_type fixed -xi_value 0\n\n./gen -n 200000 -m 1 -s 200000 -a_type constant -a_value 0\n\n./gen -n 200000 -m 1 -s 1 -a_type constant -a_value 1073741823\n\n./gen -n 200000 -m 200000 -s 1 -a_type constant -a_value 1073741823\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -a_max 1073741823 -xi_type fixed -xi_value 0\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -a_max 0 -xi_type fixed -xi_value 1073741823\n\n./gen -n 100000 -m 1 -s 100000 -a_type random -a_max 500000000 -xi_type random -xi_max 500000000\n\n./gen -n 200000 -m 2 -s 200000 -a_type random -xi_type random\n\n./gen -n 200000 -m 2 -s 200000 -a_type random -li_type fixed -li_value 1 -ri_type fixed -ri_value 1\n\n./gen -n 100000 -m 3 -s 100000 -a_type random -li_type random -ri_type random\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -li_type random -xi_type fixed -xi_value 0\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -xi_type random -xi_max 1\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -xi_type fixed -xi_value 1\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -li_type random -ri_type random -xi_type random\n\n./gen -n 200000 -m 1 -s 200000 -a_type max -xi_type random\n\n./gen -n 200000 -m 1 -s 200000 -a_type min -xi_type random\n\n./gen -n 200000 -m 1 -s 200000 -a_type increasing -xi_type random\n\n./gen -n 200000 -m 1 -s 200000 -a_type decreasing -xi_type random\n\n./gen -n 200000 -m 1 -s 200000 -a_type constant -a_value 1 -xi_type random\n\n./gen -n 2 -m 1 -s 1 -a_type random -a_max 1 -xi_type random -xi_max 1\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -li_type fixed -li_value 1 -ri_type fixed -ri_value 200000\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -li_type fixed -li_value 200000 -ri_type fixed -ri_value 200000\n\n./gen -n 200000 -m 1 -s 200000 -a_type random -li_type fixed -li_value 1 -ri_type fixed -ri_value 1\n\n./gen -n 200000 -m 1 -s 1 -a_type random -xi_type random -xi_max 0\n\n./gen -n 200000 -m 200000 -s 200000 -a_type random -xi_type random\n\n./gen -n 200000 -m 1 -s 1 -a_type min -xi_type fixed -xi_value 0\n\n./gen -n 10 -m 5 -s 10 -a_type decreasing -xi_type random\n\n./gen -n 10 -m 5 -s 10 -a_type increasing -xi_type random\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:14.699148",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "544/A",
      "title": "A. Set of Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a positive integer k (1 ≤ k ≤ 26) — the number of strings that should be in a beautiful sequence. The second line contains string q, consisting of lowercase Latin letters. The length of the string is within range from 1 to 100, inclusive.",
      "output_spec": "OutputIf such sequence doesn't exist, then print in a single line \"NO\" (without the quotes). Otherwise, print in the first line \"YES\" (without the quotes) and in the next k lines print the beautiful sequence of strings s1, s2, ..., sk.If there are multiple possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy1abcaOutputCopyYESabcaInputCopy2aaacasOutputCopyYESaaacasInputCopy4abcOutputCopyNO",
      "description": "A. Set of Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a positive integer k (1 ≤ k ≤ 26) — the number of strings that should be in a beautiful sequence. The second line contains string q, consisting of lowercase Latin letters. The length of the string is within range from 1 to 100, inclusive.\n\nOutputIf such sequence doesn't exist, then print in a single line \"NO\" (without the quotes). Otherwise, print in the first line \"YES\" (without the quotes) and in the next k lines print the beautiful sequence of strings s1, s2, ..., sk.If there are multiple possible answers, print any of them.\n\nInputCopy1abcaOutputCopyYESabcaInputCopy2aaacasOutputCopyYESaaacasInputCopy4abcOutputCopyNO\n\nInputCopy1abca\n\nOutputCopyYESabca\n\nInputCopy2aaacas\n\nOutputCopyYESaaacas\n\nInputCopy4abc\n\nOutputCopyNO\n\nNoteIn the second sample there are two possible answers: {\"aaaca\", \"s\"} and {\"aaa\", \"cas\"}.",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 544\\s*A"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    string q = inf.readToken(\"[a-z]{1,100}\", \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    string q = inf.readToken(\"[a-z]{1,100}\", \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 26, \"k\");\n    inf.readEoln();\n    string q = inf.readToken(\"[a-z]{1,100}\", \"q\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int k = inf.readInt();\n    string q = inf.readToken();\n\n    // Read jury's answer\n    string juryAns = ans.readToken();\n\n    auto toUpper = [](const string& s) {\n        string res = s;\n        for (char &c : res)\n            c = toupper(c);\n        return res;\n    };\n\n    bool juryHasSolution;\n\n    if (toUpper(juryAns) == \"NO\") {\n        juryHasSolution = false;\n    } else if (toUpper(juryAns) == \"YES\") {\n        juryHasSolution = true;\n        // Read k strings from ans\n        for (int i = 0; i < k; ++i) {\n            ans.readToken();\n        }\n    } else {\n        ans.quitf(_fail, \"Jury output must be YES or NO, found '%s'\", juryAns.c_str());\n    }\n\n    // Read participant's answer\n    string partAns = ouf.readToken();\n\n    if (toUpper(partAns) == \"NO\") {\n        if (juryHasSolution) {\n            quitf(_wa, \"Participant output NO, but a solution exists\");\n        } else {\n            quitf(_ok, \"Correct, no solution exists\");\n        }\n    } else if (toUpper(partAns) == \"YES\") {\n        // Read k strings from participant\n        vector<string> participantStrings;\n        for (int i = 0; i < k; ++i) {\n            if (ouf.eof())\n                quitf(_wa, \"Participant's output is incomplete. Expected %d strings, but found %d\", k, i);\n            participantStrings.push_back(ouf.readToken());\n        }\n        // Check for extra output\n        if (!ouf.seekEof())\n            quitf(_wa, \"Participant's output contains extra data\");\n\n        // Validate participant's solution\n        // Check that concatenation equals q\n        string concat;\n        for (const string& s : participantStrings) {\n            concat += s;\n        }\n        if (concat != q) {\n            quitf(_wa, \"Concatenation of participant's strings does not equal q\");\n        }\n        // Check that first characters are distinct\n        set<char> firstLetters;\n        for (const string& s : participantStrings) {\n            if (s.empty()) {\n                quitf(_wa, \"One of the participant's strings is empty\");\n            }\n            char firstChar = s[0];\n            if (firstLetters.count(firstChar)) {\n                quitf(_wa, \"First characters of participant's strings are not distinct\");\n            }\n            firstLetters.insert(firstChar);\n        }\n        if (juryHasSolution) {\n            quitf(_ok, \"Participant's solution is correct\");\n        } else {\n            quitf(_fail, \"Participant found a solution, but jury says no solution exists\");\n        }\n    } else {\n        quitf(_wa, \"Participant output must be YES or NO, found '%s'\", partAns.c_str());\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1); // Default -1 means decide k in code\n    int n = opt<int>(\"n\", -1); // Default -1 means decide n in code\n    string type = opt<string>(\"type\", \"random\");\n\n    string q;\n\n    if(type == \"random\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        // Generate random q of length n\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = 'a' + rnd.next(0,25);\n        }\n        if (k == -1)\n            k = rnd.next(1, min(n, 26));\n        else\n            k = min(k, min(n, 26));\n    } else if(type == \"char_repeat\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        char c = 'a' + rnd.next(0,25);\n        q = string(n, c);\n        if (k == -1)\n            k = rnd.next(1, min(n, 26));\n        else\n            k = min(k, min(n, 26));\n    } else if(type == \"max_start_letters\") {\n        if (n == -1)\n            n = 100;\n        vector<char> letters;\n        for (char c = 'a'; c <= 'z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        q.clear();\n        int idx = 0;\n        while(q.size() < n) {\n            q += letters[idx];\n            idx = (idx + 1) % letters.size();\n        }\n        q = q.substr(0, n);\n        if (k == -1)\n            k = rnd.next(1, min(26, n));\n        else\n            k = min(k, min(n, 26));\n    } else if(type == \"impossible_k\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        k = n + rnd.next(1, 10); // k is greater than n, impossible\n        k = min(k, 100); // Ensure k is within problem constraints\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = 'a' + rnd.next(0,25);\n        }\n    } else if(type == \"impossible_unique\") {\n        int num_unique = rnd.next(1, 25);\n        vector<char> letters;\n        for(int i = 0; i < num_unique; ++i) {\n            letters.push_back('a' + i);\n        }\n        if (n == -1)\n            n = rnd.next(1, 100);\n        q.clear();\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = letters[rnd.next(0, num_unique - 1)];\n        }\n        shuffle(q.begin(), q.end());\n        k = num_unique + rnd.next(1, 26 - num_unique); // k greater than possible unique starting letters\n        k = min(k, 26); // Ensure k is within problem constraints\n    } else {\n        // Default to random type if unknown type is provided\n        if (n == -1)\n            n = rnd.next(1, 100);\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = 'a' + rnd.next(0,25);\n        }\n        if (k == -1)\n            k = rnd.next(1, min(n,26));\n        else\n            k = min(k, min(n,26));\n    }\n\n    // Ensure k is within 1..26\n    k = min(max(1, k), 26);\n\n    cout << k << endl;\n    cout << q << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\", -1); // Default -1 means decide k in code\n    int n = opt<int>(\"n\", -1); // Default -1 means decide n in code\n    string type = opt<string>(\"type\", \"random\");\n\n    string q;\n\n    if(type == \"random\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        // Generate random q of length n\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = 'a' + rnd.next(0,25);\n        }\n        if (k == -1)\n            k = rnd.next(1, min(n, 26));\n        else\n            k = min(k, min(n, 26));\n    } else if(type == \"char_repeat\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        char c = 'a' + rnd.next(0,25);\n        q = string(n, c);\n        if (k == -1)\n            k = rnd.next(1, min(n, 26));\n        else\n            k = min(k, min(n, 26));\n    } else if(type == \"max_start_letters\") {\n        if (n == -1)\n            n = 100;\n        vector<char> letters;\n        for (char c = 'a'; c <= 'z'; ++c)\n            letters.push_back(c);\n        shuffle(letters.begin(), letters.end());\n        q.clear();\n        int idx = 0;\n        while(q.size() < n) {\n            q += letters[idx];\n            idx = (idx + 1) % letters.size();\n        }\n        q = q.substr(0, n);\n        if (k == -1)\n            k = rnd.next(1, min(26, n));\n        else\n            k = min(k, min(n, 26));\n    } else if(type == \"impossible_k\") {\n        if (n == -1)\n            n = rnd.next(1, 100);\n        k = n + rnd.next(1, 10); // k is greater than n, impossible\n        k = min(k, 100); // Ensure k is within problem constraints\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = 'a' + rnd.next(0,25);\n        }\n    } else if(type == \"impossible_unique\") {\n        int num_unique = rnd.next(1, 25);\n        vector<char> letters;\n        for(int i = 0; i < num_unique; ++i) {\n            letters.push_back('a' + i);\n        }\n        if (n == -1)\n            n = rnd.next(1, 100);\n        q.clear();\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = letters[rnd.next(0, num_unique - 1)];\n        }\n        shuffle(q.begin(), q.end());\n        k = num_unique + rnd.next(1, 26 - num_unique); // k greater than possible unique starting letters\n        k = min(k, 26); // Ensure k is within problem constraints\n    } else {\n        // Default to random type if unknown type is provided\n        if (n == -1)\n            n = rnd.next(1, 100);\n        q.resize(n);\n        for(int i = 0; i < n; ++i) {\n            q[i] = 'a' + rnd.next(0,25);\n        }\n        if (k == -1)\n            k = rnd.next(1, min(n,26));\n        else\n            k = min(k, min(n,26));\n    }\n\n    // Ensure k is within 1..26\n    k = min(max(1, k), 26);\n\n    cout << k << endl;\n    cout << q << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random -n 10 -k 5\n./gen -type random -n 100\n./gen -type random -n 100 -k 26\n./gen -type random -n 100 -k 1\n./gen -type random -n 50 -k 25\n./gen -type random -k 1\n./gen -type random -n 1\n./gen -type random -n 100 -k 50\n\n./gen -type char_repeat\n./gen -type char_repeat -n 20\n./gen -type char_repeat -n 50 -k 5\n./gen -type char_repeat -n 10 -k 1\n./gen -type char_repeat -n 10 -k 10\n./gen -type char_repeat -n 1\n./gen -type char_repeat -n 100 -k 26\n\n./gen -type max_start_letters\n./gen -type max_start_letters -n 26 -k 26\n./gen -type max_start_letters -n 100\n./gen -type max_start_letters -k 5\n./gen -type max_start_letters -n 10\n./gen -type max_start_letters -n 100 -k 26\n./gen -type max_start_letters -n 100 -k 1\n\n./gen -type impossible_k\n./gen -type impossible_k -n 10\n./gen -type impossible_k -n 100\n\n./gen -type impossible_unique\n./gen -type impossible_unique -n 10\n./gen -type impossible_unique -n 100\n./gen -type impossible_unique -k 30\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:16.626174",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "544/B",
      "title": "B. Sea and Islands",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two positive integers n, k (1 ≤ n ≤ 100, 0 ≤ k ≤ n2) — the size of the map and the number of islands you should form.",
      "output_spec": "OutputIf the answer doesn't exist, print \"NO\" (without the quotes) in a single line.Otherwise, print \"YES\" in the first line. In the next n lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal n.If there are multiple answers, you may print any of them.You should not maximize the sizes of islands.",
      "sample_tests": "ExamplesInputCopy5 2OutputCopyYESSSSSSLLLLLSSSSSLLLLLSSSSSInputCopy5 25OutputCopyNO",
      "description": "B. Sea and Islands\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line contains two positive integers n, k (1 ≤ n ≤ 100, 0 ≤ k ≤ n2) — the size of the map and the number of islands you should form.\n\nOutputIf the answer doesn't exist, print \"NO\" (without the quotes) in a single line.Otherwise, print \"YES\" in the first line. In the next n lines print the description of the map. Each of the lines of the description must consist only of characters 'S' and 'L', where 'S' is a cell that is occupied by the sea and 'L' is the cell covered with sand. The length of each line of the description must equal n.If there are multiple answers, you may print any of them.You should not maximize the sizes of islands.\n\nInputCopy5 2OutputCopyYESSSSSSLLLLLSSSSSLLLLLSSSSSInputCopy5 25OutputCopyNO\n\nInputCopy5 2\n\nOutputCopyYESSSSSSLLLLLSSSSSLLLLLSSSSS\n\nInputCopy5 25\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 544\\s*B"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n * n, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, k;\nint maxIslands;\nvector<string> grid;\nvector<vector<bool>> visited;\n\nvoid dfs(int x, int y) {\n    visited[x][y] = true;\n    int dx[] = {-1, 0, 0, 1};\n    int dy[] = {0, -1, 1, 0};\n    for (int dir = 0; dir < 4; dir++) {\n        int nx = x + dx[dir];\n        int ny = y + dy[dir];\n        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n            if (!visited[nx][ny] && grid[nx][ny] == 'L') {\n                dfs(nx, ny);\n            }\n        }\n    }\n}\n\nint countIslands() {\n    visited.assign(n, vector<bool>(n, false));\n    int islands = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!visited[i][j] && grid[i][j] == 'L') {\n                dfs(i, j);\n                islands++;\n            }\n        }\n    }\n    return islands;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt();\n    k = inf.readInt();\n\n    int maxIslands = (n * n + 1) / 2;\n\n    string contestant_status = ouf.readWord();\n    if (contestant_status != \"YES\" && contestant_status != \"NO\") {\n        quitf(_wa, \"First line must be YES or NO\");\n    }\n\n    if (contestant_status == \"NO\") {\n        if (k <= maxIslands) {\n            quitf(_wa, \"A solution exists but contestant output NO\");\n        } else {\n            quitf(_ok, \"Correctly output NO\");\n        }\n    } else { // \"YES\"\n        if (k > maxIslands) {\n            quitf(_wa, \"No solution exists for k > maximum islands\");\n        }\n        grid.resize(n);\n        for (int i = 0; i < n; i++) {\n            grid[i] = ouf.readWord();\n            if ((int)grid[i].length() != n) {\n                quitf(_wa, \"Line %d length is not %d\", i + 1, n);\n            }\n            for (char c : grid[i]) {\n                if (c != 'L' && c != 'S') {\n                    quitf(_wa, \"Invalid character '%c' at line %d\", c, i + 1);\n                }\n            }\n        }\n        int islands = countIslands();\n        if (islands != k) {\n            quitf(_wa, \"Number of islands is %d instead of %d\", islands, k);\n        } else {\n            quitf(_ok, \"Correctly formed %d islands\", k);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    int maxIslands = (n * n + 1) / 2;\n\n    int k;\n\n    if (type == \"zero\") {\n        k = 0;\n    } else if (type == \"one\") {\n        k = 1;\n    } else if (type == \"max\") {\n        k = maxIslands;\n    } else if (type == \"over\") {\n        k = maxIslands + 1;\n        if (k > n * n) k = n * n;\n    } else if (type == \"full\") {\n        k = n * n;\n    } else if (type == \"random\") {\n        k = rnd.next(0, maxIslands);\n    } else if (type == \"random-impossible\") {\n        if (maxIslands + 1 > n * n) {\n            k = n * n;\n        } else {\n            k = rnd.next(maxIslands + 1, n * n);\n        }\n    } else {\n        // Default case, random valid k\n        k = rnd.next(0, maxIslands);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    int maxIslands = (n * n + 1) / 2;\n\n    int k;\n\n    if (type == \"zero\") {\n        k = 0;\n    } else if (type == \"one\") {\n        k = 1;\n    } else if (type == \"max\") {\n        k = maxIslands;\n    } else if (type == \"over\") {\n        k = maxIslands + 1;\n        if (k > n * n) k = n * n;\n    } else if (type == \"full\") {\n        k = n * n;\n    } else if (type == \"random\") {\n        k = rnd.next(0, maxIslands);\n    } else if (type == \"random-impossible\") {\n        if (maxIslands + 1 > n * n) {\n            k = n * n;\n        } else {\n            k = rnd.next(maxIslands + 1, n * n);\n        }\n    } else {\n        // Default case, random valid k\n        k = rnd.next(0, maxIslands);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type zero\n./gen -n 1 -type one\n./gen -n 1 -type over\n./gen -n 1 -type full\n./gen -n 1 -type random\n./gen -n 1 -type random-impossible\n\n./gen -n 2 -type zero\n./gen -n 2 -type one\n./gen -n 2 -type max\n./gen -n 2 -type over\n\n./gen -n 3 -type zero\n./gen -n 3 -type one\n./gen -n 3 -type random\n./gen -n 3 -type random-impossible\n\n./gen -n 5 -type random\n./gen -n 5 -type random-impossible\n\n./gen -n 10 -type zero\n./gen -n 10 -type one\n./gen -n 10 -type max\n./gen -n 10 -type over\n./gen -n 10 -type random\n./gen -n 10 -type random-impossible\n\n./gen -n 50 -type random\n./gen -n 50 -type random-impossible\n\n./gen -n 75 -type zero\n./gen -n 75 -type one\n./gen -n 75 -type random\n\n./gen -n 99 -type max\n./gen -n 99 -type full\n\n./gen -n 100 -type zero\n./gen -n 100 -type one\n./gen -n 100 -type max\n./gen -n 100 -type over\n./gen -n 100 -type random\n./gen -n 100 -type random-impossible\n./gen -n 100 -type full\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:18.712565",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "544/C",
      "title": "C. Writing Code",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n, m, b, mod (1 ≤ n, m ≤ 500, 0 ≤ b ≤ 500; 1 ≤ mod ≤ 109 + 7) — the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer.The next line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 500) — the number of bugs per line for each programmer.",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo mod.",
      "sample_tests": "ExamplesInputCopy3 3 3 1001 1 1OutputCopy10InputCopy3 6 5 10000000071 2 3OutputCopy0InputCopy3 5 6 111 2 1OutputCopy0",
      "description": "C. Writing Code\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers n, m, b, mod (1 ≤ n, m ≤ 500, 0 ≤ b ≤ 500; 1 ≤ mod ≤ 109 + 7) — the number of programmers, the number of lines of code in the task, the maximum total number of bugs respectively and the modulo you should use when printing the answer.The next line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 500) — the number of bugs per line for each programmer.\n\nOutputPrint a single integer — the answer to the problem modulo mod.\n\nInputCopy3 3 3 1001 1 1OutputCopy10InputCopy3 6 5 10000000071 2 3OutputCopy0InputCopy3 5 6 111 2 1OutputCopy0\n\nInputCopy3 3 3 1001 1 1\n\nOutputCopy10\n\nInputCopy3 6 5 10000000071 2 3\n\nOutputCopy0\n\nInputCopy3 5 6 111 2 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 544 和字母"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(0, 500, \"b\");\n    inf.readSpace();\n    int mod = inf.readInt(1, 1000000007, \"mod\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 500);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(0, 500, \"b\");\n    inf.readSpace();\n    int mod = inf.readInt(1, 1000000007, \"mod\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 500);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(0, 500, \"b\");\n    inf.readSpace();\n    int mod = inf.readInt(1, 1000000007, \"mod\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 500);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    int mod = opt<int>(\"mod\");\n    string type = opt<string>(\"type\", \"random\");\n    int a_max = opt<int>(\"a_max\", 500); // Default maximum ai\n    \n    // Adjust parameters to be within allowed ranges\n    n = max(1, min(n, 500));\n    m = max(1, min(m, 500));\n    b = max(0, min(b, 500));\n    mod = max(1, min(mod, 1000000007));\n    a_max = max(0, min(a_max, 500));\n    \n    vector<int> a(n);\n\n    if (type == \"zero_bugs\") {\n        // ai = 0 for all i\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"max_bugs\") {\n        // ai = maximum value (a_max) for all i\n        for(int i = 0; i < n; ++i)\n            a[i] = a_max;\n    } else if (type == \"small_ai\") {\n        // ai between 0 and min(10, a_max)\n        int max_val = min(10, a_max);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_val);\n    } else if (type == \"large_ai\") {\n        // ai between max(400, a_max/2) and a_max\n        int min_val = max(400, a_max / 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_val, a_max);\n    } else if (type == \"half_zero_ai\") {\n        // Half ai are zero, half random between 0 and a_max\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(0, a_max);\n        }\n    } else if (type == \"increasing_ai\") {\n        // ai increasing from 0 to a_max\n        for(int i = 0; i < n; ++i)\n            a[i] = i * a_max / max(1, n - 1);\n    } else if (type == \"decreasing_ai\") {\n        // ai decreasing from a_max to 0\n        for(int i = 0; i < n; ++i)\n            a[i] = (n - 1 - i) * a_max / max(1, n - 1);\n    } else if (type == \"single_large_ai\") {\n        // Only one large ai, rest are zero\n        int idx = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[idx] = a_max;\n    } else if (type == \"random\") {\n        // ai random between 0 and a_max\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, a_max);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, a_max);\n    }\n    \n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, b, mod);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 == n)\n            printf(\"\\n\");\n        else\n            printf(\" \");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    int mod = opt<int>(\"mod\");\n    string type = opt<string>(\"type\", \"random\");\n    int a_max = opt<int>(\"a_max\", 500); // Default maximum ai\n    \n    // Adjust parameters to be within allowed ranges\n    n = max(1, min(n, 500));\n    m = max(1, min(m, 500));\n    b = max(0, min(b, 500));\n    mod = max(1, min(mod, 1000000007));\n    a_max = max(0, min(a_max, 500));\n    \n    vector<int> a(n);\n\n    if (type == \"zero_bugs\") {\n        // ai = 0 for all i\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"max_bugs\") {\n        // ai = maximum value (a_max) for all i\n        for(int i = 0; i < n; ++i)\n            a[i] = a_max;\n    } else if (type == \"small_ai\") {\n        // ai between 0 and min(10, a_max)\n        int max_val = min(10, a_max);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, max_val);\n    } else if (type == \"large_ai\") {\n        // ai between max(400, a_max/2) and a_max\n        int min_val = max(400, a_max / 2);\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(min_val, a_max);\n    } else if (type == \"half_zero_ai\") {\n        // Half ai are zero, half random between 0 and a_max\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(0, a_max);\n        }\n    } else if (type == \"increasing_ai\") {\n        // ai increasing from 0 to a_max\n        for(int i = 0; i < n; ++i)\n            a[i] = i * a_max / max(1, n - 1);\n    } else if (type == \"decreasing_ai\") {\n        // ai decreasing from a_max to 0\n        for(int i = 0; i < n; ++i)\n            a[i] = (n - 1 - i) * a_max / max(1, n - 1);\n    } else if (type == \"single_large_ai\") {\n        // Only one large ai, rest are zero\n        int idx = rnd.next(0, n - 1);\n        for(int i = 0; i < n; ++i)\n            a[i] = 0;\n        a[idx] = a_max;\n    } else if (type == \"random\") {\n        // ai random between 0 and a_max\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, a_max);\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, a_max);\n    }\n    \n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, b, mod);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 == n)\n            printf(\"\\n\");\n        else\n            printf(\" \");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test case\n./gen -n 2 -m 2 -b 10 -mod 1000000007 -type random\n\n# Small test case, ai all zero\n./gen -n 3 -m 3 -b 0 -mod 1000000007 -type zero_bugs\n\n# Large n and m, random ai\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type random\n\n# Large ai, small b, expect zero plans\n./gen -n 500 -m 500 -b 1 -mod 1000000007 -type max_bugs\n\n# ai are small, b is small\n./gen -n 100 -m 100 -b 10 -mod 1000000007 -type small_ai\n\n# ai are large, b is large\n./gen -n 100 -m 100 -b 50000 -mod 1000000007 -type large_ai\n\n# Half ai zero\n./gen -n 100 -m 100 -b 1000 -mod 1000000007 -type half_zero_ai\n\n# Increasing ai\n./gen -n 100 -m 100 -b 1000 -mod 1000000007 -type increasing_ai\n\n# Decreasing ai\n./gen -n 100 -m 100 -b 1000 -mod 1000000007 -type decreasing_ai\n\n# Single large ai\n./gen -n 100 -m 100 -b 1000 -mod 1000000007 -type single_large_ai\n\n# b = 0, ai = 0\n./gen -n 50 -m 50 -b 0 -mod 1000000007 -type zero_bugs\n\n# b = 0, ai > 0\n./gen -n 50 -m 50 -b 0 -mod 1000000007 -type small_ai\n\n# b is maximum\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type random\n\n# Maximum mod\n./gen -n 30 -m 30 -b 100 -mod 1000000007 -type random\n\n# Small mod\n./gen -n 30 -m 30 -b 100 -mod 1 -type random\n\n# Mod is a prime number\n./gen -n 30 -m 30 -b 100 -mod 1000000007 -type random\n\n# Min n, max m\n./gen -n 1 -m 500 -b 500 -mod 1000000007 -type random\n\n# Max n, min m\n./gen -n 500 -m 1 -b 500 -mod 1000000007 -type random\n\n# Max n and m, random ai\n./gen -n 500 -m 500 -b 500 -mod 1000000007 -type random\n\n# Min n and m, random ai\n./gen -n 1 -m 1 -b 1 -mod 1000000007 -type random\n\n# Test with ai = 500\n./gen -n 100 -m 100 -b 50000 -mod 1000000007 -type max_bugs -a_max 500\n\n# Test with ai = 1\n./gen -n 100 -m 100 -b 100 -mod 1000000007 -type max_bugs -a_max 1\n\n# Random ai with a_max = 250\n./gen -n 100 -m 100 -b 25000 -mod 1000000007 -type random -a_max 250\n\n# Max m and b\n./gen -n 100 -m 500 -b 50000 -mod 1000000007 -type large_ai\n\n# Min b\n./gen -n 100 -m 100 -b 0 -mod 1000000007 -type random\n\n# Medium n and m\n./gen -n 250 -m 250 -b 500 -mod 1000000007 -type random\n\n# Random mod (within constraints)\n./gen -n 100 -m 100 -b 500 -mod 123456789 -type random\n\n# Max allowed mod\n./gen -n 100 -m 100 -b 500 -mod 1000000007 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:20.672773",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "544/D",
      "title": "D. Разрушение дорог",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано два целых числа n, m (1 ≤ n ≤ 3000, ) — количество городов и дорог в стране соответственно. Далее в m строках задано описание дорог в виде пар чисел ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Гарантируется, что по заданным в описании дорогам из каждого города можно добраться до любого другого города. Гарантируется, что между каждой парой городов существует не более одной дороги.Последние две строки содержат по три числа s1, t1, l1 и s2, t2, l2, соответственно (1 ≤ si, ti ≤ n, 0 ≤ li ≤ n).",
      "output_spec": "Выходные данныеВыведите единственное число — ответ на задачу. Если план выполнить невозможно, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 41 22 33 44 51 3 23 5 2Выходные данныеСкопировать0Входные данныеСкопировать5 41 22 33 44 51 3 22 4 2Выходные данныеСкопировать1Входные данныеСкопировать5 41 22 33 44 51 3 23 5 1Выходные данныеСкопировать-1",
      "description": "D. Разрушение дорог\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано два целых числа n, m (1 ≤ n ≤ 3000, ) — количество городов и дорог в стране соответственно. Далее в m строках задано описание дорог в виде пар чисел ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Гарантируется, что по заданным в описании дорогам из каждого города можно добраться до любого другого города. Гарантируется, что между каждой парой городов существует не более одной дороги.Последние две строки содержат по три числа s1, t1, l1 и s2, t2, l2, соответственно (1 ≤ si, ti ≤ n, 0 ≤ li ≤ n).\n\nВходные данные\n\nВыходные данныеВыведите единственное число — ответ на задачу. Если план выполнить невозможно, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать5 41 22 33 44 51 3 23 5 2Выходные данныеСкопировать0Входные данныеСкопировать5 41 22 33 44 51 3 22 4 2Выходные данныеСкопировать1Входные данныеСкопировать5 41 22 33 44 51 3 23 5 1Выходные данныеСкопировать-1\n\nВходные данныеСкопировать5 41 22 33 44 51 3 23 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 41 22 33 44 51 3 22 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 41 22 33 44 51 3 23 5 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Привет Codeforces!Скоро состоится очередной раунд Codeforces Round #302, задачи для которого придумал я, Виталий Гриднев.Хочу сказать большое спасибо Максиму Ахмедову (Zlobober), Александру Игнатьеву (aiMR), Данилу Сагунову (danilka.pro) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Распределение баллов: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Контест закончен, поздравляем победителей:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 647
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces",
          "content": "544A - Набор строкВ этой задаче нужно написать то, что написано в условии. Для этого можно воспользоваться массивом, с помощью которого мы будем понимать встречалась буква до этого. Будем будем обрабатывать символы по очереди. И поддерживать некоторую строчку. Если текущий символ ещё не встречался, то тогда начнём новую строку, а текущую строку мы положим в массив ответа. Иначе добавим текущий символ конец текущей строки.Если в массиве ответа окажется больше чем к строк, то тогда сконкатенируем на несколько последних в одну. Авторское решение: 11035685544B - Море и островаВ эти задачи нетрудно понять что оптимальный ответ всегда состоит из одиночных клеток обладающих следущим свойством: сумма индекса строчки и столбца четная. Таким образом попробуем разместить ровно k островков в этих в клетках, если не получится, то ответ на задачу NO. Попробуйте доказать почему всегда так действовать оптимально.Авторское решение: 11035691543A - Пишем кодДавайте для начала придумаем решение который будет работать медленнее чем нужно. Будем решать задачи динамическим программированием: z[i][j][k] — мы обработали ровно i программистов, написали ровно j строчек кода и при этом возникло ровно k ошибок. Как сделать в такой динамике переходы? Очень просто, переберём сколько строчек напишет i программист (пусть r) и прибавим к z[i][j][k] значение z[i][j - r][k - r[ai]]. Однако давайте посмотрим на переходы с другой стороны. Очевидно, что i программист либо не напишет ни одной строчки, тогда к ответу прибавится значение z[i - 1][j][k], либо он напишет одну строчку, а остальные строчки учтутся в значении z[i][j - 1][k - a[i]]. Здесь можно провести аналогию c подсчетом биномиальных коэффициентов c помощью треугольника паскаля. Таким образом получим решение за ассимптотику O(n3)Авторское решение: 11035704543B - Разрушение дорогДля начала попробуем решить задачу проще: задана пара вершин, нужно определить минимальный набор ребер, который нужно оставить, чтобы существовал путь из одной вершины, в другую. Очевидно, это число в точности равно кратчайшему расстоянию между вершинами. Теперь перейдем к искомой задаче. Пусть d[i][j] — кратчайшее расстояние между вершинами. Такую матрицу очень просто насчитать, запустив из каждой из n вершин bfs. ОтличноТеперь разберем два случая: Пути не пересекаются, тогда ответ можно обновить числом m - d[s1][t1] - d[s2][t2] (при условии, что выполнены условия на длину путей). Иначе, заметим что если пути пересекаются, то тогда тогда ответ имеет вид буквы Н. Более формально, сначала каждый из путей будет содержать различные ребра, потом несколько общих ребер, идущих подряд, и затем каждый из путей будет содержать различные ребра. Таким образом, переберем первую и последнюю общие вершины пути. Пусть эти величины равны (i, j). Тогда обновим ответ величиной m - d[s1][i] - d[i][j] - d[j][t1] - d[s2][i] - d[j][t2] (при условии, что выполняются ограничения на длину путей). Стоит отметить, что также стоит обменять вершины s1 и t1 местами, и снова обновить ответ, поскольку иногда выгодно соединить t1 и с вершиной i, а s1 с вершиной j. Решения, которые не учитывали это не проходили 11 тестАвторское решение: 11035716543C - Запоминаем строкиВо первых стоит отметить важный факт: количество строк меньше длины алфавита. Таким образом, всегда когда мы хотим сделать замену символа на другой, мы всегда сможем найти подходящий другой символ.Далее возможны две ситуации: за одну операцию мы можем взять и заменить символ на любой другой, за это мы заплатим a[i][j] денег ( в зависимости от столбца, в котором мы сделаем строку уникальной). Либо за мы можем взять некоторый столбец, и рассмотреть некоторое множество строк, имеющих одинаковый символ в заданном столбце, и все сделать их уникальными. За это мы оплатим стоимость замены всех символов, кроме одного: самого дорого. Таким образом, получим решение: d[mask] — ответ на задачу, если мы сделали все строки, отвечающие за единичные биты уникальными. Как пересчитывать такую динамику? Пусть lowbit — младший единичный бит. Тогда очевидно, что мы сделаем его уникальным либо с помощью первой операции, либо с помощью второй. Для этого, переберем столбец и рассмотрим множество строк, имеющих такой же символ с со строкой lowbit. И обновим ответ соответствующим значением. Получим решение за ассимптотику O(m2n), где m — длина строки. Авторское решение: 11035719543D - Улучшение дорогПодвесим дерево за вершину 1. Для начала подсчитаем вспомогательную динамику d[i] — количество способов починить дороги для поддерева с корнем в вершине i. Как такую динамику пересчитывать — где j это дети вершины i. Отлично. Таким образом ответ на задачу для вершины 1 — это d[1] Далее научимся переподвешивать дерево за некоторого ребенка j текущей вершины i. Очевидно, пересчитаем величину d[i]: suf[i][j] * pref[i][j] * d[parent], где parent — это родитель вершины i, (для вершины 1 d[parent] = 1), а массивы suf[i][j] — это произведение величин d[k], для всех детей i, k < j (pref[i][j] — k > j). После этого, обновим значение d[j] значением d[j] * (d[i] + 1). Все, теперь вершина j стала корнем, и ответ для нее — текущее значение d[j]Авторское решение: 11035737543E - Слушаем музыкуОтсортируем песни по убыванию. Будем последовательно рассматривать песни и говорить, что теперь песня хорошая и удовлетворяет критерию качества. Пусть si = 0, если песня с номером i еще не добавлена в рассмотрение, и si = 1 иначе. Тогда пусть . Очевидно, когда мы добавляем новую песню позиции idx в рассмотрение, мы должны сделать  +  = 1 на отрезке [max(0, idx - m + 1), idx] в нашем массиве v. Значит, чтобы ответить на запрос, мы должны поддержать структуру данных которая могла бы восстановить заданные значения в массиве v в на тот момент, когда все песни имели качество  ≥ q. Кроме этого, она должна использовать мало памяти. В итоге ответ на запрос очевидно равен m - max(vi), lj ≤ i ≤ rj. Каждые добавлений песен сохраним три величины: значение первого элемента в блоке позиций, максимум значения массива v на блоке, и дополнительно не более обновлений, которые пришли в текущем блоке обновлений, но не покрывали полностью заданный блок. Используя эти значения нужно аккуратно восстановить нужную информацию о массиве v и ответить на запрос.Авторское решение: 11035739",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 544 和字母"
          },
          "content_length": 6248
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 13",
          "code": "YES\nLSLS\nSLSL\nLSLS\nSLSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 14",
          "code": "YES\nLSLS\nSLSL\nLSLS\nSLSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 15",
          "code": "SLSL\nLSLS\nSLSL\nLSLL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 16",
          "code": "SLSL\nLSLS\nSLSL\nLSLL",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 17",
          "code": "add = this.min - min(left.min, right.min)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 18",
          "code": "encoded = MAX_min * (MAX_left * right + left) + min",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 19",
          "code": "MAX_min = 200 001",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 20",
          "code": "MAX_left = 8 000 000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<vector<int>> adj;\nset<pair<int, int>> edges;\n\nvoid dfs(int u, vector<bool>& visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v, visited);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m_lower_bound = (n == 1 ? 0 : n - 1);\n    long long m_upper_bound = 1LL * n * (n - 1) / 2;\n    m = inf.readInt(m_lower_bound, m_upper_bound, \"m\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // cities numbered from 1 to n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge %d has same node ai=bi=%d\", i+1, a);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert({u, v});\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check connectivity\n    vector<bool> visited(n + 1, false);\n    dfs(1, visited);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n\n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, n, \"t1\");\n    inf.readSpace();\n    int l1 = inf.readInt(0, n, \"l1\");\n    inf.readEoln();\n\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, n, \"t2\");\n    inf.readSpace();\n    int l2 = inf.readInt(0, n, \"l2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<vector<int>> adj;\nset<pair<int, int>> edges;\n\nvoid dfs(int u, vector<bool>& visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v, visited);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m_lower_bound = (n == 1 ? 0 : n - 1);\n    long long m_upper_bound = 1LL * n * (n - 1) / 2;\n    m = inf.readInt(m_lower_bound, m_upper_bound, \"m\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // cities numbered from 1 to n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge %d has same node ai=bi=%d\", i+1, a);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert({u, v});\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check connectivity\n    vector<bool> visited(n + 1, false);\n    dfs(1, visited);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n\n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, n, \"t1\");\n    inf.readSpace();\n    int l1 = inf.readInt(0, n, \"l1\");\n    inf.readEoln();\n\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, n, \"t2\");\n    inf.readSpace();\n    int l2 = inf.readInt(0, n, \"l2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<vector<int>> adj;\nset<pair<int, int>> edges;\n\nvoid dfs(int u, vector<bool>& visited) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) dfs(v, visited);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(1, 3000, \"n\");\n    inf.readSpace();\n    int m_lower_bound = (n == 1 ? 0 : n - 1);\n    long long m_upper_bound = 1LL * n * (n - 1) / 2;\n    m = inf.readInt(m_lower_bound, m_upper_bound, \"m\");\n    inf.readEoln();\n\n    adj.resize(n + 1); // cities numbered from 1 to n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(a != b, \"Edge %d has same node ai=bi=%d\", i+1, a);\n        int u = min(a, b);\n        int v = max(a, b);\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between %d and %d\", a, b);\n        edges.insert({u, v});\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    // Check connectivity\n    vector<bool> visited(n + 1, false);\n    dfs(1, visited);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n\n    int s1 = inf.readInt(1, n, \"s1\");\n    inf.readSpace();\n    int t1 = inf.readInt(1, n, \"t1\");\n    inf.readSpace();\n    int l1 = inf.readInt(0, n, \"l1\");\n    inf.readEoln();\n\n    int s2 = inf.readInt(1, n, \"s2\");\n    inf.readSpace();\n    int t2 = inf.readInt(1, n, \"t2\");\n    inf.readSpace();\n    int l2 = inf.readInt(0, n, \"l2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int s1 = opt<int>(\"s1\", -1);\n    int t1 = opt<int>(\"t1\", -1);\n    int l1 = opt<int>(\"l1\", -1);\n    int s2 = opt<int>(\"s2\", -1);\n    int t2 = opt<int>(\"t2\", -1);\n    int l2 = opt<int>(\"l2\", -1);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Chain graph\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n        m = n - 1;\n    } else if (type == \"star\") {\n        // Star graph\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n        m = n - 1;\n    } else if (type == \"dense\") {\n        // Complete graph\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                edges.push_back(make_pair(i, j));\n            }\n        }\n        m = n * (n - 1) / 2;\n    } else if (type == \"random\") {\n        // Random connected graph\n        // Initialize union-find structure\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        };\n\n        auto unite = [&](int x, int y) {\n            int fx = find(x);\n            int fy = find(y);\n            if (fx != fy) {\n                parent[fx] = fy;\n                return true;\n            }\n            return false;\n        };\n\n        // Build a spanning tree\n        vector<pair<int, int>> possible_edges;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                possible_edges.push_back(make_pair(i, j));\n            }\n        }\n\n        shuffle(possible_edges.begin(), possible_edges.end());\n\n        for (auto e : possible_edges) {\n            if (unite(e.first, e.second)) {\n                edges.push_back(e);\n                if ((int)edges.size() == n - 1) break;\n            }\n        }\n\n        // Add extra edges\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        vector<pair<int, int>> remaining_edges;\n        for (auto e : possible_edges) {\n            if (edge_set.count(e) == 0) {\n                remaining_edges.push_back(e);\n            }\n        }\n\n        int remaining_edges_to_add = m - (n - 1);\n        if (remaining_edges_to_add > (int)remaining_edges.size()) {\n            remaining_edges_to_add = remaining_edges.size();\n            m = n - 1 + remaining_edges_to_add;\n        }\n        shuffle(remaining_edges.begin(), remaining_edges.end());\n        for (int i = 0; i < remaining_edges_to_add; ++i) {\n            edges.push_back(remaining_edges[i]);\n        }\n    } else {\n        // Default to random connected graph\n        // Same as \"random\" type\n        // (For unrecognized types)\n        // Code same as above\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    if (s1 == -1) s1 = rnd.next(1, n);\n    if (t1 == -1) t1 = rnd.next(1, n);\n    if (l1 == -1) l1 = rnd.next(0, n);\n\n    if (s2 == -1) s2 = rnd.next(1, n);\n    if (t2 == -1) t2 = rnd.next(1, n);\n    if (l2 == -1) l2 = rnd.next(0, n);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Output s1, t1, l1\n    printf(\"%d %d %d\\n\", s1, t1, l1);\n\n    // Output s2, t2, l2\n    printf(\"%d %d %d\\n\", s2, t2, l2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n - 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    int s1 = opt<int>(\"s1\", -1);\n    int t1 = opt<int>(\"t1\", -1);\n    int l1 = opt<int>(\"l1\", -1);\n    int s2 = opt<int>(\"s2\", -1);\n    int t2 = opt<int>(\"t2\", -1);\n    int l2 = opt<int>(\"l2\", -1);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Chain graph\n        for (int i = 1; i < n; ++i) {\n            edges.push_back(make_pair(i, i + 1));\n        }\n        m = n - 1;\n    } else if (type == \"star\") {\n        // Star graph\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back(make_pair(1, i));\n        }\n        m = n - 1;\n    } else if (type == \"dense\") {\n        // Complete graph\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                edges.push_back(make_pair(i, j));\n            }\n        }\n        m = n * (n - 1) / 2;\n    } else if (type == \"random\") {\n        // Random connected graph\n        // Initialize union-find structure\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n\n        function<int(int)> find = [&](int x) {\n            if (parent[x] != x) parent[x] = find(parent[x]);\n            return parent[x];\n        };\n\n        auto unite = [&](int x, int y) {\n            int fx = find(x);\n            int fy = find(y);\n            if (fx != fy) {\n                parent[fx] = fy;\n                return true;\n            }\n            return false;\n        };\n\n        // Build a spanning tree\n        vector<pair<int, int>> possible_edges;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                possible_edges.push_back(make_pair(i, j));\n            }\n        }\n\n        shuffle(possible_edges.begin(), possible_edges.end());\n\n        for (auto e : possible_edges) {\n            if (unite(e.first, e.second)) {\n                edges.push_back(e);\n                if ((int)edges.size() == n - 1) break;\n            }\n        }\n\n        // Add extra edges\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        vector<pair<int, int>> remaining_edges;\n        for (auto e : possible_edges) {\n            if (edge_set.count(e) == 0) {\n                remaining_edges.push_back(e);\n            }\n        }\n\n        int remaining_edges_to_add = m - (n - 1);\n        if (remaining_edges_to_add > (int)remaining_edges.size()) {\n            remaining_edges_to_add = remaining_edges.size();\n            m = n - 1 + remaining_edges_to_add;\n        }\n        shuffle(remaining_edges.begin(), remaining_edges.end());\n        for (int i = 0; i < remaining_edges_to_add; ++i) {\n            edges.push_back(remaining_edges[i]);\n        }\n    } else {\n        // Default to random connected graph\n        // Same as \"random\" type\n        // (For unrecognized types)\n        // Code same as above\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    if (s1 == -1) s1 = rnd.next(1, n);\n    if (t1 == -1) t1 = rnd.next(1, n);\n    if (l1 == -1) l1 = rnd.next(0, n);\n\n    if (s2 == -1) s2 = rnd.next(1, n);\n    if (t2 == -1) t2 = rnd.next(1, n);\n    if (l2 == -1) l2 = rnd.next(0, n);\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Output s1, t1, l1\n    printf(\"%d %d %d\\n\", s1, t1, l1);\n\n    // Output s2, t2, l2\n    printf(\"%d %d %d\\n\", s2, t2, l2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 4 -type chain\n./gen -n 5 -m 4 -type star\n./gen -n 5 -m 10 -type dense\n\n./gen -n 10 -m 9 -type chain\n./gen -n 10 -m 9 -type star\n./gen -n 10 -m 20 -type random\n\n./gen -n 50 -m 49 -type chain\n./gen -n 50 -m 49 -type star\n./gen -n 50 -m 100 -type random\n\n./gen -n 100 -m 99 -type chain\n./gen -n 100 -m 99 -type star\n./gen -n 100 -m 200 -type random\n\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 3000 -m 4500000 -type dense\n\n./gen -n 3000 -m 6000 -type random\n\n./gen -n 100 -m 200 -type random -s1 1 -t1 100 -l1 2 -s2 50 -t2 75 -l2 3\n\n./gen -n 100 -m 200 -type chain -s1 1 -t1 100 -l1 1 -s2 1 -t2 100 -l2 1\n\n./gen -n 1000 -m 2000 -type random\n\n./gen -n 100 -m 200 -type random -s1 1 -t1 1 -l1 0 -s2 2 -t2 2 -l2 0\n\n./gen -n 100 -m 200 -type random -s1 1 -t1 100 -l1 100 -s2 50 -t2 75 -l2 100\n\n./gen -n 3000 -m 6000 -type random\n\nfor m in 3000 5000 7000 9000 11000; do\n  ./gen -n 3000 -m $m -type random\ndone\n\nfor m in 1000000 2000000 3000000; do\n  ./gen -n 3000 -m $m -type random\ndone\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:22.537658",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "544/E",
      "title": "E. Remembering Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n, m ≤ 20) — the number of strings in the multiset and the length of the strings respectively. Next n lines contain the strings of the multiset, consisting only of lowercase English letters, each string's length is m.Next n lines contain m integers each, the i-th of them contains integers ai1, ai2, ..., aim (0 ≤ aij ≤ 106).",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy4 5abcdeabcdeabcdeabcde1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1OutputCopy3InputCopy4 3abcabaadcada10 10 1010 1 1010 10 1010 1 10OutputCopy2InputCopy3 3abcadassa1 1 11 1 11 1 1OutputCopy0",
      "description": "E. Remembering Strings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, m (1 ≤ n, m ≤ 20) — the number of strings in the multiset and the length of the strings respectively. Next n lines contain the strings of the multiset, consisting only of lowercase English letters, each string's length is m.Next n lines contain m integers each, the i-th of them contains integers ai1, ai2, ..., aim (0 ≤ aij ≤ 106).\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopy4 5abcdeabcdeabcdeabcde1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1OutputCopy3InputCopy4 3abcabaadcada10 10 1010 1 1010 10 1010 1 10OutputCopy2InputCopy3 3abcadassa1 1 11 1 11 1 1OutputCopy0\n\nInputCopy4 5abcdeabcdeabcdeabcde1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1\n\nOutputCopy3\n\nInputCopy4 3abcabaadcada10 10 1010 1 1010 10 1010 1 10\n\nOutputCopy2\n\nInputCopy3 3abcadassa1 1 11 1 11 1 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #302 - Codeforces",
          "content": "Hello Codeforces!Soon you are lucky to participate in Codeforces Round #302, and I am writer of this contest.I want to thank Max Akhmedov (Zlobober), Alexander Ignatyev (aiMR), Danil Sagunov (danilka.pro) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for marvelous Codeforces and Polygon systems.Scoring will be next: Div1: 500 — 1000 — 1750 — 1750 — 2500 Div2: 500 — 1000 — 1500 — 2000 — 2750 Contest finished, congratulations to winners:Div1: Petr qwerty787788 -XraY- kraskevich Merkurev Div2: nka55 never_retired_phoenix lowsfish Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17755",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 627
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces",
          "content": "544A - Set of StringsIn that task you need to implement what was written in the statements. Let's iterate over all characters of string and keep array used. Also let's keep current string. If current character was not used previously, then let's put current string to the answer and after that we need to clear current string. Otherwise, let's append current character to the current string. If array, that contain answer will have more then k elements, we will concatenate few last strings.The jury solution: 11035685544B - Sea and IslandsIt's clear to understand, that optimal answer will consists of simple cells, for which following condition fullfills: the sum of indices of row and column is even. We will try to put k islands in such way, and if it's impossible, we will report that answer is NO. Try to prove that this solution is optimal.The jury solution: 11035691543A - Writing CodeLet's create the solution, which will work too slow, but after that we will improve it. Let's calculate the following dynamic programming z[i][j][k] — answer to the problem, if we already used exactly i programmers, writed exactly j lines of code, and there are exactly k bugs. How we can do transitions in such dp? We can suppose that we i-th programmer will write r lines of code, then we should add to z[i][j][k] value z[i - 1][j - r][k - ra[i]]But let's look at transitions from the other side. It's clear, that there are exactly 2 cases. The first case, we will give any task for i-th programmer. So, we should add to z[i][j][k] value z[i - 1][j][k]. The second case, is to give at least one task to i-th programmer. So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same idea, which is used to calculate binomial coefficients using Pascal's triangle. So overall solution will have complexity: O(n3)The jury solution: 11035704543B - Destroying RoadsLet's solve easiest task. We have only one pair of vertices, and we need to calculate smallest amout of edges, such that there is a path from first of vertex to the second. It's clear, that the answer for that problem equals to shortest distance from first vertex to the second.Let's come back to initial task. Let's d[i][j] — shortest distance between i and j. You can calculate such matrix using bfs from each vertex. Now we need to handle two cases: Paths doesn't intersects. In such way we can update the answer with the following value: m - d[s0][t0] - d[s1][t1] (just in case wheh conditions on the paths lengths fullfills). Otherwise paths are intersecting, and the correct answer looks like a letter 'H'. More formally, at the start two paths will consists wiht different edges, after that paths will consists with same edges, and will finish with different edges. Let's iterate over pairs (i, j) — the start and the finish vertices of the same part of paths. Then we can update answer with the following value: m - d[s0][i] - d[i][j] - d[j][t0] - d[s1][i] - d[j][t1] (just in case wheh conditions on the paths lengths fullfills). Please note, that we need to swap vertices s0 and t0, and recheck the second case, because in some situations it's better to connect vertex t0 with vertex i and s0 with vertex j. Solutions, which didn't handle that case failed system test on testcase 11. The jury solution: 11035716543C - Remembering StringsFirst that we need to notice, that is amout of strings is smaller then alphabet size. It means, that we can always change some character to another, because at least one character is not used by some string.After that we need handle two cases: We can change exactly one character to another. The cost of such operation equals to a[i][j] (which depends on chosed column) After that we can remember string very easy. We can choose some column, and choose some set of strings, that have same character in that column, By one move we can make all these strings are easy to remember.The cost of such move equals to cost of all characters, except most expensive. As the result, we will have following solution: d[mask] — answer to the problem, when we make all strings from set mask easy to remember. We can calculate this dp in following way: let lowbit — smallest element of set mask. It's clear, that we can do this string easy to remember using first or second move. So we need just iterate over possible columns, and try first or second move (in second move we should choose set that contain string lowbit) Overall complexity is O(m2n), where m — is length of strings. The jury solution: 11035719543D - Road ImprovementLet's suppose i is a root of tree. Let's calculate extra dynamic programming d[i] — answer to the problem for sub-tree with root i We can understand, that d[i] equals to the following value: — where j is a child of the vertex i. It's nice. After that answer to problem for first vertex equal to d[1]. After that let's study how to make child j of current root i as new root of tree. We need to recalculate only two values d[i] and d[j]. First value we can recalculate using following formula d[i]: suf[i][j] * pref[i][j] * d[parent], where parent — is the parent of vertex i, (for vertex 1 d[parent] = 1), and array suf[i][j] — is the product of values d[k], for all childs of vertex i and k < j (pref[i][j] have same definition, but k > j). And after we can calculate d[j] as d[j] * (d[i] + 1). That is all, j is root now, and answer to vertex j equals to current value d[j]The jury solution: 11035737543E - Listening to MusicLet's sort all songs in decreasing order. We will iterate over songs, and each time we will say, that now current song will fully satisfy our conditions. So, let's si = 0, is song i was not processed yet and si = 1 otherwise. Let . It's clear, when we add new song in position idx then we should do  + 1 for all on segment [max(0, idx - m + 1), idx] in our array v. So, when we need to implement some data structure, which can restore our array v to the position when all strings have quality  ≥ q. It also should use very small amout of memory. So, answer to the query will be m - max(vi), lj ≤ i ≤ rj. We will store this data structure in the following way. Let's beat all positions of songs in blocks of length . Each time, when we added about songs as good, we will store three arrays: first array will contain value vi of first element of the block of indices. second array will contain maximum value of v on each block and also we will keep about of ''small'' updates which doesn't cover full block. Using this information array v will be restored and we process current query in easy way.The jury solution: 11035739",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17773",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 544 和字母"
          },
          "content_length": 6605
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #302 - Codeforces - Code 1",
          "code": "I only say I must give up",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 2",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 3",
          "code": "SSS\nSLS\nSSS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 4",
          "code": "The island is the maximal set of sand cells on existing picture",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 5",
          "code": "(meaning that you can add no new cell from the existing picture without",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 6",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 7",
          "code": "factor 1000000006: 2 500000003\nfactor 500000002: 2 41 41 148721\nfactor 148720: 2 2 2 2 5 11 13 13",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 8",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 9",
          "code": "MEM(dp,0);\n    dp[0][0]=1;\n    FOR(i,n){\n        FOR(j,m){\n            for(int k=0;k<=b-a[i];k++) \n                dp[j+1][k+a[i]]= (dp[j+1][k+a[i]]+dp[j][k])%v; //dp[i][j] where i represents the number of lines and j represents the number of bugs.\n        }\n    }\n    ll ans = 0;\n    for(int i=0;i<=b;i++)\n    ans = (ans + dp[m][i])%v;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 10",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 11",
          "code": "min(a(x,i), sum(a(z,i) where s(z,i)==s(x,i))\n+ min(a(y,i), sum(a(z,i) where s(z,i)==s(y,i))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #302 - Codeforces - Code 12",
          "code": "update(f[i][mask | maskSet[i][c]], t + costSet[i][c]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17755",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 1",
          "code": "543A - Writing Code",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 2",
          "code": "fourth line",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 3",
          "code": "z[i][j][k] value z[i - 1][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 4",
          "code": "z[i][j][k] value z[i][j - r][k - ra[i]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 5",
          "code": "The second case, is to give at least one task to i-th programmer.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 6",
          "code": "So, this value will be included in that state: z[i][j - 1][k - a[i]]. In that solution we use same",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 7",
          "code": "idea, which is used to calculate binomial coefficients using Pascal's triangle.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 8",
          "code": "dp[2][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 9",
          "code": "dp[N][N][N]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 10",
          "code": "a = 24; b = 6; p = 3; inv(b) mod p = b ^ (p - 2) mod p = 6 mod 3 = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 11",
          "code": "(a / b) mod p = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 12",
          "code": "(a * inv(b)) mod p = 0 != 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 13",
          "code": "a / (b mod p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 14",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 15",
          "code": "HashSet<Integer> set = m.get(j);\nif(set == null) {\n  set = new HashSet<Integer>();\n  m.put(j, set);\n}\nset.add(count);\n//if(!m.containsKey(j)) m.put(j, new HashSet<Integer>());\n//m.get(j).add(count);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 16",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 17",
          "code": "int sqrt = Math.sqrt(i-1);\nfor(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 18",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #302 - Codeforces - Code 19",
          "code": "//int sqrt = Math.sqrt(i-1);\n//for(long j=2; j<=sqrt; j++) {}\n//for(long j=2; j<=Math.sqrt(i-1); j++) {}\nfor(long j = 2; j * j <= i; j++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17773",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[a-z]{\" + vtos(m) + \"}\", \"s[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n    for (int i = 1; i <= n; ++i) {\n        vector<int> a = inf.readInts(m, 0, 1000000, \"a[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[a-z]{\" + vtos(m) + \"}\", \"s[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n    for (int i = 1; i <= n; ++i) {\n        vector<int> a = inf.readInts(m, 0, 1000000, \"a[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(\"[a-z]{\" + vtos(m) + \"}\", \"s[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n    for (int i = 1; i <= n; ++i) {\n        vector<int> a = inf.readInts(m, 0, 1000000, \"a[\" + vtos(i) + \"]\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> strings(n);\n    vector<vector<int> > costs(n, vector<int>(m));\n\n    if (type == \"identical\") {\n        // All strings are identical\n        string s;\n        for (int i = 0; i < m; ++i) {\n            s += rnd.next('a', 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n        }\n        // Random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"unique\") {\n        // Strings are already easy to remember\n        // For each string, set a unique character at a unique position\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            int pos = i % m;\n            char c = 'a' + i % 26;\n            s[pos] = c;\n            strings[i] = s;\n        }\n        // Random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"maxcost\") {\n        // Random strings, costs are maximum\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = 1000000;\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"zerocost\") {\n        // Random strings, costs are zero\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = 0;\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"random\") {\n        // Random strings and costs\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 1000000);\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"smallcost\") {\n        // Random strings, costs are small\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 10);\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"maxn\") {\n        n = 20;\n        m = 20;\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 1000000);\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"minn\") {\n        n = 1;\n        m = 1;\n        strings[0] = string(1, rnd.next('a', 'z'));\n        costs[0][0] = rnd.next(0, 1000000);\n    } else if (type == \"worstcase\") {\n        // All strings identical, costs maximum\n        string s(m, 'a');\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n            for (int j = 0; j < m; ++j) {\n                costs[i][j] = 1000000;\n            }\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 1000000);\n            }\n            strings[i] = s;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", strings[i].c_str());\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", costs[i][j], (j == m-1 ? '\\n' : ' '));\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> strings(n);\n    vector<vector<int> > costs(n, vector<int>(m));\n\n    if (type == \"identical\") {\n        // All strings are identical\n        string s;\n        for (int i = 0; i < m; ++i) {\n            s += rnd.next('a', 'z');\n        }\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n        }\n        // Random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"unique\") {\n        // Strings are already easy to remember\n        // For each string, set a unique character at a unique position\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            int pos = i % m;\n            char c = 'a' + i % 26;\n            s[pos] = c;\n            strings[i] = s;\n        }\n        // Random costs\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                costs[i][j] = rnd.next(0, 1000000);\n    } else if (type == \"maxcost\") {\n        // Random strings, costs are maximum\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = 1000000;\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"zerocost\") {\n        // Random strings, costs are zero\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = 0;\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"random\") {\n        // Random strings and costs\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 1000000);\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"smallcost\") {\n        // Random strings, costs are small\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 10);\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"maxn\") {\n        n = 20;\n        m = 20;\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 1000000);\n            }\n            strings[i] = s;\n        }\n    } else if (type == \"minn\") {\n        n = 1;\n        m = 1;\n        strings[0] = string(1, rnd.next('a', 'z'));\n        costs[0][0] = rnd.next(0, 1000000);\n    } else if (type == \"worstcase\") {\n        // All strings identical, costs maximum\n        string s(m, 'a');\n        for (int i = 0; i < n; ++i) {\n            strings[i] = s;\n            for (int j = 0; j < m; ++j) {\n                costs[i][j] = 1000000;\n            }\n        }\n    } else {\n        // Default random\n        for (int i = 0; i < n; ++i) {\n            string s(m, 'a');\n            for (int j = 0; j < m; ++j) {\n                s[j] = rnd.next('a', 'z');\n                costs[i][j] = rnd.next(0, 1000000);\n            }\n            strings[i] = s;\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", strings[i].c_str());\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", costs[i][j], (j == m-1 ? '\\n' : ' '));\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type minn\n./gen -n 20 -m 20 -type maxn\n./gen -n 5 -m 5 -type identical\n./gen -n 5 -m 5 -type unique\n./gen -n 5 -m 5 -type random\n\n./gen -n 20 -m 20 -type identical\n./gen -n 20 -m 20 -type unique\n./gen -n 20 -m 20 -type random\n\n./gen -n 10 -m 15 -type maxcost\n./gen -n 10 -m 15 -type zerocost\n\n./gen -n 20 -m 20 -type worstcase\n./gen -n 1 -m 20 -type random\n./gen -n 20 -m 1 -type random\n\n./gen -n 10 -m 10 -type smallcost\n./gen -n 15 -m 15 -type random\n./gen -n 15 -m 15 -type unique\n./gen -n 15 -m 15 -type identical\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type worstcase\n\n./gen -n 20 -m 20 -type smallcost\n./gen -n 5 -m 5 -type zerocost\n./gen -n 5 -m 5 -type maxcost\n\n./gen -n 10 -m 10 -type maxcost\n./gen -n 10 -m 10 -type zerocost\n\n./gen -n 20 -m 5 -type random\n./gen -n 5 -m 20 -type random\n\n./gen -n 2 -m 2 -type random\n./gen -n 19 -m 18 -type random\n./gen -n 18 -m 19 -type random\n\n./gen -n 20 -m 20 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:24.729246",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "545/A",
      "title": "A. Toy Cars",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of cars.Each of the next n lines contains n space-separated integers that determine matrix A. It is guaranteed that on the main diagonal there are  - 1, and  - 1 doesn't appear anywhere else in the matrix.It is guaranteed that the input is correct, that is, if Aij = 1, then Aji = 2, if Aij = 3, then Aji = 3, and if Aij = 0, then Aji = 0.",
      "output_spec": "OutputPrint the number of good cars and in the next line print their space-separated indices in the increasing order.",
      "sample_tests": "ExamplesInputCopy3-1 0 00 -1 10 2 -1OutputCopy21 3 InputCopy4-1 3 3 33 -1 3 33 3 -1 33 3 3 -1OutputCopy0",
      "description": "A. Toy Cars\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of cars.Each of the next n lines contains n space-separated integers that determine matrix A. It is guaranteed that on the main diagonal there are  - 1, and  - 1 doesn't appear anywhere else in the matrix.It is guaranteed that the input is correct, that is, if Aij = 1, then Aji = 2, if Aij = 3, then Aji = 3, and if Aij = 0, then Aji = 0.\n\nOutputPrint the number of good cars and in the next line print their space-separated indices in the increasing order.\n\nInputCopy3-1 0 00 -1 10 2 -1OutputCopy21 3 InputCopy4-1 3 3 33 -1 3 33 3 -1 33 3 3 -1OutputCopy0\n\nInputCopy3-1 0 00 -1 10 2 -1\n\nOutputCopy21 3\n\nInputCopy4-1 3 3 33 -1 3 33 3 -1 33 3 3 -1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces",
          "content": "Hello everyone!I am glad to announce that soon will Codeforces Round #303 for Div.2 paricipants, the author of which I am. Traditionally Div.1 participants can take part out of the competition.This is my first round, and I hope that it will be interesting.Round wouldn't take place without the help of the Codeforces team! Great thanks to Zlobober for helping me preparing the round and Delinur for translation. Special thanks to everyone who puts his effort into the creation and maintenance of Codeforces and Polygon systems.Score distribution will be announce later.Good luck and inspiration!UPD Score distribution will be — 500-1000-1750-1750-2500.UPD Congratulations for winners in Div.2: Bell-sama anko BobDylan Gusheng Diguised imyyimdog And in Div.1: ngfam_kongu Laakeri Um_nik KrK UPD Link for editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17967",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 813
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces",
          "content": "545A - Toy CarsWe can find all information about i-th car collisions in the i-th row of the matrix A. More specific, if there is at least one 1 or 3 at i-th row, then i-th car isn't good (it was turned over in at least one collision). Otherwise, i-th car is good. We just need to check this condition for each car.545B - Equidistant StringOne can see, that if si = ti for some i, then the value of pi isn't important for us. Really, if we make pi equal to si then it also be equal to ti. And if we make pi not equal to si then it also be not equal to ti. So, we have an answer that is closer or further to both of s and t. So we interested about such position i that si ≠ ti. If we make pi equal to si we make p further from t. If we make pi equal to ti we make p further from s. It means that we need to divide these positions into two equal parts to have equidistant string. For example, we can make first of these positions closer to s, second closer to t and so on. If the number of these positions is even, we find an answer, if it is odd, answer doesn't exist. Time complexity — O(n).545C - WoodcuttersOne can solve this problem using dynamic programming or greedy algorithm. Start with DP solution.Define stayi, lefti and righti as maximal count of trees that woodcutters can fell, if only trees with number from 1 to i exist, and i-th tree isn't cutted down, i-th tree is cutted down and fallen left, i-th tree is cutted down and fallen right correspondingly. Now we can compute this values for each i from 1 to n by O(n) time because for each next we need only two previous value. Answer is maximum of stayn, leftn, rightn.Also this problem can be solved by the next greedy algoritm. Let's fell leftmost tree to the left (it always doesn't make an answer worse). After that, try to fell the next tree. If we can fell it to the left, let's do it (because it also always doesn't make an answer worse). If we can't, then try to fell it to the right. If it is possible, let's do it. Last step is correct because felling some tree to the right may only prevent the next tree's fallen. So we may \"exchange\" one tree to another without worsing an answer.Time complexity — O(n).545D - QueueWe can solve this problem by greedy algorithm. Let's prove that it is always possible find an answer (queue with the maximal number of not disappointed people), where all not disappointed people are at the begin of queue. Assume the contrary — there are two position i and j such that i < j, persons at position from i to j - 1 are disappointed, but j-th person isn't. Then just swap persons at positions i and j. After that all persons from i to j - 1 will be still disappointed (or become not disappointed) and j-th person will be still not disappointed. So the answer isn't maked worse.So, we need to find person with minimal ti, that can be served now and will be not disappointed. We can do that by sorting all the people by time ti and try to serve them one by one. If somebody will be disappointed, we may send he to the end of queue, and doesn't add his serve time to the waiting time.Time complexity — O(n + sort).545E - Paths and TreesIt's true, that Dijkstra modification, where in case of equal distances we take one with shorter last edge, find an answer. For prove that let's do some transformation with graph. At first, find all shortest paths from u to other vertices. Define di as the length of shortest path from u to i. After that, we can delete some edges. Specifically, we can delete an edge with ends in x and y and weight w if |dx - dy| ≠ w, because it isn't contained in any shortest path, so it isn't contained in shortest path tree. After that, we can direct all edges from vertices with less distance to vertices with greater distance (because of all weight are positive). It's easy to prove, that if we take one edge that entering each vertex, we have a shortest path tree. Then we only need to take for each vertex minimal egde, that entering this vertex. Why? Because we have to take at least one edge, that entering each vertex to make a graph connected. We can't take edges with less weights than minimal. And if we take minimal edges, that entering each vertex we will have an shortest path tree. So that is minimal possible total wieght of shortest path tree.You can see, that Dijkstra with modification do exactly the same things.Time complexity —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 545\\s*A"
          },
          "content_length": 4373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 1",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 2",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 3",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 4",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 5",
          "code": "1 1 1 1 1 1 1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 1",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 2",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 3",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 4",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 5",
          "code": "TreeSet<Vertex> q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n\n    vector<vector<int>> A(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i) {\n        // Read n integers for row i.\n        for (int j = 0; j < n; ++j) {\n            if (j > 0) inf.readSpace();\n            A[i][j] = inf.readInt(-1, 3);\n            // Check that -1 only occurs on the main diagonal\n            if (A[i][j] == -1) {\n                ensuref(i == j, \"-1 can only appear on the main diagonal, but found at position (%d, %d)\", i+1, j+1);\n            }\n            // Check that the main diagonal elements are -1\n            if (i == j) {\n                ensuref(A[i][j] == -1, \"Main diagonal elements must be -1, but found %d at position (%d, %d)\", A[i][j], i+1, j+1);\n            }\n        }\n        inf.readEoln();\n    }\n\n    // Now check the symmetry properties\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // Skip checking where i == j (diagonal elements)\n            if (i == j) continue;\n            int aij = A[i][j];\n            int aji = A[j][i];\n\n            if (aij == 1) {\n                ensuref(aji == 2, \"A[%d][%d]=1, so A[%d][%d] must be 2, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 2) {\n                ensuref(aji == 1, \"A[%d][%d]=2, so A[%d][%d] must be 1, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 3) {\n                ensuref(aji == 3, \"A[%d][%d]=3, so A[%d][%d] must be 3, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 0) {\n                ensuref(aji == 0, \"A[%d][%d]=0, so A[%d][%d] must be 0, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else {\n                // This should have been caught earlier\n                ensuref(false, \"Invalid value A[%d][%d]=%d\", i+1, j+1, aij);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n\n    vector<vector<int>> A(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i) {\n        // Read n integers for row i.\n        for (int j = 0; j < n; ++j) {\n            if (j > 0) inf.readSpace();\n            A[i][j] = inf.readInt(-1, 3);\n            // Check that -1 only occurs on the main diagonal\n            if (A[i][j] == -1) {\n                ensuref(i == j, \"-1 can only appear on the main diagonal, but found at position (%d, %d)\", i+1, j+1);\n            }\n            // Check that the main diagonal elements are -1\n            if (i == j) {\n                ensuref(A[i][j] == -1, \"Main diagonal elements must be -1, but found %d at position (%d, %d)\", A[i][j], i+1, j+1);\n            }\n        }\n        inf.readEoln();\n    }\n\n    // Now check the symmetry properties\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // Skip checking where i == j (diagonal elements)\n            if (i == j) continue;\n            int aij = A[i][j];\n            int aji = A[j][i];\n\n            if (aij == 1) {\n                ensuref(aji == 2, \"A[%d][%d]=1, so A[%d][%d] must be 2, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 2) {\n                ensuref(aji == 1, \"A[%d][%d]=2, so A[%d][%d] must be 1, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 3) {\n                ensuref(aji == 3, \"A[%d][%d]=3, so A[%d][%d] must be 3, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 0) {\n                ensuref(aji == 0, \"A[%d][%d]=0, so A[%d][%d] must be 0, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else {\n                // This should have been caught earlier\n                ensuref(false, \"Invalid value A[%d][%d]=%d\", i+1, j+1, aij);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100);\n    inf.readEoln();\n\n    vector<vector<int>> A(n, vector<int>(n));\n\n    for (int i = 0; i < n; ++i) {\n        // Read n integers for row i.\n        for (int j = 0; j < n; ++j) {\n            if (j > 0) inf.readSpace();\n            A[i][j] = inf.readInt(-1, 3);\n            // Check that -1 only occurs on the main diagonal\n            if (A[i][j] == -1) {\n                ensuref(i == j, \"-1 can only appear on the main diagonal, but found at position (%d, %d)\", i+1, j+1);\n            }\n            // Check that the main diagonal elements are -1\n            if (i == j) {\n                ensuref(A[i][j] == -1, \"Main diagonal elements must be -1, but found %d at position (%d, %d)\", A[i][j], i+1, j+1);\n            }\n        }\n        inf.readEoln();\n    }\n\n    // Now check the symmetry properties\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // Skip checking where i == j (diagonal elements)\n            if (i == j) continue;\n            int aij = A[i][j];\n            int aji = A[j][i];\n\n            if (aij == 1) {\n                ensuref(aji == 2, \"A[%d][%d]=1, so A[%d][%d] must be 2, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 2) {\n                ensuref(aji == 1, \"A[%d][%d]=2, so A[%d][%d] must be 1, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 3) {\n                ensuref(aji == 3, \"A[%d][%d]=3, so A[%d][%d] must be 3, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else if (aij == 0) {\n                ensuref(aji == 0, \"A[%d][%d]=0, so A[%d][%d] must be 0, but found A[%d][%d]=%d\", i+1, j+1, j+1, i+1, j+1, i+1, aji);\n            } else {\n                // This should have been caught earlier\n                ensuref(false, \"Invalid value A[%d][%d]=%d\", i+1, j+1, aij);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize matrix A\n    vector<vector<int>> A(n, vector<int>(n, -1)); // Initialize to -1\n\n    if (type == \"all_good\") {\n        // All cars are good; all entries off-diagonal are 0\n        for (int i = 0; i < n; ++i) {\n            A[i][i] = -1;\n            for (int j = i + 1; j < n; ++j) {\n                A[i][j] = A[j][i] = 0;\n            }\n        }\n    } else if (type == \"none_good\") {\n        // No cars are good; every car turned over at least once\n        for (int i = 0; i < n; ++i)\n            A[i][i] = -1;\n        for (int i = 0; i < n; ++i) {\n            int j = (i + 1) % n;\n            A[i][j] = 1; // Car i turned over\n            A[j][i] = 2; // Car i turned over\n            for (int k = 0; k < n; ++k) {\n                if (k != i && k != j) {\n                    A[i][k] = A[k][i] = 0; // No car turned over\n                }\n            }\n        }\n    } else if (type == \"some_good\") {\n        int k = opt<int>(\"k\", n / 2); // Number of good cars\n        // First k cars are good\n        for (int i = 0; i < n; ++i)\n            A[i][i] = -1;\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (j == i) continue;\n                A[i][j] = A[j][i] = 0;\n            }\n        }\n        for (int i = k; i < n; ++i) {\n            // Ensure car i turned over at least once\n            int turnedOverAgainst = rnd.next(0, k - 1); // Collide with a good car\n            A[i][turnedOverAgainst] = 1; // Only car i turned over\n            A[turnedOverAgainst][i] = 2; // Only car i turned over\n            for (int j = 0; j < n; ++j) {\n                if (j == i || j == turnedOverAgainst) continue;\n                A[i][j] = A[j][i] = 0; // No car turned over\n            }\n        }\n    } else if (type == \"swap\") {\n        // Test case to check for misinterpretation of 1 and 2\n        if (n < 2) n = 2;\n        A = vector<vector<int>>(n, vector<int>(n, -1));\n        A[0][0] = A[1][1] = -1;\n        A[0][1] = 1; // Only car 0 turned over\n        A[1][0] = 2; // Only car 0 turned over\n        for (int i = 2; i < n; ++i) {\n            A[i][i] = -1;\n            for (int j = 0; j < n; ++j) {\n                if (j == i) continue;\n                A[i][j] = A[j][i] = 0;\n            }\n        }\n    } else { // Random type\n        for (int i = 0; i < n; ++i)\n            A[i][i] = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int outcome = rnd.next(0, 3); // Random outcome between 0 and 3\n                if (outcome == 0) {\n                    A[i][j] = A[j][i] = 0;\n                } else if (outcome == 1) {\n                    A[i][j] = 1;\n                    A[j][i] = 2;\n                } else if (outcome == 2) {\n                    A[i][j] = 2;\n                    A[j][i] = 1;\n                } else if (outcome == 3) {\n                    A[i][j] = A[j][i] = 3;\n                }\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the matrix A\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\n            printf(\"%d%c\", A[i][j], j == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize matrix A\n    vector<vector<int>> A(n, vector<int>(n, -1)); // Initialize to -1\n\n    if (type == \"all_good\") {\n        // All cars are good; all entries off-diagonal are 0\n        for (int i = 0; i < n; ++i) {\n            A[i][i] = -1;\n            for (int j = i + 1; j < n; ++j) {\n                A[i][j] = A[j][i] = 0;\n            }\n        }\n    } else if (type == \"none_good\") {\n        // No cars are good; every car turned over at least once\n        for (int i = 0; i < n; ++i)\n            A[i][i] = -1;\n        for (int i = 0; i < n; ++i) {\n            int j = (i + 1) % n;\n            A[i][j] = 1; // Car i turned over\n            A[j][i] = 2; // Car i turned over\n            for (int k = 0; k < n; ++k) {\n                if (k != i && k != j) {\n                    A[i][k] = A[k][i] = 0; // No car turned over\n                }\n            }\n        }\n    } else if (type == \"some_good\") {\n        int k = opt<int>(\"k\", n / 2); // Number of good cars\n        // First k cars are good\n        for (int i = 0; i < n; ++i)\n            A[i][i] = -1;\n        for (int i = 0; i < k; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (j == i) continue;\n                A[i][j] = A[j][i] = 0;\n            }\n        }\n        for (int i = k; i < n; ++i) {\n            // Ensure car i turned over at least once\n            int turnedOverAgainst = rnd.next(0, k - 1); // Collide with a good car\n            A[i][turnedOverAgainst] = 1; // Only car i turned over\n            A[turnedOverAgainst][i] = 2; // Only car i turned over\n            for (int j = 0; j < n; ++j) {\n                if (j == i || j == turnedOverAgainst) continue;\n                A[i][j] = A[j][i] = 0; // No car turned over\n            }\n        }\n    } else if (type == \"swap\") {\n        // Test case to check for misinterpretation of 1 and 2\n        if (n < 2) n = 2;\n        A = vector<vector<int>>(n, vector<int>(n, -1));\n        A[0][0] = A[1][1] = -1;\n        A[0][1] = 1; // Only car 0 turned over\n        A[1][0] = 2; // Only car 0 turned over\n        for (int i = 2; i < n; ++i) {\n            A[i][i] = -1;\n            for (int j = 0; j < n; ++j) {\n                if (j == i) continue;\n                A[i][j] = A[j][i] = 0;\n            }\n        }\n    } else { // Random type\n        for (int i = 0; i < n; ++i)\n            A[i][i] = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int outcome = rnd.next(0, 3); // Random outcome between 0 and 3\n                if (outcome == 0) {\n                    A[i][j] = A[j][i] = 0;\n                } else if (outcome == 1) {\n                    A[i][j] = 1;\n                    A[j][i] = 2;\n                } else if (outcome == 2) {\n                    A[i][j] = 2;\n                    A[j][i] = 1;\n                } else if (outcome == 3) {\n                    A[i][j] = A[j][i] = 3;\n                }\n            }\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the matrix A\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\n            printf(\"%d%c\", A[i][j], j == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_good\n./gen -n 1 -type none_good\n\n./gen -n 2 -type swap\n\n./gen -n 3 -type all_good\n./gen -n 3 -type none_good\n./gen -n 3 -type some_good -k 1\n\n./gen -n 4 -type random\n./gen -n 4 -type swap\n\n./gen -n 10 -type random\n./gen -n 10 -type all_good\n./gen -n 10 -type none_good\n./gen -n 10 -type some_good -k 5\n\n./gen -n 20 -type some_good -k 1\n./gen -n 20 -type some_good -k 10\n./gen -n 20 -type some_good -k 19\n./gen -n 20 -type random\n\n./gen -n 50 -type random\n./gen -n 50 -type all_good\n./gen -n 50 -type none_good\n./gen -n 50 -type some_good -k 25\n\n./gen -n 99 -type swap\n\n./gen -n 100 -type random\n./gen -n 100 -type all_good\n./gen -n 100 -type none_good\n./gen -n 100 -type some_good -k 1\n./gen -n 100 -type some_good -k 50\n./gen -n 100 -type some_good -k 99\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:26.573142",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "545/B",
      "title": "B. Равноудалённая строка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задана строка s длины n. Во второй строке задана строка t длины n.Длина строки n лежит в пределах от 1 до 105. Гарантируется, что обе строки содержат только нули и единицы.",
      "output_spec": "Выходные данныеВыведите строку длины n, состоящую из нулей и единиц, удовлетворяющую условию задачи. Если такой строки не существует выведите в единственной строке \"impossible\" (без кавычек).Если возможных ответов несколько — выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать00011011Выходные данныеСкопировать0011Входные данныеСкопировать000111Выходные данныеСкопироватьimpossible",
      "description": "B. Равноудалённая строка\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задана строка s длины n. Во второй строке задана строка t длины n.Длина строки n лежит в пределах от 1 до 105. Гарантируется, что обе строки содержат только нули и единицы.\n\nВходные данные\n\nВыходные данныеВыведите строку длины n, состоящую из нулей и единиц, удовлетворяющую условию задачи. Если такой строки не существует выведите в единственной строке \"impossible\" (без кавычек).Если возможных ответов несколько — выведите любой.\n\nВыходные данные\n\nВходные данныеСкопировать00011011Выходные данныеСкопировать0011Входные данныеСкопировать000111Выходные данныеСкопироватьimpossible\n\nВходные данныеСкопировать00011011\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0011\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать000111\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьimpossible\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере возможны разные ответы, а именно — 0010, 0011, 0110, 0111, 1000, 1001, 1100, 1101.",
      "solutions": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces",
          "content": "Всем привет!Рад сообщить, что скоро состоится Codeforces Round #303 для участников Div.2, автором которого являюсь я. Как всегда, участники Div.1 могут поучаствовать вне конкурса.Это мой первый раунд, и я надеюсь, что он будет для Вас интересным.Раунд не состоялся бы без помощи команды Codeforces! Спасибо Zlobober за помощь в подготовке раунда и Delinur за перевод. Отдельное спасибо всем, кто вложил силы в создание и поддержку систем Codeforces и Polygon.Распределение баллов будет объявлено позже.Удачи и вдохновения!UPD Распределение баллов по задачам — 500-1000-1750-1750-2500.UPD Поздравляем победителей в официальном зачёте: Bell-sama anko BobDylan Gusheng Diguised imyyimdog И в неофициальном зачёте: ngfam_kongu Laakeri Um_nik KrK UPD Ссылка на разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17967",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 763
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces",
          "content": "545A - Игрушечные машинкиМожно найти всю информацию о столкновениях i-той машинки в i-той строке матрицы A. А именно, если в i-той строке есть хотя бы одна из цифр 1 или 3, то i-тая машина не является хорошей (она перевернулась при каком-то столкновении). Иначе, i-тая машина — хорошая. Теперь нам просто нужно проверить это условие для каждой машинки.545B - Равноудалённая строкаМожно заметить, что если si = ti для некоторого i, то значение pi для нас не важно. В самом деле, если pi равно si, то оно также равно и ti. И если pi не равно si, то оно также не равно и ti. Так мы получаем ответ, который одновременно ближе или дальше от обоих строк s и t.Тогда нам интересны такие позиции i, что si ≠ ti. Если мы положим pi равным si мы увеличим расстояние от p до t. Если мы положим pi равным ti то мы увеличим расстояние от p до s. Это означает, что нам необходимо разделить эти позиции на две равные по количеству группу, чтобы получить равноудалённую строку. Например, мы можем сделать так, чтобы первая из этих позиций была ближе к s, вторая к t и т.д. Если таких позиций чётное количество, то мы получим ответ, если нечётное, то ответа не существует.Временная сложность — O(n).545C - ДровосекиЗадачу можно решить с помощью динамического программирование или с помощью жадного алгоритма. Начнём с динамики.Обозначим через stayi, lefti and righti наибольшее количество деревьев, которые дровосеки могут повалить, если существует только деревья с номерами с 1 по i, и i-тое дерево не срублено, i-тое дерево срублен и повалено влево, i-тое дерево срублено и повалено вправо соответственно. Теперь мы можем посчитать эти значения для каждого i от 1 до n за O(n) времени, потому что для вычисления каждой следующей величины нам нужно только две предыдущих. Ответом будет наибольшее из stayn, leftn, rightn.Также эту задачу можно было решить жадным алгоритмом. Давайте повалим самое левое дерево влево (это никогда не ухудшает ответ). После этого, попробуем повалить следующее дерево. Если мы можем повалить его влево, сделаем это (потому что это также никогда не ухудшает ответ). Если не можем, тогда пробуем повалить вправо. Если это возможно, делаем это. Последний шаг справедлив, потому что сваливание некоторого дерева вправо может помешать только сваливанию следующего дерева. Так что мы можем \"обменять\" одно дерево на другое, не ухудшив ответа.Временная сложность — O(n).545D - ОчередьМожно решить задачу с помощью жадного алгоритма. Докажем, что всегда можно найти ответ (очередь с наибольшим числом довольных людей), в которой все довольные люди стоят вначале очереди. Предположим противное — существует позиции i и j, такие что i < j, все люди с i-го по j - 1-го недовольны, а j-тый человек доволен. Тогда просто поменяем местами людей на позиции i и j. После этого люди на с i-го по j - 1 будет по-прежнему недовольными (или некоторые станут довольными), а j-тый будет по-прежнему довольным. Таким образом, ответ не ухудшился.Значит, нам нужно находить человека с минимальным ti, который можно обслужить сейчас и он будет доволен. Это можно сделать, отсортировав всех людей по возрастанию ti и пробуя обслуживать их по очереди. Если кто-то будет недоволен, можно отправить его в конец очереди и не добавлять время на его обслуживание к текущему времени ожидания.Временная сложность — — O(n + sort).545E - Пути и деревьяЭто правда, что модификация алгоритма Дейкстры, в которой среди разных расстояний выбирают то, в котором последнее ребро минимально, даёт правильный ответ.Чтобы доказать это, немного модифицируем граф. Для начала найдём кратчайшие пути из u до каждой вершины. Обозначим через di длины кратчайшего пути из u в i. После этого можем удалить некоторые рёбра. Конкретнее, мы можем удалить ребро с концами x и y и весом w если |dx - dy| ≠ w, потому что оно не содержится ни в одном кратчайшем пути, а значит не содержится и в дереве кратчайших путей. После этого можем ориентировать рёбра от вершин с меньшим d в вершину с большим (потому что веса рёбер положительны). Легко доказать, что если взять по одному входящему ребру в каждую вершину, то эти рёбра будут образовывать дерево кратчайших путей. Тогда нам достаточно взять для каждой вершины, входящее в неё ребро минимального веса. Почему? Потому что мы должны взять хотя бы по одному ребру, входящему в каждую вершину, чтобы получить связный граф. Мы не можем взять ребра с меньшим весом, чем минимальное. И если мы возьмем минимальные рёбра мы также получим дерево кратчайших путей. Так что это и есть дерево кратчайших путей с минимальным суммарным весом.Можно заметить, что такая модификация алгоритма Дейкстры выполняет точно такие же действия.Time complexity —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 545\\s*B"
          },
          "content_length": 4645
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 1",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 2",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 3",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 4",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 5",
          "code": "1 1 1 1 1 1 1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 1",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 2",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 3",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 4",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 5",
          "code": "TreeSet<Vertex> q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"^[01]{1,100000}$\", \"s\");\n    string t = inf.readLine(\"^[01]{1,100000}$\", \"t\");\n\n    ensuref(s.length() == t.length(), \"Strings s and t must have equal length\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"^[01]{1,100000}$\", \"s\");\n    string t = inf.readLine(\"^[01]{1,100000}$\", \"t\");\n\n    ensuref(s.length() == t.length(), \"Strings s and t must have equal length\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"^[01]{1,100000}$\", \"s\");\n    string t = inf.readLine(\"^[01]{1,100000}$\", \"t\");\n\n    ensuref(s.length() == t.length(), \"Strings s and t must have equal length\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    string s = inf.readLine();\n    string t = inf.readLine();\n\n    int n = s.length();\n\n    if (t.length() != n)\n        quitf(_fail, \"Input strings have different lengths: |s| = %d, |t| = %d\", n, (int)t.length());\n\n    int k = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] != t[i]) {\n            ++k;\n        }\n    }\n\n    string p_ouf = ouf.readLine();\n\n    if (p_ouf == \"impossible\") {\n        if (k % 2 == 1) {\n            ouf.skipBlanks();\n            if (!ouf.eof())\n                quitf(_wa, \"Extra data in output after 'impossible'\");\n            quitf(_ok, \"Correctly reported impossible.\");\n        } else {\n            quitf(_wa, \"Solution exists, but participant reports 'impossible'.\");\n        }\n    } else {\n        if ((int)p_ouf.length() != n)\n            quitf(_wa, \"Output string length is not equal to n: expected %d, found %d\", n, (int)p_ouf.length());\n\n        for (int i = 0; i < n; ++i) {\n            if (p_ouf[i] != '0' && p_ouf[i] != '1') {\n                quitf(_wa, \"Output string contains invalid character at position %d: '%c'\", i + 1, p_ouf[i]);\n            }\n        }\n\n        int ds = 0, dt = 0;\n        for (int i = 0; i < n; ++i) {\n            if (p_ouf[i] != s[i])\n                ++ds;\n            if (p_ouf[i] != t[i])\n                ++dt;\n        }\n\n        if (ds != dt)\n            quitf(_wa, \"Hamming distances are not equal: D(p, s) = %d, D(p, t) = %d\", ds, dt);\n\n        if (k % 2 == 1)\n            quitf(_wa, \"Participant outputs a solution, but it should be impossible.\");\n\n        ouf.skipBlanks();\n        if (!ouf.eof())\n            quitf(_wa, \"Extra data in output after expected output\");\n\n        quitf(_ok, \"Correct solution, D(p, s) = D(p, t) = %d\", ds);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int n) {\n    string s(n, '0');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('0', '1');\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"possible_random\");\n\n    string s(n, '0');\n    string t(n, '0');\n\n    if (type == \"possible_random\") {\n        int K = 0; // number of positions where s_i != t_i\n\n        for (int i = 0; i < n; ++i) {\n            int d;\n            if (i < n -1) {\n                d = rnd.next(0, 1); // 0: s_i == t_i, 1: s_i != t_i\n            } else {\n                // Last position, adjust to make K even\n                if (K % 2 == 0) {\n                    d = rnd.next(0, 1);\n                } else {\n                    d = 1;\n                }\n            }\n            s[i] = rnd.next('0', '1');\n            if (d == 0) {\n                t[i] = s[i];\n            } else {\n                t[i] = s[i] == '0' ? '1' : '0';\n                K++;\n            }\n        }\n    } else if (type == \"impossible_random\") {\n        int K = 0; // number of positions where s_i != t_i\n\n        for (int i = 0; i < n; ++i) {\n            int d;\n            if (i < n -1) {\n                d = rnd.next(0, 1); // 0: s_i == t_i, 1: s_i != t_i\n            } else {\n                // Last position, adjust to make K odd\n                if (K % 2 == 0) {\n                    d = 1;\n                } else {\n                    d = rnd.next(0, 1);\n                }\n            }\n            s[i] = rnd.next('0', '1');\n            if (d == 0) {\n                t[i] = s[i];\n            } else {\n                t[i] = s[i] == '0' ? '1' : '0';\n                K++;\n            }\n        }\n    } else if (type == \"all_same\") {\n        // s == t\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"zeros_ones_even\") {\n        if (n % 2 != 0) {\n            // Cannot generate K even in this type\n            ensuref(false, \"n must be even for zeros_ones_even\");\n        }\n        s = string(n, '0');\n        t = string(n, '1');\n    } else if (type == \"zeros_ones_odd\") {\n        if (n % 2 != 1) {\n            // Cannot generate K odd in this type\n            ensuref(false, \"n must be odd for zeros_ones_odd\");\n        }\n        s = string(n, '0');\n        t = string(n, '1');\n    } else if (type == \"k_equals_zero\") {\n        // s == t\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"k_equals_n\") {\n        // s_i != t_i for all i\n        s = generate_random_string(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = s[i] == '0' ? '1' : '0';\n        }\n    } else if (type == \"alternating_even\") {\n        // K is even\n        if (n % 2 != 0) {\n            ensuref(false, \"n must be even for alternating_even\");\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = '0';\n                t[i] = '1';\n            } else {\n                s[i] = '1';\n                t[i] = '0';\n            }\n        }\n    } else if (type == \"alternating_odd\") {\n        // K is odd\n        if (n % 2 != 1) {\n            ensuref(false, \"n must be odd for alternating_odd\");\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = '0';\n                t[i] = '1';\n            } else {\n                s[i] = '1';\n                t[i] = '0';\n            }\n        }\n    } else {\n        // Default case, possible_random\n        int K = 0; // number of positions where s_i != t_i\n\n        for (int i = 0; i < n; ++i) {\n            int d;\n            if (i < n -1) {\n                d = rnd.next(0, 1); // 0: s_i == t_i, 1: s_i != t_i\n            } else {\n                // Last position, adjust to make K even\n                if (K % 2 == 0) {\n                    d = rnd.next(0, 1);\n                } else {\n                    d = 1;\n                }\n            }\n            s[i] = rnd.next('0', '1');\n            if (d == 0) {\n                t[i] = s[i];\n            } else {\n                t[i] = s[i] == '0' ? '1' : '0';\n                K++;\n            }\n        }\n    }\n\n    // Output s and t\n    printf(\"%s\\n%s\\n\", s.c_str(), t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring generate_random_string(int n) {\n    string s(n, '0');\n    for (int i = 0; i < n; ++i) {\n        s[i] = rnd.next('0', '1');\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"possible_random\");\n\n    string s(n, '0');\n    string t(n, '0');\n\n    if (type == \"possible_random\") {\n        int K = 0; // number of positions where s_i != t_i\n\n        for (int i = 0; i < n; ++i) {\n            int d;\n            if (i < n -1) {\n                d = rnd.next(0, 1); // 0: s_i == t_i, 1: s_i != t_i\n            } else {\n                // Last position, adjust to make K even\n                if (K % 2 == 0) {\n                    d = rnd.next(0, 1);\n                } else {\n                    d = 1;\n                }\n            }\n            s[i] = rnd.next('0', '1');\n            if (d == 0) {\n                t[i] = s[i];\n            } else {\n                t[i] = s[i] == '0' ? '1' : '0';\n                K++;\n            }\n        }\n    } else if (type == \"impossible_random\") {\n        int K = 0; // number of positions where s_i != t_i\n\n        for (int i = 0; i < n; ++i) {\n            int d;\n            if (i < n -1) {\n                d = rnd.next(0, 1); // 0: s_i == t_i, 1: s_i != t_i\n            } else {\n                // Last position, adjust to make K odd\n                if (K % 2 == 0) {\n                    d = 1;\n                } else {\n                    d = rnd.next(0, 1);\n                }\n            }\n            s[i] = rnd.next('0', '1');\n            if (d == 0) {\n                t[i] = s[i];\n            } else {\n                t[i] = s[i] == '0' ? '1' : '0';\n                K++;\n            }\n        }\n    } else if (type == \"all_same\") {\n        // s == t\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"zeros_ones_even\") {\n        if (n % 2 != 0) {\n            // Cannot generate K even in this type\n            ensuref(false, \"n must be even for zeros_ones_even\");\n        }\n        s = string(n, '0');\n        t = string(n, '1');\n    } else if (type == \"zeros_ones_odd\") {\n        if (n % 2 != 1) {\n            // Cannot generate K odd in this type\n            ensuref(false, \"n must be odd for zeros_ones_odd\");\n        }\n        s = string(n, '0');\n        t = string(n, '1');\n    } else if (type == \"k_equals_zero\") {\n        // s == t\n        s = generate_random_string(n);\n        t = s;\n    } else if (type == \"k_equals_n\") {\n        // s_i != t_i for all i\n        s = generate_random_string(n);\n        for (int i = 0; i < n; ++i) {\n            t[i] = s[i] == '0' ? '1' : '0';\n        }\n    } else if (type == \"alternating_even\") {\n        // K is even\n        if (n % 2 != 0) {\n            ensuref(false, \"n must be even for alternating_even\");\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = '0';\n                t[i] = '1';\n            } else {\n                s[i] = '1';\n                t[i] = '0';\n            }\n        }\n    } else if (type == \"alternating_odd\") {\n        // K is odd\n        if (n % 2 != 1) {\n            ensuref(false, \"n must be odd for alternating_odd\");\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = '0';\n                t[i] = '1';\n            } else {\n                s[i] = '1';\n                t[i] = '0';\n            }\n        }\n    } else {\n        // Default case, possible_random\n        int K = 0; // number of positions where s_i != t_i\n\n        for (int i = 0; i < n; ++i) {\n            int d;\n            if (i < n -1) {\n                d = rnd.next(0, 1); // 0: s_i == t_i, 1: s_i != t_i\n            } else {\n                // Last position, adjust to make K even\n                if (K % 2 == 0) {\n                    d = rnd.next(0, 1);\n                } else {\n                    d = 1;\n                }\n            }\n            s[i] = rnd.next('0', '1');\n            if (d == 0) {\n                t[i] = s[i];\n            } else {\n                t[i] = s[i] == '0' ? '1' : '0';\n                K++;\n            }\n        }\n    }\n\n    // Output s and t\n    printf(\"%s\\n%s\\n\", s.c_str(), t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type k_equals_n\n./gen -n 1 -type possible_random\n./gen -n 1 -type impossible_random\n\n./gen -n 2 -type all_same\n./gen -n 2 -type k_equals_n\n./gen -n 2 -type possible_random\n./gen -n 2 -type impossible_random\n./gen -n 2 -type zeros_ones_even\n\n./gen -n 3 -type all_same\n./gen -n 3 -type k_equals_n\n./gen -n 3 -type possible_random\n./gen -n 3 -type impossible_random\n./gen -n 3 -type zeros_ones_odd\n\n./gen -n 10 -type possible_random\n./gen -n 10 -type impossible_random\n./gen -n 10 -type all_same\n./gen -n 10 -type k_equals_n\n./gen -n 10 -type alternating_even\n\n./gen -n 15 -type possible_random\n./gen -n 15 -type impossible_random\n./gen -n 15 -type k_equals_n\n./gen -n 15 -type alternating_odd\n\n./gen -n 100000 -type possible_random\n./gen -n 100000 -type impossible_random\n./gen -n 100000 -type all_same\n./gen -n 100000 -type k_equals_n\n./gen -n 100000 -type zeros_ones_even\n./gen -n 99999 -type zeros_ones_odd\n\n./gen -n 100000 -type alternating_even\n./gen -n 99999 -type alternating_odd\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:28.621216",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "545/C",
      "title": "C. Woodcutters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of trees.Next n lines contain pairs of integers xi, hi (1 ≤ xi, hi ≤ 109) — the coordinate and the height of the і-th tree.The pairs are given in the order of ascending xi. No two trees are located at the point with the same coordinate.",
      "output_spec": "OutputPrint a single number — the maximum number of trees that you can cut down by the given rules.",
      "sample_tests": "ExamplesInputCopy51 22 15 1010 919 1OutputCopy3InputCopy51 22 15 1010 920 1OutputCopy4",
      "description": "C. Woodcutters\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of trees.Next n lines contain pairs of integers xi, hi (1 ≤ xi, hi ≤ 109) — the coordinate and the height of the і-th tree.The pairs are given in the order of ascending xi. No two trees are located at the point with the same coordinate.\n\nOutputPrint a single number — the maximum number of trees that you can cut down by the given rules.\n\nInputCopy51 22 15 1010 919 1OutputCopy3InputCopy51 22 15 1010 920 1OutputCopy4\n\nInputCopy51 22 15 1010 919 1\n\nOutputCopy3\n\nInputCopy51 22 15 1010 920 1\n\nOutputCopy4\n\nNoteIn the first sample you can fell the trees like that:   fell the 1-st tree to the left — now it occupies segment [ - 1;1]  fell the 2-nd tree to the right — now it occupies segment [2;3]  leave the 3-rd tree — it occupies point 5  leave the 4-th tree — it occupies point 10  fell the 5-th tree to the right — now it occupies segment [19;20] In the second sample you can also fell 4-th tree to the right, after that it will occupy segment [10;19].",
      "solutions": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces",
          "content": "Hello everyone!I am glad to announce that soon will Codeforces Round #303 for Div.2 paricipants, the author of which I am. Traditionally Div.1 participants can take part out of the competition.This is my first round, and I hope that it will be interesting.Round wouldn't take place without the help of the Codeforces team! Great thanks to Zlobober for helping me preparing the round and Delinur for translation. Special thanks to everyone who puts his effort into the creation and maintenance of Codeforces and Polygon systems.Score distribution will be announce later.Good luck and inspiration!UPD Score distribution will be — 500-1000-1750-1750-2500.UPD Congratulations for winners in Div.2: Bell-sama anko BobDylan Gusheng Diguised imyyimdog And in Div.1: ngfam_kongu Laakeri Um_nik KrK UPD Link for editorial.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17967",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 813
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces",
          "content": "545A - Toy CarsWe can find all information about i-th car collisions in the i-th row of the matrix A. More specific, if there is at least one 1 or 3 at i-th row, then i-th car isn't good (it was turned over in at least one collision). Otherwise, i-th car is good. We just need to check this condition for each car.545B - Equidistant StringOne can see, that if si = ti for some i, then the value of pi isn't important for us. Really, if we make pi equal to si then it also be equal to ti. And if we make pi not equal to si then it also be not equal to ti. So, we have an answer that is closer or further to both of s and t. So we interested about such position i that si ≠ ti. If we make pi equal to si we make p further from t. If we make pi equal to ti we make p further from s. It means that we need to divide these positions into two equal parts to have equidistant string. For example, we can make first of these positions closer to s, second closer to t and so on. If the number of these positions is even, we find an answer, if it is odd, answer doesn't exist. Time complexity — O(n).545C - WoodcuttersOne can solve this problem using dynamic programming or greedy algorithm. Start with DP solution.Define stayi, lefti and righti as maximal count of trees that woodcutters can fell, if only trees with number from 1 to i exist, and i-th tree isn't cutted down, i-th tree is cutted down and fallen left, i-th tree is cutted down and fallen right correspondingly. Now we can compute this values for each i from 1 to n by O(n) time because for each next we need only two previous value. Answer is maximum of stayn, leftn, rightn.Also this problem can be solved by the next greedy algoritm. Let's fell leftmost tree to the left (it always doesn't make an answer worse). After that, try to fell the next tree. If we can fell it to the left, let's do it (because it also always doesn't make an answer worse). If we can't, then try to fell it to the right. If it is possible, let's do it. Last step is correct because felling some tree to the right may only prevent the next tree's fallen. So we may \"exchange\" one tree to another without worsing an answer.Time complexity — O(n).545D - QueueWe can solve this problem by greedy algorithm. Let's prove that it is always possible find an answer (queue with the maximal number of not disappointed people), where all not disappointed people are at the begin of queue. Assume the contrary — there are two position i and j such that i < j, persons at position from i to j - 1 are disappointed, but j-th person isn't. Then just swap persons at positions i and j. After that all persons from i to j - 1 will be still disappointed (or become not disappointed) and j-th person will be still not disappointed. So the answer isn't maked worse.So, we need to find person with minimal ti, that can be served now and will be not disappointed. We can do that by sorting all the people by time ti and try to serve them one by one. If somebody will be disappointed, we may send he to the end of queue, and doesn't add his serve time to the waiting time.Time complexity — O(n + sort).545E - Paths and TreesIt's true, that Dijkstra modification, where in case of equal distances we take one with shorter last edge, find an answer. For prove that let's do some transformation with graph. At first, find all shortest paths from u to other vertices. Define di as the length of shortest path from u to i. After that, we can delete some edges. Specifically, we can delete an edge with ends in x and y and weight w if |dx - dy| ≠ w, because it isn't contained in any shortest path, so it isn't contained in shortest path tree. After that, we can direct all edges from vertices with less distance to vertices with greater distance (because of all weight are positive). It's easy to prove, that if we take one edge that entering each vertex, we have a shortest path tree. Then we only need to take for each vertex minimal egde, that entering this vertex. Why? Because we have to take at least one edge, that entering each vertex to make a graph connected. We can't take edges with less weights than minimal. And if we take minimal edges, that entering each vertex we will have an shortest path tree. So that is minimal possible total wieght of shortest path tree.You can see, that Dijkstra with modification do exactly the same things.Time complexity —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 545\\s*C"
          },
          "content_length": 4373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 1",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 2",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 3",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 4",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 5",
          "code": "1 1 1 1 1 1 1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 1",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 2",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 3",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 4",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 5",
          "code": "TreeSet<Vertex> q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int last_x = -1;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000000000, \"x_i\");\n        inf.readSpace();\n        int h = inf.readInt(1, 1000000000, \"h_i\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(x > last_x, \"Coordinates x_i must be in strictly increasing order.\");\n        }\n        last_x = x;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int last_x = -1;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000000000, \"x_i\");\n        inf.readSpace();\n        int h = inf.readInt(1, 1000000000, \"h_i\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(x > last_x, \"Coordinates x_i must be in strictly increasing order.\");\n        }\n        last_x = x;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int last_x = -1;\n    for (int i = 0; i < n; i++) {\n        int x = inf.readInt(1, 1000000000, \"x_i\");\n        inf.readSpace();\n        int h = inf.readInt(1, 1000000000, \"h_i\");\n        inf.readEoln();\n\n        if (i > 0) {\n            ensuref(x > last_x, \"Coordinates x_i must be in strictly increasing order.\");\n        }\n        last_x = x;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_x = opt<int>(\"max_x\", 1000000000);\n    int max_h = opt<int>(\"max_h\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n);\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = rnd.next(1, max_h);\n        }\n    } else if (type == \"max_heights\") {\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = max_h; \n        }\n    } else if (type == \"min_heights\") {\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = 1;\n        }\n    } else if (type == \"can_all_fell_left\") {\n        x[0] = 1;\n        h[0] = rnd.next(1, min(max_h, max_x - n * 10));\n        for (int i = 1; i < n; ++i) {\n            int gap = rnd.next(1, 10);\n            x[i] = x[i - 1] + h[i -1] + gap;\n            if (x[i] > max_x) {\n                x.resize(i);\n                h.resize(i);\n                n = i;\n                break;\n            }\n            h[i] = rnd.next(1, min(max_h, max_x - x[i]));\n        }\n    } else if (type == \"can_all_fell_right\") {\n        x[n -1] = max_x;\n        h[n -1] = rnd.next(1, min(max_h, max_x - n * 10));\n        for (int i = n - 2; i >= 0; --i) {\n            int gap = rnd.next(1, 10);\n            x[i] = x[i +1] - h[i +1] - gap;\n            if (x[i] < 1) {\n                x.erase(x.begin(), x.begin() + i + 1);\n                h.erase(h.begin(), h.begin() + i + 1);\n                n = x.size();\n                break;\n            }\n            h[i] = rnd.next(1, min(max_h, x[i] - 1));\n        }\n    } else if (type == \"close_trees\") {\n        x[0] = 1;\n        h[0] = rnd.next(1, max_h);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + 1;\n            h[i] = rnd.next(1, max_h);\n        }\n    } else if (type == \"spread_trees\") {\n        int gap = max_x / n;\n        x[0] = rnd.next(1, gap);\n        h[0] = rnd.next(1, max_h);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + gap;\n            h[i] = rnd.next(1, max_h);\n        }\n    } else if (type == \"alternating_close_far\") {\n        x[0] = 1;\n        h[0] = rnd.next(1, max_h);\n        bool close = true;\n        for (int i = 1; i < n; ++i) {\n            if (close) {\n                x[i] = x[i - 1] + 1;\n            } else {\n                x[i] = x[i - 1] + rnd.next(1e5, 1e6);\n                if (x[i] > max_x) {\n                    x.resize(i);\n                    h.resize(i);\n                    n = i;\n                    break;\n                }\n            }\n            h[i] = rnd.next(1, max_h);\n            close = !close;\n        }\n    } else {\n        // Default: random\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = rnd.next(1, max_h);\n        }\n    }\n\n    // Ensure x and h vectors are of size n\n    n = x.size();\n\n    // Sort x and rearrange h accordingly\n    vector<pair<int, int>> trees(n);\n    for (int i = 0; i < n; ++i) {\n        trees[i] = {x[i], h[i]};\n    }\n    sort(trees.begin(), trees.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", trees[i].first, trees[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int max_x = opt<int>(\"max_x\", 1000000000);\n    int max_h = opt<int>(\"max_h\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n);\n    vector<int> h(n);\n\n    if (type == \"random\") {\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = rnd.next(1, max_h);\n        }\n    } else if (type == \"max_heights\") {\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = max_h; \n        }\n    } else if (type == \"min_heights\") {\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = 1;\n        }\n    } else if (type == \"can_all_fell_left\") {\n        x[0] = 1;\n        h[0] = rnd.next(1, min(max_h, max_x - n * 10));\n        for (int i = 1; i < n; ++i) {\n            int gap = rnd.next(1, 10);\n            x[i] = x[i - 1] + h[i -1] + gap;\n            if (x[i] > max_x) {\n                x.resize(i);\n                h.resize(i);\n                n = i;\n                break;\n            }\n            h[i] = rnd.next(1, min(max_h, max_x - x[i]));\n        }\n    } else if (type == \"can_all_fell_right\") {\n        x[n -1] = max_x;\n        h[n -1] = rnd.next(1, min(max_h, max_x - n * 10));\n        for (int i = n - 2; i >= 0; --i) {\n            int gap = rnd.next(1, 10);\n            x[i] = x[i +1] - h[i +1] - gap;\n            if (x[i] < 1) {\n                x.erase(x.begin(), x.begin() + i + 1);\n                h.erase(h.begin(), h.begin() + i + 1);\n                n = x.size();\n                break;\n            }\n            h[i] = rnd.next(1, min(max_h, x[i] - 1));\n        }\n    } else if (type == \"close_trees\") {\n        x[0] = 1;\n        h[0] = rnd.next(1, max_h);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + 1;\n            h[i] = rnd.next(1, max_h);\n        }\n    } else if (type == \"spread_trees\") {\n        int gap = max_x / n;\n        x[0] = rnd.next(1, gap);\n        h[0] = rnd.next(1, max_h);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + gap;\n            h[i] = rnd.next(1, max_h);\n        }\n    } else if (type == \"alternating_close_far\") {\n        x[0] = 1;\n        h[0] = rnd.next(1, max_h);\n        bool close = true;\n        for (int i = 1; i < n; ++i) {\n            if (close) {\n                x[i] = x[i - 1] + 1;\n            } else {\n                x[i] = x[i - 1] + rnd.next(1e5, 1e6);\n                if (x[i] > max_x) {\n                    x.resize(i);\n                    h.resize(i);\n                    n = i;\n                    break;\n                }\n            }\n            h[i] = rnd.next(1, max_h);\n            close = !close;\n        }\n    } else {\n        // Default: random\n        set<int> xs;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(1, max_x);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            x[i] = xi;\n            h[i] = rnd.next(1, max_h);\n        }\n    }\n\n    // Ensure x and h vectors are of size n\n    n = x.size();\n\n    // Sort x and rearrange h accordingly\n    vector<pair<int, int>> trees(n);\n    for (int i = 0; i < n; ++i) {\n        trees[i] = {x[i], h[i]};\n    }\n    sort(trees.begin(), trees.end());\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", trees[i].first, trees[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 1 -type min_n\n./gen -n 1 -type random\n./gen -n 1 -type max_heights\n./gen -n 1 -type min_heights\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n\n./gen -n 100000 -type random\n\n./gen -n 100000 -type max_heights\n./gen -n 100000 -type min_heights\n\n./gen -n 100000 -type can_all_fell_left\n./gen -n 100000 -type can_all_fell_right\n\n./gen -n 1000 -type close_trees\n./gen -n 100000 -type close_trees\n\n./gen -n 1000 -type spread_trees\n./gen -n 100000 -type spread_trees\n\n./gen -n 1000 -type alternating_close_far\n./gen -n 100000 -type alternating_close_far\n\n# Edge cases\n./gen -n 100000 -type max_heights -max_h 1000000000\n./gen -n 100000 -type min_heights -max_h 1\n\n# Special case, heights are always 1\n./gen -n 100000 -type random -max_h 1\n\n# Special case, heights are maximal\n./gen -n 100000 -type random -max_h 1000000000\n\n# All trees have same height\n./gen -n 100000 -type random -max_h 500000000\n\n# Trees with various heights\n./gen -n 100000 -type random -max_h 1000\n\n# Largest possible n with special types\n./gen -n 100000 -type can_all_fell_left -max_h 1\n./gen -n 100000 -type can_all_fell_right -max_h 1\n\n# Minimal N\n./gen -n 1 -type min_n\n\n# Random small test cases\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 20 -type random\n\n# Max n, random test cases\n./gen -n 100000 -type random -max_x 1000000000 -max_h 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:31.042426",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "545/D",
      "title": "D. Очередь",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится целое число n (1 ≤ n ≤ 105).В следующей строке находятся n целых чисел ti (1 ≤ ti ≤ 109), разделенных пробелами.",
      "output_spec": "Выходные данныеВведите единственное число — максимальное количество довольных людей в очереди.",
      "sample_tests": "ПримерыВходные данныеСкопировать515 2 1 5 3Выходные данныеСкопировать4",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находится целое число n (1 ≤ n ≤ 105).В следующей строке находятся n целых чисел ti (1 ≤ ti ≤ 109), разделенных пробелами.\n\nВходные данные\n\nВыходные данныеВведите единственное число — максимальное количество довольных людей в очереди.\n\nВыходные данные\n\nВходные данныеСкопировать515 2 1 5 3Выходные данныеСкопировать4\n\nВходные данныеСкопировать515 2 1 5 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЗначение 4 достигается, например, при такой расстановке: 1, 2, 3, 5, 15. Таким образом можно сделать всех, кроме человека с временем 5, довольными.",
      "solutions": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces",
          "content": "Всем привет!Рад сообщить, что скоро состоится Codeforces Round #303 для участников Div.2, автором которого являюсь я. Как всегда, участники Div.1 могут поучаствовать вне конкурса.Это мой первый раунд, и я надеюсь, что он будет для Вас интересным.Раунд не состоялся бы без помощи команды Codeforces! Спасибо Zlobober за помощь в подготовке раунда и Delinur за перевод. Отдельное спасибо всем, кто вложил силы в создание и поддержку систем Codeforces и Polygon.Распределение баллов будет объявлено позже.Удачи и вдохновения!UPD Распределение баллов по задачам — 500-1000-1750-1750-2500.UPD Поздравляем победителей в официальном зачёте: Bell-sama anko BobDylan Gusheng Diguised imyyimdog И в неофициальном зачёте: ngfam_kongu Laakeri Um_nik KrK UPD Ссылка на разбор.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17967",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 763
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces",
          "content": "545A - Игрушечные машинкиМожно найти всю информацию о столкновениях i-той машинки в i-той строке матрицы A. А именно, если в i-той строке есть хотя бы одна из цифр 1 или 3, то i-тая машина не является хорошей (она перевернулась при каком-то столкновении). Иначе, i-тая машина — хорошая. Теперь нам просто нужно проверить это условие для каждой машинки.545B - Равноудалённая строкаМожно заметить, что если si = ti для некоторого i, то значение pi для нас не важно. В самом деле, если pi равно si, то оно также равно и ti. И если pi не равно si, то оно также не равно и ti. Так мы получаем ответ, который одновременно ближе или дальше от обоих строк s и t.Тогда нам интересны такие позиции i, что si ≠ ti. Если мы положим pi равным si мы увеличим расстояние от p до t. Если мы положим pi равным ti то мы увеличим расстояние от p до s. Это означает, что нам необходимо разделить эти позиции на две равные по количеству группу, чтобы получить равноудалённую строку. Например, мы можем сделать так, чтобы первая из этих позиций была ближе к s, вторая к t и т.д. Если таких позиций чётное количество, то мы получим ответ, если нечётное, то ответа не существует.Временная сложность — O(n).545C - ДровосекиЗадачу можно решить с помощью динамического программирование или с помощью жадного алгоритма. Начнём с динамики.Обозначим через stayi, lefti and righti наибольшее количество деревьев, которые дровосеки могут повалить, если существует только деревья с номерами с 1 по i, и i-тое дерево не срублено, i-тое дерево срублен и повалено влево, i-тое дерево срублено и повалено вправо соответственно. Теперь мы можем посчитать эти значения для каждого i от 1 до n за O(n) времени, потому что для вычисления каждой следующей величины нам нужно только две предыдущих. Ответом будет наибольшее из stayn, leftn, rightn.Также эту задачу можно было решить жадным алгоритмом. Давайте повалим самое левое дерево влево (это никогда не ухудшает ответ). После этого, попробуем повалить следующее дерево. Если мы можем повалить его влево, сделаем это (потому что это также никогда не ухудшает ответ). Если не можем, тогда пробуем повалить вправо. Если это возможно, делаем это. Последний шаг справедлив, потому что сваливание некоторого дерева вправо может помешать только сваливанию следующего дерева. Так что мы можем \"обменять\" одно дерево на другое, не ухудшив ответа.Временная сложность — O(n).545D - ОчередьМожно решить задачу с помощью жадного алгоритма. Докажем, что всегда можно найти ответ (очередь с наибольшим числом довольных людей), в которой все довольные люди стоят вначале очереди. Предположим противное — существует позиции i и j, такие что i < j, все люди с i-го по j - 1-го недовольны, а j-тый человек доволен. Тогда просто поменяем местами людей на позиции i и j. После этого люди на с i-го по j - 1 будет по-прежнему недовольными (или некоторые станут довольными), а j-тый будет по-прежнему довольным. Таким образом, ответ не ухудшился.Значит, нам нужно находить человека с минимальным ti, который можно обслужить сейчас и он будет доволен. Это можно сделать, отсортировав всех людей по возрастанию ti и пробуя обслуживать их по очереди. Если кто-то будет недоволен, можно отправить его в конец очереди и не добавлять время на его обслуживание к текущему времени ожидания.Временная сложность — — O(n + sort).545E - Пути и деревьяЭто правда, что модификация алгоритма Дейкстры, в которой среди разных расстояний выбирают то, в котором последнее ребро минимально, даёт правильный ответ.Чтобы доказать это, немного модифицируем граф. Для начала найдём кратчайшие пути из u до каждой вершины. Обозначим через di длины кратчайшего пути из u в i. После этого можем удалить некоторые рёбра. Конкретнее, мы можем удалить ребро с концами x и y и весом w если |dx - dy| ≠ w, потому что оно не содержится ни в одном кратчайшем пути, а значит не содержится и в дереве кратчайших путей. После этого можем ориентировать рёбра от вершин с меньшим d в вершину с большим (потому что веса рёбер положительны). Легко доказать, что если взять по одному входящему ребру в каждую вершину, то эти рёбра будут образовывать дерево кратчайших путей. Тогда нам достаточно взять для каждой вершины, входящее в неё ребро минимального веса. Почему? Потому что мы должны взять хотя бы по одному ребру, входящему в каждую вершину, чтобы получить связный граф. Мы не можем взять ребра с меньшим весом, чем минимальное. И если мы возьмем минимальные рёбра мы также получим дерево кратчайших путей. Так что это и есть дерево кратчайших путей с минимальным суммарным весом.Можно заметить, что такая модификация алгоритма Дейкстры выполняет точно такие же действия.Time complexity —",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 545\\s*D"
          },
          "content_length": 4645
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 1",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 2",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 3",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 4",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 5",
          "code": "1 1 1 1 1 1 1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 1",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 2",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 3",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 4",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #303 (Div.2) разбор - Codeforces - Code 5",
          "code": "TreeSet<Vertex> q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> t(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    } else if (type == \"sorted\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        sort(t.begin(), t.end());\n    } else if (type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        sort(t.begin(), t.end());\n        reverse(t.begin(), t.end());\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            t[i] = val;\n    } else if (type == \"max_ti\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = 1000000000;\n    } else if (type == \"min_ti\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = 1;\n    } else if (type == \"alternating\") {\n        int small = 1;\n        int large = 1000000000;\n        for (int i = 0; i < n; ++i)\n            t[i] = (i % 2 == 0) ? small : large;\n    } else if (type == \"overflows\") {\n        t[0] = 1000000000;\n        long long sum = t[0];\n        for (int i = 1; i < n; ++i) {\n            t[i] = min(1000000000LL, sum + 1);\n            sum += t[i];\n        }\n    } else if (type == \"single_large\") {\n        for (int i = 0; i < n - 1; ++i)\n            t[i] = 1;\n        t[n - 1] = 1000000000;\n    } else if (type == \"small_n\") {\n        n = min(n, 10);\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 10);\n    } else {\n        // Default random data\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> t(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    } else if (type == \"sorted\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        sort(t.begin(), t.end());\n    } else if (type == \"reversed\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n        sort(t.begin(), t.end());\n        reverse(t.begin(), t.end());\n    } else if (type == \"equal\") {\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i)\n            t[i] = val;\n    } else if (type == \"max_ti\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = 1000000000;\n    } else if (type == \"min_ti\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = 1;\n    } else if (type == \"alternating\") {\n        int small = 1;\n        int large = 1000000000;\n        for (int i = 0; i < n; ++i)\n            t[i] = (i % 2 == 0) ? small : large;\n    } else if (type == \"overflows\") {\n        t[0] = 1000000000;\n        long long sum = t[0];\n        for (int i = 1; i < n; ++i) {\n            t[i] = min(1000000000LL, sum + 1);\n            sum += t[i];\n        }\n    } else if (type == \"single_large\") {\n        for (int i = 0; i < n - 1; ++i)\n            t[i] = 1;\n        t[n - 1] = 1000000000;\n    } else if (type == \"small_n\") {\n        n = min(n, 10);\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 10);\n    } else {\n        // Default random data\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(1, 1000000000);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_ti\n./gen -n 1 -type max_ti\n./gen -n 2 -type min_ti\n./gen -n 2 -type max_ti\n./gen -n 5 -type equal\n./gen -n 5 -type small_n\n\n./gen -n 10 -type random\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type overflows\n./gen -n 100 -type single_large\n\n./gen -n 1000 -type random\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reversed\n./gen -n 1000 -type equal\n\n./gen -n 10000 -type random\n./gen -n 10000 -type overflows\n./gen -n 10000 -type single_large\n\n./gen -n 100000 -type random\n./gen -n 100000 -type sorted\n./gen -n 100000 -type reversed\n./gen -n 100000 -type equal\n\n./gen -n 100000 -type alternating\n./gen -n 100000 -type min_ti\n./gen -n 100000 -type max_ti\n\n./gen -n 100000 -type overflows\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:33.371470",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "545/E",
      "title": "E. Paths and Trees",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers, n and m (1 ≤ n ≤ 3·105, 0 ≤ m ≤ 3·105) — the number of vertices and edges of the graph, respectively.Next m lines contain three integers each, representing an edge — ui, vi, wi — the numbers of vertices connected by an edge and the weight of the edge (ui ≠ vi, 1 ≤ wi ≤ 109). It is guaranteed that graph is connected and that there is no more than one edge between any pair of vertices.The last line of the input contains integer u (1 ≤ u ≤ n) — the number of the start vertex.",
      "output_spec": "OutputIn the first line print the minimum total weight of the edges of the tree.In the next line print the indices of the edges that are included in the tree, separated by spaces. The edges are numbered starting from 1 in the order they follow in the input. You may print the numbers of the edges in any order.If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy3 31 2 12 3 11 3 23OutputCopy21 2 InputCopy4 41 2 12 3 13 4 14 1 24OutputCopy42 3 4",
      "description": "E. Paths and Trees\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers, n and m (1 ≤ n ≤ 3·105, 0 ≤ m ≤ 3·105) — the number of vertices and edges of the graph, respectively.Next m lines contain three integers each, representing an edge — ui, vi, wi — the numbers of vertices connected by an edge and the weight of the edge (ui ≠ vi, 1 ≤ wi ≤ 109). It is guaranteed that graph is connected and that there is no more than one edge between any pair of vertices.The last line of the input contains integer u (1 ≤ u ≤ n) — the number of the start vertex.\n\nOutputIn the first line print the minimum total weight of the edges of the tree.In the next line print the indices of the edges that are included in the tree, separated by spaces. The edges are numbered starting from 1 in the order they follow in the input. You may print the numbers of the edges in any order.If there are multiple answers, print any of them.\n\nInputCopy3 31 2 12 3 11 3 23OutputCopy21 2 InputCopy4 41 2 12 3 13 4 14 1 24OutputCopy42 3 4\n\nInputCopy3 31 2 12 3 11 3 23\n\nOutputCopy21 2\n\nInputCopy4 41 2 12 3 13 4 14 1 24\n\nOutputCopy42 3 4\n\nNoteIn the first sample there are two possible shortest path trees:  with edges 1 – 3 and 2 – 3 (the total weight is 3);  with edges 1 – 2 and 2 – 3 (the total weight is 2); And, for example, a tree with edges 1 – 2 and 1 – 3 won't be a shortest path tree for vertex 3, because the distance from vertex 3 to vertex 2 in this tree equals 3, and in the original graph it is 1.",
      "solutions": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces",
          "content": "Hello everyone!I am glad to announce that soon will Codeforces Round #303 for Div.2 paricipants, the author of which I am. Traditionally Div.1 participants can take part out of the competition.This is my first round, and I hope that it will be interesting.Round wouldn't take place without the help of the Codeforces team! Great thanks to Zlobober for helping me preparing the round and Delinur for translation. Special thanks to everyone who puts his effort into the creation and maintenance of Codeforces and Polygon systems.Score distribution will be announce later.Good luck and inspiration!UPD Score distribution will be — 500-1000-1750-1750-2500.UPD Congratulations for winners in Div.2: Bell-sama anko BobDylan Gusheng Diguised imyyimdog And in Div.1: ngfam_kongu Laakeri Um_nik KrK UPD Link for editorial.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17967",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 813
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces",
          "content": "545A - Toy CarsWe can find all information about i-th car collisions in the i-th row of the matrix A. More specific, if there is at least one 1 or 3 at i-th row, then i-th car isn't good (it was turned over in at least one collision). Otherwise, i-th car is good. We just need to check this condition for each car.545B - Equidistant StringOne can see, that if si = ti for some i, then the value of pi isn't important for us. Really, if we make pi equal to si then it also be equal to ti. And if we make pi not equal to si then it also be not equal to ti. So, we have an answer that is closer or further to both of s and t. So we interested about such position i that si ≠ ti. If we make pi equal to si we make p further from t. If we make pi equal to ti we make p further from s. It means that we need to divide these positions into two equal parts to have equidistant string. For example, we can make first of these positions closer to s, second closer to t and so on. If the number of these positions is even, we find an answer, if it is odd, answer doesn't exist. Time complexity — O(n).545C - WoodcuttersOne can solve this problem using dynamic programming or greedy algorithm. Start with DP solution.Define stayi, lefti and righti as maximal count of trees that woodcutters can fell, if only trees with number from 1 to i exist, and i-th tree isn't cutted down, i-th tree is cutted down and fallen left, i-th tree is cutted down and fallen right correspondingly. Now we can compute this values for each i from 1 to n by O(n) time because for each next we need only two previous value. Answer is maximum of stayn, leftn, rightn.Also this problem can be solved by the next greedy algoritm. Let's fell leftmost tree to the left (it always doesn't make an answer worse). After that, try to fell the next tree. If we can fell it to the left, let's do it (because it also always doesn't make an answer worse). If we can't, then try to fell it to the right. If it is possible, let's do it. Last step is correct because felling some tree to the right may only prevent the next tree's fallen. So we may \"exchange\" one tree to another without worsing an answer.Time complexity — O(n).545D - QueueWe can solve this problem by greedy algorithm. Let's prove that it is always possible find an answer (queue with the maximal number of not disappointed people), where all not disappointed people are at the begin of queue. Assume the contrary — there are two position i and j such that i < j, persons at position from i to j - 1 are disappointed, but j-th person isn't. Then just swap persons at positions i and j. After that all persons from i to j - 1 will be still disappointed (or become not disappointed) and j-th person will be still not disappointed. So the answer isn't maked worse.So, we need to find person with minimal ti, that can be served now and will be not disappointed. We can do that by sorting all the people by time ti and try to serve them one by one. If somebody will be disappointed, we may send he to the end of queue, and doesn't add his serve time to the waiting time.Time complexity — O(n + sort).545E - Paths and TreesIt's true, that Dijkstra modification, where in case of equal distances we take one with shorter last edge, find an answer. For prove that let's do some transformation with graph. At first, find all shortest paths from u to other vertices. Define di as the length of shortest path from u to i. After that, we can delete some edges. Specifically, we can delete an edge with ends in x and y and weight w if |dx - dy| ≠ w, because it isn't contained in any shortest path, so it isn't contained in shortest path tree. After that, we can direct all edges from vertices with less distance to vertices with greater distance (because of all weight are positive). It's easy to prove, that if we take one edge that entering each vertex, we have a shortest path tree. Then we only need to take for each vertex minimal egde, that entering this vertex. Why? Because we have to take at least one edge, that entering each vertex to make a graph connected. We can't take edges with less weights than minimal. And if we take minimal edges, that entering each vertex we will have an shortest path tree. So that is minimal possible total wieght of shortest path tree.You can see, that Dijkstra with modification do exactly the same things.Time complexity —",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17982",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 545\\s*E"
          },
          "content_length": 4373
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 1",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 2",
          "code": "its wrong, so you cannot prove it :D\nUPD: I wasn't fast enough",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 3",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 4",
          "code": "i used this method.\nconsider the spanning-tree (shortest path ST) with minimum weights.\ndelete a leaf from it then it can be prove that the remaining spanning tree is still with minimum weight.\nso remove all nodes then add them one by one, in which you add you shout set it parent the node with minimum edge weight.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) - Codeforces - Code 5",
          "code": "1 1 1 1 1 1 1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17967",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 1",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 2",
          "code": "// if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 3",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 4",
          "code": "if (dist == o.dist) return Integer.compare(v, o.v);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #303 (Div.2) editorial - Codeforces - Code 5",
          "code": "TreeSet<Vertex> q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17982",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n    \n    if (m == 0) {\n        ensuref(n == 1, \"When m is 0, n must be 1 to be connected, but n = %d\", n);\n    }\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n    \n    set<pair<int, int>> edges;\n    \n    for (int i = 0; i < m; ++i) {\n        string uName = \"u[\" + to_string(i + 1) + \"]\";\n        string vName = \"v[\" + to_string(i + 1) + \"]\";\n        string wName = \"w[\" + to_string(i + 1) + \"]\";\n        int u = inf.readInt(1, n, uName);\n        inf.readSpace();\n        int v = inf.readInt(1, n, vName);\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, wName);\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d connects vertex %d to itself\", i + 1, u);\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between vertices %d and %d\", a, b);\n        edges.insert(edge);\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) parent[pu] = pv;\n    }\n    \n    // Check connectedness\n    int components = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) == i) components++;\n    }\n    ensuref(components == 1, \"Graph is not connected, has %d components\", components);\n    \n    int u0 = inf.readInt(1, n, \"u\");\n    inf.readEoln();\n    inf.readEof();\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n    \n    if (m == 0) {\n        ensuref(n == 1, \"When m is 0, n must be 1 to be connected, but n = %d\", n);\n    }\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n    \n    set<pair<int, int>> edges;\n    \n    for (int i = 0; i < m; ++i) {\n        string uName = \"u[\" + to_string(i + 1) + \"]\";\n        string vName = \"v[\" + to_string(i + 1) + \"]\";\n        string wName = \"w[\" + to_string(i + 1) + \"]\";\n        int u = inf.readInt(1, n, uName);\n        inf.readSpace();\n        int v = inf.readInt(1, n, vName);\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, wName);\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d connects vertex %d to itself\", i + 1, u);\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between vertices %d and %d\", a, b);\n        edges.insert(edge);\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) parent[pu] = pv;\n    }\n    \n    // Check connectedness\n    int components = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) == i) components++;\n    }\n    ensuref(components == 1, \"Graph is not connected, has %d components\", components);\n    \n    int u0 = inf.readInt(1, n, \"u\");\n    inf.readEoln();\n    inf.readEof();\n    \n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n    \n    if (m == 0) {\n        ensuref(n == 1, \"When m is 0, n must be 1 to be connected, but n = %d\", n);\n    }\n    \n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n    \n    set<pair<int, int>> edges;\n    \n    for (int i = 0; i < m; ++i) {\n        string uName = \"u[\" + to_string(i + 1) + \"]\";\n        string vName = \"v[\" + to_string(i + 1) + \"]\";\n        string wName = \"w[\" + to_string(i + 1) + \"]\";\n        int u = inf.readInt(1, n, uName);\n        inf.readSpace();\n        int v = inf.readInt(1, n, vName);\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, wName);\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d connects vertex %d to itself\", i + 1, u);\n        int a = min(u, v);\n        int b = max(u, v);\n        pair<int, int> edge = make_pair(a, b);\n        ensuref(edges.count(edge) == 0, \"Multiple edges between vertices %d and %d\", a, b);\n        edges.insert(edge);\n        int pu = find(u);\n        int pv = find(v);\n        if (pu != pv) parent[pu] = pv;\n    }\n    \n    // Check connectedness\n    int components = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (find(i) == i) components++;\n    }\n    ensuref(components == 1, \"Graph is not connected, has %d components\", components);\n    \n    int u0 = inf.readInt(1, n, \"u\");\n    inf.readEoln();\n    inf.readEof();\n    \n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long INF = 1e18;\n\nint n, m, u;\nvector<vector<pair<int, int>>> adj; // adjacency list: adj[v] = list of (neighbor, weight)\nvector<tuple<int, int, int>> edges; // edges[i] = (u, v, w)\nvector<long long> dist; // dist[v]: minimal distance from u to v in original graph\nvector<int> parent; // parent[v]: previous vertex in the minimal path\nvector<int> edge_id; // edge_id[v]: edge index used to reach v\n\nvoid compute_original_distances() {\n    dist.assign(n + 1, INF);\n    parent.assign(n + 1, -1);\n    edge_id.assign(n + 1, -1);\n    dist[u] = 0;\n    // priority_queue of (distance, vertex)\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\n    pq.push({0, u});\n    while (!pq.empty()) {\n        auto [d, v] = pq.top();\n        pq.pop();\n        if (d > dist[v]) continue;\n        for (auto [to, idx] : adj[v]) {\n            int w = get<2>(edges[idx]);\n            if (dist[to] > dist[v] + w) {\n                dist[to] = dist[v] + w;\n                parent[to] = v;\n                edge_id[to] = idx;\n                pq.push({dist[to], to});\n            } else if (dist[to] == dist[v] + w) {\n                // Equal distance, prefer minimal edge weight\n                int current_edge_w = get<2>(edges[edge_id[to]]);\n                if (w < current_edge_w) {\n                    parent[to] = v;\n                    edge_id[to] = idx;\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    n = inf.readInt();\n    m = inf.readInt();\n    adj.resize(n + 1);\n    edges.resize(m + 1); // edges[1..m]\n    for (int idx = 1; idx <= m; idx++) {\n        int a = inf.readInt();\n        int b = inf.readInt();\n        int w = inf.readInt();\n        edges[idx] = {a, b, w};\n        adj[a].push_back({b, idx});\n        adj[b].push_back({a, idx});\n    }\n    u = inf.readInt();\n\n    // Compute original distances and minimal total weight\n    compute_original_distances();\n\n    // Compute minimal total weight\n    long long ansTotalWeight = 0;\n    for (int v = 1; v <= n; v++) {\n        if (v != u && parent[v] != -1) {\n            ansTotalWeight += get<2>(edges[edge_id[v]]);\n        }\n    }\n\n    // Read participant's output\n    long long pansTotalWeight = ouf.readLong();\n    vector<int> p_edge_indices;\n    p_edge_indices = ouf.readInts(n - 1, 1, m, \"edge indices\");\n\n    // Build participant's tree\n    vector<int> p_u(n), p_v(n), p_w(n);\n    vector<vector<pair<int, int>>> p_adj(n + 1);\n    set<int> used_edges;\n    for (int idx : p_edge_indices) {\n        if (used_edges.count(idx)) {\n            quitf(_wa, \"Edge %d is used more than once\", idx);\n        }\n        used_edges.insert(idx);\n        int a = get<0>(edges[idx]);\n        int b = get<1>(edges[idx]);\n        int w = get<2>(edges[idx]);\n        p_adj[a].push_back({b, w});\n        p_adj[b].push_back({a, w});\n    }\n\n    // Check that the participant's edges form a tree\n    vector<int> dsu(n + 1);\n    iota(dsu.begin(), dsu.end(), 0);\n    function<int(int)> find = [&](int v) {\n        return dsu[v] == v ? v : dsu[v] = find(dsu[v]);\n    };\n    for (int idx : p_edge_indices) {\n        int a = get<0>(edges[idx]);\n        int b = get<1>(edges[idx]);\n        if (find(a) == find(b)) {\n            quitf(_wa, \"Cycle detected in participant's tree\");\n        }\n        dsu[find(a)] = find(b);\n    }\n    // Check connectedness\n    int root = find(u);\n    for (int v = 1; v <= n; v++) {\n        if (find(v) != root) {\n            quitf(_wa, \"Participant's tree is not connected\");\n        }\n    }\n\n    // Compute participant's total weight and verify\n    long long participant_weight = 0;\n    for (int idx : p_edge_indices) {\n        participant_weight += get<2>(edges[idx]);\n    }\n    if (participant_weight != pansTotalWeight) {\n        quitf(_wa, \"Participant's total weight does not match the sum of edge weights\");\n    }\n\n    // Verify that participant's distances match original distances\n    vector<long long> p_dist(n + 1, INF);\n    p_dist[u] = 0;\n    queue<int> q;\n    q.push(u);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (auto [to, w] : p_adj[v]) {\n            if (p_dist[to] > p_dist[v] + w) {\n                p_dist[to] = p_dist[v] + w;\n                q.push(to);\n            }\n        }\n    }\n    for (int v = 1; v <= n; v++) {\n        if (p_dist[v] != dist[v]) {\n            quitf(_wa, \"Distances from u to vertex %d do not match\", v);\n        }\n    }\n\n    if (participant_weight > ansTotalWeight)\n        quitf(_wa, \"Participant's total weight is greater than minimal total weight\");\n    else if (participant_weight == ansTotalWeight)\n        quitf(_ok, \"Correct, total weight = %lld\", participant_weight);\n    else\n        quitf(_fail, \"Participant's total weight %lld is less than minimal total weight %lld\", participant_weight, ansTotalWeight);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string weight = opt<string>(\"weight\", \"random\");\n    int uSource = opt<int>(\"u\", -1);\n    if (uSource == -1) uSource = rnd.next(1, n);\n\n    vector<pair<int,int>> edges;\n    set<pair<int,int>> edgeSet;\n\n    // Ensure that m is at least n - 1 and at most 3e5\n    if (m < n - 1) {\n        cerr << \"Error: m must be at least n - 1 to form a connected graph.\\n\";\n        exit(1);\n    }\n    if (m > 3e5) {\n        cerr << \"Error: m must be at most 300000.\\n\";\n        exit(1);\n    }\n    if (n > 3e5) {\n        cerr << \"Error: n must be at most 300000.\\n\";\n        exit(1);\n    }\n\n    // Generate the initial tree\n    if (type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i+1);\n            edgeSet.insert({min(i, i+1), max(i, i+1)});\n        }\n    }\n    else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.emplace_back(1, i);\n            edgeSet.insert({1, i});\n        }\n    }\n    else if (type == \"random\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.emplace_back(u, v);\n            edgeSet.insert({min(u, v), max(u, v)});\n        }\n    }\n    else if (type == \"complete\") {\n        long long max_edges = 1LL * n * (n -1) /2;\n        if (m > max_edges) {\n            cerr << \"Error: m cannot be greater than n*(n-1)/2 for a complete graph.\\n\";\n            exit(1);\n        }\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u +1; v <= n; ++v) {\n                edges.emplace_back(u, v);\n                edgeSet.insert({u, v});\n                if ((int)edges.size() == m) break;\n            }\n            if ((int)edges.size() == m) break;\n        }\n    }\n    else {\n        cerr << \"Error: unknown type '\" << type << \"'.\\n\";\n        exit(1);\n    }\n\n    // Add extra edges if needed\n    int extraEdges = m - ((int)edges.size());\n    while (extraEdges > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        if (u > v) swap(u, v);\n        if (edgeSet.count({u, v})) continue;\n        edges.emplace_back(u, v);\n        edgeSet.insert({u, v});\n        --extraEdges;\n    }\n\n    // Generate weights\n    vector<int> weights(edges.size());\n\n    if (weight == \"equal\") {\n        int w = rnd.next(1, 1000000000);\n        fill(weights.begin(), weights.end(), w);\n    }\n    else if (weight == \"heavy\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(500000000, 1000000000);\n        }\n    }\n    else if (weight == \"light\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(1, 10);\n        }\n    }\n    else if (weight == \"big_range\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            if (rnd.next(0, 1)) {\n                weights[i] = rnd.next(1, 10);\n            } else {\n                weights[i] = rnd.next(500000000, 1000000000);\n            }\n        }\n    }\n    else { // random weights\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Update uSource\n    uSource = perm[uSource];\n\n    // Update edges with permuted node labels\n    vector<tuple<int, int, int>> edge_list(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = perm[edges[i].first];\n        int v = perm[edges[i].second];\n        int w = weights[i];\n        edge_list[i] = make_tuple(u, v, w);\n    }\n\n    // Shuffle edges\n    shuffle(edge_list.begin(), edge_list.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (size_t i = 0; i < edge_list.size(); ++i) {\n        int u = get<0>(edge_list[i]);\n        int v = get<1>(edge_list[i]);\n        int w = get<2>(edge_list[i]);\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n    printf(\"%d\\n\", uSource);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string weight = opt<string>(\"weight\", \"random\");\n    int uSource = opt<int>(\"u\", -1);\n    if (uSource == -1) uSource = rnd.next(1, n);\n\n    vector<pair<int,int>> edges;\n    set<pair<int,int>> edgeSet;\n\n    // Ensure that m is at least n - 1 and at most 3e5\n    if (m < n - 1) {\n        cerr << \"Error: m must be at least n - 1 to form a connected graph.\\n\";\n        exit(1);\n    }\n    if (m > 3e5) {\n        cerr << \"Error: m must be at most 300000.\\n\";\n        exit(1);\n    }\n    if (n > 3e5) {\n        cerr << \"Error: n must be at most 300000.\\n\";\n        exit(1);\n    }\n\n    // Generate the initial tree\n    if (type == \"chain\") {\n        for (int i = 1; i < n; ++i) {\n            edges.emplace_back(i, i+1);\n            edgeSet.insert({min(i, i+1), max(i, i+1)});\n        }\n    }\n    else if (type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.emplace_back(1, i);\n            edgeSet.insert({1, i});\n        }\n    }\n    else if (type == \"random\") {\n        // Generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.emplace_back(u, v);\n            edgeSet.insert({min(u, v), max(u, v)});\n        }\n    }\n    else if (type == \"complete\") {\n        long long max_edges = 1LL * n * (n -1) /2;\n        if (m > max_edges) {\n            cerr << \"Error: m cannot be greater than n*(n-1)/2 for a complete graph.\\n\";\n            exit(1);\n        }\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u +1; v <= n; ++v) {\n                edges.emplace_back(u, v);\n                edgeSet.insert({u, v});\n                if ((int)edges.size() == m) break;\n            }\n            if ((int)edges.size() == m) break;\n        }\n    }\n    else {\n        cerr << \"Error: unknown type '\" << type << \"'.\\n\";\n        exit(1);\n    }\n\n    // Add extra edges if needed\n    int extraEdges = m - ((int)edges.size());\n    while (extraEdges > 0) {\n        int u = rnd.next(1, n);\n        int v = rnd.next(1, n);\n        if (u == v) continue;\n        if (u > v) swap(u, v);\n        if (edgeSet.count({u, v})) continue;\n        edges.emplace_back(u, v);\n        edgeSet.insert({u, v});\n        --extraEdges;\n    }\n\n    // Generate weights\n    vector<int> weights(edges.size());\n\n    if (weight == \"equal\") {\n        int w = rnd.next(1, 1000000000);\n        fill(weights.begin(), weights.end(), w);\n    }\n    else if (weight == \"heavy\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(500000000, 1000000000);\n        }\n    }\n    else if (weight == \"light\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(1, 10);\n        }\n    }\n    else if (weight == \"big_range\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            if (rnd.next(0, 1)) {\n                weights[i] = rnd.next(1, 10);\n            } else {\n                weights[i] = rnd.next(500000000, 1000000000);\n            }\n        }\n    }\n    else { // random weights\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i)\n        perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Update uSource\n    uSource = perm[uSource];\n\n    // Update edges with permuted node labels\n    vector<tuple<int, int, int>> edge_list(edges.size());\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = perm[edges[i].first];\n        int v = perm[edges[i].second];\n        int w = weights[i];\n        edge_list[i] = make_tuple(u, v, w);\n    }\n\n    // Shuffle edges\n    shuffle(edge_list.begin(), edge_list.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (size_t i = 0; i < edge_list.size(); ++i) {\n        int u = get<0>(edge_list[i]);\n        int v = get<1>(edge_list[i]);\n        int w = get<2>(edge_list[i]);\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n    printf(\"%d\\n\", uSource);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type random -weight random\n./gen -n 2 -m 1 -type random -weight random\n\n./gen -n 5 -m 4 -type chain -weight random\n./gen -n 1000 -m 999 -type chain -weight random\n./gen -n 100000 -m 99999 -type chain -weight random\n\n./gen -n 5 -m 4 -type star -weight random\n./gen -n 1000 -m 999 -type star -weight random\n./gen -n 100000 -m 99999 -type star -weight random\n\n./gen -n 100 -m 99 -type random -weight random\n./gen -n 1000 -m 999 -type random -weight random\n./gen -n 100000 -m 99999 -type random -weight random\n\n./gen -n 1000 -m 2000 -type random -weight heavy\n./gen -n 1000 -m 2000 -type random -weight light\n./gen -n 1000 -m 2000 -type random -weight equal\n./gen -n 1000 -m 2000 -type random -weight big_range\n\n./gen -n 775 -m 299175 -type complete -weight random\n\n./gen -n 100000 -m 200000 -type random -weight random\n./gen -n 100000 -m 300000 -type random -weight random\n./gen -n 300000 -m 299999 -type random -weight random\n\n./gen -n 100000 -m 200000 -type random -weight big_range\n./gen -n 1000 -m 2000 -type random -weight big_range\n\n./gen -n 5000 -m 10000 -type random -weight equal\n./gen -n 5000 -m 10000 -type random -weight heavy\n./gen -n 5000 -m 10000 -type random -weight light\n\n./gen -n 100000 -m 300000 -type random -weight light\n./gen -n 100000 -m 300000 -type random -weight heavy\n\n./gen -n 300000 -m 300000 -type random -weight random\n\n./gen -n 100000 -m 150000 -type star -weight random\n./gen -n 100000 -m 200000 -type chain -weight random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:35.617196",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "546/A",
      "title": "A. Солдат и бананы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три положительных целых числа k, n, w (1  ≤  k, w  ≤  1000, 0 ≤ n ≤ 109), стоимость первого банана, изначальное количество долларов у солдата и количество бананов, которые он хочет купить.",
      "output_spec": "Выходные данныеВыведите единственное целое число — количество долларов, которое солдату надо одолжить у однополчанина. Если деньги одалживать не надо, выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 17 4Выходные данныеСкопировать13",
      "description": "A. Солдат и бананы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано три положительных целых числа k, n, w (1  ≤  k, w  ≤  1000, 0 ≤ n ≤ 109), стоимость первого банана, изначальное количество долларов у солдата и количество бананов, которые он хочет купить.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — количество долларов, которое солдату надо одолжить у однополчанина. Если деньги одалживать не надо, выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать3 17 4Выходные данныеСкопировать13\n\nВходные данныеСкопировать3 17 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces",
          "content": "Hi everyone!I am pleased to announce that Codeforces Round #304 (Div.2), of which I am the author, will take place today. This will be my first round, so I hope that it will be cool and interesting. Traditionally Div.1 participants can take part out of the competition.I want to thank znirzej, Dakurels and Zlobober for help with preparing the problems, thank Delinur for translating the problems, and thank to MikeMirzayanov and all who created polygon for this great system.I wish you all good luck!UPD Scoring will be 500-1000-1250-1500-2250.UPD editorialUPD Congratulations for winners in div.2: phoenix__jpn Hujishiro_otone lzw4896s jinzhao jabbawookiees And in div.1: ngfam_kongu uwi anta W4yneb0t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces",
          "content": "A. Soldier and BananasWe can easily calculate the sum of money that we need to buy all the bananas that we want, let's name it x.If n >  = x the answer is 0, because we don't need to borrow anything.Otherwise the answer is x - n.B. Soldier and BadgesLet's count the number of badges with coolness factor 1, 2 and so on. Then, let's look at the number of badges with value equal to 1. If it's greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n - 2 (because maximum value of badge which we can achieve is 2n - 1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.C. Soldier and CardsIt's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?Firstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n + 1 places (because we can count the before and after deck case too).So war has (n + 1)! states. If we'd do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.After checking this game more accurately I can say that the longest path in the state-graph for n = 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.Alternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast.D. Soldier and Number GameFirstly we have to note, that second soldier should choose only prime numbers. If he choose a composite number x that is equal to p * q, he can choose first p, then q and get better score. So our task is to find a number of prime factors in factorization of n.Now we have to note that factorization of number a! / b! is this same as factorization of numbers (b + 1)*(b + 2)*...*(a - 1)*a.Let's count number of prime factor in factorization of every number from 2 to 5000000.First, we use Sieve of Eratosthenes to find a prime diviser of each of these numbers. Then we can calculate a number of prime factors in factorization of a using the formula:primefactors[a] = primefactors[a / primediviser[a]] + 1When we know all these numbers, we can use a prefix sums, and then answer for sum on interval.E. Soldier and TravelingThere are few ways to solve this task, but I'll describe the simplest (in my opinion) one.Let's build a flow network in following way:Make a source.Make a first group of vertices consisting of n vertices, each of them for one city.Connect a source with ith vertex in first group with edge that has capacity ai.Make a sink and second group of vertices in the same way, but use bi except for ai.If there is a road between cities i and j or i = j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.Then find a maxflow, in any complexity.If maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.I told about many solutions, because every solution, which doesn't use greedy strategy, can undo it's previous pushes, and does it in reasonable complexity should pass.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3740
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 1",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 2",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 3",
          "code": "if(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 4",
          "code": "while(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 5",
          "code": "#define nline printf(\"\\n\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 6",
          "code": "cout<<ans<<\"\\n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 7",
          "code": "printf(\"%d\\n\", ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 9",
          "code": "#define stack queue",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 2",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 3",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 4",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 5",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 6",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 7",
          "code": "System.out.println(f[a]-f[b])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 8",
          "code": "StringBuilder",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 9",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 10",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 1000000000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 1000000000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 1000000000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k_max = opt<int>(\"k_max\", 1000);\n    int w_max = opt<int>(\"w_max\", 1000);\n    long long n_max = opt<long long>(\"n_max\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k, w;\n    long long n;\n\n    if (type == \"min_values\") {\n        /* Minimal values for k and w, n = 0 */\n        k = 1;\n        w = 1;\n        n = 0;\n    } else if (type == \"max_values\") {\n        /* Maximal values for k, w, n */\n        k = 1000;\n        w = 1000;\n        n = 1000000000;\n    } else if (type == \"no_borrow_needed\") {\n        /* Generate k, w such that total cost ≤ n */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        n = rnd.next(total_cost, n_max);\n    } else if (type == \"exact_money\") {\n        /* Generate k, w such that total cost == n */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        n = total_cost;\n    } else if (type == \"borrow_needed\") {\n        /* Generate k, w such that total cost > n */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        if (total_cost == 0) total_cost = 1; // Should not happen as k, w ≥ 1\n        n = rnd.next(0LL, total_cost - 1);\n    } else if (type == \"overflow_test\") {\n        /* Generate values that may cause integer overflow in naive solutions */\n        k = k_max;\n        w = w_max;\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        n = rnd.next(0LL, total_cost - 1);\n    } else { // random\n        /* Random valid values */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        n = rnd.next(0LL, n_max);\n    }\n\n    printf(\"%d %lld %d\\n\", k, n, w);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k_max = opt<int>(\"k_max\", 1000);\n    int w_max = opt<int>(\"w_max\", 1000);\n    long long n_max = opt<long long>(\"n_max\", 1000000000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int k, w;\n    long long n;\n\n    if (type == \"min_values\") {\n        /* Minimal values for k and w, n = 0 */\n        k = 1;\n        w = 1;\n        n = 0;\n    } else if (type == \"max_values\") {\n        /* Maximal values for k, w, n */\n        k = 1000;\n        w = 1000;\n        n = 1000000000;\n    } else if (type == \"no_borrow_needed\") {\n        /* Generate k, w such that total cost ≤ n */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        n = rnd.next(total_cost, n_max);\n    } else if (type == \"exact_money\") {\n        /* Generate k, w such that total cost == n */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        n = total_cost;\n    } else if (type == \"borrow_needed\") {\n        /* Generate k, w such that total cost > n */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        if (total_cost == 0) total_cost = 1; // Should not happen as k, w ≥ 1\n        n = rnd.next(0LL, total_cost - 1);\n    } else if (type == \"overflow_test\") {\n        /* Generate values that may cause integer overflow in naive solutions */\n        k = k_max;\n        w = w_max;\n        long long total_cost = (long long)k * w * (w + 1) / 2;\n        n = rnd.next(0LL, total_cost - 1);\n    } else { // random\n        /* Random valid values */\n        k = rnd.next(1, k_max);\n        w = rnd.next(1, w_max);\n        n = rnd.next(0LL, n_max);\n    }\n\n    printf(\"%d %lld %d\\n\", k, n, w);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with default parameters\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Random test cases with maximum k and w\n./gen -type random -k_max 1000 -w_max 1000 -n_max 1000000000\n./gen -type random -k_max 1000 -w_max 1000 -n_max 1000000000\n./gen -type random -k_max 1000 -w_max 1000 -n_max 1000000000\n\n# Minimal values test case\n./gen -type min_values\n\n# Maximal values test case\n./gen -type max_values\n\n# No borrow needed (soldier has enough money)\n./gen -type no_borrow_needed\n./gen -type no_borrow_needed\n\n# Exact money (soldier has exactly enough money)\n./gen -type exact_money\n./gen -type exact_money\n\n# Borrow needed (soldier needs to borrow money)\n./gen -type borrow_needed\n./gen -type borrow_needed\n./gen -type borrow_needed\n\n# Overflow test cases\n./gen -type overflow_test\n./gen -type overflow_test\n\n# Edge case: n = 0 (soldier has no money)\n./gen -type random -n_max 0\n\n# Edge case: n = total cost - 1 (just short of the needed amount)\n./gen -type borrow_needed -k_max 1000 -w_max 1000\n\n# Edge case: n = total cost + 1 (soldier has extra money)\n./gen -type no_borrow_needed -n_max 1000000000\n\n# Random test cases with small k and w\n./gen -type random -k_max 10 -w_max 10\n./gen -type random -k_max 10 -w_max 10\n\n# Random test cases with large n\n./gen -type random -n_max 1000000000\n./gen -type random -n_max 1000000000\n\n# Random test cases with small n\n./gen -type random -n_max 100\n./gen -type random -n_max 100\n\n# Random test cases with varied parameters\n./gen -type random -k_max 500 -w_max 500 -n_max 500000000\n./gen -type random -k_max 1000 -w_max 1 -n_max 1000000\n./gen -type random -k_max 1 -w_max 1000 -n_max 1000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:37.468435",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "546/B",
      "title": "B. Солдат и значки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка состоит из единственного целого числа n (1 ≤ n ≤ 3000) — количества солдат.В следующей строке записано n целых чисел ai (1 ≤ ai ≤ n), обозначающих коэффициент крутизны каждого значка.",
      "output_spec": "Выходные данныеВыведите единственное целое число — минимальное количество монет, которые придется выплатить полковнику.",
      "sample_tests": "ПримерыВходные данныеСкопировать41 3 1 4Выходные данныеСкопировать1Входные данныеСкопировать51 2 3 2 5Выходные данныеСкопировать2",
      "description": "B. Солдат и значки\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка состоит из единственного целого числа n (1 ≤ n ≤ 3000) — количества солдат.В следующей строке записано n целых чисел ai (1 ≤ ai ≤ n), обозначающих коэффициент крутизны каждого значка.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — минимальное количество монет, которые придется выплатить полковнику.\n\nВыходные данные\n\nВходные данныеСкопировать41 3 1 4Выходные данныеСкопировать1Входные данныеСкопировать51 2 3 2 5Выходные данныеСкопировать2\n\nВходные данныеСкопировать41 3 1 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать51 2 3 2 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из примера мы можем увеличить коэффициент первого значка на 1.Во втором тесте из примера мы можем увеличить коэффициенты второго и третьего значка на 1.",
      "solutions": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces",
          "content": "Hi everyone!I am pleased to announce that Codeforces Round #304 (Div.2), of which I am the author, will take place today. This will be my first round, so I hope that it will be cool and interesting. Traditionally Div.1 participants can take part out of the competition.I want to thank znirzej, Dakurels and Zlobober for help with preparing the problems, thank Delinur for translating the problems, and thank to MikeMirzayanov and all who created polygon for this great system.I wish you all good luck!UPD Scoring will be 500-1000-1250-1500-2250.UPD editorialUPD Congratulations for winners in div.2: phoenix__jpn Hujishiro_otone lzw4896s jinzhao jabbawookiees And in div.1: ngfam_kongu uwi anta W4yneb0t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces",
          "content": "A. Soldier and BananasWe can easily calculate the sum of money that we need to buy all the bananas that we want, let's name it x.If n >  = x the answer is 0, because we don't need to borrow anything.Otherwise the answer is x - n.B. Soldier and BadgesLet's count the number of badges with coolness factor 1, 2 and so on. Then, let's look at the number of badges with value equal to 1. If it's greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n - 2 (because maximum value of badge which we can achieve is 2n - 1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.C. Soldier and CardsIt's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?Firstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n + 1 places (because we can count the before and after deck case too).So war has (n + 1)! states. If we'd do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.After checking this game more accurately I can say that the longest path in the state-graph for n = 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.Alternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast.D. Soldier and Number GameFirstly we have to note, that second soldier should choose only prime numbers. If he choose a composite number x that is equal to p * q, he can choose first p, then q and get better score. So our task is to find a number of prime factors in factorization of n.Now we have to note that factorization of number a! / b! is this same as factorization of numbers (b + 1)*(b + 2)*...*(a - 1)*a.Let's count number of prime factor in factorization of every number from 2 to 5000000.First, we use Sieve of Eratosthenes to find a prime diviser of each of these numbers. Then we can calculate a number of prime factors in factorization of a using the formula:primefactors[a] = primefactors[a / primediviser[a]] + 1When we know all these numbers, we can use a prefix sums, and then answer for sum on interval.E. Soldier and TravelingThere are few ways to solve this task, but I'll describe the simplest (in my opinion) one.Let's build a flow network in following way:Make a source.Make a first group of vertices consisting of n vertices, each of them for one city.Connect a source with ith vertex in first group with edge that has capacity ai.Make a sink and second group of vertices in the same way, but use bi except for ai.If there is a road between cities i and j or i = j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.Then find a maxflow, in any complexity.If maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.I told about many solutions, because every solution, which doesn't use greedy strategy, can undo it's previous pushes, and does it in reasonable complexity should pass.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3740
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 1",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 2",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 3",
          "code": "if(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 4",
          "code": "while(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 5",
          "code": "#define nline printf(\"\\n\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 6",
          "code": "cout<<ans<<\"\\n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 7",
          "code": "printf(\"%d\\n\", ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 9",
          "code": "#define stack queue",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 2",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 3",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 4",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 5",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 6",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 7",
          "code": "System.out.println(f[a]-f[b])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 8",
          "code": "StringBuilder",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 9",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 10",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, n, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, n, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 3000, \"n\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, n, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int K = opt<int>(\"K\", 1); // The coolness factor to use\n        for (int i = 0; i < n; ++i)\n            a[i] = K;\n    } else if (type == \"unique\") {\n        // Generate unique coolness factors from 1 to n\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_duplicates\") {\n        // All badges have the minimal coolness factor\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"min_increments\") {\n        // Set up a case where minimal increments are needed\n        int num_duplicates = n / 2;\n        for (int i = 0; i < n - num_duplicates; ++i)\n            a[i] = i + 1; // Unique values\n        int duplicate_value = a[n - num_duplicates - 1];\n        for (int i = n - num_duplicates; i < n; ++i)\n            a[i] = duplicate_value; // Duplicate values\n        shuffle(a.begin(), a.end());\n    } else if (type == \"increasing\") {\n        // An increasing sequence of coolness factors\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        // A decreasing sequence of coolness factors\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"zigzag\") {\n        // A sequence alternating between two values\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } else if (type == \"random\") {\n        // Random coolness factors between 1 and n\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    } else {\n        // Default to random if an unknown type is specified\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the coolness factors\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        int K = opt<int>(\"K\", 1); // The coolness factor to use\n        for (int i = 0; i < n; ++i)\n            a[i] = K;\n    } else if (type == \"unique\") {\n        // Generate unique coolness factors from 1 to n\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_duplicates\") {\n        // All badges have the minimal coolness factor\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (type == \"min_increments\") {\n        // Set up a case where minimal increments are needed\n        int num_duplicates = n / 2;\n        for (int i = 0; i < n - num_duplicates; ++i)\n            a[i] = i + 1; // Unique values\n        int duplicate_value = a[n - num_duplicates - 1];\n        for (int i = n - num_duplicates; i < n; ++i)\n            a[i] = duplicate_value; // Duplicate values\n        shuffle(a.begin(), a.end());\n    } else if (type == \"increasing\") {\n        // An increasing sequence of coolness factors\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        // A decreasing sequence of coolness factors\n        for (int i = 0; i < n; ++i)\n            a[i] = n - i;\n    } else if (type == \"zigzag\") {\n        // A sequence alternating between two values\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } else if (type == \"random\") {\n        // Random coolness factors between 1 and n\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    } else {\n        // Default to random if an unknown type is specified\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the coolness factors\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test cases with small n\n./gen -n 1 -type all_same\n./gen -n 2 -type unique\n./gen -n 2 -type random\n\n# Test cases with medium n\n./gen -n 10 -type all_same -K 5\n./gen -n 10 -type unique\n./gen -n 10 -type max_duplicates\n./gen -n 10 -type min_increments\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type zigzag\n./gen -n 10 -type random\n\n# Test cases with larger n\n./gen -n 100 -type all_same -K 42\n./gen -n 100 -type unique\n./gen -n 100 -type max_duplicates\n./gen -n 100 -type min_increments\n./gen -n 100 -type increasing\n./gen -n 100 -type decreasing\n./gen -n 100 -type zigzag\n./gen -n 100 -type random\n\n# Edge cases with maximum n\n./gen -n 3000 -type all_same -K 1\n./gen -n 3000 -type unique\n./gen -n 3000 -type max_duplicates\n./gen -n 3000 -type min_increments\n./gen -n 3000 -type increasing\n./gen -n 3000 -type decreasing\n./gen -n 3000 -type zigzag\n./gen -n 3000 -type random\n\n# Additional random test cases\n./gen -n 2999 -type random\n./gen -n 3000 -type random\n./gen -n 3000 -type min_increments\n./gen -n 3000 -type random\n./gen -n 3000 -type unique\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:39.478468",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "546/C",
      "title": "C. Солдат и карты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 10), количество карт.Во второй строке записано целое число k1 (1 ≤ k1 ≤ n - 1), количество карт у первого солдата. Затем следует k1 целых чисел — значения карт первого солдата в порядке сверху вниз.В третьей строке записано целое число k2 (k1 + k2 = n), количество карт у второго солдата. Затем следует k2 целых чисел — значения карт второго солдата сверху вниз.Все значения карт различны.",
      "output_spec": "Выходные данныеЕсли кто-то победит в этой игре, выведите 2 целых чисел, где первое число обозначает количество сражений в игре, а второе — 1 или 2, обозначающее, какой игрок победил.Если игра не закончится, а будет продолжаться вечно, выведите  - 1.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 1 32 4 2Выходные данныеСкопировать6 2Входные данныеСкопировать31 22 1 3Выходные данныеСкопировать-1",
      "description": "C. Солдат и карты\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано единственное целое число n (2 ≤ n ≤ 10), количество карт.Во второй строке записано целое число k1 (1 ≤ k1 ≤ n - 1), количество карт у первого солдата. Затем следует k1 целых чисел — значения карт первого солдата в порядке сверху вниз.В третьей строке записано целое число k2 (k1 + k2 = n), количество карт у второго солдата. Затем следует k2 целых чисел — значения карт второго солдата сверху вниз.Все значения карт различны.\n\nВходные данные\n\nВыходные данныеЕсли кто-то победит в этой игре, выведите 2 целых чисел, где первое число обозначает количество сражений в игре, а второе — 1 или 2, обозначающее, какой игрок победил.Если игра не закончится, а будет продолжаться вечно, выведите  - 1.\n\nВыходные данные\n\nВходные данныеСкопировать42 1 32 4 2Выходные данныеСкопировать6 2Входные данныеСкопировать31 22 1 3Выходные данныеСкопировать-1\n\nВходные данныеСкопировать42 1 32 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 22 1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый пример:   Второй пример:",
      "solutions": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces",
          "content": "Hi everyone!I am pleased to announce that Codeforces Round #304 (Div.2), of which I am the author, will take place today. This will be my first round, so I hope that it will be cool and interesting. Traditionally Div.1 participants can take part out of the competition.I want to thank znirzej, Dakurels and Zlobober for help with preparing the problems, thank Delinur for translating the problems, and thank to MikeMirzayanov and all who created polygon for this great system.I wish you all good luck!UPD Scoring will be 500-1000-1250-1500-2250.UPD editorialUPD Congratulations for winners in div.2: phoenix__jpn Hujishiro_otone lzw4896s jinzhao jabbawookiees And in div.1: ngfam_kongu uwi anta W4yneb0t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces",
          "content": "A. Soldier and BananasWe can easily calculate the sum of money that we need to buy all the bananas that we want, let's name it x.If n >  = x the answer is 0, because we don't need to borrow anything.Otherwise the answer is x - n.B. Soldier and BadgesLet's count the number of badges with coolness factor 1, 2 and so on. Then, let's look at the number of badges with value equal to 1. If it's greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n - 2 (because maximum value of badge which we can achieve is 2n - 1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.C. Soldier and CardsIt's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?Firstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n + 1 places (because we can count the before and after deck case too).So war has (n + 1)! states. If we'd do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.After checking this game more accurately I can say that the longest path in the state-graph for n = 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.Alternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast.D. Soldier and Number GameFirstly we have to note, that second soldier should choose only prime numbers. If he choose a composite number x that is equal to p * q, he can choose first p, then q and get better score. So our task is to find a number of prime factors in factorization of n.Now we have to note that factorization of number a! / b! is this same as factorization of numbers (b + 1)*(b + 2)*...*(a - 1)*a.Let's count number of prime factor in factorization of every number from 2 to 5000000.First, we use Sieve of Eratosthenes to find a prime diviser of each of these numbers. Then we can calculate a number of prime factors in factorization of a using the formula:primefactors[a] = primefactors[a / primediviser[a]] + 1When we know all these numbers, we can use a prefix sums, and then answer for sum on interval.E. Soldier and TravelingThere are few ways to solve this task, but I'll describe the simplest (in my opinion) one.Let's build a flow network in following way:Make a source.Make a first group of vertices consisting of n vertices, each of them for one city.Connect a source with ith vertex in first group with edge that has capacity ai.Make a sink and second group of vertices in the same way, but use bi except for ai.If there is a road between cities i and j or i = j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.Then find a maxflow, in any complexity.If maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.I told about many solutions, because every solution, which doesn't use greedy strategy, can undo it's previous pushes, and does it in reasonable complexity should pass.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3740
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 1",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 2",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 3",
          "code": "if(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 4",
          "code": "while(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 5",
          "code": "#define nline printf(\"\\n\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 6",
          "code": "cout<<ans<<\"\\n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 7",
          "code": "printf(\"%d\\n\", ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 9",
          "code": "#define stack queue",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 2",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 3",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 4",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 5",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 6",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 7",
          "code": "System.out.println(f[a]-f[b])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 8",
          "code": "StringBuilder",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 9",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 10",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(2, 10, \"n\");\n    inf.readEoln();\n\n    // Read k1 and k1 integers\n    int k1 = inf.readInt(1, n - 1, \"k1\");\n    vector<int> cards1;\n    set<int> cardValues; // To store all card values and check duplicates\n\n    for (int i = 0; i < k1; i++) {\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"card1\");\n        ensuref(cardValues.insert(c).second, \"Card value %d occurs more than once\", c);\n        cards1.push_back(c);\n    }\n\n    inf.readEoln();\n\n    // Read k2 and k2 integers\n    int k2 = inf.readInt(1, n - 1, \"k2\");\n    ensuref(k1 + k2 == n, \"k1 + k2 must be equal to n\");\n\n    vector<int> cards2;\n\n    for (int i = 0; i < k2; i++) {\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"card2\");\n        ensuref(cardValues.insert(c).second, \"Card value %d occurs more than once\", c);\n        cards2.push_back(c);\n    }\n\n    inf.readEoln();\n\n    // Ensure that total number of cards is n\n    ensuref(int(cardValues.size()) == n, \"Total number of distinct cards must be n\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(2, 10, \"n\");\n    inf.readEoln();\n\n    // Read k1 and k1 integers\n    int k1 = inf.readInt(1, n - 1, \"k1\");\n    vector<int> cards1;\n    set<int> cardValues; // To store all card values and check duplicates\n\n    for (int i = 0; i < k1; i++) {\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"card1\");\n        ensuref(cardValues.insert(c).second, \"Card value %d occurs more than once\", c);\n        cards1.push_back(c);\n    }\n\n    inf.readEoln();\n\n    // Read k2 and k2 integers\n    int k2 = inf.readInt(1, n - 1, \"k2\");\n    ensuref(k1 + k2 == n, \"k1 + k2 must be equal to n\");\n\n    vector<int> cards2;\n\n    for (int i = 0; i < k2; i++) {\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"card2\");\n        ensuref(cardValues.insert(c).second, \"Card value %d occurs more than once\", c);\n        cards2.push_back(c);\n    }\n\n    inf.readEoln();\n\n    // Ensure that total number of cards is n\n    ensuref(int(cardValues.size()) == n, \"Total number of distinct cards must be n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n\n    int n = inf.readInt(2, 10, \"n\");\n    inf.readEoln();\n\n    // Read k1 and k1 integers\n    int k1 = inf.readInt(1, n - 1, \"k1\");\n    vector<int> cards1;\n    set<int> cardValues; // To store all card values and check duplicates\n\n    for (int i = 0; i < k1; i++) {\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"card1\");\n        ensuref(cardValues.insert(c).second, \"Card value %d occurs more than once\", c);\n        cards1.push_back(c);\n    }\n\n    inf.readEoln();\n\n    // Read k2 and k2 integers\n    int k2 = inf.readInt(1, n - 1, \"k2\");\n    ensuref(k1 + k2 == n, \"k1 + k2 must be equal to n\");\n\n    vector<int> cards2;\n\n    for (int i = 0; i < k2; i++) {\n        inf.readSpace();\n        int c = inf.readInt(1, n, \"card2\");\n        ensuref(cardValues.insert(c).second, \"Card value %d occurs more than once\", c);\n        cards2.push_back(c);\n    }\n\n    inf.readEoln();\n\n    // Ensure that total number of cards is n\n    ensuref(int(cardValues.size()) == n, \"Total number of distinct cards must be n\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to simulate the game and determine if it ends or loops infinitely\nvector<int> simulate_game(int n, vector<int> deck1, vector<int> deck2, int max_moves = 1000) {\n    map<pair<vector<int>, vector<int>>, int> states;\n    int moves = 0;\n    while (!deck1.empty() && !deck2.empty() && moves <= max_moves) {\n        pair<vector<int>, vector<int>> state = make_pair(deck1, deck2);\n        if (states.count(state)) {\n            // Loop detected\n            return {-1};\n        }\n        states[state] = moves;\n\n        int card1 = deck1.front(); deck1.erase(deck1.begin());\n        int card2 = deck2.front(); deck2.erase(deck2.begin());\n\n        if (card1 > card2) {\n            deck1.push_back(card2);\n            deck1.push_back(card1);\n        } else {\n            deck2.push_back(card1);\n            deck2.push_back(card2);\n        }\n        moves++;\n    }\n    if (moves > max_moves) {\n        return {-1};\n    }\n    if (deck1.empty()) {\n        return {moves, 2};\n    } else if (deck2.empty()) {\n        return {moves, 1};\n    } else {\n        return {-1};\n    }\n}\n\nint main(int argc, char* argv[]){\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> cards(n);\n    iota(cards.begin(), cards.end(), 1); // Cards 1..n\n\n    vector<int> deck1, deck2;\n\n    if (type == \"random\") {\n        shuffle(cards.begin(), cards.end());\n        int k1 = rnd.next(1, n - 1);\n        int k2 = n - k1;\n        deck1.assign(cards.begin(), cards.begin() + k1);\n        deck2.assign(cards.begin() + k1, cards.end());\n    } else if (type == \"infinite\") {\n        if (n == 3) {\n            deck1 = {2};\n            deck2 = {1,3};\n        } else if (n == 4) {\n            deck1 = {2};\n            deck2 = {1,3,4};\n        } else if (n == 5) {\n            deck1 = {3};\n            deck2 = {1,2,4,5};\n        } else if (n >= 6) {\n            deck1 = {n / 2};\n            deck2.clear();\n            for (int i = 1; i <= n; i++) {\n                if (i != n / 2)\n                    deck2.push_back(i);\n            }\n        } else {\n            // For n=2, no infinite game possible, generate random instead\n            shuffle(cards.begin(), cards.end());\n            int k1 = rnd.next(1, n - 1);\n            int k2 = n - k1;\n            deck1.assign(cards.begin(), cards.begin() + k1);\n            deck2.assign(cards.begin() + k1, cards.end());\n        }\n    } else if (type == \"player1_wins_fast\") {\n        deck1 = {n};\n        deck2.clear();\n        for (int i = 1; i < n; i++)\n            deck2.push_back(i);\n        shuffle(deck2.begin(), deck2.end());\n    } else if (type == \"player2_wins_fast\") {\n        deck2 = {n};\n        deck1.clear();\n        for (int i = 1; i < n; i++)\n            deck1.push_back(i);\n        shuffle(deck1.begin(), deck1.end());\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    printf(\"%lu\", deck1.size());\n    for (int x : deck1) printf(\" %d\", x);\n    printf(\"\\n\");\n    printf(\"%lu\", deck2.size());\n    for (int x : deck2) printf(\" %d\", x);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to simulate the game and determine if it ends or loops infinitely\nvector<int> simulate_game(int n, vector<int> deck1, vector<int> deck2, int max_moves = 1000) {\n    map<pair<vector<int>, vector<int>>, int> states;\n    int moves = 0;\n    while (!deck1.empty() && !deck2.empty() && moves <= max_moves) {\n        pair<vector<int>, vector<int>> state = make_pair(deck1, deck2);\n        if (states.count(state)) {\n            // Loop detected\n            return {-1};\n        }\n        states[state] = moves;\n\n        int card1 = deck1.front(); deck1.erase(deck1.begin());\n        int card2 = deck2.front(); deck2.erase(deck2.begin());\n\n        if (card1 > card2) {\n            deck1.push_back(card2);\n            deck1.push_back(card1);\n        } else {\n            deck2.push_back(card1);\n            deck2.push_back(card2);\n        }\n        moves++;\n    }\n    if (moves > max_moves) {\n        return {-1};\n    }\n    if (deck1.empty()) {\n        return {moves, 2};\n    } else if (deck2.empty()) {\n        return {moves, 1};\n    } else {\n        return {-1};\n    }\n}\n\nint main(int argc, char* argv[]){\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> cards(n);\n    iota(cards.begin(), cards.end(), 1); // Cards 1..n\n\n    vector<int> deck1, deck2;\n\n    if (type == \"random\") {\n        shuffle(cards.begin(), cards.end());\n        int k1 = rnd.next(1, n - 1);\n        int k2 = n - k1;\n        deck1.assign(cards.begin(), cards.begin() + k1);\n        deck2.assign(cards.begin() + k1, cards.end());\n    } else if (type == \"infinite\") {\n        if (n == 3) {\n            deck1 = {2};\n            deck2 = {1,3};\n        } else if (n == 4) {\n            deck1 = {2};\n            deck2 = {1,3,4};\n        } else if (n == 5) {\n            deck1 = {3};\n            deck2 = {1,2,4,5};\n        } else if (n >= 6) {\n            deck1 = {n / 2};\n            deck2.clear();\n            for (int i = 1; i <= n; i++) {\n                if (i != n / 2)\n                    deck2.push_back(i);\n            }\n        } else {\n            // For n=2, no infinite game possible, generate random instead\n            shuffle(cards.begin(), cards.end());\n            int k1 = rnd.next(1, n - 1);\n            int k2 = n - k1;\n            deck1.assign(cards.begin(), cards.begin() + k1);\n            deck2.assign(cards.begin() + k1, cards.end());\n        }\n    } else if (type == \"player1_wins_fast\") {\n        deck1 = {n};\n        deck2.clear();\n        for (int i = 1; i < n; i++)\n            deck2.push_back(i);\n        shuffle(deck2.begin(), deck2.end());\n    } else if (type == \"player2_wins_fast\") {\n        deck2 = {n};\n        deck1.clear();\n        for (int i = 1; i < n; i++)\n            deck1.push_back(i);\n        shuffle(deck1.begin(), deck1.end());\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    printf(\"%lu\", deck1.size());\n    for (int x : deck1) printf(\" %d\", x);\n    printf(\"\\n\");\n    printf(\"%lu\", deck2.size());\n    for (int x : deck2) printf(\" %d\", x);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type player1_wins_fast\n./gen -n 2 -type player2_wins_fast\n./gen -n 2 -type infinite\n\n./gen -n 3 -type random\n./gen -n 3 -type player1_wins_fast\n./gen -n 3 -type player2_wins_fast\n./gen -n 3 -type infinite\n\n./gen -n 4 -type random\n./gen -n 4 -type player1_wins_fast\n./gen -n 4 -type player2_wins_fast\n./gen -n 4 -type infinite\n\n./gen -n 5 -type random\n./gen -n 5 -type player1_wins_fast\n./gen -n 5 -type player2_wins_fast\n./gen -n 5 -type infinite\n\n./gen -n 6 -type random\n./gen -n 6 -type player1_wins_fast\n./gen -n 6 -type player2_wins_fast\n./gen -n 6 -type infinite\n\n./gen -n 7 -type random\n./gen -n 7 -type player1_wins_fast\n./gen -n 7 -type player2_wins_fast\n./gen -n 7 -type infinite\n\n./gen -n 8 -type random\n./gen -n 8 -type player1_wins_fast\n./gen -n 8 -type player2_wins_fast\n./gen -n 8 -type infinite\n\n./gen -n 9 -type random\n./gen -n 9 -type player1_wins_fast\n./gen -n 9 -type player2_wins_fast\n./gen -n 9 -type infinite\n\n./gen -n 10 -type random\n./gen -n 10 -type player1_wins_fast\n./gen -n 10 -type player2_wins_fast\n./gen -n 10 -type infinite\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:41.653994",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "546/D",
      "title": "D. Солдат и игра с числами",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входа записано единственное целое число t (1 ≤ t ≤ 1 000 000) обозначающее количество игр, в которые играют солдаты.Затем следуют t строк, в каждой строке записана пара чисел a и b (1 ≤ b ≤ a ≤ 5 000 000), обозначающая значение n для игры.",
      "output_spec": "Выходные данныеДля каждой игры выведите максимальный счет, которого может достичь второй солдат.",
      "sample_tests": "ПримерыВходные данныеСкопировать23 16 3Выходные данныеСкопировать25",
      "description": "D. Солдат и игра с числами\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входа записано единственное целое число t (1 ≤ t ≤ 1 000 000) обозначающее количество игр, в которые играют солдаты.Затем следуют t строк, в каждой строке записана пара чисел a и b (1 ≤ b ≤ a ≤ 5 000 000), обозначающая значение n для игры.\n\nВходные данные\n\nВыходные данныеДля каждой игры выведите максимальный счет, которого может достичь второй солдат.\n\nВыходные данные\n\nВходные данныеСкопировать23 16 3Выходные данныеСкопировать25\n\nВходные данныеСкопировать23 16 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать25\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces",
          "content": "Hi everyone!I am pleased to announce that Codeforces Round #304 (Div.2), of which I am the author, will take place today. This will be my first round, so I hope that it will be cool and interesting. Traditionally Div.1 participants can take part out of the competition.I want to thank znirzej, Dakurels and Zlobober for help with preparing the problems, thank Delinur for translating the problems, and thank to MikeMirzayanov and all who created polygon for this great system.I wish you all good luck!UPD Scoring will be 500-1000-1250-1500-2250.UPD editorialUPD Congratulations for winners in div.2: phoenix__jpn Hujishiro_otone lzw4896s jinzhao jabbawookiees And in div.1: ngfam_kongu uwi anta W4yneb0t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces",
          "content": "A. Soldier and BananasWe can easily calculate the sum of money that we need to buy all the bananas that we want, let's name it x.If n >  = x the answer is 0, because we don't need to borrow anything.Otherwise the answer is x - n.B. Soldier and BadgesLet's count the number of badges with coolness factor 1, 2 and so on. Then, let's look at the number of badges with value equal to 1. If it's greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n - 2 (because maximum value of badge which we can achieve is 2n - 1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.C. Soldier and CardsIt's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?Firstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n + 1 places (because we can count the before and after deck case too).So war has (n + 1)! states. If we'd do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.After checking this game more accurately I can say that the longest path in the state-graph for n = 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.Alternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast.D. Soldier and Number GameFirstly we have to note, that second soldier should choose only prime numbers. If he choose a composite number x that is equal to p * q, he can choose first p, then q and get better score. So our task is to find a number of prime factors in factorization of n.Now we have to note that factorization of number a! / b! is this same as factorization of numbers (b + 1)*(b + 2)*...*(a - 1)*a.Let's count number of prime factor in factorization of every number from 2 to 5000000.First, we use Sieve of Eratosthenes to find a prime diviser of each of these numbers. Then we can calculate a number of prime factors in factorization of a using the formula:primefactors[a] = primefactors[a / primediviser[a]] + 1When we know all these numbers, we can use a prefix sums, and then answer for sum on interval.E. Soldier and TravelingThere are few ways to solve this task, but I'll describe the simplest (in my opinion) one.Let's build a flow network in following way:Make a source.Make a first group of vertices consisting of n vertices, each of them for one city.Connect a source with ith vertex in first group with edge that has capacity ai.Make a sink and second group of vertices in the same way, but use bi except for ai.If there is a road between cities i and j or i = j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.Then find a maxflow, in any complexity.If maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.I told about many solutions, because every solution, which doesn't use greedy strategy, can undo it's previous pushes, and does it in reasonable complexity should pass.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3740
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 1",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 2",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 3",
          "code": "if(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 4",
          "code": "while(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 5",
          "code": "#define nline printf(\"\\n\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 6",
          "code": "cout<<ans<<\"\\n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 7",
          "code": "printf(\"%d\\n\", ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 9",
          "code": "#define stack queue",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 2",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 3",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 4",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 5",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 6",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 7",
          "code": "System.out.println(f[a]-f[b])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 8",
          "code": "StringBuilder",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 9",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 10",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        int a = inf.readInt(1, 5000000, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, a, \"b\"); // b <= a\n        inf.readEoln();\n\n        // b <= a is already ensured by inf.readInt(1, a)\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        int a = inf.readInt(1, 5000000, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, a, \"b\"); // b <= a\n        inf.readEoln();\n\n        // b <= a is already ensured by inf.readInt(1, a)\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int t = inf.readInt(1, 1000000, \"t\");\n    inf.readEoln();\n\n    for (int i = 0; i < t; i++) {\n        int a = inf.readInt(1, 5000000, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, a, \"b\"); // b <= a\n        inf.readEoln();\n\n        // b <= a is already ensured by inf.readInt(1, a)\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 5000000);\n    int maxB = opt<int>(\"maxB\", maxA); // default maxB is maxA\n\n    // Ensure maxB does not exceed maxA\n    maxB = min(maxB, maxA);\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    if (type == \"random\") {\n        // Generate t random cases\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB);\n            int a = rnd.next(b, maxA);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"edge_a_equals_b\") {\n        // Generate t cases where a = b\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB);\n            int a = b;\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"edge_b_equals_1\") {\n        // Generate t cases where b = 1\n        for (int i = 0; i < t; ++i) {\n            int b = 1;\n            int a = rnd.next(1, maxA);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"a_max_b_min\") {\n        // Generate t cases where a = maxA, b = 1\n        for (int i = 0; i < t; ++i) {\n            int a = maxA;\n            int b = 1;\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"a_equals_b_plus_1\") {\n        // Generate t cases where a = b + 1\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB - 1);\n            int a = b + 1;\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"fixed\") {\n        // Generate t cases with fixed a and b\n        int a = opt<int>(\"a\");\n        int b = opt<int>(\"b\");\n        if (a < b || b < 1 || a > maxA || b > maxB) {\n            fprintf(stderr, \"Invalid fixed values of a and b\\n\");\n            return 1;\n        }\n        for (int i = 0; i < t; ++i) {\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else {\n        // Default: random\n        // same as \"random\"\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB);\n            int a = rnd.next(b, maxA);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int t = opt<int>(\"t\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 5000000);\n    int maxB = opt<int>(\"maxB\", maxA); // default maxB is maxA\n\n    // Ensure maxB does not exceed maxA\n    maxB = min(maxB, maxA);\n\n    // Output t\n    printf(\"%d\\n\", t);\n\n    if (type == \"random\") {\n        // Generate t random cases\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB);\n            int a = rnd.next(b, maxA);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"edge_a_equals_b\") {\n        // Generate t cases where a = b\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB);\n            int a = b;\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"edge_b_equals_1\") {\n        // Generate t cases where b = 1\n        for (int i = 0; i < t; ++i) {\n            int b = 1;\n            int a = rnd.next(1, maxA);\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"a_max_b_min\") {\n        // Generate t cases where a = maxA, b = 1\n        for (int i = 0; i < t; ++i) {\n            int a = maxA;\n            int b = 1;\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"a_equals_b_plus_1\") {\n        // Generate t cases where a = b + 1\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB - 1);\n            int a = b + 1;\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else if (type == \"fixed\") {\n        // Generate t cases with fixed a and b\n        int a = opt<int>(\"a\");\n        int b = opt<int>(\"b\");\n        if (a < b || b < 1 || a > maxA || b > maxB) {\n            fprintf(stderr, \"Invalid fixed values of a and b\\n\");\n            return 1;\n        }\n        for (int i = 0; i < t; ++i) {\n            printf(\"%d %d\\n\", a, b);\n        }\n    } else {\n        // Default: random\n        // same as \"random\"\n        for (int i = 0; i < t; ++i) {\n            int b = rnd.next(1, maxB);\n            int a = rnd.next(b, maxA);\n            printf(\"%d %d\\n\", a, b);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -t 1 -type fixed -a 1 -b 1\n./gen -t 1 -type fixed -a 2 -b 1\n./gen -t 1 -type edge_a_equals_b\n./gen -t 10 -type edge_a_equals_b\n./gen -t 10 -type edge_b_equals_1\n./gen -t 100 -type edge_b_equals_1 -maxA 1000\n./gen -t 1000 -type random -maxA 1000 -maxB 1000\n./gen -t 10000 -type random -maxA 5000 -maxB 5000\n./gen -t 1 -type a_max_b_min\n./gen -t 10 -type a_equals_b_plus_1\n./gen -t 100000 -type random\n./gen -t 100000 -type edge_a_equals_b\n./gen -t 100000 -type edge_b_equals_1\n./gen -t 100000 -type a_equals_b_plus_1\n./gen -t 100000 -type fixed -a 5000000 -b 4999999\n./gen -t 1000000 -type random\n./gen -t 1000000 -type edge_a_equals_b\n./gen -t 1000000 -type a_max_b_min\n./gen -t 1000000 -type fixed -a 5000000 -b 1\n./gen -t 1000000 -type fixed -a 5000000 -b 5000000\n./gen -t 1000 -type random -maxA 2 -maxB 2\n./gen -t 1000 -type random -maxA 3 -maxB 3\n./gen -t 1000 -type random -maxA 100 -maxB 50\n./gen -t 500000 -type random -maxA 5000000 -maxB 1\n./gen -t 500000 -type a_equals_b_plus_1 -maxB 4999999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:43.527012",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "546/E",
      "title": "E. Солдат и путешествия",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входа содержит два целых числа, n и m (1 ≤ n ≤ 100, 0 ≤ m ≤ 200).В следующей строке записано n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 100).В следующей строке записано n целых чисел b1, b2, ..., bn (0 ≤ bi ≤ 100).Затем слеует m строк, каждая состоит из двух целых чисел, p и q (1 ≤ p, q ≤ n, p ≠ q) обозначающих, что между городами p и q есть дорога. Гарантируется, что между каждой парой городов существует не более одной дороги.",
      "output_spec": "Выходные данныеЕсли требуемое невозможно, выведите единственное слово: \"NO\".В противном случае выведите слово \"YES\", а затем выведите n строк, в каждой строке выведите по n целых чисел. Число в i-й строке и j-м столбце должно обозначать, сколько солдат должно перейти из города i в город j (если i ≠ j), либо сколько солдат должно остаться в городе i (если i = j).Если возможных ответов несколько, выведите любой из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 41 2 6 33 5 3 11 22 33 44 2Выходные данныеСкопироватьYES1 0 0 0 2 0 0 0 0 5 1 0 0 0 2 1 Входные данныеСкопировать2 01 22 1Выходные данныеСкопироватьNO",
      "description": "E. Солдат и путешествия\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка входа содержит два целых числа, n и m (1 ≤ n ≤ 100, 0 ≤ m ≤ 200).В следующей строке записано n целых чисел a1, a2, ..., an (0 ≤ ai ≤ 100).В следующей строке записано n целых чисел b1, b2, ..., bn (0 ≤ bi ≤ 100).Затем слеует m строк, каждая состоит из двух целых чисел, p и q (1 ≤ p, q ≤ n, p ≠ q) обозначающих, что между городами p и q есть дорога. Гарантируется, что между каждой парой городов существует не более одной дороги.\n\nВходные данные\n\nВыходные данныеЕсли требуемое невозможно, выведите единственное слово: \"NO\".В противном случае выведите слово \"YES\", а затем выведите n строк, в каждой строке выведите по n целых чисел. Число в i-й строке и j-м столбце должно обозначать, сколько солдат должно перейти из города i в город j (если i ≠ j), либо сколько солдат должно остаться в городе i (если i = j).Если возможных ответов несколько, выведите любой из них.\n\nВыходные данные\n\nВходные данныеСкопировать4 41 2 6 33 5 3 11 22 33 44 2Выходные данныеСкопироватьYES1 0 0 0 2 0 0 0 0 5 1 0 0 0 2 1 Входные данныеСкопировать2 01 22 1Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать4 41 2 6 33 5 3 11 22 33 44 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES1 0 0 0 2 0 0 0 0 5 1 0 0 0 2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 01 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces",
          "content": "Hi everyone!I am pleased to announce that Codeforces Round #304 (Div.2), of which I am the author, will take place today. This will be my first round, so I hope that it will be cool and interesting. Traditionally Div.1 participants can take part out of the competition.I want to thank znirzej, Dakurels and Zlobober for help with preparing the problems, thank Delinur for translating the problems, and thank to MikeMirzayanov and all who created polygon for this great system.I wish you all good luck!UPD Scoring will be 500-1000-1250-1500-2250.UPD editorialUPD Congratulations for winners in div.2: phoenix__jpn Hujishiro_otone lzw4896s jinzhao jabbawookiees And in div.1: ngfam_kongu uwi anta W4yneb0t",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18031",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 703
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces",
          "content": "A. Soldier and BananasWe can easily calculate the sum of money that we need to buy all the bananas that we want, let's name it x.If n >  = x the answer is 0, because we don't need to borrow anything.Otherwise the answer is x - n.B. Soldier and BadgesLet's count the number of badges with coolness factor 1, 2 and so on. Then, let's look at the number of badges with value equal to 1. If it's greater than 1, we have to increase a value of every of them except for one. Then, we look at number of badges with value 2, 3 and so on up to 2n - 2 (because maximum value of badge which we can achieve is 2n - 1). It is easy to see that this is the correct solution. We can implement it in O(n), but solutions that work in complexity O(n^2) also passed.C. Soldier and CardsIt's easy to count who wins and after how many \"fights\", but it's harder to say, that game won't end. How to do it?Firstly let's count a number of different states that we can have in the game. Cards can be arranged in any one of n! ways. In every of this combination, we must separate first soldier's cards from the second one's. We can separate it in n + 1 places (because we can count the before and after deck case too).So war has (n + 1)! states. If we'd do (n + 1)! \"fights\" and we have not finished the game yes, then we'll be sure that there is a state, that we passed at least twice. That means that we have a cycle, and game won't end.After checking this game more accurately I can say that the longest path in the state-graph for n = 10 has length 106, so it is enough to do 106 fights, but solutions that did about 40 millions also passed.Alternative solution is to map states that we already passed. If we know, that we longest time needed to return to state is about 100, then we know that this solution is correct and fast.D. Soldier and Number GameFirstly we have to note, that second soldier should choose only prime numbers. If he choose a composite number x that is equal to p * q, he can choose first p, then q and get better score. So our task is to find a number of prime factors in factorization of n.Now we have to note that factorization of number a! / b! is this same as factorization of numbers (b + 1)*(b + 2)*...*(a - 1)*a.Let's count number of prime factor in factorization of every number from 2 to 5000000.First, we use Sieve of Eratosthenes to find a prime diviser of each of these numbers. Then we can calculate a number of prime factors in factorization of a using the formula:primefactors[a] = primefactors[a / primediviser[a]] + 1When we know all these numbers, we can use a prefix sums, and then answer for sum on interval.E. Soldier and TravelingThere are few ways to solve this task, but I'll describe the simplest (in my opinion) one.Let's build a flow network in following way:Make a source.Make a first group of vertices consisting of n vertices, each of them for one city.Connect a source with ith vertex in first group with edge that has capacity ai.Make a sink and second group of vertices in the same way, but use bi except for ai.If there is a road between cities i and j or i = j. Make two edges, first should be connecting ith vertex from first group, and jth vertex from second group, and has infinity capacity. Second should be similar, but connect jth from first group and ith from second group.Then find a maxflow, in any complexity.If maxflow is equal to sum of ai and is equal to sum of bi, then there exists an answer. How can we get it? We just have to check how many units are we pushing through edge connecting two vertices from different groups.I told about many solutions, because every solution, which doesn't use greedy strategy, can undo it's previous pushes, and does it in reasonable complexity should pass.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18034",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3740
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 1",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 2",
          "code": "5\n1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 3",
          "code": "if(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 4",
          "code": "while(a[i] > 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 5",
          "code": "#define nline printf(\"\\n\")",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 6",
          "code": "cout<<ans<<\"\\n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 7",
          "code": "printf(\"%d\\n\", ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) - Codeforces - Code 9",
          "code": "#define stack queue",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18031",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 2",
          "code": "#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 3",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 4",
          "code": "s.insert (t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 5",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 6",
          "code": "if (a.front()>b.front())\n{\n...\n}\n//???\nif (a.front()<b.front())\n{\n...\t\t\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 7",
          "code": "System.out.println(f[a]-f[b])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 8",
          "code": "StringBuilder",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 9",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #304 (Div.2) editorial - Codeforces - Code 10",
          "code": "int t;\nscanf(\"%d\",&t);\nwhile(t--){\n    int a,b;\n    scanf(\"%d\",&a);\n    scanf(\"%d\",&b);\n\n    int ans = prime_factors[a] - prime_factors[b];\n    printf(\"%d\",ans);\n    printf(\"\\n\");\n}\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18034",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 100, \"b\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int p = inf.readInt(1, n, \"p_i\");\n        inf.readSpace();\n        int q = inf.readInt(1, n, \"q_i\");\n        inf.readEoln();\n\n        ensuref(p != q, \"Self-loops are not allowed: p = %d, q = %d\", p, q);\n\n        int u = min(p, q);\n        int v = max(p, q);\n\n        ensuref(edges.find(make_pair(u, v)) == edges.end(), \"Multiple edges between the same pair of cities: p = %d, q = %d\", p, q);\n\n        edges.insert(make_pair(u, v));\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 100, \"b\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int p = inf.readInt(1, n, \"p_i\");\n        inf.readSpace();\n        int q = inf.readInt(1, n, \"q_i\");\n        inf.readEoln();\n\n        ensuref(p != q, \"Self-loops are not allowed: p = %d, q = %d\", p, q);\n\n        int u = min(p, q);\n        int v = max(p, q);\n\n        ensuref(edges.find(make_pair(u, v)) == edges.end(), \"Multiple edges between the same pair of cities: p = %d, q = %d\", p, q);\n\n        edges.insert(make_pair(u, v));\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 200, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100, \"a\");\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 0, 100, \"b\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int p = inf.readInt(1, n, \"p_i\");\n        inf.readSpace();\n        int q = inf.readInt(1, n, \"q_i\");\n        inf.readEoln();\n\n        ensuref(p != q, \"Self-loops are not allowed: p = %d, q = %d\", p, q);\n\n        int u = min(p, q);\n        int v = max(p, q);\n\n        ensuref(edges.find(make_pair(u, v)) == edges.end(), \"Multiple edges between the same pair of cities: p = %d, q = %d\", p, q);\n\n        edges.insert(make_pair(u, v));\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 105;\n\nint n, m;\nint ai[MAX_N], bi[MAX_N];\nset<int> adj[MAX_N];\nint M[MAX_N][MAX_N];\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data\n    n = inf.readInt(1, 100, \"n\");\n    m = inf.readInt(0, 200, \"m\");\n\n    for (int i = 1; i <= n; ++i) {\n        ai[i] = inf.readInt(0, 100, format(\"ai[%d]\", i).c_str());\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        bi[i] = inf.readInt(0, 100, format(\"bi[%d]\", i).c_str());\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, format(\"edge %d u\", i+1).c_str());\n        int v = inf.readInt(1, n, format(\"edge %d v\", i+1).c_str());\n        if (u == v) {\n            inf.quitf(_fail, \"Self loop detected in input: edge between %d and %d\", u, v);\n        }\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    // Read jury's answer\n    string juryAns = ans.readToken();\n    if (juryAns != \"YES\" && juryAns != \"NO\") {\n        quitf(_fail, \"Jury's answer must be YES or NO, found '%s'\", juryAns.c_str());\n    }\n\n    // Read participant's answer\n    string partAns = ouf.readToken();\n    if (partAns != \"YES\" && partAns != \"NO\") {\n        quitf(_pe, \"Your answer must be YES or NO, found '%s'\", partAns.c_str());\n    }\n\n    if (partAns == \"NO\") {\n        if (juryAns == \"NO\") {\n            ouf.skipBlanks();\n            if (!ouf.eof())\n                quitf(_pe, \"Extra information after NO\");\n            quitf(_ok, \"Correctly answered NO\");\n        } else {\n            quitf(_wa, \"Participant answered NO, but solution exists\");\n        }\n    } else if (partAns == \"YES\") {\n        // Participant answered YES\n        // Read the n x n matrix\n        memset(M, 0, sizeof(M));\n\n        for (int i = 1; i <= n; ++i) {\n            // Read n integers\n            for (int j = 1; j <= n; ++j) {\n                if (ouf.seekEof())\n                    quitf(_pe, \"Too few numbers in row %d\", i);\n                M[i][j] = ouf.readInt(0, 10000, format(\"M[%d][%d]\", i, j).c_str());\n            }\n        }\n\n        // Check for extra output\n        ouf.skipBlanks();\n        if (!ouf.eof()) {\n            quitf(_pe, \"Extra information after reading matrix\");\n        }\n\n        // Validate the matrix\n        // 1. All M[i][j] >= 0\n        // Already ensured during reading\n\n        // 2. For each i, sum over j of M[i][j] == ai[i]\n        for (int i = 1; i <= n; ++i) {\n            int sum_out = 0;\n            for (int j = 1; j <= n; ++j) {\n                sum_out += M[i][j];\n            }\n            if (sum_out != ai[i]) {\n                quitf(_wa, \"Total soldiers moving from city %d (%d) does not equal initial soldiers ai[%d] = %d\", i, sum_out, i, ai[i]);\n            }\n        }\n\n        // 3. For each i, sum over j of M[j][i] == bi[i]\n        for (int i = 1; i <= n; ++i) {\n            int sum_in = 0;\n            for (int j = 1; j <= n; ++j) {\n                sum_in += M[j][i];\n            }\n            if (sum_in != bi[i]) {\n                quitf(_wa, \"Total soldiers moving into city %d (%d) does not equal desired soldiers bi[%d] = %d\", i, sum_in, i, bi[i]);\n            }\n        }\n\n        // 4. For all i != j, if M[i][j] > 0, adj[i] must contain j\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (i != j && M[i][j] > 0) {\n                    if (adj[i].find(j) == adj[i].end()) {\n                        quitf(_wa, \"Soldiers move from city %d to non-adjacent city %d\", i, j);\n                    }\n                }\n            }\n        }\n\n        // If the jury's answer was \"YES\", we accept the participant's valid solution\n        if (juryAns == \"YES\") {\n            quitf(_ok, \"Valid solution\");\n        } else {\n            // Jury's answer was \"NO\", but participant provided a valid solution\n            // This indicates an error in the jury's data\n            quitf(_fail, \"Participant found a valid solution, but jury's answer is NO\");\n        }\n    } else {\n        // Participant's answer is neither YES nor NO\n        quitf(_pe, \"The first line must be YES or NO\");\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the problem:\n    - n cities, numbered 1..n\n    - m roads (bidirectional)\n    - a_i soldiers initially in city i\n    - b_i soldiers required finally in city i\n    - 1 <= n <= 100\n    - 0 <= m <= 200\n    - 0 <= a_i, b_i <= 100\n    - at most one road between a pair of cities (no duplicates)\n\n  Command-line parameters:\n    -n <int> : number of cities\n    -m <int> : number of roads (optional; if not provided, we choose automatically)\n    -type <string> : type of test. Possible values:\n        1) \"random\"      : random a[], b[], random edges\n        2) \"complete\"    : produce a fully-connected graph if possible,\n                           or as many edges as allowed (200)\n        3) \"disconnected\": produce at least two components\n        4) \"all-zero\"    : all a_i = 0, all b_i = 0, edges random\n        5) \"star\"        : produce a star-like structure for edges\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parsing arguments\n    int n = opt<int>(\"n\");                      // required\n    int m_provided = opt<int>(\"m\", -1);         // optional\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints on n\n    // The statement says 1 <= n <= 100, but we trust the user\n    // to not pass invalid values. Same for m.\n\n    // Decide how many edges to generate if not provided\n    // The upper bound for edges is min(n*(n-1)/2, 200).\n    int maxPossibleEdges = n * (n - 1) / 2;\n    if (maxPossibleEdges > 200) {\n        maxPossibleEdges = 200;\n    }\n\n    int m;\n    if (m_provided == -1) {\n        // We'll pick a random number of edges from [0, maxPossibleEdges]\n        m = rnd.next(maxPossibleEdges + 1);\n    } else {\n        // Use the provided parameter, but clamp to feasible range\n        m = min(m_provided, maxPossibleEdges);\n        if (m < 0) m = 0;\n    }\n\n    // Prepare arrays a and b\n    vector<int> a(n), b(n);\n\n    // We'll define how to generate a[] and b[] based on type\n    if (type == \"all-zero\") {\n        // All are zero\n        for (int i = 0; i < n; i++) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n    } else {\n        // By default, generate random a[i], b[i] in [0..100]\n        // (Except for \"disconnected\", \"complete\", or \"star\", we might\n        //  still do random, or do something specialized. \n        //  But we'll keep it simple and produce random in these as well,\n        //  except for \"all-zero\".)\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(0, 100);\n            b[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Generate edges\n    // We'll create a candidate list of all possible edges (i < j), then choose\n    // the needed number based on the test type.\n    // For \"complete\": we take as many distinct edges as possible (up to 200).\n    // For \"disconnected\": we will partition into two subgraphs so that there's no cross-edge.\n    // For \"star\": 1 center with edges to all other nodes.\n    // For \"random\": just pick any random subset of edges of size m.\n\n    vector<pair<int,int>> allEdges;\n    allEdges.reserve(maxPossibleEdges);\n\n    // Helper lambda to add edges (i, j), i < j\n    auto addAllPossibleEdges = [&](int start, int end) {\n        // add pairs in [start, end) so that i<j\n        for (int i = start; i < end; i++) {\n            for (int j = i + 1; j < end; j++) {\n                allEdges.push_back({i, j});\n            }\n        }\n    };\n\n    if (type == \"complete\") {\n        // Try to make a complete graph if feasible\n        // i.e., edges = min(n*(n-1)/2, 200)\n        allEdges.clear();\n        addAllPossibleEdges(0, n);\n        m = min(m, (int)allEdges.size());\n        // no shuffle needed if we literally want them all,\n        // but let's shuffle to avoid sorted output\n        shuffle(allEdges.begin(), allEdges.end());\n        allEdges.resize(m);\n    } \n    else if (type == \"disconnected\" && n > 1) {\n        // We'll force a partition into 2 disjoint sets\n        // We choose a random k in [1, n-1]\n        int k = rnd.next(1, n-1);\n        // subgraph1: nodes [0..k-1]\n        // subgraph2: nodes [k..n-1]\n        // We'll generate random edges inside each subgraph, but no cross edges.\n        allEdges.clear();\n        addAllPossibleEdges(0, k);\n        addAllPossibleEdges(k, n);\n        // Shuffle them\n        shuffle(allEdges.begin(), allEdges.end());\n        // Possibly create fewer edges than the total inside these subgraphs\n        m = min(m, (int)allEdges.size());\n        allEdges.resize(m);\n    }\n    else if (type == \"star\" && n > 1) {\n        // We'll produce a star from node 0 to all others\n        // That yields exactly n-1 edges if n>1 (unless n=1, we skip)\n        // If user wants more edges, we won't add them. \n        // If user wants fewer, we'll clamp. But typically star is just (n-1) edges.\n        allEdges.clear();\n        for (int i = 1; i < n; i++) {\n            allEdges.push_back({0, i});\n        }\n        // Number of edges is n-1 or maybe fewer if user-specified m < n-1\n        m = min(m, n-1);\n        // If user wants to omit some edges from the star, we can shuffle and trim\n        shuffle(allEdges.begin(), allEdges.end());\n        allEdges.resize(m);\n    }\n    else {\n        // \"random\" or fallback\n        // We'll pick a random subset of all possible edges\n        // up to size m\n        allEdges.clear();\n        addAllPossibleEdges(0, n);\n        shuffle(allEdges.begin(), allEdges.end());\n        m = min(m, (int)allEdges.size());\n        allEdges.resize(m);\n    }\n\n    // Now we have a[] and b[], plus m edges in allEdges\n    // Let's output in the required format.\n\n    // 1) print n and m\n    cout << n << \" \" << m << \"\\n\";\n\n    // 2) print a1..an\n    for (int i = 0; i < n; i++) {\n        cout << a[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    // 3) print b1..bn\n    for (int i = 0; i < n; i++) {\n        cout << b[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    // 4) print edges\n    //     each edge is (p, q), with p != q and 1 <= p,q <= n\n    //     here we stored them as 0-based, so convert to 1-based\n    for (auto &e : allEdges) {\n        cout << e.first + 1 << \" \" << e.second + 1 << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case for the problem:\n    - n cities, numbered 1..n\n    - m roads (bidirectional)\n    - a_i soldiers initially in city i\n    - b_i soldiers required finally in city i\n    - 1 <= n <= 100\n    - 0 <= m <= 200\n    - 0 <= a_i, b_i <= 100\n    - at most one road between a pair of cities (no duplicates)\n\n  Command-line parameters:\n    -n <int> : number of cities\n    -m <int> : number of roads (optional; if not provided, we choose automatically)\n    -type <string> : type of test. Possible values:\n        1) \"random\"      : random a[], b[], random edges\n        2) \"complete\"    : produce a fully-connected graph if possible,\n                           or as many edges as allowed (200)\n        3) \"disconnected\": produce at least two components\n        4) \"all-zero\"    : all a_i = 0, all b_i = 0, edges random\n        5) \"star\"        : produce a star-like structure for edges\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parsing arguments\n    int n = opt<int>(\"n\");                      // required\n    int m_provided = opt<int>(\"m\", -1);         // optional\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints on n\n    // The statement says 1 <= n <= 100, but we trust the user\n    // to not pass invalid values. Same for m.\n\n    // Decide how many edges to generate if not provided\n    // The upper bound for edges is min(n*(n-1)/2, 200).\n    int maxPossibleEdges = n * (n - 1) / 2;\n    if (maxPossibleEdges > 200) {\n        maxPossibleEdges = 200;\n    }\n\n    int m;\n    if (m_provided == -1) {\n        // We'll pick a random number of edges from [0, maxPossibleEdges]\n        m = rnd.next(maxPossibleEdges + 1);\n    } else {\n        // Use the provided parameter, but clamp to feasible range\n        m = min(m_provided, maxPossibleEdges);\n        if (m < 0) m = 0;\n    }\n\n    // Prepare arrays a and b\n    vector<int> a(n), b(n);\n\n    // We'll define how to generate a[] and b[] based on type\n    if (type == \"all-zero\") {\n        // All are zero\n        for (int i = 0; i < n; i++) {\n            a[i] = 0;\n            b[i] = 0;\n        }\n    } else {\n        // By default, generate random a[i], b[i] in [0..100]\n        // (Except for \"disconnected\", \"complete\", or \"star\", we might\n        //  still do random, or do something specialized. \n        //  But we'll keep it simple and produce random in these as well,\n        //  except for \"all-zero\".)\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(0, 100);\n            b[i] = rnd.next(0, 100);\n        }\n    }\n\n    // Generate edges\n    // We'll create a candidate list of all possible edges (i < j), then choose\n    // the needed number based on the test type.\n    // For \"complete\": we take as many distinct edges as possible (up to 200).\n    // For \"disconnected\": we will partition into two subgraphs so that there's no cross-edge.\n    // For \"star\": 1 center with edges to all other nodes.\n    // For \"random\": just pick any random subset of edges of size m.\n\n    vector<pair<int,int>> allEdges;\n    allEdges.reserve(maxPossibleEdges);\n\n    // Helper lambda to add edges (i, j), i < j\n    auto addAllPossibleEdges = [&](int start, int end) {\n        // add pairs in [start, end) so that i<j\n        for (int i = start; i < end; i++) {\n            for (int j = i + 1; j < end; j++) {\n                allEdges.push_back({i, j});\n            }\n        }\n    };\n\n    if (type == \"complete\") {\n        // Try to make a complete graph if feasible\n        // i.e., edges = min(n*(n-1)/2, 200)\n        allEdges.clear();\n        addAllPossibleEdges(0, n);\n        m = min(m, (int)allEdges.size());\n        // no shuffle needed if we literally want them all,\n        // but let's shuffle to avoid sorted output\n        shuffle(allEdges.begin(), allEdges.end());\n        allEdges.resize(m);\n    } \n    else if (type == \"disconnected\" && n > 1) {\n        // We'll force a partition into 2 disjoint sets\n        // We choose a random k in [1, n-1]\n        int k = rnd.next(1, n-1);\n        // subgraph1: nodes [0..k-1]\n        // subgraph2: nodes [k..n-1]\n        // We'll generate random edges inside each subgraph, but no cross edges.\n        allEdges.clear();\n        addAllPossibleEdges(0, k);\n        addAllPossibleEdges(k, n);\n        // Shuffle them\n        shuffle(allEdges.begin(), allEdges.end());\n        // Possibly create fewer edges than the total inside these subgraphs\n        m = min(m, (int)allEdges.size());\n        allEdges.resize(m);\n    }\n    else if (type == \"star\" && n > 1) {\n        // We'll produce a star from node 0 to all others\n        // That yields exactly n-1 edges if n>1 (unless n=1, we skip)\n        // If user wants more edges, we won't add them. \n        // If user wants fewer, we'll clamp. But typically star is just (n-1) edges.\n        allEdges.clear();\n        for (int i = 1; i < n; i++) {\n            allEdges.push_back({0, i});\n        }\n        // Number of edges is n-1 or maybe fewer if user-specified m < n-1\n        m = min(m, n-1);\n        // If user wants to omit some edges from the star, we can shuffle and trim\n        shuffle(allEdges.begin(), allEdges.end());\n        allEdges.resize(m);\n    }\n    else {\n        // \"random\" or fallback\n        // We'll pick a random subset of all possible edges\n        // up to size m\n        allEdges.clear();\n        addAllPossibleEdges(0, n);\n        shuffle(allEdges.begin(), allEdges.end());\n        m = min(m, (int)allEdges.size());\n        allEdges.resize(m);\n    }\n\n    // Now we have a[] and b[], plus m edges in allEdges\n    // Let's output in the required format.\n\n    // 1) print n and m\n    cout << n << \" \" << m << \"\\n\";\n\n    // 2) print a1..an\n    for (int i = 0; i < n; i++) {\n        cout << a[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    // 3) print b1..bn\n    for (int i = 0; i < n; i++) {\n        cout << b[i];\n        if (i + 1 < n) cout << \" \";\n    }\n    cout << \"\\n\";\n\n    // 4) print edges\n    //     each edge is (p, q), with p != q and 1 <= p,q <= n\n    //     here we stored them as 0-based, so convert to 1-based\n    for (auto &e : allEdges) {\n        cout << e.first + 1 << \" \" << e.second + 1 << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20 DISTINCT commands to run the generator.\n# Each command will print exactly one test case to STDOUT.\n\n# 1) Smallest n = 1, no edges, all-zero\n./gen -n 1 -type all-zero\n\n# 2) n=2, let's do all-zero again\n./gen -n 2 -type all-zero\n\n# 3) n=2, random with possible edges\n./gen -n 2 -type random\n\n# 4) n=2, force m=1 with random type\n./gen -n 2 -m 1 -type random\n\n# 5) n=3, disconnected (two components)\n./gen -n 3 -type disconnected\n\n# 6) n=5, try star structure\n./gen -n 5 -type star\n\n# 7) n=5, random edges\n./gen -n 5 -type random\n\n# 8) n=5, complete type\n./gen -n 5 -type complete\n\n# 9) n=6, force exactly m=0 edges (no roads)\n./gen -n 6 -m 0 -type random\n\n# 10) n=6, disconnect explicitly\n./gen -n 6 -type disconnected\n\n# 11) n=8, star shape\n./gen -n 8 -type star\n\n# 12) n=8, attempt complete (should produce min of 28 and 200 edges => 28 edges)\n./gen -n 8 -type complete\n\n# 13) n=10, random edges\n./gen -n 10 -type random\n\n# 14) n=10, disconnected\n./gen -n 10 -type disconnected\n\n# 15) n=12, star\n./gen -n 12 -type star\n\n# 16) n=12, all-zero\n./gen -n 12 -type all-zero\n\n# 17) n=15, complete\n./gen -n 15 -type complete\n\n# 18) n=20, random\n./gen -n 20 -type random\n\n# 19) n=50, random\n./gen -n 50 -type random\n\n# 20) n=100, force complete type (the generator will only produce up to 200 edges)\n./gen -n 100 -type complete\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:45.733872",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "547/A",
      "title": "A. Mike and Frog",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer m (2 ≤ m ≤ 106).The second line of input contains integers h1 and a1 (0 ≤ h1, a1 < m).The third line of input contains integers x1 and y1 (0 ≤ x1, y1 < m).The fourth line of input contains integers h2 and a2 (0 ≤ h2, a2 < m).The fifth line of input contains integers x2 and y2 (0 ≤ x2, y2 < m).It is guaranteed that h1 ≠ a1 and h2 ≠ a2.",
      "output_spec": "OutputPrint the minimum number of seconds until Xaniar reaches height a1 and Abol reaches height a2 or print -1 otherwise.",
      "sample_tests": "ExamplesInputCopy54 21 10 12 3OutputCopy3InputCopy10231 21 01 21 1OutputCopy-1",
      "description": "A. Mike and Frog\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integer m (2 ≤ m ≤ 106).The second line of input contains integers h1 and a1 (0 ≤ h1, a1 < m).The third line of input contains integers x1 and y1 (0 ≤ x1, y1 < m).The fourth line of input contains integers h2 and a2 (0 ≤ h2, a2 < m).The fifth line of input contains integers x2 and y2 (0 ≤ x2, y2 < m).It is guaranteed that h1 ≠ a1 and h2 ≠ a2.\n\nOutputPrint the minimum number of seconds until Xaniar reaches height a1 and Abol reaches height a2 or print -1 otherwise.\n\nInputCopy54 21 10 12 3OutputCopy3InputCopy10231 21 01 21 1OutputCopy-1\n\nInputCopy54 21 10 12 3\n\nOutputCopy3\n\nInputCopy10231 21 01 21 1\n\nOutputCopy-1\n\nNoteIn the first sample, heights sequences are following:Xaniar: Abol:",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 547\\s*A"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 1000000, \"m\");\n    inf.readEoln();\n\n    int mMinusOne = m - 1;\n\n    int h1 = inf.readInt(0, mMinusOne, \"h1\");\n    inf.readSpace();\n    int a1 = inf.readInt(0, mMinusOne, \"a1\");\n    inf.readEoln();\n    ensuref(h1 != a1, \"h1 (%d) should not be equal to a1 (%d)\", h1, a1);\n\n    int x1 = inf.readInt(0, mMinusOne, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, mMinusOne, \"y1\");\n    inf.readEoln();\n\n    int h2 = inf.readInt(0, mMinusOne, \"h2\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, mMinusOne, \"a2\");\n    inf.readEoln();\n    ensuref(h2 != a2, \"h2 (%d) should not be equal to a2 (%d)\", h2, a2);\n\n    int x2 = inf.readInt(0, mMinusOne, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, mMinusOne, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 1000000, \"m\");\n    inf.readEoln();\n\n    int mMinusOne = m - 1;\n\n    int h1 = inf.readInt(0, mMinusOne, \"h1\");\n    inf.readSpace();\n    int a1 = inf.readInt(0, mMinusOne, \"a1\");\n    inf.readEoln();\n    ensuref(h1 != a1, \"h1 (%d) should not be equal to a1 (%d)\", h1, a1);\n\n    int x1 = inf.readInt(0, mMinusOne, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, mMinusOne, \"y1\");\n    inf.readEoln();\n\n    int h2 = inf.readInt(0, mMinusOne, \"h2\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, mMinusOne, \"a2\");\n    inf.readEoln();\n    ensuref(h2 != a2, \"h2 (%d) should not be equal to a2 (%d)\", h2, a2);\n\n    int x2 = inf.readInt(0, mMinusOne, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, mMinusOne, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int m = inf.readInt(2, 1000000, \"m\");\n    inf.readEoln();\n\n    int mMinusOne = m - 1;\n\n    int h1 = inf.readInt(0, mMinusOne, \"h1\");\n    inf.readSpace();\n    int a1 = inf.readInt(0, mMinusOne, \"a1\");\n    inf.readEoln();\n    ensuref(h1 != a1, \"h1 (%d) should not be equal to a1 (%d)\", h1, a1);\n\n    int x1 = inf.readInt(0, mMinusOne, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, mMinusOne, \"y1\");\n    inf.readEoln();\n\n    int h2 = inf.readInt(0, mMinusOne, \"h2\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, mMinusOne, \"a2\");\n    inf.readEoln();\n    ensuref(h2 != a2, \"h2 (%d) should not be equal to a2 (%d)\", h2, a2);\n\n    int x2 = inf.readInt(0, mMinusOne, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, mMinusOne, \"y2\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int h1, a1, x1, y1;\n    int h2, a2, x2, y2;\n\n    if (type == \"random\") {\n        // Random test case\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n    } else if (type == \"never_reaches\") {\n        // Generate sequences that never reach a1 and a2\n        x1 = 0;\n        y1 = rnd.next(0, m - 1);\n        h1 = y1;\n        a1 = (y1 + 1) % m;\n        if (h1 == a1) {\n            a1 = (a1 + 1) % m;\n        }\n        x2 = 0;\n        y2 = rnd.next(0, m - 1);\n        h2 = y2;\n        a2 = (y2 + 1) % m;\n        if (h2 == a2) {\n            a2 = (a2 + 1) % m;\n        }\n    } else if (type == \"small_time\") {\n        // Generate sequences that reach the targets in small time\n        x1 = 1;\n        y1 = rnd.next(1, m - 1);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x2 = 1;\n        y2 = rnd.next(1, m - 1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n    } else if (type == \"large_time\") {\n        // Generate sequences that reach the targets in large time\n        x1 = rnd.next(1, m - 1);\n        y1 = rnd.next(0, m - 1);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x2 = rnd.next(1, m - 1);\n        y2 = rnd.next(0, m - 1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n    } else {\n        // Default to random\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", m);\n    printf(\"%d %d\\n\", h1, a1);\n    printf(\"%d %d\\n\", x1, y1);\n    printf(\"%d %d\\n\", h2, a2);\n    printf(\"%d %d\\n\", x2, y2);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int h1, a1, x1, y1;\n    int h2, a2, x2, y2;\n\n    if (type == \"random\") {\n        // Random test case\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n    } else if (type == \"never_reaches\") {\n        // Generate sequences that never reach a1 and a2\n        x1 = 0;\n        y1 = rnd.next(0, m - 1);\n        h1 = y1;\n        a1 = (y1 + 1) % m;\n        if (h1 == a1) {\n            a1 = (a1 + 1) % m;\n        }\n        x2 = 0;\n        y2 = rnd.next(0, m - 1);\n        h2 = y2;\n        a2 = (y2 + 1) % m;\n        if (h2 == a2) {\n            a2 = (a2 + 1) % m;\n        }\n    } else if (type == \"small_time\") {\n        // Generate sequences that reach the targets in small time\n        x1 = 1;\n        y1 = rnd.next(1, m - 1);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x2 = 1;\n        y2 = rnd.next(1, m - 1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n    } else if (type == \"large_time\") {\n        // Generate sequences that reach the targets in large time\n        x1 = rnd.next(1, m - 1);\n        y1 = rnd.next(0, m - 1);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x2 = rnd.next(1, m - 1);\n        y2 = rnd.next(0, m - 1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n    } else {\n        // Default to random\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", m);\n    printf(\"%d %d\\n\", h1, a1);\n    printf(\"%d %d\\n\", x1, y1);\n    printf(\"%d %d\\n\", h2, a2);\n    printf(\"%d %d\\n\", x2, y2);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 5 -type random\n./gen -m 5 -type never_reaches\n./gen -m 5 -type small_time\n./gen -m 5 -type large_time\n\n./gen -m 10 -type random\n./gen -m 10 -type never_reaches\n./gen -m 10 -type small_time\n./gen -m 10 -type large_time\n\n./gen -m 37 -type random\n./gen -m 37 -type never_reaches\n./gen -m 37 -type small_time\n./gen -m 37 -type large_time\n\n./gen -m 100 -type random\n./gen -m 100 -type never_reaches\n./gen -m 100 -type small_time\n./gen -m 100 -type large_time\n\n./gen -m 1000 -type random\n./gen -m 1000 -type never_reaches\n./gen -m 1000 -type small_time\n./gen -m 1000 -type large_time\n\n./gen -m 10000 -type random\n./gen -m 10000 -type never_reaches\n./gen -m 10000 -type small_time\n./gen -m 10000 -type large_time\n\n./gen -m 100000 -type random\n./gen -m 100000 -type never_reaches\n./gen -m 100000 -type small_time\n./gen -m 100000 -type large_time\n\n./gen -m 999999 -type random\n./gen -m 999999 -type never_reaches\n./gen -m 999999 -type small_time\n./gen -m 999999 -type large_time\n\n./gen -m 1000000 -type random\n./gen -m 1000000 -type never_reaches\n./gen -m 1000000 -type small_time\n./gen -m 1000000 -type large_time\n\n./gen -m 2 -type random\n./gen -m 2 -type never_reaches\n./gen -m 2 -type small_time\n./gen -m 2 -type large_time\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:47.495272",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "547/B",
      "title": "B. Майк и футы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано целое число n (1 ≤ n ≤ 2 × 105), количество медведей.Во второй строке записано n целых чисел, разделенных пробелом, a1, a2, ..., an (1 ≤ ai ≤ 109) — высоты медведей.",
      "output_spec": "Выходные данныеВыведите n целых чисел в одной строке. Для каждого x от 1 до n выведите максимальную силу среди всех групп размера x.",
      "sample_tests": "ПримерыВходные данныеСкопировать101 2 3 4 5 4 3 2 1 6Выходные данныеСкопировать6 4 4 3 3 2 2 1 1 1",
      "description": "B. Майк и футы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано целое число n (1 ≤ n ≤ 2 × 105), количество медведей.Во второй строке записано n целых чисел, разделенных пробелом, a1, a2, ..., an (1 ≤ ai ≤ 109) — высоты медведей.\n\nВходные данные\n\nВыходные данныеВыведите n целых чисел в одной строке. Для каждого x от 1 до n выведите максимальную силу среди всех групп размера x.\n\nВыходные данные\n\nВходные данныеСкопировать101 2 3 4 5 4 3 2 1 6Выходные данныеСкопировать6 4 4 3 3 2 2 1 1 1\n\nВходные данныеСкопировать101 2 3 4 5 4 3 2 1 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6 4 4 3 3 2 2 1 1 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 547\\s*B"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"min\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        // All ai = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000; // 1e9\n        }\n    } else if (type == \"inc\") {\n        // Increasing sequence from 1 to 1e9\n        int max_value = 1000000000; // 1e9\n        int step = max(1, max_value / n);\n        int value = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            value = min(value + step, max_value);\n        }\n    } else if (type == \"dec\") {\n        // Decreasing sequence from 1e9 to 1\n        int max_value = 1000000000; // 1e9\n        int step = max(1, max_value / n);\n        int value = max_value;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            value = max(1, value - step);\n        }\n    } else if (type == \"random\") {\n        // Random sequence between 1 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"zigzag\") {\n        // High and low alternating\n        int low = 1;\n        int high = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = high;\n            else\n                a[i] = low;\n        }\n    } else if (type == \"plateau\") {\n        // Sequences with plateaus\n        int value = rnd.next(1, 1000000000);\n        int plateau_size = max(1, n / 10);\n        int i = 0;\n        while (i < n) {\n            int len = rnd.next(1, plateau_size);\n            len = min(len, n - i);\n            for (int j = 0; j < len; ++j) {\n                a[i++] = value;\n            }\n            value = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"ones_then_max\") {\n        // First half ones, second half max values\n        int half = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < half)\n                a[i] = 1;\n            else\n                a[i] = 1000000000;\n        }\n    } else {\n        // Handle invalid type\n        ensuref(false, \"unknown type %s\", type.c_str());\n    }\n\n    // Output n and then ai\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"min\") {\n        // All ai = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"max\") {\n        // All ai = 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1000000000; // 1e9\n        }\n    } else if (type == \"inc\") {\n        // Increasing sequence from 1 to 1e9\n        int max_value = 1000000000; // 1e9\n        int step = max(1, max_value / n);\n        int value = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            value = min(value + step, max_value);\n        }\n    } else if (type == \"dec\") {\n        // Decreasing sequence from 1e9 to 1\n        int max_value = 1000000000; // 1e9\n        int step = max(1, max_value / n);\n        int value = max_value;\n        for (int i = 0; i < n; ++i) {\n            a[i] = value;\n            value = max(1, value - step);\n        }\n    } else if (type == \"random\") {\n        // Random sequence between 1 and 1e9\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"zigzag\") {\n        // High and low alternating\n        int low = 1;\n        int high = 1000000000;\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = high;\n            else\n                a[i] = low;\n        }\n    } else if (type == \"plateau\") {\n        // Sequences with plateaus\n        int value = rnd.next(1, 1000000000);\n        int plateau_size = max(1, n / 10);\n        int i = 0;\n        while (i < n) {\n            int len = rnd.next(1, plateau_size);\n            len = min(len, n - i);\n            for (int j = 0; j < len; ++j) {\n                a[i++] = value;\n            }\n            value = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"ones_then_max\") {\n        // First half ones, second half max values\n        int half = n / 2;\n        for (int i = 0; i < n; ++i) {\n            if (i < half)\n                a[i] = 1;\n            else\n                a[i] = 1000000000;\n        }\n    } else {\n        // Handle invalid type\n        ensuref(false, \"unknown type %s\", type.c_str());\n    }\n\n    // Output n and then ai\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, various types\n./gen -n 1 -type min\n./gen -n 1 -type max\n./gen -n 1 -type random\n\n# Moderate n, various types\n./gen -n 10 -type min\n./gen -n 10 -type max\n./gen -n 10 -type random\n./gen -n 10 -type inc\n./gen -n 10 -type dec\n./gen -n 10 -type zigzag\n./gen -n 10 -type plateau\n./gen -n 10 -type ones_then_max\n\n# Larger n, various types\n./gen -n 1000 -type min\n./gen -n 1000 -type max\n./gen -n 1000 -type random\n./gen -n 1000 -type inc\n./gen -n 1000 -type dec\n./gen -n 1000 -type zigzag\n./gen -n 1000 -type plateau\n./gen -n 1000 -type ones_then_max\n\n# Near maximum n, various types\n./gen -n 200000 -type min\n./gen -n 200000 -type max\n./gen -n 200000 -type random\n./gen -n 200000 -type inc\n./gen -n 200000 -type dec\n./gen -n 200000 -type zigzag\n./gen -n 200000 -type plateau\n./gen -n 200000 -type ones_then_max\n\n# Edge cases\n./gen -n 2 -type min\n./gen -n 2 -type max\n./gen -n 2 -type random\n\n# Max n, special types\n./gen -n 200000 -type min\n./gen -n 200000 -type max\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:49.787991",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "547/C",
      "title": "C. Mike and Foam",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains numbers n and q (1 ≤ n, q ≤ 2 × 105), the number of different kinds of beer and number of queries.The next line contains n space separated integers, a1, a2, ... , an (1 ≤ ai ≤ 5 × 105), the height of foam in top of each kind of beer.The next q lines contain the queries. Each query consists of a single integer integer x (1 ≤ x ≤ n), the index of a beer that should be added or removed from the shelf.",
      "output_spec": "OutputFor each query, print the answer for that query in one line.",
      "sample_tests": "ExamplesInputCopy5 61 2 3 4 6123451OutputCopy013562",
      "description": "C. Mike and Foam\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains numbers n and q (1 ≤ n, q ≤ 2 × 105), the number of different kinds of beer and number of queries.The next line contains n space separated integers, a1, a2, ... , an (1 ≤ ai ≤ 5 × 105), the height of foam in top of each kind of beer.The next q lines contain the queries. Each query consists of a single integer integer x (1 ≤ x ≤ n), the index of a beer that should be added or removed from the shelf.\n\nOutputFor each query, print the answer for that query in one line.\n\nInputCopy5 61 2 3 4 6123451OutputCopy013562\n\nInputCopy5 61 2 3 4 6123451\n\nOutputCopy013562",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 547\\s*C"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 500000, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < q; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 500000, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < q; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 500000, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < q; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getPrimes(int max_limit) {\n    vector<bool> is_prime(max_limit + 1, true);\n    vector<int> primes;\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= max_limit; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            if (i <= max_limit / i) {\n                for(int j = i * i; j <= max_limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n    }\n    return primes;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> a(n);\n    if (a_type == \"random\") {\n        int max_ai = opt<int>(\"max_ai\", 500000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    } else if (a_type == \"all_ones\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (a_type == \"all_same\") {\n        int same_value = opt<int>(\"same_value\", rnd.next(2, 500000));\n        for(int i = 0; i < n; ++i) {\n            a[i] = same_value;\n        }\n    } else if (a_type == \"primes\") {\n        vector<int> primes = getPrimes(500000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else if (a_type == \"same_factors\") {\n        int max_f = opt<int>(\"max_f\", 1000);\n        int f = rnd.next(2, max_f);\n        int max_ai = 500000 / f;\n        for(int i = 0; i < n; ++i) {\n            a[i] = f * rnd.next(1, max_ai);\n        }\n    } else if (a_type == \"no_common_factors\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            if (a[i] > 500000) a[i] -= 500000;\n        }\n    } else if (a_type == \"incremental\") {\n        int start = opt<int>(\"start\", 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i;\n            if (a[i] > 500000) a[i] = 500000;\n        }\n    } else {\n        // Default to random if unknown type\n        int max_ai = opt<int>(\"max_ai\", 500000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    }\n\n    vector<int> queries(q);\n    if (q_type == \"random\") {\n        for(int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    } else if (q_type == \"add_all_remove_all\") {\n        int idx = 0;\n        while(idx < q) {\n            for(int i = 1; i <= n && idx < q; ++i) {\n                queries[idx++] = i;\n            }\n            for(int i = 1; i <= n && idx < q; ++i) {\n                queries[idx++] = i;\n            }\n        }\n    } else if (q_type == \"toggle_same\") {\n        int x = rnd.next(1, n);\n        for(int i = 0; i < q; ++i) {\n            queries[i] = x;\n        }\n    } else if (q_type == \"sequential\") {\n        int idx = 0;\n        while(idx < q) {\n            for(int i = 1; i <= n && idx < q; ++i) {\n                queries[idx++] = i;\n            }\n        }\n    } else if (q_type == \"reverse_sequential\") {\n        int idx = 0;\n        while(idx < q) {\n            for(int i = n; i >= 1 && idx < q; --i) {\n                queries[idx++] = i;\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, q);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < q; ++i) {\n        printf(\"%d\\n\", queries[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> getPrimes(int max_limit) {\n    vector<bool> is_prime(max_limit + 1, true);\n    vector<int> primes;\n    is_prime[0] = is_prime[1] = false;\n    for(int i = 2; i <= max_limit; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n            if (i <= max_limit / i) {\n                for(int j = i * i; j <= max_limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n    }\n    return primes;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string q_type = opt<string>(\"q_type\", \"random\");\n\n    vector<int> a(n);\n    if (a_type == \"random\") {\n        int max_ai = opt<int>(\"max_ai\", 500000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    } else if (a_type == \"all_ones\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (a_type == \"all_same\") {\n        int same_value = opt<int>(\"same_value\", rnd.next(2, 500000));\n        for(int i = 0; i < n; ++i) {\n            a[i] = same_value;\n        }\n    } else if (a_type == \"primes\") {\n        vector<int> primes = getPrimes(500000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = primes[rnd.next(0, (int)primes.size() - 1)];\n        }\n    } else if (a_type == \"same_factors\") {\n        int max_f = opt<int>(\"max_f\", 1000);\n        int f = rnd.next(2, max_f);\n        int max_ai = 500000 / f;\n        for(int i = 0; i < n; ++i) {\n            a[i] = f * rnd.next(1, max_ai);\n        }\n    } else if (a_type == \"no_common_factors\") {\n        for(int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n            if (a[i] > 500000) a[i] -= 500000;\n        }\n    } else if (a_type == \"incremental\") {\n        int start = opt<int>(\"start\", 1);\n        for(int i = 0; i < n; ++i) {\n            a[i] = start + i;\n            if (a[i] > 500000) a[i] = 500000;\n        }\n    } else {\n        // Default to random if unknown type\n        int max_ai = opt<int>(\"max_ai\", 500000);\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    }\n\n    vector<int> queries(q);\n    if (q_type == \"random\") {\n        for(int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    } else if (q_type == \"add_all_remove_all\") {\n        int idx = 0;\n        while(idx < q) {\n            for(int i = 1; i <= n && idx < q; ++i) {\n                queries[idx++] = i;\n            }\n            for(int i = 1; i <= n && idx < q; ++i) {\n                queries[idx++] = i;\n            }\n        }\n    } else if (q_type == \"toggle_same\") {\n        int x = rnd.next(1, n);\n        for(int i = 0; i < q; ++i) {\n            queries[i] = x;\n        }\n    } else if (q_type == \"sequential\") {\n        int idx = 0;\n        while(idx < q) {\n            for(int i = 1; i <= n && idx < q; ++i) {\n                queries[idx++] = i;\n            }\n        }\n    } else if (q_type == \"reverse_sequential\") {\n        int idx = 0;\n        while(idx < q) {\n            for(int i = n; i >= 1 && idx < q; --i) {\n                queries[idx++] = i;\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for(int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, q);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for(int i = 0; i < q; ++i) {\n        printf(\"%d\\n\", queries[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -a_type all_ones -q_type random\n\n./gen -n 10 -q 10 -a_type random -q_type random\n\n./gen -n 100 -q 50 -a_type all_same -q_type sequential\n\n./gen -n 1000 -q 1000 -a_type primes -q_type reverse_sequential\n\n./gen -n 10000 -q 20000 -a_type same_factors -q_type add_all_remove_all\n\n./gen -n 50000 -q 50000 -a_type no_common_factors -q_type toggle_same\n\n./gen -n 100000 -q 200000 -a_type incremental -q_type random\n\n./gen -n 200000 -q 200000 -a_type random -q_type random\n\n./gen -n 200000 -q 200000 -a_type all_ones -q_type sequential\n\n./gen -n 200000 -q 200000 -a_type all_same -q_type reverse_sequential\n\n./gen -n 200000 -q 200000 -a_type primes -q_type add_all_remove_all\n\n./gen -n 200000 -q 200000 -a_type same_factors -q_type toggle_same\n\n./gen -n 200000 -q 200000 -a_type no_common_factors -q_type sequential\n\n./gen -n 200000 -q 200000 -a_type incremental -q_type reverse_sequential\n\n./gen -n 2 -q 4 -a_type all_ones -q_type toggle_same\n\n./gen -n 3 -q 6 -a_type random -q_type add_all_remove_all\n\n./gen -n 500000 -q 500000 -a_type all_ones -q_type random\n\n./gen -n 5 -q 10 -a_type random -q_type sequential\n\n./gen -n 250000 -q 250000 -a_type same_factors -max_f 2 -q_type random\n\n./gen -n 250000 -q 250000 -a_type same_factors -max_f 100000 -q_type random\n\n./gen -n 100000 -q 100000 -a_type no_common_factors -q_type random\n\n./gen -n 200000 -q 200000 -a_type primes -q_type random\n\n./gen -n 200000 -q 200000 -a_type incremental -q_type add_all_remove_all\n\n./gen -n 200000 -q 200000 -a_type random -q_type toggle_same\n\n./gen -n 200000 -q 200000 -a_type random -q_type random\n\n./gen -n 200000 -q 200000 -a_type random -q_type sequential\n\n./gen -n 200000 -q 200000 -a_type all_same -same_value 500000 -q_type random\n\n./gen -n 200000 -q 200000 -a_type same_factors -max_f 500000 -q_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:51.708394",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "547/D",
      "title": "D. Mike and Fish",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n (1 ≤ n ≤ 2 × 105).The next n lines contain the information about the points, i-th line contains two integers xi and yi (1 ≤ xi, yi ≤ 2 × 105), the i-th point coordinates.It is guaranteed that there is at least one valid answer.",
      "output_spec": "OutputPrint the answer as a sequence of n characters 'r' (for red) or 'b' (for blue) where i-th character denotes the color of the fish in the i-th point.",
      "sample_tests": "ExamplesInputCopy41 11 22 12 2OutputCopybrrbInputCopy31 11 22 1OutputCopybrr",
      "description": "D. Mike and Fish\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integer n (1 ≤ n ≤ 2 × 105).The next n lines contain the information about the points, i-th line contains two integers xi and yi (1 ≤ xi, yi ≤ 2 × 105), the i-th point coordinates.It is guaranteed that there is at least one valid answer.\n\nOutputPrint the answer as a sequence of n characters 'r' (for red) or 'b' (for blue) where i-th character denotes the color of the fish in the i-th point.\n\nInputCopy41 11 22 12 2OutputCopybrrbInputCopy31 11 22 1OutputCopybrr\n\nInputCopy41 11 22 12 2\n\nOutputCopybrrb\n\nInputCopy31 11 22 1\n\nOutputCopybrr",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 547\\s*D"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 200000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 200000, \"yi\");\n        inf.readEoln();\n        ensuref(points.insert({xi, yi}).second, \"Point (%d, %d) is duplicated\", xi, yi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 200000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 200000, \"yi\");\n        inf.readEoln();\n        ensuref(points.insert({xi, yi}).second, \"Point (%d, %d) is duplicated\", xi, yi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 200000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 200000, \"yi\");\n        inf.readEoln();\n        ensuref(points.insert({xi, yi}).second, \"Point (%d, %d) is duplicated\", xi, yi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read n\n    int n = inf.readInt(1, 200000, \"n\");\n    // Read the coordinates\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i) {\n        x[i] = inf.readInt(1, 200000, format(\"x[%d]\", i+1).c_str());\n        y[i] = inf.readInt(1, 200000, format(\"y[%d]\", i+1).c_str());\n    }\n    \n    // Read the contestant's output\n    string s = ouf.readToken();\n    if ((int)s.size() != n)\n        quitf(_wa, \"Output length is %d, but expected %d\", (int)s.size(), n);\n    \n    // Check that all characters are 'r' or 'b'\n    for (int i = 0; i < n; ++i) {\n        if (s[i] != 'r' && s[i] != 'b')\n            quitf(_wa, \"Invalid character '%c' at position %d\", s[i], i+1);\n    }\n    \n    // Build mappings from x and y to indices\n    map<int, vector<int>> x_points, y_points;\n    for (int i = 0; i < n; ++i) {\n        x_points[x[i]].push_back(i);\n        y_points[y[i]].push_back(i);\n    }\n    \n    // For each x coordinate, check the counts\n    for (auto& p : x_points) {\n        int reds = 0, blues = 0;\n        for (int idx : p.second) {\n            if (s[idx] == 'r')\n                ++reds;\n            else\n                ++blues;\n        }\n        if (abs(reds - blues) > 1)\n            quitf(_wa, \"On vertical line x=%d, difference between reds and blues is %d (>1)\", p.first, abs(reds - blues));\n    }\n    \n    // For each y coordinate, check the counts\n    for (auto& p : y_points) {\n        int reds = 0, blues = 0;\n        for (int idx : p.second) {\n            if (s[idx] == 'r')\n                ++reds;\n            else\n                ++blues;\n        }\n        if (abs(reds - blues) > 1)\n            quitf(_wa, \"On horizontal line y=%d, difference between reds and blues is %d (>1)\", p.first, abs(reds - blues));\n    }\n    \n    // All constraints satisfied\n    quitf(_ok, \"Valid answer\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> points;  // store points\n\n    if (type == \"random\") {\n        // Generate n random distinct points\n        std::unordered_set<long long> used_points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            int y = rnd.next(1, 200000);\n            long long key = ((long long)x << 20) | y;\n            if (used_points.insert(key).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"horizontal_line\") {\n        int y = rnd.next(1, 200000);\n        // Generate n distinct x-coordinates\n        std::set<int> used_x;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            if (used_x.insert(x).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"vertical_line\") {\n        int x = rnd.next(1, 200000);\n        // Generate n distinct y-coordinates\n        std::set<int> used_y;\n        while ((int)points.size() < n) {\n            int y = rnd.next(1, 200000);\n            if (used_y.insert(y).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"grid\") {\n        // Decide grid dimensions\n        int h = sqrt(n);\n        while (h * h < n) h++;\n        std::vector<int> xs(h), ys(h);\n        for (int i = 0; i < h; ++i) xs[i] = rnd.next(1, 200000);\n        for (int i = 0; i < h; ++i) ys[i] = rnd.next(1, 200000);\n        std::sort(xs.begin(), xs.end());\n        xs.erase(unique(xs.begin(), xs.end()), xs.end());\n        std::sort(ys.begin(), ys.end());\n        ys.erase(unique(ys.begin(), ys.end()), ys.end());\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        for (int i = 0; i < (int)xs.size() && (int)points.size() < n; ++i) {\n            for (int j = 0; j < (int)ys.size() && (int)points.size() < n; ++j) {\n                points.emplace_back(xs[i], ys[j]);\n            }\n        }\n        while ((int)points.size() > n) {\n            points.pop_back();\n        }\n    } else if (type == \"diagonal\") {\n        std::set<int> used_xy;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            if (used_xy.insert(x).second) {\n                points.emplace_back(x, x);\n            }\n        }\n    } else if (type == \"sparse\") {\n        // Generate unique x and y values\n        std::vector<int> xs(200000), ys(200000);\n        std::iota(xs.begin(), xs.end(), 1);\n        std::iota(ys.begin(), ys.end(), 1);\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        for (int i = 0; i < n; ++i) {\n            points.emplace_back(xs[i], ys[i]);\n        }\n    } else if (type == \"max_coordinate\") {\n        // Generate points with maximum coordinates\n        for (int i = 0; i < n; ++i) {\n            int x = 200000 - i;\n            int y = 200000 - i;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"cluster\") {\n        // Generate clustered points\n        int clusters = 10;\n        int cluster_size = n / clusters;\n        for (int c = 0; c < clusters; ++c) {\n            int cx = rnd.next(1, 200000);\n            int cy = rnd.next(1, 200000);\n            std::set<pair<int, int>> used_points;\n            for (int i = 0; i < cluster_size && (int)points.size() < n; ++i) {\n                int x = cx + rnd.next(-10, 10);\n                int y = cy + rnd.next(-10, 10);\n                if (x >= 1 && x <= 200000 && y >= 1 && y <= 200000) {\n                    if (used_points.insert({x, y}).second) {\n                        points.emplace_back(x, y);\n                    }\n                }\n            }\n        }\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            int y = rnd.next(1, 200000);\n            if (std::find(points.begin(), points.end(), make_pair(x, y)) == points.end()) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        std::unordered_set<long long> used_points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            int y = rnd.next(1, 200000);\n            long long key = ((long long)x << 20) | y;\n            if (used_points.insert(key).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> points;  // store points\n\n    if (type == \"random\") {\n        // Generate n random distinct points\n        std::unordered_set<long long> used_points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            int y = rnd.next(1, 200000);\n            long long key = ((long long)x << 20) | y;\n            if (used_points.insert(key).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"horizontal_line\") {\n        int y = rnd.next(1, 200000);\n        // Generate n distinct x-coordinates\n        std::set<int> used_x;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            if (used_x.insert(x).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"vertical_line\") {\n        int x = rnd.next(1, 200000);\n        // Generate n distinct y-coordinates\n        std::set<int> used_y;\n        while ((int)points.size() < n) {\n            int y = rnd.next(1, 200000);\n            if (used_y.insert(y).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"grid\") {\n        // Decide grid dimensions\n        int h = sqrt(n);\n        while (h * h < n) h++;\n        std::vector<int> xs(h), ys(h);\n        for (int i = 0; i < h; ++i) xs[i] = rnd.next(1, 200000);\n        for (int i = 0; i < h; ++i) ys[i] = rnd.next(1, 200000);\n        std::sort(xs.begin(), xs.end());\n        xs.erase(unique(xs.begin(), xs.end()), xs.end());\n        std::sort(ys.begin(), ys.end());\n        ys.erase(unique(ys.begin(), ys.end()), ys.end());\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        for (int i = 0; i < (int)xs.size() && (int)points.size() < n; ++i) {\n            for (int j = 0; j < (int)ys.size() && (int)points.size() < n; ++j) {\n                points.emplace_back(xs[i], ys[j]);\n            }\n        }\n        while ((int)points.size() > n) {\n            points.pop_back();\n        }\n    } else if (type == \"diagonal\") {\n        std::set<int> used_xy;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            if (used_xy.insert(x).second) {\n                points.emplace_back(x, x);\n            }\n        }\n    } else if (type == \"sparse\") {\n        // Generate unique x and y values\n        std::vector<int> xs(200000), ys(200000);\n        std::iota(xs.begin(), xs.end(), 1);\n        std::iota(ys.begin(), ys.end(), 1);\n        shuffle(xs.begin(), xs.end());\n        shuffle(ys.begin(), ys.end());\n        for (int i = 0; i < n; ++i) {\n            points.emplace_back(xs[i], ys[i]);\n        }\n    } else if (type == \"max_coordinate\") {\n        // Generate points with maximum coordinates\n        for (int i = 0; i < n; ++i) {\n            int x = 200000 - i;\n            int y = 200000 - i;\n            points.emplace_back(x, y);\n        }\n    } else if (type == \"cluster\") {\n        // Generate clustered points\n        int clusters = 10;\n        int cluster_size = n / clusters;\n        for (int c = 0; c < clusters; ++c) {\n            int cx = rnd.next(1, 200000);\n            int cy = rnd.next(1, 200000);\n            std::set<pair<int, int>> used_points;\n            for (int i = 0; i < cluster_size && (int)points.size() < n; ++i) {\n                int x = cx + rnd.next(-10, 10);\n                int y = cy + rnd.next(-10, 10);\n                if (x >= 1 && x <= 200000 && y >= 1 && y <= 200000) {\n                    if (used_points.insert({x, y}).second) {\n                        points.emplace_back(x, y);\n                    }\n                }\n            }\n        }\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            int y = rnd.next(1, 200000);\n            if (std::find(points.begin(), points.end(), make_pair(x, y)) == points.end()) {\n                points.emplace_back(x, y);\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        std::unordered_set<long long> used_points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(1, 200000);\n            int y = rnd.next(1, 200000);\n            long long key = ((long long)x << 20) | y;\n            if (used_points.insert(key).second) {\n                points.emplace_back(x, y);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (auto p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n (n = 1)\n./gen -n 1 -type random\n./gen -n 1 -type horizontal_line\n./gen -n 1 -type vertical_line\n./gen -n 1 -type grid\n./gen -n 1 -type diagonal\n./gen -n 1 -type max_coordinate\n\n# Small n (n = 2)\n./gen -n 2 -type random\n./gen -n 2 -type horizontal_line\n./gen -n 2 -type vertical_line\n./gen -n 2 -type grid\n./gen -n 2 -type diagonal\n./gen -n 2 -type sparse\n./gen -n 2 -type cluster\n./gen -n 2 -type max_coordinate\n\n# Moderate n (n = 1000)\n./gen -n 1000 -type random\n./gen -n 1000 -type horizontal_line\n./gen -n 1000 -type vertical_line\n./gen -n 1000 -type grid\n./gen -n 1000 -type diagonal\n./gen -n 1000 -type sparse\n./gen -n 1000 -type cluster\n./gen -n 1000 -type max_coordinate\n\n# Large n (n = 200000)\n./gen -n 200000 -type random\n./gen -n 200000 -type horizontal_line\n./gen -n 200000 -type vertical_line\n./gen -n 200000 -type grid\n./gen -n 200000 -type diagonal\n./gen -n 200000 -type sparse\n./gen -n 200000 -type cluster\n./gen -n 200000 -type max_coordinate\n\n# Additional varied tests\n./gen -n 50000 -type random\n./gen -n 50000 -type cluster\n./gen -n 199999 -type diagonal\n./gen -n 123456 -type sparse\n./gen -n 200000 -type max_coordinate\n./gen -n 200000 -type random\n./gen -n 100000 -type horizontal_line\n./gen -n 100000 -type vertical_line\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:53.804169",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "547/E",
      "title": "E. Mike and Friends",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integers n and q (1 ≤ n ≤ 2 × 105 and 1 ≤ q ≤ 5 × 105).The next n lines contain the phone numbers, i-th line contains a string si consisting of lowercase English letters ().The next q lines contain the information about the questions, each of them contains integers l, r and k (1 ≤ l ≤ r ≤ n and 1 ≤ k ≤ n).",
      "output_spec": "OutputPrint the answer for each question in a separate line.",
      "sample_tests": "ExamplesInputCopy5 5aababababababb1 5 13 5 11 5 21 5 31 4 5OutputCopy75636",
      "description": "E. Mike and Friends\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integers n and q (1 ≤ n ≤ 2 × 105 and 1 ≤ q ≤ 5 × 105).The next n lines contain the phone numbers, i-th line contains a string si consisting of lowercase English letters ().The next q lines contain the information about the questions, each of them contains integers l, r and k (1 ≤ l ≤ r ≤ n and 1 ≤ k ≤ n).\n\nOutputPrint the answer for each question in a separate line.\n\nInputCopy5 5aababababababb1 5 13 5 11 5 21 5 31 4 5OutputCopy75636\n\nInputCopy5 5aababababababb1 5 13 5 11 5 21 5 31 4 5\n\nOutputCopy75636",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 547\\s*E"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(\"[a-z]{1,100000}\", \"s_i\");\n        inf.readEoln();\n        total_length += s.length();\n    }\n    ensuref(total_length <= 2000000, \"Total length of s_i should not exceed 2000000, but is %lld\", total_length);\n\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(\"[a-z]{1,100000}\", \"s_i\");\n        inf.readEoln();\n        total_length += s.length();\n    }\n    ensuref(total_length <= 2000000, \"Total length of s_i should not exceed 2000000, but is %lld\", total_length);\n\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 500000, \"q\");\n    inf.readEoln();\n\n    long long total_length = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readToken(\"[a-z]{1,100000}\", \"s_i\");\n        inf.readEoln();\n        total_length += s.length();\n    }\n    ensuref(total_length <= 2000000, \"Total length of s_i should not exceed 2000000, but is %lld\", total_length);\n\n    for (int i = 0; i < q; ++i) {\n        int l = inf.readInt(1, n, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r_i\");\n        inf.readSpace();\n        int k = inf.readInt(1, n, \"k_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"What-The-Fatherland\" problem.\n\n  This generator will produce:\n  1) n, q\n  2) n phone numbers (strings of lowercase English letters)\n  3) q queries, each consisting of integers (l, r, k)\n\n  Constraints to keep in mind:\n  - 1 <= n <= 2 * 10^5\n  - 1 <= q <= 5 * 10^5\n  - Each phone number consists of lowercase English letters.\n  - The sum of lengths of all phone numbers should not exceed ~10^6\n    (safe limit inferred from the provided solution's memory constraints).\n  - 1 <= l <= r <= n\n  - 1 <= k <= n\n\n  We provide different \"types\" of test generation via the -type parameter.\n  You can control:\n  - n: number of phone numbers\n  - q: number of queries\n  - alpha: number of distinct letters allowed (from 'a' to 'a'+alpha-1)\n  - maxLen: maximum length of each phone number\n  - type: how to generate the phone numbers\n  - qtype: how to generate the queries\n*/\n\nstatic string genRandomString(int len, int alpha) {\n    string s;\n    s.resize(len);\n    for (int i = 0; i < len; i++) {\n        // characters from 'a' to 'a' + alpha - 1\n        s[i] = char('a' + rnd.next(alpha));\n    }\n    return s;\n}\n\nstatic vector<string> makeAllSameStrings(int n, int len, int alpha) {\n    // Generate a single random string of length len, then duplicate it\n    // for all n phone numbers.\n    string base = genRandomString(len, alpha);\n    vector<string> phones(n, base);\n    return phones;\n}\n\nstatic vector<string> makeAscendingPrefixStrings(int n, int maxLen, int alpha) {\n    // Each phone number is (roughly) a prefix of the next, with small variations\n    // to ensure not all are identical. This can catch mistakes in substring logic.\n    // We'll ensure total length does not blow up too large.\n    vector<string> phones(n);\n    // Generate a base string\n    int baseLen = rnd.next(1, maxLen);\n    string baseStr = genRandomString(baseLen, alpha);\n\n    phones[0] = baseStr;\n    for (int i = 1; i < n; i++) {\n        // With some probability, extend or slightly modify the previous string\n        if (rnd.next(2) == 0 && (int)phones[i-1].size() < maxLen) {\n            // Extend\n            phones[i] = phones[i-1] + char('a' + rnd.next(alpha));\n        } else {\n            // Slightly modify\n            phones[i] = phones[i-1];\n            if (!phones[i].empty()) {\n                int pos = rnd.next((int)phones[i].size());\n                phones[i][pos] = char('a' + rnd.next(alpha));\n            }\n        }\n    }\n    return phones;\n}\n\nstatic vector<string> makeRandomStrings(int n, int maxLen, int alpha) {\n    // Each phone number is purely random, length in [1..maxLen].\n    vector<string> phones(n);\n    for (int i = 0; i < n; i++) {\n        int len = rnd.next(1, maxLen);\n        phones[i] = genRandomString(len, alpha);\n    }\n    return phones;\n}\n\nstatic long long totalLength(const vector<string> &phones) {\n    long long sumLen = 0;\n    for (auto &p : phones) {\n        sumLen += p.size();\n    }\n    return sumLen;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    int n       = opt<int>(\"n\", 10);         // number of phone numbers\n    int q       = opt<int>(\"q\", 10);         // number of queries\n    int alpha   = opt<int>(\"alpha\", 26);     // alphabet size (1..26)\n    int maxLen  = opt<int>(\"maxLen\", 10);    // max length for each phone number\n    string type = opt<string>(\"type\", \"random\");   // how to generate phone numbers\n    string qtype= opt<string>(\"qtype\", \"random\");  // how to generate queries\n\n    // Generate phone numbers\n    vector<string> phones;\n    if (type == \"same\") {\n        // all phone numbers are identical\n        // length = random in [1, maxLen]\n        int len = rnd.next(1, maxLen);\n        phones = makeAllSameStrings(n, len, alpha);\n    } \n    else if (type == \"prefix\") {\n        // ascending prefix strings with possible modifications\n        phones = makeAscendingPrefixStrings(n, maxLen, alpha);\n    }\n    else {\n        // default: random strings\n        phones = makeRandomStrings(n, maxLen, alpha);\n    }\n\n    // Ensure total length is within a safe limit\n    // If it is too large, we can forcibly reduce lengths or simply exit(1).\n    // For demonstration, we'll just do a simple check:\n    if (totalLength(phones) > 1000000LL) {\n        // In real usage, you might handle this differently,\n        // but here we'll just show a message and adjust lengths forcibly\n        // to keep them within the sum limit.\n        long long over = totalLength(phones) - 1000000LL;\n        // Simple approach: reduce from the largest strings\n        // (This is just a fallback mechanism, so we don't produce out-of-bounds data)\n        for (int i = n - 1; i >= 0 && over > 0; i--) {\n            int oldSize = (int)phones[i].size();\n            if (oldSize > 1) {\n                int reduceBy = min<long long>(oldSize - 1, over);\n                phones[i].resize(oldSize - reduceBy);\n                over -= reduceBy;\n            }\n        }\n    }\n\n    // Generate queries\n    // Each query is l, r, k with 1 <= l <= r <= n and 1 <= k <= n\n    vector<array<int,3>> queries(q);\n    if (qtype == \"allrange\") {\n        // All queries cover the entire range [1..n].\n        // k is random in [1..n].\n        for (int i = 0; i < q; i++) {\n            queries[i] = {1, n, rnd.next(1, n)};\n        }\n    }\n    else if (qtype == \"smallrange\") {\n        // small subranges\n        // about half queries where l = r, half random\n        for (int i = 0; i < q; i++) {\n            if (rnd.next(2) == 0) {\n                int pos = rnd.next(1, n);\n                queries[i] = {pos, pos, rnd.next(1, n)};\n            } else {\n                int l = rnd.next(1, n);\n                int r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n                queries[i] = {l, r, rnd.next(1, n)};\n            }\n        }\n    }\n    else {\n        // default: random queries\n        for (int i = 0; i < q; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int k = rnd.next(1, n);\n            queries[i] = {l, r, k};\n        }\n    }\n\n    // Output\n    // 1) n, q\n    // 2) n phone numbers\n    // 3) q queries\n    printf(\"%d %d\\n\", n, q);\n    for (auto &p : phones) {\n        printf(\"%s\\n\", p.c_str());\n    }\n    for (auto &arr : queries) {\n        printf(\"%d %d %d\\n\", arr[0], arr[1], arr[2]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Generator for the \"What-The-Fatherland\" problem.\n\n  This generator will produce:\n  1) n, q\n  2) n phone numbers (strings of lowercase English letters)\n  3) q queries, each consisting of integers (l, r, k)\n\n  Constraints to keep in mind:\n  - 1 <= n <= 2 * 10^5\n  - 1 <= q <= 5 * 10^5\n  - Each phone number consists of lowercase English letters.\n  - The sum of lengths of all phone numbers should not exceed ~10^6\n    (safe limit inferred from the provided solution's memory constraints).\n  - 1 <= l <= r <= n\n  - 1 <= k <= n\n\n  We provide different \"types\" of test generation via the -type parameter.\n  You can control:\n  - n: number of phone numbers\n  - q: number of queries\n  - alpha: number of distinct letters allowed (from 'a' to 'a'+alpha-1)\n  - maxLen: maximum length of each phone number\n  - type: how to generate the phone numbers\n  - qtype: how to generate the queries\n*/\n\nstatic string genRandomString(int len, int alpha) {\n    string s;\n    s.resize(len);\n    for (int i = 0; i < len; i++) {\n        // characters from 'a' to 'a' + alpha - 1\n        s[i] = char('a' + rnd.next(alpha));\n    }\n    return s;\n}\n\nstatic vector<string> makeAllSameStrings(int n, int len, int alpha) {\n    // Generate a single random string of length len, then duplicate it\n    // for all n phone numbers.\n    string base = genRandomString(len, alpha);\n    vector<string> phones(n, base);\n    return phones;\n}\n\nstatic vector<string> makeAscendingPrefixStrings(int n, int maxLen, int alpha) {\n    // Each phone number is (roughly) a prefix of the next, with small variations\n    // to ensure not all are identical. This can catch mistakes in substring logic.\n    // We'll ensure total length does not blow up too large.\n    vector<string> phones(n);\n    // Generate a base string\n    int baseLen = rnd.next(1, maxLen);\n    string baseStr = genRandomString(baseLen, alpha);\n\n    phones[0] = baseStr;\n    for (int i = 1; i < n; i++) {\n        // With some probability, extend or slightly modify the previous string\n        if (rnd.next(2) == 0 && (int)phones[i-1].size() < maxLen) {\n            // Extend\n            phones[i] = phones[i-1] + char('a' + rnd.next(alpha));\n        } else {\n            // Slightly modify\n            phones[i] = phones[i-1];\n            if (!phones[i].empty()) {\n                int pos = rnd.next((int)phones[i].size());\n                phones[i][pos] = char('a' + rnd.next(alpha));\n            }\n        }\n    }\n    return phones;\n}\n\nstatic vector<string> makeRandomStrings(int n, int maxLen, int alpha) {\n    // Each phone number is purely random, length in [1..maxLen].\n    vector<string> phones(n);\n    for (int i = 0; i < n; i++) {\n        int len = rnd.next(1, maxLen);\n        phones[i] = genRandomString(len, alpha);\n    }\n    return phones;\n}\n\nstatic long long totalLength(const vector<string> &phones) {\n    long long sumLen = 0;\n    for (auto &p : phones) {\n        sumLen += p.size();\n    }\n    return sumLen;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parameters\n    int n       = opt<int>(\"n\", 10);         // number of phone numbers\n    int q       = opt<int>(\"q\", 10);         // number of queries\n    int alpha   = opt<int>(\"alpha\", 26);     // alphabet size (1..26)\n    int maxLen  = opt<int>(\"maxLen\", 10);    // max length for each phone number\n    string type = opt<string>(\"type\", \"random\");   // how to generate phone numbers\n    string qtype= opt<string>(\"qtype\", \"random\");  // how to generate queries\n\n    // Generate phone numbers\n    vector<string> phones;\n    if (type == \"same\") {\n        // all phone numbers are identical\n        // length = random in [1, maxLen]\n        int len = rnd.next(1, maxLen);\n        phones = makeAllSameStrings(n, len, alpha);\n    } \n    else if (type == \"prefix\") {\n        // ascending prefix strings with possible modifications\n        phones = makeAscendingPrefixStrings(n, maxLen, alpha);\n    }\n    else {\n        // default: random strings\n        phones = makeRandomStrings(n, maxLen, alpha);\n    }\n\n    // Ensure total length is within a safe limit\n    // If it is too large, we can forcibly reduce lengths or simply exit(1).\n    // For demonstration, we'll just do a simple check:\n    if (totalLength(phones) > 1000000LL) {\n        // In real usage, you might handle this differently,\n        // but here we'll just show a message and adjust lengths forcibly\n        // to keep them within the sum limit.\n        long long over = totalLength(phones) - 1000000LL;\n        // Simple approach: reduce from the largest strings\n        // (This is just a fallback mechanism, so we don't produce out-of-bounds data)\n        for (int i = n - 1; i >= 0 && over > 0; i--) {\n            int oldSize = (int)phones[i].size();\n            if (oldSize > 1) {\n                int reduceBy = min<long long>(oldSize - 1, over);\n                phones[i].resize(oldSize - reduceBy);\n                over -= reduceBy;\n            }\n        }\n    }\n\n    // Generate queries\n    // Each query is l, r, k with 1 <= l <= r <= n and 1 <= k <= n\n    vector<array<int,3>> queries(q);\n    if (qtype == \"allrange\") {\n        // All queries cover the entire range [1..n].\n        // k is random in [1..n].\n        for (int i = 0; i < q; i++) {\n            queries[i] = {1, n, rnd.next(1, n)};\n        }\n    }\n    else if (qtype == \"smallrange\") {\n        // small subranges\n        // about half queries where l = r, half random\n        for (int i = 0; i < q; i++) {\n            if (rnd.next(2) == 0) {\n                int pos = rnd.next(1, n);\n                queries[i] = {pos, pos, rnd.next(1, n)};\n            } else {\n                int l = rnd.next(1, n);\n                int r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n                queries[i] = {l, r, rnd.next(1, n)};\n            }\n        }\n    }\n    else {\n        // default: random queries\n        for (int i = 0; i < q; i++) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(1, n);\n            if (l > r) swap(l, r);\n            int k = rnd.next(1, n);\n            queries[i] = {l, r, k};\n        }\n    }\n\n    // Output\n    // 1) n, q\n    // 2) n phone numbers\n    // 3) q queries\n    printf(\"%d %d\\n\", n, q);\n    for (auto &p : phones) {\n        printf(\"%s\\n\", p.c_str());\n    }\n    for (auto &arr : queries) {\n        printf(\"%d %d %d\\n\", arr[0], arr[1], arr[2]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are approximately 20-30 sample commands to generate a variety of tests.\n# Each command prints one test case to standard output (without redirection).\n\n# Small tests\n./gen -n 1 -q 1 -alpha 1 -maxLen 1 -type random -qtype random\n./gen -n 2 -q 3 -alpha 2 -maxLen 2 -type same -qtype allrange\n./gen -n 5 -q 5 -alpha 3 -maxLen 3 -type prefix -qtype smallrange\n./gen -n 5 -q 5 -alpha 3 -maxLen 5 -type same -qtype random\n\n# Medium tests\n./gen -n 10 -q 10 -alpha 4 -maxLen 5 -type random -qtype random\n./gen -n 10 -q 10 -alpha 2 -maxLen 10 -type prefix -qtype allrange\n./gen -n 20 -q 20 -alpha 2 -maxLen 5 -type same -qtype smallrange\n./gen -n 30 -q 30 -alpha 5 -maxLen 10 -type random -qtype random\n\n# Larger tests with various types\n./gen -n 50 -q 50 -alpha 4 -maxLen 12 -type prefix -qtype random\n./gen -n 50 -q 100 -alpha 6 -maxLen 20 -type random -qtype smallrange\n./gen -n 100 -q 100 -alpha 3 -maxLen 15 -type same -qtype allrange\n./gen -n 100 -q 300 -alpha 6 -maxLen 10 -type random -qtype random\n./gen -n 200 -q 200 -alpha 2 -maxLen 10 -type prefix -qtype random\n\n# Even bigger tests (make sure sum of lengths is still within ~1e6)\n./gen -n 1000 -q 1000 -alpha 5 -maxLen 50 -type random -qtype random\n./gen -n 2000 -q 2000 -alpha 3 -maxLen 20 -type prefix -qtype smallrange\n./gen -n 3000 -q 5000 -alpha 4 -maxLen 15 -type random -qtype allrange\n\n# Very large n with small maxLen (so total length ~ n * maxLen <= 1e6)\n./gen -n 50000 -q 50000 -alpha 2 -maxLen 5 -type random -qtype random\n./gen -n 50000 -q 100000 -alpha 3 -maxLen 2 -type same -qtype random\n./gen -n 100000 -q 100000 -alpha 2 -maxLen 2 -type prefix -qtype allrange\n./gen -n 200000 -q 500000 -alpha 2 -maxLen 1 -type random -qtype smallrange\n\n# A couple more mixed variants for broader coverage\n./gen -n 50 -q 500 -alpha 6 -maxLen 10 -type same -qtype random\n./gen -n 100 -q 500 -alpha 4 -maxLen 5 -type prefix -qtype smallrange\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:55.739902",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "548/A",
      "title": "A. Mike and Fax",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains string s containing lowercase English letters (1 ≤ |s| ≤ 1000).The second line contains integer k (1 ≤ k ≤ 1000).",
      "output_spec": "OutputPrint \"YES\"(without quotes) if he has worn his own back-bag or \"NO\"(without quotes) otherwise.",
      "sample_tests": "ExamplesInputCopysaba2OutputCopyNOInputCopysaddastavvat2OutputCopyYES",
      "description": "A. Mike and Fax\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains string s containing lowercase English letters (1 ≤ |s| ≤ 1000).The second line contains integer k (1 ≤ k ≤ 1000).\n\nOutputPrint \"YES\"(without quotes) if he has worn his own back-bag or \"NO\"(without quotes) otherwise.\n\nInputCopysaba2OutputCopyNOInputCopysaddastavvat2OutputCopyYES\n\nInputCopysaba2\n\nOutputCopyNO\n\nInputCopysaddastavvat2\n\nOutputCopyYES\n\nNotePalindrome is a string reading the same forward and backward.In the second sample, the faxes in his back-bag can be \"saddas\" and \"tavvat\".",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 548\\s*A"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[a-z]{1,1000}\", \"s\");\n    inf.readEoln();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[a-z]{1,1000}\", \"s\");\n    inf.readEoln();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readToken(\"[a-z]{1,1000}\", \"s\");\n    inf.readEoln();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool is_palindrome(const string& s) {\n    int n = s.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (s[i] != s[n - i -1]) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Length of string s\n    int k = opt<int>(\"k\"); // Number of substrings\n    string type = opt<string>(\"type\", \"positive\"); // Type of test case\n\n    if (type == \"positive\") {\n        // Generate a positive test case where s can be divided into k palindromic substrings of equal length\n        if (n % k != 0) {\n            cerr << \"In positive type, n should be divisible by k\" << endl;\n            exit(1);\n        }\n        int len = n / k;\n        string s = \"\";\n        for (int i = 0; i < k; ++i) {\n            string pal;\n            if (len == 1) {\n                pal += (char)('a' + rnd.next(26));\n            } else {\n                string half = \"\";\n                for (int j = 0; j < len / 2; ++j) {\n                    half += (char)('a' + rnd.next(26));\n                }\n                pal = half;\n                if (len % 2 == 1) {\n                    pal += (char)('a' + rnd.next(26));\n                }\n                reverse(half.begin(), half.end());\n                pal += half;\n            }\n            s += pal;\n        }\n        assert((int)s.size() == n);\n        cout << s << endl;\n        cout << k << endl;\n    } else if (type == \"not_divisible\") {\n        // Generate a negative test case where s length is not divisible by k\n        if (n % k == 0) {\n            // Adjust n to not be divisible by k\n            if (n < 1000) {\n                n += 1;\n            } else if (n > 1) {\n                n -= 1;\n            } else {\n                cerr << \"Cannot adjust n to not divisible by k\" << endl;\n                exit(1);\n            }\n        }\n        string s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n        assert((int)s.size() == n);\n        cout << s << endl;\n        cout << k << endl;\n    } else if (type == \"not_palindromes\") {\n        // Generate a negative test case where substrings are not palindromic\n        if (n % k != 0) {\n            cerr << \"In not_palindromes type, n should be divisible by k\" << endl;\n            exit(1);\n        }\n        int len = n / k;\n        if (len == 1) {\n            // All substrings of length 1 are palindromes, adjust n to make len >= 2\n            if (n >= 2 * k && 2 * k <= 1000) {\n                n = 2 * k;\n                len = n / k;\n            } else {\n                cerr << \"Cannot adjust len to greater than 1 without exceeding constraints\" << endl;\n                exit(1);\n            }\n        }\n        if (len < 2) {\n            cerr << \"Cannot generate non-palindromic substrings of length less than 2\" << endl;\n            exit(1);\n        }\n        string s = \"\";\n        for (int i = 0; i < k; ++i) {\n            string w = \"\";\n            do {\n                w = \"\";\n                for (int j = 0; j < len; ++j) {\n                    w += (char)('a' + rnd.next(26));\n                }\n            } while (is_palindrome(w));\n            s += w;\n        }\n        assert((int)s.size() == n);\n        cout << s << endl;\n        cout << k << endl;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nbool is_palindrome(const string& s) {\n    int n = s.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (s[i] != s[n - i -1]) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Length of string s\n    int k = opt<int>(\"k\"); // Number of substrings\n    string type = opt<string>(\"type\", \"positive\"); // Type of test case\n\n    if (type == \"positive\") {\n        // Generate a positive test case where s can be divided into k palindromic substrings of equal length\n        if (n % k != 0) {\n            cerr << \"In positive type, n should be divisible by k\" << endl;\n            exit(1);\n        }\n        int len = n / k;\n        string s = \"\";\n        for (int i = 0; i < k; ++i) {\n            string pal;\n            if (len == 1) {\n                pal += (char)('a' + rnd.next(26));\n            } else {\n                string half = \"\";\n                for (int j = 0; j < len / 2; ++j) {\n                    half += (char)('a' + rnd.next(26));\n                }\n                pal = half;\n                if (len % 2 == 1) {\n                    pal += (char)('a' + rnd.next(26));\n                }\n                reverse(half.begin(), half.end());\n                pal += half;\n            }\n            s += pal;\n        }\n        assert((int)s.size() == n);\n        cout << s << endl;\n        cout << k << endl;\n    } else if (type == \"not_divisible\") {\n        // Generate a negative test case where s length is not divisible by k\n        if (n % k == 0) {\n            // Adjust n to not be divisible by k\n            if (n < 1000) {\n                n += 1;\n            } else if (n > 1) {\n                n -= 1;\n            } else {\n                cerr << \"Cannot adjust n to not divisible by k\" << endl;\n                exit(1);\n            }\n        }\n        string s = \"\";\n        for (int i = 0; i < n; ++i) {\n            s += (char)('a' + rnd.next(26));\n        }\n        assert((int)s.size() == n);\n        cout << s << endl;\n        cout << k << endl;\n    } else if (type == \"not_palindromes\") {\n        // Generate a negative test case where substrings are not palindromic\n        if (n % k != 0) {\n            cerr << \"In not_palindromes type, n should be divisible by k\" << endl;\n            exit(1);\n        }\n        int len = n / k;\n        if (len == 1) {\n            // All substrings of length 1 are palindromes, adjust n to make len >= 2\n            if (n >= 2 * k && 2 * k <= 1000) {\n                n = 2 * k;\n                len = n / k;\n            } else {\n                cerr << \"Cannot adjust len to greater than 1 without exceeding constraints\" << endl;\n                exit(1);\n            }\n        }\n        if (len < 2) {\n            cerr << \"Cannot generate non-palindromic substrings of length less than 2\" << endl;\n            exit(1);\n        }\n        string s = \"\";\n        for (int i = 0; i < k; ++i) {\n            string w = \"\";\n            do {\n                w = \"\";\n                for (int j = 0; j < len; ++j) {\n                    w += (char)('a' + rnd.next(26));\n                }\n            } while (is_palindrome(w));\n            s += w;\n        }\n        assert((int)s.size() == n);\n        cout << s << endl;\n        cout << k << endl;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Positive test cases\n./gen -n 1 -k 1 -type positive\n./gen -n 2 -k 1 -type positive\n./gen -n 4 -k 2 -type positive\n./gen -n 10 -k 5 -type positive\n./gen -n 10 -k 2 -type positive\n./gen -n 100 -k 10 -type positive\n./gen -n 100 -k 25 -type positive\n./gen -n 1000 -k 1 -type positive\n./gen -n 1000 -k 2 -type positive\n./gen -n 1000 -k 4 -type positive\n./gen -n 1000 -k 10 -type positive\n./gen -n 1000 -k 250 -type positive\n./gen -n 1000 -k 500 -type positive\n\n# Negative test cases - not_divisible\n./gen -n 3 -k 2 -type not_divisible\n./gen -n 10 -k 3 -type not_divisible\n./gen -n 99 -k 7 -type not_divisible\n./gen -n 100 -k 3 -type not_divisible\n./gen -n 1000 -k 7 -type not_divisible\n./gen -n 999 -k 1000 -type not_divisible\n\n# Negative test cases - not_palindromes\n./gen -n 2 -k 1 -type not_palindromes\n./gen -n 4 -k 2 -type not_palindromes\n./gen -n 10 -k 2 -type not_palindromes\n./gen -n 10 -k 5 -type not_palindromes\n./gen -n 100 -k 10 -type not_palindromes\n./gen -n 100 -k 50 -type not_palindromes\n./gen -n 1000 -k 10 -type not_palindromes\n./gen -n 1000 -k 100 -type not_palindromes\n./gen -n 1000 -k 500 -type not_palindromes\n\n# Edge cases\n./gen -n 10 -k 5 -type not_palindromes\n./gen -n 10 -k 5 -type positive\n./gen -n 1000 -k 1000 -type positive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:57.363708",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "548/B",
      "title": "B. Mike and Fun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers n, m and q (1 ≤ n, m ≤ 500 and 1 ≤ q ≤ 5000).The next n lines contain the grid description. There are m integers separated by spaces in each line. Each of these numbers is either 0 (for mouth) or 1 (for eyes).The next q lines contain the information about the rounds. Each of them contains two integers i and j (1 ≤ i ≤ n and 1 ≤ j ≤ m), the row number and the column number of the bear changing his state.",
      "output_spec": "OutputAfter each round, print the current score of the bears.",
      "sample_tests": "ExamplesInputCopy5 4 50 1 1 01 0 0 10 1 1 01 0 0 10 0 0 01 11 41 14 24 3OutputCopy34334",
      "description": "B. Mike and Fun\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers n, m and q (1 ≤ n, m ≤ 500 and 1 ≤ q ≤ 5000).The next n lines contain the grid description. There are m integers separated by spaces in each line. Each of these numbers is either 0 (for mouth) or 1 (for eyes).The next q lines contain the information about the rounds. Each of them contains two integers i and j (1 ≤ i ≤ n and 1 ≤ j ≤ m), the row number and the column number of the bear changing his state.\n\nOutputAfter each round, print the current score of the bears.\n\nInputCopy5 4 50 1 1 01 0 0 10 1 1 01 0 0 10 0 0 01 11 41 14 24 3OutputCopy34334\n\nInputCopy5 4 50 1 1 01 0 0 10 1 1 01 0 0 10 0 0 01 11 41 14 24 3\n\nOutputCopy34334",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 548\\s*B"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1, \"grid_row\");\n        inf.readEoln();\n    }\n\n    for (int k = 1; k <= q; ++k) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(1, m, \"j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1, \"grid_row\");\n        inf.readEoln();\n    }\n\n    for (int k = 1; k <= q; ++k) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(1, m, \"j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 500, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 5000, \"q\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1, \"grid_row\");\n        inf.readEoln();\n    }\n\n    for (int k = 1; k <= q; ++k) {\n        int i = inf.readInt(1, n, \"i\");\n        inf.readSpace();\n        int j = inf.readInt(1, m, \"j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string gridType = opt<string>(\"gridType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Adjust n, m for single_row and single_column\n    if (gridType == \"single_row\") {\n        n = 1;\n    }\n    if (gridType == \"single_column\") {\n        m = 1;\n    }\n\n    // Limit n, m to [1, 500] and q to [1, 5000]\n    n = max(1, min(n, 500));\n    m = max(1, min(m, 500));\n    if (queryType == \"max_q\") {\n        q = 5000;\n    } else {\n        q = max(1, min(q, 5000));\n    }\n\n    // Generate initial grid\n    vector<vector<int>> grid(n, vector<int>(m));\n    if (gridType == \"all_zeros\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n    } else if (gridType == \"all_ones\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n    } else if (gridType == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i + j) % 2;\n    } else if (gridType == \"max_initial_score\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n    } else if (gridType == \"min_initial_score\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(0, 1);\n    }\n\n    // Generate queries\n    vector<pair<int,int>> queries(q);\n    if (queryType == \"same_query\") {\n        int i = rnd.next(1, n);\n        int j = rnd.next(1, m);\n        for (int k = 0; k < q; ++k)\n            queries[k] = make_pair(i, j);\n    } else if (queryType == \"toggle_edges\") {\n        for (int k = 0; k < q; ++k) {\n            int side = rnd.next(4);\n            int i, j;\n            if (side == 0) { // Top row\n                i = 1;\n                j = rnd.next(1, m);\n            } else if (side == 1) { // Bottom row\n                i = n;\n                j = rnd.next(1, m);\n            } else if (side == 2) { // Left column\n                i = rnd.next(1, n);\n                j = 1;\n            } else { // Right column\n                i = rnd.next(1, n);\n                j = m;\n            }\n            queries[k] = make_pair(i, j);\n        }\n    } else {\n        // Default: random queries\n        for (int k = 0; k < q; ++k) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(1, m);\n            queries[k] = make_pair(i, j);\n        }\n    }\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, m, q);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (j > 0) printf(\" \");\n            printf(\"%d\", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    // Output queries\n    for (int k = 0; k < q; ++k) {\n        printf(\"%d %d\\n\", queries[k].first, queries[k].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Get parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string gridType = opt<string>(\"gridType\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n\n    // Adjust n, m for single_row and single_column\n    if (gridType == \"single_row\") {\n        n = 1;\n    }\n    if (gridType == \"single_column\") {\n        m = 1;\n    }\n\n    // Limit n, m to [1, 500] and q to [1, 5000]\n    n = max(1, min(n, 500));\n    m = max(1, min(m, 500));\n    if (queryType == \"max_q\") {\n        q = 5000;\n    } else {\n        q = max(1, min(q, 5000));\n    }\n\n    // Generate initial grid\n    vector<vector<int>> grid(n, vector<int>(m));\n    if (gridType == \"all_zeros\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n    } else if (gridType == \"all_ones\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n    } else if (gridType == \"checkerboard\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i + j) % 2;\n    } else if (gridType == \"max_initial_score\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n    } else if (gridType == \"min_initial_score\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(0, 1);\n    }\n\n    // Generate queries\n    vector<pair<int,int>> queries(q);\n    if (queryType == \"same_query\") {\n        int i = rnd.next(1, n);\n        int j = rnd.next(1, m);\n        for (int k = 0; k < q; ++k)\n            queries[k] = make_pair(i, j);\n    } else if (queryType == \"toggle_edges\") {\n        for (int k = 0; k < q; ++k) {\n            int side = rnd.next(4);\n            int i, j;\n            if (side == 0) { // Top row\n                i = 1;\n                j = rnd.next(1, m);\n            } else if (side == 1) { // Bottom row\n                i = n;\n                j = rnd.next(1, m);\n            } else if (side == 2) { // Left column\n                i = rnd.next(1, n);\n                j = 1;\n            } else { // Right column\n                i = rnd.next(1, n);\n                j = m;\n            }\n            queries[k] = make_pair(i, j);\n        }\n    } else {\n        // Default: random queries\n        for (int k = 0; k < q; ++k) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(1, m);\n            queries[k] = make_pair(i, j);\n        }\n    }\n\n    // Output n m q\n    printf(\"%d %d %d\\n\", n, m, q);\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (j > 0) printf(\" \");\n            printf(\"%d\", grid[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    // Output queries\n    for (int k = 0; k < q; ++k) {\n        printf(\"%d %d\\n\", queries[k].first, queries[k].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -q 1 -gridType random -queryType random\n\n./gen -n 3 -m 3 -q 5 -gridType all_zeros -queryType random\n\n./gen -n 3 -m 4 -q 5 -gridType all_ones -queryType same_query\n\n./gen -n 4 -m 5 -q 6 -gridType checkerboard -queryType toggle_edges\n\n./gen -n 1 -m 500 -q 10 -gridType single_row -queryType random\n\n./gen -n 500 -m 1 -q 10 -gridType single_column -queryType random\n\n./gen -n 500 -m 500 -q 5000 -gridType random -queryType random\n\n./gen -n 500 -m 500 -q 5000 -gridType random -queryType same_query\n\n./gen -n 500 -m 500 -q 5000 -gridType random -queryType toggle_edges\n\n./gen -n 500 -m 500 -gridType max_initial_score -q 5000 -queryType random\n\n./gen -n 500 -m 500 -gridType min_initial_score -q 5000 -queryType random\n\n./gen -n 500 -m 500 -gridType all_ones -queryType same_query -q 5000\n\n./gen -n 500 -m 500 -gridType all_zeros -queryType same_query -q 5000\n\n./gen -n 500 -m 500 -gridType checkerboard -q 5000 -queryType random\n\n./gen -n 1 -m 1 -q 5000 -gridType random -queryType random\n\n./gen -n 500 -m 500 -q 5000 -gridType random -queryType max_q\n\n./gen -n 100 -m 100 -q 1000 -gridType random -queryType random\n\n./gen -n 100 -m 100 -q 1000 -gridType random -queryType same_query\n\n./gen -n 500 -m 500 -q 5000 -gridType random -queryType random\n\n./gen -n 10 -m 10 -q 200 -gridType random -queryType random\n\n./gen -n 10 -m 500 -q 200 -gridType random -queryType random\n\n./gen -n 500 -m 10 -q 200 -gridType random -queryType random\n\n./gen -n 2 -m 2 -q 4 -gridType random -queryType same_query\n\n./gen -n 2 -m 2 -q 4 -gridType random -queryType toggle_edges\n\n./gen -n 50 -m 50 -q 5000 -gridType random -queryType random\n\n./gen -n 500 -m 500 -q 5000 -gridType random -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:46:59.437217",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "548/C",
      "title": "C. Майк, лягушка и цветок",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано целое число m (2 ≤ m ≤ 106).Во второй строке ввода записаны целые числа, h1 и a1 (0 ≤ h1, a1 < m).В третьей строке ввода записаны целые числа, x1 и y1 (0 ≤ x1, y1 < m).В четвертой строка ввода записаны целые числа, h2 и a2 (0 ≤ h2, a2 < m).В пяятой строке ввода записаны целые числа, x2 и y2 (0 ≤ x2, y2 < m).Гарантируется, что h1 ≠ a1 и h2 ≠ a2.",
      "output_spec": "Выходные данныеВыведите минимальное количество секунд, необходмое до того момента, как Xaniar достигнет высоты a1, а Abol достигнет высоты a2, а если же это никогда не произойдёт, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать54 21 10 12 3Выходные данныеСкопировать3Входные данныеСкопировать10231 21 01 21 1Выходные данныеСкопировать-1",
      "description": "C. Майк, лягушка и цветок\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано целое число m (2 ≤ m ≤ 106).Во второй строке ввода записаны целые числа, h1 и a1 (0 ≤ h1, a1 < m).В третьей строке ввода записаны целые числа, x1 и y1 (0 ≤ x1, y1 < m).В четвертой строка ввода записаны целые числа, h2 и a2 (0 ≤ h2, a2 < m).В пяятой строке ввода записаны целые числа, x2 и y2 (0 ≤ x2, y2 < m).Гарантируется, что h1 ≠ a1 и h2 ≠ a2.\n\nВходные данные\n\nВыходные данныеВыведите минимальное количество секунд, необходмое до того момента, как Xaniar достигнет высоты a1, а Abol достигнет высоты a2, а если же это никогда не произойдёт, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать54 21 10 12 3Выходные данныеСкопировать3Входные данныеСкопировать10231 21 01 21 1Выходные данныеСкопировать-1\n\nВходные данныеСкопировать54 21 10 12 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10231 21 01 21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия высоты меняются следующим образом:Xaniar: Abol:",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 548 和字母"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 1000000, \"m\");\n    inf.readEoln();\n\n    int h1 = inf.readInt(0, m - 1, \"h1\");\n    inf.readSpace();\n    int a1 = inf.readInt(0, m - 1, \"a1\");\n    inf.readEoln();\n\n    int x1 = inf.readInt(0, m - 1, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, m - 1, \"y1\");\n    inf.readEoln();\n\n    int h2 = inf.readInt(0, m - 1, \"h2\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, m - 1, \"a2\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(0, m - 1, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, m - 1, \"y2\");\n    inf.readEoln();\n\n    ensuref(h1 != a1, \"h1 (%d) should not be equal to a1 (%d)\", h1, a1);\n    ensuref(h2 != a2, \"h2 (%d) should not be equal to a2 (%d)\", h2, a2);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 1000000, \"m\");\n    inf.readEoln();\n\n    int h1 = inf.readInt(0, m - 1, \"h1\");\n    inf.readSpace();\n    int a1 = inf.readInt(0, m - 1, \"a1\");\n    inf.readEoln();\n\n    int x1 = inf.readInt(0, m - 1, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, m - 1, \"y1\");\n    inf.readEoln();\n\n    int h2 = inf.readInt(0, m - 1, \"h2\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, m - 1, \"a2\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(0, m - 1, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, m - 1, \"y2\");\n    inf.readEoln();\n\n    ensuref(h1 != a1, \"h1 (%d) should not be equal to a1 (%d)\", h1, a1);\n    ensuref(h2 != a2, \"h2 (%d) should not be equal to a2 (%d)\", h2, a2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 1000000, \"m\");\n    inf.readEoln();\n\n    int h1 = inf.readInt(0, m - 1, \"h1\");\n    inf.readSpace();\n    int a1 = inf.readInt(0, m - 1, \"a1\");\n    inf.readEoln();\n\n    int x1 = inf.readInt(0, m - 1, \"x1\");\n    inf.readSpace();\n    int y1 = inf.readInt(0, m - 1, \"y1\");\n    inf.readEoln();\n\n    int h2 = inf.readInt(0, m - 1, \"h2\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, m - 1, \"a2\");\n    inf.readEoln();\n\n    int x2 = inf.readInt(0, m - 1, \"x2\");\n    inf.readSpace();\n    int y2 = inf.readInt(0, m - 1, \"y2\");\n    inf.readEoln();\n\n    ensuref(h1 != a1, \"h1 (%d) should not be equal to a1 (%d)\", h1, a1);\n    ensuref(h2 != a2, \"h2 (%d) should not be equal to a2 (%d)\", h2, a2);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int h1, a1, x1, y1;\n    int h2, a2, x2, y2;\n\n    if (type == \"random\") {\n        m = rnd.next(2, m);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n\n    } else if (type == \"never_reach\") {\n        // Set up sequences that never reach the target\n        m = rnd.next(2, m);\n        // For h1 sequence\n        h1 = rnd.next(0, m - 1);\n        x1 = 1; // h1_t = (h1 + y1) % m\n        y1 = 0;\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n\n        // Ensure that h1 never reaches a1\n        // Since h1_t = h1 for all t, it will never reach a1\n\n        // For h2 sequence\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n\n    } else if (type == \"immediate\") {\n        m = rnd.next(2, m);\n\n        // To make h1 reach a1 in one step\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x1 = rnd.next(0, m - 1);\n        y1 = (a1 - (x1 * h1) % m + m) % m;\n\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = (a2 - (x2 * h2) % m + m) % m;\n\n    } else if (type == \"long_cycle\") {\n        m = rnd.next(2, m);\n\n        // Choose x1 coprime to m for long cycle\n        x1 = rnd.next(1, m - 1);\n        while (__gcd(x1, m) != 1)\n            x1 = rnd.next(1, m - 1);\n\n        y1 = rnd.next(0, m - 1);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n\n        x2 = rnd.next(1, m - 1);\n        while (__gcd(x2, m) != 1)\n            x2 = rnd.next(1, m - 1);\n\n        y2 = rnd.next(0, m - 1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n\n    } else {\n        // Default to random\n        m = rnd.next(2, m);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output h1 and a1\n    printf(\"%d %d\\n\", h1, a1);\n    // Output x1 and y1\n    printf(\"%d %d\\n\", x1, y1);\n    // Output h2 and a2\n    printf(\"%d %d\\n\", h2, a2);\n    // Output x2 and y2\n    printf(\"%d %d\\n\", x2, y2);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int h1, a1, x1, y1;\n    int h2, a2, x2, y2;\n\n    if (type == \"random\") {\n        m = rnd.next(2, m);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n\n    } else if (type == \"never_reach\") {\n        // Set up sequences that never reach the target\n        m = rnd.next(2, m);\n        // For h1 sequence\n        h1 = rnd.next(0, m - 1);\n        x1 = 1; // h1_t = (h1 + y1) % m\n        y1 = 0;\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n\n        // Ensure that h1 never reaches a1\n        // Since h1_t = h1 for all t, it will never reach a1\n\n        // For h2 sequence\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n\n    } else if (type == \"immediate\") {\n        m = rnd.next(2, m);\n\n        // To make h1 reach a1 in one step\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x1 = rnd.next(0, m - 1);\n        y1 = (a1 - (x1 * h1) % m + m) % m;\n\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = (a2 - (x2 * h2) % m + m) % m;\n\n    } else if (type == \"long_cycle\") {\n        m = rnd.next(2, m);\n\n        // Choose x1 coprime to m for long cycle\n        x1 = rnd.next(1, m - 1);\n        while (__gcd(x1, m) != 1)\n            x1 = rnd.next(1, m - 1);\n\n        y1 = rnd.next(0, m - 1);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n\n        x2 = rnd.next(1, m - 1);\n        while (__gcd(x2, m) != 1)\n            x2 = rnd.next(1, m - 1);\n\n        y2 = rnd.next(0, m - 1);\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n\n    } else {\n        // Default to random\n        m = rnd.next(2, m);\n        h1 = rnd.next(0, m - 1);\n        do {\n            a1 = rnd.next(0, m - 1);\n        } while (a1 == h1);\n        x1 = rnd.next(0, m - 1);\n        y1 = rnd.next(0, m - 1);\n\n        h2 = rnd.next(0, m - 1);\n        do {\n            a2 = rnd.next(0, m - 1);\n        } while (a2 == h2);\n        x2 = rnd.next(0, m - 1);\n        y2 = rnd.next(0, m - 1);\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output h1 and a1\n    printf(\"%d %d\\n\", h1, a1);\n    // Output x1 and y1\n    printf(\"%d %d\\n\", x1, y1);\n    // Output h2 and a2\n    printf(\"%d %d\\n\", h2, a2);\n    // Output x2 and y2\n    printf(\"%d %d\\n\", x2, y2);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 10 -type random\n./gen -m 10 -type immediate\n./gen -m 10 -type never_reach\n./gen -m 10 -type long_cycle\n\n./gen -m 100 -type random\n./gen -m 100 -type immediate\n./gen -m 100 -type never_reach\n./gen -m 100 -type long_cycle\n\n./gen -m 1000 -type random\n./gen -m 1000 -type immediate\n./gen -m 1000 -type never_reach\n./gen -m 1000 -type long_cycle\n\n./gen -m 10000 -type random\n./gen -m 10000 -type immediate\n./gen -m 10000 -type never_reach\n./gen -m 10000 -type long_cycle\n\n./gen -m 100000 -type random\n./gen -m 100000 -type immediate\n./gen -m 100000 -type never_reach\n./gen -m 100000 -type long_cycle\n\n./gen -m 1000000 -type random\n./gen -m 1000000 -type immediate\n./gen -m 1000000 -type never_reach\n./gen -m 1000000 -type long_cycle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:01.147402",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "548/D",
      "title": "D. Mike and Feet",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n (1 ≤ n ≤ 2 × 105), the number of bears.The second line contains n integers separated by space, a1, a2, ..., an (1 ≤ ai ≤ 109), heights of bears.",
      "output_spec": "OutputPrint n integers in one line. For each x from 1 to n, print the maximum strength among all groups of size x.",
      "sample_tests": "ExamplesInputCopy101 2 3 4 5 4 3 2 1 6OutputCopy6 4 4 3 3 2 2 1 1 1",
      "description": "D. Mike and Feet\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains integer n (1 ≤ n ≤ 2 × 105), the number of bears.The second line contains n integers separated by space, a1, a2, ..., an (1 ≤ ai ≤ 109), heights of bears.\n\nOutputPrint n integers in one line. For each x from 1 to n, print the maximum strength among all groups of size x.\n\nInputCopy101 2 3 4 5 4 3 2 1 6OutputCopy6 4 4 3 3 2 2 1 1 1\n\nInputCopy101 2 3 4 5 4 3 2 1 6\n\nOutputCopy6 4 4 3 3 2 2 1 1 1",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 548 和字母"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n\n    vector<int> a(n);\n\n    if (type == \"constant\") {\n        int val = rnd.next(1, max_ai);\n        for (int i = 0; i < n; i++) {\n            a[i] = val;\n        }\n    } else if (type == \"ascending\") {\n        int range = max_ai - 1; // ai >= 1\n        int step = max(1, range / n);\n        int val = 1;\n        for (int i = 0; i < n; i++) {\n            a[i] = val;\n            val = min(max_ai, val + step);\n        }\n    } else if (type == \"descending\") {\n        int range = max_ai - 1;\n        int step = max(1, range / n);\n        int val = max_ai;\n        for (int i = 0; i < n; i++) {\n            a[i] = val;\n            val = max(1, val - step);\n        }\n    } else if (type == \"peak\") {\n        int mid = n / 2;\n        int peak = max_ai;\n        int step = max(1, (peak - 1) / mid);\n        int val = 1;\n        for (int i = 0; i < mid; i++) {\n            a[i] = val;\n            val = min(peak - 1, val + step);\n        }\n        a[mid] = peak;\n        val = peak - 1;\n        for (int i = mid + 1; i < n; i++) {\n            a[i] = val;\n            val = max(1, val - step);\n        }\n    } else if (type == \"valley\") {\n        int mid = n / 2;\n        int low = 1;\n        int high = max_ai;\n        int step = max(1, (high - low) / mid);\n        int val = high;\n        for (int i = 0; i < mid; i++) {\n            a[i] = val;\n            val = max(low + 1, val - step);\n        }\n        a[mid] = low;\n        val = low + 1;\n        for (int i = mid + 1; i < n; i++) {\n            a[i] = val;\n            val = min(high, val + step);\n        }\n    } else if (type == \"big_peak\") {\n        int pos = rnd.next(0, n - 1);\n        int low_val = rnd.next(1, max_ai / 10 + 1);\n        for (int i = 0; i < n; i++) {\n            if (i == pos) {\n                a[i] = max_ai;\n            } else {\n                a[i] = low_val;\n            }\n        }\n    } else if (type == \"sawtooth\") {\n        int high = max_ai;\n        int low = 1;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0)\n                a[i] = high;\n            else\n                a[i] = low;\n        }\n    } else if (type == \"random_shuffled\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        // default \"random\"\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 1000000000);\n\n    vector<int> a(n);\n\n    if (type == \"constant\") {\n        int val = rnd.next(1, max_ai);\n        for (int i = 0; i < n; i++) {\n            a[i] = val;\n        }\n    } else if (type == \"ascending\") {\n        int range = max_ai - 1; // ai >= 1\n        int step = max(1, range / n);\n        int val = 1;\n        for (int i = 0; i < n; i++) {\n            a[i] = val;\n            val = min(max_ai, val + step);\n        }\n    } else if (type == \"descending\") {\n        int range = max_ai - 1;\n        int step = max(1, range / n);\n        int val = max_ai;\n        for (int i = 0; i < n; i++) {\n            a[i] = val;\n            val = max(1, val - step);\n        }\n    } else if (type == \"peak\") {\n        int mid = n / 2;\n        int peak = max_ai;\n        int step = max(1, (peak - 1) / mid);\n        int val = 1;\n        for (int i = 0; i < mid; i++) {\n            a[i] = val;\n            val = min(peak - 1, val + step);\n        }\n        a[mid] = peak;\n        val = peak - 1;\n        for (int i = mid + 1; i < n; i++) {\n            a[i] = val;\n            val = max(1, val - step);\n        }\n    } else if (type == \"valley\") {\n        int mid = n / 2;\n        int low = 1;\n        int high = max_ai;\n        int step = max(1, (high - low) / mid);\n        int val = high;\n        for (int i = 0; i < mid; i++) {\n            a[i] = val;\n            val = max(low + 1, val - step);\n        }\n        a[mid] = low;\n        val = low + 1;\n        for (int i = mid + 1; i < n; i++) {\n            a[i] = val;\n            val = min(high, val + step);\n        }\n    } else if (type == \"big_peak\") {\n        int pos = rnd.next(0, n - 1);\n        int low_val = rnd.next(1, max_ai / 10 + 1);\n        for (int i = 0; i < n; i++) {\n            if (i == pos) {\n                a[i] = max_ai;\n            } else {\n                a[i] = low_val;\n            }\n        }\n    } else if (type == \"sawtooth\") {\n        int high = max_ai;\n        int low = 1;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0)\n                a[i] = high;\n            else\n                a[i] = low;\n        }\n    } else if (type == \"random_shuffled\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        // default \"random\"\n        for (int i = 0; i < n; i++) {\n            a[i] = rnd.next(1, max_ai);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type constant\n./gen -n 1 -type random\n\n./gen -n 2 -type random\n./gen -n 2 -type ascending\n\n./gen -n 10 -type constant\n./gen -n 10 -type ascending\n./gen -n 10 -type descending\n./gen -n 10 -type random\n./gen -n 10 -type peak\n./gen -n 10 -type valley\n./gen -n 10 -type big_peak\n./gen -n 10 -type sawtooth\n\n./gen -n 100 -type constant\n./gen -n 100 -type ascending\n./gen -n 100 -type descending\n./gen -n 100 -type random\n./gen -n 100 -type peak\n./gen -n 100 -type valley\n\n./gen -n 1000 -type random\n\n./gen -n 100000 -type random\n./gen -n 100000 -type ascending\n./gen -n 100000 -type descending\n./gen -n 100000 -type constant\n./gen -n 100000 -type big_peak\n\n./gen -n 200000 -type random -max_ai 1000000000\n./gen -n 200000 -type random -max_ai 1000\n\n./gen -n 200000 -type big_peak\n\n./gen -n 200000 -type ascending\n./gen -n 200000 -type descending\n\n./gen -n 200000 -type sawtooth\n\n./gen -n 200000 -type peak\n./gen -n 200000 -type valley\n\n./gen -n 200000 -type constant -max_ai 1\n./gen -n 200000 -type constant -max_ai 1000000000\n\n./gen -n 200000 -type random_shuffled\n\n./gen -n 100000 -type random -max_ai 1\n./gen -n 100000 -type random -max_ai 1000000000\n\n./gen -n 200000 -type random -max_ai 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:02.934780",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "548/E",
      "title": "E. Mike and Foam",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains numbers n and q (1 ≤ n, q ≤ 2 × 105), the number of different kinds of beer and number of queries.The next line contains n space separated integers, a1, a2, ... , an (1 ≤ ai ≤ 5 × 105), the height of foam in top of each kind of beer.The next q lines contain the queries. Each query consists of a single integer integer x (1 ≤ x ≤ n), the index of a beer that should be added or removed from the shelf.",
      "output_spec": "OutputFor each query, print the answer for that query in one line.",
      "sample_tests": "ExamplesInputCopy5 61 2 3 4 6123451OutputCopy013562",
      "description": "E. Mike and Foam\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains numbers n and q (1 ≤ n, q ≤ 2 × 105), the number of different kinds of beer and number of queries.The next line contains n space separated integers, a1, a2, ... , an (1 ≤ ai ≤ 5 × 105), the height of foam in top of each kind of beer.The next q lines contain the queries. Each query consists of a single integer integer x (1 ≤ x ≤ n), the index of a beer that should be added or removed from the shelf.\n\nOutputFor each query, print the answer for that query in one line.\n\nInputCopy5 61 2 3 4 6123451OutputCopy013562\n\nInputCopy5 61 2 3 4 6123451\n\nOutputCopy013562",
      "solutions": [
        {
          "title": "Codeforces Round #305 - Codeforces",
          "content": "Codeforces round #305 is gonna take place soon and I'm the writer.After my previous contest that many people think it was a hard contest, I prepared an easy contest to cheer you up!I want to thank Haghani for testing this round, Zlobober for help me prepare this round and his great advises, Delinur for translating problem statements into Russian, mruxim and Yasser Ahmadi Phoulady (Rasta) for their advises and ideas, HosseinYousefi for helping me choose legends and graphics and MikeMirzayanov for great Codeforces and Polygon platform and guys from Physics Olympiad that kept disturbing me while preparing this round.This is my second official round and I hope you enjoy it.The main character of this round is gonna be Mike (I didn't say MikeMirzayanov :D).Also you'll meet Xaniar and Abol.I wish you all Successful hacks and Accepted solutions and high ratings.Scoring will be posted soon.GL & HF!UPD: Scoring is: Div.2: 500-1000-1750-2000-2750 Div.1: 750-1000-1750-1750-2500 UPD2: Due to technical reasons we moved the round by 5 minutes.UPD3: Contest has just ended. You can find the editorial here.UPD4: System testing is done.Congratulations to the winners, specially dreamoon_love_AA that got to his goal !Div.1 winners: dreamoon_love_AA HYPERHYPERHYPERCUBELOVER jqdai0815 YuukaKazami subscriber Div.2 winners: fromWork IloveGoodness norge metal_knight williamzpf See you in the next rounds.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18046",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces",
          "content": "548A - Mike and FaxConsider characters of this string are number 0-based from left to right. If |s| is not a multiply of k, then answer is \"NO\". Otherwise, let . Then answer is \"Yes\" if and only if for each i that 0 ≤ i < |s|, si = s(i / len) * len + len - 1 - (i%len) where a%b is the remainder of dividing a by b.Time complexity: .C++ Code by PrinceOfPersiaPython Code by HaghaniPython Code by Zlobober548B - Mike and FunConsider this problem: We have a binary sequence s and want to find the maximum number of consecutive 1s in it. How to solve this? Easily: ans = 0\ncur = 0\nfor i = 1 to n:\n if s[i] == 0\n then cur = 0\n else\n cur = cur + 1\n ans = max(ans, cur)Finally, answer to this problem is ans. For each row r of the table, let ansr be the maximum number of consecutive 1s in it (we know how to calculate it in O(m) right ?). So after each query, update ansi in O(m) and then find max(ans1, ans2, ..., ansn) in O(n).Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniPython Code by Zlobober547A - Mike and FrogIn this editorial, consider p = m, a = h1, a′ = a1, b = h2 and b′ = a2, x = x1, y = y1, X = x2 and Y = y2.First of all, find the number of seconds it takes until height of Xaniar becomes a′ (starting from a) and call it q. Please note that q ≤ p and if we don't reach a′ after p seconds, then answer is  - 1. If after q seconds also height of Abol will become equal to b′ then answer if q.Otherwise, find the height of Abdol after q seconds and call it e.Then find the number of seconds it takes until height of Xaniar becomes a′ (starting from a′) and call it c. Please note that c ≤ p and if we don't reach a′ after p seconds, then answer is  - 1.if g(x) = Xx + Y, then find f(x) = g(g(...(g(x)))) (c times). It is really easy: c = 1, d = 0\nfor i = 1 to c\n c = (cX) % p\n d = (dX + Y) % pThen, f(x)\n return (cx + d) % pActually, if height of Abol is x then, after c seconds it will be f(x).Then, starting from e, find the minimum number of steps of performing e = f(e) it takes to reach b′ and call it o. Please note that o ≤ p and if we don't reach b′ after p seconds, then answer is  - 1.Then answer is x + c × o.Time Complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547B - Mike and FeetFor each i, find the largest j that aj < ai and show it by li (if there is no such j, then li = 0).Also, find the smallest j that aj < ai and show it by ri (if there is no such j, then ri = n + 1).This can be done in O(n) with a stack. Pseudo code of the first part (second part is also like that) : stack s // initially empty\nfor i = 1 to n\n while s is not empty and a[s.top()] >= a[i]\n do s.pop()\n if s is empty\n then l[i] = 0\n otherwise\n l[i] = s.top()\n s.push(i)Consider that you are asked to print n integers, ans1, ans2, ..., ansn. Obviously, ans1 ≥ ans2 ≥ ... ≥ ansn.For each i, we know that ai can be minimum element in groups of size 1, 2, ..., ri - li - 1.Se we need a data structure for us to do this:We have array ans1, ans2, ..., ansn and all its elements are initially equal to 0. Also, n queries. Each query gives x, val and want us to perform ans1 = max(ans1, val), ans2 = max(ans2, val), ..., ansx = max(ansx, val). We want the final array.This can be done in O(n) with a maximum partial sum (keeping maximum instead of sum), read here for more information about partial sum. Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547C - Mike and FoamWe define that a number x is good if and only if there is no y > 1 that y2 is a divisor of x.Also, we define function f(x) as follow:Consider x = p1a1 × p2a2 × ... × pkak where all pis are prime. Then, f(x) = a1 + a2 + ... + an.Use simple inclusion. Consider all the primes from 1 to 5 × 105 are p1, p2, ..., pk.So, after each query, if d(x) is the set of beers like i in the shelf that x is a divisor of ai, then number of pairs with gcd equal to 1 is: Consider good numbers from 1 to 5 × 105 are b1, b2, ..., bm. The above phrase can be written in some other way: |d(b1)| × ( - 1)f(b1) + |d(b2)| × ( - 1)f(b2) + ... + |d(bm)| × ( - 1)f(bm).So, for each query if we can find all good numbers that ai is divisible by them in a fast way, we can solve the rest of the problem easily (for each good number x, we can store |d(x)| in an array and just update this array and update the answer).Since all numbers are less than 2 × 3 × 5 × 7 × 11 × 13 × 17, then there are at most 6 primes divisible buy ai. With a simple preprocesses, we can find their maximum and so easily we can find these (at most 6) primes fast. If their amount is x, then there are exactly 2x good numbers that ai is divisible by them (power of each prime should be either 0 or 1).So we can perform each query in O(26)Time complexity: .C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547D - Mike and FishConsider a bipartite graph. In each part (we call them first and second part) there are L = 2 × 105 vertices numbered from 1 to L. For each point (x, y) add an edge between vertex number x from the first part and vertex number y from the second part.In this problem, we want to color edges with two colors so that the difference between the number of blue edges connected to a vertex and the number of red edges connected to it be at most 1.Doing such thing is always possible.We prove this and solve the problem at the same time with induction on the number of edges :If all vertices have even degree, then for each component there is an Eulerian circuit, find it and color the edges alternatively_ with blue and red. Because graph is bipartite, then our circuit is an even walk and so, the difference between the number of blue and red edges connected to a vertex will be 0.Otherwise, if a vertex like v has odd degree, consider a vertex like u that there is and edge between v and u. Delete this edge and solve the problem for the rest of the edges (with the induction definition) and then add this edge and if the number of red edges connected to u is more than the blue ones, then color this edge with blue, otherwise with red.You can handle this add/delete edge requests and find odd vertices with a simple set. So,Time complexity: C++ Code by PrinceOfPersiaC++ Code by HaghaniJava Code by Zlobober547E - Mike and Friendscall(i, j) = match(sjinsi) which match(tins) is the number of occurrences of t in s.Concatenate all strings together in order (an put null character between them) and call it string S. We know that .Consider N = 5 × 105. Consider Consider for each i, Sxisxi + 1...syi = si (xi + 1 = yi + 2).Also, for i - th character of S which is not a null character, consider it belongs to swi.Calculate the suffix array of S in and show it by f1, f2, ..., f|S| (we show each suffix by the index of its beginning).For each query, we want to know the number of occurrences of sk in Sxl...syr. For this propose, we can use this suffix array.Consider that we show suffix of S starting from index x by S(x).Also, for each i < |S|, calculate lcp(S(fi), S(fi + 1)) totally in and show it by lci.For each query, consider fi = xk, also find minimum number a and maximum number b (using binary search and sparse table on sequence lc) such that a ≤ i ≤ b and min(lca, lca + 1, ..., lci - 1) ≥ |sk| and min(lci, lci + 1, ..., lcb - 1) ≥ |sk|.Finally answer of this query is the number of elements in wa, wa + 1, ..., wb that are in the interval [l, r].This problem is just like KQUERY. You can read my offline approach for KQUERY here. It uses segment tree, but you can also use Fenwick instead of segment tree.This wasn't my main approach. My main approach uses aho-corasick and a data structure I invented and named it C-Tree.Time complexity: C++ Code by PrinceOfPersia () C++ Code by PrinceOfPersia ()C++ Code by Haghani (Suffix array construction in and the rest in )Java Code by ZloboberIf there's any suggestion or error let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18126",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 548 和字母"
          },
          "content_length": 7875
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #305 - Codeforces - Code 1",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 2",
          "code": "for(int i=0;i<500;i++){",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 3",
          "code": "for(int j=0;j<499;j++)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 4",
          "code": "printf(\"0 \");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 5",
          "code": "printf(\"0\\n\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 6",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 7",
          "code": "int id = query[it];\n--id;\nint x = a[id];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 8",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 9",
          "code": "int id = query[it];\n--id;\nint x = id;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 - Codeforces - Code 10",
          "code": "I prepared an easy contest to cheer you up!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18046",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 1",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 2",
          "code": "ans = 0\ncur = 0\nfor i = 1 to n:\n     if s[i] == 0\n          then cur = 0\n     else\n          cur = cur + 1\n     ans = max(ans, cur)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 3",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 4",
          "code": "c = 1, d = 0\nfor i = 1 to c\n     c = (cX) % p\n     d = (dX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 5",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 6",
          "code": "f(x)\n     return (cx + d) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 7",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 8",
          "code": "stack s // initially empty\nfor i = 1 to n\n     while s is not empty and a[s.top()] >= a[i]\n          do s.pop()\n     if s is empty\n          then l[i] = 0\n     otherwise\n          l[i] = s.top()\n     s.push(i)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 9",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 10",
          "code": "if(a[i][j] == 1)t++;\n                    else if(t > ans){\n                         ans = t;\n                         t = 0;\n                    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 11",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 12",
          "code": "ios :: sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 13",
          "code": "p*(sizeof(v1)) + i = j + q*(sizeof(v2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 14",
          "code": "p*(sizeof(v1)) - q*(sizeof(v2)) = j - i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 15",
          "code": "j - i % gcd(sizeof(v1), -sizeof(v2)) != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 16",
          "code": "for(int i=1; i<=n; i++)   // for l[]\n{\n    while(!S.empty() && A[S.top()]>=A[i])\n        S.pop();\n    if(S.empty())\n        l[i]=0;\n    else\n        l[i]=S.top();\n    S.push(i);\n}\n\nfor(int i=n; i>=1; i--)   //for r[]\n{\n    while(!T.empty() && A[T.top()]>=A[i])\n        T.pop();\n    if(T.empty())\n        r[i]=n+1;\n    else\n        r[i]=T.top();\n    T.push(i);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 17",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 18",
          "code": "for(int i=n-1; i>0; i--) ans[i]=max(ans[i],ans[i+1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 19",
          "code": "len = |s| / k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 20",
          "code": "2 * len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 21",
          "code": "(x+1) * len -1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 22",
          "code": "(i /len) * len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 23",
          "code": "(i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 24",
          "code": "s[len - 1 - i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 25",
          "code": "s[end - index]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 26",
          "code": "end = (i /len) * len + len - 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 27",
          "code": "index = i % len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 28",
          "code": "s[(i / len) * len + len - 1 - (i%len)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 29",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 30",
          "code": "// f(x) can be represented by Ax+B.\n// Ax+B becomes (Ax+B)X+Y=(AX)x+(BX+Y) next second. calculate it c times.\nA = 1, B = 0\nfor i = 1 to c\n     A = (AX) % p\n     B = (BX + Y) % p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 31",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 32",
          "code": "// bp=b' here\nfor o = 0 to p\n    if e=bp then break\n    e=f(e)\nprint q+co",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 33",
          "code": "printf(\"%d\", i1-1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 34",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 35",
          "code": "if(l % k == 1 || k > l)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 36",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #305 Editorial - Codeforces - Code 37",
          "code": "if(l % k)\n    cout << \"NO\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18126",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 500000);\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 500000);\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 500000);\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string ait = opt<string>(\"ait\", \"random\");\n    string qt = opt<string>(\"qt\", \"random\");\n\n    vector<int> a(n);\n\n    if (ait == \"random\") {\n        // ai is random in [1, 5e5]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500000);\n        }\n    } else if (ait == \"same\") {\n        // All ai are the same number\n        int val = opt<int>(\"a_val\", 2); // default to 2\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (ait == \"primes\") {\n        // All ai are odd numbers simulating primes\n        for (int i = 0; i < n; ++i) {\n            int candidate = rnd.next(100000, 500000);\n            if (candidate % 2 == 0) candidate++;\n            a[i] = candidate;\n        }\n    } else if (ait == \"multiples\") {\n        int k = opt<int>(\"k\", 2); // default to 2\n        int max_v = 500000 / k;\n        if (max_v == 0) max_v = 1; // ensure at least 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = k * rnd.next(1, max_v);\n        }\n    } else if (ait == \"powers\") {\n        // ai's are powers of two not exceeding 500000\n        vector<int> powers;\n        int x = 1;\n        while (x <= 500000) {\n            powers.push_back(x);\n            x <<= 1;\n        }\n        int sz = powers.size();\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, sz - 1);\n            a[i] = powers[idx];\n        }\n    } else if (ait == \"sequence\") {\n        // ai's are i + 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500000);\n        }\n    }\n\n    // Now generate the queries\n    vector<int> queries(q);\n    if (qt == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    } else if (qt == \"add_all\") {\n        // Build up the shelf\n        for (int i = 0; i < q; ++i) {\n            queries[i] = i % n + 1;\n        }\n    } else if (qt == \"remove_all\") {\n        // Remove all items after adding them\n        for (int i = 0; i < n; ++i) {\n            queries[i] = i + 1;\n        }\n        for (int i = n; i < q; ++i) {\n            queries[i] = (i - n) % n + 1;\n        }\n    } else if (qt == \"alternating\") {\n        // Alternate between adding and removing the same element\n        int x = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries[i] = x;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d\\n\", queries[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string ait = opt<string>(\"ait\", \"random\");\n    string qt = opt<string>(\"qt\", \"random\");\n\n    vector<int> a(n);\n\n    if (ait == \"random\") {\n        // ai is random in [1, 5e5]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500000);\n        }\n    } else if (ait == \"same\") {\n        // All ai are the same number\n        int val = opt<int>(\"a_val\", 2); // default to 2\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (ait == \"primes\") {\n        // All ai are odd numbers simulating primes\n        for (int i = 0; i < n; ++i) {\n            int candidate = rnd.next(100000, 500000);\n            if (candidate % 2 == 0) candidate++;\n            a[i] = candidate;\n        }\n    } else if (ait == \"multiples\") {\n        int k = opt<int>(\"k\", 2); // default to 2\n        int max_v = 500000 / k;\n        if (max_v == 0) max_v = 1; // ensure at least 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = k * rnd.next(1, max_v);\n        }\n    } else if (ait == \"powers\") {\n        // ai's are powers of two not exceeding 500000\n        vector<int> powers;\n        int x = 1;\n        while (x <= 500000) {\n            powers.push_back(x);\n            x <<= 1;\n        }\n        int sz = powers.size();\n        for (int i = 0; i < n; ++i) {\n            int idx = rnd.next(0, sz - 1);\n            a[i] = powers[idx];\n        }\n    } else if (ait == \"sequence\") {\n        // ai's are i + 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 500000);\n        }\n    }\n\n    // Now generate the queries\n    vector<int> queries(q);\n    if (qt == \"random\") {\n        for (int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    } else if (qt == \"add_all\") {\n        // Build up the shelf\n        for (int i = 0; i < q; ++i) {\n            queries[i] = i % n + 1;\n        }\n    } else if (qt == \"remove_all\") {\n        // Remove all items after adding them\n        for (int i = 0; i < n; ++i) {\n            queries[i] = i + 1;\n        }\n        for (int i = n; i < q; ++i) {\n            queries[i] = (i - n) % n + 1;\n        }\n    } else if (qt == \"alternating\") {\n        // Alternate between adding and removing the same element\n        int x = rnd.next(1, n);\n        for (int i = 0; i < q; ++i) {\n            queries[i] = x;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < q; ++i) {\n            queries[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%d\\n\", queries[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -ait same -a_val 2 -qt random\n./gen -n 2 -q 2 -ait same -a_val 2 -qt add_all\n./gen -n 2 -q 2 -ait same -a_val 2 -qt alternating\n./gen -n 5 -q 6 -ait random -qt random\n./gen -n 5 -q 6 -ait random -qt alternating\n./gen -n 5 -q 6 -ait same -a_val 2 -qt random\n./gen -n 1000 -q 1000 -ait same -a_val 1 -qt random\n./gen -n 1000 -q 1000 -ait random -qt random\n./gen -n 100000 -q 100000 -ait random -qt random\n./gen -n 200000 -q 200000 -ait random -qt random\n./gen -n 200000 -q 200000 -ait same -a_val 2 -qt add_all\n./gen -n 200000 -q 200000 -ait same -a_val 2 -qt random\n./gen -n 200000 -q 200000 -ait same -a_val 17 -qt random\n./gen -n 200000 -q 200000 -ait same -a_val 1 -qt random\n./gen -n 200000 -q 200000 -ait multiples -k 2 -qt random\n./gen -n 200000 -q 200000 -ait multiples -k 500000 -qt random\n./gen -n 200000 -q 200000 -ait primes -qt random\n./gen -n 200000 -q 200000 -ait powers -qt random\n./gen -n 200000 -q 200000 -ait sequence -qt random\n./gen -n 200000 -q 200000 -ait random -qt alternating\n./gen -n 200000 -q 200000 -ait random -qt remove_all\n./gen -n 200000 -q 200000 -ait random -qt add_all\n./gen -n 200000 -q 200000 -ait random -qt random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:05.260131",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/A",
      "title": "A. Face Detection",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers, n and m (1 ≤ n, m ≤ 50) — the height and the width of the image, respectively.Next n lines define the image. Each line contains m lowercase Latin letters.",
      "output_spec": "OutputIn the single line print the number of faces on the image.",
      "sample_tests": "ExamplesInputCopy4 4xxxxxfaxxcexxxxxOutputCopy1InputCopy4 2xxcfaexxOutputCopy1InputCopy2 3faccefOutputCopy2InputCopy1 4faceOutputCopy0",
      "description": "A. Face Detection\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers, n and m (1 ≤ n, m ≤ 50) — the height and the width of the image, respectively.Next n lines define the image. Each line contains m lowercase Latin letters.\n\nOutputIn the single line print the number of faces on the image.\n\nInputCopy4 4xxxxxfaxxcexxxxxOutputCopy1InputCopy4 2xxcfaexxOutputCopy1InputCopy2 3faccefOutputCopy2InputCopy1 4faceOutputCopy0\n\nInputCopy4 4xxxxxfaxxcexxxxx\n\nOutputCopy1\n\nInputCopy4 2xxcfaexx\n\nOutputCopy1\n\nInputCopy2 3faccef\n\nOutputCopy2\n\nInputCopy1 4face\n\nOutputCopy0\n\nNoteIn the first sample the image contains a single face, located in a square with the upper left corner at the second line and the second column:   In the second sample the image also contains exactly one face, its upper left corner is at the second row and the first column.In the third sample two faces are shown:   In the fourth sample the image has no faces on it.",
      "solutions": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces",
          "content": "Hi, Codeforces! I am glad to announce Looksery Cup 2015, that is prepared by our developers, each one of them has made a great impact: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 and I. Special thank to coordinator Zlobober for the help with problems and advices and to Delinur for the translation.We've prepared 8 problems for you, that will have random order at the contest. Round will last 2 hours 30 minutes under the standard Codeforces rules with smooth dynamic scoring. We hope, that you will enjoy competition, and we will receive small amount of clars :) Top-200 competitors will get t-shirts with the handle at Codeforces:Winner will get opportunity to have a prepaid trip to San-Francisco. Besides, top-15 competitors will get Oculus Development Kit 2.And competitors from 16 to 50 — gadget Ollie.Also I would like to thank MikeMirzayanov and everybody, who works on Codeforces and Polygon — your contribution in education and IT is hard to be overestimated.UPD. Round will be rated for both divisions.Looking forward to seeing you tomorrow,Looksery Inc.UPD3. EditorialUPD2. Rating will be recalculated today, but it could be changed a little till final results.UPD. Round is over. Thank to everybody, who took part. Congratulations to winners! The final results will be announced in a day, after catching all cheaters. Current top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1556
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces",
          "content": "UPD Editorial of problem E was added, I apologize for the delay. Hope you found it interesting.A. Face DetectionAuthor: MonyuraOne should iterate through each 2x2 square and check if it is possible to rearrange letters in such way they they form the word \"face\". It could be done i.e. by sorting all letters from the square in alphabetic order and comparing the result with the word \"acef\"(sorted letters of word \"face\").B. Looksery PartyAuthor: Igor_KudryashovIn any cases there is such set of people that if they come on party and send messages to their contacts then each employee receives the number of messages that is different from what Igor pointed. Let's show how to build such set. There are 2 cases.There are no zeros among Igor's numbers. So if nobody comes on party then each employee receives 0 messages and, therefore, the desired set is empty.There is at least one zero. Suppose Igor thinks that i-th employee will receive 0 messages. Then we should add i-th employee in the desired set. He will send messages to his contacts and will receive 1 message from himself. If we add other employees in the desired set then the number of messages that i-th employee will receive will not decrease so we can remove him from considering. Igor pointed some numbers for people from contact list of i-th employee and because they have already received one message we need to decrease these numbers by one. After that we can consider the same problem but with number of employees equals to n - 1. If the remaining number of employees is equal to 0 then the desired set is built. C. The Game Of ParityAuthor: olpetOdessaONUIf n = k no moves may be done. The winner is determined with starting parity of citizens' number. Otherwise let's see that the player making the last move may guarantee his victory, if there are both odd and even cities when he makes the move. He just selects the city of which parity he should burn to obtain required parity. So, his enemy's target is to destroy all the cities of some one type. Sometimes the type does matter, sometimes doesn't. It depends on the player's name and the parity of k. So the problem's solution consists in checking if \"non-last\" player's moves number (n - k) / 2 is enough to destroy all the odd or even cities. If Stannis makes the last move and k is even, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the odd cities. If Daenerys makes the last move and k is even, Stannis has no chance to win. If k is odd, Stannis should burn all the even cities.D. Haar FeaturesAuthor: MonyuraThis problem had a complicated statement but it is very similar to the real description of the features. Assume that we have a solution. It means we have a sequence of prefix-rectangles and coefficients to multiply. We can sort that sequence by the bottom-right corner of the rectangle and feature's value wouldn't be changed. Now we could apply our operations from the last one to the first. To calculate the minimum number of operations we will iterate through each pixel starting from the bottom-right in any of the column-major or raw-major order. For each pixel we will maintain the coefficient with which it appears in the feature's value. Initially it is 0 for all. If the coefficient of the current cell is not equal to  + 1 for W and  - 1 for B we increment the required amount of operations. Now we should make coefficient to have a proper value. Assume that it has to be X( - 1 or  + 1 depends on the color) but current coefficient of this pixel is C. Then we should anyway add this pixel's value to the feature's value with the coefficient X - C. But the only way to add this pixel's value now(after skipping all pixels that have not smaller index of both row and column) is to get sum on the prefix rectangle with the bottom-left corner in this pixel. Doing this addition we also add X - C to the coefficient of all pixels in prefix-rectangle. This solution could be implemented as I describe above in O(n2m2) or O(nm).Also I want to notice that in real Haar-like features one applies them not to the whole image but to the part of the image. Anyway, the minimum amount of operations could be calculated in the same way.E. Sasha CircleAuthors: Krasnokutskiy, 2222Author's solution has complexity , where C is a maximum absolute value of the coordinates of all given points.Let’s call a set of points A and B separable if there’s a circle inside or on the boundary of which lie all the points of one set. When there’re no points neither inside nor on the boundary of the circle we call this circle separating. Let points of the set A lie inside or on the boundary of the circle and points of the set B lie outside the circle. Points from set A are allowed to be on the boundary of the separative circle as after increasing radius a little we’re getting set A strictly inside and set B strictly outside the circle.Let A contain at least two points. Separating circle can be compressed in such a way that it’ll pass at least through two points of the set A. It’s possible to look over all the pairs of points and try to pass each pair through the separating circle. The centre of the desired circle lies on the medial perpendicular of the segment pq. Let’s designate the points of the medial perpendicular as l(t) where is a parameter. All the points that don’t lie on the straight line pq make parameter t bounded above or below. All the points that lie on the straight line pq have to lie outside the limits of the segment pq. E.g. a picture below displays a blue point which bounds the centre of separating circle from the left side and red points – from the right side. That’s why the centre has to lie inside a segment cd.Let’s look over all the points to make sure that a value t which satisfies all the bounds exists. This provides us with the problem solving for O((|A|2 + |B|2)(|A| + |B|)).Let’s examine paraboloid z = x2 + y2 and draw arbitrary non-vertical plane ax + by + z = c. The intersection of the paraboloid and the plane satysfies the equation ax + by + x2 + y2 = c, or . If project points of the paraboloid (x, y, x2 + y2) onto the plane the cross-section of the paraboloid formed by the plane projects onto a circle, the paraboloid points below the plane projects onto internal points of the circle, those above the plane projects onto points outside the circle. As is one-to-one correspondence the opposite is also true: when points of the plane project onto the paraboloid the plane projects onto the cross-section of the paraboloid formed by the plane, the internal points – onto the paraboloid below the cross-section and external points – above the cross-section.So, projection of points onto paraboloid assigns one-to-one correspondence between circles and planes (non-vertical). partitioning of sets of points A and B of plane by circle can be done by means of partitioning of their three-dimensional projections into paraboloid A′ and B′ by non-vertical plane. Let’s call such a plane separating (like separating circle, separating plane can include points from A′).By analogy with separating, circle separating plane can be passed through two points of set A′. All the other points of A′ will lie below or on the plane. In other words separating plane will pass through the edge of the upper convex hull of the set A′. The projection of edges of the upper convex hull A′ onto the plane xOy will produce some sort of a set flat convex hull partitioning into A by non-intersecting edges. In this case separating plane corresponds separating circle passing through the edge partition. Let’s designate the convex hull A as coA. In case when none of 4 vertices coA lies within one circle all the edges of the upper convex hull are triangles and the derived partitioning is triangulation. Otherwise the derived partitioning should be completed to be triangulation.To construct a separating circle look over triangulation edges and check the possibility of drawing a circle though an edge as it is described above.The derived triangulation has the following feature: circle drawn around any triangle contains the whole polygon coA as the corresponding bound of three-dimensional convex hull is higher than all three-dimensional points A′. The described triangulation is “opposite” to the Delaunay triangulation according to which circle drawn around any triangle doesn’t contain any points of the original set. This triangulation is commonly known as the Anti-Delaunay triangulation.Using the characterizing feature the Anti-Delaunay triangulation can be constructed by means of the method “divide and conquer” without transferring into three-dimensional space and working with points of plane and circles only. Let us triangulate polygon created by the vertices coA when moving counter-clock-wise from i to j. Let us find the third point of triangle, that will contain edge (i, j). I.e such point k, that circumscribed circle over triangle (i, j, k) contains the whole current polygon. For this purpose let’s iterate through all polygon’s vertices and select the one, that gives the extreme position of the center of the circumscribed circle lied on the mid-perpendicular of (i, j). The circle will contain the whole polygon coA as the edge (i, j) is included in the Anti-Delaunay triangulation. Recursively triangulate polygons with vertices from i to k and from k to j. The base of recursion is a segment, that shouldn't be triangulated. To solve the original problem one should swap A and B and perform the above procedure once more. Complexity of the algorithm is O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, where C is a maximum absolute value of the coordinates of all given points. Actually, O(C3 / 2) is an estimation of the number of points at a convex hull with no three points in a line. F. Yura and DevelopersAuthors: RubanenkoLet's consider following solution:Let f(l, r) be the solution for [l, r] subarray. It's easy to see that f(1, n) is the answer for the given problem. How should one count f(l, r)? Let m be an index of the maximum value over subarray [l, r]. All the good segments can be divided into two non-intersecting sets: those that contain m and those that don't. To count the latter we can call f(l, m - 1) and f(m + 1, r). We are left with counting the number of subarrays that contain m, i.e. the number of pairs (i, j) such that l ≤ i < m < j ≤ r and g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) defines as + as + 1 + ... + at). Let s be the sequence of partial sums of the given array, i.e. si = a1 + a2 + ... + ai. For every j we are interested in the number of such i that sj - si - am%k = 0, so if we iterate over every possible j, then we are interested in number of i that si = sj - am(modk) and l ≤ i < m. So we are left with simple query over the segment problem of form \"how many numbers equal to x and belong to a given segment (l, r)\". It can be done in O(q + k) time and memory, where q is the number of generated queries. Model solution processes all the queries in offline mode, using frequency array. One can notice that in the worst case we can generate O(n2) queries which doesn't fit into TL or ML. However, we can choose which is faster: iterate over all possible j or i. In both cases we get an easy congruence which ends up as a query described above. If we iterate only over the smaller segment, every time we \"look at\" the element w it moves to a smaller segment which is at least two times smaller than the previous one. So, every element will end up in 1-element length segment where recursion will meet it's base in O(log(n)) \"looking at\" this element. The overall complexity is O(n × log(n) + k).G. Happy LineAuthors: 2222, MrDindowsLet's reformulate the condition in terms of a certain height the towers, which will be on the stairs. Then an appropriate amount of money of a person in the queue is equal to the height of the tower with the height of the step at which the tower stands. And the process of moving in the queue will be equivalent to raising a tower on the top step, and the one in whose place it came up — down. As shown in the illustrations. Then, it becomes apparent that to make all of the tower on the steps to be sorted, it is enough to sort the tower without the height of step it stays. Total complexity of sorting is O(nlog(n)). H. Degenerate MatrixAuthor: Igor_KudryashovThe rows of degenerate matrix are linear dependent so the matrix B can be written in the following way:Suppose Let's assume that elements of the first row of matrix A are coordinates of point a0 on two-dimensional plane and the elements of the second row are coordinates of point a1. Assume that the rows of matrix B are also coordinates of points b0 and b1. Let's note that in this case the line that is passing through points b0 and b1 is also passing through point (0, 0).Let's find the answer — the number d — by using binary search. Suppose we are considering some number d0. We need to check if there is such matrix B thatIn geometric interpretation it means that point b0 are inside the square which center is point a0 and length of side is 2·d0. In the same way the point b1 are inside the square which center is point a1 and length of side is 2·d0. So we need to check if there is a line that is passing through point (0, 0) and is crossing these squares. In order to do this we should consider every vertex of the first square, build the line that is passing through the chosen vertex and the center of coordinate plane and check if it cross any side of the other square. Afterwards we should swap the squares and check again. Finally if there is a desired line we need to reduce the search area and to expand otherwise.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 13725
        }
      ],
      "code_examples": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(pattern, \"s[\" + to_string(i) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(pattern, \"s[\" + to_string(i) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 50, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[a-z]{\" + to_string(m) + \"}\";\n    for (int i = 1; i <= n; ++i) {\n        string s = inf.readToken(pattern, \"s[\" + to_string(i) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"random\") {\n        // Generate random grid with random letters\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = (char)('a' + rnd.next(26));\n            }\n        }\n    } else if (type == \"noface\") {\n        // Generate grid without 'f', 'a', 'c', 'e' letters\n        string letters = \"\";\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (c != 'f' && c != 'a' && c != 'c' && c != 'e') {\n                letters += c;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(letters.size())];\n            }\n        }\n    } else if (type == \"maxface\") {\n        // Generate grid where all possible 2x2 squares are faces\n        // We'll generate grid with letters 'f', 'a', 'c', 'e' in such a way that every 2x2 square can be rearranged to 'face'\n        vector<char> face_letters = {'f', 'a', 'c', 'e'};\n        for (int i = 0; i + 1 < n; ++i) {\n            for (int j = 0; j + 1 < m; ++j) {\n                vector<char> letters = face_letters;\n                shuffle(letters.begin(), letters.end());\n                grid[i][j] = letters[0];\n                grid[i][j+1] = letters[1];\n                grid[i+1][j] = letters[2];\n                grid[i+1][j+1] = letters[3];\n            }\n        }\n        // Fill the remaining cells (if any) with random 'face' letters\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == '.')\n                    grid[i][j] = face_letters[rnd.next(4)];\n    } else if (type == \"oneface\") {\n        // Generate grid with one face at random position\n        // First, fill the grid with random letters\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = (char)('a' + rnd.next(26));\n            }\n        }\n        // Place the letters 'f', 'a', 'c', 'e' in a 2x2 square\n        if (n >= 2 && m >= 2) {\n            int x = rnd.next(n - 1);\n            int y = rnd.next(m - 1);\n            vector<char> face_letters = {'f', 'a', 'c', 'e'};\n            shuffle(face_letters.begin(), face_letters.end());\n            grid[x][y] = face_letters[0];\n            grid[x][y + 1] = face_letters[1];\n            grid[x + 1][y] = face_letters[2];\n            grid[x + 1][y + 1] = face_letters[3];\n        }\n    } else if (type == \"minimal\") {\n        // For the minimal size grids\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (char)('a' + rnd.next(26));\n    } else {\n        // Default to random grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (char)('a' + rnd.next(26));\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"random\") {\n        // Generate random grid with random letters\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = (char)('a' + rnd.next(26));\n            }\n        }\n    } else if (type == \"noface\") {\n        // Generate grid without 'f', 'a', 'c', 'e' letters\n        string letters = \"\";\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (c != 'f' && c != 'a' && c != 'c' && c != 'e') {\n                letters += c;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = letters[rnd.next(letters.size())];\n            }\n        }\n    } else if (type == \"maxface\") {\n        // Generate grid where all possible 2x2 squares are faces\n        // We'll generate grid with letters 'f', 'a', 'c', 'e' in such a way that every 2x2 square can be rearranged to 'face'\n        vector<char> face_letters = {'f', 'a', 'c', 'e'};\n        for (int i = 0; i + 1 < n; ++i) {\n            for (int j = 0; j + 1 < m; ++j) {\n                vector<char> letters = face_letters;\n                shuffle(letters.begin(), letters.end());\n                grid[i][j] = letters[0];\n                grid[i][j+1] = letters[1];\n                grid[i+1][j] = letters[2];\n                grid[i+1][j+1] = letters[3];\n            }\n        }\n        // Fill the remaining cells (if any) with random 'face' letters\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (grid[i][j] == '.')\n                    grid[i][j] = face_letters[rnd.next(4)];\n    } else if (type == \"oneface\") {\n        // Generate grid with one face at random position\n        // First, fill the grid with random letters\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = (char)('a' + rnd.next(26));\n            }\n        }\n        // Place the letters 'f', 'a', 'c', 'e' in a 2x2 square\n        if (n >= 2 && m >= 2) {\n            int x = rnd.next(n - 1);\n            int y = rnd.next(m - 1);\n            vector<char> face_letters = {'f', 'a', 'c', 'e'};\n            shuffle(face_letters.begin(), face_letters.end());\n            grid[x][y] = face_letters[0];\n            grid[x][y + 1] = face_letters[1];\n            grid[x + 1][y] = face_letters[2];\n            grid[x + 1][y + 1] = face_letters[3];\n        }\n    } else if (type == \"minimal\") {\n        // For the minimal size grids\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (char)('a' + rnd.next(26));\n    } else {\n        // Default to random grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (char)('a' + rnd.next(26));\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal size grids\n./gen -n 1 -m 1 -type minimal\n./gen -n 1 -m 2 -type minimal\n./gen -n 2 -m 1 -type minimal\n./gen -n 1 -m 50 -type minimal\n./gen -n 50 -m 1 -type minimal\n\n# Grids with no faces\n./gen -n 2 -m 2 -type noface\n./gen -n 5 -m 5 -type noface\n./gen -n 10 -m 10 -type noface\n./gen -n 50 -m 50 -type noface\n\n# Grids with one face\n./gen -n 2 -m 2 -type oneface\n./gen -n 3 -m 3 -type oneface\n./gen -n 10 -m 10 -type oneface\n./gen -n 50 -m 50 -type oneface\n\n# Grids with maximum number of faces\n./gen -n 2 -m 2 -type maxface\n./gen -n 3 -m 3 -type maxface\n./gen -n 10 -m 10 -type maxface\n./gen -n 50 -m 50 -type maxface\n\n# Random grids\n./gen -n 2 -m 2 -type random\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 25 -m 25 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 49 -m 50 -type random\n./gen -n 50 -m 49 -type random\n\n# Edge cases\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 2 -type random\n./gen -n 2 -m 1 -type random\n\n# Additional tests\n./gen -n 7 -m 8 -type oneface\n./gen -n 7 -m 8 -type noface\n./gen -n 50 -m 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:07.581634",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/B",
      "title": "B. Вечеринка в Looksery",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано одно целое число n (1 ≤ n ≤ 100) — количество сотрудников компании Looksery.В следующих n строках задано описание списков контактов сотрудников. В i-й из этих строк записана строка длины n, состоящая из нулей и единиц, задающая список контактов i-го сотрудника. Если j-й символ i-й строки равен 1, то j-ый сотрудник находится в списке контактов i-го, в противном случае — не находится. Гарантируется, что i-й символ i-й строки всегда равен 1.В последней строке задано n целых чисел, разделенных пробелами: a1, a2, ..., an (0 ≤ ai ≤ n), где ai обозначает число сообщений, которое должен получить i-й сотрудник по мнению Игоря.",
      "output_spec": "Выходные данныеВ первой строке выведите одно целое число m — количество сотрудников, которые должны прийти на вечеринку, чтобы Игорь проиграл спор.Во второй строке через пробел выведите m целых чисел — номера этих сотрудников в произвольном порядке.Если же Игорь в любом случае выиграет спор, выведите -1.Если возможных ответов несколько, выведите любой из них.",
      "sample_tests": "ПримерыВходные данныеСкопировать31010100010 1 2Выходные данныеСкопировать11 Входные данныеСкопировать111Выходные данныеСкопировать0Входные данныеСкопировать411110101111000011 0 1 0Выходные данныеСкопировать41 2 3 4",
      "description": "B. Вечеринка в Looksery\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано одно целое число n (1 ≤ n ≤ 100) — количество сотрудников компании Looksery.В следующих n строках задано описание списков контактов сотрудников. В i-й из этих строк записана строка длины n, состоящая из нулей и единиц, задающая список контактов i-го сотрудника. Если j-й символ i-й строки равен 1, то j-ый сотрудник находится в списке контактов i-го, в противном случае — не находится. Гарантируется, что i-й символ i-й строки всегда равен 1.В последней строке задано n целых чисел, разделенных пробелами: a1, a2, ..., an (0 ≤ ai ≤ n), где ai обозначает число сообщений, которое должен получить i-й сотрудник по мнению Игоря.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите одно целое число m — количество сотрудников, которые должны прийти на вечеринку, чтобы Игорь проиграл спор.Во второй строке через пробел выведите m целых чисел — номера этих сотрудников в произвольном порядке.Если же Игорь в любом случае выиграет спор, выведите -1.Если возможных ответов несколько, выведите любой из них.\n\nВыходные данные\n\nВходные данныеСкопировать31010100010 1 2Выходные данныеСкопировать11 Входные данныеСкопировать111Выходные данныеСкопировать0Входные данныеСкопировать411110101111000011 0 1 0Выходные данныеСкопировать41 2 3 4\n\nВходные данныеСкопировать31010100010 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать11\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать111\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать411110101111000011 0 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41 2 3 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере по мнению Игоря первый сотрудник получит 0 сообщений. Т.к. его нет в списке контактов других сотрудников, то он должен прийти на вечеринку, чтобы получить сообщение от самого себя. Если на вечеринку придет только первый сотрудник, то он получит 1 сообщение, второй — 0 сообщений, и третий также 1 сообщение. В итоге Игорь не угадает ни одного числа.Во втором примере, если единственный сотрудник придет на вечеринку, то он получит 1 сообщение и Игорь победит в споре, следовательно ему не стоит этого делать.В третьем примере первый сотрудник компании получит 2 сообщения, второй — 3, третий — 2, четвертый — 3.",
      "solutions": [
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces",
          "content": "Codeforces, привет! Я рад анонсировать Looksery Cup 2015, над подготовкой которого работала целая команда наших сотрудников, каждый из которых внес огромный вклад: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 и я. Отдельное спасибо координатору Zlobober за помощь с задачами и советы, а также Delinur за перевод условий.Мы подготовили для вас 8 задач различной сложности, которые будут расположены в случайном порядке. Раунд будет длиться 2 часа 30 минут и пройдет по правилам Codeforces с плавной динамической стоимостью. Очень надеемся, что задачи понравятся и вы получите удовольствие от соревнования, а мы получим мало кларов :) Топ-200 участников соревнования получат именные футболки с их хендлами на Codeforces:Как сообщалось в предварительном анонсе, победитель соревнования получит возможность поехать в полностью оплаченное путешествие в Сан-Франциско. Кроме этого, топ-15 участников получат Oculus Development Kit 2.А участники с 16 по 50 места — гаджет Ollie.Также хочется выразить большую благодарность MikeMirzayanov и всем, кто трудится над Codeforces и Polygon — ваш вклад в образование и развитие IT сферы трудно переоценить, я думаю все со мной согласятся.UPD. Раунд будет рейтинговым для обоих дивизионов.Ждем вас завтра,Looksery Inc.UPD3. Появился разборUPD2. Рейтинг будет пересчитан сегодня, но завтра могут произойти небольшие изменения, не пугайтесьUPD. Раунд завершился, всем спасибо, что приняли участие. Поздравляем победителей! Окончательные результаты будут объявлены в течении суток, после определения читеров. По предварительным результатам top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1788
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces",
          "content": "UPD. Появился разбор задачи Е. Мы просим прощения за задержку, он получился действительно трудоемким, и, чтобы как-то загладить свою вину, мы публикуем несколько интерпретаций решения. A. Определение лицАвтор: MonyuraДля решения этой задачи следует перебрать все квадраты 2х2 и проверить, что переставив буквы можно получить слово \"face\". Это можно удобно сделать, например, отсортировав буквы квадрата в алфавитном порядке и проверив, что отсортированное множество равно \"acef\"(Отсортированный порядок букв слова \"face\").B. Вечеринка в LookseryАвтор: Igor_KudryashovПри любом раскладе существует такое множество людей, что, если они придут и разошлют сообщения своим контактам, то каждый сотрудник получит количество сообщений отличное от того, что указал Игорь. Покажем как построить это множество. Рассмотрим 2 случая.Ни одно из чисел, предложенных Игорем, не равно нулю. Тогда если никто не придет на вечеринку, то всем сотрудникам придет по 0 сообщений, и, следовательно, искомое множество — это пустое множество.Хотя бы одно из чисел Игоря равно нулю. Пусть он предполагает, что i-ому сотруднику достанется 0 сообщений. В этом случае добавим i-ого сотрудника в искомое множество. Он разошлет сообщения всем своим контактам и у него самого количество пришедших сообщений станет равно 1. При добавлении других сотрудников в искомое множество, количество сообщений, пришедших i-ому не уменьшится, а, значит, его можно удалить из рассмотрения. Для людей из списка контактов i-го сотрудника Игорь предсказал некоторые количества сообщений, и т.к. по одному сообщению этим людям уже пришло, из желаемых Игорем чисел нужно вычесть единицу. После этого можно перейти к той же задаче, считая что у нас имеется n - 1 сотрудников. Если оставшееся количество сотрудников равно 0, то искомое множество построено. C. Игра чётностиАвтор: olpetOdessaONUЕсли n = k, то ни один ход не может быть совершен. Победитель определяется изначальной суммарной четностью количества жителей. Иначе заметим, что игрок, который делает ход последним, может гарантировать себе победу, если на момент его последнего хода остаются как четные, так и нечетные города — он просто выберет, город с какой четностью сжечь, чтобы получить нужную итоговую четность. Поэтому задача его противника — уничтожить все города какого-то одного типа. Иногда все равно какого, а иногда — нет, это зависит от имени игрока и четности k. Поэтому дальнейшее решение задачи заключается в сравнении количества ходов (n - k) / 2 «непоследнего» игрока с количествами четных и нечетных городов — хватит ли ходов, чтобы их уничтожить. Если последним ходит Станнис, то, в случае четного k, Дейнерис должна сжечь все четные либо все нечетные города. В случае нечетного k, Дейнерис следует сжечь все нечетные города. Если последней ходит Дейнерис, то, в случае четного k ее противник не имеет шансов на победу, а, в случае нечетного k, Станнис должен сжечь все четные города.D. Признаки ХаараАвтор: MonyuraЭта задача имела сложное условие, но максимально близкое к реальности.Один из вариантов решения задачи состоит в изучении структуры ответа. Предположим, что у нас есть ответ, т.е последовательность операций: взятие сумм на префикс-прямоугольнике и коэффициентов, на который умножается сумма. Мы можем менять порядок операций, значение признака при этом меняться не будет. Тогда отсортируем операции по правому нижнему углу прямоугольника. Будем применять операции начиная от последний к первой. Решение состоит в том, что бы не применять операции, которые не нужны и применить все те, которые мы обязаны применить. Для этого для каждого пикселя будем поддерживать коэффициент с которым он сейчас входит в значение признака. Изначально этот коэффициент равен 0. Пройдем по каждому пикселю начиная с нижнего правого угла. Если текущий коэффициент не равен  + 1 для пикселя покрытого W и  - 1 для пикселя покрытого B, то пиксель входит в значение признака с неправильным коэффициентом и нам надо его поменять, для этого используем одну операцию. Единственный способ поменять значение этого пикселя теперь, после того как все большие и по ряду и по столбцу просмотрены — это взять сумму на префикс-прямоугольнике с правым нижним углом в этом пикселе. Предположим значение коэффициента должно быть X ( + 1 или  - 1 в зависимости от цвета), а сейчас равно C. Тогда мы должны прибавить сумму на прямоугольнике с коэффициентом X - C к значению признака. Но сделав это, мы так же прибавим X - C к коэффициентам всех пикселей на префикс-прямоугольнике. Это решение может быть реализовано так, как описано за O(n2m2) или за O(nm).Так же хочется добавить, что от настоящих признаков Хаара данное определение отличается только тем, что настоящие применяются к региону изображения, а не ко всему изображению. Но минимальное число операций можно посчитать по такому же принципу.E. Саша КругАвторы: Krasnokutskiy, 2222Сложность авторского решения составляет O((n + m) * h + n * logn + m * logm), где h — максимальное(среди двух множеств) число точек выпуклой оболочки. Ниже будет доказано, что для данных ограничений имеет место более точная оценка O((n + m) * С2 / 3 + n * logn + m * logm), где С — максимальная координата. Существует две интерпретации решения, мы приведем обе. Для начала докажем независимую оценку на число точек выпуклой оболочки:Пусть есть множество точек на плоскости с целочисленными неотрицательными координатами. Докажем, что количество точек в выпуклой оболочке, в которой никакие три точки не лежат на одной прямой, равно O(C2 / 3), где C — максимальная координата.Пусть выпуклая оболочка в порядке обхода против часовой стрелке образуется последовательностью точек P0, P1, …, Pn - 1. Рассмотрим последовательность векторов P1 - P0, P2 - P1, .., Pn - 1 - Pn - 2, P0 - Pn - 1 Обозначим элемент этой последовательности Vi = P(i + 1)modn - Pi. Рассмотрим такие Vi = (xi, yi), что 0 ≤ xi, yi ≤ C. т.е. вектора, лежащие в первой координатной четверти. Заметим, что эти вектора будут идти подряд в последовательности векторов всех четвертей из-за свойств выпуклой оболочки. Докажем, что их количество равно O(C2 / 3), а доказательство для других четвертей будут аналогичны.Ключевой факт — любая частичная сумма векторов, дает точку из выпуклой оболочки, включая сумму всех векторов. Тогда сумма по каждой координате всех векторов первой четверти не превышает C. Так же, напоминаю, что никакие три точки не лежали на одной прямой в выпуклой оболочке, а значит не существует одинаковых векторов(даже коллинеарных). Посчитаем сколько максимум можно набрать векторов из первой четверти, что бы сумма по каждой координате не превосходила C:0 ≤ sumX, sumY ≤ C. Ослабим ограничения до 0 ≤ sumX + sumY ≤ C, от этого максимальное количество векторов, очевидно, не уменьшится. Будем набирать наше множество жадно, очевидно, что сначала имеет смысл брать вектора с как можно меньшей суммой координат. Возьмем максимальное количество векторов, сумма координат которых 1 , таких векторов всего два: (0, 1), (1, 0). Добавим вектора с суммой 2: (0, 2), (1, 1), (2, 0), их всего три. В общем случаи, если сумма координат равна k, то с такой суммой существует (k + 1) различных векторов. Нам надо набирать вектора до тех пор, пока сумма координат не превзойдет C. Т.е. 1 * 2 + 2 * 3 + 3 * 4 + … + k * (k + 1) = O(C). Можно честно посчитать эту сумму, но её порядок будет O(k3). Отсюда следует, что k = O(C1 / 3). Теперь посчитаем количество векторов, которые мы взяли: 2 + 3 + … + (k + 1) = O(k2). Таким образом максимум можно взять O(C2 / 3) векторов в первой четверти. Во всех других четвертях оценка такая же, из-за соображений симметрии. Теперь можно переходить к разбору решения. Первый вариант интерпретации решения, автор Sklyack:Назовём множества точек A и B разделимыми, если существует окружность, содержащая внутри или на границе все точки одного множества, и не содержащая ни внутри, ни на границе точек другого множества, такую окружность назовём разделяющей. Пусть для определённости точки множества A находятся внутри или на границе окружности, а B -- снаружи. Точки из A на границе разделяющей окружности допускаются, так как немного увеличив радиус, получим A строго внутри, B -- строго снаружи окружности.Пусть A содержит хотя бы две точки. Разделяющую окружность можно сжать так, что она пройдёт через хотя бы две точки из A. Можно перебрать все пары точек и через каждую такую пару попытаться провести разделяющую окружность. Центр искомой окружности лежит на серединном перпендикуляре отрезка pq. Обозначим точки серединного перпендикуляра как l(t), где -- параметр. Все точки, не лежащие на прямой pq, ограничивают параметр t сверху или снизу, точки на прямой pq должны лежать за пределами отрезка pq. Например, на следующем рисунке синяя точка ограничивает центр разделяющей окружности слева, а красные точки -- справа, поэтому центр должен лежать внутри отрезка cd. Переберём все точки и проверим, что найдётся значение t, которое удовлетворяет всем ограничениям. Это даёт нам решение задачи за O((|A|2 + |B|2)(|A| + |B|)).Рассмотрим параболоид z = x2 + y2 и проведём произвольную не вертикальную плоскость ax + by + z = c. Пересечение параболоида и плоскости удовлетворяет уравнению ax + by + x2 + y2 = c, или . Если проецировать точки параболоида (x, y, x2 + y2) на плоскость, , то сечение параболоида плоскостью проецируется в окружность, точки параболоида ниже плоскости проецируются во внутренние точки круга, выше плоскости -- в точки снаружи круга. Так как соответствие взаимно-однозначно, то верно и обратное: при проекции точек плоскости на парабалоид окружность проецируются в сечение параболоида плоскостью, внутренние точки -- в часть параболоида ниже секущей плоскости, внешние -- выше плоскости.Таким образом, проекция точек на параболоид задаёт взаимно-однозначное соответствие между окружностями и плоскостями (не вертикальными), а для разделения множеств A и B точек плоскости окружностью достаточно разделить их трёхмерные проекции на параболоид A′ и B′ не вертикальной плоскостью. Такую плоскость назовём разделяющей (при этом по аналогии с разделяющей окружностью, разделяющая плоскость может содержать точки из A′).По аналогии с разделяющей окружностью, разделяющую плоскость можно провести через две точки множества A′. При этом остальные точки A′ будут лежать ниже или на плоскости. Другими словами, разделяющая плоскость пройдёт через ребро верхней выпуклой оболочки множества A′. При проекции рёбер верхней выпуклой оболочки A′ на плоскость xOy получится некоторое разбиение плоской выпуклой оболочки множества A непересекающимися рёбрами, а разделяющей плоскости соответствует разделяющая окружность, проходящая через ребро разбиения. Обозначим выпуклую оболочку A как coA. В случае, когда никакие 4 вершины coA не лежат на одной окружности, все грани верхней выпуклой оболочки -- треугольники, а полученное разбиение -- триангуляция. В противном случае, достроим полученное разбиение до триангуляции. Для построения разделяющей окружности достаточно перебрать рёбра триангуляции и проверить возможность провести окружность через ребро как описано выше.Полученная триангуляция характеризуется следующим свойством: окружность, описанная около любого треугольника, содержит весь многоугольник coA, так как соответствующая грань трёхмерной выпуклой оболочки проходит выше, чем все трёхмерные точки A′. Эта триангуляция \"противоположна\" триангуляции Делоне, в которой окружность, описанная около любого треугольника, не содержит внутри других точек исходного множества. Её можно назвать триангуляцией Анти-Делоне, вроде бы такой термин где-то используется.Используя характеризующее свойство, триангуляцию Анти-Делоне можно построить методом \"разделяй и властвуй\" без перехода в трёхмерное пространство, работая только с точками плоскости и окружностями. Пусть мы триангулируем многоугольник, образованный вершинами coA при обходе против часовой стрелки с i-й по j-ю. Найдём третью точку треугольника, в который войдет ребро (i, j), то есть такую точку k, что окружность, описанная около треугольника (i, j, k), содержит текущий многоугольник. Для этого переберём вершины текущего многоугольника и выберем ту, которая даёт крайнее положение центра описанной окружности на серединном перпендикуляре ребра (i, j). Окружность будет содержать весь многоугольник coA, так как ребро (i, j) входит в триангуляцию Анти-Делоне. Рекурсивно триангулируем многоугольники с вершинами с i-й по k-ю и с k-й по j-ю. База рекурсии -- отрезок, его триангулировать не нужно. Для решения исходной задачи следуют поменять множества A и B ролями и ещё раз применить описанный алгоритм. Вычислительная сложность решения составляет O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, где C — максимальное абсолютное значение координат заданных точек.Вторая интерпретация, автор 2222:Предположим, что возможно построить разделяющую окружность. Тогда обозначим множество точек внутри окружности как A, а множество точек снаружи, как B.Для простоты описания решения, предположим что никакие 4 точки не лежат на одной окружности. В таком случае, если мы найдём разделяющую окружность, проходящую через несколько точек, то мы всегда сможем немного увеличить радиус и, возможно, немного сдвинуть окружность так, чтобы одно множество точек стало лежать строго внутри окружности, а другое — строго снаружи.Обозначим множество вершин выпуклой оболочки множества A как CH(A), тогда один из вариантов решения задачи — перебрать пары точек из CH(A) и попытаться провести через них окружность, которая содержит все точки CH(A) (а следовательно, и все точки A), а все точки из B лежат снаружи, или на границе окружности. Обозначим пару точек из CH(A) как p и q. Так как все точки из CH(A) должны лежать внутри окружности, а все точки из B — снаружи, то каждая из этих точек задаёт некие ограничения на радиус окружности и на расположение центра окружности относительно прямой, проходящей через точки p и q. Например, на следующем рисунке, точки c, d и e — центры синей и красных окружностей. Заметим, что любая окружность с центром на отрезке cd будет содержать все синие точки, а все красные точки будут снаружи или на границе окружности.Таким образом, мы можем проверить существует ли разделяющая окружность, проходящая через точки p и q, просто проверив вступают ли ограничения на разделяющую окружность в противоречие или нет, это можно сделать за . Cложность всего алгоритма составит . Для того, чтобы понять быстро это или нет, воспользуемся следующим фактом: , где C — максимальная по модулю координата точек из A, тогда сложность алгоритма составит O(C2 + C4 / 3|B|). Очевидно, что этот алгоритм слишком медленный, чтобы уложиться в лимит по времени.Назовём пару точек Ai, Aj хорошей, если существует окружность, проходящая через эти точки, которая содержит в себе все точки CH(A). \\textbf{Лемма 1}. Если каждую хорошую пару точек соединить отрезком, то никакие 2 отрезка, соответствующие 4-ем различным точкам, не пересекаются.Допустим, что это не так, тогда существуют 2 разные окружности с хордами ab и cd соответственно, такие что точки a, b, c и d лежат внутри или на границе этих окружностей.Так как точки c и d лежат внутри окружности с хордой ab, то α + β < π, аналогично точки a и b лежат внутри другой окружности, поэтому γ + δ < π, где α, β, γ и δ углы при a, b, c и d соответственно в четырёхугольнике с вершинами в этих точках. Но так сумма углов четырёхугольника равна 2π, то получили противоречие, значит лемма 1 верна.Пронумеруем вершины CH(A) по часовой стрелке от 1 до h, обозначим i-ую вершину CH(A) как chi. Построим рекурсивную процедуру нахождения всех хороших пар точек на промежутке [i..j], при условии, что пара точек (chi, chj) хорошая. Выберем на промежутке [i + 1..j - 1] такое k, что окружность проходящая через chi, chj и chk содержит CH(A), а следовательно пары точек (chi, chk) и (chj, chk) являются хорошими. Заметим, что такая окружность всегда существует, так как пара (chi, chj) является хорошей. Такое k можно найти за O(j - i) по аналогии с алгоритмом нахождения разделяющей окружности проходящей через 2 точки. Теперь решим задачу для [i..k] и [k..j]. Заметим, что пара точек (ch1, chh) является хорошей, так как соответствующий отрезок является ребром выпуклой оболочки, поэтому для решения всей задачи, выполним данную процедуру для промежутка [1..h]. Данная рекурсивная процедура имеет сложность O(h2) и будет вызвана h - 1 раз, а значит количество хороших пар — O(h).Финальный алгоритм выглядит следующим образом. Переберём все хорошие пары точек, для каждой пары, найдём разделяющую окружность, которая проходит через эту пару точек. Если разделяющая окружность не была найдена, то поменяем множества A и B местами и повторим процедуру. Сложность данного алгоритма составляет .Для того, чтобы не было проблем с точностью, необходимо все вычисления делать в целых числах.F. Юра и разработчикиАвтор: RubanenkoПосмотрим на следующее решение:Пусть f(l, r) — это решения для подмассива [l, r]. Легко заметить, что f(1, n) — это ответ на поставленную задачу. Как считать f(l, r)? Пусть m — это индекс максимального элемента подмассива [l, r]. Все хорошие подмассивы могут быть разбиты на два непересекающихся множества: те, которые содержат m, и те которые его не содержат. Чтобы посчитать последние можно просто вызвать f(l, m - 1) и f(m + 1, r). Осталось посчитать количество \"хороших\" подмассивов, которые содержат m, другими словами, количество пар (i, j), что l ≤ i < m < j ≤ r и g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) означает as + as + 1 + ... + at). Пусть s — это последовательность частичных сумм массива из условия, то есть si = a1 + a2 + ... + ai. Для всех j нам интересно количество i, что sj - si - am%k = 0, так что если мы переберем все возможны j, то нам интересно количество таких i, что si = sj - am(modk) и l ≤ i < m. Имеем ряд запросов на отрезке вида \"сколько есть чисел на отрезке (l, r), что они равны x\". Это можно сделать за O(q + k) времени и памяти, где q — количество запросов, которые сгенерировались в ходе рекурсивного вычисления f(1, n). Авторское решение обрабатывает эти запросы в режиме оффлайн, с помощью массива подсчета. Можно заметить, что в худшем случае мы получим O(n2) запросов, которые очевидно не дадут уложиться в ограничения. Тем не менее, мы можем выбрать, что быстрее: перебрать все возможные j или i. В обоих случаях мы получаем простую сравнимость и запрос на отрезке, описанный выше. Если идти только по меньшему отрезку, то каждый раз, как мы \"проходим\" по элементу w, он переходит в отрезок, который, как минимум, в два раза меньше, чем тот, которому он принадлежал до этого. Таким образом, каждый элемент окажется в отрезке единичной длины(база рекурсии) за O(log(n)) \"проходов\" по нему.Сложность алгоритма O(n × log(n) + k).G. Счастливая очередьАвторы: 2222, MrDindowsДавайте переформулируем условие в терминах башен определенной высоты, которые будут находиться на лестнице. Тогда количество денег соответствующего человека в очереди будет равно высоте башни вместе с высотой ступеньки, на которой башня стоит. А процесс продвижения в очереди будет эквивалентен подъему одной башни на ступеньку вверх, а та, на чье место она взошла — вниз, как показано на иллюстрации. Тогда, становится очевидно, что чтобы все башни на ступеньках были отсортированы, достаточно отсортировать башни без учета высот ступенек. Итого сложность сортировки O(nlog(n)). H. Вырожденная матрицаАвтор: Igor_KudryashovУ вырожденной матрицы строки линейно зависимы, а значит можно представить матрицу B в следующем виде:ПустьПоложим, что элементы первой строки матрицы A являются координатами точки a0 на двухмерной плоскости, а элементы второй строки — координатами точки a1. Представим, что строки матрицы B также являются координатами точек b0 и b1. Заметим, что в этом случае прямая, проходящая через точки b0 и b1, также проходит через точку (0, 0).Будем искать ответ на задачу — число d — бинарным поиском. Предположим мы зафиксировали некоторое число d0 и хотим проверить, существует ли такая матрица B, что В геометрической интерпретации это означает, что точка b0 находится в квадрате, с центром в точке a0 и длиной стороны 2·d0, а точка b1, соответственно, в квадрате с такой же длиной стороны и центром в a1. Таким образом, нам нужно проверить, существует ли прямая, проходящая через точку (0, 0) и пересекающая эти квадраты. Чтобы это сделать, достаточно перебрать вершины одного квадрата, построить прямую, проходящую через выбранную вершину и центр координат и проверить, что она пересекает какую-нибудь из сторон второго квадрата. Затем нужно сделать то же самое, обменяв квадраты. В итоге, если прямая нашлась, то нужно уменьшить границу поиска, иначе расширить.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 20615
        }
      ],
      "code_examples": [
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    for (int i = 1; i <= n; i++) {\n        string s = inf.readToken(pattern);\n        ensuref(s.length() == n, \"Line %d should have length %d\", i, n);\n        ensuref(s[i - 1] == '1', \"The %d-th character of line %d must be '1'\", i, i);\n        inf.readEoln();\n    }\n    vector<int> a = inf.readInts(n, 0, n, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    for (int i = 1; i <= n; i++) {\n        string s = inf.readToken(pattern);\n        ensuref(s.length() == n, \"Line %d should have length %d\", i, n);\n        ensuref(s[i - 1] == '1', \"The %d-th character of line %d must be '1'\", i, i);\n        inf.readEoln();\n    }\n    vector<int> a = inf.readInts(n, 0, n, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\" + to_string(n) + \"}\";\n    for (int i = 1; i <= n; i++) {\n        string s = inf.readToken(pattern);\n        ensuref(s.length() == n, \"Line %d should have length %d\", i, n);\n        ensuref(s[i - 1] == '1', \"The %d-th character of line %d must be '1'\", i, i);\n        inf.readEoln();\n    }\n    vector<int> a = inf.readInts(n, 0, n, \"ai\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector<string> contacts;\nvector<int> a;\n\n// Function to read and verify a solution from a stream (ans or ouf)\nint readSolution(InStream& stream, vector<int>& employees) {\n    int m = stream.readInt(-1, n, \"m\");\n    if (m == -1) {\n        // Impossible case\n        return -1;\n    }\n    if (m != 0) {\n        employees = stream.readInts(m, 1, n, \"employees\");\n        set<int> s(employees.begin(), employees.end());\n        if (s.size() < employees.size())\n            stream.quitf(_wa, \"Employees indices are not unique\");\n    } else {\n        // m == 0, empty list\n        employees.clear();\n    }\n    return m;\n}\n\n// Function to check if a solution is valid\nbool isValidSolution(const vector<int>& employees) {\n    vector<int> received(n, 0);\n    for (int s : employees) {\n        s--; // 0-based indexing\n        for (int i = 0; i < n; ++i) {\n            if (contacts[s][i] == '1') {\n                received[i]++;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (received[i] == a[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt();\n    contacts.resize(n);\n    for (int i = 0; i < n; ++i) {\n        contacts[i] = inf.readToken(format(\"[01]{%d}\", n).c_str(), format(\"contacts[%d]\", i + 1).c_str());\n    }\n    a.resize(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(0, n, format(\"a[%d]\", i + 1).c_str());\n    }\n\n    // Read jury's answer\n    vector<int> juryEmployees;\n    int jm = readSolution(ans, juryEmployees);\n    if (jm != -1 && !isValidSolution(juryEmployees)) {\n        quitf(_fail, \"Jury's answer is invalid\");\n    }\n\n    // Read participant's answer\n    vector<int> participantEmployees;\n    int pm = readSolution(ouf, participantEmployees);\n\n    if (pm == -1) {\n        if (jm == -1) {\n            // Correct, both say impossible\n            quitf(_ok, \"Participant correctly found it's impossible\");\n        } else {\n            // Participant says impossible but jury has a solution\n            quitf(_wa, \"Participant claims impossible, but jury has a valid solution\");\n        }\n    } else {\n        if (!isValidSolution(participantEmployees)) {\n            quitf(_wa, \"Participant's solution is invalid\");\n        } else {\n            if (jm == -1) {\n                // Jury says impossible but participant found a solution\n                quitf(_fail, \"Participant found a valid solution, but jury claims impossible\");\n            } else {\n                // Correct solution\n                quitf(_ok, \"Participant's solution is valid\");\n            }\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid output(int n, vector<string>& contact, vector<int>& a){\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%s\\n\", contact[i].c_str());\n    }\n    for(int i = 0; i < n; ++i){\n        if(i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> contact(n, string(n, '0'));\n    vector<int> a(n, 0);\n\n    if(type == \"random\"){\n        // Generate random contact lists\n        for(int i = 0; ++i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n        }\n        // Generate random a_i\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else if(type == \"complete\"){\n        // Everyone knows everyone\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                contact[i][j] = '1';\n            }\n        }\n        // Generate random a_i\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else if(type == \"self_only\"){\n        // Only diagonal elements are '1'\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1'; // Only knows themselves\n        }\n        // Generate a_i between 0 and 1\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, 1);\n        }\n    }\n    else if(type == \"chain\"){\n        // Employee i knows employee (i+1)%n\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1'; // They have to know themselves\n            contact[i][(i+1)%n] = '1';\n        }\n        // Generate random a_i\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else if(type == \"impossible\"){\n        // Max cannot win\n        if(n > 2){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = '0';\n                }\n            }\n        }\n        if(n == 1){\n            a[0] = 0;\n        } else {\n            a[0] = 1;\n            a[1] = 1;\n        }\n    }\n    else if(type == \"empty_win\"){\n        // Max wins by inviting no one\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n            a[i] = 1;\n        }\n    }\n    else if(type == \"full_win\"){\n        // Max can win only by inviting everyone\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n            a[i] = 0;\n        }\n    }\n    else if(type == \"balanced\"){\n        // Max needs to invite exactly half of the employees\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    if((i % 2 == 0) && (j % 2 == 0)){\n                        contact[i][j] = '1';\n                    } else {\n                        contact[i][j] = '0';\n                    }\n                }\n            }\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n            a[i] = rnd.next(0, n);\n        }\n    }\n\n    // Output the data\n    output(n, contact, a);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid output(int n, vector<string>& contact, vector<int>& a){\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i){\n        printf(\"%s\\n\", contact[i].c_str());\n    }\n    for(int i = 0; i < n; ++i){\n        if(i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> contact(n, string(n, '0'));\n    vector<int> a(n, 0);\n\n    if(type == \"random\"){\n        // Generate random contact lists\n        for(int i = 0; ++i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n        }\n        // Generate random a_i\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else if(type == \"complete\"){\n        // Everyone knows everyone\n        for(int i = 0; i < n; ++i){\n            for(int j = 0; j < n; ++j){\n                contact[i][j] = '1';\n            }\n        }\n        // Generate random a_i\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else if(type == \"self_only\"){\n        // Only diagonal elements are '1'\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1'; // Only knows themselves\n        }\n        // Generate a_i between 0 and 1\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, 1);\n        }\n    }\n    else if(type == \"chain\"){\n        // Employee i knows employee (i+1)%n\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1'; // They have to know themselves\n            contact[i][(i+1)%n] = '1';\n        }\n        // Generate random a_i\n        for(int i = 0; i < n; ++i){\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else if(type == \"impossible\"){\n        // Max cannot win\n        if(n > 2){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = '0';\n                }\n            }\n        }\n        if(n == 1){\n            a[0] = 0;\n        } else {\n            a[0] = 1;\n            a[1] = 1;\n        }\n    }\n    else if(type == \"empty_win\"){\n        // Max wins by inviting no one\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n            a[i] = 1;\n        }\n    }\n    else if(type == \"full_win\"){\n        // Max can win only by inviting everyone\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n            a[i] = 0;\n        }\n    }\n    else if(type == \"balanced\"){\n        // Max needs to invite exactly half of the employees\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    if((i % 2 == 0) && (j % 2 == 0)){\n                        contact[i][j] = '1';\n                    } else {\n                        contact[i][j] = '0';\n                    }\n                }\n            }\n            a[i] = rnd.next(0, n);\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i){\n            contact[i][i] = '1';\n            for(int j = 0; j < n; ++j){\n                if(i != j){\n                    contact[i][j] = rnd.next(0, 1) + '0';\n                }\n            }\n            a[i] = rnd.next(0, n);\n        }\n    }\n\n    // Output the data\n    output(n, contact, a);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type impossible\n\n./gen -n 2 -type random\n./gen -n 2 -type impossible\n\n./gen -n 3 -type random\n\n./gen -n 10 -type random\n./gen -n 10 -type complete\n./gen -n 10 -type self_only\n./gen -n 10 -type chain\n./gen -n 10 -type empty_win\n./gen -n 10 -type full_win\n./gen -n 10 -type balanced\n\n./gen -n 50 -type random\n./gen -n 50 -type complete\n./gen -n 50 -type chain\n./gen -n 50 -type empty_win\n./gen -n 50 -type full_win\n./gen -n 50 -type balanced\n\n./gen -n 100 -type random\n./gen -n 100 -type complete\n./gen -n 100 -type self_only\n./gen -n 100 -type chain\n./gen -n 100 -type empty_win\n./gen -n 100 -type full_win\n./gen -n 100 -type balanced\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:09.323223",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/C",
      "title": "C. Игра чётности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых положительных числа, разделенные пробелом, n и k (1 ≤ k ≤ n ≤ 2·105) — изначальное количество городов в Вестеросе и количество городов, при котором игра завершается. Вторая строка содержит n разделённых пробелами целых положительных чисел ai (1 ≤ ai ≤ 106), обозначающих население каждого из городов Вестероса.",
      "output_spec": "Выходные данныеВыведите строку «Daenerys» (без кавычек), если победит Дейнерис, и «Stannis» (без кавычек), если победит Станнис.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 11 2 1Выходные данныеСкопироватьStannisВходные данныеСкопировать3 12 2 1Выходные данныеСкопироватьDaenerysВходные данныеСкопировать6 35 20 12 7 14 101Выходные данныеСкопироватьStannis",
      "description": "C. Игра чётности\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записаны два целых положительных числа, разделенные пробелом, n и k (1 ≤ k ≤ n ≤ 2·105) — изначальное количество городов в Вестеросе и количество городов, при котором игра завершается. Вторая строка содержит n разделённых пробелами целых положительных чисел ai (1 ≤ ai ≤ 106), обозначающих население каждого из городов Вестероса.\n\nВходные данные\n\nВыходные данныеВыведите строку «Daenerys» (без кавычек), если победит Дейнерис, и «Stannis» (без кавычек), если победит Станнис.\n\nВыходные данные\n\nВходные данныеСкопировать3 11 2 1Выходные данныеСкопироватьStannisВходные данныеСкопировать3 12 2 1Выходные данныеСкопироватьDaenerysВходные данныеСкопировать6 35 20 12 7 14 101Выходные данныеСкопироватьStannis\n\nВходные данныеСкопировать3 11 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьStannis\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 12 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьDaenerys\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 35 20 12 7 14 101\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьStannis\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Станнис своим ходом сожжет город с двумя жителями и Дейнерис будет вынуждена сжечь город с одним жителем. В единственном выжившем городе останется один житель, то есть, итоговая сумма нечетная, а значит, побеждает Станнис.Во втором примере, если Станнис сжигает город с двумя жителями, Дейнерис сжигает город с одним жителем, либо наоборот. В любом случае, последний оставшийся город будет населён двумя жителями, то есть, итоговая сумма четная, а значит, побеждает Дейнерис.",
      "solutions": [
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces",
          "content": "Codeforces, привет! Я рад анонсировать Looksery Cup 2015, над подготовкой которого работала целая команда наших сотрудников, каждый из которых внес огромный вклад: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 и я. Отдельное спасибо координатору Zlobober за помощь с задачами и советы, а также Delinur за перевод условий.Мы подготовили для вас 8 задач различной сложности, которые будут расположены в случайном порядке. Раунд будет длиться 2 часа 30 минут и пройдет по правилам Codeforces с плавной динамической стоимостью. Очень надеемся, что задачи понравятся и вы получите удовольствие от соревнования, а мы получим мало кларов :) Топ-200 участников соревнования получат именные футболки с их хендлами на Codeforces:Как сообщалось в предварительном анонсе, победитель соревнования получит возможность поехать в полностью оплаченное путешествие в Сан-Франциско. Кроме этого, топ-15 участников получат Oculus Development Kit 2.А участники с 16 по 50 места — гаджет Ollie.Также хочется выразить большую благодарность MikeMirzayanov и всем, кто трудится над Codeforces и Polygon — ваш вклад в образование и развитие IT сферы трудно переоценить, я думаю все со мной согласятся.UPD. Раунд будет рейтинговым для обоих дивизионов.Ждем вас завтра,Looksery Inc.UPD3. Появился разборUPD2. Рейтинг будет пересчитан сегодня, но завтра могут произойти небольшие изменения, не пугайтесьUPD. Раунд завершился, всем спасибо, что приняли участие. Поздравляем победителей! Окончательные результаты будут объявлены в течении суток, после определения читеров. По предварительным результатам top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1788
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces",
          "content": "UPD. Появился разбор задачи Е. Мы просим прощения за задержку, он получился действительно трудоемким, и, чтобы как-то загладить свою вину, мы публикуем несколько интерпретаций решения. A. Определение лицАвтор: MonyuraДля решения этой задачи следует перебрать все квадраты 2х2 и проверить, что переставив буквы можно получить слово \"face\". Это можно удобно сделать, например, отсортировав буквы квадрата в алфавитном порядке и проверив, что отсортированное множество равно \"acef\"(Отсортированный порядок букв слова \"face\").B. Вечеринка в LookseryАвтор: Igor_KudryashovПри любом раскладе существует такое множество людей, что, если они придут и разошлют сообщения своим контактам, то каждый сотрудник получит количество сообщений отличное от того, что указал Игорь. Покажем как построить это множество. Рассмотрим 2 случая.Ни одно из чисел, предложенных Игорем, не равно нулю. Тогда если никто не придет на вечеринку, то всем сотрудникам придет по 0 сообщений, и, следовательно, искомое множество — это пустое множество.Хотя бы одно из чисел Игоря равно нулю. Пусть он предполагает, что i-ому сотруднику достанется 0 сообщений. В этом случае добавим i-ого сотрудника в искомое множество. Он разошлет сообщения всем своим контактам и у него самого количество пришедших сообщений станет равно 1. При добавлении других сотрудников в искомое множество, количество сообщений, пришедших i-ому не уменьшится, а, значит, его можно удалить из рассмотрения. Для людей из списка контактов i-го сотрудника Игорь предсказал некоторые количества сообщений, и т.к. по одному сообщению этим людям уже пришло, из желаемых Игорем чисел нужно вычесть единицу. После этого можно перейти к той же задаче, считая что у нас имеется n - 1 сотрудников. Если оставшееся количество сотрудников равно 0, то искомое множество построено. C. Игра чётностиАвтор: olpetOdessaONUЕсли n = k, то ни один ход не может быть совершен. Победитель определяется изначальной суммарной четностью количества жителей. Иначе заметим, что игрок, который делает ход последним, может гарантировать себе победу, если на момент его последнего хода остаются как четные, так и нечетные города — он просто выберет, город с какой четностью сжечь, чтобы получить нужную итоговую четность. Поэтому задача его противника — уничтожить все города какого-то одного типа. Иногда все равно какого, а иногда — нет, это зависит от имени игрока и четности k. Поэтому дальнейшее решение задачи заключается в сравнении количества ходов (n - k) / 2 «непоследнего» игрока с количествами четных и нечетных городов — хватит ли ходов, чтобы их уничтожить. Если последним ходит Станнис, то, в случае четного k, Дейнерис должна сжечь все четные либо все нечетные города. В случае нечетного k, Дейнерис следует сжечь все нечетные города. Если последней ходит Дейнерис, то, в случае четного k ее противник не имеет шансов на победу, а, в случае нечетного k, Станнис должен сжечь все четные города.D. Признаки ХаараАвтор: MonyuraЭта задача имела сложное условие, но максимально близкое к реальности.Один из вариантов решения задачи состоит в изучении структуры ответа. Предположим, что у нас есть ответ, т.е последовательность операций: взятие сумм на префикс-прямоугольнике и коэффициентов, на который умножается сумма. Мы можем менять порядок операций, значение признака при этом меняться не будет. Тогда отсортируем операции по правому нижнему углу прямоугольника. Будем применять операции начиная от последний к первой. Решение состоит в том, что бы не применять операции, которые не нужны и применить все те, которые мы обязаны применить. Для этого для каждого пикселя будем поддерживать коэффициент с которым он сейчас входит в значение признака. Изначально этот коэффициент равен 0. Пройдем по каждому пикселю начиная с нижнего правого угла. Если текущий коэффициент не равен  + 1 для пикселя покрытого W и  - 1 для пикселя покрытого B, то пиксель входит в значение признака с неправильным коэффициентом и нам надо его поменять, для этого используем одну операцию. Единственный способ поменять значение этого пикселя теперь, после того как все большие и по ряду и по столбцу просмотрены — это взять сумму на префикс-прямоугольнике с правым нижним углом в этом пикселе. Предположим значение коэффициента должно быть X ( + 1 или  - 1 в зависимости от цвета), а сейчас равно C. Тогда мы должны прибавить сумму на прямоугольнике с коэффициентом X - C к значению признака. Но сделав это, мы так же прибавим X - C к коэффициентам всех пикселей на префикс-прямоугольнике. Это решение может быть реализовано так, как описано за O(n2m2) или за O(nm).Так же хочется добавить, что от настоящих признаков Хаара данное определение отличается только тем, что настоящие применяются к региону изображения, а не ко всему изображению. Но минимальное число операций можно посчитать по такому же принципу.E. Саша КругАвторы: Krasnokutskiy, 2222Сложность авторского решения составляет O((n + m) * h + n * logn + m * logm), где h — максимальное(среди двух множеств) число точек выпуклой оболочки. Ниже будет доказано, что для данных ограничений имеет место более точная оценка O((n + m) * С2 / 3 + n * logn + m * logm), где С — максимальная координата. Существует две интерпретации решения, мы приведем обе. Для начала докажем независимую оценку на число точек выпуклой оболочки:Пусть есть множество точек на плоскости с целочисленными неотрицательными координатами. Докажем, что количество точек в выпуклой оболочке, в которой никакие три точки не лежат на одной прямой, равно O(C2 / 3), где C — максимальная координата.Пусть выпуклая оболочка в порядке обхода против часовой стрелке образуется последовательностью точек P0, P1, …, Pn - 1. Рассмотрим последовательность векторов P1 - P0, P2 - P1, .., Pn - 1 - Pn - 2, P0 - Pn - 1 Обозначим элемент этой последовательности Vi = P(i + 1)modn - Pi. Рассмотрим такие Vi = (xi, yi), что 0 ≤ xi, yi ≤ C. т.е. вектора, лежащие в первой координатной четверти. Заметим, что эти вектора будут идти подряд в последовательности векторов всех четвертей из-за свойств выпуклой оболочки. Докажем, что их количество равно O(C2 / 3), а доказательство для других четвертей будут аналогичны.Ключевой факт — любая частичная сумма векторов, дает точку из выпуклой оболочки, включая сумму всех векторов. Тогда сумма по каждой координате всех векторов первой четверти не превышает C. Так же, напоминаю, что никакие три точки не лежали на одной прямой в выпуклой оболочке, а значит не существует одинаковых векторов(даже коллинеарных). Посчитаем сколько максимум можно набрать векторов из первой четверти, что бы сумма по каждой координате не превосходила C:0 ≤ sumX, sumY ≤ C. Ослабим ограничения до 0 ≤ sumX + sumY ≤ C, от этого максимальное количество векторов, очевидно, не уменьшится. Будем набирать наше множество жадно, очевидно, что сначала имеет смысл брать вектора с как можно меньшей суммой координат. Возьмем максимальное количество векторов, сумма координат которых 1 , таких векторов всего два: (0, 1), (1, 0). Добавим вектора с суммой 2: (0, 2), (1, 1), (2, 0), их всего три. В общем случаи, если сумма координат равна k, то с такой суммой существует (k + 1) различных векторов. Нам надо набирать вектора до тех пор, пока сумма координат не превзойдет C. Т.е. 1 * 2 + 2 * 3 + 3 * 4 + … + k * (k + 1) = O(C). Можно честно посчитать эту сумму, но её порядок будет O(k3). Отсюда следует, что k = O(C1 / 3). Теперь посчитаем количество векторов, которые мы взяли: 2 + 3 + … + (k + 1) = O(k2). Таким образом максимум можно взять O(C2 / 3) векторов в первой четверти. Во всех других четвертях оценка такая же, из-за соображений симметрии. Теперь можно переходить к разбору решения. Первый вариант интерпретации решения, автор Sklyack:Назовём множества точек A и B разделимыми, если существует окружность, содержащая внутри или на границе все точки одного множества, и не содержащая ни внутри, ни на границе точек другого множества, такую окружность назовём разделяющей. Пусть для определённости точки множества A находятся внутри или на границе окружности, а B -- снаружи. Точки из A на границе разделяющей окружности допускаются, так как немного увеличив радиус, получим A строго внутри, B -- строго снаружи окружности.Пусть A содержит хотя бы две точки. Разделяющую окружность можно сжать так, что она пройдёт через хотя бы две точки из A. Можно перебрать все пары точек и через каждую такую пару попытаться провести разделяющую окружность. Центр искомой окружности лежит на серединном перпендикуляре отрезка pq. Обозначим точки серединного перпендикуляра как l(t), где -- параметр. Все точки, не лежащие на прямой pq, ограничивают параметр t сверху или снизу, точки на прямой pq должны лежать за пределами отрезка pq. Например, на следующем рисунке синяя точка ограничивает центр разделяющей окружности слева, а красные точки -- справа, поэтому центр должен лежать внутри отрезка cd. Переберём все точки и проверим, что найдётся значение t, которое удовлетворяет всем ограничениям. Это даёт нам решение задачи за O((|A|2 + |B|2)(|A| + |B|)).Рассмотрим параболоид z = x2 + y2 и проведём произвольную не вертикальную плоскость ax + by + z = c. Пересечение параболоида и плоскости удовлетворяет уравнению ax + by + x2 + y2 = c, или . Если проецировать точки параболоида (x, y, x2 + y2) на плоскость, , то сечение параболоида плоскостью проецируется в окружность, точки параболоида ниже плоскости проецируются во внутренние точки круга, выше плоскости -- в точки снаружи круга. Так как соответствие взаимно-однозначно, то верно и обратное: при проекции точек плоскости на парабалоид окружность проецируются в сечение параболоида плоскостью, внутренние точки -- в часть параболоида ниже секущей плоскости, внешние -- выше плоскости.Таким образом, проекция точек на параболоид задаёт взаимно-однозначное соответствие между окружностями и плоскостями (не вертикальными), а для разделения множеств A и B точек плоскости окружностью достаточно разделить их трёхмерные проекции на параболоид A′ и B′ не вертикальной плоскостью. Такую плоскость назовём разделяющей (при этом по аналогии с разделяющей окружностью, разделяющая плоскость может содержать точки из A′).По аналогии с разделяющей окружностью, разделяющую плоскость можно провести через две точки множества A′. При этом остальные точки A′ будут лежать ниже или на плоскости. Другими словами, разделяющая плоскость пройдёт через ребро верхней выпуклой оболочки множества A′. При проекции рёбер верхней выпуклой оболочки A′ на плоскость xOy получится некоторое разбиение плоской выпуклой оболочки множества A непересекающимися рёбрами, а разделяющей плоскости соответствует разделяющая окружность, проходящая через ребро разбиения. Обозначим выпуклую оболочку A как coA. В случае, когда никакие 4 вершины coA не лежат на одной окружности, все грани верхней выпуклой оболочки -- треугольники, а полученное разбиение -- триангуляция. В противном случае, достроим полученное разбиение до триангуляции. Для построения разделяющей окружности достаточно перебрать рёбра триангуляции и проверить возможность провести окружность через ребро как описано выше.Полученная триангуляция характеризуется следующим свойством: окружность, описанная около любого треугольника, содержит весь многоугольник coA, так как соответствующая грань трёхмерной выпуклой оболочки проходит выше, чем все трёхмерные точки A′. Эта триангуляция \"противоположна\" триангуляции Делоне, в которой окружность, описанная около любого треугольника, не содержит внутри других точек исходного множества. Её можно назвать триангуляцией Анти-Делоне, вроде бы такой термин где-то используется.Используя характеризующее свойство, триангуляцию Анти-Делоне можно построить методом \"разделяй и властвуй\" без перехода в трёхмерное пространство, работая только с точками плоскости и окружностями. Пусть мы триангулируем многоугольник, образованный вершинами coA при обходе против часовой стрелки с i-й по j-ю. Найдём третью точку треугольника, в который войдет ребро (i, j), то есть такую точку k, что окружность, описанная около треугольника (i, j, k), содержит текущий многоугольник. Для этого переберём вершины текущего многоугольника и выберем ту, которая даёт крайнее положение центра описанной окружности на серединном перпендикуляре ребра (i, j). Окружность будет содержать весь многоугольник coA, так как ребро (i, j) входит в триангуляцию Анти-Делоне. Рекурсивно триангулируем многоугольники с вершинами с i-й по k-ю и с k-й по j-ю. База рекурсии -- отрезок, его триангулировать не нужно. Для решения исходной задачи следуют поменять множества A и B ролями и ещё раз применить описанный алгоритм. Вычислительная сложность решения составляет O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, где C — максимальное абсолютное значение координат заданных точек.Вторая интерпретация, автор 2222:Предположим, что возможно построить разделяющую окружность. Тогда обозначим множество точек внутри окружности как A, а множество точек снаружи, как B.Для простоты описания решения, предположим что никакие 4 точки не лежат на одной окружности. В таком случае, если мы найдём разделяющую окружность, проходящую через несколько точек, то мы всегда сможем немного увеличить радиус и, возможно, немного сдвинуть окружность так, чтобы одно множество точек стало лежать строго внутри окружности, а другое — строго снаружи.Обозначим множество вершин выпуклой оболочки множества A как CH(A), тогда один из вариантов решения задачи — перебрать пары точек из CH(A) и попытаться провести через них окружность, которая содержит все точки CH(A) (а следовательно, и все точки A), а все точки из B лежат снаружи, или на границе окружности. Обозначим пару точек из CH(A) как p и q. Так как все точки из CH(A) должны лежать внутри окружности, а все точки из B — снаружи, то каждая из этих точек задаёт некие ограничения на радиус окружности и на расположение центра окружности относительно прямой, проходящей через точки p и q. Например, на следующем рисунке, точки c, d и e — центры синей и красных окружностей. Заметим, что любая окружность с центром на отрезке cd будет содержать все синие точки, а все красные точки будут снаружи или на границе окружности.Таким образом, мы можем проверить существует ли разделяющая окружность, проходящая через точки p и q, просто проверив вступают ли ограничения на разделяющую окружность в противоречие или нет, это можно сделать за . Cложность всего алгоритма составит . Для того, чтобы понять быстро это или нет, воспользуемся следующим фактом: , где C — максимальная по модулю координата точек из A, тогда сложность алгоритма составит O(C2 + C4 / 3|B|). Очевидно, что этот алгоритм слишком медленный, чтобы уложиться в лимит по времени.Назовём пару точек Ai, Aj хорошей, если существует окружность, проходящая через эти точки, которая содержит в себе все точки CH(A). \\textbf{Лемма 1}. Если каждую хорошую пару точек соединить отрезком, то никакие 2 отрезка, соответствующие 4-ем различным точкам, не пересекаются.Допустим, что это не так, тогда существуют 2 разные окружности с хордами ab и cd соответственно, такие что точки a, b, c и d лежат внутри или на границе этих окружностей.Так как точки c и d лежат внутри окружности с хордой ab, то α + β < π, аналогично точки a и b лежат внутри другой окружности, поэтому γ + δ < π, где α, β, γ и δ углы при a, b, c и d соответственно в четырёхугольнике с вершинами в этих точках. Но так сумма углов четырёхугольника равна 2π, то получили противоречие, значит лемма 1 верна.Пронумеруем вершины CH(A) по часовой стрелке от 1 до h, обозначим i-ую вершину CH(A) как chi. Построим рекурсивную процедуру нахождения всех хороших пар точек на промежутке [i..j], при условии, что пара точек (chi, chj) хорошая. Выберем на промежутке [i + 1..j - 1] такое k, что окружность проходящая через chi, chj и chk содержит CH(A), а следовательно пары точек (chi, chk) и (chj, chk) являются хорошими. Заметим, что такая окружность всегда существует, так как пара (chi, chj) является хорошей. Такое k можно найти за O(j - i) по аналогии с алгоритмом нахождения разделяющей окружности проходящей через 2 точки. Теперь решим задачу для [i..k] и [k..j]. Заметим, что пара точек (ch1, chh) является хорошей, так как соответствующий отрезок является ребром выпуклой оболочки, поэтому для решения всей задачи, выполним данную процедуру для промежутка [1..h]. Данная рекурсивная процедура имеет сложность O(h2) и будет вызвана h - 1 раз, а значит количество хороших пар — O(h).Финальный алгоритм выглядит следующим образом. Переберём все хорошие пары точек, для каждой пары, найдём разделяющую окружность, которая проходит через эту пару точек. Если разделяющая окружность не была найдена, то поменяем множества A и B местами и повторим процедуру. Сложность данного алгоритма составляет .Для того, чтобы не было проблем с точностью, необходимо все вычисления делать в целых числах.F. Юра и разработчикиАвтор: RubanenkoПосмотрим на следующее решение:Пусть f(l, r) — это решения для подмассива [l, r]. Легко заметить, что f(1, n) — это ответ на поставленную задачу. Как считать f(l, r)? Пусть m — это индекс максимального элемента подмассива [l, r]. Все хорошие подмассивы могут быть разбиты на два непересекающихся множества: те, которые содержат m, и те которые его не содержат. Чтобы посчитать последние можно просто вызвать f(l, m - 1) и f(m + 1, r). Осталось посчитать количество \"хороших\" подмассивов, которые содержат m, другими словами, количество пар (i, j), что l ≤ i < m < j ≤ r и g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) означает as + as + 1 + ... + at). Пусть s — это последовательность частичных сумм массива из условия, то есть si = a1 + a2 + ... + ai. Для всех j нам интересно количество i, что sj - si - am%k = 0, так что если мы переберем все возможны j, то нам интересно количество таких i, что si = sj - am(modk) и l ≤ i < m. Имеем ряд запросов на отрезке вида \"сколько есть чисел на отрезке (l, r), что они равны x\". Это можно сделать за O(q + k) времени и памяти, где q — количество запросов, которые сгенерировались в ходе рекурсивного вычисления f(1, n). Авторское решение обрабатывает эти запросы в режиме оффлайн, с помощью массива подсчета. Можно заметить, что в худшем случае мы получим O(n2) запросов, которые очевидно не дадут уложиться в ограничения. Тем не менее, мы можем выбрать, что быстрее: перебрать все возможные j или i. В обоих случаях мы получаем простую сравнимость и запрос на отрезке, описанный выше. Если идти только по меньшему отрезку, то каждый раз, как мы \"проходим\" по элементу w, он переходит в отрезок, который, как минимум, в два раза меньше, чем тот, которому он принадлежал до этого. Таким образом, каждый элемент окажется в отрезке единичной длины(база рекурсии) за O(log(n)) \"проходов\" по нему.Сложность алгоритма O(n × log(n) + k).G. Счастливая очередьАвторы: 2222, MrDindowsДавайте переформулируем условие в терминах башен определенной высоты, которые будут находиться на лестнице. Тогда количество денег соответствующего человека в очереди будет равно высоте башни вместе с высотой ступеньки, на которой башня стоит. А процесс продвижения в очереди будет эквивалентен подъему одной башни на ступеньку вверх, а та, на чье место она взошла — вниз, как показано на иллюстрации. Тогда, становится очевидно, что чтобы все башни на ступеньках были отсортированы, достаточно отсортировать башни без учета высот ступенек. Итого сложность сортировки O(nlog(n)). H. Вырожденная матрицаАвтор: Igor_KudryashovУ вырожденной матрицы строки линейно зависимы, а значит можно представить матрицу B в следующем виде:ПустьПоложим, что элементы первой строки матрицы A являются координатами точки a0 на двухмерной плоскости, а элементы второй строки — координатами точки a1. Представим, что строки матрицы B также являются координатами точек b0 и b1. Заметим, что в этом случае прямая, проходящая через точки b0 и b1, также проходит через точку (0, 0).Будем искать ответ на задачу — число d — бинарным поиском. Предположим мы зафиксировали некоторое число d0 и хотим проверить, существует ли такая матрица B, что В геометрической интерпретации это означает, что точка b0 находится в квадрате, с центром в точке a0 и длиной стороны 2·d0, а точка b1, соответственно, в квадрате с такой же длиной стороны и центром в a1. Таким образом, нам нужно проверить, существует ли прямая, проходящая через точку (0, 0) и пересекающая эти квадраты. Чтобы это сделать, достаточно перебрать вершины одного квадрата, построить прямую, проходящую через выбранную вершину и центр координат и проверить, что она пересекает какую-нибудь из сторон второго квадрата. Затем нужно сделать то же самое, обменяв квадраты. В итоге, если прямая нашлась, то нужно уменьшить границу поиска, иначе расширить.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 20615
        }
      ],
      "code_examples": [
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    // Adjust k based on type if necessary\n    if (type == \"k1\")\n        k = 1;\n    else if (type == \"kn\")\n        k = n;\n    else if (k == -1) {\n        // If k not specified, set randomly between 1 and n\n        k = rnd.next(1, n);\n    }\n    vector<int> a(n);\n    if (type == \"max_ai\") {\n        // All a_i = 1e6\n        fill(a.begin(), a.end(), 1000000);\n    } else if (type == \"min_ai\") {\n        // All a_i = 1\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"odd_total\") {\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000);\n            sum += a[i];\n        }\n        sum %= 2;\n        if (sum == 0) {\n            // Need to make last_ai odd\n            a[n - 1] = rnd.next(1, 500000) * 2 - 1;\n        } else {\n            // Need to make last_ai even\n            a[n - 1] = rnd.next(1, 500000) * 2;\n        }\n    } else if (type == \"even_total\") {\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000);\n            sum += a[i];\n        }\n        sum %= 2;\n        if (sum == 0) {\n            // Need to make last_ai even\n            a[n - 1] = rnd.next(1, 500000) * 2;\n        } else {\n            // Need to make last_ai odd\n            a[n - 1] = rnd.next(1, 500000) * 2 - 1;\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    // Adjust k based on type if necessary\n    if (type == \"k1\")\n        k = 1;\n    else if (type == \"kn\")\n        k = n;\n    else if (k == -1) {\n        // If k not specified, set randomly between 1 and n\n        k = rnd.next(1, n);\n    }\n    vector<int> a(n);\n    if (type == \"max_ai\") {\n        // All a_i = 1e6\n        fill(a.begin(), a.end(), 1000000);\n    } else if (type == \"min_ai\") {\n        // All a_i = 1\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"odd_total\") {\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000);\n            sum += a[i];\n        }\n        sum %= 2;\n        if (sum == 0) {\n            // Need to make last_ai odd\n            a[n - 1] = rnd.next(1, 500000) * 2 - 1;\n        } else {\n            // Need to make last_ai even\n            a[n - 1] = rnd.next(1, 500000) * 2;\n        }\n    } else if (type == \"even_total\") {\n        long long sum = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000);\n            sum += a[i];\n        }\n        sum %= 2;\n        if (sum == 0) {\n            // Need to make last_ai even\n            a[n - 1] = rnd.next(1, 500000) * 2;\n        } else {\n            // Need to make last_ai odd\n            a[n - 1] = rnd.next(1, 500000) * 2 - 1;\n        }\n    } else { // random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000);\n        }\n    }\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type min_ai\n./gen -n 1 -k 1 -type max_ai\n./gen -n 2 -k 1 -type min_ai\n./gen -n 2 -k 2 -type max_ai\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 10 -type random\n./gen -n 100 -k 50 -type odd_total\n./gen -n 100 -k 50 -type even_total\n./gen -n 1000 -k 1 -type min_ai\n./gen -n 1000 -k 1000 -type max_ai\n./gen -n 10000 -k 9999 -type random\n./gen -n 100000 -k 1 -type min_ai\n./gen -n 100000 -k 100000 -type max_ai\n./gen -n 200000 -k 1 -type odd_total\n./gen -n 200000 -k 200000 -type even_total\n./gen -n 200000 -k 100000 -type random\n./gen -n 200000 -k 150000 -type max_ai\n./gen -n 200000 -k 50000 -type min_ai\n./gen -n 200000 -k 1 -type random\n./gen -n 200000 -k 200000 -type random\n./gen -n 200000 -k 100000 -type odd_total\n./gen -n 200000 -k 100000 -type even_total\n./gen -n 200000 -type k1\n./gen -n 200000 -type kn\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 200000 -k 100000 -type max_ai\n./gen -n 200000 -k 100000 -type min_ai\n./gen -n 10000 -k 5000 -type random\n./gen -n 10000 -k 5000 -type odd_total\n./gen -n 10000 -k 5000 -type even_total\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:11.189917",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/D",
      "title": "D. Haar Features",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 100) — the number of rows and columns in the feature.Next n lines contain the description of the feature. Each line consists of m characters, the j-th character of the i-th line equals to \"W\", if this element of the feature is white and \"B\" if it is black.",
      "output_spec": "OutputPrint a single number — the minimum number of operations that you need to make to calculate the value of the feature.",
      "sample_tests": "ExamplesInputCopy6 8BBBBBBBBBBBBBBBBBBBBBBBBWWWWWWWWWWWWWWWWWWWWWWWWOutputCopy2InputCopy3 3WBWBWWWWWOutputCopy4InputCopy3 6WWBBWWWWBBWWWWBBWWOutputCopy3InputCopy4 4BBBBBBBBBBBBBBBWOutputCopy4",
      "description": "D. Haar Features\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 100) — the number of rows and columns in the feature.Next n lines contain the description of the feature. Each line consists of m characters, the j-th character of the i-th line equals to \"W\", if this element of the feature is white and \"B\" if it is black.\n\nOutputPrint a single number — the minimum number of operations that you need to make to calculate the value of the feature.\n\nInputCopy6 8BBBBBBBBBBBBBBBBBBBBBBBBWWWWWWWWWWWWWWWWWWWWWWWWOutputCopy2InputCopy3 3WBWBWWWWWOutputCopy4InputCopy3 6WWBBWWWWBBWWWWBBWWOutputCopy3InputCopy4 4BBBBBBBBBBBBBBBWOutputCopy4\n\nInputCopy6 8BBBBBBBBBBBBBBBBBBBBBBBBWWWWWWWWWWWWWWWWWWWWWWWW\n\nOutputCopy2\n\nInputCopy3 3WBWBWWWWW\n\nOutputCopy4\n\nInputCopy3 6WWBBWWWWBBWWWWBBWW\n\nOutputCopy3\n\nInputCopy4 4BBBBBBBBBBBBBBBW\n\nOutputCopy4\n\nNoteThe first sample corresponds to feature B, the one shown in the picture. The value of this feature in an image of size 6 × 8 equals to the difference of the total brightness of the pixels in the lower and upper half of the image. To calculate its value, perform the following two operations:  add the sum of pixels in the prefix rectangle with the lower right corner in the 6-th row and 8-th column with coefficient 1 to the variable value (the rectangle is indicated by a red frame);  add the number of pixels in the prefix rectangle with the lower right corner in the 3-rd row and 8-th column with coefficient  - 2 and variable value.  Thus, all the pixels in the lower three rows of the image will be included with factor 1, and all pixels in the upper three rows of the image will be included with factor 1 - 2 =  - 1, as required.",
      "solutions": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces",
          "content": "Hi, Codeforces! I am glad to announce Looksery Cup 2015, that is prepared by our developers, each one of them has made a great impact: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 and I. Special thank to coordinator Zlobober for the help with problems and advices and to Delinur for the translation.We've prepared 8 problems for you, that will have random order at the contest. Round will last 2 hours 30 minutes under the standard Codeforces rules with smooth dynamic scoring. We hope, that you will enjoy competition, and we will receive small amount of clars :) Top-200 competitors will get t-shirts with the handle at Codeforces:Winner will get opportunity to have a prepaid trip to San-Francisco. Besides, top-15 competitors will get Oculus Development Kit 2.And competitors from 16 to 50 — gadget Ollie.Also I would like to thank MikeMirzayanov and everybody, who works on Codeforces and Polygon — your contribution in education and IT is hard to be overestimated.UPD. Round will be rated for both divisions.Looking forward to seeing you tomorrow,Looksery Inc.UPD3. EditorialUPD2. Rating will be recalculated today, but it could be changed a little till final results.UPD. Round is over. Thank to everybody, who took part. Congratulations to winners! The final results will be announced in a day, after catching all cheaters. Current top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1556
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces",
          "content": "UPD Editorial of problem E was added, I apologize for the delay. Hope you found it interesting.A. Face DetectionAuthor: MonyuraOne should iterate through each 2x2 square and check if it is possible to rearrange letters in such way they they form the word \"face\". It could be done i.e. by sorting all letters from the square in alphabetic order and comparing the result with the word \"acef\"(sorted letters of word \"face\").B. Looksery PartyAuthor: Igor_KudryashovIn any cases there is such set of people that if they come on party and send messages to their contacts then each employee receives the number of messages that is different from what Igor pointed. Let's show how to build such set. There are 2 cases.There are no zeros among Igor's numbers. So if nobody comes on party then each employee receives 0 messages and, therefore, the desired set is empty.There is at least one zero. Suppose Igor thinks that i-th employee will receive 0 messages. Then we should add i-th employee in the desired set. He will send messages to his contacts and will receive 1 message from himself. If we add other employees in the desired set then the number of messages that i-th employee will receive will not decrease so we can remove him from considering. Igor pointed some numbers for people from contact list of i-th employee and because they have already received one message we need to decrease these numbers by one. After that we can consider the same problem but with number of employees equals to n - 1. If the remaining number of employees is equal to 0 then the desired set is built. C. The Game Of ParityAuthor: olpetOdessaONUIf n = k no moves may be done. The winner is determined with starting parity of citizens' number. Otherwise let's see that the player making the last move may guarantee his victory, if there are both odd and even cities when he makes the move. He just selects the city of which parity he should burn to obtain required parity. So, his enemy's target is to destroy all the cities of some one type. Sometimes the type does matter, sometimes doesn't. It depends on the player's name and the parity of k. So the problem's solution consists in checking if \"non-last\" player's moves number (n - k) / 2 is enough to destroy all the odd or even cities. If Stannis makes the last move and k is even, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the odd cities. If Daenerys makes the last move and k is even, Stannis has no chance to win. If k is odd, Stannis should burn all the even cities.D. Haar FeaturesAuthor: MonyuraThis problem had a complicated statement but it is very similar to the real description of the features. Assume that we have a solution. It means we have a sequence of prefix-rectangles and coefficients to multiply. We can sort that sequence by the bottom-right corner of the rectangle and feature's value wouldn't be changed. Now we could apply our operations from the last one to the first. To calculate the minimum number of operations we will iterate through each pixel starting from the bottom-right in any of the column-major or raw-major order. For each pixel we will maintain the coefficient with which it appears in the feature's value. Initially it is 0 for all. If the coefficient of the current cell is not equal to  + 1 for W and  - 1 for B we increment the required amount of operations. Now we should make coefficient to have a proper value. Assume that it has to be X( - 1 or  + 1 depends on the color) but current coefficient of this pixel is C. Then we should anyway add this pixel's value to the feature's value with the coefficient X - C. But the only way to add this pixel's value now(after skipping all pixels that have not smaller index of both row and column) is to get sum on the prefix rectangle with the bottom-left corner in this pixel. Doing this addition we also add X - C to the coefficient of all pixels in prefix-rectangle. This solution could be implemented as I describe above in O(n2m2) or O(nm).Also I want to notice that in real Haar-like features one applies them not to the whole image but to the part of the image. Anyway, the minimum amount of operations could be calculated in the same way.E. Sasha CircleAuthors: Krasnokutskiy, 2222Author's solution has complexity , where C is a maximum absolute value of the coordinates of all given points.Let’s call a set of points A and B separable if there’s a circle inside or on the boundary of which lie all the points of one set. When there’re no points neither inside nor on the boundary of the circle we call this circle separating. Let points of the set A lie inside or on the boundary of the circle and points of the set B lie outside the circle. Points from set A are allowed to be on the boundary of the separative circle as after increasing radius a little we’re getting set A strictly inside and set B strictly outside the circle.Let A contain at least two points. Separating circle can be compressed in such a way that it’ll pass at least through two points of the set A. It’s possible to look over all the pairs of points and try to pass each pair through the separating circle. The centre of the desired circle lies on the medial perpendicular of the segment pq. Let’s designate the points of the medial perpendicular as l(t) where is a parameter. All the points that don’t lie on the straight line pq make parameter t bounded above or below. All the points that lie on the straight line pq have to lie outside the limits of the segment pq. E.g. a picture below displays a blue point which bounds the centre of separating circle from the left side and red points – from the right side. That’s why the centre has to lie inside a segment cd.Let’s look over all the points to make sure that a value t which satisfies all the bounds exists. This provides us with the problem solving for O((|A|2 + |B|2)(|A| + |B|)).Let’s examine paraboloid z = x2 + y2 and draw arbitrary non-vertical plane ax + by + z = c. The intersection of the paraboloid and the plane satysfies the equation ax + by + x2 + y2 = c, or . If project points of the paraboloid (x, y, x2 + y2) onto the plane the cross-section of the paraboloid formed by the plane projects onto a circle, the paraboloid points below the plane projects onto internal points of the circle, those above the plane projects onto points outside the circle. As is one-to-one correspondence the opposite is also true: when points of the plane project onto the paraboloid the plane projects onto the cross-section of the paraboloid formed by the plane, the internal points – onto the paraboloid below the cross-section and external points – above the cross-section.So, projection of points onto paraboloid assigns one-to-one correspondence between circles and planes (non-vertical). partitioning of sets of points A and B of plane by circle can be done by means of partitioning of their three-dimensional projections into paraboloid A′ and B′ by non-vertical plane. Let’s call such a plane separating (like separating circle, separating plane can include points from A′).By analogy with separating, circle separating plane can be passed through two points of set A′. All the other points of A′ will lie below or on the plane. In other words separating plane will pass through the edge of the upper convex hull of the set A′. The projection of edges of the upper convex hull A′ onto the plane xOy will produce some sort of a set flat convex hull partitioning into A by non-intersecting edges. In this case separating plane corresponds separating circle passing through the edge partition. Let’s designate the convex hull A as coA. In case when none of 4 vertices coA lies within one circle all the edges of the upper convex hull are triangles and the derived partitioning is triangulation. Otherwise the derived partitioning should be completed to be triangulation.To construct a separating circle look over triangulation edges and check the possibility of drawing a circle though an edge as it is described above.The derived triangulation has the following feature: circle drawn around any triangle contains the whole polygon coA as the corresponding bound of three-dimensional convex hull is higher than all three-dimensional points A′. The described triangulation is “opposite” to the Delaunay triangulation according to which circle drawn around any triangle doesn’t contain any points of the original set. This triangulation is commonly known as the Anti-Delaunay triangulation.Using the characterizing feature the Anti-Delaunay triangulation can be constructed by means of the method “divide and conquer” without transferring into three-dimensional space and working with points of plane and circles only. Let us triangulate polygon created by the vertices coA when moving counter-clock-wise from i to j. Let us find the third point of triangle, that will contain edge (i, j). I.e such point k, that circumscribed circle over triangle (i, j, k) contains the whole current polygon. For this purpose let’s iterate through all polygon’s vertices and select the one, that gives the extreme position of the center of the circumscribed circle lied on the mid-perpendicular of (i, j). The circle will contain the whole polygon coA as the edge (i, j) is included in the Anti-Delaunay triangulation. Recursively triangulate polygons with vertices from i to k and from k to j. The base of recursion is a segment, that shouldn't be triangulated. To solve the original problem one should swap A and B and perform the above procedure once more. Complexity of the algorithm is O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, where C is a maximum absolute value of the coordinates of all given points. Actually, O(C3 / 2) is an estimation of the number of points at a convex hull with no three points in a line. F. Yura and DevelopersAuthors: RubanenkoLet's consider following solution:Let f(l, r) be the solution for [l, r] subarray. It's easy to see that f(1, n) is the answer for the given problem. How should one count f(l, r)? Let m be an index of the maximum value over subarray [l, r]. All the good segments can be divided into two non-intersecting sets: those that contain m and those that don't. To count the latter we can call f(l, m - 1) and f(m + 1, r). We are left with counting the number of subarrays that contain m, i.e. the number of pairs (i, j) such that l ≤ i < m < j ≤ r and g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) defines as + as + 1 + ... + at). Let s be the sequence of partial sums of the given array, i.e. si = a1 + a2 + ... + ai. For every j we are interested in the number of such i that sj - si - am%k = 0, so if we iterate over every possible j, then we are interested in number of i that si = sj - am(modk) and l ≤ i < m. So we are left with simple query over the segment problem of form \"how many numbers equal to x and belong to a given segment (l, r)\". It can be done in O(q + k) time and memory, where q is the number of generated queries. Model solution processes all the queries in offline mode, using frequency array. One can notice that in the worst case we can generate O(n2) queries which doesn't fit into TL or ML. However, we can choose which is faster: iterate over all possible j or i. In both cases we get an easy congruence which ends up as a query described above. If we iterate only over the smaller segment, every time we \"look at\" the element w it moves to a smaller segment which is at least two times smaller than the previous one. So, every element will end up in 1-element length segment where recursion will meet it's base in O(log(n)) \"looking at\" this element. The overall complexity is O(n × log(n) + k).G. Happy LineAuthors: 2222, MrDindowsLet's reformulate the condition in terms of a certain height the towers, which will be on the stairs. Then an appropriate amount of money of a person in the queue is equal to the height of the tower with the height of the step at which the tower stands. And the process of moving in the queue will be equivalent to raising a tower on the top step, and the one in whose place it came up — down. As shown in the illustrations. Then, it becomes apparent that to make all of the tower on the steps to be sorted, it is enough to sort the tower without the height of step it stays. Total complexity of sorting is O(nlog(n)). H. Degenerate MatrixAuthor: Igor_KudryashovThe rows of degenerate matrix are linear dependent so the matrix B can be written in the following way:Suppose Let's assume that elements of the first row of matrix A are coordinates of point a0 on two-dimensional plane and the elements of the second row are coordinates of point a1. Assume that the rows of matrix B are also coordinates of points b0 and b1. Let's note that in this case the line that is passing through points b0 and b1 is also passing through point (0, 0).Let's find the answer — the number d — by using binary search. Suppose we are considering some number d0. We need to check if there is such matrix B thatIn geometric interpretation it means that point b0 are inside the square which center is point a0 and length of side is 2·d0. In the same way the point b1 are inside the square which center is point a1 and length of side is 2·d0. So we need to check if there is a line that is passing through point (0, 0) and is crossing these squares. In order to do this we should consider every vertex of the first square, build the line that is passing through the chosen vertex and the center of coordinate plane and check if it cross any side of the other square. Afterwards we should swap the squares and check again. Finally if there is a desired line we need to reduce the search area and to expand otherwise.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 13725
        }
      ],
      "code_examples": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    string pattern = \"[WB]{\" + to_string(m) + \"}\";\n    for(int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    string pattern = \"[WB]{\" + to_string(m) + \"}\";\n    for(int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    string pattern = \"[WB]{\" + to_string(m) + \"}\";\n    for(int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'W'));\n\n    if (type == \"allW\") {\n        // All cells are 'W'; initialized that way\n    } else if (type == \"allB\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, 'B');\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? 'W' : 'B';\n    } else if (type == \"checker\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? 'W' : 'B';\n    } else if (type == \"edgeW\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == 0 || i == n - 1 || j == 0 || j == m - 1) ? 'W' : 'B';\n    } else if (type == \"edgeB\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == 0 || i == n - 1 || j == 0 || j == m - 1) ? 'B' : 'W';\n    } else if (type == \"diagW\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == j) ? 'W' : 'B';\n    } else if (type == \"diagB\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == j) ? 'B' : 'W';\n    } else if (type == \"topW\") {\n        int mid = n / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i] = (i < mid) ? string(m, 'W') : string(m, 'B');\n    } else if (type == \"botW\") {\n        int mid = n / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i] = (i >= mid) ? string(m, 'W') : string(m, 'B');\n    } else if (type == \"leftW\") {\n        int mid = m / 2;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (j < mid) ? 'W' : 'B';\n    } else if (type == \"rightW\") {\n        int mid = m / 2;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (j >= mid) ? 'W' : 'B';\n    } else if (type == \"verticalStripe\") {\n        int k = opt<int>(\"k\", 2); // stripe width\n        for (int j = 0; j < m; ++j) {\n            char ch = ((j / k) % 2 == 0) ? 'W' : 'B';\n            for (int i = 0; i < n; ++i)\n                grid[i][j] = ch;\n        }\n    } else if (type == \"horizontalStripe\") {\n        int k = opt<int>(\"k\", 2); // stripe height\n        for (int i = 0; i < n; ++i) {\n            char ch = ((i / k) % 2 == 0) ? 'W' : 'B';\n            grid[i] = string(m, ch);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? 'W' : 'B';\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, 'W'));\n\n    if (type == \"allW\") {\n        // All cells are 'W'; initialized that way\n    } else if (type == \"allB\") {\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, 'B');\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? 'W' : 'B';\n    } else if (type == \"checker\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? 'W' : 'B';\n    } else if (type == \"edgeW\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == 0 || i == n - 1 || j == 0 || j == m - 1) ? 'W' : 'B';\n    } else if (type == \"edgeB\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == 0 || i == n - 1 || j == 0 || j == m - 1) ? 'B' : 'W';\n    } else if (type == \"diagW\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == j) ? 'W' : 'B';\n    } else if (type == \"diagB\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i == j) ? 'B' : 'W';\n    } else if (type == \"topW\") {\n        int mid = n / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i] = (i < mid) ? string(m, 'W') : string(m, 'B');\n    } else if (type == \"botW\") {\n        int mid = n / 2;\n        for (int i = 0; i < n; ++i)\n            grid[i] = (i >= mid) ? string(m, 'W') : string(m, 'B');\n    } else if (type == \"leftW\") {\n        int mid = m / 2;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (j < mid) ? 'W' : 'B';\n    } else if (type == \"rightW\") {\n        int mid = m / 2;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (j >= mid) ? 'W' : 'B';\n    } else if (type == \"verticalStripe\") {\n        int k = opt<int>(\"k\", 2); // stripe width\n        for (int j = 0; j < m; ++j) {\n            char ch = ((j / k) % 2 == 0) ? 'W' : 'B';\n            for (int i = 0; i < n; ++i)\n                grid[i][j] = ch;\n        }\n    } else if (type == \"horizontalStripe\") {\n        int k = opt<int>(\"k\", 2); // stripe height\n        for (int i = 0; i < n; ++i) {\n            char ch = ((i / k) % 2 == 0) ? 'W' : 'B';\n            grid[i] = string(m, ch);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(2) ? 'W' : 'B';\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type allW\n./gen -n 1 -m 1 -type allB\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type checker\n./gen -n 2 -m 2 -type random\n./gen -n 3 -m 3 -type diagW\n./gen -n 3 -m 3 -type diagB\n./gen -n 1 -m 100 -type edgeW\n./gen -n 1 -m 100 -type edgeB\n./gen -n 100 -m 1 -type edgeW\n./gen -n 100 -m 1 -type edgeB\n./gen -n 10 -m 10 -type verticalStripe -k 2\n./gen -n 10 -m 10 -type horizontalStripe -k 2\n./gen -n 50 -m 50 -type allW\n./gen -n 50 -m 50 -type allB\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type checker\n./gen -n 50 -m 50 -type edgeW\n./gen -n 50 -m 50 -type edgeB\n./gen -n 50 -m 50 -type diagW\n./gen -n 50 -m 50 -type diagB\n./gen -n 100 -m 100 -type allW\n./gen -n 100 -m 100 -type allB\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type checker\n./gen -n 100 -m 100 -type edgeW\n./gen -n 100 -m 100 -type edgeB\n./gen -n 100 -m 100 -type diagW\n./gen -n 100 -m 100 -type diagB\n./gen -n 100 -m 100 -type verticalStripe -k 5\n./gen -n 100 -m 100 -type horizontalStripe -k 5\n./gen -n 100 -m 100 -type topW\n./gen -n 100 -m 100 -type botW\n./gen -n 100 -m 100 -type leftW\n./gen -n 100 -m 100 -type rightW\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:13.459773",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/E",
      "title": "E. Sasha Circle",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 10000), numbers of Misha's and Sasha's trade points respectively.The next n lines contains pairs of space-separated integers Mx, My ( - 104 ≤ Mx, My ≤ 104), coordinates of Misha's trade points.The next m lines contains pairs of space-separated integers Sx, Sy ( - 104 ≤ Sx, Sy ≤ 104), coordinates of Sasha's trade points.It is guaranteed that all n + m points are distinct.",
      "output_spec": "OutputThe only output line should contain either word \"YES\" without quotes in case it is possible to build a such fence or word \"NO\" in the other case.",
      "sample_tests": "ExamplesInputCopy2 2-1 01 00 -10 1OutputCopyNOInputCopy4 41 00 1-1 00 -11 1-1 1-1 -11 -1OutputCopyYES",
      "description": "E. Sasha Circle\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 10000), numbers of Misha's and Sasha's trade points respectively.The next n lines contains pairs of space-separated integers Mx, My ( - 104 ≤ Mx, My ≤ 104), coordinates of Misha's trade points.The next m lines contains pairs of space-separated integers Sx, Sy ( - 104 ≤ Sx, Sy ≤ 104), coordinates of Sasha's trade points.It is guaranteed that all n + m points are distinct.\n\nOutputThe only output line should contain either word \"YES\" without quotes in case it is possible to build a such fence or word \"NO\" in the other case.\n\nInputCopy2 2-1 01 00 -10 1OutputCopyNOInputCopy4 41 00 1-1 00 -11 1-1 1-1 -11 -1OutputCopyYES\n\nInputCopy2 2-1 01 00 -10 1\n\nOutputCopyNO\n\nInputCopy4 41 00 1-1 00 -11 1-1 1-1 -11 -1\n\nOutputCopyYES\n\nNoteIn the first sample there is no possibility to separate points, because any circle that contains both points ( - 1, 0), (1, 0) also contains at least one point from the set (0,  - 1), (0, 1), and vice-versa: any circle that contains both points (0,  - 1), (0, 1) also contains at least one point from the set ( - 1, 0), (1, 0)In the second sample one of the possible solution is shown below. Misha's points are marked with red colour and Sasha's are marked with blue.",
      "solutions": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces",
          "content": "Hi, Codeforces! I am glad to announce Looksery Cup 2015, that is prepared by our developers, each one of them has made a great impact: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 and I. Special thank to coordinator Zlobober for the help with problems and advices and to Delinur for the translation.We've prepared 8 problems for you, that will have random order at the contest. Round will last 2 hours 30 minutes under the standard Codeforces rules with smooth dynamic scoring. We hope, that you will enjoy competition, and we will receive small amount of clars :) Top-200 competitors will get t-shirts with the handle at Codeforces:Winner will get opportunity to have a prepaid trip to San-Francisco. Besides, top-15 competitors will get Oculus Development Kit 2.And competitors from 16 to 50 — gadget Ollie.Also I would like to thank MikeMirzayanov and everybody, who works on Codeforces and Polygon — your contribution in education and IT is hard to be overestimated.UPD. Round will be rated for both divisions.Looking forward to seeing you tomorrow,Looksery Inc.UPD3. EditorialUPD2. Rating will be recalculated today, but it could be changed a little till final results.UPD. Round is over. Thank to everybody, who took part. Congratulations to winners! The final results will be announced in a day, after catching all cheaters. Current top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1556
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces",
          "content": "UPD Editorial of problem E was added, I apologize for the delay. Hope you found it interesting.A. Face DetectionAuthor: MonyuraOne should iterate through each 2x2 square and check if it is possible to rearrange letters in such way they they form the word \"face\". It could be done i.e. by sorting all letters from the square in alphabetic order and comparing the result with the word \"acef\"(sorted letters of word \"face\").B. Looksery PartyAuthor: Igor_KudryashovIn any cases there is such set of people that if they come on party and send messages to their contacts then each employee receives the number of messages that is different from what Igor pointed. Let's show how to build such set. There are 2 cases.There are no zeros among Igor's numbers. So if nobody comes on party then each employee receives 0 messages and, therefore, the desired set is empty.There is at least one zero. Suppose Igor thinks that i-th employee will receive 0 messages. Then we should add i-th employee in the desired set. He will send messages to his contacts and will receive 1 message from himself. If we add other employees in the desired set then the number of messages that i-th employee will receive will not decrease so we can remove him from considering. Igor pointed some numbers for people from contact list of i-th employee and because they have already received one message we need to decrease these numbers by one. After that we can consider the same problem but with number of employees equals to n - 1. If the remaining number of employees is equal to 0 then the desired set is built. C. The Game Of ParityAuthor: olpetOdessaONUIf n = k no moves may be done. The winner is determined with starting parity of citizens' number. Otherwise let's see that the player making the last move may guarantee his victory, if there are both odd and even cities when he makes the move. He just selects the city of which parity he should burn to obtain required parity. So, his enemy's target is to destroy all the cities of some one type. Sometimes the type does matter, sometimes doesn't. It depends on the player's name and the parity of k. So the problem's solution consists in checking if \"non-last\" player's moves number (n - k) / 2 is enough to destroy all the odd or even cities. If Stannis makes the last move and k is even, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the odd cities. If Daenerys makes the last move and k is even, Stannis has no chance to win. If k is odd, Stannis should burn all the even cities.D. Haar FeaturesAuthor: MonyuraThis problem had a complicated statement but it is very similar to the real description of the features. Assume that we have a solution. It means we have a sequence of prefix-rectangles and coefficients to multiply. We can sort that sequence by the bottom-right corner of the rectangle and feature's value wouldn't be changed. Now we could apply our operations from the last one to the first. To calculate the minimum number of operations we will iterate through each pixel starting from the bottom-right in any of the column-major or raw-major order. For each pixel we will maintain the coefficient with which it appears in the feature's value. Initially it is 0 for all. If the coefficient of the current cell is not equal to  + 1 for W and  - 1 for B we increment the required amount of operations. Now we should make coefficient to have a proper value. Assume that it has to be X( - 1 or  + 1 depends on the color) but current coefficient of this pixel is C. Then we should anyway add this pixel's value to the feature's value with the coefficient X - C. But the only way to add this pixel's value now(after skipping all pixels that have not smaller index of both row and column) is to get sum on the prefix rectangle with the bottom-left corner in this pixel. Doing this addition we also add X - C to the coefficient of all pixels in prefix-rectangle. This solution could be implemented as I describe above in O(n2m2) or O(nm).Also I want to notice that in real Haar-like features one applies them not to the whole image but to the part of the image. Anyway, the minimum amount of operations could be calculated in the same way.E. Sasha CircleAuthors: Krasnokutskiy, 2222Author's solution has complexity , where C is a maximum absolute value of the coordinates of all given points.Let’s call a set of points A and B separable if there’s a circle inside or on the boundary of which lie all the points of one set. When there’re no points neither inside nor on the boundary of the circle we call this circle separating. Let points of the set A lie inside or on the boundary of the circle and points of the set B lie outside the circle. Points from set A are allowed to be on the boundary of the separative circle as after increasing radius a little we’re getting set A strictly inside and set B strictly outside the circle.Let A contain at least two points. Separating circle can be compressed in such a way that it’ll pass at least through two points of the set A. It’s possible to look over all the pairs of points and try to pass each pair through the separating circle. The centre of the desired circle lies on the medial perpendicular of the segment pq. Let’s designate the points of the medial perpendicular as l(t) where is a parameter. All the points that don’t lie on the straight line pq make parameter t bounded above or below. All the points that lie on the straight line pq have to lie outside the limits of the segment pq. E.g. a picture below displays a blue point which bounds the centre of separating circle from the left side and red points – from the right side. That’s why the centre has to lie inside a segment cd.Let’s look over all the points to make sure that a value t which satisfies all the bounds exists. This provides us with the problem solving for O((|A|2 + |B|2)(|A| + |B|)).Let’s examine paraboloid z = x2 + y2 and draw arbitrary non-vertical plane ax + by + z = c. The intersection of the paraboloid and the plane satysfies the equation ax + by + x2 + y2 = c, or . If project points of the paraboloid (x, y, x2 + y2) onto the plane the cross-section of the paraboloid formed by the plane projects onto a circle, the paraboloid points below the plane projects onto internal points of the circle, those above the plane projects onto points outside the circle. As is one-to-one correspondence the opposite is also true: when points of the plane project onto the paraboloid the plane projects onto the cross-section of the paraboloid formed by the plane, the internal points – onto the paraboloid below the cross-section and external points – above the cross-section.So, projection of points onto paraboloid assigns one-to-one correspondence between circles and planes (non-vertical). partitioning of sets of points A and B of plane by circle can be done by means of partitioning of their three-dimensional projections into paraboloid A′ and B′ by non-vertical plane. Let’s call such a plane separating (like separating circle, separating plane can include points from A′).By analogy with separating, circle separating plane can be passed through two points of set A′. All the other points of A′ will lie below or on the plane. In other words separating plane will pass through the edge of the upper convex hull of the set A′. The projection of edges of the upper convex hull A′ onto the plane xOy will produce some sort of a set flat convex hull partitioning into A by non-intersecting edges. In this case separating plane corresponds separating circle passing through the edge partition. Let’s designate the convex hull A as coA. In case when none of 4 vertices coA lies within one circle all the edges of the upper convex hull are triangles and the derived partitioning is triangulation. Otherwise the derived partitioning should be completed to be triangulation.To construct a separating circle look over triangulation edges and check the possibility of drawing a circle though an edge as it is described above.The derived triangulation has the following feature: circle drawn around any triangle contains the whole polygon coA as the corresponding bound of three-dimensional convex hull is higher than all three-dimensional points A′. The described triangulation is “opposite” to the Delaunay triangulation according to which circle drawn around any triangle doesn’t contain any points of the original set. This triangulation is commonly known as the Anti-Delaunay triangulation.Using the characterizing feature the Anti-Delaunay triangulation can be constructed by means of the method “divide and conquer” without transferring into three-dimensional space and working with points of plane and circles only. Let us triangulate polygon created by the vertices coA when moving counter-clock-wise from i to j. Let us find the third point of triangle, that will contain edge (i, j). I.e such point k, that circumscribed circle over triangle (i, j, k) contains the whole current polygon. For this purpose let’s iterate through all polygon’s vertices and select the one, that gives the extreme position of the center of the circumscribed circle lied on the mid-perpendicular of (i, j). The circle will contain the whole polygon coA as the edge (i, j) is included in the Anti-Delaunay triangulation. Recursively triangulate polygons with vertices from i to k and from k to j. The base of recursion is a segment, that shouldn't be triangulated. To solve the original problem one should swap A and B and perform the above procedure once more. Complexity of the algorithm is O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, where C is a maximum absolute value of the coordinates of all given points. Actually, O(C3 / 2) is an estimation of the number of points at a convex hull with no three points in a line. F. Yura and DevelopersAuthors: RubanenkoLet's consider following solution:Let f(l, r) be the solution for [l, r] subarray. It's easy to see that f(1, n) is the answer for the given problem. How should one count f(l, r)? Let m be an index of the maximum value over subarray [l, r]. All the good segments can be divided into two non-intersecting sets: those that contain m and those that don't. To count the latter we can call f(l, m - 1) and f(m + 1, r). We are left with counting the number of subarrays that contain m, i.e. the number of pairs (i, j) such that l ≤ i < m < j ≤ r and g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) defines as + as + 1 + ... + at). Let s be the sequence of partial sums of the given array, i.e. si = a1 + a2 + ... + ai. For every j we are interested in the number of such i that sj - si - am%k = 0, so if we iterate over every possible j, then we are interested in number of i that si = sj - am(modk) and l ≤ i < m. So we are left with simple query over the segment problem of form \"how many numbers equal to x and belong to a given segment (l, r)\". It can be done in O(q + k) time and memory, where q is the number of generated queries. Model solution processes all the queries in offline mode, using frequency array. One can notice that in the worst case we can generate O(n2) queries which doesn't fit into TL or ML. However, we can choose which is faster: iterate over all possible j or i. In both cases we get an easy congruence which ends up as a query described above. If we iterate only over the smaller segment, every time we \"look at\" the element w it moves to a smaller segment which is at least two times smaller than the previous one. So, every element will end up in 1-element length segment where recursion will meet it's base in O(log(n)) \"looking at\" this element. The overall complexity is O(n × log(n) + k).G. Happy LineAuthors: 2222, MrDindowsLet's reformulate the condition in terms of a certain height the towers, which will be on the stairs. Then an appropriate amount of money of a person in the queue is equal to the height of the tower with the height of the step at which the tower stands. And the process of moving in the queue will be equivalent to raising a tower on the top step, and the one in whose place it came up — down. As shown in the illustrations. Then, it becomes apparent that to make all of the tower on the steps to be sorted, it is enough to sort the tower without the height of step it stays. Total complexity of sorting is O(nlog(n)). H. Degenerate MatrixAuthor: Igor_KudryashovThe rows of degenerate matrix are linear dependent so the matrix B can be written in the following way:Suppose Let's assume that elements of the first row of matrix A are coordinates of point a0 on two-dimensional plane and the elements of the second row are coordinates of point a1. Assume that the rows of matrix B are also coordinates of points b0 and b1. Let's note that in this case the line that is passing through points b0 and b1 is also passing through point (0, 0).Let's find the answer — the number d — by using binary search. Suppose we are considering some number d0. We need to check if there is such matrix B thatIn geometric interpretation it means that point b0 are inside the square which center is point a0 and length of side is 2·d0. In the same way the point b1 are inside the square which center is point a1 and length of side is 2·d0. So we need to check if there is a line that is passing through point (0, 0) and is crossing these squares. In order to do this we should consider every vertex of the first square, build the line that is passing through the chosen vertex and the center of coordinate plane and check if it cross any side of the other square. Afterwards we should swap the squares and check again. Finally if there is a desired line we need to reduce the search area and to expand otherwise.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 13725
        }
      ],
      "code_examples": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-10000, 10000, \"Mx\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"My\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", x, y);\n        points.insert(p);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(-10000, 10000, \"Sx\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"Sy\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", x, y);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-10000, 10000, \"Mx\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"My\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", x, y);\n        points.insert(p);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(-10000, 10000, \"Sx\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"Sy\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", x, y);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-10000, 10000, \"Mx\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"My\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", x, y);\n        points.insert(p);\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int x = inf.readInt(-10000, 10000, \"Sx\");\n        inf.readSpace();\n        int y = inf.readInt(-10000, 10000, \"Sy\");\n        inf.readEoln();\n        pair<int, int> p = make_pair(x, y);\n        ensuref(points.count(p) == 0, \"Point (%d, %d) is duplicated\", x, y);\n        points.insert(p);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int coord_limit = 10000;\n\nvoid generate_unique_point_in_circle(double cx, double cy, double radius, set<pair<int, int>>& points, int &x_out, int &y_out) {\n    while (true) {\n        double theta = rnd.next(0.0, 2.0 * M_PI);\n        double r = sqrt(rnd.next(0.0, 1.0)) * radius;\n        double x = cx + r * cos(theta);\n        double y = cy + r * sin(theta);\n        int xi = int(round(x));\n        int yi = int(round(y));\n        if (abs(xi) > coord_limit || abs(yi) > coord_limit)\n            continue;\n        if (points.count({xi, yi}) == 0) {\n            x_out = xi;\n            y_out = yi;\n            points.insert({xi, yi});\n            break;\n        }\n    }\n}\n\nvoid generate_unique_point_outside_circle(double cx, double cy, double r_min, set<pair<int, int>>& points, int &x_out, int &y_out) {\n    while (true) {\n        int xi = rnd.next(-coord_limit, coord_limit);\n        int yi = rnd.next(-coord_limit, coord_limit);\n        if (points.count({xi, yi}) != 0) continue;\n        double dist = sqrt((xi - cx)*(xi - cx) + (yi - cy)*(yi - cy));\n        if (dist <= r_min) continue; // Must be outside the circle\n        x_out = xi;\n        y_out = yi;\n        points.insert({xi, yi});\n        break;\n    }\n}\n\nvoid generate_random_unique_point(set<pair<int, int>>& points, int &x_out, int &y_out, int area_limit) {\n    while (true) {\n        int xi = rnd.next(-area_limit, area_limit);\n        int yi = rnd.next(-area_limit, area_limit);\n        if (abs(xi) > coord_limit || abs(yi) > coord_limit)\n            continue;\n        if (points.count({xi, yi}) == 0) {\n            x_out = xi;\n            y_out = yi;\n            points.insert({xi, yi});\n            break;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"yes\");\n\n    set<pair<int, int>> points;\n\n    vector<pair<int, int>> misha_points, sasha_points;\n\n    if (type == \"yes\") {\n        double cx = 0.0, cy = 0.0;\n        double r1 = coord_limit / 3.0;      // Inner circle radius\n        double r2 = 2.0 * coord_limit / 3.0; // Outer circle radius\n\n        // Generate Misha's points inside circle of radius r1\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            generate_unique_point_in_circle(cx, cy, r1, points, x, y);\n            misha_points.push_back({x, y});\n        }\n\n        // Generate Sasha's points outside circle of radius r2\n        for (int i = 0; i < m; ++i) {\n            int x, y;\n            generate_unique_point_outside_circle(cx, cy, r2, points, x, y);\n            sasha_points.push_back({x, y});\n        }\n\n    } else if (type == \"no\") {\n        // Generate n + m random points within a small area\n        int total = n + m;\n        int area_limit = coord_limit / 5; // Small area to force overlap\n        for (int i = 0; i < total; ++i) {\n            int x, y;\n            generate_random_unique_point(points, x, y, area_limit);\n            if (i < n)\n                misha_points.push_back({x, y});\n            else\n                sasha_points.push_back({x, y});\n        }\n\n        // Optional: Shuffle the points to mix them\n        shuffle(misha_points.begin(), misha_points.end());\n        shuffle(sasha_points.begin(), sasha_points.end());\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output Misha's points\n    for (auto p : misha_points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    // Output Sasha's points\n    for (auto p : sasha_points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int coord_limit = 10000;\n\nvoid generate_unique_point_in_circle(double cx, double cy, double radius, set<pair<int, int>>& points, int &x_out, int &y_out) {\n    while (true) {\n        double theta = rnd.next(0.0, 2.0 * M_PI);\n        double r = sqrt(rnd.next(0.0, 1.0)) * radius;\n        double x = cx + r * cos(theta);\n        double y = cy + r * sin(theta);\n        int xi = int(round(x));\n        int yi = int(round(y));\n        if (abs(xi) > coord_limit || abs(yi) > coord_limit)\n            continue;\n        if (points.count({xi, yi}) == 0) {\n            x_out = xi;\n            y_out = yi;\n            points.insert({xi, yi});\n            break;\n        }\n    }\n}\n\nvoid generate_unique_point_outside_circle(double cx, double cy, double r_min, set<pair<int, int>>& points, int &x_out, int &y_out) {\n    while (true) {\n        int xi = rnd.next(-coord_limit, coord_limit);\n        int yi = rnd.next(-coord_limit, coord_limit);\n        if (points.count({xi, yi}) != 0) continue;\n        double dist = sqrt((xi - cx)*(xi - cx) + (yi - cy)*(yi - cy));\n        if (dist <= r_min) continue; // Must be outside the circle\n        x_out = xi;\n        y_out = yi;\n        points.insert({xi, yi});\n        break;\n    }\n}\n\nvoid generate_random_unique_point(set<pair<int, int>>& points, int &x_out, int &y_out, int area_limit) {\n    while (true) {\n        int xi = rnd.next(-area_limit, area_limit);\n        int yi = rnd.next(-area_limit, area_limit);\n        if (abs(xi) > coord_limit || abs(yi) > coord_limit)\n            continue;\n        if (points.count({xi, yi}) == 0) {\n            x_out = xi;\n            y_out = yi;\n            points.insert({xi, yi});\n            break;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"yes\");\n\n    set<pair<int, int>> points;\n\n    vector<pair<int, int>> misha_points, sasha_points;\n\n    if (type == \"yes\") {\n        double cx = 0.0, cy = 0.0;\n        double r1 = coord_limit / 3.0;      // Inner circle radius\n        double r2 = 2.0 * coord_limit / 3.0; // Outer circle radius\n\n        // Generate Misha's points inside circle of radius r1\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            generate_unique_point_in_circle(cx, cy, r1, points, x, y);\n            misha_points.push_back({x, y});\n        }\n\n        // Generate Sasha's points outside circle of radius r2\n        for (int i = 0; i < m; ++i) {\n            int x, y;\n            generate_unique_point_outside_circle(cx, cy, r2, points, x, y);\n            sasha_points.push_back({x, y});\n        }\n\n    } else if (type == \"no\") {\n        // Generate n + m random points within a small area\n        int total = n + m;\n        int area_limit = coord_limit / 5; // Small area to force overlap\n        for (int i = 0; i < total; ++i) {\n            int x, y;\n            generate_random_unique_point(points, x, y, area_limit);\n            if (i < n)\n                misha_points.push_back({x, y});\n            else\n                sasha_points.push_back({x, y});\n        }\n\n        // Optional: Shuffle the points to mix them\n        shuffle(misha_points.begin(), misha_points.end());\n        shuffle(sasha_points.begin(), sasha_points.end());\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output Misha's points\n    for (auto p : misha_points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    // Output Sasha's points\n    for (auto p : sasha_points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type yes\n./gen -n 1 -m 1 -type no\n\n./gen -n 2 -m 2 -type yes\n./gen -n 2 -m 2 -type no\n\n./gen -n 10 -m 10 -type yes\n./gen -n 10 -m 10 -type no\n\n./gen -n 100 -m 100 -type yes\n./gen -n 100 -m 100 -type no\n\n./gen -n 1000 -m 1000 -type yes\n./gen -n 1000 -m 1000 -type no\n\n./gen -n 5000 -m 5000 -type yes\n./gen -n 5000 -m 5000 -type no\n\n./gen -n 10000 -m 10000 -type yes\n./gen -n 10000 -m 10000 -type no\n\n./gen -n 5000 -m 10000 -type yes\n./gen -n 10000 -m 5000 -type no\n\n./gen -n 1 -m 10000 -type yes\n./gen -n 10000 -m 1 -type no\n\n./gen -n 9999 -m 9999 -type yes\n./gen -n 9999 -m 9999 -type no\n\n./gen -n 1234 -m 5678 -type yes\n./gen -n 5678 -m 1234 -type no\n\n./gen -n 1 -m 9999 -type yes\n./gen -n 9999 -m 1 -type no\n\n./gen -n 5000 -m 5000 -type yes\n./gen -n 5000 -m 5000 -type no\n\n./gen -n 2500 -m 7500 -type yes\n./gen -n 7500 -m 2500 -type no\n\n./gen -n 10 -m 10000 -type yes\n./gen -n 10000 -m 10 -type no\n\n./gen -n 1 -m 1 -type yes\n./gen -n 1 -m 10 -type no\n\n./gen -n 10 -m 1 -type yes\n./gen -n 1 -m 10 -type no\n\n./gen -n 10000 -m 10000 -type yes\n./gen -n 10000 -m 10000 -type no\n\n./gen -n 3000 -m 7000 -type yes\n./gen -n 7000 -m 3000 -type no\n\n./gen -n 8000 -m 2000 -type yes\n./gen -n 2000 -m 8000 -type no\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:15.588593",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/F",
      "title": "F. Yura and Developers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two positive integers: n and k (1 ≤ n ≤ 300 000, 1 ≤ k ≤ 1 000 000), the number of tasks in the list and the number of developers in Yura's disposal. The second line contains n integers ai (1 ≤ ai ≤ 109).",
      "output_spec": "OutputOutput a single integer — the number of pairs (l, r) satisfying the conditions from the statement.",
      "sample_tests": "ExamplesInputCopy4 31 2 3 4OutputCopy3InputCopy4 24 4 7 4OutputCopy6",
      "description": "F. Yura and Developers\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains two positive integers: n and k (1 ≤ n ≤ 300 000, 1 ≤ k ≤ 1 000 000), the number of tasks in the list and the number of developers in Yura's disposal. The second line contains n integers ai (1 ≤ ai ≤ 109).\n\nOutputOutput a single integer — the number of pairs (l, r) satisfying the conditions from the statement.\n\nInputCopy4 31 2 3 4OutputCopy3InputCopy4 24 4 7 4OutputCopy6\n\nInputCopy4 31 2 3 4\n\nOutputCopy3\n\nInputCopy4 24 4 7 4\n\nOutputCopy6\n\nNoteIn the first sample there are three good segments: [1;3] — the hardest task requires 3 man-hours, so there are tasks left that require 1 and 2 man-hours. A solution is to make first developer work on the first task for an hour, while second and third developers work on the second task. Each developer works exactly one hour. [1;4] — the hardest task requires 4 man-hours, so there are tasks left that require 1, 2 and 3 man-hours. If the first developer spends an hour on the first task and an hour on the third one, the second developer spends two hours on the second task and the third developer spends two hours on the third task, then they are done, since every developer worked exactly for two hours. [3;4] — the hardest task requires 4 man-hours, so there is only one task left that requires 3 man-hours. A solution is to make each developer work for an hour.",
      "solutions": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces",
          "content": "Hi, Codeforces! I am glad to announce Looksery Cup 2015, that is prepared by our developers, each one of them has made a great impact: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 and I. Special thank to coordinator Zlobober for the help with problems and advices and to Delinur for the translation.We've prepared 8 problems for you, that will have random order at the contest. Round will last 2 hours 30 minutes under the standard Codeforces rules with smooth dynamic scoring. We hope, that you will enjoy competition, and we will receive small amount of clars :) Top-200 competitors will get t-shirts with the handle at Codeforces:Winner will get opportunity to have a prepaid trip to San-Francisco. Besides, top-15 competitors will get Oculus Development Kit 2.And competitors from 16 to 50 — gadget Ollie.Also I would like to thank MikeMirzayanov and everybody, who works on Codeforces and Polygon — your contribution in education and IT is hard to be overestimated.UPD. Round will be rated for both divisions.Looking forward to seeing you tomorrow,Looksery Inc.UPD3. EditorialUPD2. Rating will be recalculated today, but it could be changed a little till final results.UPD. Round is over. Thank to everybody, who took part. Congratulations to winners! The final results will be announced in a day, after catching all cheaters. Current top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1556
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces",
          "content": "UPD Editorial of problem E was added, I apologize for the delay. Hope you found it interesting.A. Face DetectionAuthor: MonyuraOne should iterate through each 2x2 square and check if it is possible to rearrange letters in such way they they form the word \"face\". It could be done i.e. by sorting all letters from the square in alphabetic order and comparing the result with the word \"acef\"(sorted letters of word \"face\").B. Looksery PartyAuthor: Igor_KudryashovIn any cases there is such set of people that if they come on party and send messages to their contacts then each employee receives the number of messages that is different from what Igor pointed. Let's show how to build such set. There are 2 cases.There are no zeros among Igor's numbers. So if nobody comes on party then each employee receives 0 messages and, therefore, the desired set is empty.There is at least one zero. Suppose Igor thinks that i-th employee will receive 0 messages. Then we should add i-th employee in the desired set. He will send messages to his contacts and will receive 1 message from himself. If we add other employees in the desired set then the number of messages that i-th employee will receive will not decrease so we can remove him from considering. Igor pointed some numbers for people from contact list of i-th employee and because they have already received one message we need to decrease these numbers by one. After that we can consider the same problem but with number of employees equals to n - 1. If the remaining number of employees is equal to 0 then the desired set is built. C. The Game Of ParityAuthor: olpetOdessaONUIf n = k no moves may be done. The winner is determined with starting parity of citizens' number. Otherwise let's see that the player making the last move may guarantee his victory, if there are both odd and even cities when he makes the move. He just selects the city of which parity he should burn to obtain required parity. So, his enemy's target is to destroy all the cities of some one type. Sometimes the type does matter, sometimes doesn't. It depends on the player's name and the parity of k. So the problem's solution consists in checking if \"non-last\" player's moves number (n - k) / 2 is enough to destroy all the odd or even cities. If Stannis makes the last move and k is even, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the odd cities. If Daenerys makes the last move and k is even, Stannis has no chance to win. If k is odd, Stannis should burn all the even cities.D. Haar FeaturesAuthor: MonyuraThis problem had a complicated statement but it is very similar to the real description of the features. Assume that we have a solution. It means we have a sequence of prefix-rectangles and coefficients to multiply. We can sort that sequence by the bottom-right corner of the rectangle and feature's value wouldn't be changed. Now we could apply our operations from the last one to the first. To calculate the minimum number of operations we will iterate through each pixel starting from the bottom-right in any of the column-major or raw-major order. For each pixel we will maintain the coefficient with which it appears in the feature's value. Initially it is 0 for all. If the coefficient of the current cell is not equal to  + 1 for W and  - 1 for B we increment the required amount of operations. Now we should make coefficient to have a proper value. Assume that it has to be X( - 1 or  + 1 depends on the color) but current coefficient of this pixel is C. Then we should anyway add this pixel's value to the feature's value with the coefficient X - C. But the only way to add this pixel's value now(after skipping all pixels that have not smaller index of both row and column) is to get sum on the prefix rectangle with the bottom-left corner in this pixel. Doing this addition we also add X - C to the coefficient of all pixels in prefix-rectangle. This solution could be implemented as I describe above in O(n2m2) or O(nm).Also I want to notice that in real Haar-like features one applies them not to the whole image but to the part of the image. Anyway, the minimum amount of operations could be calculated in the same way.E. Sasha CircleAuthors: Krasnokutskiy, 2222Author's solution has complexity , where C is a maximum absolute value of the coordinates of all given points.Let’s call a set of points A and B separable if there’s a circle inside or on the boundary of which lie all the points of one set. When there’re no points neither inside nor on the boundary of the circle we call this circle separating. Let points of the set A lie inside or on the boundary of the circle and points of the set B lie outside the circle. Points from set A are allowed to be on the boundary of the separative circle as after increasing radius a little we’re getting set A strictly inside and set B strictly outside the circle.Let A contain at least two points. Separating circle can be compressed in such a way that it’ll pass at least through two points of the set A. It’s possible to look over all the pairs of points and try to pass each pair through the separating circle. The centre of the desired circle lies on the medial perpendicular of the segment pq. Let’s designate the points of the medial perpendicular as l(t) where is a parameter. All the points that don’t lie on the straight line pq make parameter t bounded above or below. All the points that lie on the straight line pq have to lie outside the limits of the segment pq. E.g. a picture below displays a blue point which bounds the centre of separating circle from the left side and red points – from the right side. That’s why the centre has to lie inside a segment cd.Let’s look over all the points to make sure that a value t which satisfies all the bounds exists. This provides us with the problem solving for O((|A|2 + |B|2)(|A| + |B|)).Let’s examine paraboloid z = x2 + y2 and draw arbitrary non-vertical plane ax + by + z = c. The intersection of the paraboloid and the plane satysfies the equation ax + by + x2 + y2 = c, or . If project points of the paraboloid (x, y, x2 + y2) onto the plane the cross-section of the paraboloid formed by the plane projects onto a circle, the paraboloid points below the plane projects onto internal points of the circle, those above the plane projects onto points outside the circle. As is one-to-one correspondence the opposite is also true: when points of the plane project onto the paraboloid the plane projects onto the cross-section of the paraboloid formed by the plane, the internal points – onto the paraboloid below the cross-section and external points – above the cross-section.So, projection of points onto paraboloid assigns one-to-one correspondence between circles and planes (non-vertical). partitioning of sets of points A and B of plane by circle can be done by means of partitioning of their three-dimensional projections into paraboloid A′ and B′ by non-vertical plane. Let’s call such a plane separating (like separating circle, separating plane can include points from A′).By analogy with separating, circle separating plane can be passed through two points of set A′. All the other points of A′ will lie below or on the plane. In other words separating plane will pass through the edge of the upper convex hull of the set A′. The projection of edges of the upper convex hull A′ onto the plane xOy will produce some sort of a set flat convex hull partitioning into A by non-intersecting edges. In this case separating plane corresponds separating circle passing through the edge partition. Let’s designate the convex hull A as coA. In case when none of 4 vertices coA lies within one circle all the edges of the upper convex hull are triangles and the derived partitioning is triangulation. Otherwise the derived partitioning should be completed to be triangulation.To construct a separating circle look over triangulation edges and check the possibility of drawing a circle though an edge as it is described above.The derived triangulation has the following feature: circle drawn around any triangle contains the whole polygon coA as the corresponding bound of three-dimensional convex hull is higher than all three-dimensional points A′. The described triangulation is “opposite” to the Delaunay triangulation according to which circle drawn around any triangle doesn’t contain any points of the original set. This triangulation is commonly known as the Anti-Delaunay triangulation.Using the characterizing feature the Anti-Delaunay triangulation can be constructed by means of the method “divide and conquer” without transferring into three-dimensional space and working with points of plane and circles only. Let us triangulate polygon created by the vertices coA when moving counter-clock-wise from i to j. Let us find the third point of triangle, that will contain edge (i, j). I.e such point k, that circumscribed circle over triangle (i, j, k) contains the whole current polygon. For this purpose let’s iterate through all polygon’s vertices and select the one, that gives the extreme position of the center of the circumscribed circle lied on the mid-perpendicular of (i, j). The circle will contain the whole polygon coA as the edge (i, j) is included in the Anti-Delaunay triangulation. Recursively triangulate polygons with vertices from i to k and from k to j. The base of recursion is a segment, that shouldn't be triangulated. To solve the original problem one should swap A and B and perform the above procedure once more. Complexity of the algorithm is O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, where C is a maximum absolute value of the coordinates of all given points. Actually, O(C3 / 2) is an estimation of the number of points at a convex hull with no three points in a line. F. Yura and DevelopersAuthors: RubanenkoLet's consider following solution:Let f(l, r) be the solution for [l, r] subarray. It's easy to see that f(1, n) is the answer for the given problem. How should one count f(l, r)? Let m be an index of the maximum value over subarray [l, r]. All the good segments can be divided into two non-intersecting sets: those that contain m and those that don't. To count the latter we can call f(l, m - 1) and f(m + 1, r). We are left with counting the number of subarrays that contain m, i.e. the number of pairs (i, j) such that l ≤ i < m < j ≤ r and g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) defines as + as + 1 + ... + at). Let s be the sequence of partial sums of the given array, i.e. si = a1 + a2 + ... + ai. For every j we are interested in the number of such i that sj - si - am%k = 0, so if we iterate over every possible j, then we are interested in number of i that si = sj - am(modk) and l ≤ i < m. So we are left with simple query over the segment problem of form \"how many numbers equal to x and belong to a given segment (l, r)\". It can be done in O(q + k) time and memory, where q is the number of generated queries. Model solution processes all the queries in offline mode, using frequency array. One can notice that in the worst case we can generate O(n2) queries which doesn't fit into TL or ML. However, we can choose which is faster: iterate over all possible j or i. In both cases we get an easy congruence which ends up as a query described above. If we iterate only over the smaller segment, every time we \"look at\" the element w it moves to a smaller segment which is at least two times smaller than the previous one. So, every element will end up in 1-element length segment where recursion will meet it's base in O(log(n)) \"looking at\" this element. The overall complexity is O(n × log(n) + k).G. Happy LineAuthors: 2222, MrDindowsLet's reformulate the condition in terms of a certain height the towers, which will be on the stairs. Then an appropriate amount of money of a person in the queue is equal to the height of the tower with the height of the step at which the tower stands. And the process of moving in the queue will be equivalent to raising a tower on the top step, and the one in whose place it came up — down. As shown in the illustrations. Then, it becomes apparent that to make all of the tower on the steps to be sorted, it is enough to sort the tower without the height of step it stays. Total complexity of sorting is O(nlog(n)). H. Degenerate MatrixAuthor: Igor_KudryashovThe rows of degenerate matrix are linear dependent so the matrix B can be written in the following way:Suppose Let's assume that elements of the first row of matrix A are coordinates of point a0 on two-dimensional plane and the elements of the second row are coordinates of point a1. Assume that the rows of matrix B are also coordinates of points b0 and b1. Let's note that in this case the line that is passing through points b0 and b1 is also passing through point (0, 0).Let's find the answer — the number d — by using binary search. Suppose we are considering some number d0. We need to check if there is such matrix B thatIn geometric interpretation it means that point b0 are inside the square which center is point a0 and length of side is 2·d0. In the same way the point b1 are inside the square which center is point a1 and length of side is 2·d0. So we need to check if there is a line that is passing through point (0, 0) and is crossing these squares. In order to do this we should consider every vertex of the first square, build the line that is passing through the chosen vertex and the center of coordinate plane and check if it cross any side of the other square. Afterwards we should swap the squares and check again. Finally if there is a desired line we need to reduce the search area and to expand otherwise.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 13725
        }
      ],
      "code_examples": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\"); \n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\"); \n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"ai\"); \n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<int> a(n);\n\n    if (type == \"max_ai\") {\n        for (int i = 0; i < n; i++)\n            a[i] = int(1e9);\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; i++)\n            a[i] = 1;\n    } else if (type == \"equal_ai\") {\n        int val = rnd.next(1, int(1e9));\n        for (int i = 0; i < n; i++)\n            a[i] = val;\n    } else if (type == \"increasing_ai\") {\n        a[0] = rnd.next(1, int(1e9)/n);\n        for (int i = 1; i < n; i++)\n            a[i] = a[i-1] + rnd.next(0, int(1e9)/n);\n    } else if (type == \"decreasing_ai\") {\n        a[0] = rnd.next(int(1e8), int(1e9));\n        for (int i = 1; i < n; i++) {\n            int dec = rnd.next(0, min(a[i-1]-1, int(1e8)/n));\n            a[i] = a[i-1] - dec;\n        }\n        for (int i = 0; i < n; ++i)\n            a[i] = max(a[i], 1);\n    } else if (type == \"multiple_max_ai\") {\n        int max_ai = rnd.next(int(1e8), int(1e9));\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_ai);\n        int m = rnd.next(2, n);\n        for (int i = 0; i < m; ++i)\n            a[i] = max_ai;\n    } else if (type == \"alternating_ai\") {\n        int val1 = rnd.next(1, int(1e9));\n        int val2 = rnd.next(1, int(1e9));\n        for (int i = 0; i < n; i++)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else {\n        // Random ai\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, int(1e9));\n    }\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<int> a(n);\n\n    if (type == \"max_ai\") {\n        for (int i = 0; i < n; i++)\n            a[i] = int(1e9);\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; i++)\n            a[i] = 1;\n    } else if (type == \"equal_ai\") {\n        int val = rnd.next(1, int(1e9));\n        for (int i = 0; i < n; i++)\n            a[i] = val;\n    } else if (type == \"increasing_ai\") {\n        a[0] = rnd.next(1, int(1e9)/n);\n        for (int i = 1; i < n; i++)\n            a[i] = a[i-1] + rnd.next(0, int(1e9)/n);\n    } else if (type == \"decreasing_ai\") {\n        a[0] = rnd.next(int(1e8), int(1e9));\n        for (int i = 1; i < n; i++) {\n            int dec = rnd.next(0, min(a[i-1]-1, int(1e8)/n));\n            a[i] = a[i-1] - dec;\n        }\n        for (int i = 0; i < n; ++i)\n            a[i] = max(a[i], 1);\n    } else if (type == \"multiple_max_ai\") {\n        int max_ai = rnd.next(int(1e8), int(1e9));\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, max_ai);\n        int m = rnd.next(2, n);\n        for (int i = 0; i < m; ++i)\n            a[i] = max_ai;\n    } else if (type == \"alternating_ai\") {\n        int val1 = rnd.next(1, int(1e9));\n        int val2 = rnd.next(1, int(1e9));\n        for (int i = 0; i < n; i++)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else {\n        // Random ai\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, int(1e9));\n    }\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", a[i], i == n-1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, small k, minimal ai\n./gen -n 1 -k 1 -type min_ai\n./gen -n 2 -k 1 -type min_ai\n./gen -n 2 -k 2 -type min_ai\n./gen -n 5 -k 3 -type min_ai\n\n# Small n, small k, maximal ai\n./gen -n 1 -k 1 -type max_ai\n./gen -n 2 -k 1 -type max_ai\n./gen -n 2 -k 2 -type max_ai\n./gen -n 5 -k 3 -type max_ai\n\n# Small n, small k, equal ai\n./gen -n 2 -k 1 -type equal_ai\n./gen -n 5 -k 3 -type equal_ai\n\n# Small n, small k, multiple max ai\n./gen -n 5 -k 2 -type multiple_max_ai\n\n# Small n, large k\n./gen -n 5 -k 1000 -type random\n\n# Medium n, medium k, random ai\n./gen -n 1000 -k 500 -type random\n./gen -n 1000 -k 1 -type random\n\n# Medium n, large k\n./gen -n 1000 -k 1000000 -type random\n\n# Large n, medium k\n./gen -n 300000 -k 500000 -type random\n\n# Large n, small k\n./gen -n 300000 -k 1 -type random\n\n# Large n, large k\n./gen -n 300000 -k 1000000 -type random\n\n# Large n, increasing ai\n./gen -n 300000 -k 500000 -type increasing_ai\n\n# Large n, decreasing ai\n./gen -n 300000 -k 500000 -type decreasing_ai\n\n# Large n, equal ai\n./gen -n 300000 -k 500000 -type equal_ai\n\n# Large n, multiple max ai\n./gen -n 300000 -k 500000 -type multiple_max_ai\n\n# Small n, k=1\n./gen -n 10 -k 1 -type random\n\n# Small n, k=max\n./gen -n 10 -k 1000000 -type random\n\n# Max n, Max k, Max ai\n./gen -n 300000 -k 1000000 -type max_ai\n\n# Max n, Max k, Min ai\n./gen -n 300000 -k 1000000 -type min_ai\n\n# Min n, Min k\n./gen -n 1 -k 1 -type random\n\n# Edge case where ai's are 1\n./gen -n 1000 -k 1 -type min_ai\n\n# Edge case where ai's are max\n./gen -n 1000 -k 1 -type max_ai\n\n# n=1, k > 1\n./gen -n 1 -k 1000000 -type random\n\n# n=2, k=1\n./gen -n 2 -k 1 -type random\n\n# Large n, k=1\n./gen -n 300000 -k 1 -type random\n\n# Test with all ai equal\n./gen -n 300000 -k 1 -type equal_ai\n\n# Test with alternating ai\n./gen -n 200000 -k 500000 -type alternating_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:17.477886",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/G",
      "title": "G. Happy Line",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 200 000) — the number of residents who stand in the line.The second line contains n space-separated integers ai (0 ≤ ai ≤ 109), where ai is the number of Berland dollars of a man standing on the i-th position in the line. The positions are numbered starting from the end of the line.",
      "output_spec": "OutputIf it is impossible to make all the residents happy, print \":(\" without the quotes. Otherwise, print in the single line n space-separated integers, the i-th of them must be equal to the number of money of the person on position i in the new line. If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy211 8OutputCopy9 10 InputCopy510 9 7 10 6OutputCopy:(InputCopy312 3 3OutputCopy4 4 10",
      "description": "G. Happy Line\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 200 000) — the number of residents who stand in the line.The second line contains n space-separated integers ai (0 ≤ ai ≤ 109), where ai is the number of Berland dollars of a man standing on the i-th position in the line. The positions are numbered starting from the end of the line.\n\nOutputIf it is impossible to make all the residents happy, print \":(\" without the quotes. Otherwise, print in the single line n space-separated integers, the i-th of them must be equal to the number of money of the person on position i in the new line. If there are multiple answers, print any of them.\n\nInputCopy211 8OutputCopy9 10 InputCopy510 9 7 10 6OutputCopy:(InputCopy312 3 3OutputCopy4 4 10\n\nInputCopy211 8\n\nOutputCopy9 10\n\nInputCopy510 9 7 10 6\n\nOutputCopy:(\n\nInputCopy312 3 3\n\nOutputCopy4 4 10\n\nNoteIn the first sample two residents should swap places, after that the first resident has 10 dollars and he is at the head of the line and the second resident will have 9 coins and he will be at the end of the line. In the second sample it is impossible to achieve the desired result.In the third sample the first person can swap with the second one, then they will have the following numbers of dollars: 4 11 3, then the second person (in the new line) swaps with the third one, and the resulting numbers of dollars will equal to: 4 4 10. In this line everybody will be happy.",
      "solutions": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces",
          "content": "Hi, Codeforces! I am glad to announce Looksery Cup 2015, that is prepared by our developers, each one of them has made a great impact: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 and I. Special thank to coordinator Zlobober for the help with problems and advices and to Delinur for the translation.We've prepared 8 problems for you, that will have random order at the contest. Round will last 2 hours 30 minutes under the standard Codeforces rules with smooth dynamic scoring. We hope, that you will enjoy competition, and we will receive small amount of clars :) Top-200 competitors will get t-shirts with the handle at Codeforces:Winner will get opportunity to have a prepaid trip to San-Francisco. Besides, top-15 competitors will get Oculus Development Kit 2.And competitors from 16 to 50 — gadget Ollie.Also I would like to thank MikeMirzayanov and everybody, who works on Codeforces and Polygon — your contribution in education and IT is hard to be overestimated.UPD. Round will be rated for both divisions.Looking forward to seeing you tomorrow,Looksery Inc.UPD3. EditorialUPD2. Rating will be recalculated today, but it could be changed a little till final results.UPD. Round is over. Thank to everybody, who took part. Congratulations to winners! The final results will be announced in a day, after catching all cheaters. Current top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1556
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces",
          "content": "UPD Editorial of problem E was added, I apologize for the delay. Hope you found it interesting.A. Face DetectionAuthor: MonyuraOne should iterate through each 2x2 square and check if it is possible to rearrange letters in such way they they form the word \"face\". It could be done i.e. by sorting all letters from the square in alphabetic order and comparing the result with the word \"acef\"(sorted letters of word \"face\").B. Looksery PartyAuthor: Igor_KudryashovIn any cases there is such set of people that if they come on party and send messages to their contacts then each employee receives the number of messages that is different from what Igor pointed. Let's show how to build such set. There are 2 cases.There are no zeros among Igor's numbers. So if nobody comes on party then each employee receives 0 messages and, therefore, the desired set is empty.There is at least one zero. Suppose Igor thinks that i-th employee will receive 0 messages. Then we should add i-th employee in the desired set. He will send messages to his contacts and will receive 1 message from himself. If we add other employees in the desired set then the number of messages that i-th employee will receive will not decrease so we can remove him from considering. Igor pointed some numbers for people from contact list of i-th employee and because they have already received one message we need to decrease these numbers by one. After that we can consider the same problem but with number of employees equals to n - 1. If the remaining number of employees is equal to 0 then the desired set is built. C. The Game Of ParityAuthor: olpetOdessaONUIf n = k no moves may be done. The winner is determined with starting parity of citizens' number. Otherwise let's see that the player making the last move may guarantee his victory, if there are both odd and even cities when he makes the move. He just selects the city of which parity he should burn to obtain required parity. So, his enemy's target is to destroy all the cities of some one type. Sometimes the type does matter, sometimes doesn't. It depends on the player's name and the parity of k. So the problem's solution consists in checking if \"non-last\" player's moves number (n - k) / 2 is enough to destroy all the odd or even cities. If Stannis makes the last move and k is even, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the odd cities. If Daenerys makes the last move and k is even, Stannis has no chance to win. If k is odd, Stannis should burn all the even cities.D. Haar FeaturesAuthor: MonyuraThis problem had a complicated statement but it is very similar to the real description of the features. Assume that we have a solution. It means we have a sequence of prefix-rectangles and coefficients to multiply. We can sort that sequence by the bottom-right corner of the rectangle and feature's value wouldn't be changed. Now we could apply our operations from the last one to the first. To calculate the minimum number of operations we will iterate through each pixel starting from the bottom-right in any of the column-major or raw-major order. For each pixel we will maintain the coefficient with which it appears in the feature's value. Initially it is 0 for all. If the coefficient of the current cell is not equal to  + 1 for W and  - 1 for B we increment the required amount of operations. Now we should make coefficient to have a proper value. Assume that it has to be X( - 1 or  + 1 depends on the color) but current coefficient of this pixel is C. Then we should anyway add this pixel's value to the feature's value with the coefficient X - C. But the only way to add this pixel's value now(after skipping all pixels that have not smaller index of both row and column) is to get sum on the prefix rectangle with the bottom-left corner in this pixel. Doing this addition we also add X - C to the coefficient of all pixels in prefix-rectangle. This solution could be implemented as I describe above in O(n2m2) or O(nm).Also I want to notice that in real Haar-like features one applies them not to the whole image but to the part of the image. Anyway, the minimum amount of operations could be calculated in the same way.E. Sasha CircleAuthors: Krasnokutskiy, 2222Author's solution has complexity , where C is a maximum absolute value of the coordinates of all given points.Let’s call a set of points A and B separable if there’s a circle inside or on the boundary of which lie all the points of one set. When there’re no points neither inside nor on the boundary of the circle we call this circle separating. Let points of the set A lie inside or on the boundary of the circle and points of the set B lie outside the circle. Points from set A are allowed to be on the boundary of the separative circle as after increasing radius a little we’re getting set A strictly inside and set B strictly outside the circle.Let A contain at least two points. Separating circle can be compressed in such a way that it’ll pass at least through two points of the set A. It’s possible to look over all the pairs of points and try to pass each pair through the separating circle. The centre of the desired circle lies on the medial perpendicular of the segment pq. Let’s designate the points of the medial perpendicular as l(t) where is a parameter. All the points that don’t lie on the straight line pq make parameter t bounded above or below. All the points that lie on the straight line pq have to lie outside the limits of the segment pq. E.g. a picture below displays a blue point which bounds the centre of separating circle from the left side and red points – from the right side. That’s why the centre has to lie inside a segment cd.Let’s look over all the points to make sure that a value t which satisfies all the bounds exists. This provides us with the problem solving for O((|A|2 + |B|2)(|A| + |B|)).Let’s examine paraboloid z = x2 + y2 and draw arbitrary non-vertical plane ax + by + z = c. The intersection of the paraboloid and the plane satysfies the equation ax + by + x2 + y2 = c, or . If project points of the paraboloid (x, y, x2 + y2) onto the plane the cross-section of the paraboloid formed by the plane projects onto a circle, the paraboloid points below the plane projects onto internal points of the circle, those above the plane projects onto points outside the circle. As is one-to-one correspondence the opposite is also true: when points of the plane project onto the paraboloid the plane projects onto the cross-section of the paraboloid formed by the plane, the internal points – onto the paraboloid below the cross-section and external points – above the cross-section.So, projection of points onto paraboloid assigns one-to-one correspondence between circles and planes (non-vertical). partitioning of sets of points A and B of plane by circle can be done by means of partitioning of their three-dimensional projections into paraboloid A′ and B′ by non-vertical plane. Let’s call such a plane separating (like separating circle, separating plane can include points from A′).By analogy with separating, circle separating plane can be passed through two points of set A′. All the other points of A′ will lie below or on the plane. In other words separating plane will pass through the edge of the upper convex hull of the set A′. The projection of edges of the upper convex hull A′ onto the plane xOy will produce some sort of a set flat convex hull partitioning into A by non-intersecting edges. In this case separating plane corresponds separating circle passing through the edge partition. Let’s designate the convex hull A as coA. In case when none of 4 vertices coA lies within one circle all the edges of the upper convex hull are triangles and the derived partitioning is triangulation. Otherwise the derived partitioning should be completed to be triangulation.To construct a separating circle look over triangulation edges and check the possibility of drawing a circle though an edge as it is described above.The derived triangulation has the following feature: circle drawn around any triangle contains the whole polygon coA as the corresponding bound of three-dimensional convex hull is higher than all three-dimensional points A′. The described triangulation is “opposite” to the Delaunay triangulation according to which circle drawn around any triangle doesn’t contain any points of the original set. This triangulation is commonly known as the Anti-Delaunay triangulation.Using the characterizing feature the Anti-Delaunay triangulation can be constructed by means of the method “divide and conquer” without transferring into three-dimensional space and working with points of plane and circles only. Let us triangulate polygon created by the vertices coA when moving counter-clock-wise from i to j. Let us find the third point of triangle, that will contain edge (i, j). I.e such point k, that circumscribed circle over triangle (i, j, k) contains the whole current polygon. For this purpose let’s iterate through all polygon’s vertices and select the one, that gives the extreme position of the center of the circumscribed circle lied on the mid-perpendicular of (i, j). The circle will contain the whole polygon coA as the edge (i, j) is included in the Anti-Delaunay triangulation. Recursively triangulate polygons with vertices from i to k and from k to j. The base of recursion is a segment, that shouldn't be triangulated. To solve the original problem one should swap A and B and perform the above procedure once more. Complexity of the algorithm is O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, where C is a maximum absolute value of the coordinates of all given points. Actually, O(C3 / 2) is an estimation of the number of points at a convex hull with no three points in a line. F. Yura and DevelopersAuthors: RubanenkoLet's consider following solution:Let f(l, r) be the solution for [l, r] subarray. It's easy to see that f(1, n) is the answer for the given problem. How should one count f(l, r)? Let m be an index of the maximum value over subarray [l, r]. All the good segments can be divided into two non-intersecting sets: those that contain m and those that don't. To count the latter we can call f(l, m - 1) and f(m + 1, r). We are left with counting the number of subarrays that contain m, i.e. the number of pairs (i, j) such that l ≤ i < m < j ≤ r and g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) defines as + as + 1 + ... + at). Let s be the sequence of partial sums of the given array, i.e. si = a1 + a2 + ... + ai. For every j we are interested in the number of such i that sj - si - am%k = 0, so if we iterate over every possible j, then we are interested in number of i that si = sj - am(modk) and l ≤ i < m. So we are left with simple query over the segment problem of form \"how many numbers equal to x and belong to a given segment (l, r)\". It can be done in O(q + k) time and memory, where q is the number of generated queries. Model solution processes all the queries in offline mode, using frequency array. One can notice that in the worst case we can generate O(n2) queries which doesn't fit into TL or ML. However, we can choose which is faster: iterate over all possible j or i. In both cases we get an easy congruence which ends up as a query described above. If we iterate only over the smaller segment, every time we \"look at\" the element w it moves to a smaller segment which is at least two times smaller than the previous one. So, every element will end up in 1-element length segment where recursion will meet it's base in O(log(n)) \"looking at\" this element. The overall complexity is O(n × log(n) + k).G. Happy LineAuthors: 2222, MrDindowsLet's reformulate the condition in terms of a certain height the towers, which will be on the stairs. Then an appropriate amount of money of a person in the queue is equal to the height of the tower with the height of the step at which the tower stands. And the process of moving in the queue will be equivalent to raising a tower on the top step, and the one in whose place it came up — down. As shown in the illustrations. Then, it becomes apparent that to make all of the tower on the steps to be sorted, it is enough to sort the tower without the height of step it stays. Total complexity of sorting is O(nlog(n)). H. Degenerate MatrixAuthor: Igor_KudryashovThe rows of degenerate matrix are linear dependent so the matrix B can be written in the following way:Suppose Let's assume that elements of the first row of matrix A are coordinates of point a0 on two-dimensional plane and the elements of the second row are coordinates of point a1. Assume that the rows of matrix B are also coordinates of points b0 and b1. Let's note that in this case the line that is passing through points b0 and b1 is also passing through point (0, 0).Let's find the answer — the number d — by using binary search. Suppose we are considering some number d0. We need to check if there is such matrix B thatIn geometric interpretation it means that point b0 are inside the square which center is point a0 and length of side is 2·d0. In the same way the point b1 are inside the square which center is point a1 and length of side is 2·d0. So we need to check if there is a line that is passing through point (0, 0) and is crossing these squares. In order to do this we should consider every vertex of the first square, build the line that is passing through the chosen vertex and the center of coordinate plane and check if it cross any side of the other square. Afterwards we should swap the squares and check again. Finally if there is a desired line we need to reduce the search area and to expand otherwise.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 13725
        }
      ],
      "code_examples": [
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Announce of Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Looksery Cup 2015 Editorial - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> ai(n);\n\n    if (type == \"sorted\") {\n        // ai in non-decreasing order\n        ai[0] = rnd.next(0, 10);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i-1] + rnd.next(0, 10);\n            if (ai[i] > 1000000000) ai[i] = 1000000000; // Cap at 1e9\n        }\n    } else if (type == \"reversed\") {\n        // ai in non-increasing order\n        ai[0] = rnd.next(0, 1000000000);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i-1] - rnd.next(0, 10);\n            if (ai[i] < 0) ai[i] = 0; // Ensure ai[i] >= 0\n        }\n    } else if (type == \"random\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 1000000000);\n        }\n    } else if (type == \"zeros\") {\n        // Some zeros in ai\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0)\n                ai[i] = 0;\n            else\n                ai[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"small\") {\n        // ai in small values\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 10);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i+1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    vector<int> ai(n);\n\n    if (type == \"sorted\") {\n        // ai in non-decreasing order\n        ai[0] = rnd.next(0, 10);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i-1] + rnd.next(0, 10);\n            if (ai[i] > 1000000000) ai[i] = 1000000000; // Cap at 1e9\n        }\n    } else if (type == \"reversed\") {\n        // ai in non-increasing order\n        ai[0] = rnd.next(0, 1000000000);\n        for (int i = 1; i < n; ++i) {\n            ai[i] = ai[i-1] - rnd.next(0, 10);\n            if (ai[i] < 0) ai[i] = 0; // Ensure ai[i] >= 0\n        }\n    } else if (type == \"random\") {\n        // Random ai\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 1000000000);\n        }\n    } else if (type == \"zeros\") {\n        // Some zeros in ai\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0)\n                ai[i] = 0;\n            else\n                ai[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"small\") {\n        // ai in small values\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, 10);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", ai[i]);\n        if (i+1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type sorted\n./gen -n 1 -type reversed\n./gen -n 1 -type random\n\n./gen -n 2 -type sorted\n./gen -n 2 -type reversed\n./gen -n 2 -type random\n\n./gen -n 5 -type sorted\n./gen -n 5 -type reversed\n./gen -n 5 -type random\n./gen -n 5 -type zeros\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type random\n./gen -n 10 -type zeros\n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reversed\n./gen -n 1000 -type random\n./gen -n 1000 -type zeros\n\n./gen -n 200000 -type sorted\n./gen -n 200000 -type reversed\n./gen -n 200000 -type random\n./gen -n 200000 -type zeros\n\n./gen -n 200000 -type small\n./gen -n 2 -type zeros\n./gen -n 199999 -type sorted\n./gen -n 199999 -type reversed\n\n./gen -n 1 -type zeros\n./gen -n 200000 -type random\n./gen -n 200000 -type small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:19.341924",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "549/H",
      "title": "H. Вырожденная матрица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находятся два целых числа a, b (|a|, |b| ≤ 109) — элементы первой строки матрицы A. Во второй строке находятся два целых числа c, d (|c|, |d| ≤ 109) — элементы второй строки матрицы A.",
      "output_spec": "Выходные данныеВыведите единственное вещественное число, минимальное возможное значение ||A - B||. Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превосходит 10 - 9.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 23 4Выходные данныеСкопировать0.2000000000Входные данныеСкопировать1 00 1Выходные данныеСкопировать0.5000000000",
      "description": "H. Вырожденная матрица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке находятся два целых числа a, b (|a|, |b| ≤ 109) — элементы первой строки матрицы A. Во второй строке находятся два целых числа c, d (|c|, |d| ≤ 109) — элементы второй строки матрицы A.\n\nВходные данные\n\nВыходные данныеВыведите единственное вещественное число, минимальное возможное значение ||A - B||. Ваш ответ будет считаться правильным, если его абсолютная или относительная погрешность не превосходит 10 - 9.\n\nВыходные данные\n\nВходные данныеСкопировать1 23 4Выходные данныеСкопировать0.2000000000Входные данныеСкопировать1 00 1Выходные данныеСкопировать0.5000000000\n\nВходные данныеСкопировать1 23 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.2000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 00 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.5000000000\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере матрица B выглядит следующим образом: Во втором примере матрица B выглядит следующим образом:",
      "solutions": [
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces",
          "content": "Codeforces, привет! Я рад анонсировать Looksery Cup 2015, над подготовкой которого работала целая команда наших сотрудников, каждый из которых внес огромный вклад: Sfairat, olpetOdessaONU, Sklyack, MrDindows, Rubanenko, Krasnokutskiy, 2222, Maxim, Avalanche, Igor_Kudryashov, Kepnu4 и я. Отдельное спасибо координатору Zlobober за помощь с задачами и советы, а также Delinur за перевод условий.Мы подготовили для вас 8 задач различной сложности, которые будут расположены в случайном порядке. Раунд будет длиться 2 часа 30 минут и пройдет по правилам Codeforces с плавной динамической стоимостью. Очень надеемся, что задачи понравятся и вы получите удовольствие от соревнования, а мы получим мало кларов :) Топ-200 участников соревнования получат именные футболки с их хендлами на Codeforces:Как сообщалось в предварительном анонсе, победитель соревнования получит возможность поехать в полностью оплаченное путешествие в Сан-Франциско. Кроме этого, топ-15 участников получат Oculus Development Kit 2.А участники с 16 по 50 места — гаджет Ollie.Также хочется выразить большую благодарность MikeMirzayanov и всем, кто трудится над Codeforces и Polygon — ваш вклад в образование и развитие IT сферы трудно переоценить, я думаю все со мной согласятся.UPD. Раунд будет рейтинговым для обоих дивизионов.Ждем вас завтра,Looksery Inc.UPD3. Появился разборUPD2. Рейтинг будет пересчитан сегодня, но завтра могут произойти небольшие изменения, не пугайтесьUPD. Раунд завершился, всем спасибо, что приняли участие. Поздравляем победителей! Окончательные результаты будут объявлены в течении суток, после определения читеров. По предварительным результатам top-15: tourist scott_wu Petr Haghani jqdai0815 PavelKunyavskiy W4yneb0t vepifanov LHiC Gullesnuffs simonlindholm subscriber Shik izban data_h",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18348",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1788
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces",
          "content": "UPD. Появился разбор задачи Е. Мы просим прощения за задержку, он получился действительно трудоемким, и, чтобы как-то загладить свою вину, мы публикуем несколько интерпретаций решения. A. Определение лицАвтор: MonyuraДля решения этой задачи следует перебрать все квадраты 2х2 и проверить, что переставив буквы можно получить слово \"face\". Это можно удобно сделать, например, отсортировав буквы квадрата в алфавитном порядке и проверив, что отсортированное множество равно \"acef\"(Отсортированный порядок букв слова \"face\").B. Вечеринка в LookseryАвтор: Igor_KudryashovПри любом раскладе существует такое множество людей, что, если они придут и разошлют сообщения своим контактам, то каждый сотрудник получит количество сообщений отличное от того, что указал Игорь. Покажем как построить это множество. Рассмотрим 2 случая.Ни одно из чисел, предложенных Игорем, не равно нулю. Тогда если никто не придет на вечеринку, то всем сотрудникам придет по 0 сообщений, и, следовательно, искомое множество — это пустое множество.Хотя бы одно из чисел Игоря равно нулю. Пусть он предполагает, что i-ому сотруднику достанется 0 сообщений. В этом случае добавим i-ого сотрудника в искомое множество. Он разошлет сообщения всем своим контактам и у него самого количество пришедших сообщений станет равно 1. При добавлении других сотрудников в искомое множество, количество сообщений, пришедших i-ому не уменьшится, а, значит, его можно удалить из рассмотрения. Для людей из списка контактов i-го сотрудника Игорь предсказал некоторые количества сообщений, и т.к. по одному сообщению этим людям уже пришло, из желаемых Игорем чисел нужно вычесть единицу. После этого можно перейти к той же задаче, считая что у нас имеется n - 1 сотрудников. Если оставшееся количество сотрудников равно 0, то искомое множество построено. C. Игра чётностиАвтор: olpetOdessaONUЕсли n = k, то ни один ход не может быть совершен. Победитель определяется изначальной суммарной четностью количества жителей. Иначе заметим, что игрок, который делает ход последним, может гарантировать себе победу, если на момент его последнего хода остаются как четные, так и нечетные города — он просто выберет, город с какой четностью сжечь, чтобы получить нужную итоговую четность. Поэтому задача его противника — уничтожить все города какого-то одного типа. Иногда все равно какого, а иногда — нет, это зависит от имени игрока и четности k. Поэтому дальнейшее решение задачи заключается в сравнении количества ходов (n - k) / 2 «непоследнего» игрока с количествами четных и нечетных городов — хватит ли ходов, чтобы их уничтожить. Если последним ходит Станнис, то, в случае четного k, Дейнерис должна сжечь все четные либо все нечетные города. В случае нечетного k, Дейнерис следует сжечь все нечетные города. Если последней ходит Дейнерис, то, в случае четного k ее противник не имеет шансов на победу, а, в случае нечетного k, Станнис должен сжечь все четные города.D. Признаки ХаараАвтор: MonyuraЭта задача имела сложное условие, но максимально близкое к реальности.Один из вариантов решения задачи состоит в изучении структуры ответа. Предположим, что у нас есть ответ, т.е последовательность операций: взятие сумм на префикс-прямоугольнике и коэффициентов, на который умножается сумма. Мы можем менять порядок операций, значение признака при этом меняться не будет. Тогда отсортируем операции по правому нижнему углу прямоугольника. Будем применять операции начиная от последний к первой. Решение состоит в том, что бы не применять операции, которые не нужны и применить все те, которые мы обязаны применить. Для этого для каждого пикселя будем поддерживать коэффициент с которым он сейчас входит в значение признака. Изначально этот коэффициент равен 0. Пройдем по каждому пикселю начиная с нижнего правого угла. Если текущий коэффициент не равен  + 1 для пикселя покрытого W и  - 1 для пикселя покрытого B, то пиксель входит в значение признака с неправильным коэффициентом и нам надо его поменять, для этого используем одну операцию. Единственный способ поменять значение этого пикселя теперь, после того как все большие и по ряду и по столбцу просмотрены — это взять сумму на префикс-прямоугольнике с правым нижним углом в этом пикселе. Предположим значение коэффициента должно быть X ( + 1 или  - 1 в зависимости от цвета), а сейчас равно C. Тогда мы должны прибавить сумму на прямоугольнике с коэффициентом X - C к значению признака. Но сделав это, мы так же прибавим X - C к коэффициентам всех пикселей на префикс-прямоугольнике. Это решение может быть реализовано так, как описано за O(n2m2) или за O(nm).Так же хочется добавить, что от настоящих признаков Хаара данное определение отличается только тем, что настоящие применяются к региону изображения, а не ко всему изображению. Но минимальное число операций можно посчитать по такому же принципу.E. Саша КругАвторы: Krasnokutskiy, 2222Сложность авторского решения составляет O((n + m) * h + n * logn + m * logm), где h — максимальное(среди двух множеств) число точек выпуклой оболочки. Ниже будет доказано, что для данных ограничений имеет место более точная оценка O((n + m) * С2 / 3 + n * logn + m * logm), где С — максимальная координата. Существует две интерпретации решения, мы приведем обе. Для начала докажем независимую оценку на число точек выпуклой оболочки:Пусть есть множество точек на плоскости с целочисленными неотрицательными координатами. Докажем, что количество точек в выпуклой оболочке, в которой никакие три точки не лежат на одной прямой, равно O(C2 / 3), где C — максимальная координата.Пусть выпуклая оболочка в порядке обхода против часовой стрелке образуется последовательностью точек P0, P1, …, Pn - 1. Рассмотрим последовательность векторов P1 - P0, P2 - P1, .., Pn - 1 - Pn - 2, P0 - Pn - 1 Обозначим элемент этой последовательности Vi = P(i + 1)modn - Pi. Рассмотрим такие Vi = (xi, yi), что 0 ≤ xi, yi ≤ C. т.е. вектора, лежащие в первой координатной четверти. Заметим, что эти вектора будут идти подряд в последовательности векторов всех четвертей из-за свойств выпуклой оболочки. Докажем, что их количество равно O(C2 / 3), а доказательство для других четвертей будут аналогичны.Ключевой факт — любая частичная сумма векторов, дает точку из выпуклой оболочки, включая сумму всех векторов. Тогда сумма по каждой координате всех векторов первой четверти не превышает C. Так же, напоминаю, что никакие три точки не лежали на одной прямой в выпуклой оболочке, а значит не существует одинаковых векторов(даже коллинеарных). Посчитаем сколько максимум можно набрать векторов из первой четверти, что бы сумма по каждой координате не превосходила C:0 ≤ sumX, sumY ≤ C. Ослабим ограничения до 0 ≤ sumX + sumY ≤ C, от этого максимальное количество векторов, очевидно, не уменьшится. Будем набирать наше множество жадно, очевидно, что сначала имеет смысл брать вектора с как можно меньшей суммой координат. Возьмем максимальное количество векторов, сумма координат которых 1 , таких векторов всего два: (0, 1), (1, 0). Добавим вектора с суммой 2: (0, 2), (1, 1), (2, 0), их всего три. В общем случаи, если сумма координат равна k, то с такой суммой существует (k + 1) различных векторов. Нам надо набирать вектора до тех пор, пока сумма координат не превзойдет C. Т.е. 1 * 2 + 2 * 3 + 3 * 4 + … + k * (k + 1) = O(C). Можно честно посчитать эту сумму, но её порядок будет O(k3). Отсюда следует, что k = O(C1 / 3). Теперь посчитаем количество векторов, которые мы взяли: 2 + 3 + … + (k + 1) = O(k2). Таким образом максимум можно взять O(C2 / 3) векторов в первой четверти. Во всех других четвертях оценка такая же, из-за соображений симметрии. Теперь можно переходить к разбору решения. Первый вариант интерпретации решения, автор Sklyack:Назовём множества точек A и B разделимыми, если существует окружность, содержащая внутри или на границе все точки одного множества, и не содержащая ни внутри, ни на границе точек другого множества, такую окружность назовём разделяющей. Пусть для определённости точки множества A находятся внутри или на границе окружности, а B -- снаружи. Точки из A на границе разделяющей окружности допускаются, так как немного увеличив радиус, получим A строго внутри, B -- строго снаружи окружности.Пусть A содержит хотя бы две точки. Разделяющую окружность можно сжать так, что она пройдёт через хотя бы две точки из A. Можно перебрать все пары точек и через каждую такую пару попытаться провести разделяющую окружность. Центр искомой окружности лежит на серединном перпендикуляре отрезка pq. Обозначим точки серединного перпендикуляра как l(t), где -- параметр. Все точки, не лежащие на прямой pq, ограничивают параметр t сверху или снизу, точки на прямой pq должны лежать за пределами отрезка pq. Например, на следующем рисунке синяя точка ограничивает центр разделяющей окружности слева, а красные точки -- справа, поэтому центр должен лежать внутри отрезка cd. Переберём все точки и проверим, что найдётся значение t, которое удовлетворяет всем ограничениям. Это даёт нам решение задачи за O((|A|2 + |B|2)(|A| + |B|)).Рассмотрим параболоид z = x2 + y2 и проведём произвольную не вертикальную плоскость ax + by + z = c. Пересечение параболоида и плоскости удовлетворяет уравнению ax + by + x2 + y2 = c, или . Если проецировать точки параболоида (x, y, x2 + y2) на плоскость, , то сечение параболоида плоскостью проецируется в окружность, точки параболоида ниже плоскости проецируются во внутренние точки круга, выше плоскости -- в точки снаружи круга. Так как соответствие взаимно-однозначно, то верно и обратное: при проекции точек плоскости на парабалоид окружность проецируются в сечение параболоида плоскостью, внутренние точки -- в часть параболоида ниже секущей плоскости, внешние -- выше плоскости.Таким образом, проекция точек на параболоид задаёт взаимно-однозначное соответствие между окружностями и плоскостями (не вертикальными), а для разделения множеств A и B точек плоскости окружностью достаточно разделить их трёхмерные проекции на параболоид A′ и B′ не вертикальной плоскостью. Такую плоскость назовём разделяющей (при этом по аналогии с разделяющей окружностью, разделяющая плоскость может содержать точки из A′).По аналогии с разделяющей окружностью, разделяющую плоскость можно провести через две точки множества A′. При этом остальные точки A′ будут лежать ниже или на плоскости. Другими словами, разделяющая плоскость пройдёт через ребро верхней выпуклой оболочки множества A′. При проекции рёбер верхней выпуклой оболочки A′ на плоскость xOy получится некоторое разбиение плоской выпуклой оболочки множества A непересекающимися рёбрами, а разделяющей плоскости соответствует разделяющая окружность, проходящая через ребро разбиения. Обозначим выпуклую оболочку A как coA. В случае, когда никакие 4 вершины coA не лежат на одной окружности, все грани верхней выпуклой оболочки -- треугольники, а полученное разбиение -- триангуляция. В противном случае, достроим полученное разбиение до триангуляции. Для построения разделяющей окружности достаточно перебрать рёбра триангуляции и проверить возможность провести окружность через ребро как описано выше.Полученная триангуляция характеризуется следующим свойством: окружность, описанная около любого треугольника, содержит весь многоугольник coA, так как соответствующая грань трёхмерной выпуклой оболочки проходит выше, чем все трёхмерные точки A′. Эта триангуляция \"противоположна\" триангуляции Делоне, в которой окружность, описанная около любого треугольника, не содержит внутри других точек исходного множества. Её можно назвать триангуляцией Анти-Делоне, вроде бы такой термин где-то используется.Используя характеризующее свойство, триангуляцию Анти-Делоне можно построить методом \"разделяй и властвуй\" без перехода в трёхмерное пространство, работая только с точками плоскости и окружностями. Пусть мы триангулируем многоугольник, образованный вершинами coA при обходе против часовой стрелки с i-й по j-ю. Найдём третью точку треугольника, в который войдет ребро (i, j), то есть такую точку k, что окружность, описанная около треугольника (i, j, k), содержит текущий многоугольник. Для этого переберём вершины текущего многоугольника и выберем ту, которая даёт крайнее положение центра описанной окружности на серединном перпендикуляре ребра (i, j). Окружность будет содержать весь многоугольник coA, так как ребро (i, j) входит в триангуляцию Анти-Делоне. Рекурсивно триангулируем многоугольники с вершинами с i-й по k-ю и с k-й по j-ю. База рекурсии -- отрезок, его триангулировать не нужно. Для решения исходной задачи следуют поменять множества A и B ролями и ещё раз применить описанный алгоритм. Вычислительная сложность решения составляет O(|A|log|A| + |coA|(|coA| + |B|) + |B|log|B| + |coB|(|coB| + |A|)=, где C — максимальное абсолютное значение координат заданных точек.Вторая интерпретация, автор 2222:Предположим, что возможно построить разделяющую окружность. Тогда обозначим множество точек внутри окружности как A, а множество точек снаружи, как B.Для простоты описания решения, предположим что никакие 4 точки не лежат на одной окружности. В таком случае, если мы найдём разделяющую окружность, проходящую через несколько точек, то мы всегда сможем немного увеличить радиус и, возможно, немного сдвинуть окружность так, чтобы одно множество точек стало лежать строго внутри окружности, а другое — строго снаружи.Обозначим множество вершин выпуклой оболочки множества A как CH(A), тогда один из вариантов решения задачи — перебрать пары точек из CH(A) и попытаться провести через них окружность, которая содержит все точки CH(A) (а следовательно, и все точки A), а все точки из B лежат снаружи, или на границе окружности. Обозначим пару точек из CH(A) как p и q. Так как все точки из CH(A) должны лежать внутри окружности, а все точки из B — снаружи, то каждая из этих точек задаёт некие ограничения на радиус окружности и на расположение центра окружности относительно прямой, проходящей через точки p и q. Например, на следующем рисунке, точки c, d и e — центры синей и красных окружностей. Заметим, что любая окружность с центром на отрезке cd будет содержать все синие точки, а все красные точки будут снаружи или на границе окружности.Таким образом, мы можем проверить существует ли разделяющая окружность, проходящая через точки p и q, просто проверив вступают ли ограничения на разделяющую окружность в противоречие или нет, это можно сделать за . Cложность всего алгоритма составит . Для того, чтобы понять быстро это или нет, воспользуемся следующим фактом: , где C — максимальная по модулю координата точек из A, тогда сложность алгоритма составит O(C2 + C4 / 3|B|). Очевидно, что этот алгоритм слишком медленный, чтобы уложиться в лимит по времени.Назовём пару точек Ai, Aj хорошей, если существует окружность, проходящая через эти точки, которая содержит в себе все точки CH(A). \\textbf{Лемма 1}. Если каждую хорошую пару точек соединить отрезком, то никакие 2 отрезка, соответствующие 4-ем различным точкам, не пересекаются.Допустим, что это не так, тогда существуют 2 разные окружности с хордами ab и cd соответственно, такие что точки a, b, c и d лежат внутри или на границе этих окружностей.Так как точки c и d лежат внутри окружности с хордой ab, то α + β < π, аналогично точки a и b лежат внутри другой окружности, поэтому γ + δ < π, где α, β, γ и δ углы при a, b, c и d соответственно в четырёхугольнике с вершинами в этих точках. Но так сумма углов четырёхугольника равна 2π, то получили противоречие, значит лемма 1 верна.Пронумеруем вершины CH(A) по часовой стрелке от 1 до h, обозначим i-ую вершину CH(A) как chi. Построим рекурсивную процедуру нахождения всех хороших пар точек на промежутке [i..j], при условии, что пара точек (chi, chj) хорошая. Выберем на промежутке [i + 1..j - 1] такое k, что окружность проходящая через chi, chj и chk содержит CH(A), а следовательно пары точек (chi, chk) и (chj, chk) являются хорошими. Заметим, что такая окружность всегда существует, так как пара (chi, chj) является хорошей. Такое k можно найти за O(j - i) по аналогии с алгоритмом нахождения разделяющей окружности проходящей через 2 точки. Теперь решим задачу для [i..k] и [k..j]. Заметим, что пара точек (ch1, chh) является хорошей, так как соответствующий отрезок является ребром выпуклой оболочки, поэтому для решения всей задачи, выполним данную процедуру для промежутка [1..h]. Данная рекурсивная процедура имеет сложность O(h2) и будет вызвана h - 1 раз, а значит количество хороших пар — O(h).Финальный алгоритм выглядит следующим образом. Переберём все хорошие пары точек, для каждой пары, найдём разделяющую окружность, которая проходит через эту пару точек. Если разделяющая окружность не была найдена, то поменяем множества A и B местами и повторим процедуру. Сложность данного алгоритма составляет .Для того, чтобы не было проблем с точностью, необходимо все вычисления делать в целых числах.F. Юра и разработчикиАвтор: RubanenkoПосмотрим на следующее решение:Пусть f(l, r) — это решения для подмассива [l, r]. Легко заметить, что f(1, n) — это ответ на поставленную задачу. Как считать f(l, r)? Пусть m — это индекс максимального элемента подмассива [l, r]. Все хорошие подмассивы могут быть разбиты на два непересекающихся множества: те, которые содержат m, и те которые его не содержат. Чтобы посчитать последние можно просто вызвать f(l, m - 1) и f(m + 1, r). Осталось посчитать количество \"хороших\" подмассивов, которые содержат m, другими словами, количество пар (i, j), что l ≤ i < m < j ≤ r и g(i, m - 1) + g(m + 1, j)%k = 0 (g(s, t) означает as + as + 1 + ... + at). Пусть s — это последовательность частичных сумм массива из условия, то есть si = a1 + a2 + ... + ai. Для всех j нам интересно количество i, что sj - si - am%k = 0, так что если мы переберем все возможны j, то нам интересно количество таких i, что si = sj - am(modk) и l ≤ i < m. Имеем ряд запросов на отрезке вида \"сколько есть чисел на отрезке (l, r), что они равны x\". Это можно сделать за O(q + k) времени и памяти, где q — количество запросов, которые сгенерировались в ходе рекурсивного вычисления f(1, n). Авторское решение обрабатывает эти запросы в режиме оффлайн, с помощью массива подсчета. Можно заметить, что в худшем случае мы получим O(n2) запросов, которые очевидно не дадут уложиться в ограничения. Тем не менее, мы можем выбрать, что быстрее: перебрать все возможные j или i. В обоих случаях мы получаем простую сравнимость и запрос на отрезке, описанный выше. Если идти только по меньшему отрезку, то каждый раз, как мы \"проходим\" по элементу w, он переходит в отрезок, который, как минимум, в два раза меньше, чем тот, которому он принадлежал до этого. Таким образом, каждый элемент окажется в отрезке единичной длины(база рекурсии) за O(log(n)) \"проходов\" по нему.Сложность алгоритма O(n × log(n) + k).G. Счастливая очередьАвторы: 2222, MrDindowsДавайте переформулируем условие в терминах башен определенной высоты, которые будут находиться на лестнице. Тогда количество денег соответствующего человека в очереди будет равно высоте башни вместе с высотой ступеньки, на которой башня стоит. А процесс продвижения в очереди будет эквивалентен подъему одной башни на ступеньку вверх, а та, на чье место она взошла — вниз, как показано на иллюстрации. Тогда, становится очевидно, что чтобы все башни на ступеньках были отсортированы, достаточно отсортировать башни без учета высот ступенек. Итого сложность сортировки O(nlog(n)). H. Вырожденная матрицаАвтор: Igor_KudryashovУ вырожденной матрицы строки линейно зависимы, а значит можно представить матрицу B в следующем виде:ПустьПоложим, что элементы первой строки матрицы A являются координатами точки a0 на двухмерной плоскости, а элементы второй строки — координатами точки a1. Представим, что строки матрицы B также являются координатами точек b0 и b1. Заметим, что в этом случае прямая, проходящая через точки b0 и b1, также проходит через точку (0, 0).Будем искать ответ на задачу — число d — бинарным поиском. Предположим мы зафиксировали некоторое число d0 и хотим проверить, существует ли такая матрица B, что В геометрической интерпретации это означает, что точка b0 находится в квадрате, с центром в точке a0 и длиной стороны 2·d0, а точка b1, соответственно, в квадрате с такой же длиной стороны и центром в a1. Таким образом, нам нужно проверить, существует ли прямая, проходящая через точку (0, 0) и пересекающая эти квадраты. Чтобы это сделать, достаточно перебрать вершины одного квадрата, построить прямую, проходящую через выбранную вершину и центр координат и проверить, что она пересекает какую-нибудь из сторон второго квадрата. Затем нужно сделать то же самое, обменяв квадраты. В итоге, если прямая нашлась, то нужно уменьшить границу поиска, иначе расширить.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18363",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 20615
        }
      ],
      "code_examples": [
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 1",
          "code": "Top-200 competitors will get t-shirts with the handle at Codeforces.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 2",
          "code": "Winner will get opportunity to have a prepaid trip to San-Francisco.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 3",
          "code": "Besides, top-15 competitors will get Oculus Development Kit 2.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 4",
          "code": "And competitors from 16 to 50 — gadget Ollie.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 5",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 6",
          "code": "for (int bs = -1; bs <= 1; bs += 2) {\n\t\tfor (int cs = -1; cs <= 1; cs += 2) {\n\t\t\tfor (int ds = -1; ds <= 1; ds += 2) {\n\t\t\t\tif (bs*cs == ds) {\n\t\t\t\t\tlong long den = -a + bs*b + cs*c - ds*d;\n\t\t\t\t\tif (den != 0) k = min(k, fabs((a*d - b*c) / (double) den));\n\t\t\t\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Анонс Looksery Cup 2015 - Codeforces - Code 7",
          "code": "Public - your code will be available to everyone",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18348",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 1",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 2",
          "code": "If Stannis makes the last move and k is odd, Daenerys should burn all the odd or all the even cities. If k is even, Daenerys should burn all the odd cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 3",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 4",
          "code": "If Stannis makes the last move and k is **even**, Daenerys should burn all the odd or all the even cities. If k is odd, Daenerys should burn all the **odd** cities",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 5",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Looksery Cup 2015 - Codeforces - Code 6",
          "code": "using t=0\n\n| 6    5   | = |6 5|\n| 6*0  5*0 |   |0 0|\n\ninstead of | 0   0  |\n           | 6   5  |",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18363",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n    int c = inf.readInt(-1000000000, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(-1000000000, 1000000000, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n    int c = inf.readInt(-1000000000, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(-1000000000, 1000000000, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int a = inf.readInt(-1000000000, 1000000000, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000, \"b\");\n    inf.readEoln();\n    int c = inf.readInt(-1000000000, 1000000000, \"c\");\n    inf.readSpace();\n    int d = inf.readInt(-1000000000, 1000000000, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    long long max_abs = opt<long long>(\"max_abs\", 1000000000LL);\n\n    long long a, b, c, d;\n\n    auto getRandom = [&]() {\n        return rnd.next(-max_abs, max_abs);\n    };\n\n    if (type == \"random\") {\n        // Generate all elements randomly in [-max_abs, max_abs]\n        a = getRandom();\n        b = getRandom();\n        c = getRandom();\n        d = getRandom();\n    } else if (type == \"zero_determinant\") {\n        // Generate elements such that determinant is zero\n        // That is, ad - bc = 0\n        // We can set a, b, c randomly and compute d = (bc)/a if a != 0\n        // Be careful with division by zero\n        while (true) {\n            a = getRandom();\n            b = getRandom();\n            c = getRandom();\n            if (a != 0) {\n                d = (b * c) / a;\n                if (abs(d) <= max_abs && a * d - b * c == 0) break;\n            } else {\n                // If a == 0, set d randomly and set b == 0 or c == 0 to make determinant zero\n                d = getRandom();\n                if (b == 0 || c == 0) {\n                    // ad - bc = 0\n                    break;\n                }\n                if (b * c == 0) {\n                    // ad - bc = 0\n                    break;\n                }\n            }\n        }\n    } else if (type == \"near_zero_determinant\") {\n        // Generate elements such that determinant is close to zero\n        // ad - bc = delta (small integer)\n        long long delta = rnd.next(-10LL, 10LL); // Small determinant\n        if (delta == 0) delta = rnd.next(1, 10); // Ensure delta != 0\n        while (true) {\n            a = getRandom();\n            b = getRandom();\n            c = getRandom();\n            if (a != 0) {\n                d = (b * c + delta) / a;\n                if (abs(d) <= max_abs && a * d - b * c == delta) break;\n            } else {\n                // a == 0, so ad - bc = -bc = delta => b or c can be adjusted\n                if (b != 0) {\n                    c = -delta / b;\n                    d = getRandom();\n                    if (abs(c) <= max_abs && a * d - b * c == delta) break;\n                } else {\n                    b = getRandom();\n                }\n            }\n        }\n    } else if (type == \"max_elements\") {\n        // Elements are at maximum absolute value\n        a = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n        b = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n        c = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n        d = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n    } else if (type == \"identity\") {\n        // Identity matrix [[1,0],[0,1]]\n        a = 1;\n        b = 0;\n        c = 0;\n        d = 1;\n    } else if (type == \"scalar\") {\n        // Matrix where all elements are same\n        a = b = c = d = getRandom();\n    } else if (type == \"diagonal\") {\n        // Matrix with elements only on diagonal, off-diagonal zero\n        a = getRandom();\n        b = 0;\n        c = 0;\n        d = getRandom();\n    } else if (type == \"upper_triangular\") {\n        // Lower-left element zero\n        a = getRandom();\n        b = getRandom();\n        c = 0;\n        d = getRandom();\n    } else if (type == \"lower_triangular\") {\n        // Upper-right element zero\n        a = getRandom();\n        b = 0;\n        c = getRandom();\n        d = getRandom();\n    } else if (type == \"large_determinant\") {\n        // Generate a matrix where the determinant is large\n        // So that the minimal change is big\n        while (true) {\n            a = getRandom();\n            b = getRandom();\n            c = getRandom();\n            d = getRandom();\n            long long det = a * d - b * c;\n            if (abs(det) >= max_abs * max_abs / 2) {\n                break;\n            }\n        }\n    } else {\n        // Default to random\n        a = getRandom();\n        b = getRandom();\n        c = getRandom();\n        d = getRandom();\n    }\n\n    // Output the generated elements\n    printf(\"%lld %lld\\n\", a, b);\n    printf(\"%lld %lld\\n\", c, d);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    string type = opt<string>(\"type\", \"random\");\n    long long max_abs = opt<long long>(\"max_abs\", 1000000000LL);\n\n    long long a, b, c, d;\n\n    auto getRandom = [&]() {\n        return rnd.next(-max_abs, max_abs);\n    };\n\n    if (type == \"random\") {\n        // Generate all elements randomly in [-max_abs, max_abs]\n        a = getRandom();\n        b = getRandom();\n        c = getRandom();\n        d = getRandom();\n    } else if (type == \"zero_determinant\") {\n        // Generate elements such that determinant is zero\n        // That is, ad - bc = 0\n        // We can set a, b, c randomly and compute d = (bc)/a if a != 0\n        // Be careful with division by zero\n        while (true) {\n            a = getRandom();\n            b = getRandom();\n            c = getRandom();\n            if (a != 0) {\n                d = (b * c) / a;\n                if (abs(d) <= max_abs && a * d - b * c == 0) break;\n            } else {\n                // If a == 0, set d randomly and set b == 0 or c == 0 to make determinant zero\n                d = getRandom();\n                if (b == 0 || c == 0) {\n                    // ad - bc = 0\n                    break;\n                }\n                if (b * c == 0) {\n                    // ad - bc = 0\n                    break;\n                }\n            }\n        }\n    } else if (type == \"near_zero_determinant\") {\n        // Generate elements such that determinant is close to zero\n        // ad - bc = delta (small integer)\n        long long delta = rnd.next(-10LL, 10LL); // Small determinant\n        if (delta == 0) delta = rnd.next(1, 10); // Ensure delta != 0\n        while (true) {\n            a = getRandom();\n            b = getRandom();\n            c = getRandom();\n            if (a != 0) {\n                d = (b * c + delta) / a;\n                if (abs(d) <= max_abs && a * d - b * c == delta) break;\n            } else {\n                // a == 0, so ad - bc = -bc = delta => b or c can be adjusted\n                if (b != 0) {\n                    c = -delta / b;\n                    d = getRandom();\n                    if (abs(c) <= max_abs && a * d - b * c == delta) break;\n                } else {\n                    b = getRandom();\n                }\n            }\n        }\n    } else if (type == \"max_elements\") {\n        // Elements are at maximum absolute value\n        a = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n        b = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n        c = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n        d = max_abs * ((rnd.next(0, 1) == 0) ? -1 : 1);\n    } else if (type == \"identity\") {\n        // Identity matrix [[1,0],[0,1]]\n        a = 1;\n        b = 0;\n        c = 0;\n        d = 1;\n    } else if (type == \"scalar\") {\n        // Matrix where all elements are same\n        a = b = c = d = getRandom();\n    } else if (type == \"diagonal\") {\n        // Matrix with elements only on diagonal, off-diagonal zero\n        a = getRandom();\n        b = 0;\n        c = 0;\n        d = getRandom();\n    } else if (type == \"upper_triangular\") {\n        // Lower-left element zero\n        a = getRandom();\n        b = getRandom();\n        c = 0;\n        d = getRandom();\n    } else if (type == \"lower_triangular\") {\n        // Upper-right element zero\n        a = getRandom();\n        b = 0;\n        c = getRandom();\n        d = getRandom();\n    } else if (type == \"large_determinant\") {\n        // Generate a matrix where the determinant is large\n        // So that the minimal change is big\n        while (true) {\n            a = getRandom();\n            b = getRandom();\n            c = getRandom();\n            d = getRandom();\n            long long det = a * d - b * c;\n            if (abs(det) >= max_abs * max_abs / 2) {\n                break;\n            }\n        }\n    } else {\n        // Default to random\n        a = getRandom();\n        b = getRandom();\n        c = getRandom();\n        d = getRandom();\n    }\n\n    // Output the generated elements\n    printf(\"%lld %lld\\n\", a, b);\n    printf(\"%lld %lld\\n\", c, d);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type zero_determinant\n./gen -type zero_determinant\n./gen -type zero_determinant\n\n./gen -type near_zero_determinant\n./gen -type near_zero_determinant\n./gen -type near_zero_determinant\n\n./gen -type max_elements\n./gen -type max_elements\n./gen -type max_elements\n\n./gen -type identity\n\n./gen -type scalar\n./gen -type scalar\n\n./gen -type diagonal\n./gen -type diagonal\n\n./gen -type upper_triangular\n./gen -type lower_triangular\n\n./gen -type large_determinant\n./gen -type large_determinant\n./gen -type large_determinant\n\n./gen -type random -max_abs 10\n./gen -type zero_determinant -max_abs 10\n./gen -type near_zero_determinant -max_abs 10\n\n./gen -type random -max_abs 1\n./gen -type zero_determinant -max_abs 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:21.477948",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "55/A",
      "title": "A. Flea travel",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line contains single integer: 1 ≤ n ≤ 1000 — number of hassocks.",
      "output_spec": "OutputOutput \"YES\" if all the hassocks will be visited and \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopy1OutputCopyYESInputCopy3OutputCopyNO",
      "description": "A. Flea travel\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe only line contains single integer: 1 ≤ n ≤ 1000 — number of hassocks.\n\nOutputOutput \"YES\" if all the hassocks will be visited and \"NO\" otherwise.\n\nInputCopy1OutputCopyYESInputCopy3OutputCopyNO\n\nOutputCopyYES\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Beta Round #51 - Codeforces",
          "content": "Good morning (day, evening, night)!Today's round problems authors are we — Rei and yaro. We've been thoroughly selecting the problemset, so hope you'll enjoy the final edition.Thanks to problem coordinator Artem Rakhov for invaluable help in round preparation, and to those, who makes codeforces more comfortable, functional and stable.Wish you good luck!UPD. Analysis: A B C D E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 379
        },
        {
          "title": "Round 51, D - Codeforces",
          "content": "In this problem one should answer the query: how many beautiful numbers are there in the interval from 1 to R.Clearly, to check whether a number is divisible by all its digits, it is sufficient to know the remainder of a division by the lcm of all possible digits (call this lcm M), that is M = 8 * 9 * 5 * 7 = 2520. The standart dynamic solution is supposed to maintain such state parameters: the length of the number, \"strictly less\" flag, current remainder of a division by M and the mask of already taken digits.The first note: we can maitnain the lcm of the digits already taken, not the mask. This will decrease the number of different values of the last parameter (from 256 to 4 * 3 * 2 * 2 = 48, where 4 is the number of different powers of 2 etc).Then, it is a good idea to pre-count transitions to the new parameters. But we wanted and tried to set such a time limit restriction, so that this solution would not be enough to avoid TL.The idea that will decrease the running time even more lies in number theory. If we add digits from the end of a number we may see that the remainder of a number after division by 5 depends only on the last digit. Therefore, we may maintain the flag \"last digit = 5 or 0\" and ban transitions to the digit 5 if the flag is set to \"false\". Such an idea reduces the number of states by 5 * 2 / 2 = 5. This solution is fast enough to pass in any language, though there are even more powerful optimizations (the trick mentioned above can be done with digit 2 also).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1504
        },
        {
          "title": "Round 51, E - Codeforces",
          "content": "Let us solve this problem for every point P independently. We will show how to do this in linear time, that is, O(N). It seems that the most easy way to do this is to count the number of triangles not containing P (call them good), and then subtract this value from the total number of triangles.Consider triples of vertices A, B, C that form a triangle, such that: P doesn't lie in ABC; AB separates P and C in the polygon; P lies in the polygon to the right from AB (clockwise). Note, that every good triangle provides us one such triple and each triple forms a good triangle. Thus, we may consider such triples instead of good triangles.Let's consider an arbitrary vertex of the polygon. We want it to become an A-vertex in some triple. Then we can obtain the set of vertices, suitable for B-vertex in a triple moving diagonals from A (clockwise) until we reach P. Then for the fixed A the number of triples is equal to the sum of the number of triples for this A and the fixed B, which is equal to the sum of some linear series (as all suitable C lie between A and B and their number is equal to the vertex-distance between A and B minus one).The only thing left to do is to find the last B (last until P is reached) for each vertex of the polygon. And this is a simple exercise on the two pointers technique.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1313
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"small\") {\n        if (n == -1) {\n            n = rnd.next(1, 10);\n        } else {\n            n = min(n, 10);\n        }\n    } else if (type == \"powerof2\") {\n        if (n == -1) n = 1024;\n        int exponent = int(log2(n));\n        n = 1 << exponent;\n    } else if (type == \"nearpowerof2\") {\n        if (n == -1) n = 1000;\n        int exponent = int(log2(n));\n        int base = 1 << exponent;\n        n = base + rnd.next(-5, 5);\n        n = max(1, min(n, 1000));\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"random\") {\n        if (n == -1)\n            n = rnd.next(1, 1000);\n        else\n            n = rnd.next(1, n);\n    } else if (type == \"custom\") {\n        if (n == -1) {\n            n = rnd.next(1, 1000);\n        }\n        // n remains as given\n    } else {\n        // Default to random\n        if (n == -1)\n            n = rnd.next(1, 1000);\n        else\n            n = rnd.next(1, n);\n    }\n    // Ensure n is within [1,1000]\n    n = max(1, min(n, 1000));\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"small\") {\n        if (n == -1) {\n            n = rnd.next(1, 10);\n        } else {\n            n = min(n, 10);\n        }\n    } else if (type == \"powerof2\") {\n        if (n == -1) n = 1024;\n        int exponent = int(log2(n));\n        n = 1 << exponent;\n    } else if (type == \"nearpowerof2\") {\n        if (n == -1) n = 1000;\n        int exponent = int(log2(n));\n        int base = 1 << exponent;\n        n = base + rnd.next(-5, 5);\n        n = max(1, min(n, 1000));\n    } else if (type == \"max\") {\n        n = 1000;\n    } else if (type == \"random\") {\n        if (n == -1)\n            n = rnd.next(1, 1000);\n        else\n            n = rnd.next(1, n);\n    } else if (type == \"custom\") {\n        if (n == -1) {\n            n = rnd.next(1, 1000);\n        }\n        // n remains as given\n    } else {\n        // Default to random\n        if (n == -1)\n            n = rnd.next(1, 1000);\n        else\n            n = rnd.next(1, n);\n    }\n    // Ensure n is within [1,1000]\n    n = max(1, min(n, 1000));\n\n    printf(\"%d\\n\", n);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -type custom -n 1\n./gen -type custom -n 2\n./gen -type custom -n 3\n./gen -type custom -n 4\n./gen -type custom -n 5\n./gen -type custom -n 7\n./gen -type custom -n 10\n\n# Power of 2 n values\n./gen -type powerof2 -n 2\n./gen -type powerof2 -n 4\n./gen -type powerof2 -n 8\n./gen -type powerof2 -n 16\n./gen -type powerof2 -n 32\n./gen -type powerof2 -n 64\n./gen -type powerof2 -n 128\n./gen -type powerof2 -n 256\n./gen -type powerof2 -n 512\n./gen -type powerof2 -n 1000\n\n# Near power of 2 n values\n./gen -type nearpowerof2 -n 15\n./gen -type nearpowerof2 -n 31\n./gen -type nearpowerof2 -n 63\n./gen -type nearpowerof2 -n 127\n./gen -type nearpowerof2 -n 255\n./gen -type nearpowerof2 -n 511\n\n# Maximum n value\n./gen -type max\n\n# Random n values up to a certain limit\n./gen -type random -n 100\n./gen -type random -n 500\n./gen -type random -n 1000\n./gen -type random\n\n# Custom n values to test specific cases\n./gen -type custom -n 6\n./gen -type custom -n 9\n./gen -type custom -n 12\n./gen -type custom -n 14\n./gen -type custom -n 17\n./gen -type custom -n 20\n./gen -type custom -n 23\n./gen -type custom -n 30\n./gen -type custom -n 33\n./gen -type custom -n 40\n./gen -type custom -n 50\n./gen -type custom -n 60\n./gen -type custom -n 70\n./gen -type custom -n 80\n./gen -type custom -n 90\n./gen -type custom -n 100\n./gen -type custom -n 500\n./gen -type custom -n 999\n./gen -type custom -n 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:24.012219",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "55/B",
      "title": "B. Smallest number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line contains four integers separated by space: 0 ≤ a, b, c, d ≤ 1000 — the original numbers. Second line contains three signs ('+' or '*' each) separated by space — the sequence of the operations in the order of performing. ('+' stands for addition, '*' — multiplication)",
      "output_spec": "OutputOutput one integer number — the minimal result which can be obtained.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy1 1 1 1+ + *OutputCopy3InputCopy2 2 2 2* * +OutputCopy8InputCopy1 2 3 4* + +OutputCopy9",
      "description": "B. Smallest number\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line contains four integers separated by space: 0 ≤ a, b, c, d ≤ 1000 — the original numbers. Second line contains three signs ('+' or '*' each) separated by space — the sequence of the operations in the order of performing. ('+' stands for addition, '*' — multiplication)\n\nOutputOutput one integer number — the minimal result which can be obtained.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n\nInputCopy1 1 1 1+ + *OutputCopy3InputCopy2 2 2 2* * +OutputCopy8InputCopy1 2 3 4* + +OutputCopy9\n\nInputCopy1 1 1 1+ + *\n\nOutputCopy3\n\nInputCopy2 2 2 2* * +\n\nOutputCopy8\n\nInputCopy1 2 3 4* + +\n\nOutputCopy9",
      "solutions": [
        {
          "title": "Codeforces Beta Round #51 - Codeforces",
          "content": "Good morning (day, evening, night)!Today's round problems authors are we — Rei and yaro. We've been thoroughly selecting the problemset, so hope you'll enjoy the final edition.Thanks to problem coordinator Artem Rakhov for invaluable help in round preparation, and to those, who makes codeforces more comfortable, functional and stable.Wish you good luck!UPD. Analysis: A B C D E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 379
        },
        {
          "title": "Round 51, D - Codeforces",
          "content": "In this problem one should answer the query: how many beautiful numbers are there in the interval from 1 to R.Clearly, to check whether a number is divisible by all its digits, it is sufficient to know the remainder of a division by the lcm of all possible digits (call this lcm M), that is M = 8 * 9 * 5 * 7 = 2520. The standart dynamic solution is supposed to maintain such state parameters: the length of the number, \"strictly less\" flag, current remainder of a division by M and the mask of already taken digits.The first note: we can maitnain the lcm of the digits already taken, not the mask. This will decrease the number of different values of the last parameter (from 256 to 4 * 3 * 2 * 2 = 48, where 4 is the number of different powers of 2 etc).Then, it is a good idea to pre-count transitions to the new parameters. But we wanted and tried to set such a time limit restriction, so that this solution would not be enough to avoid TL.The idea that will decrease the running time even more lies in number theory. If we add digits from the end of a number we may see that the remainder of a number after division by 5 depends only on the last digit. Therefore, we may maintain the flag \"last digit = 5 or 0\" and ban transitions to the digit 5 if the flag is set to \"false\". Such an idea reduces the number of states by 5 * 2 / 2 = 5. This solution is fast enough to pass in any language, though there are even more powerful optimizations (the trick mentioned above can be done with digit 2 also).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1504
        },
        {
          "title": "Round 51, E - Codeforces",
          "content": "Let us solve this problem for every point P independently. We will show how to do this in linear time, that is, O(N). It seems that the most easy way to do this is to count the number of triangles not containing P (call them good), and then subtract this value from the total number of triangles.Consider triples of vertices A, B, C that form a triangle, such that: P doesn't lie in ABC; AB separates P and C in the polygon; P lies in the polygon to the right from AB (clockwise). Note, that every good triangle provides us one such triple and each triple forms a good triangle. Thus, we may consider such triples instead of good triangles.Let's consider an arbitrary vertex of the polygon. We want it to become an A-vertex in some triple. Then we can obtain the set of vertices, suitable for B-vertex in a triple moving diagonals from A (clockwise) until we reach P. Then for the fixed A the number of triples is equal to the sum of the number of triples for this A and the fixed B, which is equal to the sum of some linear series (as all suitable C lie between A and B and their number is equal to the vertex-distance between A and B minus one).The only thing left to do is to find the last B (last until P is reached) for each vertex of the polygon. And this is a simple exercise on the two pointers technique.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1313
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a1 = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int a3 = inf.readInt(0, 1000, \"c\");\n    inf.readSpace();\n    int a4 = inf.readInt(0, 1000, \"d\");\n    inf.readEoln();\n\n    string s1 = inf.readToken(\"[+*]\", \"op1\");\n    inf.readSpace();\n    string s2 = inf.readToken(\"[+*]\", \"op2\");\n    inf.readSpace();\n    string s3 = inf.readToken(\"[+*]\", \"op3\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a1 = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int a3 = inf.readInt(0, 1000, \"c\");\n    inf.readSpace();\n    int a4 = inf.readInt(0, 1000, \"d\");\n    inf.readEoln();\n\n    string s1 = inf.readToken(\"[+*]\", \"op1\");\n    inf.readSpace();\n    string s2 = inf.readToken(\"[+*]\", \"op2\");\n    inf.readSpace();\n    string s3 = inf.readToken(\"[+*]\", \"op3\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a1 = inf.readInt(0, 1000, \"a\");\n    inf.readSpace();\n    int a2 = inf.readInt(0, 1000, \"b\");\n    inf.readSpace();\n    int a3 = inf.readInt(0, 1000, \"c\");\n    inf.readSpace();\n    int a4 = inf.readInt(0, 1000, \"d\");\n    inf.readEoln();\n\n    string s1 = inf.readToken(\"[+*]\", \"op1\");\n    inf.readSpace();\n    string s2 = inf.readToken(\"[+*]\", \"op2\");\n    inf.readSpace();\n    string s3 = inf.readToken(\"[+*]\", \"op3\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string mode = opt<string>(\"mode\", \"random\");\n    string ops = opt<string>(\"ops\", \"+++\");\n\n    int a, b, c, d;\n    if (mode == \"zeros\") {\n        a = b = c = d = 0;\n    } else if (mode == \"ones\") {\n        a = b = c = d = 1;\n    } else if (mode == \"maxes\") {\n        a = b = c = d = 1000;\n    } else if (mode == \"mix\") {\n        a = 0;\n        b = 1;\n        c = 1000;\n        d = rnd.next(0, 1000);\n    } else if (mode == \"given\") {\n        a = opt<int>(\"a\", 0);\n        b = opt<int>(\"b\", 0);\n        c = opt<int>(\"c\", 0);\n        d = opt<int>(\"d\", 0);\n    } else if (mode == \"random\") {\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n        d = rnd.next(0, 1000);\n    }\n\n    printf(\"%d %d %d %d\\n\", a, b, c, d);\n\n    if (ops.length() != 3) {\n        // generate random operations\n        ops = \"\";\n        for (int i = 0; i < 3; ++i) {\n            if (rnd.next(0,1) == 0) {\n                ops += '+';\n            } else {\n                ops += '*';\n            }\n        }\n    }\n\n    printf(\"%c %c %c\\n\", ops[0], ops[1], ops[2]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string mode = opt<string>(\"mode\", \"random\");\n    string ops = opt<string>(\"ops\", \"+++\");\n\n    int a, b, c, d;\n    if (mode == \"zeros\") {\n        a = b = c = d = 0;\n    } else if (mode == \"ones\") {\n        a = b = c = d = 1;\n    } else if (mode == \"maxes\") {\n        a = b = c = d = 1000;\n    } else if (mode == \"mix\") {\n        a = 0;\n        b = 1;\n        c = 1000;\n        d = rnd.next(0, 1000);\n    } else if (mode == \"given\") {\n        a = opt<int>(\"a\", 0);\n        b = opt<int>(\"b\", 0);\n        c = opt<int>(\"c\", 0);\n        d = opt<int>(\"d\", 0);\n    } else if (mode == \"random\") {\n        a = rnd.next(0, 1000);\n        b = rnd.next(0, 1000);\n        c = rnd.next(0, 1000);\n        d = rnd.next(0, 1000);\n    }\n\n    printf(\"%d %d %d %d\\n\", a, b, c, d);\n\n    if (ops.length() != 3) {\n        // generate random operations\n        ops = \"\";\n        for (int i = 0; i < 3; ++i) {\n            if (rnd.next(0,1) == 0) {\n                ops += '+';\n            } else {\n                ops += '*';\n            }\n        }\n    }\n\n    printf(\"%c %c %c\\n\", ops[0], ops[1], ops[2]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# All zeros, all plus\n./gen -mode zeros -ops +++\n\n# All zeros, all multiply\n./gen -mode zeros -ops ***\n\n# All ones, all plus\n./gen -mode ones -ops +++\n\n# All ones, all multiply\n./gen -mode ones -ops ***\n\n# All maxes, all plus\n./gen -mode maxes -ops +++\n\n# All maxes, all multiply\n./gen -mode maxes -ops ***\n\n# Mix mode, operations '*++'\n./gen -mode mix -ops '*++'\n\n# Mix mode, operations '+*+'\n./gen -mode mix -ops '+*+'\n\n# Specific numbers, zeros and ones\n./gen -mode given -a 0 -b 1 -c 0 -d 1 -ops '***'\n\n# Specific numbers, zeros and maxes\n./gen -mode given -a 0 -b 1000 -c 0 -d 1000 -ops '***'\n\n# Specific numbers, ones and maxes\n./gen -mode given -a 1 -b 1000 -c 1 -d 1000 -ops '+++'\n\n# Specific numbers, zeros and random number\n./gen -mode given -a 0 -b 500 -c 0 -d 250 -ops '+*+'\n\n# Random numbers, all plus\n./gen -mode random -ops +++\n\n# Random numbers, all multiply\n./gen -mode random -ops ***\n\n# Random numbers, mixed operations '*+*'\n./gen -mode random -ops '*+*'\n\n# Random numbers, random operations\n./gen -mode random\n\n# Random numbers, random operations\n./gen -mode random\n\n# Random numbers, random operations\n./gen -mode random\n\n# Specific numbers, testing with zeros and big numbers\n./gen -mode given -a 0 -b 1000 -c 500 -d 999 -ops '*++'\n\n# Specific numbers, small numbers\n./gen -mode given -a 2 -b 3 -c 4 -d 5 -ops '+*+'\n\n# Maximum numbers mixed with zeros\n./gen -mode given -a 1000 -b 0 -c 1000 -d 0 -ops '*+*'\n\n# All numbers are mid-range\n./gen -mode given -a 500 -b 500 -c 500 -d 500 -ops '++*'\n\n# Random numbers, operations '+**'\n./gen -mode random -ops '+**'\n\n# Random numbers, operations '*++'\n./gen -mode random -ops '*++'\n\n# Random numbers, operations '**+'\n./gen -mode random -ops '**+'\n\n# Random numbers, operations '++*'\n./gen -mode random -ops '++*'\n\n# Specific numbers, one zero, others are max\n./gen -mode given -a 0 -b 1000 -c 1000 -d 1000 -ops '***'\n\n# Specific numbers, one zero, others are small\n./gen -mode given -a 0 -b 1 -c 2 -d 3 -ops '***'\n\n# Specific numbers, all same number\n./gen -mode given -a 42 -b 42 -c 42 -d 42 -ops '*+*'\n\n# Random numbers, random operations\n./gen -mode random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:26.237345",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "55/C",
      "title": "C. Кекс или смерть",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записаны три целых числа, разделенные пробелом: 1 ≤ n, m ≤ 100 — размеры доски и 0 ≤ k ≤ 100 — количество кексов. Каждая из следующих k строк описывает расположение кексов в виде двух целых чисел, разделенных пробелом: 1 ≤ x ≤ n и 1 ≤ y ≤ m — координаты кекса на доске. В одной клетке может находиться несколько кексов.",
      "output_spec": "Выходные данныеВыведите единственное слово: \"YES\" — если Володя выигрывает, \"NO\" — в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 11 2Выходные данныеСкопироватьYESВходные данныеСкопировать3 4 0Выходные данныеСкопироватьNOВходные данныеСкопировать100 50 250 2550 25Выходные данныеСкопироватьNO",
      "description": "C. Кекс или смерть\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны три целых числа, разделенные пробелом: 1 ≤ n, m ≤ 100 — размеры доски и 0 ≤ k ≤ 100 — количество кексов. Каждая из следующих k строк описывает расположение кексов в виде двух целых чисел, разделенных пробелом: 1 ≤ x ≤ n и 1 ≤ y ≤ m — координаты кекса на доске. В одной клетке может находиться несколько кексов.\n\nВходные данные\n\nВыходные данныеВыведите единственное слово: \"YES\" — если Володя выигрывает, \"NO\" — в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать2 2 11 2Выходные данныеСкопироватьYESВходные данныеСкопировать3 4 0Выходные данныеСкопироватьNOВходные данныеСкопировать100 50 250 2550 25Выходные данныеСкопироватьNO\n\nВходные данныеСкопировать2 2 11 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать100 50 250 2550 25\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #51 - Codeforces",
          "content": "Доброе утро (день, вечер, ночь)!Авторы сегодняшнего раунда — Rei и yaro. Мы долго выбирали задачи для раунда и надеемся, что итоговый вариант вам понравится.Наши благодарности координатору задач Артему Рахову за неизменную отзывчивость при совместной подготовке раунда, а также тем (тому), кто делает систему Codeforces все более удобной, функциональной и стабильной.Удачи!UPD. Разборы: А B C D E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 396
        },
        {
          "title": "Round 51, D - Codeforces",
          "content": "В этой задаче нужно было научиться отвечать на запрос количества красивых чисел от 1 до R.Ясно, что чтобы проверить, делится ли число на все свои цифры, достаточно знать остаток числа при делении на наименьшее общее кратное (НОК) всевозможных цифр (обозначим M), то есть M = 8 * 9 * 5 * 7 = 2520. Стандартная динамика подразумевает следующие параметры состояния: длина уже построенного числа, флаг \"строго меньше\", текущий остаток по модулю M и маску набора цифр, которые уже встретились.Первое замечание: можно хранить не маску набора цифр, а, опять же, НОК тех цифр, которые уже вошли в число. Это уменьшит количество возможных значений последнего параметра c 256 до 4 * 3 * 2 * 2 = 48 (4 - кол-во возможных степеней двойки и так далее).Далее, переходы к новым параметрам при добавлении цифры стоит делать с предподсчетом (от остатка к новому остатку и от НОКа цифр к новому НОКу). Мы хотели и постарались поставить такие ограничения в задаче, чтобы и это решение не проходило (а это было непросто, так как разница между Java и C++ по времени выполнения была разительна; в итоге, к сожалению, часть решений обошла TL без нижеизложенной оптимизации).Идея, которую хотелось увидеть в динамическом решении — числовая. Если добавлять цифры с конца, то можно заметить, что на остаток числа при делении на 5 влияет лишь последняя цифра. Таким образом, можно хранить флаг \"последняя цифра = 5 или 0\" и запрещать переходы по цифре 5, если флаг не выставлен. Эта идея уменьшает количество состояний в 5 * 2 / 2 = 5 раз. Такое решение без проблем проходило на любом языке, но есть и более сильные оптимизации, тоже основанные на идее делимости (например, можно провернуть этот же трюк с двойкой).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1688
        },
        {
          "title": "Round 51, E - Codeforces",
          "content": "Будем решать задачу для каждой точки P отдельно и решим ее за О(N). Видимо, самый простой способ - посчитать количество треугольников, не содержащих P, а затем вычесть это количество из общего количества треугольников.Рассмотрим тройки вершин A, B, C, образующих треугольник, таких что P не лежит в ABC, кроме того, AB разделяет P и C и P лежит в многоугольнике справа от АB по часовой стрелке. Заметим, что для каждого треугольника его вершины в некотором порядке образуют такую тройку и каждая тройка дает нам треугольник. То есть можно вместо треугольников без P считать такие тройки.Рассмотрим произвольную вершину многоугольника, мы хотим, чтобы она стала вершиной А в тройке. Тогда множество вершин, подходящих на место B в тройке мы получим идя диагоналями от A по часовой стрелке, пока не дойдем до P. Причем для каждой подходящей вершины B количество треугольников - это расстояние между A и B (в вершинах) по часовой стрелке минус один. То есть для фиксированной А мы получаем сумму арифметической прогрессии по подходящим B.Единственное, что осталось понять - как найти последнюю B для А. Ну а эта задача просто решается двумя указателями сразу для всевозможных А.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1175
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < k; i++) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, k for type \"max\" or \"zero\"\n    if (type == \"max\") {\n        n = 100;\n        m = 100;\n        k = 100;\n    } else if (type == \"zero\") {\n        k = 0;\n    }\n\n    vector<pair<int, int>> pies;\n\n    if (k > 0) {\n        if (type == \"random\" || type == \"max\" || type == \"zero\") {\n            // Generate random pie positions\n            for (int i = 0; i < k; ++i) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                pies.emplace_back(x, y);\n            }\n        } else if (type == \"border\") {\n            // Place pies on the border\n            for (int i = 0; i < k; ++i) {\n                int side = rnd.next(1, 4);\n                int x, y;\n                if (side == 1) { // top row\n                    x = 1;\n                    y = rnd.next(1, m);\n                } else if (side == 2) { // bottom row\n                    x = n;\n                    y = rnd.next(1, m);\n                } else if (side == 3) { // left column\n                    x = rnd.next(1, n);\n                    y = 1;\n                } else { // right column\n                    x = rnd.next(1, n);\n                    y = m;\n                }\n                pies.emplace_back(x, y);\n            }\n        } else if (type == \"center\") {\n            // Place pies not on the border\n            int startX = (n <= 2) ? 1 : 2;\n            int endX = (n <= 2) ? n : n - 1;\n            int startY = (m <= 2) ? 1 : 2;\n            int endY = (m <= 2) ? m : m - 1;\n            for (int i = 0; i < k; ++i) {\n                int x = rnd.next(startX, endX);\n                int y = rnd.next(startY, endY);\n                pies.emplace_back(x, y);\n            }\n        } else if (type == \"onecell\") {\n            // Place all pies at the same cell\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            for (int i = 0; i < k; ++i) {\n                pies.emplace_back(x, y);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", pies[i].first, pies[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Adjust n, m, k for type \"max\" or \"zero\"\n    if (type == \"max\") {\n        n = 100;\n        m = 100;\n        k = 100;\n    } else if (type == \"zero\") {\n        k = 0;\n    }\n\n    vector<pair<int, int>> pies;\n\n    if (k > 0) {\n        if (type == \"random\" || type == \"max\" || type == \"zero\") {\n            // Generate random pie positions\n            for (int i = 0; i < k; ++i) {\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                pies.emplace_back(x, y);\n            }\n        } else if (type == \"border\") {\n            // Place pies on the border\n            for (int i = 0; i < k; ++i) {\n                int side = rnd.next(1, 4);\n                int x, y;\n                if (side == 1) { // top row\n                    x = 1;\n                    y = rnd.next(1, m);\n                } else if (side == 2) { // bottom row\n                    x = n;\n                    y = rnd.next(1, m);\n                } else if (side == 3) { // left column\n                    x = rnd.next(1, n);\n                    y = 1;\n                } else { // right column\n                    x = rnd.next(1, n);\n                    y = m;\n                }\n                pies.emplace_back(x, y);\n            }\n        } else if (type == \"center\") {\n            // Place pies not on the border\n            int startX = (n <= 2) ? 1 : 2;\n            int endX = (n <= 2) ? n : n - 1;\n            int startY = (m <= 2) ? 1 : 2;\n            int endY = (m <= 2) ? m : m - 1;\n            for (int i = 0; i < k; ++i) {\n                int x = rnd.next(startX, endX);\n                int y = rnd.next(startY, endY);\n                pies.emplace_back(x, y);\n            }\n        } else if (type == \"onecell\") {\n            // Place all pies at the same cell\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            for (int i = 0; i < k; ++i) {\n                pies.emplace_back(x, y);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", pies[i].first, pies[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 0 -type zero\n./gen -n 1 -m 1 -k 1 -type random\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 2 -m 2 -k 4 -type random\n./gen -n 2 -m 2 -k 4 -type onecell\n./gen -n 2 -m 2 -k 4 -type border\n./gen -n 2 -m 2 -k 4 -type center\n\n./gen -n 10 -m 10 -k 0 -type zero\n./gen -n 10 -m 10 -k 5 -type random\n./gen -n 10 -m 10 -k 5 -type border\n./gen -n 10 -m 10 -k 5 -type center\n./gen -n 10 -m 10 -k 5 -type onecell\n\n./gen -n 50 -m 50 -k 25 -type random\n./gen -n 50 -m 50 -k 25 -type border\n./gen -n 50 -m 50 -k 25 -type center\n./gen -n 50 -m 50 -k 25 -type onecell\n\n./gen -n 100 -m 100 -k 0 -type zero\n./gen -n 100 -m 100 -k 100 -type max\n./gen -n 100 -m 100 -k 100 -type random\n./gen -n 100 -m 100 -k 100 -type border\n./gen -n 100 -m 100 -k 100 -type center\n./gen -n 100 -m 100 -k 100 -type onecell\n\n./gen -n 1 -m 100 -k 50 -type random\n./gen -n 1 -m 100 -k 100 -type onecell\n./gen -n 100 -m 1 -k 50 -type random\n./gen -n 100 -m 1 -k 100 -type onecell\n\n./gen -n 3 -m 3 -k 10 -type onecell\n./gen -n 3 -m 3 -k 5 -type center\n./gen -n 3 -m 3 -k 5 -type border\n\n./gen -n 5 -m 5 -k 10 -type random\n./gen -n 5 -m 5 -k 10 -type center\n./gen -n 5 -m 5 -k 10 -type border\n\n./gen -n 99 -m 99 -k 99 -type random\n./gen -n 99 -m 99 -k 99 -type onecell\n\n./gen -n 50 -m 50 -k 0 -type zero\n./gen -n 50 -m 50 -k 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:27.956870",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "55/D",
      "title": "D. Beautiful numbers",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains the number of cases t (1 ≤ t ≤ 10). Each of the next t lines contains two natural numbers li and ri (1 ≤ li ≤ ri ≤ 9 ·1018).Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).",
      "output_spec": "OutputOutput should contain t numbers — answers to the queries, one number per line — quantities of beautiful numbers in given intervals (from li to ri, inclusively).",
      "sample_tests": "ExamplesInputCopy11 9OutputCopy9InputCopy112 15OutputCopy2",
      "description": "D. Beautiful numbers\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains the number of cases t (1 ≤ t ≤ 10). Each of the next t lines contains two natural numbers li and ri (1 ≤ li ≤ ri ≤ 9 ·1018).Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n\nOutputOutput should contain t numbers — answers to the queries, one number per line — quantities of beautiful numbers in given intervals (from li to ri, inclusively).\n\nInputCopy11 9OutputCopy9InputCopy112 15OutputCopy2\n\nInputCopy11 9\n\nOutputCopy9\n\nInputCopy112 15\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #51 - Codeforces",
          "content": "Good morning (day, evening, night)!Today's round problems authors are we — Rei and yaro. We've been thoroughly selecting the problemset, so hope you'll enjoy the final edition.Thanks to problem coordinator Artem Rakhov for invaluable help in round preparation, and to those, who makes codeforces more comfortable, functional and stable.Wish you good luck!UPD. Analysis: A B C D E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 379
        },
        {
          "title": "Round 51, D - Codeforces",
          "content": "In this problem one should answer the query: how many beautiful numbers are there in the interval from 1 to R.Clearly, to check whether a number is divisible by all its digits, it is sufficient to know the remainder of a division by the lcm of all possible digits (call this lcm M), that is M = 8 * 9 * 5 * 7 = 2520. The standart dynamic solution is supposed to maintain such state parameters: the length of the number, \"strictly less\" flag, current remainder of a division by M and the mask of already taken digits.The first note: we can maitnain the lcm of the digits already taken, not the mask. This will decrease the number of different values of the last parameter (from 256 to 4 * 3 * 2 * 2 = 48, where 4 is the number of different powers of 2 etc).Then, it is a good idea to pre-count transitions to the new parameters. But we wanted and tried to set such a time limit restriction, so that this solution would not be enough to avoid TL.The idea that will decrease the running time even more lies in number theory. If we add digits from the end of a number we may see that the remainder of a number after division by 5 depends only on the last digit. Therefore, we may maintain the flag \"last digit = 5 or 0\" and ban transitions to the digit 5 if the flag is set to \"false\". Such an idea reduces the number of states by 5 * 2 / 2 = 5. This solution is fast enough to pass in any language, though there are even more powerful optimizations (the trick mentioned above can be done with digit 2 also).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1504
        },
        {
          "title": "Round 51, E - Codeforces",
          "content": "Let us solve this problem for every point P independently. We will show how to do this in linear time, that is, O(N). It seems that the most easy way to do this is to count the number of triangles not containing P (call them good), and then subtract this value from the total number of triangles.Consider triples of vertices A, B, C that form a triangle, such that: P doesn't lie in ABC; AB separates P and C in the polygon; P lies in the polygon to the right from AB (clockwise). Note, that every good triangle provides us one such triple and each triple forms a good triangle. Thus, we may consider such triples instead of good triangles.Let's consider an arbitrary vertex of the polygon. We want it to become an A-vertex in some triple. Then we can obtain the set of vertices, suitable for B-vertex in a triple moving diagonals from A (clockwise) until we reach P. Then for the fixed A the number of triples is equal to the sum of the number of triples for this A and the fixed B, which is equal to the sum of some linear series (as all suitable C lie between A and B and their number is equal to the vertex-distance between A and B minus one).The only thing left to do is to find the last B (last until P is reached) for each vertex of the polygon. And this is a simple exercise on the two pointers technique.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1313
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        long long l = inf.readLong(1LL, 9000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long r = inf.readLong(l, 9000000000000000000LL, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        long long l = inf.readLong(1LL, 9000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long r = inf.readLong(l, 9000000000000000000LL, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int t = inf.readInt(1, 10, \"t\");\n    inf.readEoln();\n    for (int i = 0; i < t; ++i) {\n        long long l = inf.readLong(1LL, 9000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long r = inf.readLong(l, 9000000000000000000LL, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAX_N = 9000000000000000000LL; // 9e18\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t_input = opt<int>(\"t\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    int t;\n\n    if (type == \"minimal\" || type == \"single_number\") {\n        t = 1;\n    } else if (type == \"maximal\") {\n        t = 10;\n    } else {\n        t = t_input;\n    }\n\n    printf(\"%d\\n\", t);\n\n    long long prev_ri = 0; // For \"increasing\" type\n    for (int i = 0; i < t; ++i) {\n        long long li, ri;\n\n        if (type == \"minimal\") {\n            li = ri = 1;\n        }\n        else if (type == \"maximal\") {\n            li = 1;\n            ri = MAX_N;\n        }\n        else if (type == \"single_number\") {\n            li = ri = rnd.next(1LL, MAX_N);\n        }\n        else if (type == \"equal_li_ri\") {\n            li = ri = rnd.next(1LL, MAX_N);\n        }\n        else if (type == \"small_range\") {\n            li = rnd.next(1LL, 1000LL);\n            ri = rnd.next(1LL, 1000LL);\n            if (li > ri) swap(li, ri);\n        }\n        else if (type == \"large_range\") {\n            li = rnd.next(MAX_N - 1000LL, MAX_N);\n            ri = rnd.next(MAX_N - 1000LL, MAX_N);\n            if (li > ri) swap(li, ri);\n        }\n        else if (type == \"increasing\") {\n            li = prev_ri + 1;\n            ri = li + rnd.next(0LL, MAX_N / t);\n            if (ri > MAX_N) ri = MAX_N;\n            prev_ri = ri;\n        }\n        else if (type == \"no_beautiful\") {\n            // Choose a range where there are no beautiful numbers\n            // We'll pick a number containing a zero digit\n            li = rnd.next(10LL, MAX_N / 2);\n            while (true) {\n                long long temp = li;\n                bool has_zero_digit = false;\n                while (temp > 0) {\n                    if (temp % 10 == 0) {\n                        has_zero_digit = true;\n                        break;\n                    }\n                    temp /= 10;\n                }\n                if (has_zero_digit) break;\n                li++;\n                if (li > MAX_N) break;\n            }\n            ri = li + rnd.next(0LL, 10LL);\n            if (ri > MAX_N) ri = MAX_N;\n        }\n        else {\n            // Random case\n            li = rnd.next(1LL, MAX_N);\n            ri = rnd.next(1LL, MAX_N);\n            if (li > ri) swap(li, ri);\n        }\n\n        printf(\"%lld %lld\\n\", li, ri);\n\n        if ((type == \"minimal\" || type == \"single_number\") && i == 0) {\n            // Only need one test case for these types\n            break;\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long MAX_N = 9000000000000000000LL; // 9e18\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int t_input = opt<int>(\"t\", 10);\n    string type = opt<string>(\"type\", \"random\");\n    int t;\n\n    if (type == \"minimal\" || type == \"single_number\") {\n        t = 1;\n    } else if (type == \"maximal\") {\n        t = 10;\n    } else {\n        t = t_input;\n    }\n\n    printf(\"%d\\n\", t);\n\n    long long prev_ri = 0; // For \"increasing\" type\n    for (int i = 0; i < t; ++i) {\n        long long li, ri;\n\n        if (type == \"minimal\") {\n            li = ri = 1;\n        }\n        else if (type == \"maximal\") {\n            li = 1;\n            ri = MAX_N;\n        }\n        else if (type == \"single_number\") {\n            li = ri = rnd.next(1LL, MAX_N);\n        }\n        else if (type == \"equal_li_ri\") {\n            li = ri = rnd.next(1LL, MAX_N);\n        }\n        else if (type == \"small_range\") {\n            li = rnd.next(1LL, 1000LL);\n            ri = rnd.next(1LL, 1000LL);\n            if (li > ri) swap(li, ri);\n        }\n        else if (type == \"large_range\") {\n            li = rnd.next(MAX_N - 1000LL, MAX_N);\n            ri = rnd.next(MAX_N - 1000LL, MAX_N);\n            if (li > ri) swap(li, ri);\n        }\n        else if (type == \"increasing\") {\n            li = prev_ri + 1;\n            ri = li + rnd.next(0LL, MAX_N / t);\n            if (ri > MAX_N) ri = MAX_N;\n            prev_ri = ri;\n        }\n        else if (type == \"no_beautiful\") {\n            // Choose a range where there are no beautiful numbers\n            // We'll pick a number containing a zero digit\n            li = rnd.next(10LL, MAX_N / 2);\n            while (true) {\n                long long temp = li;\n                bool has_zero_digit = false;\n                while (temp > 0) {\n                    if (temp % 10 == 0) {\n                        has_zero_digit = true;\n                        break;\n                    }\n                    temp /= 10;\n                }\n                if (has_zero_digit) break;\n                li++;\n                if (li > MAX_N) break;\n            }\n            ri = li + rnd.next(0LL, 10LL);\n            if (ri > MAX_N) ri = MAX_N;\n        }\n        else {\n            // Random case\n            li = rnd.next(1LL, MAX_N);\n            ri = rnd.next(1LL, MAX_N);\n            if (li > ri) swap(li, ri);\n        }\n\n        printf(\"%lld %lld\\n\", li, ri);\n\n        if ((type == \"minimal\" || type == \"single_number\") && i == 0) {\n            // Only need one test case for these types\n            break;\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n./gen -type maximal\n./gen -type single_number\n./gen -type equal_li_ri -t 5\n./gen -type small_range -t 5\n./gen -type large_range -t 5\n./gen -type increasing -t 10\n./gen -type no_beautiful -t 5\n./gen -type random -t 10\n\n# Generating multiple random test cases\n./gen -type random -t 1\n./gen -type random -t 2\n./gen -type random -t 3\n./gen -type random -t 4\n./gen -type random -t 5\n./gen -type random -t 6\n./gen -type random -t 7\n./gen -type random -t 8\n./gen -type random -t 9\n./gen -type random -t 10\n\n# Generating test cases with \"small_range\" of varying t\n./gen -type small_range -t 1\n./gen -type small_range -t 2\n./gen -type small_range -t 3\n./gen - -type small_range -t 4\n./gen -type small_range -t 5\n\n# Generating test cases with \"large_range\"\n./gen -type large_range -t 1\n./gen -type large_range -t 2\n./gen -type large_range -t 3\n./gen -type large_range -t 4\n./gen -type large_range -t 5\n\n# Generating test cases with \"increasing\" li and ri\n./gen -type increasing -t 10\n\n# Generating test cases with \"equal_li_ri\"\n./gen -type equal_li_ri -t 10\n\n# Generating test cases with \"no_beautiful\" ranges\n./gen -type no_beautiful -t 5\n./gen -type no_beautiful -t 10\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:29.595101",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "55/E",
      "title": "E. Very simple problem",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n — the number of vertices of the polygon (3 ≤ n ≤ 100000). The polygon description is following: n lines containing coordinates of the vertices in clockwise order (integer x and y not greater than 109 by absolute value). It is guaranteed that the given polygon is nondegenerate and convex (no three points lie on the same line).The next line contains integer t (1 ≤ t ≤ 20) — the number of points which you should count the answer for. It is followed by t lines with coordinates of the points (integer x and y not greater than 109 by absolute value).",
      "output_spec": "OutputThe output should contain t integer numbers, each on a separate line, where i-th number is the answer for the i-th point.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy45 00 00 55 511 3OutputCopy2InputCopy30 00 55 021 110 10OutputCopy10InputCopy57 66 34 11 22 443 32 35 54 2OutputCopy5334",
      "description": "E. Very simple problem\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n — the number of vertices of the polygon (3 ≤ n ≤ 100000). The polygon description is following: n lines containing coordinates of the vertices in clockwise order (integer x and y not greater than 109 by absolute value). It is guaranteed that the given polygon is nondegenerate and convex (no three points lie on the same line).The next line contains integer t (1 ≤ t ≤ 20) — the number of points which you should count the answer for. It is followed by t lines with coordinates of the points (integer x and y not greater than 109 by absolute value).\n\nOutputThe output should contain t integer numbers, each on a separate line, where i-th number is the answer for the i-th point.Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cin (also you may use %I64d).\n\nInputCopy45 00 00 55 511 3OutputCopy2InputCopy30 00 55 021 110 10OutputCopy10InputCopy57 66 34 11 22 443 32 35 54 2OutputCopy5334\n\nInputCopy45 00 00 55 511 3\n\nOutputCopy2\n\nInputCopy30 00 55 021 110 10\n\nOutputCopy10\n\nInputCopy57 66 34 11 22 443 32 35 54 2\n\nOutputCopy5334",
      "solutions": [
        {
          "title": "Codeforces Beta Round #51 - Codeforces",
          "content": "Good morning (day, evening, night)!Today's round problems authors are we — Rei and yaro. We've been thoroughly selecting the problemset, so hope you'll enjoy the final edition.Thanks to problem coordinator Artem Rakhov for invaluable help in round preparation, and to those, who makes codeforces more comfortable, functional and stable.Wish you good luck!UPD. Analysis: A B C D E",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1107",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 379
        },
        {
          "title": "Round 51, D - Codeforces",
          "content": "In this problem one should answer the query: how many beautiful numbers are there in the interval from 1 to R.Clearly, to check whether a number is divisible by all its digits, it is sufficient to know the remainder of a division by the lcm of all possible digits (call this lcm M), that is M = 8 * 9 * 5 * 7 = 2520. The standart dynamic solution is supposed to maintain such state parameters: the length of the number, \"strictly less\" flag, current remainder of a division by M and the mask of already taken digits.The first note: we can maitnain the lcm of the digits already taken, not the mask. This will decrease the number of different values of the last parameter (from 256 to 4 * 3 * 2 * 2 = 48, where 4 is the number of different powers of 2 etc).Then, it is a good idea to pre-count transitions to the new parameters. But we wanted and tried to set such a time limit restriction, so that this solution would not be enough to avoid TL.The idea that will decrease the running time even more lies in number theory. If we add digits from the end of a number we may see that the remainder of a number after division by 5 depends only on the last digit. Therefore, we may maintain the flag \"last digit = 5 or 0\" and ban transitions to the digit 5 if the flag is set to \"false\". Such an idea reduces the number of states by 5 * 2 / 2 = 5. This solution is fast enough to pass in any language, though there are even more powerful optimizations (the trick mentioned above can be done with digit 2 also).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1109",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1504
        },
        {
          "title": "Round 51, E - Codeforces",
          "content": "Let us solve this problem for every point P independently. We will show how to do this in linear time, that is, O(N). It seems that the most easy way to do this is to count the number of triangles not containing P (call them good), and then subtract this value from the total number of triangles.Consider triples of vertices A, B, C that form a triangle, such that: P doesn't lie in ABC; AB separates P and C in the polygon; P lies in the polygon to the right from AB (clockwise). Note, that every good triangle provides us one such triple and each triple forms a good triangle. Thus, we may consider such triples instead of good triangles.Let's consider an arbitrary vertex of the polygon. We want it to become an A-vertex in some triple. Then we can obtain the set of vertices, suitable for B-vertex in a triple moving diagonals from A (clockwise) until we reach P. Then for the fixed A the number of triples is equal to the sum of the number of triples for this A and the fixed B, which is equal to the sum of some linear series (as all suitable C lie between A and B and their number is equal to the vertex-distance between A and B minus one).The only thing left to do is to find the last B (last until P is reached) for each vertex of the polygon. And this is a simple exercise on the two pointers technique.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1313
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    ll x, y;\n    Point(ll x=0, ll y=0): x(x), y(y){}\n    Point operator - (const Point& b) const {\n        return Point(x - b.x, y - b.y);\n    }\n};\n\nll cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    vector<Point> poly(n);\n    for(int i = 0; i < n; ++i) {\n        ll x = inf.readLong(-1000000000LL, 1000000000LL, format(\"x[%d]\", i+1));\n        inf.readSpace();\n        ll y = inf.readLong(-1000000000LL, 1000000000LL, format(\"y[%d]\", i+1));\n        inf.readEoln();\n        poly[i] = Point(x, y);\n    }\n\n    // Check that all cross products have the same sign\n    int sign = 0;\n    for(int i = 0; i < n; ++i) {\n        Point A = poly[i];\n        Point B = poly[(i+1)%n];\n        Point C = poly[(i+2)%n];\n        Point BA = B - A;\n        Point CB = C - B;\n        ll z = cross(BA, CB);\n        ensuref(z != 0, \"No three consecutive points may be colinear at positions %d, %d, %d\", i+1, ((i+1)%n)+1, ((i+2)%n)+1);\n        int curr_sign = (z > 0 ? 1 : -1);\n        if(sign == 0) sign = curr_sign;\n        else ensuref(sign == curr_sign, \"Polygon is not convex at positions %d, %d, %d\", i+1, ((i+1)%n)+1, ((i+2)%n)+1);\n    }\n\n    // Check that all points are unique\n    set<pair<ll, ll>> points_set;\n    for(int i = 0; i < n; ++i) {\n        auto p = make_pair(poly[i].x, poly[i].y);\n        ensuref(points_set.find(p) == points_set.end(), \"No two vertices can be at the same position (%lld, %lld)\", poly[i].x, poly[i].y);\n        points_set.insert(p);\n    }\n\n    int t = inf.readInt(1, 20, \"t\");\n    inf.readEoln();\n\n    for(int i = 0; i < t; ++i) {\n        ll x = inf.readLong(-1000000000LL, 1000000000LL, format(\"query_x[%d]\", i+1));\n        inf.readSpace();\n        ll y = inf.readLong(-1000000000LL, 1000000000LL, format(\"query_y[%d]\", i+1));\n        inf.readEoln();\n        Point p = Point(x, y);\n\n        // Check that point p does not lie on any side of the polygon\n        for(int j = 0; j < n; ++j) {\n            Point A = poly[j];\n            Point B = poly[(j+1)%n];\n            Point BA = B - A;\n            Point PA = p - A;\n            ll cross_prod = cross(BA, PA);\n            if(cross_prod != 0) continue; // Not colinear\n            // Colinear, check if p lies on segment AB\n            ll dot1 = (B.x - A.x) * (p.x - A.x) + (B.y - A.y) * (p.y - A.y);\n            ll dot2 = (A.x - B.x) * (p.x - B.x) + (A.y - B.y) * (p.y - B.y);\n            if(dot1 >= 0 && dot2 >= 0) {\n                ensuref(false, \"Query point %d lies on side %d\", i+1, j+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    ll x, y;\n    Point(ll x=0, ll y=0): x(x), y(y){}\n    Point operator - (const Point& b) const {\n        return Point(x - b.x, y - b.y);\n    }\n};\n\nll cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    vector<Point> poly(n);\n    for(int i = 0; i < n; ++i) {\n        ll x = inf.readLong(-1000000000LL, 1000000000LL, format(\"x[%d]\", i+1));\n        inf.readSpace();\n        ll y = inf.readLong(-1000000000LL, 1000000000LL, format(\"y[%d]\", i+1));\n        inf.readEoln();\n        poly[i] = Point(x, y);\n    }\n\n    // Check that all cross products have the same sign\n    int sign = 0;\n    for(int i = 0; i < n; ++i) {\n        Point A = poly[i];\n        Point B = poly[(i+1)%n];\n        Point C = poly[(i+2)%n];\n        Point BA = B - A;\n        Point CB = C - B;\n        ll z = cross(BA, CB);\n        ensuref(z != 0, \"No three consecutive points may be colinear at positions %d, %d, %d\", i+1, ((i+1)%n)+1, ((i+2)%n)+1);\n        int curr_sign = (z > 0 ? 1 : -1);\n        if(sign == 0) sign = curr_sign;\n        else ensuref(sign == curr_sign, \"Polygon is not convex at positions %d, %d, %d\", i+1, ((i+1)%n)+1, ((i+2)%n)+1);\n    }\n\n    // Check that all points are unique\n    set<pair<ll, ll>> points_set;\n    for(int i = 0; i < n; ++i) {\n        auto p = make_pair(poly[i].x, poly[i].y);\n        ensuref(points_set.find(p) == points_set.end(), \"No two vertices can be at the same position (%lld, %lld)\", poly[i].x, poly[i].y);\n        points_set.insert(p);\n    }\n\n    int t = inf.readInt(1, 20, \"t\");\n    inf.readEoln();\n\n    for(int i = 0; i < t; ++i) {\n        ll x = inf.readLong(-1000000000LL, 1000000000LL, format(\"query_x[%d]\", i+1));\n        inf.readSpace();\n        ll y = inf.readLong(-1000000000LL, 1000000000LL, format(\"query_y[%d]\", i+1));\n        inf.readEoln();\n        Point p = Point(x, y);\n\n        // Check that point p does not lie on any side of the polygon\n        for(int j = 0; j < n; ++j) {\n            Point A = poly[j];\n            Point B = poly[(j+1)%n];\n            Point BA = B - A;\n            Point PA = p - A;\n            ll cross_prod = cross(BA, PA);\n            if(cross_prod != 0) continue; // Not colinear\n            // Colinear, check if p lies on segment AB\n            ll dot1 = (B.x - A.x) * (p.x - A.x) + (B.y - A.y) * (p.y - A.y);\n            ll dot2 = (A.x - B.x) * (p.x - B.x) + (A.y - B.y) * (p.y - B.y);\n            if(dot1 >= 0 && dot2 >= 0) {\n                ensuref(false, \"Query point %d lies on side %d\", i+1, j+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Point {\n    ll x, y;\n    Point(ll x=0, ll y=0): x(x), y(y){}\n    Point operator - (const Point& b) const {\n        return Point(x - b.x, y - b.y);\n    }\n};\n\nll cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n\n    vector<Point> poly(n);\n    for(int i = 0; i < n; ++i) {\n        ll x = inf.readLong(-1000000000LL, 1000000000LL, format(\"x[%d]\", i+1));\n        inf.readSpace();\n        ll y = inf.readLong(-1000000000LL, 1000000000LL, format(\"y[%d]\", i+1));\n        inf.readEoln();\n        poly[i] = Point(x, y);\n    }\n\n    // Check that all cross products have the same sign\n    int sign = 0;\n    for(int i = 0; i < n; ++i) {\n        Point A = poly[i];\n        Point B = poly[(i+1)%n];\n        Point C = poly[(i+2)%n];\n        Point BA = B - A;\n        Point CB = C - B;\n        ll z = cross(BA, CB);\n        ensuref(z != 0, \"No three consecutive points may be colinear at positions %d, %d, %d\", i+1, ((i+1)%n)+1, ((i+2)%n)+1);\n        int curr_sign = (z > 0 ? 1 : -1);\n        if(sign == 0) sign = curr_sign;\n        else ensuref(sign == curr_sign, \"Polygon is not convex at positions %d, %d, %d\", i+1, ((i+1)%n)+1, ((i+2)%n)+1);\n    }\n\n    // Check that all points are unique\n    set<pair<ll, ll>> points_set;\n    for(int i = 0; i < n; ++i) {\n        auto p = make_pair(poly[i].x, poly[i].y);\n        ensuref(points_set.find(p) == points_set.end(), \"No two vertices can be at the same position (%lld, %lld)\", poly[i].x, poly[i].y);\n        points_set.insert(p);\n    }\n\n    int t = inf.readInt(1, 20, \"t\");\n    inf.readEoln();\n\n    for(int i = 0; i < t; ++i) {\n        ll x = inf.readLong(-1000000000LL, 1000000000LL, format(\"query_x[%d]\", i+1));\n        inf.readSpace();\n        ll y = inf.readLong(-1000000000LL, 1000000000LL, format(\"query_y[%d]\", i+1));\n        inf.readEoln();\n        Point p = Point(x, y);\n\n        // Check that point p does not lie on any side of the polygon\n        for(int j = 0; j < n; ++j) {\n            Point A = poly[j];\n            Point B = poly[(j+1)%n];\n            Point BA = B - A;\n            Point PA = p - A;\n            ll cross_prod = cross(BA, PA);\n            if(cross_prod != 0) continue; // Not colinear\n            // Colinear, check if p lies on segment AB\n            ll dot1 = (B.x - A.x) * (p.x - A.x) + (B.y - A.y) * (p.y - A.y);\n            ll dot2 = (A.x - B.x) * (p.x - B.x) + (A.y - B.y) * (p.y - B.y);\n            if(dot1 >= 0 && dot2 >= 0) {\n                ensuref(false, \"Query point %d lies on side %d\", i+1, j+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\", 1);\n    string poly_type = opt<string>(\"poly_type\", \"regular\");\n    string point_type = opt<string>(\"point_type\", \"inside\");\n\n    vector<pair<int, int>> polygon;\n\n    // Generate polygon vertices\n    if (poly_type == \"regular\") {\n        // Regular polygon\n        double R = 1e8;\n        for (int i = 0; i < n; i++) {\n            double angle = 2.0 * PI * (n - 1 - i) / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int) round(x);\n            int yi = (int) round(y);\n            polygon.push_back(make_pair(xi, yi));\n        }\n    } else if (poly_type == \"random\") {\n        // Random convex polygon\n        // Generate random angles\n        vector<double> angles;\n        for (int i = 0; i < n; i++) {\n            angles.push_back(rnd.next(0.0, 2.0 * PI));\n        }\n        sort(angles.begin(), angles.end());\n        double R = 1e8;\n        for (int i = 0; i < n; i++) {\n            double angle = angles[n - 1 - i]; // Clockwise order\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int) round(x);\n            int yi = (int) round(y);\n            polygon.push_back(make_pair(xi, yi));\n        }\n    } else if (poly_type == \"maxcoords\") {\n        // Polygon with coordinates near max values\n        polygon.push_back(make_pair(1000000000, 1000000000));\n        polygon.push_back(make_pair(-999999999, 1000000000)); // Ensure no three colinear\n        polygon.push_back(make_pair(-999999998, -999999999));\n        polygon.push_back(make_pair(999999999, -999999998));\n        // If n > 4, add more points near the corners\n        for (int i = 4; i < n; i++) {\n            int xi = rnd.next(-999999997, 999999997);\n            int yi = rnd.next(-999999997, 999999997);\n            // Ensure the point is within the convex hull\n            polygon.push_back(make_pair(xi, yi));\n        }\n        // For simplicity, restrict n to be at most 5 for \"maxcoords\" type in our test cases\n    } else if (poly_type == \"skinny\") {\n        // Generate a skinny polygon\n        double x_start = -5e8;\n        double x_end = 5e8;\n        double y_base = 0;\n        double y_top = 1e6;\n        for (int i = 0; i < n; i++) {\n            double x = x_start + (x_end - x_start) * i / (n - 1);\n            if (i % 2 == 0)\n                polygon.push_back(make_pair((int)x, (int)y_base));\n            else\n                polygon.push_back(make_pair((int)x, (int)y_top));\n        }\n    } else {\n        // Default to regular polygon\n        double R = 1e8;\n        for (int i = 0; i < n; i++) {\n            double angle = 2.0 * PI * (n - 1 - i) / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int) round(x);\n            int yi = (int) round(y);\n            polygon.push_back(make_pair(xi, yi));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the polygon vertices\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", polygon[i].first, polygon[i].second);\n    }\n\n    vector<pair<int, int>> points;\n\n    // Generate t points\n    for (int i = 0; i < t; i++) {\n        int xi, yi;\n\n        if (point_type == \"inside\") {\n            // Generate a point inside the polygon\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(0.0, 0.8e8);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        } else if (point_type == \"outside\") {\n            // Generate a point outside the polygon\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(1.1e8, 2e8);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        } else if (point_type == \"near_edge\") {\n            // Generate a point near the edge\n            int idx = rnd.next(0, n - 1);\n            int x1 = polygon[idx].first;\n            int y1 = polygon[idx].second;\n            int x2 = polygon[(idx + 1) % n].first;\n            int y2 = polygon[(idx + 1) % n].second;\n            double t = rnd.next(0.2, 0.8);\n            double x = x1 + t * (x2 - x1);\n            double y = y1 + t * (y2 - y1);\n            // Perturb slightly towards inside\n            double dx = -(y2 - y1);\n            double dy = x2 - x1;\n            double len = sqrt(dx * dx + dy * dy);\n            dx /= len;\n            dy /= len;\n            double offset = rnd.next(1e3, 1e4);\n            xi = (int) round(x + dx * offset);\n            yi = (int) round(y + dy * offset);\n        } else if (point_type == \"outside_far\") {\n            // Generate a point far outside the polygon\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(1e9, 1e9 * 1.1);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        } else if (point_type == \"center\") {\n            xi = 0;\n            yi = 0;\n        } else {\n            // Default to inside\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(0.0, 0.8e8);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        }\n\n        // Ensure the point is not on any side or diagonal\n        points.push_back(make_pair(xi, yi));\n    }\n\n    // Output t\n    printf(\"%d\\n\", t);\n    // Output the points\n    for (int i = 0; i < t; i++) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst double PI = acos(-1.0);\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\", 1);\n    string poly_type = opt<string>(\"poly_type\", \"regular\");\n    string point_type = opt<string>(\"point_type\", \"inside\");\n\n    vector<pair<int, int>> polygon;\n\n    // Generate polygon vertices\n    if (poly_type == \"regular\") {\n        // Regular polygon\n        double R = 1e8;\n        for (int i = 0; i < n; i++) {\n            double angle = 2.0 * PI * (n - 1 - i) / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int) round(x);\n            int yi = (int) round(y);\n            polygon.push_back(make_pair(xi, yi));\n        }\n    } else if (poly_type == \"random\") {\n        // Random convex polygon\n        // Generate random angles\n        vector<double> angles;\n        for (int i = 0; i < n; i++) {\n            angles.push_back(rnd.next(0.0, 2.0 * PI));\n        }\n        sort(angles.begin(), angles.end());\n        double R = 1e8;\n        for (int i = 0; i < n; i++) {\n            double angle = angles[n - 1 - i]; // Clockwise order\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int) round(x);\n            int yi = (int) round(y);\n            polygon.push_back(make_pair(xi, yi));\n        }\n    } else if (poly_type == \"maxcoords\") {\n        // Polygon with coordinates near max values\n        polygon.push_back(make_pair(1000000000, 1000000000));\n        polygon.push_back(make_pair(-999999999, 1000000000)); // Ensure no three colinear\n        polygon.push_back(make_pair(-999999998, -999999999));\n        polygon.push_back(make_pair(999999999, -999999998));\n        // If n > 4, add more points near the corners\n        for (int i = 4; i < n; i++) {\n            int xi = rnd.next(-999999997, 999999997);\n            int yi = rnd.next(-999999997, 999999997);\n            // Ensure the point is within the convex hull\n            polygon.push_back(make_pair(xi, yi));\n        }\n        // For simplicity, restrict n to be at most 5 for \"maxcoords\" type in our test cases\n    } else if (poly_type == \"skinny\") {\n        // Generate a skinny polygon\n        double x_start = -5e8;\n        double x_end = 5e8;\n        double y_base = 0;\n        double y_top = 1e6;\n        for (int i = 0; i < n; i++) {\n            double x = x_start + (x_end - x_start) * i / (n - 1);\n            if (i % 2 == 0)\n                polygon.push_back(make_pair((int)x, (int)y_base));\n            else\n                polygon.push_back(make_pair((int)x, (int)y_top));\n        }\n    } else {\n        // Default to regular polygon\n        double R = 1e8;\n        for (int i = 0; i < n; i++) {\n            double angle = 2.0 * PI * (n - 1 - i) / n;\n            double x = R * cos(angle);\n            double y = R * sin(angle);\n            int xi = (int) round(x);\n            int yi = (int) round(y);\n            polygon.push_back(make_pair(xi, yi));\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the polygon vertices\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", polygon[i].first, polygon[i].second);\n    }\n\n    vector<pair<int, int>> points;\n\n    // Generate t points\n    for (int i = 0; i < t; i++) {\n        int xi, yi;\n\n        if (point_type == \"inside\") {\n            // Generate a point inside the polygon\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(0.0, 0.8e8);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        } else if (point_type == \"outside\") {\n            // Generate a point outside the polygon\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(1.1e8, 2e8);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        } else if (point_type == \"near_edge\") {\n            // Generate a point near the edge\n            int idx = rnd.next(0, n - 1);\n            int x1 = polygon[idx].first;\n            int y1 = polygon[idx].second;\n            int x2 = polygon[(idx + 1) % n].first;\n            int y2 = polygon[(idx + 1) % n].second;\n            double t = rnd.next(0.2, 0.8);\n            double x = x1 + t * (x2 - x1);\n            double y = y1 + t * (y2 - y1);\n            // Perturb slightly towards inside\n            double dx = -(y2 - y1);\n            double dy = x2 - x1;\n            double len = sqrt(dx * dx + dy * dy);\n            dx /= len;\n            dy /= len;\n            double offset = rnd.next(1e3, 1e4);\n            xi = (int) round(x + dx * offset);\n            yi = (int) round(y + dy * offset);\n        } else if (point_type == \"outside_far\") {\n            // Generate a point far outside the polygon\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(1e9, 1e9 * 1.1);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        } else if (point_type == \"center\") {\n            xi = 0;\n            yi = 0;\n        } else {\n            // Default to inside\n            double angle = rnd.next(0.0, 2.0 * PI);\n            double radius = rnd.next(0.0, 0.8e8);\n            double x = radius * cos(angle);\n            double y = radius * sin(angle);\n            xi = (int) round(x);\n            yi = (int) round(y);\n        }\n\n        // Ensure the point is not on any side or diagonal\n        points.push_back(make_pair(xi, yi));\n    }\n\n    // Output t\n    printf(\"%d\\n\", t);\n    // Output the points\n    for (int i = 0; i < t; i++) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -t 1 -poly_type regular -point_type inside\n./gen -n 3 -t 1 -poly_type regular -point_type outside\n./gen -n 3 -t 1 -poly_type regular -point_type near_edge\n\n./gen -n 10 -t 5 -poly_type regular -point_type inside\n./gen -n 10 -t 5 -poly_type regular -point_type outside\n\n./gen -n 100 -t 10 -poly_type random -point_type inside\n./gen -n 100 -t 10 -poly_type random -point_type outside\n\n./gen -n 1000 -t 5 -poly_type regular -point_type inside\n./gen -n 1000 -t 5 -poly_type skinny -point_type inside\n\n./gen -n 100000 -t 1 -poly_type random -point_type inside\n./gen -n 100000 -t 1 -poly_type regular -point_type outside\n\n./gen -n 50000 -t 20 -poly_type random -point_type near_edge\n\n./gen -n 100000 -t 20 -poly_type random -point_type inside\n\n./gen -n 99999 -t 20 -poly_type skinny -point_type near_edge\n\n./gen -n 100000 -t 20 -poly_type regular -point_type outside_far\n\n./gen -n 100000 -t 1 -poly_type random -point_type center\n\n# Edge cases\n./gen -n 3 -t 1 -poly_type regular -point_type center\n./gen -n 3 -t 1 -poly_type maxcoords -point_type inside\n\n./gen -n 4 -t 2 -poly_type maxcoords -point_type inside\n\n./gen -n 1000 -t 1 -poly_type skinny -point_type inside\n\n./gen -n 100000 -t 1 -poly_type skinny -point_type outside\n\n./gen -n 99713 -t 10 -poly_type random -point_type inside\n\n# Maximum limits\n./gen -n 100000 -t 20 -poly_type random -point_type inside\n./gen -n 100000 -t 20 -poly_type skinny -point_type outside\n./gen -n 100000 -t 20 -poly_type regular -point_type inside\n./gen -n 100000 -t 20 -poly_type random -point_type outside\n./gen -n 100000 -t 20 -poly_type skinny -point_type near_edge\n./gen -n 100000 -t 20 -poly_type random -point_type near_edge\n./gen -n 100000 -t 20 -poly_type regular -point_type center\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:31.796333",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "550/A",
      "title": "A. Two Substrings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe only line of input contains a string s of length between 1 and 105 consisting of uppercase Latin letters.",
      "output_spec": "OutputPrint \"YES\" (without the quotes), if string s contains two non-overlapping substrings \"AB\" and \"BA\", and \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopyABAOutputCopyNOInputCopyBACFABOutputCopyYESInputCopyAXBYBXAOutputCopyNO",
      "description": "A. Two Substrings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe only line of input contains a string s of length between 1 and 105 consisting of uppercase Latin letters.\n\nOutputPrint \"YES\" (without the quotes), if string s contains two non-overlapping substrings \"AB\" and \"BA\", and \"NO\" otherwise.\n\nInputCopyABAOutputCopyNOInputCopyBACFABOutputCopyYESInputCopyAXBYBXAOutputCopyNO\n\nInputCopyABA\n\nOutputCopyNO\n\nInputCopyBACFAB\n\nOutputCopyYES\n\nInputCopyAXBYBXA\n\nOutputCopyNO\n\nNoteIn the first sample test, despite the fact that there are substrings \"AB\" and \"BA\", their occurrences overlap, so the answer is \"NO\".In the second sample test there are the following occurrences of the substrings: BACFAB.In the third sample test there is no substring \"AB\" nor substring \"BA\".",
      "solutions": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!We are glad to announce that on 4th of June at 19:30 MSK Codeforces Round #306 will be held. Authors of this contest are me (Adilet Zhaxybay) and Timur Sitdikov (Timur_Sitdikov). The round will be rated for the second division, however, participants from the first division can, as usually, participate in it unofficially.We want to thank all the people, who helped us to prepare the contest: Max Akhmedov (Zlobober), who helped us with the problems, Bekzhan Kassenov (BekzhanKassenov) and Sergey Lazarev (SergeyLazarev), who tested the round, and Maria Belova (Delinur), who translated problem statements. Also we want to say great thanks to Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon.By the way, as far as we know, Timur_Sitdikov is the first participant from Uzbekistan, who took part in the preparation of Codeforces round. We hope that everything will go well :) Good luck to all! UPD The scoring will be dynamicUPD2 Editorial can be found hereUPD3 Congratulations to winners! mff I_Love_Nodir.Daminov tun I_love_Ngoc_cmn_Thuy goodhope Round is over, thanks to everybody, who took part in it!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18303",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1141
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces",
          "content": "550A - Two SubstringsThere are many ways to solve this problem. Author solution does the following: check if substring \"AB\" goes before \"BA\", and then vice versa, if \"BA\" goes before \"AB\". You can do it in the following way: find the first occurence of \"AB\" then check all substrings of length two to the right of it to check if substring \"BA\" also exists. Then do it vice versa. Complexity of the solution is O(n), where n is the length of the given string.550B - Preparing OlympiadBecause of the low constraints, this problem can be solved by complete search over all problem sets (there are 2n of them).For every potential problem set (which can be conviniently expressed as bit mask) we need to check if it satisfies all needed criteria. We can simply find the sum of problem complexities and also the difference between the most difficult and the easiest problems in linear time, iterating over the problems that we included in our current set/bitmask. If this problem set can be used, we increase the answer by one.Complexity of this solution is O(2n·n).550C - Divisibility by EightThis problem can be solved with at least two different approaches. The first one is based on the \"school\" property of the divisibility by eight — number can be divided by eight if and only if its last three digits form a number that can be divided by eight. Thus, it is enough to test only numbers that can be obtained from the original one by crossing out and that contain at most three digits (so we check only all one-digit, two-digit and three-digit numbers). This can be done in O(len3) with three nested loops (here len is the length of the original number).Second approach uses dynamic programming. Let's calculate dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8. The value of dp is true if we can cross out some digits from the prefix of length i such that the remaining number gives j modulo eight, and false otherwise. This dp can be calculated in the following way: let ai be ith digit of the given number. Then dp[i][aimod8] = true (just this number). For all 0 ≤ j < 8 such that dp[i - 1][j] = true, dp[i][(j * 10 + ai)mod8] = true (we add current digit to some previous result), dp[i][j] = true (we cross out current digit). Answer is \"YES\" if dp[i][0] = true for some position i. For restoring the answer we need to keep additional array prev[i][j], which will say from where current value was calculated. Complexity of such solution is O(8·len) = O(len) (again len is the length of the original number).Code for DP solution: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Regular BridgeLet's prove that there is no solution for even k. Suppose our graph contains some bridges, k = 2s (even), all degrees are k. Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge. Consider this component. Let's remove bridge that connects it to the remaining graph. Then it has one vertex with degree k - 1 = 2s - 1 and some vertices with degrees k = 2s. But then the graph consisting of this component will contain only one vertex with odd degree, which is impossible by Handshaking Lemma. Let's construct the answer for odd k. Let k = 2s - 1.For k = 1 graph consisting of two nodes connected by edge works. For k ≥ 3 let's construct graph with 2k + 4 nodes. Let it consist of two strongly connected components connected by bridge. Enumerate nodes of first component from 1 to k + 2, second component will be the same as the first one.Let vertex 1 be connected to the second component by bridge. Also connect it with k - 1 edges to vertices 2, 3, ..., k. Connect vertices 2, 3, ..., k to each other (add all possible edges between them), and then remove edges between every neighbouring pair, for example edges 2 - 3, 4 - 5, ..., (k - 1) - k. Then we connect vertices 2, 3, ..., k with vertices k + 1 and k + 2. And finally add an edge between nodes k + 1 and k + 2. Build the second component in the similar manner, and add a bridge between components. Constructed graph has one bridge, all degrees of k and consists of O(k) nodes and O(k2) edges.Complexity of the solution — O(k2).550E - Brackets in ImplicationsLet input consists of , ai is 0 or 1 for all i.Let's show that there is no solution in only two cases:1) an = 1., for all x, and no parentheses can change last 1 to 0.2) Input has the form or its suffix with at least two arguments.This can be proven by induction. For input there is no solution, for longer inputs any attempt to put parentheses will decrease the number of 1s in the beginning by one, or will introduce 1 in the last position (which will lead to case one). Let's construct solution for all other cases.1) For input 0 we don't need to do anything.2) For input of the form we don't need any parentheses, the value of this expression is always 3) Expression in the form (where second missed part consists of ones only). Then .Complexity of the solution is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*A"
          },
          "content_length": 5853
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces",
          "content": "550A - Two SubstringsThere are many ways to solve this problem. Author solution does the following: check if substring \"AB\" goes before \"BA\", and then vice versa, if \"BA\" goes before \"AB\". You can do it in the following way: find the first occurence of \"AB\" then check all substrings of length two to the right of it to check if substring \"BA\" also exists. Then do it vice versa. Complexity of the solution is O(n), where n is the length of the given string.550B - Preparing OlympiadBecause of the low constraints, this problem can be solved by complete search over all problem sets (there are 2n of them).For every potential problem set (which can be conviniently expressed as bit mask) we need to check if it satisfies all needed criteria. We can simply find the sum of problem complexities and also the difference between the most difficult and the easiest problems in linear time, iterating over the problems that we included in our current set/bitmask. If this problem set can be used, we increase the answer by one.Complexity of this solution is O(2n·n).550C - Divisibility by EightThis problem can be solved with at least two different approaches. The first one is based on the \"school\" property of the divisibility by eight — number can be divided by eight if and only if its last three digits form a number that can be divided by eight. Thus, it is enough to test only numbers that can be obtained from the original one by crossing out and that contain at most three digits (so we check only all one-digit, two-digit and three-digit numbers). This can be done in O(len3) with three nested loops (here len is the length of the original number).Second approach uses dynamic programming. Let's calculate dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8. The value of dp is true if we can cross out some digits from the prefix of length i such that the remaining number gives j modulo eight, and false otherwise. This dp can be calculated in the following way: let ai be ith digit of the given number. Then dp[i][aimod8] = true (just this number). For all 0 ≤ j < 8 such that dp[i - 1][j] = true, dp[i][(j * 10 + ai)mod8] = true (we add current digit to some previous result), dp[i][j] = true (we cross out current digit). Answer is \"YES\" if dp[i][0] = true for some position i. For restoring the answer we need to keep additional array prev[i][j], which will say from where current value was calculated. Complexity of such solution is O(8·len) = O(len) (again len is the length of the original number).Code for DP solution: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Regular BridgeLet's prove that there is no solution for even k. Suppose our graph contains some bridges, k = 2s (even), all degrees are k. Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge. Consider this component. Let's remove bridge that connects it to the remaining graph. Then it has one vertex with degree k - 1 = 2s - 1 and some vertices with degrees k = 2s. But then the graph consisting of this component will contain only one vertex with odd degree, which is impossible by Handshaking Lemma. Let's construct the answer for odd k. Let k = 2s - 1.For k = 1 graph consisting of two nodes connected by edge works. For k ≥ 3 let's construct graph with 2k + 4 nodes. Let it consist of two strongly connected components connected by bridge. Enumerate nodes of first component from 1 to k + 2, second component will be the same as the first one.Let vertex 1 be connected to the second component by bridge. Also connect it with k - 1 edges to vertices 2, 3, ..., k. Connect vertices 2, 3, ..., k to each other (add all possible edges between them), and then remove edges between every neighbouring pair, for example edges 2 - 3, 4 - 5, ..., (k - 1) - k. Then we connect vertices 2, 3, ..., k with vertices k + 1 and k + 2. And finally add an edge between nodes k + 1 and k + 2. Build the second component in the similar manner, and add a bridge between components. Constructed graph has one bridge, all degrees of k and consists of O(k) nodes and O(k2) edges.Complexity of the solution — O(k2).550E - Brackets in ImplicationsLet input consists of , ai is 0 or 1 for all i.Let's show that there is no solution in only two cases:1) an = 1., for all x, and no parentheses can change last 1 to 0.2) Input has the form or its suffix with at least two arguments.This can be proven by induction. For input there is no solution, for longer inputs any attempt to put parentheses will decrease the number of 1s in the beginning by one, or will introduce 1 in the last position (which will lead to case one). Let's construct solution for all other cases.1) For input 0 we don't need to do anything.2) For input of the form we don't need any parentheses, the value of this expression is always 3) Expression in the form (where second missed part consists of ones only). Then .Complexity of the solution is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*A"
          },
          "content_length": 5853
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "string temp=std::to_string(i);\n\n                     ^",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "#define endl \"\\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,100000}\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,100000}\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]{1,100000}\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate random uppercase letters 'A'-'Z'\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"no_substrings\") {\n        // Generate a string without \"AB\" or \"BA\"\n        // Use letters other than 'A' and 'B'\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = 'A' + rnd.next(26);\n            } while(c == 'A' || c == 'B');\n            s[i] = c;\n        }\n    } else if (type == \"overlapping\") {\n        // Generate a string where \"AB\" and \"BA\" occur but they overlap\n        if(n < 3) {\n            // Not possible to have overlapping substrings in less than 3 letters\n            quitf(_fail, \"n must be at least 3 for overlapping test\");\n        }\n        // Create a string like \"ABABAB...\"\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i%2==0) ? 'A' : 'B';\n        }\n    } else if (type == \"nonoverlapping\") {\n        // Generate a string where \"AB\" and \"BA\" occur non-overlapping\n        if(n < 4) {\n            // Not possible to have non-overlapping substrings in less than 4 letters\n            quitf(_fail, \"n must be at least 4 for nonoverlapping test\");\n        }\n        // Initialize s with random letters\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n\n        int pos1 = rnd.next(0, n-2);\n        int pos2;\n        do {\n            pos2 = rnd.next(0, n-2);\n        } while(abs(pos1 - pos2) <= 1); // Ensure they do not overlap\n\n        // Assign \"AB\" at pos1, \"BA\" at pos2\n        s[pos1] = 'A';\n        s[pos1 +1] = 'B';\n        s[pos2] = 'B';\n        s[pos2 +1] = 'A';\n\n    } else if (type == \"allA\") {\n        // String of all 'A's\n        s.assign(n, 'A');\n    } else if (type == \"allB\") {\n        // String of all 'B's\n        s.assign(n, 'B');\n    } else if (type == \"max_length\") {\n        // A string of max length n=1e5, random letters\n        if(n != 100000) {\n            quitf(_fail, \"n must be 100000 for max_length test\");\n        }\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"edge\") {\n        // Test edge cases\n        if(n == 1) {\n            s = \"A\";\n        } else if(n == 2) {\n            s = \"AB\";\n        } else {\n            s.assign(n, 'C'); // A string of 'C's\n        }\n    } else if (type == \"alternating\") {\n        // Alternating 'A's and 'B's\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i%2==0) ? 'A' : 'B';\n        }\n    } else {\n        quitf(_fail, \"Unknown type '%s'\", type.c_str());\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate random uppercase letters 'A'-'Z'\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"no_substrings\") {\n        // Generate a string without \"AB\" or \"BA\"\n        // Use letters other than 'A' and 'B'\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            char c;\n            do {\n                c = 'A' + rnd.next(26);\n            } while(c == 'A' || c == 'B');\n            s[i] = c;\n        }\n    } else if (type == \"overlapping\") {\n        // Generate a string where \"AB\" and \"BA\" occur but they overlap\n        if(n < 3) {\n            // Not possible to have overlapping substrings in less than 3 letters\n            quitf(_fail, \"n must be at least 3 for overlapping test\");\n        }\n        // Create a string like \"ABABAB...\"\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i%2==0) ? 'A' : 'B';\n        }\n    } else if (type == \"nonoverlapping\") {\n        // Generate a string where \"AB\" and \"BA\" occur non-overlapping\n        if(n < 4) {\n            // Not possible to have non-overlapping substrings in less than 4 letters\n            quitf(_fail, \"n must be at least 4 for nonoverlapping test\");\n        }\n        // Initialize s with random letters\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n\n        int pos1 = rnd.next(0, n-2);\n        int pos2;\n        do {\n            pos2 = rnd.next(0, n-2);\n        } while(abs(pos1 - pos2) <= 1); // Ensure they do not overlap\n\n        // Assign \"AB\" at pos1, \"BA\" at pos2\n        s[pos1] = 'A';\n        s[pos1 +1] = 'B';\n        s[pos2] = 'B';\n        s[pos2 +1] = 'A';\n\n    } else if (type == \"allA\") {\n        // String of all 'A's\n        s.assign(n, 'A');\n    } else if (type == \"allB\") {\n        // String of all 'B's\n        s.assign(n, 'B');\n    } else if (type == \"max_length\") {\n        // A string of max length n=1e5, random letters\n        if(n != 100000) {\n            quitf(_fail, \"n must be 100000 for max_length test\");\n        }\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = 'A' + rnd.next(26);\n        }\n    } else if (type == \"edge\") {\n        // Test edge cases\n        if(n == 1) {\n            s = \"A\";\n        } else if(n == 2) {\n            s = \"AB\";\n        } else {\n            s.assign(n, 'C'); // A string of 'C's\n        }\n    } else if (type == \"alternating\") {\n        // Alternating 'A's and 'B's\n        s.resize(n);\n        for(int i = 0; i < n; ++i) {\n            s[i] = (i%2==0) ? 'A' : 'B';\n        }\n    } else {\n        quitf(_fail, \"Unknown type '%s'\", type.c_str());\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random strings of small length\n./gen -n 5 -type random\n./gen -n 10 -type random\n\n# Random strings of medium length\n./gen -n 100 -type random\n./gen -n 1000 -type random\n\n# Random string of maximum length\n./gen -n 100000 -type random\n\n# Strings with no \"AB\" or \"BA\" substrings\n./gen -n 5 -type no_substrings\n./gen -n 100 -type no_substrings\n./gen -n 100000 -type no_substrings\n\n# Strings with overlapping \"AB\" and \"BA\"\n./gen -n 3 -type overlapping\n./gen -n 10 -type overlapping\n./gen -n 1000 -type overlapping\n./gen -n 100000 -type overlapping\n\n# Strings with non-overlapping \"AB\" and \"BA\"\n./gen -n 4 -type nonoverlapping\n./gen -n 100 -type nonoverlapping\n./gen -n 100000 -type nonoverlapping\n\n# Strings of all 'A's\n./gen -n 1 -type allA\n./gen -n 2 -type allA\n./gen -n 100000 -type allA\n\n# Strings of all 'B's\n./gen -n 1 -type allB\n./gen -n 2 -type allB\n./gen -n 100000 -type allB\n\n# Edge cases\n./gen -n 1 -type edge\n./gen -n 2 -type edge\n./gen -n 3 -type edge\n\n# Alternating 'A's and 'B's\n./gen -n 2 -type alternating\n./gen -n 3 -type alternating\n./gen -n 100000 -type alternating\n\n# Max length test with random letters\n./gen -n 100000 -type max_length\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:33.827868",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "550/B",
      "title": "B. Preparing Olympiad",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.",
      "output_spec": "OutputPrint the number of ways to choose a suitable problemset for the contest.",
      "sample_tests": "ExamplesInputCopy3 5 6 11 2 3OutputCopy2InputCopy4 40 50 1010 20 30 25OutputCopy2InputCopy5 25 35 1010 10 20 10 20OutputCopy6",
      "description": "B. Preparing Olympiad\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers n, l, r, x (1 ≤ n ≤ 15, 1 ≤ l ≤ r ≤ 109, 1 ≤ x ≤ 106) — the number of problems you have, the minimum and maximum value of total difficulty of the problemset and the minimum difference in difficulty between the hardest problem in the pack and the easiest one, respectively.The second line contains n integers c1, c2, ..., cn (1 ≤ ci ≤ 106) — the difficulty of each problem.\n\nOutputPrint the number of ways to choose a suitable problemset for the contest.\n\nInputCopy3 5 6 11 2 3OutputCopy2InputCopy4 40 50 1010 20 30 25OutputCopy2InputCopy5 25 35 1010 10 20 10 20OutputCopy6\n\nInputCopy3 5 6 11 2 3\n\nOutputCopy2\n\nInputCopy4 40 50 1010 20 30 25\n\nOutputCopy2\n\nInputCopy5 25 35 1010 10 20 10 20\n\nOutputCopy6\n\nNoteIn the first example two sets are suitable, one consisting of the second and third problem, another one consisting of all three problems.In the second example, two sets of problems are suitable — the set of problems with difficulties 10 and 30 as well as the set of problems with difficulties 20 and 30.In the third example any set consisting of one problem of difficulty 10 and one problem of difficulty 20 is suitable.",
      "solutions": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!We are glad to announce that on 4th of June at 19:30 MSK Codeforces Round #306 will be held. Authors of this contest are me (Adilet Zhaxybay) and Timur Sitdikov (Timur_Sitdikov). The round will be rated for the second division, however, participants from the first division can, as usually, participate in it unofficially.We want to thank all the people, who helped us to prepare the contest: Max Akhmedov (Zlobober), who helped us with the problems, Bekzhan Kassenov (BekzhanKassenov) and Sergey Lazarev (SergeyLazarev), who tested the round, and Maria Belova (Delinur), who translated problem statements. Also we want to say great thanks to Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon.By the way, as far as we know, Timur_Sitdikov is the first participant from Uzbekistan, who took part in the preparation of Codeforces round. We hope that everything will go well :) Good luck to all! UPD The scoring will be dynamicUPD2 Editorial can be found hereUPD3 Congratulations to winners! mff I_Love_Nodir.Daminov tun I_love_Ngoc_cmn_Thuy goodhope Round is over, thanks to everybody, who took part in it!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18303",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1141
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces",
          "content": "550A - Two SubstringsThere are many ways to solve this problem. Author solution does the following: check if substring \"AB\" goes before \"BA\", and then vice versa, if \"BA\" goes before \"AB\". You can do it in the following way: find the first occurence of \"AB\" then check all substrings of length two to the right of it to check if substring \"BA\" also exists. Then do it vice versa. Complexity of the solution is O(n), where n is the length of the given string.550B - Preparing OlympiadBecause of the low constraints, this problem can be solved by complete search over all problem sets (there are 2n of them).For every potential problem set (which can be conviniently expressed as bit mask) we need to check if it satisfies all needed criteria. We can simply find the sum of problem complexities and also the difference between the most difficult and the easiest problems in linear time, iterating over the problems that we included in our current set/bitmask. If this problem set can be used, we increase the answer by one.Complexity of this solution is O(2n·n).550C - Divisibility by EightThis problem can be solved with at least two different approaches. The first one is based on the \"school\" property of the divisibility by eight — number can be divided by eight if and only if its last three digits form a number that can be divided by eight. Thus, it is enough to test only numbers that can be obtained from the original one by crossing out and that contain at most three digits (so we check only all one-digit, two-digit and three-digit numbers). This can be done in O(len3) with three nested loops (here len is the length of the original number).Second approach uses dynamic programming. Let's calculate dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8. The value of dp is true if we can cross out some digits from the prefix of length i such that the remaining number gives j modulo eight, and false otherwise. This dp can be calculated in the following way: let ai be ith digit of the given number. Then dp[i][aimod8] = true (just this number). For all 0 ≤ j < 8 such that dp[i - 1][j] = true, dp[i][(j * 10 + ai)mod8] = true (we add current digit to some previous result), dp[i][j] = true (we cross out current digit). Answer is \"YES\" if dp[i][0] = true for some position i. For restoring the answer we need to keep additional array prev[i][j], which will say from where current value was calculated. Complexity of such solution is O(8·len) = O(len) (again len is the length of the original number).Code for DP solution: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Regular BridgeLet's prove that there is no solution for even k. Suppose our graph contains some bridges, k = 2s (even), all degrees are k. Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge. Consider this component. Let's remove bridge that connects it to the remaining graph. Then it has one vertex with degree k - 1 = 2s - 1 and some vertices with degrees k = 2s. But then the graph consisting of this component will contain only one vertex with odd degree, which is impossible by Handshaking Lemma. Let's construct the answer for odd k. Let k = 2s - 1.For k = 1 graph consisting of two nodes connected by edge works. For k ≥ 3 let's construct graph with 2k + 4 nodes. Let it consist of two strongly connected components connected by bridge. Enumerate nodes of first component from 1 to k + 2, second component will be the same as the first one.Let vertex 1 be connected to the second component by bridge. Also connect it with k - 1 edges to vertices 2, 3, ..., k. Connect vertices 2, 3, ..., k to each other (add all possible edges between them), and then remove edges between every neighbouring pair, for example edges 2 - 3, 4 - 5, ..., (k - 1) - k. Then we connect vertices 2, 3, ..., k with vertices k + 1 and k + 2. And finally add an edge between nodes k + 1 and k + 2. Build the second component in the similar manner, and add a bridge between components. Constructed graph has one bridge, all degrees of k and consists of O(k) nodes and O(k2) edges.Complexity of the solution — O(k2).550E - Brackets in ImplicationsLet input consists of , ai is 0 or 1 for all i.Let's show that there is no solution in only two cases:1) an = 1., for all x, and no parentheses can change last 1 to 0.2) Input has the form or its suffix with at least two arguments.This can be proven by induction. For input there is no solution, for longer inputs any attempt to put parentheses will decrease the number of 1s in the beginning by one, or will introduce 1 in the last position (which will lead to case one). Let's construct solution for all other cases.1) For input 0 we don't need to do anything.2) For input of the form we don't need any parentheses, the value of this expression is always 3) Expression in the form (where second missed part consists of ones only). Then .Complexity of the solution is O(n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*B"
          },
          "content_length": 5853
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces",
          "content": "550A - Two SubstringsThere are many ways to solve this problem. Author solution does the following: check if substring \"AB\" goes before \"BA\", and then vice versa, if \"BA\" goes before \"AB\". You can do it in the following way: find the first occurence of \"AB\" then check all substrings of length two to the right of it to check if substring \"BA\" also exists. Then do it vice versa. Complexity of the solution is O(n), where n is the length of the given string.550B - Preparing OlympiadBecause of the low constraints, this problem can be solved by complete search over all problem sets (there are 2n of them).For every potential problem set (which can be conviniently expressed as bit mask) we need to check if it satisfies all needed criteria. We can simply find the sum of problem complexities and also the difference between the most difficult and the easiest problems in linear time, iterating over the problems that we included in our current set/bitmask. If this problem set can be used, we increase the answer by one.Complexity of this solution is O(2n·n).550C - Divisibility by EightThis problem can be solved with at least two different approaches. The first one is based on the \"school\" property of the divisibility by eight — number can be divided by eight if and only if its last three digits form a number that can be divided by eight. Thus, it is enough to test only numbers that can be obtained from the original one by crossing out and that contain at most three digits (so we check only all one-digit, two-digit and three-digit numbers). This can be done in O(len3) with three nested loops (here len is the length of the original number).Second approach uses dynamic programming. Let's calculate dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8. The value of dp is true if we can cross out some digits from the prefix of length i such that the remaining number gives j modulo eight, and false otherwise. This dp can be calculated in the following way: let ai be ith digit of the given number. Then dp[i][aimod8] = true (just this number). For all 0 ≤ j < 8 such that dp[i - 1][j] = true, dp[i][(j * 10 + ai)mod8] = true (we add current digit to some previous result), dp[i][j] = true (we cross out current digit). Answer is \"YES\" if dp[i][0] = true for some position i. For restoring the answer we need to keep additional array prev[i][j], which will say from where current value was calculated. Complexity of such solution is O(8·len) = O(len) (again len is the length of the original number).Code for DP solution: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Regular BridgeLet's prove that there is no solution for even k. Suppose our graph contains some bridges, k = 2s (even), all degrees are k. Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge. Consider this component. Let's remove bridge that connects it to the remaining graph. Then it has one vertex with degree k - 1 = 2s - 1 and some vertices with degrees k = 2s. But then the graph consisting of this component will contain only one vertex with odd degree, which is impossible by Handshaking Lemma. Let's construct the answer for odd k. Let k = 2s - 1.For k = 1 graph consisting of two nodes connected by edge works. For k ≥ 3 let's construct graph with 2k + 4 nodes. Let it consist of two strongly connected components connected by bridge. Enumerate nodes of first component from 1 to k + 2, second component will be the same as the first one.Let vertex 1 be connected to the second component by bridge. Also connect it with k - 1 edges to vertices 2, 3, ..., k. Connect vertices 2, 3, ..., k to each other (add all possible edges between them), and then remove edges between every neighbouring pair, for example edges 2 - 3, 4 - 5, ..., (k - 1) - k. Then we connect vertices 2, 3, ..., k with vertices k + 1 and k + 2. And finally add an edge between nodes k + 1 and k + 2. Build the second component in the similar manner, and add a bridge between components. Constructed graph has one bridge, all degrees of k and consists of O(k) nodes and O(k2) edges.Complexity of the solution — O(k2).550E - Brackets in ImplicationsLet input consists of , ai is 0 or 1 for all i.Let's show that there is no solution in only two cases:1) an = 1., for all x, and no parentheses can change last 1 to 0.2) Input has the form or its suffix with at least two arguments.This can be proven by induction. For input there is no solution, for longer inputs any attempt to put parentheses will decrease the number of 1s in the beginning by one, or will introduce 1 in the last position (which will lead to case one). Let's construct solution for all other cases.1) For input 0 we don't need to do anything.2) For input of the form we don't need any parentheses, the value of this expression is always 3) Expression in the form (where second missed part consists of ones only). Then .Complexity of the solution is O(n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*B"
          },
          "content_length": 5853
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "string temp=std::to_string(i);\n\n                     ^",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "#define endl \"\\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1, 1000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000LL, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000, \"x\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 1000000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1, 1000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000LL, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000, \"x\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 1000000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readSpace();\n    long long l = inf.readLong(1, 1000000000LL, \"l\");\n    inf.readSpace();\n    long long r = inf.readLong(l, 1000000000LL, \"r\");\n    inf.readSpace();\n    int x = inf.readInt(1, 1000000, \"x\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n, 1, 1000000, \"c\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    ensure(1 <= n && n <= 15);\n    ensure(1 <= l && l <= r && r <= 1000000000);\n    ensure(1 <= x && x <= 1000000);\n\n    vector<int> c(n);\n\n    if (type == \"maxci\") {\n        // Generate maximum ci\n        for (int i = 0; i < n; ++i) {\n            c[i] = 1000000;\n        }\n    } else if (type == \"minci\") {\n        // Generate minimum ci\n        for (int i = 0; i < n; ++i) {\n            c[i] = 1;\n        }\n    } else if (type == \"sameci\") {\n        // All ci are the same\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            c[i] = val;\n        }\n    } else if (type == \"ascending\") {\n        // ci are in ascending order\n        c[0] = rnd.next(1, 1000000 / n);\n        for (int i = 1; i < n; ++i) {\n            int increment = rnd.next(0, (1000000 - c[i - 1]) / (n - i));\n            c[i] = c[i - 1] + increment;\n        }\n    } else if (type == \"descending\") {\n        // ci are in descending order\n        c[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; ++i) {\n            int decrement = rnd.next(0, c[i - 1] / (n - i));\n            c[i] = c[i - 1] - decrement;\n        }\n    } else {\n        // Random ci between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, l, r, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int l = opt<int>(\"l\");\n    int r = opt<int>(\"r\");\n    int x = opt<int>(\"x\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    ensure(1 <= n && n <= 15);\n    ensure(1 <= l && l <= r && r <= 1000000000);\n    ensure(1 <= x && x <= 1000000);\n\n    vector<int> c(n);\n\n    if (type == \"maxci\") {\n        // Generate maximum ci\n        for (int i = 0; i < n; ++i) {\n            c[i] = 1000000;\n        }\n    } else if (type == \"minci\") {\n        // Generate minimum ci\n        for (int i = 0; i < n; ++i) {\n            c[i] = 1;\n        }\n    } else if (type == \"sameci\") {\n        // All ci are the same\n        int val = rnd.next(1, 1000000);\n        for (int i = 0; i < n; ++i) {\n            c[i] = val;\n        }\n    } else if (type == \"ascending\") {\n        // ci are in ascending order\n        c[0] = rnd.next(1, 1000000 / n);\n        for (int i = 1; i < n; ++i) {\n            int increment = rnd.next(0, (1000000 - c[i - 1]) / (n - i));\n            c[i] = c[i - 1] + increment;\n        }\n    } else if (type == \"descending\") {\n        // ci are in descending order\n        c[0] = rnd.next(1, 1000000);\n        for (int i = 1; i < n; ++i) {\n            int decrement = rnd.next(0, c[i - 1] / (n - i));\n            c[i] = c[i - 1] - decrement;\n        }\n    } else {\n        // Random ci between 1 and 1e6\n        for (int i = 0; i < n; ++i) {\n            c[i] = rnd.next(1, 1000000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, l, r, x);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", c[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random ci\n./gen -n 2 -l 1 -r 10 -x 1 -type random\n\n# n = 1, minimal n\n./gen -n 1 -l 1 -r 10 -x 1 -type random\n\n# Maximum n, random ci\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type random\n\n# l = r\n./gen -n 15 -l 500000000 -r 500000000 -x 500000 -type random\n\n# x minimal\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type random\n\n# x maximal\n./gen -n 15 -l 1 -r 1000000000 -x 1000000 -type random\n\n# ci minimal\n./gen -n 15 -l 1 -r 10 -x 1 -type minci\n\n# ci maximal\n./gen -n 15 -l 1000000000 -r 1000000000 -x 1000000 -type maxci\n\n# ci all same\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type sameci\n\n# ci ascending\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type ascending\n\n# ci descending\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type descending\n\n# l minimal\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type random\n\n# r minimal (l = r)\n./gen -n 15 -l 1 -r 1 -x 1 -type random\n\n# l and r maximal\n./gen -n 15 -l 1000000000 -r 1000000000 -x 1 -type random\n\n# x larger than any possible ci difference\n./gen -n 15 -l 1 -r 1000000000 -x 1000000 -type sameci\n\n# ci ranges from 1 to 1e6, random\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type random\n\n# l > sum(ci), no valid subsets\n./gen -n 15 -l 15000000 -r 16000000 -x 1 -type minci\n\n# x > ci_max - ci_min, no valid subsets\n./gen -n 15 -l 1 -r 1000000000 -x 1000000 -type minci\n\n# n small, ci random\n./gen -n 5 -l 1 -r 100 -x 1 -type random\n\n# n small, ci same\n./gen -n 5 -l 1 -r 1000000 -x 1 -type sameci\n\n# n small, l > sum(ci), no valid subsets\n./gen -n 5 -l 1000000 -r 1000000 -x 1 -type minci\n\n# n minimal (n=2)\n./gen -n 2 -l 1 -r 1000000 -x 1 -type random\n\n# n minimal, ci same\n./gen -n 2 -l 1 -r 1000000 -x 1 -type sameci\n\n# l = r = sum of all ci\n./gen -n 15 -l 15000000 -r 15000000 -x 1 -type maxci\n\n# l = 1, r = 1e9, x = 1e6, ci random\n./gen -n 15 -l 1 -r 1000000000 -x 1000000 -type random\n\n# ci has duplicates\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type random\n\n# ci all different\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type ascending\n\n# l = r = x\n./gen -n 15 -l 1000 -r 1000 -x 1000 -type random\n\n# l = r = x, ci all same\n./gen -n 15 -l 1000 -r 1000 -x 1000 -type sameci\n\n# Edge case: x equal to minimal possible difference\n./gen -n 15 -l 1 -r 1000000000 -x 1 -type random\n\n# Edge case: x equal to maximal possible difference\n./gen -n 15 -l 1 -r 1000000000 -x 999999 -type random\n\n# Edge case: l equal to sum of ci\n./gen -n 15 -l 15000000 -r 15000000 -x 1 -type maxci\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:36.230455",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "550/C",
      "title": "C. Divisibility by Eight",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains a non-negative integer n. The representation of number n doesn't contain any leading zeroes and its length doesn't exceed 100 digits.",
      "output_spec": "OutputPrint \"NO\" (without quotes), if there is no such way to remove some digits from number n. Otherwise, print \"YES\" in the first line and the resulting number after removing digits from number n in the second line. The printed number must be divisible by 8.If there are multiple possible answers, you may print any of them.",
      "sample_tests": "ExamplesInputCopy3454OutputCopyYES344InputCopy10OutputCopyYES0InputCopy111111OutputCopyNO",
      "description": "C. Divisibility by Eight\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe single line of the input contains a non-negative integer n. The representation of number n doesn't contain any leading zeroes and its length doesn't exceed 100 digits.\n\nOutputPrint \"NO\" (without quotes), if there is no such way to remove some digits from number n. Otherwise, print \"YES\" in the first line and the resulting number after removing digits from number n in the second line. The printed number must be divisible by 8.If there are multiple possible answers, you may print any of them.\n\nInputCopy3454OutputCopyYES344InputCopy10OutputCopyYES0InputCopy111111OutputCopyNO\n\nInputCopy3454\n\nOutputCopyYES344\n\nInputCopy10\n\nOutputCopyYES0\n\nInputCopy111111\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!We are glad to announce that on 4th of June at 19:30 MSK Codeforces Round #306 will be held. Authors of this contest are me (Adilet Zhaxybay) and Timur Sitdikov (Timur_Sitdikov). The round will be rated for the second division, however, participants from the first division can, as usually, participate in it unofficially.We want to thank all the people, who helped us to prepare the contest: Max Akhmedov (Zlobober), who helped us with the problems, Bekzhan Kassenov (BekzhanKassenov) and Sergey Lazarev (SergeyLazarev), who tested the round, and Maria Belova (Delinur), who translated problem statements. Also we want to say great thanks to Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon.By the way, as far as we know, Timur_Sitdikov is the first participant from Uzbekistan, who took part in the preparation of Codeforces round. We hope that everything will go well :) Good luck to all! UPD The scoring will be dynamicUPD2 Editorial can be found hereUPD3 Congratulations to winners! mff I_Love_Nodir.Daminov tun I_love_Ngoc_cmn_Thuy goodhope Round is over, thanks to everybody, who took part in it!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18303",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1141
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces",
          "content": "550A - Two SubstringsThere are many ways to solve this problem. Author solution does the following: check if substring \"AB\" goes before \"BA\", and then vice versa, if \"BA\" goes before \"AB\". You can do it in the following way: find the first occurence of \"AB\" then check all substrings of length two to the right of it to check if substring \"BA\" also exists. Then do it vice versa. Complexity of the solution is O(n), where n is the length of the given string.550B - Preparing OlympiadBecause of the low constraints, this problem can be solved by complete search over all problem sets (there are 2n of them).For every potential problem set (which can be conviniently expressed as bit mask) we need to check if it satisfies all needed criteria. We can simply find the sum of problem complexities and also the difference between the most difficult and the easiest problems in linear time, iterating over the problems that we included in our current set/bitmask. If this problem set can be used, we increase the answer by one.Complexity of this solution is O(2n·n).550C - Divisibility by EightThis problem can be solved with at least two different approaches. The first one is based on the \"school\" property of the divisibility by eight — number can be divided by eight if and only if its last three digits form a number that can be divided by eight. Thus, it is enough to test only numbers that can be obtained from the original one by crossing out and that contain at most three digits (so we check only all one-digit, two-digit and three-digit numbers). This can be done in O(len3) with three nested loops (here len is the length of the original number).Second approach uses dynamic programming. Let's calculate dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8. The value of dp is true if we can cross out some digits from the prefix of length i such that the remaining number gives j modulo eight, and false otherwise. This dp can be calculated in the following way: let ai be ith digit of the given number. Then dp[i][aimod8] = true (just this number). For all 0 ≤ j < 8 such that dp[i - 1][j] = true, dp[i][(j * 10 + ai)mod8] = true (we add current digit to some previous result), dp[i][j] = true (we cross out current digit). Answer is \"YES\" if dp[i][0] = true for some position i. For restoring the answer we need to keep additional array prev[i][j], which will say from where current value was calculated. Complexity of such solution is O(8·len) = O(len) (again len is the length of the original number).Code for DP solution: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Regular BridgeLet's prove that there is no solution for even k. Suppose our graph contains some bridges, k = 2s (even), all degrees are k. Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge. Consider this component. Let's remove bridge that connects it to the remaining graph. Then it has one vertex with degree k - 1 = 2s - 1 and some vertices with degrees k = 2s. But then the graph consisting of this component will contain only one vertex with odd degree, which is impossible by Handshaking Lemma. Let's construct the answer for odd k. Let k = 2s - 1.For k = 1 graph consisting of two nodes connected by edge works. For k ≥ 3 let's construct graph with 2k + 4 nodes. Let it consist of two strongly connected components connected by bridge. Enumerate nodes of first component from 1 to k + 2, second component will be the same as the first one.Let vertex 1 be connected to the second component by bridge. Also connect it with k - 1 edges to vertices 2, 3, ..., k. Connect vertices 2, 3, ..., k to each other (add all possible edges between them), and then remove edges between every neighbouring pair, for example edges 2 - 3, 4 - 5, ..., (k - 1) - k. Then we connect vertices 2, 3, ..., k with vertices k + 1 and k + 2. And finally add an edge between nodes k + 1 and k + 2. Build the second component in the similar manner, and add a bridge between components. Constructed graph has one bridge, all degrees of k and consists of O(k) nodes and O(k2) edges.Complexity of the solution — O(k2).550E - Brackets in ImplicationsLet input consists of , ai is 0 or 1 for all i.Let's show that there is no solution in only two cases:1) an = 1., for all x, and no parentheses can change last 1 to 0.2) Input has the form or its suffix with at least two arguments.This can be proven by induction. For input there is no solution, for longer inputs any attempt to put parentheses will decrease the number of 1s in the beginning by one, or will introduce 1 in the last position (which will lead to case one). Let's construct solution for all other cases.1) For input 0 we don't need to do anything.2) For input of the form we don't need any parentheses, the value of this expression is always 3) Expression in the form (where second missed part consists of ones only). Then .Complexity of the solution is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*C"
          },
          "content_length": 5853
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces",
          "content": "550A - Two SubstringsThere are many ways to solve this problem. Author solution does the following: check if substring \"AB\" goes before \"BA\", and then vice versa, if \"BA\" goes before \"AB\". You can do it in the following way: find the first occurence of \"AB\" then check all substrings of length two to the right of it to check if substring \"BA\" also exists. Then do it vice versa. Complexity of the solution is O(n), where n is the length of the given string.550B - Preparing OlympiadBecause of the low constraints, this problem can be solved by complete search over all problem sets (there are 2n of them).For every potential problem set (which can be conviniently expressed as bit mask) we need to check if it satisfies all needed criteria. We can simply find the sum of problem complexities and also the difference between the most difficult and the easiest problems in linear time, iterating over the problems that we included in our current set/bitmask. If this problem set can be used, we increase the answer by one.Complexity of this solution is O(2n·n).550C - Divisibility by EightThis problem can be solved with at least two different approaches. The first one is based on the \"school\" property of the divisibility by eight — number can be divided by eight if and only if its last three digits form a number that can be divided by eight. Thus, it is enough to test only numbers that can be obtained from the original one by crossing out and that contain at most three digits (so we check only all one-digit, two-digit and three-digit numbers). This can be done in O(len3) with three nested loops (here len is the length of the original number).Second approach uses dynamic programming. Let's calculate dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8. The value of dp is true if we can cross out some digits from the prefix of length i such that the remaining number gives j modulo eight, and false otherwise. This dp can be calculated in the following way: let ai be ith digit of the given number. Then dp[i][aimod8] = true (just this number). For all 0 ≤ j < 8 such that dp[i - 1][j] = true, dp[i][(j * 10 + ai)mod8] = true (we add current digit to some previous result), dp[i][j] = true (we cross out current digit). Answer is \"YES\" if dp[i][0] = true for some position i. For restoring the answer we need to keep additional array prev[i][j], which will say from where current value was calculated. Complexity of such solution is O(8·len) = O(len) (again len is the length of the original number).Code for DP solution: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Regular BridgeLet's prove that there is no solution for even k. Suppose our graph contains some bridges, k = 2s (even), all degrees are k. Then there always exists strongly connected component that is connected to other part of the graph with exactly one bridge. Consider this component. Let's remove bridge that connects it to the remaining graph. Then it has one vertex with degree k - 1 = 2s - 1 and some vertices with degrees k = 2s. But then the graph consisting of this component will contain only one vertex with odd degree, which is impossible by Handshaking Lemma. Let's construct the answer for odd k. Let k = 2s - 1.For k = 1 graph consisting of two nodes connected by edge works. For k ≥ 3 let's construct graph with 2k + 4 nodes. Let it consist of two strongly connected components connected by bridge. Enumerate nodes of first component from 1 to k + 2, second component will be the same as the first one.Let vertex 1 be connected to the second component by bridge. Also connect it with k - 1 edges to vertices 2, 3, ..., k. Connect vertices 2, 3, ..., k to each other (add all possible edges between them), and then remove edges between every neighbouring pair, for example edges 2 - 3, 4 - 5, ..., (k - 1) - k. Then we connect vertices 2, 3, ..., k with vertices k + 1 and k + 2. And finally add an edge between nodes k + 1 and k + 2. Build the second component in the similar manner, and add a bridge between components. Constructed graph has one bridge, all degrees of k and consists of O(k) nodes and O(k2) edges.Complexity of the solution — O(k2).550E - Brackets in ImplicationsLet input consists of , ai is 0 or 1 for all i.Let's show that there is no solution in only two cases:1) an = 1., for all x, and no parentheses can change last 1 to 0.2) Input has the form or its suffix with at least two arguments.This can be proven by induction. For input there is no solution, for longer inputs any attempt to put parentheses will decrease the number of 1s in the beginning by one, or will introduce 1 in the last position (which will lead to case one). Let's construct solution for all other cases.1) For input 0 we don't need to do anything.2) For input of the form we don't need any parentheses, the value of this expression is always 3) Expression in the form (where second missed part consists of ones only). Then .Complexity of the solution is O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*C"
          },
          "content_length": 5853
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "string temp=std::to_string(i);\n\n                     ^",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "#define endl \"\\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) Editorial - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string n_str = inf.readToken(\"[0-9]{1,100}\", \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Check that n_str does not contain leading zeroes (unless it's \"0\")\n    if (n_str.length() > 1) {\n        ensuref(n_str[0] != '0', \"n should not contain leading zeroes\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string n_str = inf.readToken(\"[0-9]{1,100}\", \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Check that n_str does not contain leading zeroes (unless it's \"0\")\n    if (n_str.length() > 1) {\n        ensuref(n_str[0] != '0', \"n should not contain leading zeroes\");\n    }\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string n_str = inf.readToken(\"[0-9]{1,100}\", \"n\");\n    inf.readEoln();\n    inf.readEof();\n\n    // Check that n_str does not contain leading zeroes (unless it's \"0\")\n    if (n_str.length() > 1) {\n        ensuref(n_str[0] != '0', \"n should not contain leading zeroes\");\n    }\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Checks whether s is a valid subnumber according to the problem conditions\nbool isValidSubnumber(const string& s, const string& n) {\n    if (s.empty())\n        return false;\n\n    for (char c : s) {\n        if (!isdigit(c))\n            return false;\n    }\n\n    if (s == \"0\") {\n        return n.find('0') != string::npos;\n    }\n\n    if (s[0] == '0')\n        return false;\n\n    int rem = 0;\n    for (char c : s) {\n        rem = (rem * 10 + (c - '0')) % 8;\n    }\n    return rem == 0;\n}\n\n// Checks if m is a subsequence of n\nbool isSubsequence(const string& m, const string& n) {\n    int idx = 0;\n    for (char c : n) {\n        if (idx < m.size() && c == m[idx]) {\n            idx++;\n        }\n    }\n    return idx == m.size();\n}\n\n// Validates the contestant's number m\nbool isValidNumber(const string& n, const string& m) {\n    if (m.empty())\n        return false;\n\n    for (char c : m) {\n        if (!isdigit(c))\n            return false;\n    }\n\n    if (m == \"0\") {\n        return n.find('0') != string::npos;\n    }\n\n    if (m[0] == '0')\n        return false;\n\n    if (!isSubsequence(m, n))\n        return false;\n\n    int rem = 0;\n    for (char c : m) {\n        rem = (rem * 10 + (c - '0')) % 8;\n    }\n    return rem == 0;\n}\n\n// Checks whether a valid number exists that can be formed from n\nbool existsValidNumber(const string& n) {\n    int len = n.length();\n\n    // Subsequence of length 1\n    for (int i = 0; i < len; i++) {\n        string s(1, n[i]);\n        if (isValidSubnumber(s, n))\n            return true;\n    }\n\n    // Subsequence of length 2\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            string s;\n            s.push_back(n[i]);\n            s.push_back(n[j]);\n            if (isValidSubnumber(s, n))\n                return true;\n        }\n    }\n\n    // Subsequence of length 3\n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            for (int k = j + 1; k < len; k++) {\n                string s;\n                s.push_back(n[i]);\n                s.push_back(n[j]);\n                s.push_back(n[k]);\n                if (isValidSubnumber(s, n))\n                    return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    string n = inf.readToken(); // Read the original number from the input file\n\n    string first_token = lowerCase(ouf.readToken()); // Read the contestant's first token\n\n    if (first_token == \"no\") {\n        if (existsValidNumber(n)) {\n            quitf(_wa, \"A solution exists, but contestant outputs 'NO'\");\n        } else {\n            quitf(_ok, \"Correct: No solution exists\");\n        }\n    } else if (first_token == \"yes\") {\n        if (ouf.eof())\n            quitf(_wa, \"Expected number after 'YES', but found EOF\");\n\n        string m = ouf.readToken(); // Read the number output by the contestant\n\n        if (!isValidNumber(n, m)) {\n            quitf(_wa, \"Invalid number output: %s\", m.c_str());\n        } else {\n            quitf(_ok, \"Correct\");\n        }\n    } else {\n        quitf(_wa, \"Expected 'YES' or 'NO', found '%s'\", first_token.c_str());\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n    string n;\n\n    if (type == \"zero\") {\n        n = \"0\";\n    } else if (type == \"ones\") {\n        n = string(len, '1');\n    } else if (type == \"nines\") {\n        n = string(len, '9');\n    } else if (type == \"eights\") {\n        n = string(len, '8');\n    } else if (type == \"random\") {\n        n = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (i == 0)\n                n += char('1' + rnd.next(9)); // First digit cannot be zero\n            else\n                n += char('0' + rnd.next(10));\n        }\n    } else if (type == \"random_div8\") {\n        if (len >= 3) {\n            for (int i = 0; i < len - 3; ++i) {\n                if (i == 0)\n                    n += char('1' + rnd.next(9));\n                else\n                    n += char('0' + rnd.next(10));\n            }\n            int last_three = rnd.next(0, 999 / 8) * 8;\n            char buf[4];\n            sprintf(buf, \"%03d\", last_three);\n            n += buf;\n        } else if (len == 2) {\n            vector<int> options;\n            for (int i = 16; i <= 96; i += 8) {\n                options.push_back(i);\n            }\n            int num = options[rnd.next(options.size())];\n            char buf[3];\n            sprintf(buf, \"%02d\", num);\n            n = buf;\n        } else if (len == 1) {\n            vector<int> options = {0, 8};\n            n = char('0' + options[rnd.next(options.size())]);\n            if (n == \"0\") n = \"8\"; // Ensure no leading zero in input\n        }\n    } else if (type == \"impossible\") {\n        n = string(len, '1');\n    } else if (type == \"leading_zero_potential\") {\n        if (len >= 2) {\n            n = \"1\" + string(len - 1, '0');\n        } else {\n            n = \"10\";\n        }\n    } else {\n        // Default to random\n        n = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (i == 0)\n                n += char('1' + rnd.next(9));\n            else\n                n += char('0' + rnd.next(10));\n        }\n    }\n\n    // Ensure that the number has no leading zeros and length is correct\n    if (n.length() > 100) {\n        n = n.substr(0, 100);\n    }\n    if (n[0] == '0') {\n        n[0] = '1';\n    }\n\n    cout << n << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n    string n;\n\n    if (type == \"zero\") {\n        n = \"0\";\n    } else if (type == \"ones\") {\n        n = string(len, '1');\n    } else if (type == \"nines\") {\n        n = string(len, '9');\n    } else if (type == \"eights\") {\n        n = string(len, '8');\n    } else if (type == \"random\") {\n        n = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (i == 0)\n                n += char('1' + rnd.next(9)); // First digit cannot be zero\n            else\n                n += char('0' + rnd.next(10));\n        }\n    } else if (type == \"random_div8\") {\n        if (len >= 3) {\n            for (int i = 0; i < len - 3; ++i) {\n                if (i == 0)\n                    n += char('1' + rnd.next(9));\n                else\n                    n += char('0' + rnd.next(10));\n            }\n            int last_three = rnd.next(0, 999 / 8) * 8;\n            char buf[4];\n            sprintf(buf, \"%03d\", last_three);\n            n += buf;\n        } else if (len == 2) {\n            vector<int> options;\n            for (int i = 16; i <= 96; i += 8) {\n                options.push_back(i);\n            }\n            int num = options[rnd.next(options.size())];\n            char buf[3];\n            sprintf(buf, \"%02d\", num);\n            n = buf;\n        } else if (len == 1) {\n            vector<int> options = {0, 8};\n            n = char('0' + options[rnd.next(options.size())]);\n            if (n == \"0\") n = \"8\"; // Ensure no leading zero in input\n        }\n    } else if (type == \"impossible\") {\n        n = string(len, '1');\n    } else if (type == \"leading_zero_potential\") {\n        if (len >= 2) {\n            n = \"1\" + string(len - 1, '0');\n        } else {\n            n = \"10\";\n        }\n    } else {\n        // Default to random\n        n = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (i == 0)\n                n += char('1' + rnd.next(9));\n            else\n                n += char('0' + rnd.next(10));\n        }\n    }\n\n    // Ensure that the number has no leading zeros and length is correct\n    if (n.length() > 100) {\n        n = n.substr(0, 100);\n    }\n    if (n[0] == '0') {\n        n[0] = '1';\n    }\n\n    cout << n << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Zero length test case\n./gen -len 1 -type zero\n\n# Single-digit numbers\n./gen -len 1 -type ones\n./gen -len 1 -type nines\n./gen -len 1 -type eights\n./gen -len 1 -type random\n./gen -len 1 -type random_div8\n./gen -len 1 -type impossible\n./gen -len 1 -type leading_zero_potential\n\n# Two-digit numbers\n./gen -len 2 -type ones\n./gen -len 2 -type nines\n./gen -len 2 -type eights\n./gen -len 2 -type random\n./gen -len 2 -type random_div8\n./gen -len 2 -type impossible\n./gen -len 2 -type leading_zero_potential\n\n# Three-digit numbers\n./gen -len 3 -type ones\n./gen -len 3 -type nines\n./gen -len 3 -type eights\n./gen -len 3 -type random\n./gen -len 3 -type random_div8\n./gen -len 3 -type impossible\n./gen -len 3 -type leading_zero_potential\n\n# Ten-digit numbers\n./gen -len 10 -type random\n./gen -len 10 -type random_div8\n./gen -len 10 -type impossible\n./gen -len 10 -type leading_zero_potential\n\n# Fifty-digit numbers\n./gen -len 50 -type random\n./gen -len 50 -type random_div8\n./gen -len 50 -type impossible\n./gen -len 50 -type leading_zero_potential\n\n# Maximum length numbers (100 digits)\n./gen -len 100 -type ones\n./gen -len 100 -type nines\n./gen -len 100 -type eights\n./gen -len 100 -type random\n./gen -len 100 -type random_div8\n./gen -len 100 -type impossible\n./gen -len 100 -type leading_zero_potential\n\n# Additional random cases\n./gen -len 7 -type random\n./gen -len 7 -type random_div8\n./gen -len 7 -type impossible\n./gen -len 7 -type leading_zero_potential\n\n./gen -len 20 -type random\n./gen -len 20 -type random_div8\n./gen -len 20 -type impossible\n./gen -len 20 -type leading_zero_potential\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:38.366233",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "550/D",
      "title": "D. Регулярный мост",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке входных данных содержится целое число k (1 ≤ k ≤ 100) — требуемая степень вершин регулярного графа.",
      "output_spec": "Выходные данныеВыведите \"NO\" (без кавычек), если искомого графа не существует. Иначе выведите \"YES\" в первой строке и описание любого подходящего графа в последующих строках.Описание построенного графа должно начинаться с чисел n и m — количества вершин и ребер соответственно. Последующие m строк должны содержать по два целых числа a и b (1 ≤ a, b ≤ n, a ≠ b), означающих, что существует ребро, соединяющее данные вершины. Граф не должен содержать кратных ребер, а также ребер, ведущих из вершины в саму себя. Граф должен быть связным, степени всех вершин графа должны равняться k. Хотя бы одно ребро графа должно быть мостом. Ребра графа можно выводить в любом порядке. Концы каждого ребра можно выводить в любом порядке.Построенный граф должен содержать не более 106 вершин и не более 106 ребер (гарантируется что, если хотя бы один граф, удовлетворяющий требованиям, существует, то существует и граф с не более, чем 106 вершин и не более, чем 106 рёбер).",
      "sample_tests": "ПримерыВходные данныеСкопировать1Выходные данныеСкопироватьYES2 11 2",
      "description": "D. Регулярный мост\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке входных данных содержится целое число k (1 ≤ k ≤ 100) — требуемая степень вершин регулярного графа.\n\nВходные данные\n\nВыходные данныеВыведите \"NO\" (без кавычек), если искомого графа не существует. Иначе выведите \"YES\" в первой строке и описание любого подходящего графа в последующих строках.Описание построенного графа должно начинаться с чисел n и m — количества вершин и ребер соответственно. Последующие m строк должны содержать по два целых числа a и b (1 ≤ a, b ≤ n, a ≠ b), означающих, что существует ребро, соединяющее данные вершины. Граф не должен содержать кратных ребер, а также ребер, ведущих из вершины в саму себя. Граф должен быть связным, степени всех вершин графа должны равняться k. Хотя бы одно ребро графа должно быть мостом. Ребра графа можно выводить в любом порядке. Концы каждого ребра можно выводить в любом порядке.Построенный граф должен содержать не более 106 вершин и не более 106 ребер (гарантируется что, если хотя бы один граф, удовлетворяющий требованиям, существует, то существует и граф с не более, чем 106 вершин и не более, чем 106 рёбер).\n\nВыходные данные\n\nВходные данныеСкопировать1Выходные данныеСкопироватьYES2 11 2\n\nВходные данныеСкопировать1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES2 11 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ примере из условия подходит граф из двух вершин, соединенных единственным ребром.",
      "solutions": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!Мы рады сообщить, что 4 июня в 19:30 MSK состоится раунд Codeforces #306, авторами которого являюсь я (Адилет Жаксыбай), и Тимур Сытдыков (Timur_Sitdikov). Раунд будет рейтинговым для участников второго дивизиона, участники первого дивизиона могут, как обычно, поучаствовать в нем вне конкурса. Хочется выразить благодарность всем тем, кто помог нам с подготовкой раунда: Максиму Ахмедову (Zlobober), который помог нам с подготовкой задач, Бекжану Касенову (BekzhanKassenov) и Сергею Лазареву (SergeyLazarev), протестировавшим контест, и Марии Беловой (Delinur), которая перевела условия на английский язык. Отдельное спасибо Михаилу Мирзаянову (MikeMirzayanov) за создание платформ Codeforces и Polygon.Кстати, насколько нам известно, Timur_Sitdikov — первый участник с Узбекистана, принявший участие в подготовке Codeforces раунда. Мы надеемся, что все пройдет хорошо :)Всем удачи!UPD Разбалловка будет динамической.UPD2 Разбор можно найти здесь.UPD3 Поздравляем победителей: mff I_Love_Nodir.Daminov tun I_love_Ngoc_cmn_Thuy goodhope Раунд закончен, спасибо всем, кто принял участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18303",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1105
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "550A - Две подстрокиЗадачу можно решать разными способами. Авторское решение такое: проверим две возможности — когда подстрока \"AB\" идет первее \"BA\" и наоборот. Проверять можно следующим образом: найти самое первое вхождение \"AB\" в исходной строке и рассмотреть подстроки длины 2 правее. Если среди них встретилась подстрока \"BA\" — ответ \"YES\". Аналогично проверяется второй случай. Если оба варианта не выполнены, ответ \"NO\". Сложность решения — O(n), где n — длина исходной строки. 550B - Подготовка олимпиадыЗадачу можно решить полным перебором всех подмножеств задач (всего 2n подмножеств). Для каждого из подмножеств проверим, удовлетворяет ли оно условиям задачи. Найдем сумму сложностей всех задач, входящих в подмножество, и убедимся, что она лежит в отрезке [l, r]. Найдем также разность между сложностями максимально сложной задачи и минимально сложной задача подмножества и убедимся, что она не менее x. Если подмножество задач удовлетворяет условиям — увеличиваем общий ответ на 1. Сложность решения задачи — O(2n·n). 550C - Делимость на восемьЗадачу можно решить как минимум двумя способами. Первый — через \"школьный\" признак делимости на 8 (число делится на 8 тогда и только тогда, когда число, образованное его последними тремя цифрами, делится на 8). Таким образом, достаточно проверять на делимость на 8 все однозначные, двухзначные и трехзначные числа, образуемые из исходного вычеркиванием цифр. Это можно сделать за O(n3) вложенными циклами по цифрам числа, где n — количество цифр числа.Второй способ использует динамическое программирование. Будем считать величину dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8 — величину, равную 1, если из префикса числа длиной i цифр можно вычеркнуть несколько цифр так, что остаток от деления полученного числа на 8 равен j, и 0 в противном случае. Формулы для пересчета: пусть i-я цифра числа есть ai, тогда dp[i][aimod8] = 1 (по смыслу — однозначные числа), dp[i][(j * 10 + ai)mod8] = max(dp[i][(j * 10 + ai)mod8], dp[i - 1][j]) (по смыслу — дописывание текущей цифры), dp[i][j] = max(dp[i][j], dp[i - 1][j]) (по смыслу — вычеркивание текущей цифры), где 0 ≤ j < 8. Ответ \"YES\" будет в том случае, когда для некоторого i выполнено dp[i][0] = 1. Для восстановления ответа также нужно завести дополнительный массив prev[i][j], который будет хранить индекс k такой, что при подсчете dp[i][j] пересчет был сделан из dp[i - 1][k]. Сложность такого решения — O(8·n).Решение с динамическим программированием: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Регулярный мостДокажем, что если k — четное, то решения не существует. Пусть наш граф содержит мост(ы), k = 2s — четное число, степени всех вершин графа равны k. Дерево двусвязных (реберно двусвязных, далее слово \"реберных\" будет опущено для краткости) компонент исходного графа содержало компоненту, связанную с остальной частью графа только одним мостом (не несколькими мостами!) (на самом деле таких компонент как минимум две, но нам достаточно одной).Рассмотрим эту компоненту. Удалим мост, связывающий ее с остальной частью графа. Тогда в ней будет всего одна вершина степени k - 1 = 2s - 1 и какое-то количество вершин степени k = 2s. Но тогда она будет содержать только одну вершину нечетной степени, что невозможно.Построим такой граф для нечетных k. Пусть k = 2s - 1 — нечетное число. Рассмотрим отдельно случай k = 1, тогда, очевидно, подойдет дерево из двух вершин.Для k ≥ 3 сперва найдем минимальное количество вершин искомого графа. Граф будет содержать как минимум один мост и как минимум две двусвязные компоненты, связанные с остальной частью графа одним мостом. Каждая из этих компонент содержит не менее k + 2 вершин (так как одна вершина связана k - 1 ребрами с другими, остальные имеют степень k = 2s - 1 — нечетное число, т.. количество этих вершин должно быть четным, в то же время оно не может быть меньше k = 2s - 1, то есть оно будет не меньше k + 1, что в сумме с одной вершиной степени k - 1 даст k + 2).Следовательно, во всем графе будет не менее 2k + 4 вершин. Построим граф с таким количеством вершин. Занумеруем вершины первой компоненты с 1 до k + 2, вторую компоненту построим аналогично первой. Пусть вершина 1 связана мостом с второй компонентой. Соединим ее k - 1 ребрами с вершинами 2, 3, ..., k. Вершины с номерами 2, 3, ..., k соединим между собой попарно и потом между каждой соседней парой, например 2 - 3, 4 - 5, ... (k - 1) - k, выкинем ребро. После соединим вершины 2, 3, ..., k с вершинами k + 1 и k + 2. Также соединим вершины k + 1 и k + 2 между собой. Тогда все вершины компоненты, кроме первой, будут иметь степень k. Точно так же создаем вторую компоненту и соединяем мостом с первой. Искомый граф построен и содержит O(k) вершин и O(k2) ребер. Асимптотика решения — O(k2).550E - Скобки в импликацияхПусть дано выражение , ai — 0 или 1 для всех i.Покажем, что решения нет только в двух случаях.1) an = 1.Это следует из того, что , т. е. никакая расстановка скобок не сможет заменить самую правую 1 выражения на 0.2) Выражение имеет вид или является его суффиксом, содержащим не менее 2 аргументов.Это несложно доказать индукцией. Для суффикса невозможность расстановки скобок очевидна, для более длинных суффиксов любая свертка импликаций либо приведет к тому, что справа появится 1, либо уменьшит число единиц в выражении на 1.Покажем, что в остальных случаях решение есть.1) Для выражения 0 ничего делать не надо — ответ 0.2) Выражение вида . Можно не расставлять никаких скобок, так как значение такого выражения без скобок равно 0.3) Выражение вида , где вторая опущенная часть состоит только из единиц. Тогда .Асимптотика: O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*D"
          },
          "content_length": 6500
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "550A - Две подстрокиЗадачу можно решать разными способами. Авторское решение такое: проверим две возможности — когда подстрока \"AB\" идет первее \"BA\" и наоборот. Проверять можно следующим образом: найти самое первое вхождение \"AB\" в исходной строке и рассмотреть подстроки длины 2 правее. Если среди них встретилась подстрока \"BA\" — ответ \"YES\". Аналогично проверяется второй случай. Если оба варианта не выполнены, ответ \"NO\". Сложность решения — O(n), где n — длина исходной строки. 550B - Подготовка олимпиадыЗадачу можно решить полным перебором всех подмножеств задач (всего 2n подмножеств). Для каждого из подмножеств проверим, удовлетворяет ли оно условиям задачи. Найдем сумму сложностей всех задач, входящих в подмножество, и убедимся, что она лежит в отрезке [l, r]. Найдем также разность между сложностями максимально сложной задачи и минимально сложной задача подмножества и убедимся, что она не менее x. Если подмножество задач удовлетворяет условиям — увеличиваем общий ответ на 1. Сложность решения задачи — O(2n·n). 550C - Делимость на восемьЗадачу можно решить как минимум двумя способами. Первый — через \"школьный\" признак делимости на 8 (число делится на 8 тогда и только тогда, когда число, образованное его последними тремя цифрами, делится на 8). Таким образом, достаточно проверять на делимость на 8 все однозначные, двухзначные и трехзначные числа, образуемые из исходного вычеркиванием цифр. Это можно сделать за O(n3) вложенными циклами по цифрам числа, где n — количество цифр числа.Второй способ использует динамическое программирование. Будем считать величину dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8 — величину, равную 1, если из префикса числа длиной i цифр можно вычеркнуть несколько цифр так, что остаток от деления полученного числа на 8 равен j, и 0 в противном случае. Формулы для пересчета: пусть i-я цифра числа есть ai, тогда dp[i][aimod8] = 1 (по смыслу — однозначные числа), dp[i][(j * 10 + ai)mod8] = max(dp[i][(j * 10 + ai)mod8], dp[i - 1][j]) (по смыслу — дописывание текущей цифры), dp[i][j] = max(dp[i][j], dp[i - 1][j]) (по смыслу — вычеркивание текущей цифры), где 0 ≤ j < 8. Ответ \"YES\" будет в том случае, когда для некоторого i выполнено dp[i][0] = 1. Для восстановления ответа также нужно завести дополнительный массив prev[i][j], который будет хранить индекс k такой, что при подсчете dp[i][j] пересчет был сделан из dp[i - 1][k]. Сложность такого решения — O(8·n).Решение с динамическим программированием: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Регулярный мостДокажем, что если k — четное, то решения не существует. Пусть наш граф содержит мост(ы), k = 2s — четное число, степени всех вершин графа равны k. Дерево двусвязных (реберно двусвязных, далее слово \"реберных\" будет опущено для краткости) компонент исходного графа содержало компоненту, связанную с остальной частью графа только одним мостом (не несколькими мостами!) (на самом деле таких компонент как минимум две, но нам достаточно одной).Рассмотрим эту компоненту. Удалим мост, связывающий ее с остальной частью графа. Тогда в ней будет всего одна вершина степени k - 1 = 2s - 1 и какое-то количество вершин степени k = 2s. Но тогда она будет содержать только одну вершину нечетной степени, что невозможно.Построим такой граф для нечетных k. Пусть k = 2s - 1 — нечетное число. Рассмотрим отдельно случай k = 1, тогда, очевидно, подойдет дерево из двух вершин.Для k ≥ 3 сперва найдем минимальное количество вершин искомого графа. Граф будет содержать как минимум один мост и как минимум две двусвязные компоненты, связанные с остальной частью графа одним мостом. Каждая из этих компонент содержит не менее k + 2 вершин (так как одна вершина связана k - 1 ребрами с другими, остальные имеют степень k = 2s - 1 — нечетное число, т.. количество этих вершин должно быть четным, в то же время оно не может быть меньше k = 2s - 1, то есть оно будет не меньше k + 1, что в сумме с одной вершиной степени k - 1 даст k + 2).Следовательно, во всем графе будет не менее 2k + 4 вершин. Построим граф с таким количеством вершин. Занумеруем вершины первой компоненты с 1 до k + 2, вторую компоненту построим аналогично первой. Пусть вершина 1 связана мостом с второй компонентой. Соединим ее k - 1 ребрами с вершинами 2, 3, ..., k. Вершины с номерами 2, 3, ..., k соединим между собой попарно и потом между каждой соседней парой, например 2 - 3, 4 - 5, ... (k - 1) - k, выкинем ребро. После соединим вершины 2, 3, ..., k с вершинами k + 1 и k + 2. Также соединим вершины k + 1 и k + 2 между собой. Тогда все вершины компоненты, кроме первой, будут иметь степень k. Точно так же создаем вторую компоненту и соединяем мостом с первой. Искомый граф построен и содержит O(k) вершин и O(k2) ребер. Асимптотика решения — O(k2).550E - Скобки в импликацияхПусть дано выражение , ai — 0 или 1 для всех i.Покажем, что решения нет только в двух случаях.1) an = 1.Это следует из того, что , т. е. никакая расстановка скобок не сможет заменить самую правую 1 выражения на 0.2) Выражение имеет вид или является его суффиксом, содержащим не менее 2 аргументов.Это несложно доказать индукцией. Для суффикса невозможность расстановки скобок очевидна, для более длинных суффиксов любая свертка импликаций либо приведет к тому, что справа появится 1, либо уменьшит число единиц в выражении на 1.Покажем, что в остальных случаях решение есть.1) Для выражения 0 ничего делать не надо — ответ 0.2) Выражение вида . Можно не расставлять никаких скобок, так как значение такого выражения без скобок равно 0.3) Выражение вида , где вторая опущенная часть состоит только из единиц. Тогда .Асимптотика: O(n).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*D"
          },
          "content_length": 6500
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "string temp=std::to_string(i);\n\n                     ^",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "#define endl \"\\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1e6 + 5;\n\nint k;\nstring ansResult, oufResult;\n\nint n, m;\nvector<int> adj[MAX_N];\nint degree[MAX_N];\nbool visited[MAX_N];\n\nset<pair<int, int>> edgeSet;\nvector<pair<int, int>> edges;\n\nint timer;\nvector<int> tin, low;\nbool foundBridge;\n\nvoid dfsBridge(int v, int p = -1) {\n    visited[v] = true;\n    tin[v] = low[v] = timer++;\n    for (int to : adj[v]) {\n        if (to == p) continue;\n        if (visited[to]) {\n            low[v] = min(low[v], tin[to]);\n        } else {\n            dfsBridge(to, v);\n            low[v] = min(low[v], low[to]);\n            if (low[to] > tin[v]) {\n                foundBridge = true;\n            }\n        }\n    }\n}\n\nvoid dfs(int v) {\n    visited[v] = true;\n    for (int to : adj[v]) {\n        if (!visited[to]) {\n            dfs(to);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    k = inf.readInt(1, 100, \"k\");\n\n    ansResult = ans.readToken();\n    oufResult = ouf.readToken();\n\n    if (ansResult != \"YES\" && ansResult != \"NO\") {\n        quitf(_fail, \"Jury answer is neither YES nor NO\");\n    }\n    if (oufResult != \"YES\" && oufResult != \"NO\") {\n        quitf(_wa, \"Participant's output is neither YES nor NO\");\n    }\n\n    if (ansResult == \"NO\") {\n        if (oufResult != \"NO\") {\n            quitf(_wa, \"Participant outputs YES while the correct answer is NO\");\n        } else {\n            quitf(_ok, \"Correct output NO\");\n        }\n    } else {\n        if (oufResult == \"NO\") {\n            quitf(_wa, \"Participant outputs NO while a valid graph exists\");\n        } else {\n            // Participant outputs YES; read and check the graph\n            n = ouf.readInt(1, 1000000, \"n\");\n            m = ouf.readInt(0, 1000000, \"m\");\n\n            memset(degree, 0, sizeof(int) * (n + 1));\n            for (int i = 1; i <= n; i++) {\n                adj[i].clear();\n            }\n            edgeSet.clear();\n            edges.clear();\n\n            for (int i = 0; i < m; i++) {\n                int a = ouf.readInt(1, n, \"a_i\");\n                int b = ouf.readInt(1, n, \"b_i\");\n                if (a == b) {\n                    quitf(_wa, \"Self-loop detected at node %d\", a);\n                }\n                int u = min(a, b);\n                int v = max(a, b);\n                if (edgeSet.count({u, v})) {\n                    quitf(_wa, \"Multiple edges between %d and %d\", u, v);\n                }\n                edgeSet.insert({u, v});\n                edges.push_back({a, b});\n                degree[a]++;\n                degree[b]++;\n                adj[a].push_back(b);\n                adj[b].push_back(a);\n            }\n\n            // Check degrees\n            for (int i = 1; i <= n; i++) {\n                if (degree[i] != k) {\n                    quitf(_wa, \"Degree of vertex %d is %d, expected %d\", i, degree[i], k);\n                }\n            }\n\n            // Check connectedness\n            memset(visited, 0, sizeof(bool) * (n + 1));\n            dfs(1);\n            for (int i = 1; i <= n; i++) {\n                if (!visited[i]) {\n                    quitf(_wa, \"Graph is not connected\");\n                }\n            }\n\n            // Check for at least one bridge\n            foundBridge = false;\n            timer = 0;\n            tin.assign(n + 1, -1);\n            low.assign(n + 1, -1);\n            memset(visited, 0, sizeof(bool) * (n + 1));\n            dfsBridge(1);\n            if (!foundBridge) {\n                quitf(_wa, \"No bridge found in the graph\");\n            }\n\n            // Ensure no extra tokens\n            if (!ouf.seekEof()) {\n                quitf(_wa, \"Extra tokens in participant's output\");\n            }\n\n            quitf(_ok, \"Participant outputs a valid graph\");\n        }\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k;\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        k = 1; // Minimum possible value of k\n    } else if (type == \"max\") {\n        k = 100; // Maximum possible value of k\n    } else if (type == \"even\") {\n        k = rnd.next(1, 50) * 2; // Generate a random even k between 2 and 100\n    } else if (type == \"odd\") {\n        k = rnd.next(1, 49) * 2 + 1; // Generate a random odd k between 3 and 99\n    } else if (type == \"k\") {\n        k = opt<int>(\"k\", 1); // Use the specified value of k\n    } else if (type == \"random\") {\n        k = rnd.next(1, 100); // Generate a random k between 1 and 100\n    } else {\n        k = 1; // Default value\n    }\n\n    // Output the value of k\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k;\n\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min\") {\n        k = 1; // Minimum possible value of k\n    } else if (type == \"max\") {\n        k = 100; // Maximum possible value of k\n    } else if (type == \"even\") {\n        k = rnd.next(1, 50) * 2; // Generate a random even k between 2 and 100\n    } else if (type == \"odd\") {\n        k = rnd.next(1, 49) * 2 + 1; // Generate a random odd k between 3 and 99\n    } else if (type == \"k\") {\n        k = opt<int>(\"k\", 1); // Use the specified value of k\n    } else if (type == \"random\") {\n        k = rnd.next(1, 100); // Generate a random k between 1 and 100\n    } else {\n        k = 1; // Default value\n    }\n\n    // Output the value of k\n    printf(\"%d\\n\", k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Testing minimum and maximum values of k\n./gen -type min        # k = 1\n./gen -type max        # k = 100\n\n# Testing specific even values of k\n./gen -type k -k 2     # k = 2 (Known to output \"NO\")\n./gen -type k -k 4     # k = 4\n./gen -type k -k 6     # k = 6\n./gen -type k -k 8     # k = 8\n./gen -type k -k 10    # k = 10\n./gen -type k -k 50    # k = 50\n./gen -type k -k 100   # k = 100\n\n# Testing specific odd values of k\n./gen -type k -k 1     # k = 1 (Edge case)\n./gen -type k -k 3     # k = 3\n./gen -type k -k 5     # k = 5\n./gen -type k -k 7     # k = 7\n./gen -type k -k 9     # k = 9\n./gen -type k -k 99    # k = 99\n\n# Testing random even values of k\n./gen -type even\n./gen -type even\n./gen -type even\n./gen -type even\n./gen -type even\n\n# Testing random odd values of k\n./gen -type odd\n./gen -type odd\n./gen -type odd\n./gen -type odd\n./gen -type odd\n\n# Testing multiple random values of k\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:40.635748",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "550/E",
      "title": "E. Скобки в импликациях",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 100000) — количество аргументов в логическом выражении.Вторая строка содержит n чисел a1, a2, ..., an (), обозначающих значения аргументов в выражении в порядке следования.",
      "output_spec": "Выходные данныеВыведите \"NO\" (без кавычек), если расставить в выражении скобки так, чтобы его значение равнялось 0, невозможно.Иначе выведите \"YES\" в первой строке и логическое выражение с нужной расстановкой скобок во второй строке.Выражение должно содержать только символы '0', '1', '-' (символ с ASCII кодом 45), '>' (символ с ASCII кодом 62), '(' и ')'. Символы '-' и '>' могут встречаться в выражении только в паре (\"->\") и обозначают импликацию. Суммарное количество логических аргументов (т. е. цифр '0' и '1') в выражении должно равняться n. Порядок следования цифр в выражении слева направо должен совпадать с a1, a2, ..., an.Выражение должно быть правильным. Более формально, правильное выражение определяется следующим образом:  Выражения \"0\", \"1\" (без кавычек) — правильные.  Если v1, v2 — правильные выражения, то v1->v2 — правильное выражение.  Если v — правильное выражение, то (v) — правильное выражение. Общее количество символов в полученном выражении не должно превысить 106.Если возможных ответов несколько, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать40 1 1 0Выходные данныеСкопироватьYES(((0)->1)->(1->0))Входные данныеСкопировать21 1Выходные данныеСкопироватьNOВходные данныеСкопировать10Выходные данныеСкопироватьYES0",
      "description": "E. Скобки в импликациях\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 100000) — количество аргументов в логическом выражении.Вторая строка содержит n чисел a1, a2, ..., an (), обозначающих значения аргументов в выражении в порядке следования.\n\nВходные данные\n\nВыходные данныеВыведите \"NO\" (без кавычек), если расставить в выражении скобки так, чтобы его значение равнялось 0, невозможно.Иначе выведите \"YES\" в первой строке и логическое выражение с нужной расстановкой скобок во второй строке.Выражение должно содержать только символы '0', '1', '-' (символ с ASCII кодом 45), '>' (символ с ASCII кодом 62), '(' и ')'. Символы '-' и '>' могут встречаться в выражении только в паре (\"->\") и обозначают импликацию. Суммарное количество логических аргументов (т. е. цифр '0' и '1') в выражении должно равняться n. Порядок следования цифр в выражении слева направо должен совпадать с a1, a2, ..., an.Выражение должно быть правильным. Более формально, правильное выражение определяется следующим образом:  Выражения \"0\", \"1\" (без кавычек) — правильные.  Если v1, v2 — правильные выражения, то v1->v2 — правильное выражение.  Если v — правильное выражение, то (v) — правильное выражение. Общее количество символов в полученном выражении не должно превысить 106.Если возможных ответов несколько, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать40 1 1 0Выходные данныеСкопироватьYES(((0)->1)->(1->0))Входные данныеСкопировать21 1Выходные данныеСкопироватьNOВходные данныеСкопировать10Выходные данныеСкопироватьYES0\n\nВходные данныеСкопировать40 1 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES(((0)->1)->(1->0))\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYES0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!Мы рады сообщить, что 4 июня в 19:30 MSK состоится раунд Codeforces #306, авторами которого являюсь я (Адилет Жаксыбай), и Тимур Сытдыков (Timur_Sitdikov). Раунд будет рейтинговым для участников второго дивизиона, участники первого дивизиона могут, как обычно, поучаствовать в нем вне конкурса. Хочется выразить благодарность всем тем, кто помог нам с подготовкой раунда: Максиму Ахмедову (Zlobober), который помог нам с подготовкой задач, Бекжану Касенову (BekzhanKassenov) и Сергею Лазареву (SergeyLazarev), протестировавшим контест, и Марии Беловой (Delinur), которая перевела условия на английский язык. Отдельное спасибо Михаилу Мирзаянову (MikeMirzayanov) за создание платформ Codeforces и Polygon.Кстати, насколько нам известно, Timur_Sitdikov — первый участник с Узбекистана, принявший участие в подготовке Codeforces раунда. Мы надеемся, что все пройдет хорошо :)Всем удачи!UPD Разбалловка будет динамической.UPD2 Разбор можно найти здесь.UPD3 Поздравляем победителей: mff I_Love_Nodir.Daminov tun I_love_Ngoc_cmn_Thuy goodhope Раунд закончен, спасибо всем, кто принял участие!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18303",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1105
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "550A - Две подстрокиЗадачу можно решать разными способами. Авторское решение такое: проверим две возможности — когда подстрока \"AB\" идет первее \"BA\" и наоборот. Проверять можно следующим образом: найти самое первое вхождение \"AB\" в исходной строке и рассмотреть подстроки длины 2 правее. Если среди них встретилась подстрока \"BA\" — ответ \"YES\". Аналогично проверяется второй случай. Если оба варианта не выполнены, ответ \"NO\". Сложность решения — O(n), где n — длина исходной строки. 550B - Подготовка олимпиадыЗадачу можно решить полным перебором всех подмножеств задач (всего 2n подмножеств). Для каждого из подмножеств проверим, удовлетворяет ли оно условиям задачи. Найдем сумму сложностей всех задач, входящих в подмножество, и убедимся, что она лежит в отрезке [l, r]. Найдем также разность между сложностями максимально сложной задачи и минимально сложной задача подмножества и убедимся, что она не менее x. Если подмножество задач удовлетворяет условиям — увеличиваем общий ответ на 1. Сложность решения задачи — O(2n·n). 550C - Делимость на восемьЗадачу можно решить как минимум двумя способами. Первый — через \"школьный\" признак делимости на 8 (число делится на 8 тогда и только тогда, когда число, образованное его последними тремя цифрами, делится на 8). Таким образом, достаточно проверять на делимость на 8 все однозначные, двухзначные и трехзначные числа, образуемые из исходного вычеркиванием цифр. Это можно сделать за O(n3) вложенными циклами по цифрам числа, где n — количество цифр числа.Второй способ использует динамическое программирование. Будем считать величину dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8 — величину, равную 1, если из префикса числа длиной i цифр можно вычеркнуть несколько цифр так, что остаток от деления полученного числа на 8 равен j, и 0 в противном случае. Формулы для пересчета: пусть i-я цифра числа есть ai, тогда dp[i][aimod8] = 1 (по смыслу — однозначные числа), dp[i][(j * 10 + ai)mod8] = max(dp[i][(j * 10 + ai)mod8], dp[i - 1][j]) (по смыслу — дописывание текущей цифры), dp[i][j] = max(dp[i][j], dp[i - 1][j]) (по смыслу — вычеркивание текущей цифры), где 0 ≤ j < 8. Ответ \"YES\" будет в том случае, когда для некоторого i выполнено dp[i][0] = 1. Для восстановления ответа также нужно завести дополнительный массив prev[i][j], который будет хранить индекс k такой, что при подсчете dp[i][j] пересчет был сделан из dp[i - 1][k]. Сложность такого решения — O(8·n).Решение с динамическим программированием: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Регулярный мостДокажем, что если k — четное, то решения не существует. Пусть наш граф содержит мост(ы), k = 2s — четное число, степени всех вершин графа равны k. Дерево двусвязных (реберно двусвязных, далее слово \"реберных\" будет опущено для краткости) компонент исходного графа содержало компоненту, связанную с остальной частью графа только одним мостом (не несколькими мостами!) (на самом деле таких компонент как минимум две, но нам достаточно одной).Рассмотрим эту компоненту. Удалим мост, связывающий ее с остальной частью графа. Тогда в ней будет всего одна вершина степени k - 1 = 2s - 1 и какое-то количество вершин степени k = 2s. Но тогда она будет содержать только одну вершину нечетной степени, что невозможно.Построим такой граф для нечетных k. Пусть k = 2s - 1 — нечетное число. Рассмотрим отдельно случай k = 1, тогда, очевидно, подойдет дерево из двух вершин.Для k ≥ 3 сперва найдем минимальное количество вершин искомого графа. Граф будет содержать как минимум один мост и как минимум две двусвязные компоненты, связанные с остальной частью графа одним мостом. Каждая из этих компонент содержит не менее k + 2 вершин (так как одна вершина связана k - 1 ребрами с другими, остальные имеют степень k = 2s - 1 — нечетное число, т.. количество этих вершин должно быть четным, в то же время оно не может быть меньше k = 2s - 1, то есть оно будет не меньше k + 1, что в сумме с одной вершиной степени k - 1 даст k + 2).Следовательно, во всем графе будет не менее 2k + 4 вершин. Построим граф с таким количеством вершин. Занумеруем вершины первой компоненты с 1 до k + 2, вторую компоненту построим аналогично первой. Пусть вершина 1 связана мостом с второй компонентой. Соединим ее k - 1 ребрами с вершинами 2, 3, ..., k. Вершины с номерами 2, 3, ..., k соединим между собой попарно и потом между каждой соседней парой, например 2 - 3, 4 - 5, ... (k - 1) - k, выкинем ребро. После соединим вершины 2, 3, ..., k с вершинами k + 1 и k + 2. Также соединим вершины k + 1 и k + 2 между собой. Тогда все вершины компоненты, кроме первой, будут иметь степень k. Точно так же создаем вторую компоненту и соединяем мостом с первой. Искомый граф построен и содержит O(k) вершин и O(k2) ребер. Асимптотика решения — O(k2).550E - Скобки в импликацияхПусть дано выражение , ai — 0 или 1 для всех i.Покажем, что решения нет только в двух случаях.1) an = 1.Это следует из того, что , т. е. никакая расстановка скобок не сможет заменить самую правую 1 выражения на 0.2) Выражение имеет вид или является его суффиксом, содержащим не менее 2 аргументов.Это несложно доказать индукцией. Для суффикса невозможность расстановки скобок очевидна, для более длинных суффиксов любая свертка импликаций либо приведет к тому, что справа появится 1, либо уменьшит число единиц в выражении на 1.Покажем, что в остальных случаях решение есть.1) Для выражения 0 ничего делать не надо — ответ 0.2) Выражение вида . Можно не расставлять никаких скобок, так как значение такого выражения без скобок равно 0.3) Выражение вида , где вторая опущенная часть состоит только из единиц. Тогда .Асимптотика: O(n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*E"
          },
          "content_length": 6500
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces",
          "content": "550A - Две подстрокиЗадачу можно решать разными способами. Авторское решение такое: проверим две возможности — когда подстрока \"AB\" идет первее \"BA\" и наоборот. Проверять можно следующим образом: найти самое первое вхождение \"AB\" в исходной строке и рассмотреть подстроки длины 2 правее. Если среди них встретилась подстрока \"BA\" — ответ \"YES\". Аналогично проверяется второй случай. Если оба варианта не выполнены, ответ \"NO\". Сложность решения — O(n), где n — длина исходной строки. 550B - Подготовка олимпиадыЗадачу можно решить полным перебором всех подмножеств задач (всего 2n подмножеств). Для каждого из подмножеств проверим, удовлетворяет ли оно условиям задачи. Найдем сумму сложностей всех задач, входящих в подмножество, и убедимся, что она лежит в отрезке [l, r]. Найдем также разность между сложностями максимально сложной задачи и минимально сложной задача подмножества и убедимся, что она не менее x. Если подмножество задач удовлетворяет условиям — увеличиваем общий ответ на 1. Сложность решения задачи — O(2n·n). 550C - Делимость на восемьЗадачу можно решить как минимум двумя способами. Первый — через \"школьный\" признак делимости на 8 (число делится на 8 тогда и только тогда, когда число, образованное его последними тремя цифрами, делится на 8). Таким образом, достаточно проверять на делимость на 8 все однозначные, двухзначные и трехзначные числа, образуемые из исходного вычеркиванием цифр. Это можно сделать за O(n3) вложенными циклами по цифрам числа, где n — количество цифр числа.Второй способ использует динамическое программирование. Будем считать величину dp[i][j], 1 ≤ i ≤ n, 0 ≤ j < 8 — величину, равную 1, если из префикса числа длиной i цифр можно вычеркнуть несколько цифр так, что остаток от деления полученного числа на 8 равен j, и 0 в противном случае. Формулы для пересчета: пусть i-я цифра числа есть ai, тогда dp[i][aimod8] = 1 (по смыслу — однозначные числа), dp[i][(j * 10 + ai)mod8] = max(dp[i][(j * 10 + ai)mod8], dp[i - 1][j]) (по смыслу — дописывание текущей цифры), dp[i][j] = max(dp[i][j], dp[i - 1][j]) (по смыслу — вычеркивание текущей цифры), где 0 ≤ j < 8. Ответ \"YES\" будет в том случае, когда для некоторого i выполнено dp[i][0] = 1. Для восстановления ответа также нужно завести дополнительный массив prev[i][j], который будет хранить индекс k такой, что при подсчете dp[i][j] пересчет был сделан из dp[i - 1][k]. Сложность такого решения — O(8·n).Решение с динамическим программированием: Spoiler#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n\nconst int MAXN = 105;\n\nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n\nint main() {\n\n getline(cin, s);\n n = sz(s);\n\n memset(prev, -1, sizeof(prev));\n\n dp[0][(s[0] - '0') % 8] = true;\n\n for (int i = 1; i < n; i++) {\n dp[i][(s[i] - '0') % 8] = true;\n\n for (int j = 0; j < 8; j++) {\n if (dp[i - 1][j]) {\n dp[i][(j * 10 + s[i] - '0') % 8] = true;\n prev[i][(j * 10 + s[i] - '0') % 8] = j;\n\n dp[i][j] = true;\n prev[i][j] = j;\n }\n }\n }\n\n for (int i = 0; i < n; i++) {\n if (dp[i][0]) {\n string ans = \"\";\n int curI = i, curJ = 0;\n\n while (true) {\n if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n ans.append(1, s[curI]);\n }\n\n if (prev[curI][curJ] == -1) break;\n\n curJ = prev[curI][curJ];\n curI--;\n }\n\n puts(\"YES\");\n reverse(all(ans));\n cout << ans << endl;\n return 0;\n }\n }\n\n puts(\"NO\");\n\n return 0;\n}550D - Регулярный мостДокажем, что если k — четное, то решения не существует. Пусть наш граф содержит мост(ы), k = 2s — четное число, степени всех вершин графа равны k. Дерево двусвязных (реберно двусвязных, далее слово \"реберных\" будет опущено для краткости) компонент исходного графа содержало компоненту, связанную с остальной частью графа только одним мостом (не несколькими мостами!) (на самом деле таких компонент как минимум две, но нам достаточно одной).Рассмотрим эту компоненту. Удалим мост, связывающий ее с остальной частью графа. Тогда в ней будет всего одна вершина степени k - 1 = 2s - 1 и какое-то количество вершин степени k = 2s. Но тогда она будет содержать только одну вершину нечетной степени, что невозможно.Построим такой граф для нечетных k. Пусть k = 2s - 1 — нечетное число. Рассмотрим отдельно случай k = 1, тогда, очевидно, подойдет дерево из двух вершин.Для k ≥ 3 сперва найдем минимальное количество вершин искомого графа. Граф будет содержать как минимум один мост и как минимум две двусвязные компоненты, связанные с остальной частью графа одним мостом. Каждая из этих компонент содержит не менее k + 2 вершин (так как одна вершина связана k - 1 ребрами с другими, остальные имеют степень k = 2s - 1 — нечетное число, т.. количество этих вершин должно быть четным, в то же время оно не может быть меньше k = 2s - 1, то есть оно будет не меньше k + 1, что в сумме с одной вершиной степени k - 1 даст k + 2).Следовательно, во всем графе будет не менее 2k + 4 вершин. Построим граф с таким количеством вершин. Занумеруем вершины первой компоненты с 1 до k + 2, вторую компоненту построим аналогично первой. Пусть вершина 1 связана мостом с второй компонентой. Соединим ее k - 1 ребрами с вершинами 2, 3, ..., k. Вершины с номерами 2, 3, ..., k соединим между собой попарно и потом между каждой соседней парой, например 2 - 3, 4 - 5, ... (k - 1) - k, выкинем ребро. После соединим вершины 2, 3, ..., k с вершинами k + 1 и k + 2. Также соединим вершины k + 1 и k + 2 между собой. Тогда все вершины компоненты, кроме первой, будут иметь степень k. Точно так же создаем вторую компоненту и соединяем мостом с первой. Искомый граф построен и содержит O(k) вершин и O(k2) ребер. Асимптотика решения — O(k2).550E - Скобки в импликацияхПусть дано выражение , ai — 0 или 1 для всех i.Покажем, что решения нет только в двух случаях.1) an = 1.Это следует из того, что , т. е. никакая расстановка скобок не сможет заменить самую правую 1 выражения на 0.2) Выражение имеет вид или является его суффиксом, содержащим не менее 2 аргументов.Это несложно доказать индукцией. Для суффикса невозможность расстановки скобок очевидна, для более длинных суффиксов любая свертка импликаций либо приведет к тому, что справа появится 1, либо уменьшит число единиц в выражении на 1.Покажем, что в остальных случаях решение есть.1) Для выражения 0 ничего делать не надо — ответ 0.2) Выражение вида . Можно не расставлять никаких скобок, так как значение такого выражения без скобок равно 0.3) Выражение вида , где вторая опущенная часть состоит только из единиц. Тогда .Асимптотика: O(n).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18329",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 550\\s*E"
          },
          "content_length": 6500
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "string temp=std::to_string(i);\n\n                     ^",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "#define endl \"\\n\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18303",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 1",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 2",
          "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define sz(x) (int) x.size()\n#define all(a) a.begin(), a.end()\n#define prev sadasdjksgjkasjdklaj\n \nconst int MAXN = 105;\n \nstring s;\nint n;\nbool dp[MAXN][8];\nint prev[MAXN][8];\n \nint main() {\n \n    getline(cin, s);\n    n = sz(s);\n \n    memset(prev, -1, sizeof(prev));\n \n    dp[0][(s[0] - '0') % 8] = true;\n \n    for (int i = 1; i < n; i++) {\n        dp[i][(s[i] - '0') % 8] = true;\n \n        for (int j = 0; j < 8; j++) {\n            if (dp[i - 1][j]) {\n                dp[i][(j * 10 + s[i] - '0') % 8] = true;\n                prev[i][(j * 10 + s[i] - '0') % 8] = j;\n \n                dp[i][j] = true;\n                prev[i][j] = j;\n            }\n        }\n    }\n \n    for (int i = 0; i < n; i++) {\n        if (dp[i][0]) {\n            string ans = \"\";\n            int curI = i, curJ = 0;\n \n            while (true) {\n                if (prev[curI][curJ] == -1 || prev[curI][curJ] != curJ) {\n                    ans.append(1, s[curI]);\n                }\n \n                if (prev[curI][curJ] == -1) break;\n \n                curJ = prev[curI][curJ];\n                curI--;\n            }\n \n            puts(\"YES\");\n            reverse(all(ans));\n            cout << ans << endl;\n            return 0;\n        }\n    }\n \n    puts(\"NO\");\n \n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 3",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 4",
          "code": "dp[i][a[i]] = 1;\nprev[i][a[i]] = -1;\nif (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0){\n    dp[i][(j * 10 + a[i]) % 8] = 1;\n    prev[i][(j * 10 + a[i]) % 8] = j;\n}\nif (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 5",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 6",
          "code": "void recursive_print(int i, int j){\n    if (prev[i][j] == -1){\n        cout << a[i];\n        return;\n    }\n    int k = prev[i][j];\n    recursive_print(i - 1, k);\n    if ((k * 10 + a[i]) % 8 == j){\n        cout << a[i];\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 7",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 8",
          "code": "if (dp[i - 1][j] == 1 && dp[i][(j * 10 + a[i]) % 8] == 0) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 9",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 10",
          "code": "dp[i][(j * 10 + a[i]) % 8]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 11",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 12",
          "code": "dp[i - 1][j] ?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 13",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 14",
          "code": "if (dp[i-1][j] == 1) {\n    dp[i][(10*j+a[i])%8] = 1;\n    prev[i][(10*j+a[i])%8] = j;\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 15",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 16",
          "code": "if (dp[i - 1][j] == 1 && dp[i][j]  == 0){\n    dp[i][j] = 1;\n    prev[i][j] = j;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 17",
          "code": "dp[i-1][j] == 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 18",
          "code": "dp[i][(10*j+a[i]] != 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 19",
          "code": "Create a bridge. Than create (k — 1), K(k, k) (complete bipartite graphs). Remove 1 edge from each (k — 1) bipartite graphs. Connect nodes of removed edges of (k — 1) / 2 bipartite graphs to the one endpoint of the bridge and of other (k — 1) / 2 bipartite graphs to the other end of the bridge. So, total nodes = (2 * k * (k — 1) + 2), total edges = (k * k * (k — 1) + k).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 20",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 21",
          "code": "Create K(k + 1) out of vertices 1..K + 1, remove (K - 1) / 2 edges, where all vertices chosen are different. Connect these k - 1 distinct vertices to the bridge vertex 2*k + 3. Connect 2*K + 3 to 2*k + 4. Now construct K(k + 1) out of vertices K + 1 .. 2*K + 2, and proceed similarly.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 22",
          "code": "std::string",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 23",
          "code": "store[0][0]=\" \"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 24",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 25",
          "code": "for(int i=0, l=strlen(s); i<l;i++) \nif(dp[i][0] && store[i][0].length())\n{ cout << \"YES\" << endl << store[i][0] << endl;  return 0;}\n    cout << \"NO\" << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 26",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        },
        {
          "title": "Разбор задач Codeforces Round #306 (Div. 2) - Codeforces - Code 27",
          "code": "for(i=1;i<n;i++)\n\t{\n\t\tfor(j=0;j<8;j++)\n\t\t{\n\t\t\tdp[i][d(i)%8]=1;\n\t\t\tstore[i][d(i)%8]=s[i];\n                        //Added the above two lines instead\n\t\t\tif(dp[i-1][j])\n\t\t\t{\n\t\t\t\tstore[i][j]=store[i-1][j];\n\t\t\t\tstore[i][(j*10+d(i))%8]=store[i-1][j]+s[i];\n\t\t\t}\n\t\t\tdp[i][j]|=dp[i-1][j];\n\t\t\tdp[i][(j*10+d(i))%8]|=dp[i-1][j];\n\t\t}\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18329",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  ================================================================================================\n  This problem clearly admits multiple correct bracketings (if at all it is possible) that yield 0.\n  Hence, a custom checker is needed.\n\n  The participant's output can be one of the following:\n    - \"NO\"\n    - \"YES\" + a bracketed expression using '0', '1', \"->\", and parentheses\n\n  The rules from the statement:\n    1) If the participant prints \"NO\", it is correct if and only if *no* bracket arrangement yields 0.\n       For a sequence of bits [a1, a2, ..., an], the only case where you cannot yield 0 whatsoever\n       by any parenthesization is when all ai = 1. Indeed, if there's at least one '0', there is a\n       way to parenthesize so that the final result becomes 0.\n\n       So:\n         - If the participant says \"NO\" but we detect at least one '0' in the input, checker => _wa.\n         - If the participant says \"NO\" and all input bits are '1', checker => _ok.\n\n    2) If the participant prints \"YES\", we then read the entire expression (which must consist of\n       exactly n digits of '0'/'1' in the same left-to-right order as the input). We also require\n         - The expression is syntactically valid according to the grammar in the statement.\n         - After fully parsing and evaluating it, the final result must be 0 (false).\n         - The total number of '0'/'1' in the expression must be exactly n, matching the input bits\n           in order.\n\n  Implementation details:\n    - We'll read n and the list of bits from inf.\n    - We'll read \"NO\" / \"YES\" from ouf.\n    - If \"NO\", do the no-solution check described above.\n    - If \"YES\", parse the expression carefully. We'll tokenize (\"0\", \"1\", \"->\", \"(\", \")\") and\n      validate the structure with a classic \"shunting-yard\" or a direct recursive-descent parse\n      (iterative to avoid large recursion). Then we verify:\n         * The digits from left to right match the input bits exactly.\n         * The expression is well-formed.\n         * The final evaluated result is 0.\n\n    Parsing/Evaluation approach:\n      We will implement a standard recursive-descent for the simple grammar:\n        E -> T {'->' T}*\n        T -> '(' E ')' | '0' | '1'\n      which we interpret left-to-right. However, to avoid deep recursion on large n,\n      we will implement a \"shunting yard\" style parse or an iterative approach.\n\n      Because we have only one binary operator \"->\" with left associativity (as per problem statement),\n      parentheses can override that associativity. We convert to postfix and then evaluate in one pass.\n\n    NOTE: This checker must run reasonably fast for up to n=100,000 and expression length up to ~1e6.\n    We'll ensure efficient tokenization and parsing.\n\n  ================================================================================================\n*/\n\nstatic const string IMP = \"->\";\n\n// We'll store the sequence of correct bits from the input\nstatic vector<char> bits;\n\n// A small tokenizer to split the participant's expression into tokens: \"0\", \"1\", \"->\", \"(\", \")\"\n//\n// We'll also skip any whitespace if present (though problem doesn't explicitly mention it).\nclass Tokenizer {\npublic:\n    explicit Tokenizer(const string &s) : str(s), pos(0) {}\n\n    bool hasNext() {\n        skipSpaces();\n        return pos < (int)str.size();\n    }\n\n    string nextToken() {\n        skipSpaces();\n        if(!hasNext()) return \"\";\n        // If it's '(' or ')', that is a single-token.\n        if(str[pos] == '(') {\n            pos++;\n            return \"(\";\n        }\n        if(str[pos] == ')') {\n            pos++;\n            return \")\";\n        }\n        // If it's '0' or '1'.\n        if(str[pos] == '0' || str[pos] == '1') {\n            char c = str[pos++];\n            return string(1, c);\n        }\n        // If it's '-', we expect next to be '>' to form \"->\".\n        if(str[pos] == '-') {\n            pos++;\n            if(pos < (int)str.size() && str[pos] == '>') {\n                pos++;\n                return IMP;\n            }\n            // error\n            return \"#ERROR#\";\n        }\n        // Otherwise, error or unexpected symbol\n        // We'll gather it as a single token to fail on parse\n        return \"#ERROR#\";\n    }\n\nprivate:\n    void skipSpaces() {\n        while(pos < (int)str.size() && isspace((unsigned char)str[pos]))\n            pos++;\n    }\n\n    string str;\n    int pos;\n};\n\n// We'll use a standard \"shunting yard\" approach specialized for a single left-associative\n// operator \"->\" with parentheses. Then we'll build a postfix (RPN) expression and evaluate it.\n//\n// Steps:\n// 1) Tokenize\n// 2) Convert to postfix (RPN)\n// 3) Evaluate the RPN, also verifying that the digits match bits[] in order\n//\n// We'll store the user-provided bits in the postfix as an integer: 0 or 1\n// The operator \"->\" is stored as a special token. \"(\" and \")\" won't appear in postfix.\n\nstruct Token {\n    bool isOperator;   // false if it's a literal bit 0/1\n    bool value;        // valid if isOperator==false\n};\n\nstatic void quitWrongAnswer(const char* fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    quitf(_wa, fmt, ap);\n    va_end(ap);\n}\n\n// Convert tokens to postfix using a small stack approach, verifying correctness.\nstatic vector<string> toPostfix(vector<string> &tokens) {\n    // We only have one operator \"->\" (left-associative).\n    // Precedence: '(' is special, \"->\" is the only operator, nest in parentheses is presumably highest priority.\n    vector<string> output;\n    stack<string> opStack;\n\n    for(const auto &tk : tokens) {\n        if(tk == \"(\") {\n            opStack.push(tk);\n        } else if(tk == \")\") {\n            // pop until '('\n            bool foundLeftParen = false;\n            while(!opStack.empty()) {\n                if(opStack.top() == \"(\") {\n                    foundLeftParen = true;\n                    opStack.pop();\n                    break;\n                }\n                output.push_back(opStack.top());\n                opStack.pop();\n            }\n            if(!foundLeftParen) {\n                quitWrongAnswer(\"Mismatched parentheses: no matching '(' for ')'\");\n            }\n        } else if(tk == IMP) {\n            // pop while top of stack is also operator \"->\" (left-associative => pop it)\n            while(!opStack.empty() && opStack.top() == IMP) {\n                output.push_back(opStack.top());\n                opStack.pop();\n            }\n            opStack.push(tk);\n        } else if(tk == \"0\" || tk == \"1\") {\n            // literal\n            output.push_back(tk);\n        } else {\n            // error token\n            quitWrongAnswer(\"Invalid token '%s' in expression\", tk.c_str());\n        }\n    }\n    // pop remaining operators\n    while(!opStack.empty()) {\n        if(opStack.top() == \"(\") {\n            quitWrongAnswer(\"Mismatched parentheses: '(' not closed\");\n        }\n        output.push_back(opStack.top());\n        opStack.pop();\n    }\n    return output;\n}\n\n// Evaluate the postfix expression. While reading bits 0/1, match them to the input bits in order.\nstatic bool evalPostfix(const vector<string> &postfix, const vector<char> &correctBits) {\n    stack<bool> st;\n    // We'll keep an index for which bit we expect next.\n    int idx = 0;\n    int n = (int)correctBits.size();\n\n    for(const auto &tk : postfix) {\n        if(tk == \"0\" || tk == \"1\") {\n            // Must match correctBits[idx]\n            if(idx >= n)\n                quitWrongAnswer(\"Too many 0/1 tokens in expression (should be exactly %d)\", n);\n            // The token must match the next required bit from input\n            if(tk[0] != correctBits[idx])\n                quitWrongAnswer(\"Mismatched bit: expected '%c', found '%s'\", correctBits[idx], tk.c_str());\n            // push the bool value\n            bool val = (tk == \"1\");\n            st.push(val);\n            idx++;\n        } else if(tk == IMP) {\n            // need two operands\n            if(st.size() < 2) {\n                quitWrongAnswer(\"Not enough operands for '->' operator\");\n            }\n            bool b = st.top(); st.pop();\n            bool a = st.top(); st.pop();\n            // a->b is false iff a=1 and b=0\n            bool result = !(a == true && b == false);\n            st.push(result);\n        } else {\n            // no other tokens should appear\n            quitWrongAnswer(\"Unexpected token in postfix '%s'\", tk.c_str());\n        }\n    }\n\n    if(idx != n) {\n        quitWrongAnswer(\"Not all bits were used. Used %d out of %d bits\", idx, n);\n    }\n    if(st.size() != 1) {\n        quitWrongAnswer(\"Final expression does not evaluate to a single value (stack size=%d)\", (int)st.size());\n    }\n    return st.top(); // final result\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1) read input data from inf\n    int n = inf.readInt(1, 100000, \"n\");\n    bits.resize(n);\n    bool allOnes = true;\n    for(int i = 0; i < n; i++){\n        int val = inf.readInt(0, 1, \"a[i]\");\n        bits[i] = char('0' + val);\n        if(val == 0) {\n            allOnes = false;\n        }\n    }\n\n    // 2) read participant's output\n    if(!ouf.seekEof()) {\n        string firstWord = ouf.readToken();\n        // The participant output must be either \"NO\" or \"YES\"\n        // We do case-sensitive checks as problem states to print exactly NO/YES in examples.\n        if(firstWord == \"NO\") {\n            // If participant says \"NO\", it is correct only if all bits are '1'.\n            if(!allOnes) {\n                quitf(_wa, \"Participant output is NO but there exists at least one '0' in the input\");\n            }\n            // We expect no more meaningful tokens; let's accept if there's no non-whitespace after.\n            // If there's extraneous tokens, we also produce WA.\n            ouf.skipBlanks();\n            if(!ouf.eof()) {\n                quitf(_wa, \"Unexpected extra output after NO\");\n            }\n            // correct\n            quitf(_ok, \"Correct: NO for all-ones input\");\n        }\n        else if(firstWord == \"YES\") {\n            // Then we read the remainder as the expression (possibly multi-token).\n            // We'll gather everything else on the output as a single string for tokenizing.\n            // It's simpler to read the rest of the stream as lines, then combine.\n            // We'll also check for total length not exceeding 1e6.\n            string rest;\n            ouf.skipBlanks();\n            while(!ouf.eof()) {\n                rest += ouf.readString();\n                rest += ' '; // space-separate\n            }\n            // Quick length check:\n            // We only allow up to 10^6 characters in total expression.\n            // The problem states \"The total number of characters in the resulting expression\n            // mustn't exceed 10^6.\"\n            if((int)rest.size() > 1000000) {\n                quitf(_wa, \"Expression length exceeds 10^6 characters\");\n            }\n\n            // Tokenize\n            vector<string> tokens;\n            {\n                Tokenizer tz(rest);\n                while(tz.hasNext()) {\n                    auto t = tz.nextToken();\n                    if(t == \"#ERROR#\") {\n                        quitf(_wa, \"Invalid token (misuse of '-' or extra symbol) in expression\");\n                    }\n                    tokens.push_back(t);\n                }\n            }\n            if(tokens.empty()) {\n                quitf(_wa, \"Empty expression after YES\");\n            }\n\n            // Convert to postfix\n            vector<string> postfix = toPostfix(tokens);\n\n            // Evaluate the postfix\n            bool finalVal = evalPostfix(postfix, bits);\n\n            // Must be 0 (false)\n            if(finalVal == false) {\n                quitf(_ok, \"Correct expression yields 0\");\n            } else {\n                quitf(_wa, \"Expression yields 1, not 0\");\n            }\n        }\n        else {\n            quitf(_wa, \"Expected NO or YES as first output token, found '%s'\", firstWord.c_str());\n        }\n    }\n    else {\n        // The participant wrote nothing\n        // If all ones => correct answer would be NO. If not all ones => must give a bracket expression or \"YES\".\n        // So we judge that as WA.\n        if(allOnes) {\n            quitf(_wa, \"Empty output, but correct output would be 'NO'\");\n        } else {\n            quitf(_wa, \"Empty output, but correct output must be 'YES' + expression\");\n        }\n    }\n\n    return 0; // unreachable\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zeros\") {\n        /* Generate a sequence where all values are 0 */\n        for (int i = 0; i < n; i++)\n            a[i] = 0;\n\n    } else if (type == \"all_ones\") {\n        /* Generate a sequence where all values are 1 */\n        for (int i = 0; i < n; i++)\n            a[i] = 1;\n\n    } else if (type == \"alternating\") {\n        /* Generate an alternating sequence of 0 and 1 */\n        for (int i = 0; i < n; i++)\n            a[i] = i % 2;\n\n    } else if (type == \"possible\") {\n        /* Construct a sequence where it is possible to make the expression evaluate to false */\n        if (n == 1) {\n            a[0] = 0; // For n=1, setting a[0]=0 ensures the expression evaluates to false\n        } else {\n            a[0] = 1;\n            a[1] = 0; // 1 -> 0 evaluates to false\n            for (int i = 2; i < n; i++)\n                a[i] = rnd.next(0,1);\n        }\n\n    } else if (type == \"impossible\") {\n        /* Construct a sequence where it is impossible to make the expression evaluate to false */\n        if (n == 1) {\n            a[0] = 1; // For n=1 with a[0]=1, the expression evaluates to true\n        } else {\n            for (int i = 0; i < n; i++)\n                a[i] = 1; // A sequence of all ones cannot evaluate to false\n        }\n\n    } else { // Default to random\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(0,1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the sequence a1 a2 ... an */\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zeros\") {\n        /* Generate a sequence where all values are 0 */\n        for (int i = 0; i < n; i++)\n            a[i] = 0;\n\n    } else if (type == \"all_ones\") {\n        /* Generate a sequence where all values are 1 */\n        for (int i = 0; i < n; i++)\n            a[i] = 1;\n\n    } else if (type == \"alternating\") {\n        /* Generate an alternating sequence of 0 and 1 */\n        for (int i = 0; i < n; i++)\n            a[i] = i % 2;\n\n    } else if (type == \"possible\") {\n        /* Construct a sequence where it is possible to make the expression evaluate to false */\n        if (n == 1) {\n            a[0] = 0; // For n=1, setting a[0]=0 ensures the expression evaluates to false\n        } else {\n            a[0] = 1;\n            a[1] = 0; // 1 -> 0 evaluates to false\n            for (int i = 2; i < n; i++)\n                a[i] = rnd.next(0,1);\n        }\n\n    } else if (type == \"impossible\") {\n        /* Construct a sequence where it is impossible to make the expression evaluate to false */\n        if (n == 1) {\n            a[0] = 1; // For n=1 with a[0]=1, the expression evaluates to true\n        } else {\n            for (int i = 0; i < n; i++)\n                a[i] = 1; // A sequence of all ones cannot evaluate to false\n        }\n\n    } else { // Default to random\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(0,1);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the sequence a1 a2 ... an */\n    for (int i = 0; i < n; i++) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_zeros\n./gen -n 1 -type all_ones\n./gen -n 1 -type possible\n./gen -n 1 -type impossible\n\n./gen -n 2 -type random\n./gen -n 2 -type possible\n./gen -n 2 -type impossible\n\n./gen -n 3 -type random\n./gen -n 3 -type possible\n./gen -n 3 -type impossible\n\n./gen -n 5 -type random\n./gen -n 5 -type possible\n./gen -n 5 -type impossible\n\n./gen -n 10 -type random\n./gen -n 10 -type all_zeros\n./gen -n 10 -type all_ones\n./gen -n 10 -type alternating\n\n./gen -n 100 -type random\n./gen -n 100 -type possible\n./gen -n 100 -type impossible\n./gen -n 100 -type all_zeros\n./gen -n 100 -type all_ones\n./gen -n 100 -type alternating\n\n./gen -n 1000 -type random\n./gen -n 1000 -type possible\n./gen -n 1000 -type impossible\n\n./gen -n 10000 -type random\n./gen -n 10000 -type possible\n./gen -n 10000 -type impossible\n\n./gen -n 50000 -type random\n./gen -n 50000 -type possible\n./gen -n 50000 -type impossible\n\n./gen -n 100000 -type random\n./gen -n 100000 -type possible\n./gen -n 100000 -type impossible\n./gen -n 100000 -type all_zeros\n./gen -n 100000 -type all_ones\n./gen -n 100000 -type alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:42.818774",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "551/A",
      "title": "A. GukiZ and Contest",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2000), number of GukiZ's students. The second line contains n numbers a1, a2, ... an (1 ≤ ai ≤ 2000) where ai is the rating of i-th student (1 ≤ i ≤ n).",
      "output_spec": "OutputIn a single line, print the position after the end of the contest for each of n students in the same order as they appear in the input.",
      "sample_tests": "ExamplesInputCopy31 3 3OutputCopy3 1 1InputCopy11OutputCopy1InputCopy53 5 3 4 5OutputCopy4 1 4 3 1",
      "description": "A. GukiZ and Contest\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 2000), number of GukiZ's students. The second line contains n numbers a1, a2, ... an (1 ≤ ai ≤ 2000) where ai is the rating of i-th student (1 ≤ i ≤ n).\n\nOutputIn a single line, print the position after the end of the contest for each of n students in the same order as they appear in the input.\n\nInputCopy31 3 3OutputCopy3 1 1InputCopy11OutputCopy1InputCopy53 5 3 4 5OutputCopy4 1 4 3 1\n\nInputCopy31 3 3\n\nOutputCopy3 1 1\n\nInputCopy11\n\nOutputCopy1\n\nInputCopy53 5 3 4 5\n\nOutputCopy4 1 4 3 1\n\nNoteIn the first sample, students 2 and 3 are positioned first (there is no other student with higher rating), and student 1 is positioned third since there are two students with higher rating.In the second sample, first student is the only one on the contest.In the third sample, students 2 and 5 share the first position with highest rating, student 4 is next with third position, and students 1 and 3 are the last sharing fourth position.",
      "solutions": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces",
          "content": "Hello Codeforces community !I am glad to announce Codeforces Round 307 (Div. 2) on 12th of June at 19:30 MSK. Authors of this contest are Nikola Mandic (nikola12345) and Aleksa Plavsic (allllekssssa). This is our first round and we really tried to make interesting and solvable problems. Traditionally Div.1 participants can take part out of the competition ( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes ). This is the first Serbian round and we want to invite our friends from Serbia to take part in this round and maybe prepare some of next rounds.The main character of this round is gonna be GukiZ ( our proffesor of computer science ). He really helps us to become better people and developers ! We want to thank Zlobober for help in preparing contest and great advices, Delinur for translating problems statements into Russian and MikeMirzayanov for fantastic Codeforces and Polygon platform !We wish you great fun, a lot of Successful hacks, Accepted solutions and high rating !UPD: Scoring distribution: 500 — 1250 — 1750 — 2000 — 2500.UPD2: Due to technical reasons round was delayed by 10 minutes. Stay tuned!UPD3: +5 minutes. Thanks for your patience!UPD4: System testing is complete, but the rating update won't be that fast since we are working on improving our cheater catching system. Thanks for your understanding!Congratulations to winners!DIV 1:1.MrDindows2.kennethsnow3.ecnerwala4.I_love_Tanya_Romanova5.Hasan0540DIV 2:1.hrzhrz_hrzhrz2.slo3.wangjing4.cyber_tourist5.Moose_LeeThanks to all participants. We hope you have a good time and learn something new.UPD5: Link of editorial !",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18473",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1673
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces",
          "content": "Problems proved to be much harder than we expected. There were some corner cases we didn't include in pretests, so many solutions failed, which was definitely a mistake. Anyway, I hope you find this problemset interesting!Problem A. GukiZ and ContestVery simple implementation problem. Just implement what is written in the statement: for every element of array, find the number of array elements greater than it, and add one to the sum. This can be easily done with two nested loops. Total complexity O(n2).Solution: linkProblem B. ZgukistringZFirst, calculate the number of occurences of every English letter in strings a, b, and c. We can now iterate by number of non-overlapping substrings of the resulting string equal to b, then we can calculate in constant time how many substrings equal to c can be formed (by simple operations on the number of occurences of English letters in c). In every iteration, maximise the sum of numbers of b and c. Number of iterations is not greater than |a|. At the end, we can easily build the resulting string by concatenating previously calculated number of strings b and c, and add the rest of the letters to get the string obtainable from a. Total complexity is O(|a| + |b| + |c|).Solution: linkProblem C. GukiZ hates BoxesProblem solution (complete work time) can be binary searched, because if the work can be done for some amount of time, it can certainly be done for greater amount of time. Let the current search time be k. We can determine if we can complete work for this time by folowing greedy algorithm: find last non-zero pile of boxes and calculate the time needed to get there (which is equal to it's index in array) and take with first man as much boxes as we can. If he can take even more boxes, find next non-zero (to the left) pile, and get as much boxes from it, and repete untill no time is left. When the first man does the job, repete the algorithm for next man, and when all m men did their maximum, if all boxes are removed we can decrease upper bound in binary search. Otherwise, we must increase lower bound. Total compexity is .Solution: linkProblem D. GukiZ and Binary OperationsFirst convert number k into binary number system. If some bit of k is 0 than the result of or opertion applied for every adjacent pair of those bits in array a must be 0, that is no two adjacent those bits in array a are 1. We should count how many times this is fulfilled. If the values were smaller we could count it with simply dpi = dpi - 1 + dpi - 2, where dpi is equal to number of ways to make array od i bits where no two are adjacent ones. With first values dp1 = 2 and dp2 = 3, we can see that this is ordinary Fibonacci number. We can calculate Fibonacci numbers up to 1018 easily by fast matrix multiplication. If some bit at k is 1 than number of ways is 2n — \\t{(number of ways bit is 0)}, which is also easy to calculate. We must be cearful for cases when 2l smaller than k (solution is 0 then) and when l = 63 or l = 64. Total complexity is .Solution: linkProblem E. GukiZ and GukiZianaFirst we divide array a in groups with numbers. Every group in each moment will be kept sorted. For type 1 query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it's current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let's handle with type 2 queries. When we want find GukiZiana(a, j), we search for the first and the last occurence of j by groups. One group can be binary searched in , because of sorted values, and most groups will be searched. Of course, for the first occurence we search for minimum index of value of j, and for the last occurence maximum index of value of j in array. When we find these 2 indexes, we must restore their original positions in array a and print their difference. If there is no occurence of j, print  - 1. Total complexity is .Solution: link",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4036
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 1",
          "code": "[user:Ghassan.Khazaal,2015-06-12] is the closest one to Div 1 :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 2",
          "code": "( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 3",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 4",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 5",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 6",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 7",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 8",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 9",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 10",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 13",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 14",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 15",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 16",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "aaaaaabbbbbb aab abb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "a_1+...+a_n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "O(m*log(a_1+...+a_n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "abbbaaccca ab aca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if ((new BigInteger(Long.toString(k))).testBit(bit))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (l < 63 && k >= (1L << l)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n  registerValidation(argc, argv);\n  int n = inf.readInt(1, 2000, \"n\");\n  inf.readEoln();\n  vector<int> a = inf.readInts(n, 1, 2000);\n  inf.readEoln();\n  inf.readEof();\n  return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n  registerValidation(argc, argv);\n  int n = inf.readInt(1, 2000, \"n\");\n  inf.readEoln();\n  vector<int> a = inf.readInts(n, 1, 2000);\n  inf.readEoln();\n  inf.readEof();\n  return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n  registerValidation(argc, argv);\n  int n = inf.readInt(1, 2000, \"n\");\n  inf.readEoln();\n  vector<int> a = inf.readInts(n, 1, 2000);\n  inf.readEoln();\n  inf.readEof();\n  return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        /* All ratings are the same */\n        int rating = rnd.next(1, 2000);\n        for (int i = 0; i < n; i++)\n            a[i] = rating;\n    }\n    else if (type == \"sorted_increasing\") {\n        /* Ratings are increasing from 1 to n (capped at 2000) */\n        int rating = 1;\n        for (int i = 0; i < n; i++) {\n            a[i] = rating;\n            rating++;\n            if (rating > 2000)\n                rating = 2000;\n        }\n    }\n    else if (type == \"sorted_decreasing\") {\n        /* Ratings are decreasing from 2000 to 1 */\n        int rating = 2000;\n        for (int i = 0; i < n; i++) {\n            a[i] = rating;\n            rating--;\n            if (rating < 1)\n                rating = 1;\n        }\n    }\n    else if (type == \"small_range\") {\n        /* Ratings are random in a small range [1, 5] */\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 5);\n    }\n    else if (type == \"large_range\") {\n        /* Ratings are random in a large range [1, 2000] */\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 2000);\n    }\n    else if (type == \"duplicates\") {\n        /* Ratings include duplicates */\n        int numUnique = rnd.next(1, min(n, 100));\n        vector<int> uniqueRatings(numUnique);\n        for (int i = 0; i < numUnique; i++)\n            uniqueRatings[i] = rnd.next(1, 2000);\n        for (int i = 0; i < n; i++)\n            a[i] = uniqueRatings[rnd.next(0, numUnique - 1)];\n    }\n    else {\n        /* Default: Ratings are random in [1, 2000] */\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 2000);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the ratings */\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_same\") {\n        /* All ratings are the same */\n        int rating = rnd.next(1, 2000);\n        for (int i = 0; i < n; i++)\n            a[i] = rating;\n    }\n    else if (type == \"sorted_increasing\") {\n        /* Ratings are increasing from 1 to n (capped at 2000) */\n        int rating = 1;\n        for (int i = 0; i < n; i++) {\n            a[i] = rating;\n            rating++;\n            if (rating > 2000)\n                rating = 2000;\n        }\n    }\n    else if (type == \"sorted_decreasing\") {\n        /* Ratings are decreasing from 2000 to 1 */\n        int rating = 2000;\n        for (int i = 0; i < n; i++) {\n            a[i] = rating;\n            rating--;\n            if (rating < 1)\n                rating = 1;\n        }\n    }\n    else if (type == \"small_range\") {\n        /* Ratings are random in a small range [1, 5] */\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 5);\n    }\n    else if (type == \"large_range\") {\n        /* Ratings are random in a large range [1, 2000] */\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 2000);\n    }\n    else if (type == \"duplicates\") {\n        /* Ratings include duplicates */\n        int numUnique = rnd.next(1, min(n, 100));\n        vector<int> uniqueRatings(numUnique);\n        for (int i = 0; i < numUnique; i++)\n            uniqueRatings[i] = rnd.next(1, 2000);\n        for (int i = 0; i < n; i++)\n            a[i] = uniqueRatings[rnd.next(0, numUnique - 1)];\n    }\n    else {\n        /* Default: Ratings are random in [1, 2000] */\n        for (int i = 0; i < n; i++)\n            a[i] = rnd.next(1, 2000);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the ratings */\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type random\n./gen -n 2 -type duplicates\n./gen -n 10 -type random\n./gen -n 10 -type sorted_increasing\n./gen -n 10 -type sorted_decreasing\n./gen -n 10 -type all_same\n./gen -n 10 -type small_range\n./gen -n 50 -type large_range\n./gen -n 100 -type duplicates\n./gen -n 100 -type random\n./gen -n 500 -type sorted_increasing\n./gen -n 500 -type sorted_decreasing\n./gen -n 1000 -type duplicates\n./gen -n 2000 -type random\n./gen -n 2000 -type all_same\n./gen -n 2000 -type small_range\n./gen -n 2000 -type sorted_increasing\n./gen -n 2000 -type sorted_decreasing\n./gen -n 2000 -type duplicates\n./gen -n 2000 -type large_range\n./gen -n 2000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:45.158600",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "551/B",
      "title": "B. ZgukistringZ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записана строка a, во второй строке записана строка b, а в третьей строке записана строка c (1 ≤ |a|, |b|, |c| ≤ 105, где |s| обозначает длину строки s).Все три строки содержат только строчные буквы английского алфавита. Строки b и c не обязательно различны.",
      "output_spec": "Выходные данныеНайдите одну из возможных строк k, отвечающую описанию, данному в условии задачи. Если есть несколько возможных ответов, выведите любой.",
      "sample_tests": "ПримерыВходные данныеСкопироватьaaaabВыходные данныеСкопироватьaaaВходные данныеСкопироватьpozdravstaklenidodirinistedobriВыходные данныеСкопироватьnisteaadddiiklooprrvzВходные данныеСкопироватьabbbaacccaabacaВыходные данныеСкопироватьababacabcc",
      "description": "B. ZgukistringZ\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записана строка a, во второй строке записана строка b, а в третьей строке записана строка c (1 ≤ |a|, |b|, |c| ≤ 105, где |s| обозначает длину строки s).Все три строки содержат только строчные буквы английского алфавита. Строки b и c не обязательно различны.\n\nВходные данные\n\nВыходные данныеНайдите одну из возможных строк k, отвечающую описанию, данному в условии задачи. Если есть несколько возможных ответов, выведите любой.\n\nВыходные данные\n\nВходные данныеСкопироватьaaaabВыходные данныеСкопироватьaaaВходные данныеСкопироватьpozdravstaklenidodirinistedobriВыходные данныеСкопироватьnisteaadddiiklooprrvzВходные данныеСкопироватьabbbaacccaabacaВыходные данныеСкопироватьababacabcc\n\nВходные данныеСкопироватьaaaab\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьaaa\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьpozdravstaklenidodirinistedobri\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьnisteaadddiiklooprrvz\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьabbbaacccaabaca\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьababacabcc\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ третьем примере у данного оптимального решения есть три непересекающиеся подстроки, равные либо b, либо c в позициях 1 – 2 (ab), 3 – 4 (ab), 5 – 7 (aca). В этом примере существует много других оптимальных решений, одно из них: acaababbcc.",
      "solutions": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces",
          "content": "Hello Codeforces community !I am glad to announce Codeforces Round 307 (Div. 2) on 12th of June at 19:30 MSK. Authors of this contest are Nikola Mandic (nikola12345) and Aleksa Plavsic (allllekssssa). This is our first round and we really tried to make interesting and solvable problems. Traditionally Div.1 participants can take part out of the competition ( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes ). This is the first Serbian round and we want to invite our friends from Serbia to take part in this round and maybe prepare some of next rounds.The main character of this round is gonna be GukiZ ( our proffesor of computer science ). He really helps us to become better people and developers ! We want to thank Zlobober for help in preparing contest and great advices, Delinur for translating problems statements into Russian and MikeMirzayanov for fantastic Codeforces and Polygon platform !We wish you great fun, a lot of Successful hacks, Accepted solutions and high rating !UPD: Scoring distribution: 500 — 1250 — 1750 — 2000 — 2500.UPD2: Due to technical reasons round was delayed by 10 minutes. Stay tuned!UPD3: +5 minutes. Thanks for your patience!UPD4: System testing is complete, but the rating update won't be that fast since we are working on improving our cheater catching system. Thanks for your understanding!Congratulations to winners!DIV 1:1.MrDindows2.kennethsnow3.ecnerwala4.I_love_Tanya_Romanova5.Hasan0540DIV 2:1.hrzhrz_hrzhrz2.slo3.wangjing4.cyber_tourist5.Moose_LeeThanks to all participants. We hope you have a good time and learn something new.UPD5: Link of editorial !",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18473",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1673
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces",
          "content": "Problems proved to be much harder than we expected. There were some corner cases we didn't include in pretests, so many solutions failed, which was definitely a mistake. Anyway, I hope you find this problemset interesting!Problem A. GukiZ and ContestVery simple implementation problem. Just implement what is written in the statement: for every element of array, find the number of array elements greater than it, and add one to the sum. This can be easily done with two nested loops. Total complexity O(n2).Solution: linkProblem B. ZgukistringZFirst, calculate the number of occurences of every English letter in strings a, b, and c. We can now iterate by number of non-overlapping substrings of the resulting string equal to b, then we can calculate in constant time how many substrings equal to c can be formed (by simple operations on the number of occurences of English letters in c). In every iteration, maximise the sum of numbers of b and c. Number of iterations is not greater than |a|. At the end, we can easily build the resulting string by concatenating previously calculated number of strings b and c, and add the rest of the letters to get the string obtainable from a. Total complexity is O(|a| + |b| + |c|).Solution: linkProblem C. GukiZ hates BoxesProblem solution (complete work time) can be binary searched, because if the work can be done for some amount of time, it can certainly be done for greater amount of time. Let the current search time be k. We can determine if we can complete work for this time by folowing greedy algorithm: find last non-zero pile of boxes and calculate the time needed to get there (which is equal to it's index in array) and take with first man as much boxes as we can. If he can take even more boxes, find next non-zero (to the left) pile, and get as much boxes from it, and repete untill no time is left. When the first man does the job, repete the algorithm for next man, and when all m men did their maximum, if all boxes are removed we can decrease upper bound in binary search. Otherwise, we must increase lower bound. Total compexity is .Solution: linkProblem D. GukiZ and Binary OperationsFirst convert number k into binary number system. If some bit of k is 0 than the result of or opertion applied for every adjacent pair of those bits in array a must be 0, that is no two adjacent those bits in array a are 1. We should count how many times this is fulfilled. If the values were smaller we could count it with simply dpi = dpi - 1 + dpi - 2, where dpi is equal to number of ways to make array od i bits where no two are adjacent ones. With first values dp1 = 2 and dp2 = 3, we can see that this is ordinary Fibonacci number. We can calculate Fibonacci numbers up to 1018 easily by fast matrix multiplication. If some bit at k is 1 than number of ways is 2n — \\t{(number of ways bit is 0)}, which is also easy to calculate. We must be cearful for cases when 2l smaller than k (solution is 0 then) and when l = 63 or l = 64. Total complexity is .Solution: linkProblem E. GukiZ and GukiZianaFirst we divide array a in groups with numbers. Every group in each moment will be kept sorted. For type 1 query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it's current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let's handle with type 2 queries. When we want find GukiZiana(a, j), we search for the first and the last occurence of j by groups. One group can be binary searched in , because of sorted values, and most groups will be searched. Of course, for the first occurence we search for minimum index of value of j, and for the last occurence maximum index of value of j in array. When we find these 2 indexes, we must restore their original positions in array a and print their difference. If there is no occurence of j, print  - 1. Total complexity is .Solution: link",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4036
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 1",
          "code": "[user:Ghassan.Khazaal,2015-06-12] is the closest one to Div 1 :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 2",
          "code": "( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 3",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 4",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 5",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 6",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 7",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 8",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 9",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 10",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 13",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 14",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 15",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 16",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "aaaaaabbbbbb aab abb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "a_1+...+a_n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "O(m*log(a_1+...+a_n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "abbbaaccca ab aca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if ((new BigInteger(Long.toString(k))).testBit(bit))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (l < 63 && k >= (1L << l)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read string a\n    string a = inf.readToken(\"[a-z]{1,100000}\", \"a\");\n    inf.readEoln();\n\n    // Read string b\n    string b = inf.readToken(\"[a-z]{1,100000}\", \"b\");\n    inf.readEoln();\n\n    // Read string c\n    string c = inf.readToken(\"[a-z]{1,100000}\", \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read string a\n    string a = inf.readToken(\"[a-z]{1,100000}\", \"a\");\n    inf.readEoln();\n\n    // Read string b\n    string b = inf.readToken(\"[a-z]{1,100000}\", \"b\");\n    inf.readEoln();\n\n    // Read string c\n    string c = inf.readToken(\"[a-z]{1,100000}\", \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read string a\n    string a = inf.readToken(\"[a-z]{1,100000}\", \"a\");\n    inf.readEoln();\n\n    // Read string b\n    string b = inf.readToken(\"[a-z]{1,100000}\", \"b\");\n    inf.readEoln();\n\n    // Read string c\n    string c = inf.readToken(\"[a-z]{1,100000}\", \"c\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int next[26];\n    int fail;\n    vector<int> output; // indices of patterns ending at this node\n    Node() {\n        memset(next, -1, sizeof(next));\n        fail = -1;\n    }\n};\n\nvector<Node> trie;\nvector<int> pattern_lengths;\n\nvoid buildTrie(const vector<string>& patterns) {\n    trie.clear();\n    trie.emplace_back(); // root node\n    for (int pid = 0; pid < patterns.size(); pid++) {\n        const string& p = patterns[pid];\n        int node = 0;\n        for (char ch : p) {\n            int c = ch - 'a';\n            if (trie[node].next[c] == -1) {\n                trie[node].next[c] = trie.size();\n                trie.emplace_back();\n            }\n            node = trie[node].next[c];\n        }\n        trie[node].output.push_back(pid);\n    }\n}\n\nvoid buildFailLinks() {\n    queue<int> q;\n    for (int c = 0; c < 26; c++) {\n        if (trie[0].next[c] != -1) {\n            trie[trie[0].next[c]].fail = 0;\n            q.push(trie[0].next[c]);\n        } else {\n            trie[0].next[c] = 0;\n        }\n    }\n    while (!q.empty()) {\n        int r = q.front();\n        q.pop();\n        for (int c = 0; c < 26; c++) {\n            int u = trie[r].next[c];\n            if (u != -1) {\n                q.push(u);\n                int f = trie[r].fail;\n                while (trie[f].next[c] == -1) {\n                    f = trie[f].fail;\n                }\n                trie[u].fail = trie[f].next[c];\n                trie[u].output.insert(trie[u].output.end(),\n                                      trie[trie[u].fail].output.begin(),\n                                      trie[trie[u].fail].output.end());\n            }\n        }\n    }\n}\n\nint countNonOverlappingMatches(const string& s, const vector<string>& patterns) {\n    buildTrie(patterns);\n    buildFailLinks();\n    vector<pair<int, int>> matches; // (end position, start position)\n    int node = 0;\n    for (int i = 0; i < s.size(); i++) {\n        int c = s[i] - 'a';\n        while (trie[node].next[c] == -1) {\n            node = trie[node].fail;\n        }\n        node = trie[node].next[c];\n        for (int pid : trie[node].output) {\n            int length = pattern_lengths[pid];\n            int start = i - length + 1;\n            matches.emplace_back(i, start);\n        }\n    }\n    // Sort matches by end position\n    sort(matches.begin(), matches.end());\n    // Select non-overlapping matches\n    int count = 0;\n    int last_end = -1;\n    for (auto& m : matches) {\n        int start = m.second;\n        int end = m.first;\n        if (start > last_end) {\n            count++;\n            last_end = end;\n        }\n    }\n    return count;\n}\n\nvoid checkPermutation(const string& s, const string& a, InStream& stream) {\n    if (s.size() != a.size()) {\n        stream.quitf(_wa, \"Output string length does not match input string length\");\n    }\n    vector<int> cnt_s(26, 0), cnt_a(26, 0);\n    for (char ch : s) {\n        cnt_s[ch - 'a']++;\n    }\n    for (char ch : a) {\n        cnt_a[ch - 'a']++;\n    }\n    if (cnt_s != cnt_a) {\n        stream.quitf(_wa, \"Output string is not a permutation of input string\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    string a = inf.readLine();\n    string b = inf.readLine();\n    string c = inf.readLine();\n\n    vector<string> patterns = {b, c};\n    pattern_lengths = {int(b.size()), int(c.size())};\n\n    string jury_output = ans.readLine();\n    string participant_output = ouf.readLine();\n\n    // Check permutations\n    checkPermutation(jury_output, a, ans);\n    checkPermutation(participant_output, a, ouf);\n\n    // Compute the number of non-overlapping matches\n    int jans = countNonOverlappingMatches(jury_output, patterns);\n    int pans = countNonOverlappingMatches(participant_output, patterns);\n\n    if (pans > jans) {\n        quitf(_fail, \"Participant's answer is better than jury's: participant's matches = %d, jury's matches = %d\", pans, jans);\n    } else if (pans < jans) {\n        quitf(_wa, \"Participant's answer is worse than jury's: participant's matches = %d, jury's matches = %d\", pans, jans);\n    } else {\n        quitf(_ok, \"Number of matches = %d\", pans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len, const vector<char>& letters) {\n    string s;\n    int n = letters.size();\n    for (int i = 0; i < len; ++i) {\n        char ch = letters[rnd.next(n)];\n        s += ch;\n    }\n    return s;\n}\n\nstring string_shuffle(const string& s) {\n    string t = s;\n    shuffle(t.begin(), t.end());\n    return t;\n}\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n    int alen = opt<int>(\"alen\");\n    int blen = opt<int>(\"blen\");\n    int clen = opt<int>(\"clen\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b, c;\n\n    if (type == \"random\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        a = randomString(alen, letters);\n        b = randomString(blen, letters);\n        c = randomString(clen, letters);\n    } else if (type == \"same_letter\") {\n        char ch = 'a' + rnd.next(26);\n        a = string(alen, ch);\n        b = string(blen, ch);\n        c = string(clen, ch);\n    } else if (type == \"b_equals_c\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        a = randomString(alen, letters);\n        b = randomString(blen, letters);\n        c = b;\n    } else if (type == \"b_substring_c\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        b = randomString(blen, letters);\n        c = randomString(clen, letters);\n        if (blen <= clen) {\n            int idx = rnd.next(0, clen - blen);\n            c.replace(idx, blen, b);\n        } else {\n            b = c.substr(0, blen);\n        }\n        a = randomString(alen, letters);\n    } else if (type == \"c_substring_b\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        c = randomString(clen, letters);\n        b = randomString(blen, letters);\n        if (clen <= blen) {\n            int idx = rnd.next(0, blen - clen);\n            b.replace(idx, clen, c);\n        } else {\n            c = b.substr(0, clen);\n        }\n        a = randomString(alen, letters);\n    } else if (type == \"disjoint_letters\") {\n        // Generate a with letters from 'a'-'m', b and c from 'n'-'z'\n        vector<char> letters_a;\n        for (char ch = 'a'; ch <= 'm'; ++ch)\n            letters_a.push_back(ch);\n        vector<char> letters_bc;\n        for (char ch = 'n'; ch <= 'z'; ++ch)\n            letters_bc.push_back(ch);\n        a = randomString(alen, letters_a);\n        b = randomString(blen, letters_bc);\n        c = randomString(clen, letters_bc);\n    } else if (type == \"maximal_substrings\") {\n        // Choose two different letters\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        char letter_b = letters[rnd.next(26)];\n        char letter_c;\n        do {\n            letter_c = letters[rnd.next(26)];\n        } while (letter_c == letter_b);\n\n        b = string(blen, letter_b);\n        c = string(clen, letter_c);\n\n        // Now, construct 'a' with as many copies of b and c letters as possible\n        int total_letters_in_b_and_c = blen + clen;\n        int repeats = alen / total_letters_in_b_and_c;\n        int remaining = alen % total_letters_in_b_and_c;\n\n        a = \"\";\n        for (int i = 0; i < repeats; ++i) {\n            a += string(blen, letter_b);\n            a += string(clen, letter_c);\n        }\n        // For the remaining letters, fill with letters from b and c\n        int rem_b = min(remaining, blen);\n        a += string(rem_b, letter_b);\n        remaining -= rem_b;\n        if (remaining > 0) {\n            int rem_c = min(remaining, clen);\n            a += string(rem_c, letter_c);\n            remaining -= rem_c;\n        }\n        // If still remaining, fill with any other letters\n        if (remaining > 0) {\n            // Choose a different letter\n            char letter_d;\n            do {\n                letter_d = letters[rnd.next(26)];\n            } while (letter_d == letter_b || letter_d == letter_c);\n            a += string(remaining, letter_d);\n        }\n        // Shuffle 'a' to mix letters\n        a = string_shuffle(a);\n    } else if (type == \"minimal_substrings\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        // Choose two letters for b and c\n        char letter_b = letters[rnd.next(26)];\n        char letter_c;\n        do {\n            letter_c = letters[rnd.next(26)];\n        } while (letter_c == letter_b);\n\n        b = string(blen, letter_b);\n        c = string(clen, letter_c);\n\n        // Now, construct 'a' with letters not in b and c\n        vector<char> letters_a;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            if (ch != letter_b && ch != letter_c)\n                letters_a.push_back(ch);\n\n        a = randomString(alen, letters_a);\n    } else {\n        // default random\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        a = randomString(alen, letters);\n        b = randomString(blen, letters);\n        c = randomString(clen, letters);\n    }\n\n    // Output\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n    printf(\"%s\\n\", c.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len, const vector<char>& letters) {\n    string s;\n    int n = letters.size();\n    for (int i = 0; i < len; ++i) {\n        char ch = letters[rnd.next(n)];\n        s += ch;\n    }\n    return s;\n}\n\nstring string_shuffle(const string& s) {\n    string t = s;\n    shuffle(t.begin(), t.end());\n    return t;\n}\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n    int alen = opt<int>(\"alen\");\n    int blen = opt<int>(\"blen\");\n    int clen = opt<int>(\"clen\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string a, b, c;\n\n    if (type == \"random\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        a = randomString(alen, letters);\n        b = randomString(blen, letters);\n        c = randomString(clen, letters);\n    } else if (type == \"same_letter\") {\n        char ch = 'a' + rnd.next(26);\n        a = string(alen, ch);\n        b = string(blen, ch);\n        c = string(clen, ch);\n    } else if (type == \"b_equals_c\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        a = randomString(alen, letters);\n        b = randomString(blen, letters);\n        c = b;\n    } else if (type == \"b_substring_c\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        b = randomString(blen, letters);\n        c = randomString(clen, letters);\n        if (blen <= clen) {\n            int idx = rnd.next(0, clen - blen);\n            c.replace(idx, blen, b);\n        } else {\n            b = c.substr(0, blen);\n        }\n        a = randomString(alen, letters);\n    } else if (type == \"c_substring_b\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        c = randomString(clen, letters);\n        b = randomString(blen, letters);\n        if (clen <= blen) {\n            int idx = rnd.next(0, blen - clen);\n            b.replace(idx, clen, c);\n        } else {\n            c = b.substr(0, clen);\n        }\n        a = randomString(alen, letters);\n    } else if (type == \"disjoint_letters\") {\n        // Generate a with letters from 'a'-'m', b and c from 'n'-'z'\n        vector<char> letters_a;\n        for (char ch = 'a'; ch <= 'm'; ++ch)\n            letters_a.push_back(ch);\n        vector<char> letters_bc;\n        for (char ch = 'n'; ch <= 'z'; ++ch)\n            letters_bc.push_back(ch);\n        a = randomString(alen, letters_a);\n        b = randomString(blen, letters_bc);\n        c = randomString(clen, letters_bc);\n    } else if (type == \"maximal_substrings\") {\n        // Choose two different letters\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        char letter_b = letters[rnd.next(26)];\n        char letter_c;\n        do {\n            letter_c = letters[rnd.next(26)];\n        } while (letter_c == letter_b);\n\n        b = string(blen, letter_b);\n        c = string(clen, letter_c);\n\n        // Now, construct 'a' with as many copies of b and c letters as possible\n        int total_letters_in_b_and_c = blen + clen;\n        int repeats = alen / total_letters_in_b_and_c;\n        int remaining = alen % total_letters_in_b_and_c;\n\n        a = \"\";\n        for (int i = 0; i < repeats; ++i) {\n            a += string(blen, letter_b);\n            a += string(clen, letter_c);\n        }\n        // For the remaining letters, fill with letters from b and c\n        int rem_b = min(remaining, blen);\n        a += string(rem_b, letter_b);\n        remaining -= rem_b;\n        if (remaining > 0) {\n            int rem_c = min(remaining, clen);\n            a += string(rem_c, letter_c);\n            remaining -= rem_c;\n        }\n        // If still remaining, fill with any other letters\n        if (remaining > 0) {\n            // Choose a different letter\n            char letter_d;\n            do {\n                letter_d = letters[rnd.next(26)];\n            } while (letter_d == letter_b || letter_d == letter_c);\n            a += string(remaining, letter_d);\n        }\n        // Shuffle 'a' to mix letters\n        a = string_shuffle(a);\n    } else if (type == \"minimal_substrings\") {\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        // Choose two letters for b and c\n        char letter_b = letters[rnd.next(26)];\n        char letter_c;\n        do {\n            letter_c = letters[rnd.next(26)];\n        } while (letter_c == letter_b);\n\n        b = string(blen, letter_b);\n        c = string(clen, letter_c);\n\n        // Now, construct 'a' with letters not in b and c\n        vector<char> letters_a;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            if (ch != letter_b && ch != letter_c)\n                letters_a.push_back(ch);\n\n        a = randomString(alen, letters_a);\n    } else {\n        // default random\n        vector<char> letters;\n        for (char ch = 'a'; ch <= 'z'; ++ch)\n            letters.push_back(ch);\n        a = randomString(alen, letters);\n        b = randomString(blen, letters);\n        c = randomString(clen, letters);\n    }\n\n    // Output\n    printf(\"%s\\n\", a.c_str());\n    printf(\"%s\\n\", b.c_str());\n    printf(\"%s\\n\", c.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -alen 1 -blen 1 -clen 1 -type random\n./gen -alen 5 -blen 2 -clen 2 -type random\n./gen -alen 10 -blen 5 -clen 5 -type random\n./gen -alen 100000 -blen 100000 -clen 100000 -type random\n\n./gen -alen 1 -blen 1 -clen 1 -type same_letter\n./gen -alen 10 -blen 5 -clen 5 -type same_letter\n./gen -alen 100000 -blen 100000 -clen 100000 -type same_letter\n\n./gen -alen 10 -blen 5 -clen 5 -type b_equals_c\n./gen -alen 100000 -blen 50000 -clen 50000 -type b_equals_c\n\n./gen -alen 10000 -blen 5000 -clen 5000 -type b_substring_c\n./gen -alen 100000 -blen 50000 -clen 50000 -type b_substring_c\n\n./gen -alen 10000 -blen 5000 -clen 5000 -type c_substring_b\n./gen -alen 100000 -blen 50000 -clen 50000 -type c_substring_b\n\n./gen -alen 100000 -blen 1000 -clen 1000 -type disjoint_letters\n\n./gen -alen 1000 -blen 500 -clen 500 -type maximal_substrings\n./gen -alen 100000 -blen 50000 -clen 50000 -type maximal_substrings\n./gen -alen 100000 -blen 1 -clen 1 -type maximal_substrings\n./gen -alen 100000 -blen 99999 -clen 1 -type maximal_substrings\n\n./gen -alen 1000 -blen 10 -clen 10 -type minimal_substrings\n./gen -alen 100000 -blen 10 -clen 10 -type minimal_substrings\n./gen -alen 100000 -blen 99999 -clen 99999 -type minimal_substrings\n./gen -alen 1 -blen 1 -clen 1 -type minimal_substrings\n\n./gen -alen 1 -blen 1 -clen 1 -type b_equals_c\n./gen -alen 100000 -blen 1 -clen 1 -type same_letter\n./gen -alen 1 -blen 1 -clen 1 -type disjoint_letters\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:47.404324",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "551/C",
      "title": "C. GukiZ hates Boxes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 105), the number of piles of boxes and the number of GukiZ's students. The second line contains n integers a1, a2, ... an (0 ≤ ai ≤ 109) where ai represents the number of boxes on i-th pile. It's guaranteed that at least one pile of is non-empty.",
      "output_spec": "OutputIn a single line, print one number, minimum time needed to remove all the boxes in seconds.",
      "sample_tests": "ExamplesInputCopy2 11 1OutputCopy4InputCopy3 21 0 2OutputCopy5InputCopy4 1003 4 5 4OutputCopy5",
      "description": "C. GukiZ hates Boxes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 105), the number of piles of boxes and the number of GukiZ's students. The second line contains n integers a1, a2, ... an (0 ≤ ai ≤ 109) where ai represents the number of boxes on i-th pile. It's guaranteed that at least one pile of is non-empty.\n\nOutputIn a single line, print one number, minimum time needed to remove all the boxes in seconds.\n\nInputCopy2 11 1OutputCopy4InputCopy3 21 0 2OutputCopy5InputCopy4 1003 4 5 4OutputCopy5\n\nInputCopy2 11 1\n\nOutputCopy4\n\nInputCopy3 21 0 2\n\nOutputCopy5\n\nInputCopy4 1003 4 5 4\n\nOutputCopy5\n\nNoteFirst sample: Student will first move to the first pile (1 second), then remove box from first pile (1 second), then move to the second pile (1 second) and finally remove the box from second pile (1 second).Second sample: One of optimal solutions is to send one student to remove a box from the first pile and a box from the third pile, and send another student to remove a box from the third pile. Overall, 5 seconds.Third sample: With a lot of available students, send three of them to remove boxes from the first pile, four of them to remove boxes from the second pile, five of them to remove boxes from the third pile, and four of them to remove boxes from the fourth pile. Process will be over in 5 seconds, when removing the boxes from the last pile is finished.",
      "solutions": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces",
          "content": "Hello Codeforces community !I am glad to announce Codeforces Round 307 (Div. 2) on 12th of June at 19:30 MSK. Authors of this contest are Nikola Mandic (nikola12345) and Aleksa Plavsic (allllekssssa). This is our first round and we really tried to make interesting and solvable problems. Traditionally Div.1 participants can take part out of the competition ( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes ). This is the first Serbian round and we want to invite our friends from Serbia to take part in this round and maybe prepare some of next rounds.The main character of this round is gonna be GukiZ ( our proffesor of computer science ). He really helps us to become better people and developers ! We want to thank Zlobober for help in preparing contest and great advices, Delinur for translating problems statements into Russian and MikeMirzayanov for fantastic Codeforces and Polygon platform !We wish you great fun, a lot of Successful hacks, Accepted solutions and high rating !UPD: Scoring distribution: 500 — 1250 — 1750 — 2000 — 2500.UPD2: Due to technical reasons round was delayed by 10 minutes. Stay tuned!UPD3: +5 minutes. Thanks for your patience!UPD4: System testing is complete, but the rating update won't be that fast since we are working on improving our cheater catching system. Thanks for your understanding!Congratulations to winners!DIV 1:1.MrDindows2.kennethsnow3.ecnerwala4.I_love_Tanya_Romanova5.Hasan0540DIV 2:1.hrzhrz_hrzhrz2.slo3.wangjing4.cyber_tourist5.Moose_LeeThanks to all participants. We hope you have a good time and learn something new.UPD5: Link of editorial !",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18473",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1673
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces",
          "content": "Problems proved to be much harder than we expected. There were some corner cases we didn't include in pretests, so many solutions failed, which was definitely a mistake. Anyway, I hope you find this problemset interesting!Problem A. GukiZ and ContestVery simple implementation problem. Just implement what is written in the statement: for every element of array, find the number of array elements greater than it, and add one to the sum. This can be easily done with two nested loops. Total complexity O(n2).Solution: linkProblem B. ZgukistringZFirst, calculate the number of occurences of every English letter in strings a, b, and c. We can now iterate by number of non-overlapping substrings of the resulting string equal to b, then we can calculate in constant time how many substrings equal to c can be formed (by simple operations on the number of occurences of English letters in c). In every iteration, maximise the sum of numbers of b and c. Number of iterations is not greater than |a|. At the end, we can easily build the resulting string by concatenating previously calculated number of strings b and c, and add the rest of the letters to get the string obtainable from a. Total complexity is O(|a| + |b| + |c|).Solution: linkProblem C. GukiZ hates BoxesProblem solution (complete work time) can be binary searched, because if the work can be done for some amount of time, it can certainly be done for greater amount of time. Let the current search time be k. We can determine if we can complete work for this time by folowing greedy algorithm: find last non-zero pile of boxes and calculate the time needed to get there (which is equal to it's index in array) and take with first man as much boxes as we can. If he can take even more boxes, find next non-zero (to the left) pile, and get as much boxes from it, and repete untill no time is left. When the first man does the job, repete the algorithm for next man, and when all m men did their maximum, if all boxes are removed we can decrease upper bound in binary search. Otherwise, we must increase lower bound. Total compexity is .Solution: linkProblem D. GukiZ and Binary OperationsFirst convert number k into binary number system. If some bit of k is 0 than the result of or opertion applied for every adjacent pair of those bits in array a must be 0, that is no two adjacent those bits in array a are 1. We should count how many times this is fulfilled. If the values were smaller we could count it with simply dpi = dpi - 1 + dpi - 2, where dpi is equal to number of ways to make array od i bits where no two are adjacent ones. With first values dp1 = 2 and dp2 = 3, we can see that this is ordinary Fibonacci number. We can calculate Fibonacci numbers up to 1018 easily by fast matrix multiplication. If some bit at k is 1 than number of ways is 2n — \\t{(number of ways bit is 0)}, which is also easy to calculate. We must be cearful for cases when 2l smaller than k (solution is 0 then) and when l = 63 or l = 64. Total complexity is .Solution: linkProblem E. GukiZ and GukiZianaFirst we divide array a in groups with numbers. Every group in each moment will be kept sorted. For type 1 query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it's current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let's handle with type 2 queries. When we want find GukiZiana(a, j), we search for the first and the last occurence of j by groups. One group can be binary searched in , because of sorted values, and most groups will be searched. Of course, for the first occurence we search for minimum index of value of j, and for the last occurence maximum index of value of j in array. When we find these 2 indexes, we must restore their original positions in array a and print their difference. If there is no occurence of j, print  - 1. Total complexity is .Solution: link",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4036
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 1",
          "code": "[user:Ghassan.Khazaal,2015-06-12] is the closest one to Div 1 :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 2",
          "code": "( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 3",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 4",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 5",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 6",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 7",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 8",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 9",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 10",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 13",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 14",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 15",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 16",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "aaaaaabbbbbb aab abb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "a_1+...+a_n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "O(m*log(a_1+...+a_n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "abbbaaccca ab aca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if ((new BigInteger(Long.toString(k))).testBit(bit))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (l < 63 && k >= (1L << l)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    bool has_nonzero = false;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > 0) {\n            has_nonzero = true;\n            break;\n        }\n    }\n    ensuref(has_nonzero, \"At least one pile must be non-empty\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    bool has_nonzero = false;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > 0) {\n            has_nonzero = true;\n            break;\n        }\n    }\n    ensuref(has_nonzero, \"At least one pile must be non-empty\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    bool has_nonzero = false;\n    for (int i = 0; i < n; ++i) {\n        if (a[i] > 0) {\n            has_nonzero = true;\n            break;\n        }\n    }\n    ensuref(has_nonzero, \"At least one pile must be non-empty\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");           // Number of piles\n    int m = opt<int>(\"m\");           // Number of students\n    int maxA = opt<int>(\"maxA\", 1e9); // Maximum value for ai\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Initialize variables\n    vector<int> a(n, 0);\n\n    if (type == \"max\") {\n        // All piles have maximum number of boxes\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxA;\n        }\n    } else if (type == \"min\") {\n        // All piles have zero boxes except one pile with one box\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    } else if (type == \"ones\") {\n        // All piles have one box\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"zeros\") {\n        // All piles are empty except one pile with maximum boxes\n        int pos = rnd.next(0, n - 1);\n        a[pos] = maxA;\n    } else if (type == \"first_nonzero\") {\n        // Only the first pile has boxes\n        a[0] = maxA;\n    } else if (type == \"last_nonzero\") {\n        // Only the last pile has boxes\n        a[n - 1] = maxA;\n    } else if (type == \"alternating\") {\n        // Piles alternate between zero and maximum boxes\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = maxA;\n            } else {\n                a[i] = 0;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random number of boxes in each pile\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, maxA);\n        }\n    } else if (type == \"single_pile\") {\n        // Only one pile has boxes\n        int pos = rnd.next(0, n - 1);\n        a[pos] = maxA;\n    } else if (type == \"sparse\") {\n        // Few piles have boxes\n        int nonZeroPiles = opt<int>(\"nonZeroPiles\", n / 10);\n        set<int> positions;\n        while ((int)positions.size() < nonZeroPiles) {\n            positions.insert(rnd.next(0, n - 1));\n        }\n        for (int pos : positions) {\n            a[pos] = rnd.next(1, maxA);\n        }\n    } else if (type == \"dense\") {\n        // Most piles have boxes\n        int zeroPiles = opt<int>(\"zeroPiles\", n / 10);\n        set<int> positions;\n        while ((int)positions.size() < zeroPiles) {\n            positions.insert(rnd.next(0, n - 1));\n        }\n        for (int i = 0; i < n; ++i) {\n            if (positions.count(i)) {\n                a[i] = 0;\n            } else {\n                a[i] = rnd.next(1, maxA);\n            }\n        }\n    } else if (type == \"max_students\") {\n        // Maximum number of students\n        m = 100000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"min_students\") {\n        // Only one student\n        m = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxA);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, maxA);\n        }\n    }\n\n    // Ensure at least one pile has a box\n    int totalBoxes = accumulate(a.begin(), a.end(), 0LL);\n    if (totalBoxes == 0) {\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output ai's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");           // Number of piles\n    int m = opt<int>(\"m\");           // Number of students\n    int maxA = opt<int>(\"maxA\", 1e9); // Maximum value for ai\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    // Initialize variables\n    vector<int> a(n, 0);\n\n    if (type == \"max\") {\n        // All piles have maximum number of boxes\n        for (int i = 0; i < n; ++i) {\n            a[i] = maxA;\n        }\n    } else if (type == \"min\") {\n        // All piles have zero boxes except one pile with one box\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    } else if (type == \"ones\") {\n        // All piles have one box\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"zeros\") {\n        // All piles are empty except one pile with maximum boxes\n        int pos = rnd.next(0, n - 1);\n        a[pos] = maxA;\n    } else if (type == \"first_nonzero\") {\n        // Only the first pile has boxes\n        a[0] = maxA;\n    } else if (type == \"last_nonzero\") {\n        // Only the last pile has boxes\n        a[n - 1] = maxA;\n    } else if (type == \"alternating\") {\n        // Piles alternate between zero and maximum boxes\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = maxA;\n            } else {\n                a[i] = 0;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random number of boxes in each pile\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, maxA);\n        }\n    } else if (type == \"single_pile\") {\n        // Only one pile has boxes\n        int pos = rnd.next(0, n - 1);\n        a[pos] = maxA;\n    } else if (type == \"sparse\") {\n        // Few piles have boxes\n        int nonZeroPiles = opt<int>(\"nonZeroPiles\", n / 10);\n        set<int> positions;\n        while ((int)positions.size() < nonZeroPiles) {\n            positions.insert(rnd.next(0, n - 1));\n        }\n        for (int pos : positions) {\n            a[pos] = rnd.next(1, maxA);\n        }\n    } else if (type == \"dense\") {\n        // Most piles have boxes\n        int zeroPiles = opt<int>(\"zeroPiles\", n / 10);\n        set<int> positions;\n        while ((int)positions.size() < zeroPiles) {\n            positions.insert(rnd.next(0, n - 1));\n        }\n        for (int i = 0; i < n; ++i) {\n            if (positions.count(i)) {\n                a[i] = 0;\n            } else {\n                a[i] = rnd.next(1, maxA);\n            }\n        }\n    } else if (type == \"max_students\") {\n        // Maximum number of students\n        m = 100000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"min_students\") {\n        // Only one student\n        m = 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxA);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(0, maxA);\n        }\n    }\n\n    // Ensure at least one pile has a box\n    int totalBoxes = accumulate(a.begin(), a.end(), 0LL);\n    if (totalBoxes == 0) {\n        int pos = rnd.next(0, n - 1);\n        a[pos] = 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output ai's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -m 1 -maxA 10 -type min\n./gen -n 2 -m 1 -maxA 10 -type ones\n./gen -n 5 -m 2 -maxA 5 -type random\n\n# Edge cases with minimal values\n./gen -n 1 -m 1 -maxA 1 -type max\n./gen -n 1 -m 1 -maxA 1 -type zeros\n./gen -n 2 -m 1 -maxA 1 -type first_nonzero\n./gen -n 2 -m 1 -maxA 1 -type last_nonzero\n\n# Medium-sized test cases\n./gen -n 1000 -m 500 -maxA 1000 -type random\n./gen -n 1000 -m 500 -maxA 1000 -type alternating\n./gen -n 1000 -m 1000 -maxA 1000 -type ones\n\n# Large test cases with maximum values\n./gen -n 100000 -m 100000 -maxA 1000000000 -type max\n./gen -n 100000 -m 100000 -maxA 1000000000 -type random\n./gen -n 100000 -m 100000 -maxA 1000000000 -type alternating\n\n# Test cases with only one student\n./gen -n 100000 -m 1 -maxA 1000000000 -type max\n./gen -n 100000 -m 1 -maxA 1000000000 -type random\n\n# Test cases with maximum number of students\n./gen -n 100000 -m 100000 -maxA 1000000000 -type min_students\n./gen -n 100000 -m 100000 -maxA 1000000000 -type max_students\n\n# Test cases with only one pile having boxes\n./gen -n 100000 -m 50000 -maxA 1000000000 -type single_pile\n./gen -n 100000 -m 50000 -maxA 1000000000 -type zeros\n\n# Test cases with alternating zero and max piles\n./gen -n 100000 -m 50000 -maxA 1000000000 -type alternating\n\n# Sparse and dense distributions\n./gen -n 100000 -m 50000 -maxA 1000000000 -type sparse -nonZeroPiles 100\n./gen -n 100000 -m 50000 -maxA 1000000000 -type dense -zeroPiles 100\n\n# Test cases where only the first or last pile has boxes\n./gen -n 100000 -m 50000 -maxA 1000000000 -type first_nonzero\n./gen -n 100000 -m 50000 -maxA 1000000000 -type last_nonzero\n\n# Random test cases with varied maxA\n./gen -n 100000 -m 50000 -maxA 1 -type random\n./gen -n 100000 -m 50000 -maxA 1000 -type random\n./gen -n 100000 -m 50000 -maxA 1000000 -type random\n\n# All piles have one box\n./gen -n 100000 -m 50000 -maxA 1 -type ones\n\n# Test cases with m greater than n\n./gen -n 50000 -m 100000 -maxA 1000000000 -type random\n\n# Test cases with m less than n\n./gen -n 100000 -m 1000 -maxA 1000000000 -type random\n\n# Test cases with maximum ai values\n./gen -n 100000 -m 50000 -maxA 1000000000 -type max\n\n# Small n, large m\n./gen -n 10 -m 100000 -maxA 1000000000 -type random\n\n# Large n, small m\n./gen -n 100000 -m 10 -maxA 1000000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:49.042648",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "551/D",
      "title": "D. GukiZ and Binary Operations",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst and the only line of input contains four integers n, k, l, m (2 ≤ n ≤ 1018, 0 ≤ k ≤ 1018, 0 ≤ l ≤ 64, 1 ≤ m ≤ 109 + 7).",
      "output_spec": "OutputIn the single line print the number of arrays satisfying the condition above modulo m.",
      "sample_tests": "ExamplesInputCopy2 1 2 10OutputCopy3InputCopy2 1 1 3OutputCopy1InputCopy3 3 2 10OutputCopy9",
      "description": "D. GukiZ and Binary Operations\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst and the only line of input contains four integers n, k, l, m (2 ≤ n ≤ 1018, 0 ≤ k ≤ 1018, 0 ≤ l ≤ 64, 1 ≤ m ≤ 109 + 7).\n\nOutputIn the single line print the number of arrays satisfying the condition above modulo m.\n\nInputCopy2 1 2 10OutputCopy3InputCopy2 1 1 3OutputCopy1InputCopy3 3 2 10OutputCopy9\n\nInputCopy2 1 2 10\n\nOutputCopy3\n\nInputCopy2 1 1 3\n\nOutputCopy1\n\nInputCopy3 3 2 10\n\nOutputCopy9\n\nNoteIn the first sample, satisfying arrays are {1, 1}, {3, 1}, {1, 3}.In the second sample, only satisfying array is {1, 1}.In the third sample, satisfying arrays are {0, 3, 3}, {1, 3, 2}, {1, 3, 3}, {2, 3, 1}, {2, 3, 3}, {3, 3, 0}, {3, 3, 1}, {3, 3, 2}, {3, 3, 3}.",
      "solutions": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces",
          "content": "Hello Codeforces community !I am glad to announce Codeforces Round 307 (Div. 2) on 12th of June at 19:30 MSK. Authors of this contest are Nikola Mandic (nikola12345) and Aleksa Plavsic (allllekssssa). This is our first round and we really tried to make interesting and solvable problems. Traditionally Div.1 participants can take part out of the competition ( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes ). This is the first Serbian round and we want to invite our friends from Serbia to take part in this round and maybe prepare some of next rounds.The main character of this round is gonna be GukiZ ( our proffesor of computer science ). He really helps us to become better people and developers ! We want to thank Zlobober for help in preparing contest and great advices, Delinur for translating problems statements into Russian and MikeMirzayanov for fantastic Codeforces and Polygon platform !We wish you great fun, a lot of Successful hacks, Accepted solutions and high rating !UPD: Scoring distribution: 500 — 1250 — 1750 — 2000 — 2500.UPD2: Due to technical reasons round was delayed by 10 minutes. Stay tuned!UPD3: +5 minutes. Thanks for your patience!UPD4: System testing is complete, but the rating update won't be that fast since we are working on improving our cheater catching system. Thanks for your understanding!Congratulations to winners!DIV 1:1.MrDindows2.kennethsnow3.ecnerwala4.I_love_Tanya_Romanova5.Hasan0540DIV 2:1.hrzhrz_hrzhrz2.slo3.wangjing4.cyber_tourist5.Moose_LeeThanks to all participants. We hope you have a good time and learn something new.UPD5: Link of editorial !",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18473",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1673
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces",
          "content": "Problems proved to be much harder than we expected. There were some corner cases we didn't include in pretests, so many solutions failed, which was definitely a mistake. Anyway, I hope you find this problemset interesting!Problem A. GukiZ and ContestVery simple implementation problem. Just implement what is written in the statement: for every element of array, find the number of array elements greater than it, and add one to the sum. This can be easily done with two nested loops. Total complexity O(n2).Solution: linkProblem B. ZgukistringZFirst, calculate the number of occurences of every English letter in strings a, b, and c. We can now iterate by number of non-overlapping substrings of the resulting string equal to b, then we can calculate in constant time how many substrings equal to c can be formed (by simple operations on the number of occurences of English letters in c). In every iteration, maximise the sum of numbers of b and c. Number of iterations is not greater than |a|. At the end, we can easily build the resulting string by concatenating previously calculated number of strings b and c, and add the rest of the letters to get the string obtainable from a. Total complexity is O(|a| + |b| + |c|).Solution: linkProblem C. GukiZ hates BoxesProblem solution (complete work time) can be binary searched, because if the work can be done for some amount of time, it can certainly be done for greater amount of time. Let the current search time be k. We can determine if we can complete work for this time by folowing greedy algorithm: find last non-zero pile of boxes and calculate the time needed to get there (which is equal to it's index in array) and take with first man as much boxes as we can. If he can take even more boxes, find next non-zero (to the left) pile, and get as much boxes from it, and repete untill no time is left. When the first man does the job, repete the algorithm for next man, and when all m men did their maximum, if all boxes are removed we can decrease upper bound in binary search. Otherwise, we must increase lower bound. Total compexity is .Solution: linkProblem D. GukiZ and Binary OperationsFirst convert number k into binary number system. If some bit of k is 0 than the result of or opertion applied for every adjacent pair of those bits in array a must be 0, that is no two adjacent those bits in array a are 1. We should count how many times this is fulfilled. If the values were smaller we could count it with simply dpi = dpi - 1 + dpi - 2, where dpi is equal to number of ways to make array od i bits where no two are adjacent ones. With first values dp1 = 2 and dp2 = 3, we can see that this is ordinary Fibonacci number. We can calculate Fibonacci numbers up to 1018 easily by fast matrix multiplication. If some bit at k is 1 than number of ways is 2n — \\t{(number of ways bit is 0)}, which is also easy to calculate. We must be cearful for cases when 2l smaller than k (solution is 0 then) and when l = 63 or l = 64. Total complexity is .Solution: linkProblem E. GukiZ and GukiZianaFirst we divide array a in groups with numbers. Every group in each moment will be kept sorted. For type 1 query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it's current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let's handle with type 2 queries. When we want find GukiZiana(a, j), we search for the first and the last occurence of j by groups. One group can be binary searched in , because of sorted values, and most groups will be searched. Of course, for the first occurence we search for minimum index of value of j, and for the last occurence maximum index of value of j in array. When we find these 2 indexes, we must restore their original positions in array a and print their difference. If there is no occurence of j, print  - 1. Total complexity is .Solution: link",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4036
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 1",
          "code": "[user:Ghassan.Khazaal,2015-06-12] is the closest one to Div 1 :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 2",
          "code": "( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 3",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 4",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 5",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 6",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 7",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 8",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 9",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 10",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 13",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 14",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 15",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 16",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "aaaaaabbbbbb aab abb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "a_1+...+a_n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "O(m*log(a_1+...+a_n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "abbbaaccca ab aca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if ((new BigInteger(Long.toString(k))).testBit(bit))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (l < 63 && k >= (1L << l)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(2LL, 1000000000000000000LL, \"n\");  // 2 ≤ n ≤ 1e18\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");  // 0 ≤ k ≤ 1e18\n    inf.readSpace();\n    int l = inf.readInt(0, 64, \"l\");  // 0 ≤ l ≤ 64\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000007, \"m\");  // 1 ≤ m ≤ 1e9+7\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(2LL, 1000000000000000000LL, \"n\");  // 2 ≤ n ≤ 1e18\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");  // 0 ≤ k ≤ 1e18\n    inf.readSpace();\n    int l = inf.readInt(0, 64, \"l\");  // 0 ≤ l ≤ 64\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000007, \"m\");  // 1 ≤ m ≤ 1e9+7\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long n = inf.readLong(2LL, 1000000000000000000LL, \"n\");  // 2 ≤ n ≤ 1e18\n    inf.readSpace();\n    long long k = inf.readLong(0LL, 1000000000000000000LL, \"k\");  // 0 ≤ k ≤ 1e18\n    inf.readSpace();\n    int l = inf.readInt(0, 64, \"l\");  // 0 ≤ l ≤ 64\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000007, \"m\");  // 1 ≤ m ≤ 1e9+7\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    ll n = opt<ll>(\"n\", -1);\n    ll k = opt<ll>(\"k\", -1);\n    int l = opt<int>(\"l\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Initialize variables and constraints\n    const ll n_min = 2;\n    const ll n_max = (ll)1e18;\n    const ll k_min = 0;\n    const ll k_max_const = (ll)1e18;\n    const int l_min = 0;\n    const int l_max = 64;\n    const int m_min = 1;\n    const int m_max = (int)(1e9 + 7);\n    \n    // Set default values if not provided\n    if (n == -1) n = rnd.next(n_min, n_max);\n    if (l == -1) l = rnd.next(l_min, l_max);\n    if (m == -1) m = rnd.next(m_min, m_max);\n    \n    ll max_k;\n    if (l == 0) {\n        max_k = 0;\n    } else if (l >= 61) {\n        max_k = k_max_const;\n    } else {\n        max_k = min(k_max_const, (1LL << l) - 1);\n    }\n    \n    if (type == \"random\") {\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"max_n\") {\n        n = n_max;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"min_n\") {\n        n = n_min;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"l_zero\") {\n        l = 0;\n        max_k = 0;\n        if (k == -1 || k != 0)\n            k = 0;\n    } else if (type == \"l_max\") {\n        l = l_max;\n        max_k = k_max_const;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"k_zero\") {\n        k = 0;\n        if (l == -1)\n            l = rnd.next(1, l_max);\n    } else if (type == \"invalid_k\") {\n        if (l == -1)\n            l = rnd.next(l_min, 60);\n        if (l == 0)\n            k = 1;\n        else {\n            ll temp = (1LL << l);\n            k = temp + rnd.next(1LL, min(1000LL, k_max_const - temp));\n            if (k > k_max_const)\n                k = k_max_const;\n        }\n    } else if (type == \"l_near_64\") {\n        l = rnd.next(62, 64);\n        max_k = k_max_const;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"m_one\") {\n        m = 1;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"m_max\") {\n        m = m_max;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else {\n        // For other custom types, implement accordingly\n    }\n    \n    // Ensure variables are within constraints\n    n = max(n_min, min(n, n_max));\n    l = max(l_min, min(l, l_max));\n    m = max(m_min, min(m, m_max));\n    if (l == 0) {\n        max_k = 0;\n    } else if (l >= 61) {\n        max_k = k_max_const;\n    } else {\n        max_k = min(k_max_const, (1LL << l) - 1);\n    }\n    k = max(k_min, min(k, max_k));\n    \n    // Output test case\n    printf(\"%lld %lld %d %d\\n\", n, k, l, m);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    ll n = opt<ll>(\"n\", -1);\n    ll k = opt<ll>(\"k\", -1);\n    int l = opt<int>(\"l\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Initialize variables and constraints\n    const ll n_min = 2;\n    const ll n_max = (ll)1e18;\n    const ll k_min = 0;\n    const ll k_max_const = (ll)1e18;\n    const int l_min = 0;\n    const int l_max = 64;\n    const int m_min = 1;\n    const int m_max = (int)(1e9 + 7);\n    \n    // Set default values if not provided\n    if (n == -1) n = rnd.next(n_min, n_max);\n    if (l == -1) l = rnd.next(l_min, l_max);\n    if (m == -1) m = rnd.next(m_min, m_max);\n    \n    ll max_k;\n    if (l == 0) {\n        max_k = 0;\n    } else if (l >= 61) {\n        max_k = k_max_const;\n    } else {\n        max_k = min(k_max_const, (1LL << l) - 1);\n    }\n    \n    if (type == \"random\") {\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"max_n\") {\n        n = n_max;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"min_n\") {\n        n = n_min;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"l_zero\") {\n        l = 0;\n        max_k = 0;\n        if (k == -1 || k != 0)\n            k = 0;\n    } else if (type == \"l_max\") {\n        l = l_max;\n        max_k = k_max_const;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"k_zero\") {\n        k = 0;\n        if (l == -1)\n            l = rnd.next(1, l_max);\n    } else if (type == \"invalid_k\") {\n        if (l == -1)\n            l = rnd.next(l_min, 60);\n        if (l == 0)\n            k = 1;\n        else {\n            ll temp = (1LL << l);\n            k = temp + rnd.next(1LL, min(1000LL, k_max_const - temp));\n            if (k > k_max_const)\n                k = k_max_const;\n        }\n    } else if (type == \"l_near_64\") {\n        l = rnd.next(62, 64);\n        max_k = k_max_const;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"m_one\") {\n        m = 1;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else if (type == \"m_max\") {\n        m = m_max;\n        if (k == -1)\n            k = rnd.next(k_min, max_k);\n        else\n            k = min(max_k, max(k_min, k));\n    } else {\n        // For other custom types, implement accordingly\n    }\n    \n    // Ensure variables are within constraints\n    n = max(n_min, min(n, n_max));\n    l = max(l_min, min(l, l_max));\n    m = max(m_min, min(m, m_max));\n    if (l == 0) {\n        max_k = 0;\n    } else if (l >= 61) {\n        max_k = k_max_const;\n    } else {\n        max_k = min(k_max_const, (1LL << l) - 1);\n    }\n    k = max(k_min, min(k, max_k));\n    \n    // Output test case\n    printf(\"%lld %lld %d %d\\n\", n, k, l, m);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with default parameters\n./gen -type random\n\n# Test cases with minimum n\n./gen -type min_n\n./gen -type min_n -l 0\n./gen -type min_n -l 64\n./gen -type min_n -k 0\n./gen -type min_n -m 1\n\n# Test cases with maximum n\n./gen -type max_n\n./gen -type max_n -l 0\n./gen -type max_n -l 64\n./gen -type max_n -k 0\n./gen -type max_n -m 1000000007\n\n# Test cases with l = 0\n./gen -type l_zero\n./gen -type l_zero -n 100\n./gen -type l_zero -m 1\n\n# Test cases with l = 64\n./gen -type l_max\n./gen -type l_max -k 0\n./gen -type l_max -n 1000000000000000000\n\n# Test cases with k = 0\n./gen -type k_zero\n./gen -type k_zero -n 2\n./gen -type k_zero -l 64\n\n# Test cases with invalid k (k >= 2^l)\n./gen -type invalid_k\n./gen -type invalid_k -n 1000\n./gen -type invalid_k -l 15\n\n# Test cases with l near 64\n./gen -type l_near_64\n./gen -type l_near_64 -n 1000000\n./gen -type l_near_64 -k 0\n\n# Test cases with m = 1\n./gen -type m_one\n./gen -type m_one -n 1000000000000000000\n./gen -type m_one -k 0\n\n# Test cases with m at maximum\n./gen -type m_max\n./gen -type m_max -n 999999999999999999\n./gen -type m_max -k 1\n\n# Specific test cases\n./gen -n 2 -k 1 -l 2 -m 10       # First sample input\n./gen -n 2 -k 1 -l 1 -m 3        # Second sample input\n./gen -n 3 -k 3 -l 2 -m 10       # Third sample input\n./gen -n 1000000000000000000 -k 0 -l 64 -m 1000000007\n./gen -n 999999999999999999 -k 1e18 -l 63 -m 1\n./gen -type invalid_k -k 1000000000000000000\n./gen -n 500000000000000000 -k 0 -l 32 -m 998244353\n./gen -n 3 -k 7 -l 3 -m 10\n./gen -n 1000000 -k 0 -l 0 -m 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:50.919694",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "551/E",
      "title": "E. GukiZ and GukiZiana",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test10 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, q (1 ≤ n ≤ 5 * 105, 1 ≤ q ≤ 5 * 104), size of array a, and the number of queries. The second line contains n integers a1, a2, ... an (1 ≤ ai ≤ 109), forming an array a. Each of next q lines contain either four or two numbers, as described in statement:If line starts with 1, then the query looks like 1 l r x (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 109), first type query.If line starts with 2, then th query looks like 2 y (1 ≤ y ≤ 109), second type query.",
      "output_spec": "OutputFor each query of type 2, print the value of GukiZiana(a, y), for y value for that query.",
      "sample_tests": "ExamplesInputCopy4 31 2 3 41 1 2 11 1 1 12 3OutputCopy2InputCopy2 31 21 2 2 12 32 4OutputCopy0-1",
      "description": "E. GukiZ and GukiZiana\n\ntime limit per test10 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, q (1 ≤ n ≤ 5 * 105, 1 ≤ q ≤ 5 * 104), size of array a, and the number of queries. The second line contains n integers a1, a2, ... an (1 ≤ ai ≤ 109), forming an array a. Each of next q lines contain either four or two numbers, as described in statement:If line starts with 1, then the query looks like 1 l r x (1 ≤ l ≤ r ≤ n, 0 ≤ x ≤ 109), first type query.If line starts with 2, then th query looks like 2 y (1 ≤ y ≤ 109), second type query.\n\nOutputFor each query of type 2, print the value of GukiZiana(a, y), for y value for that query.\n\nInputCopy4 31 2 3 41 1 2 11 1 1 12 3OutputCopy2InputCopy2 31 21 2 2 12 32 4OutputCopy0-1\n\nInputCopy4 31 2 3 41 1 2 11 1 1 12 3\n\nOutputCopy2\n\nInputCopy2 31 21 2 2 12 32 4\n\nOutputCopy0-1",
      "solutions": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces",
          "content": "Hello Codeforces community !I am glad to announce Codeforces Round 307 (Div. 2) on 12th of June at 19:30 MSK. Authors of this contest are Nikola Mandic (nikola12345) and Aleksa Plavsic (allllekssssa). This is our first round and we really tried to make interesting and solvable problems. Traditionally Div.1 participants can take part out of the competition ( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes ). This is the first Serbian round and we want to invite our friends from Serbia to take part in this round and maybe prepare some of next rounds.The main character of this round is gonna be GukiZ ( our proffesor of computer science ). He really helps us to become better people and developers ! We want to thank Zlobober for help in preparing contest and great advices, Delinur for translating problems statements into Russian and MikeMirzayanov for fantastic Codeforces and Polygon platform !We wish you great fun, a lot of Successful hacks, Accepted solutions and high rating !UPD: Scoring distribution: 500 — 1250 — 1750 — 2000 — 2500.UPD2: Due to technical reasons round was delayed by 10 minutes. Stay tuned!UPD3: +5 minutes. Thanks for your patience!UPD4: System testing is complete, but the rating update won't be that fast since we are working on improving our cheater catching system. Thanks for your understanding!Congratulations to winners!DIV 1:1.MrDindows2.kennethsnow3.ecnerwala4.I_love_Tanya_Romanova5.Hasan0540DIV 2:1.hrzhrz_hrzhrz2.slo3.wangjing4.cyber_tourist5.Moose_LeeThanks to all participants. We hope you have a good time and learn something new.UPD5: Link of editorial !",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18473",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1673
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces",
          "content": "Problems proved to be much harder than we expected. There were some corner cases we didn't include in pretests, so many solutions failed, which was definitely a mistake. Anyway, I hope you find this problemset interesting!Problem A. GukiZ and ContestVery simple implementation problem. Just implement what is written in the statement: for every element of array, find the number of array elements greater than it, and add one to the sum. This can be easily done with two nested loops. Total complexity O(n2).Solution: linkProblem B. ZgukistringZFirst, calculate the number of occurences of every English letter in strings a, b, and c. We can now iterate by number of non-overlapping substrings of the resulting string equal to b, then we can calculate in constant time how many substrings equal to c can be formed (by simple operations on the number of occurences of English letters in c). In every iteration, maximise the sum of numbers of b and c. Number of iterations is not greater than |a|. At the end, we can easily build the resulting string by concatenating previously calculated number of strings b and c, and add the rest of the letters to get the string obtainable from a. Total complexity is O(|a| + |b| + |c|).Solution: linkProblem C. GukiZ hates BoxesProblem solution (complete work time) can be binary searched, because if the work can be done for some amount of time, it can certainly be done for greater amount of time. Let the current search time be k. We can determine if we can complete work for this time by folowing greedy algorithm: find last non-zero pile of boxes and calculate the time needed to get there (which is equal to it's index in array) and take with first man as much boxes as we can. If he can take even more boxes, find next non-zero (to the left) pile, and get as much boxes from it, and repete untill no time is left. When the first man does the job, repete the algorithm for next man, and when all m men did their maximum, if all boxes are removed we can decrease upper bound in binary search. Otherwise, we must increase lower bound. Total compexity is .Solution: linkProblem D. GukiZ and Binary OperationsFirst convert number k into binary number system. If some bit of k is 0 than the result of or opertion applied for every adjacent pair of those bits in array a must be 0, that is no two adjacent those bits in array a are 1. We should count how many times this is fulfilled. If the values were smaller we could count it with simply dpi = dpi - 1 + dpi - 2, where dpi is equal to number of ways to make array od i bits where no two are adjacent ones. With first values dp1 = 2 and dp2 = 3, we can see that this is ordinary Fibonacci number. We can calculate Fibonacci numbers up to 1018 easily by fast matrix multiplication. If some bit at k is 1 than number of ways is 2n — \\t{(number of ways bit is 0)}, which is also easy to calculate. We must be cearful for cases when 2l smaller than k (solution is 0 then) and when l = 63 or l = 64. Total complexity is .Solution: linkProblem E. GukiZ and GukiZianaFirst we divide array a in groups with numbers. Every group in each moment will be kept sorted. For type 1 query, If we update some interval, for each group, which is whole packed in the interval, we will add the number it is being increased to it's current increasing value (this means all the elements are increased by this number). If some part of group is covered by interval, update these elements and resort them. Now, let's handle with type 2 queries. When we want find GukiZiana(a, j), we search for the first and the last occurence of j by groups. One group can be binary searched in , because of sorted values, and most groups will be searched. Of course, for the first occurence we search for minimum index of value of j, and for the last occurence maximum index of value of j in array. When we find these 2 indexes, we must restore their original positions in array a and print their difference. If there is no occurence of j, print  - 1. Total complexity is .Solution: link",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18508",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4036
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 1",
          "code": "[user:Ghassan.Khazaal,2015-06-12] is the closest one to Div 1 :)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 2",
          "code": "( personally I believe that the problems are worth to Div 1 participants, and nobody can solve everything in 20 minutes )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 3",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 4",
          "code": "1) (a*b) mod m = ((a mod m) * (b mod m)) mod m.\n2) For an even b, (a ^ b) = (a ^ (b/2) ) * (a ^ (b/2)),\n   and for an odd b, (a^b) = a * (a ^ ((b-1) / 2)) * (a ^ ((b-1) / 2))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 5",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 6",
          "code": "aaabbbcd\nab\nbcd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 7",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 8",
          "code": "==> in <==\nababc\nbc\nba\n\n==> in2 <==\nababac\nabac\nba\n\n==> in3 <==\nabaabaabacc\naba\nca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 9",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 10",
          "code": "lo = 0   // the answer should be at least 0\nhi = a.length()+1  // the answer can't be larger than a.length()\nwhile (hi - lo > 1) \n\n    N = (hi + lo) / 2\n    doesThisNWork = false\n    for each numberOfStringBinA = 0 ... N\n       let numberOfStringCinA = N - numberOfStringBinA\n       good = true\n       for each character ch = 'a' ... 'z'\n           if ( (number of ch in string a) <\n                 numberOfStringBinA * (number of ch in string b) + \n                 numberOfStringCinA * (number of ch in string c) )\n                 good = false\n       if good\n            // we found a way to make numberOfStringBinA b's and\n            // numberOfStringCinA c's in string a.\n            doesThisNWork = true\n    if doesThisNWork\n         lo = N\n    else\n         hi = N",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = 0; i <= sz(a); i++){\n    bool ok = true;\n    for(int j = 0; j < 26; j++)\n      if(tmp[j] - i * usedB[j] >= 0)\n        tmp[j] -= i * usedB[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 13",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 14",
          "code": "Let a,b,c the input strings\nLet x the amount of only strings b in a.\nans = 0\nNow we can:\niterate for i=[0..x] \n   substract i strings from a. \n   let j = the amount of string c in the remain string. \n   if (i+j) > ans\n       //save results\nprint ans;\n\nI think this is the same that \nA >= i*(B)+j*(C)\nwhere A,B,C are column vectors (from string a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 15",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #307 (Div. 2) - Codeforces - Code 16",
          "code": "Thanks to all participants. We hope you have a good time and learn something new.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18473",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "boxes = array of boxes\nstudents = array of number of student at indices\nStart with all students at index=0 at t=1\nwhile(totalBoxes > 0) {\n for(i = n-1 to 0) {\n   b = boxes(i)\n   s = students(i)\n   boxesToRemove = min(b, s)\n   boxes(i) -= boxesToRemove\n   totalBoxes -= boxesToRemove\n   studentsToMove = s - boxesToRemove\n   students(i) -= studentsToMove\n   students(i+1) += studentsToMove\n }\n t += 1\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "fdto(i, min((ll)60, l-1), 0) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "fto(i, 0, l-1) {\n        if (s[i] == '0') ans=(ans*c0)%m;\n        else ans=(ans*c1)%m;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "aaaaaabbbbbb aab abb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "a_1+...+a_n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "O(m*log(a_1+...+a_n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "abbbaaccca ab aca",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "if ((k & (1L << bit)) != 0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "if ((new BigInteger(Long.toString(k))).testBit(bit))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int bit = 0; bit <= Math.min(l, 63); bit++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #307 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "if (l < 63 && k >= (1L << l)) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18508",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2);\n        if (type == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n);\n            inf.readSpace();\n            int r = inf.readInt(1, n);\n            ensuref(l <= r, \"In query %d, l (%d) > r (%d)\", i+1, l, r);\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000000);\n            inf.readEoln();\n        }\n        else {\n            inf.readSpace();\n            int y = inf.readInt(1, 1000000000);\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2);\n        if (type == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n);\n            inf.readSpace();\n            int r = inf.readInt(1, n);\n            ensuref(l <= r, \"In query %d, l (%d) > r (%d)\", i+1, l, r);\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000000);\n            inf.readEoln();\n        }\n        else {\n            inf.readSpace();\n            int y = inf.readInt(1, 1000000000);\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 500000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 50000, \"q\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    for (int i = 0; i < q; ++i) {\n        int type = inf.readInt(1, 2);\n        if (type == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n);\n            inf.readSpace();\n            int r = inf.readInt(1, n);\n            ensuref(l <= r, \"In query %d, l (%d) > r (%d)\", i+1, l, r);\n            inf.readSpace();\n            int x = inf.readInt(0, 1000000000);\n            inf.readEoln();\n        }\n        else {\n            inf.readSpace();\n            int y = inf.readInt(1, 1000000000);\n            inf.readEoln();\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Now, depending on type, generate data\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random a_i in [1, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"single_value\") {\n        // All a_i are the same value\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        // a_i = i\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // a_i = n - i\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"max\") {\n        // Maximize n and q\n        n = 500000;\n        q = 50000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"no_y\") {\n        // Generate a[] without certain y\n        int forbidden_y = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            do {\n                a[i] = rnd.next(1, 1000000000);\n            } while (a[i] == forbidden_y);\n        }\n    } else if (type == \"max_gukiziana\") {\n        // Create a[] where GukiZiana(a, y) = n - 1\n        int y = rnd.next(1, 1000000000);\n        a[0] = y;\n        a[n - 1] = y;\n        for (int i = 1; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"min_gukiziana\") {\n        // Create a[] where GukiZiana(a, y) = 0\n        int y = rnd.next(1, 1000000000);\n        int i = rnd.next(0, n - 2);\n        a[i] = y;\n        a[i + 1] = y;\n        for (int j = 0; j < n; ++j) {\n            if (j != i && j != i + 1) {\n                do {\n                    a[j] = rnd.next(1, 1000000000);\n                } while (a[j] == y);\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output a_1 to a_n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Now generate q queries\n    vector<string> queries;\n\n    if (type == \"constant_queries\") {\n        // All queries are of type 2, with same y\n        int y = rnd.next(1, 1000000000);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(y));\n        }\n    } else if (type == \"max_updates\") {\n        // All queries are type 1, updating the entire array\n        for (int i = 0; i < q; ++i) {\n            int l = 1;\n            int r = n;\n            int x = rnd.next(0, 1000000000);\n            queries.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n        }\n    } else if (type == \"no_y\") {\n        // All queries are type 2 with forbidden_y\n        int forbidden_y = rnd.next(1, 1000000000);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(forbidden_y));\n        }\n    } else if (type == \"max_gukiziana\") {\n        // Queries to test max difference\n        int y = a[0];\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(y));\n        }\n    } else if (type == \"min_gukiziana\") {\n        // Queries to test min difference\n        int y = a[rnd.next(0, n - 1)];\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(y));\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2); // 1 or 2\n\n            if (t == 1) {\n                // Query type 1\n                int l = rnd.next(1, n);\n                int r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n                int x = rnd.next(0, 1000000000);\n                queries.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                // Query type 2\n                int y = rnd.next(1, 1000000000);\n                queries.push_back(\"2 \" + to_string(y));\n            }\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Now, depending on type, generate data\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Generate random a_i in [1, 1e9]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"single_value\") {\n        // All a_i are the same value\n        int val = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = val;\n        }\n    } else if (type == \"increasing\") {\n        // a_i = i\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (type == \"decreasing\") {\n        // a_i = n - i\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else if (type == \"max\") {\n        // Maximize n and q\n        n = 500000;\n        q = 50000;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"no_y\") {\n        // Generate a[] without certain y\n        int forbidden_y = rnd.next(1, 1000000000);\n        for (int i = 0; i < n; ++i) {\n            do {\n                a[i] = rnd.next(1, 1000000000);\n            } while (a[i] == forbidden_y);\n        }\n    } else if (type == \"max_gukiziana\") {\n        // Create a[] where GukiZiana(a, y) = n - 1\n        int y = rnd.next(1, 1000000000);\n        a[0] = y;\n        a[n - 1] = y;\n        for (int i = 1; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    } else if (type == \"min_gukiziana\") {\n        // Create a[] where GukiZiana(a, y) = 0\n        int y = rnd.next(1, 1000000000);\n        int i = rnd.next(0, n - 2);\n        a[i] = y;\n        a[i + 1] = y;\n        for (int j = 0; j < n; ++j) {\n            if (j != i && j != i + 1) {\n                do {\n                    a[j] = rnd.next(1, 1000000000);\n                } while (a[j] == y);\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 1000000000);\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output a_1 to a_n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    // Now generate q queries\n    vector<string> queries;\n\n    if (type == \"constant_queries\") {\n        // All queries are of type 2, with same y\n        int y = rnd.next(1, 1000000000);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(y));\n        }\n    } else if (type == \"max_updates\") {\n        // All queries are type 1, updating the entire array\n        for (int i = 0; i < q; ++i) {\n            int l = 1;\n            int r = n;\n            int x = rnd.next(0, 1000000000);\n            queries.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n        }\n    } else if (type == \"no_y\") {\n        // All queries are type 2 with forbidden_y\n        int forbidden_y = rnd.next(1, 1000000000);\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(forbidden_y));\n        }\n    } else if (type == \"max_gukiziana\") {\n        // Queries to test max difference\n        int y = a[0];\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(y));\n        }\n    } else if (type == \"min_gukiziana\") {\n        // Queries to test min difference\n        int y = a[rnd.next(0, n - 1)];\n        for (int i = 0; i < q; ++i) {\n            queries.push_back(\"2 \" + to_string(y));\n        }\n    } else {\n        for (int i = 0; i < q; ++i) {\n            int t = rnd.next(1, 2); // 1 or 2\n\n            if (t == 1) {\n                // Query type 1\n                int l = rnd.next(1, n);\n                int r = rnd.next(1, n);\n                if (l > r) swap(l, r);\n                int x = rnd.next(0, 1000000000);\n                queries.push_back(\"1 \" + to_string(l) + \" \" + to_string(r) + \" \" + to_string(x));\n            } else {\n                // Query type 2\n                int y = rnd.next(1, 1000000000);\n                queries.push_back(\"2 \" + to_string(y));\n            }\n        }\n    }\n\n    // Output queries\n    for (int i = 0; i < q; ++i) {\n        printf(\"%s\\n\", queries[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 1 -q 1 -type random\n./gen -n 10 -q 10 -type random\n./gen -n 100 -q 100 -type random\n\n# Max size test cases\n./gen -n 500000 -q 50000 -type random\n./gen -n 500000 -q 50000 -type max\n\n# Single value test cases\n./gen -n 100000 -q 10000 -type single_value\n\n# Increasing sequence\n./gen -n 100000 -q 10000 -type increasing\n\n# Decreasing sequence\n./gen -n 100000 -q 10000 -type decreasing\n\n# Test no_y cases\n./gen -n 100000 -q 10000 -type no_y\n\n# Test max_gukiziana cases\n./gen -n 100000 -q 10000 -type max_gukiziana\n\n# Test min_gukiziana cases\n./gen -n 100000 -q 10000 -type min_gukiziana\n\n# Test constant queries\n./gen -n 100000 -q 10000 -type constant_queries\n\n# Test max_updates\n./gen -n 100000 -q 10000 -type max_updates\n\n# Vary n and q to cover variety\n./gen -n 1 -q 1 -type single_value\n./gen -n 2 -q 2 -type max_gukiziana\n\n./gen -n 1000 -q 1000 -type random\n./gen -n 1000 -q 1000 -type no_y\n\n./gen -n 500000 -q 50000 -type max_updates\n./gen -n 500000 -q 50000 -type constant_queries\n\n./gen -n 500000 -q 10000 -type increasing\n./gen -n 500000 -q 10000 -type decreasing\n\n./gen -n 10 -q 10 -type random\n./gen -n 50 -q 50 -type random\n\n./gen -n 123456 -q 12345 -type random\n\n# Additional cases\n./gen -n 10000 -q 5000 -type max_gukiziana\n./gen -n 10000 -q 5000 -type min_gukiziana\n./gen -n 10000 -q 5000 -type no_y\n./gen -n 500000 -q 50000 -type random\n./gen -n 500000 -q 50000 -type decreasing\n./gen -n 100000 -q 50000 -type constant_queries\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:53.420958",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "552/A",
      "title": "A. Vanya and Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of rectangles.Each of the following n lines contains four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ 100, 1 ≤ y1 ≤ y2 ≤ 100), where x1 and y1 are the number of the column and row of the lower left cell and x2 and y2 are the number of the column and row of the upper right cell of a rectangle.",
      "output_spec": "OutputIn a single line print the sum of all values in the cells of the table.",
      "sample_tests": "ExamplesInputCopy21 1 2 32 2 3 3OutputCopy10InputCopy21 1 3 31 1 3 3OutputCopy18",
      "description": "A. Vanya and Table\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of rectangles.Each of the following n lines contains four integers x1, y1, x2, y2 (1 ≤ x1 ≤ x2 ≤ 100, 1 ≤ y1 ≤ y2 ≤ 100), where x1 and y1 are the number of the column and row of the lower left cell and x2 and y2 are the number of the column and row of the upper right cell of a rectangle.\n\nOutputIn a single line print the sum of all values in the cells of the table.\n\nInputCopy21 1 2 32 2 3 3OutputCopy10InputCopy21 1 3 31 1 3 3OutputCopy18\n\nInputCopy21 1 2 32 2 3 3\n\nOutputCopy10\n\nInputCopy21 1 3 31 1 3 3\n\nOutputCopy18\n\nNoteNote to the first sample test:Values of the table in the first three rows and columns will be as follows:121121110So, the sum of values will be equal to 10.Note to the second sample test:Values of the table in the first three rows and columns will be as follows:222222222So, the sum of values will be equal to 18.",
      "solutions": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #308 for participants from the second division will take place on 18 June, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my second round on Codeforces(First round — Codeforces Round 280 (Div. 2)). Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard: 500-1000-1500-2000-2500.UPD: Congratulation to the winners: Ttocs45 RNS_JKS RNS_CUS kouekosita grenade UPD: Contest is over. Thanks for participating :)UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18659",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 825
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces",
          "content": "552A - Vanya and TableIn this problem we can get AC with many solutions:1) With every new rectangle we will add his area to the result, so for each line x1, y1, x2, y2 we will add to answer (x2 - x1 + 1) * (y2 - y1 + 1)Time complexity O(n).2) We can just do all, that is written in the statement: create an array and with each new rectangle we can just increment every element inside rectangle. In the end we can just add all elements inside this array.Time complexity O(n * x * y)C++ code Wild_Hamster Java code Wild_HamsterPython code Zlobober 552B - Vanya and BooksWe can find out a formula for this problem:for n < 10 answer will be n = n - 1 + 1 = 1 * (n + 1) - 1;for n < 100 answer will be 2 * (n - 9) + 9 = 2 * n - 9 = 2 * n - 10 - 1 + 2 = 2 * (n + 1) - 11;for n < 1000 answer will be 3 * (n - 99) + 2 * (99 - 9) + 9 = 3 * n - 99 - 9 = 3 * n - 100 - 10 - 1 + 3 = 3 * (n + 1) - 111;so for n < 10sz answer will be ;Time complexity O(sz), where sz is the length of n.We also could just try 10 options n < 10, n < 100, ..., n < 109, n = 109 and solve problem for each option.UPD: Don't use function pow() to find powers of 10, because it doesn't work right sometimes.C++ code Wild_HamsterJava code Wild_HamsterPython code Zlobober552C - Vanya and ScalesConvert m to number system of base w. If all digits of number – 0 or 1, then we can measure the weight of the item with putting weights, that have digits equal to 1, on one pan, and our item on another one.If this condition isn't satisfied, then we should iterate from lower digit to high and if digit is not equal to 0 or 1, we try to substract w from it and increment higher digit. If it becomes equal to  - 1, then we can put weight with number of this digit on the same pan with our item, if it becomes equal to 0, then we don't put weight, in another case we can't measure the weight of our item and answer is .Time complexity O(logm).C++ code Wild_HamsterJava code Wild_HamsterJava code Zlobober552D - Vanya and TrianglesWe can look through all pair of points, draw line through each pair and write, that this line includes these 2 points. We can do it with map. If some line includes x points, then in fact we counted, that it has 2 * x * (x - 1) points, because we included each point 2*(x-1) times in this line.We can create an array and add to him values b[2 * x * (x - 1)] = x, so we can define, how many points is on the line. Then we can iterate through all lanes and for each line with x points we will loose x * (x - 1) * (x - 2) / 6 possible triangles from all possible n * (n - 1) * (n - 2) / 6 triangles. Decide, that at first ans = n * (n - 1) * (n - 2) / 6. So for every line, that includes x points, we will substract x * (x - 1) * (x - 2) / 6 from ans.Time complexity O(n2 * logn).C++11 code Wild_HamsterJava code Wild_HamsterJava code ZloboberUPD: I am sorry, that O(n3 / 6) solutions passed, my solution with O(n3 / 6) didn't pass before the contest, so I decided, that TL 4 sec is good(it was for Java TL).552E - Vanya and BracketsWe can see, that we can reach maximal answer, when brackets will be between two signs  * , or between one sign  *  and the end of expression. For convenience we will add in the begin of expression 1 * , and in the end of expression  * 1.After that we can iterate all possible pairs of signs  *  and count the expression with putting brackets between two signs  *  for each pair.We can use two variables x and y to count the value of expression, in the begin x = 0, y = firstnumber, where firstnumber is first digit of expression, then if next sign is  + , then x = y, y = nextnumber, and if next sign is  * , then x = x, y = y * nextnumber. The value of expression will be x + y, we can create function, like that, to count expressions inside and outside the brackets.Time complexity O(|s| * 172).C++ code Wild_HamsterJava code Wild_HamsterJava code ZloboberP.S. Sorry for my bad english, I will try to correct mistakes in the near time.UPD: Editorial from hsk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 552\\s*A"
          },
          "content_length": 3972
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 1",
          "code": "long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 2",
          "code": "res += (n-99999999) * 9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 3",
          "code": "res += (n-999999999) * 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 4",
          "code": "n = 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 5",
          "code": "(n-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 6",
          "code": "= (999999999-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 7",
          "code": "= (900000000) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 8",
          "code": "= 8100000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 9",
          "code": "long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 10",
          "code": "long long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 11",
          "code": "Happy Coding!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 12",
          "code": "(long long int)pow(10,(double)x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "ceil(pow(a,b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "(pow(a,b)+0.01)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "w^1, w^2, w^3, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "position_of_found_sum & i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Dynamic Programming",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "SQRT Decomposition",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int x1 = inf.readInt(1, 100, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, 100, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, 100, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, 100, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 <= x2, \"x1(%d) should be <= x2(%d)\", x1, x2);\n        ensuref(y1 <= y2, \"y1(%d) should be <= y2(%d)\", y1, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int x1 = inf.readInt(1, 100, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, 100, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, 100, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, 100, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 <= x2, \"x1(%d) should be <= x2(%d)\", x1, x2);\n        ensuref(y1 <= y2, \"y1(%d) should be <= y2(%d)\", y1, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int x1 = inf.readInt(1, 100, \"x1\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, 100, \"y1\");\n        inf.readSpace();\n        int x2 = inf.readInt(1, 100, \"x2\");\n        inf.readSpace();\n        int y2 = inf.readInt(1, 100, \"y2\");\n        inf.readEoln();\n\n        ensuref(x1 <= x2, \"x1(%d) should be <= x2(%d)\", x1, x2);\n        ensuref(y1 <= y2, \"y1(%d) should be <= y2(%d)\", y1, y2);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = rnd.next(x1, 100);\n            int y1 = rnd.next(1, 100);\n            int y2 = rnd.next(y1, 100);\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"full\") {\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1 100 100\\n\");\n        }\n    } else if (type == \"overlap\") {\n        int x1 = rnd.next(1, 50);\n        int y1 = rnd.next(1, 50);\n        int x2 = rnd.next(x1, 100);\n        int y2 = rnd.next(y1, 100);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"single_cell\") {\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            printf(\"%d %d %d %d\\n\", x, y, x, y);\n        }\n    } else if (type == \"line_x\") {\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = x1;\n            int y1 = rnd.next(1, 100);\n            int y2 = rnd.next(y1, 100);\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"line_y\") {\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = rnd.next(x1, 100);\n            int y1 = rnd.next(1, 100);\n            int y2 = y1;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"corners\") {\n        // Generate rectangles covering each corner\n        printf(\"1 1 1 1\\n\"); // Bottom-left corner\n        printf(\"100 1 100 1\\n\"); // Bottom-right corner\n        printf(\"1 100 1 100\\n\"); // Top-left corner\n        printf(\"100 100 100 100\\n\"); // Top-right corner\n        for (int i = 4; i < n; ++i) {\n            // Fill the rest with random single cells\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            printf(\"%d %d %d %d\\n\", x, y, x, y);\n        }\n    } else if (type == \"edges\") {\n        // Generate rectangles along the edges\n        printf(\"1 1 100 1\\n\"); // Bottom edge\n        printf(\"1 100 100 100\\n\"); // Top edge\n        printf(\"1 1 1 100\\n\"); // Left edge\n        printf(\"100 1 100 100\\n\"); // Right edge\n        for (int i = 4; i < n; ++i) {\n            // Fill the rest with random lines\n            int axis = rnd.next(0, 1);\n            if (axis == 0) {\n                // Line along x-axis\n                int y = rnd.next(1, 100);\n                printf(\"1 %d 100 %d\\n\", y, y);\n            } else {\n                // Line along y-axis\n                int x = rnd.next(1, 100);\n                printf(\"%d 1 %d 100\\n\", x, x);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = rnd.next(x1, 100);\n            int y1 = rnd.next(1, 100);\n            int y2 = rnd.next(y1, 100);\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = rnd.next(x1, 100);\n            int y1 = rnd.next(1, 100);\n            int y2 = rnd.next(y1, 100);\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"full\") {\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1 100 100\\n\");\n        }\n    } else if (type == \"overlap\") {\n        int x1 = rnd.next(1, 50);\n        int y1 = rnd.next(1, 50);\n        int x2 = rnd.next(x1, 100);\n        int y2 = rnd.next(y1, 100);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"single_cell\") {\n        for (int i = 0; i < n; ++i) {\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            printf(\"%d %d %d %d\\n\", x, y, x, y);\n        }\n    } else if (type == \"line_x\") {\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = x1;\n            int y1 = rnd.next(1, 100);\n            int y2 = rnd.next(y1, 100);\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"line_y\") {\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = rnd.next(x1, 100);\n            int y1 = rnd.next(1, 100);\n            int y2 = y1;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    } else if (type == \"corners\") {\n        // Generate rectangles covering each corner\n        printf(\"1 1 1 1\\n\"); // Bottom-left corner\n        printf(\"100 1 100 1\\n\"); // Bottom-right corner\n        printf(\"1 100 1 100\\n\"); // Top-left corner\n        printf(\"100 100 100 100\\n\"); // Top-right corner\n        for (int i = 4; i < n; ++i) {\n            // Fill the rest with random single cells\n            int x = rnd.next(1, 100);\n            int y = rnd.next(1, 100);\n            printf(\"%d %d %d %d\\n\", x, y, x, y);\n        }\n    } else if (type == \"edges\") {\n        // Generate rectangles along the edges\n        printf(\"1 1 100 1\\n\"); // Bottom edge\n        printf(\"1 100 100 100\\n\"); // Top edge\n        printf(\"1 1 1 100\\n\"); // Left edge\n        printf(\"100 1 100 100\\n\"); // Right edge\n        for (int i = 4; i < n; ++i) {\n            // Fill the rest with random lines\n            int axis = rnd.next(0, 1);\n            if (axis == 0) {\n                // Line along x-axis\n                int y = rnd.next(1, 100);\n                printf(\"1 %d 100 %d\\n\", y, y);\n            } else {\n                // Line along y-axis\n                int x = rnd.next(1, 100);\n                printf(\"%d 1 %d 100\\n\", x, x);\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            int x1 = rnd.next(1, 100);\n            int x2 = rnd.next(x1, 100);\n            int y1 = rnd.next(1, 100);\n            int y2 = rnd.next(y1, 100);\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test with minimum n and random rectangles\n./gen -n 1 -type random\n\n# Test with small n and random rectangles\n./gen -n 5 -type random\n\n# Test with maximum n and random rectangles\n./gen -n 100 -type random\n\n# Test with n rectangles covering the entire table\n./gen -n 1 -type full\n./gen -n 10 -type full\n./gen -n 100 -type full\n\n# Test with overlapping rectangles\n./gen -n 5 -type overlap\n./gen -n 50 -type overlap\n./gen -n 100 -type overlap\n\n# Test with single-cell rectangles\n./gen -n 10 -type single_cell\n./gen -n 50 -type single_cell\n./gen -n 100 -type single_cell\n\n# Test with lines along the x-axis\n./gen -n 10 -type line_x\n./gen -n 50 -type line_x\n./gen -n 100 -type line_x\n\n# Test with lines along the y-axis\n./gen -n 10 -type line_y\n./gen -n 50 -type line_y\n./gen -n 100 -type line_y\n\n# Test with rectangles covering corners\n./gen -n 4 -type corners\n./gen -n 10 -type corners\n\n# Test with rectangles covering edges\n./gen -n 4 -type edges\n./gen -n 20 -type edges\n\n# Mixed test cases\n./gen -n 20 -type random\n./gen -n 20 -type overlap\n./gen -n 20 -type single_cell\n./gen -n 20 -type line_x\n./gen -n 20 -type line_y\n./gen -n 20 -type corners\n./gen -n 20 -type edges\n\n# Test with n=100 and mixed types\n./gen -n 100 -type random\n./gen -n 100 -type overlap\n./gen -n 100 -type single_cell\n./gen -n 100 -type line_x\n./gen -n 100 -type line_y\n./gen -n 100 -type corners\n./gen -n 100 -type edges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:55.135204",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "552/B",
      "title": "B. Vanya and Books",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 109) — the number of books in the library.",
      "output_spec": "OutputPrint the number of digits needed to number all the books.",
      "sample_tests": "ExamplesInputCopy13OutputCopy17InputCopy4OutputCopy4",
      "description": "B. Vanya and Books\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 109) — the number of books in the library.\n\nOutputPrint the number of digits needed to number all the books.\n\nInputCopy13OutputCopy17InputCopy4OutputCopy4\n\nInputCopy13\n\nOutputCopy17\n\nOutputCopy4\n\nNoteNote to the first test. The books get numbers 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, which totals to 17 digits.Note to the second sample. The books get numbers 1, 2, 3, 4, which totals to 4 digits.",
      "solutions": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #308 for participants from the second division will take place on 18 June, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my second round on Codeforces(First round — Codeforces Round 280 (Div. 2)). Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard: 500-1000-1500-2000-2500.UPD: Congratulation to the winners: Ttocs45 RNS_JKS RNS_CUS kouekosita grenade UPD: Contest is over. Thanks for participating :)UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18659",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 825
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces",
          "content": "552A - Vanya and TableIn this problem we can get AC with many solutions:1) With every new rectangle we will add his area to the result, so for each line x1, y1, x2, y2 we will add to answer (x2 - x1 + 1) * (y2 - y1 + 1)Time complexity O(n).2) We can just do all, that is written in the statement: create an array and with each new rectangle we can just increment every element inside rectangle. In the end we can just add all elements inside this array.Time complexity O(n * x * y)C++ code Wild_Hamster Java code Wild_HamsterPython code Zlobober 552B - Vanya and BooksWe can find out a formula for this problem:for n < 10 answer will be n = n - 1 + 1 = 1 * (n + 1) - 1;for n < 100 answer will be 2 * (n - 9) + 9 = 2 * n - 9 = 2 * n - 10 - 1 + 2 = 2 * (n + 1) - 11;for n < 1000 answer will be 3 * (n - 99) + 2 * (99 - 9) + 9 = 3 * n - 99 - 9 = 3 * n - 100 - 10 - 1 + 3 = 3 * (n + 1) - 111;so for n < 10sz answer will be ;Time complexity O(sz), where sz is the length of n.We also could just try 10 options n < 10, n < 100, ..., n < 109, n = 109 and solve problem for each option.UPD: Don't use function pow() to find powers of 10, because it doesn't work right sometimes.C++ code Wild_HamsterJava code Wild_HamsterPython code Zlobober552C - Vanya and ScalesConvert m to number system of base w. If all digits of number – 0 or 1, then we can measure the weight of the item with putting weights, that have digits equal to 1, on one pan, and our item on another one.If this condition isn't satisfied, then we should iterate from lower digit to high and if digit is not equal to 0 or 1, we try to substract w from it and increment higher digit. If it becomes equal to  - 1, then we can put weight with number of this digit on the same pan with our item, if it becomes equal to 0, then we don't put weight, in another case we can't measure the weight of our item and answer is .Time complexity O(logm).C++ code Wild_HamsterJava code Wild_HamsterJava code Zlobober552D - Vanya and TrianglesWe can look through all pair of points, draw line through each pair and write, that this line includes these 2 points. We can do it with map. If some line includes x points, then in fact we counted, that it has 2 * x * (x - 1) points, because we included each point 2*(x-1) times in this line.We can create an array and add to him values b[2 * x * (x - 1)] = x, so we can define, how many points is on the line. Then we can iterate through all lanes and for each line with x points we will loose x * (x - 1) * (x - 2) / 6 possible triangles from all possible n * (n - 1) * (n - 2) / 6 triangles. Decide, that at first ans = n * (n - 1) * (n - 2) / 6. So for every line, that includes x points, we will substract x * (x - 1) * (x - 2) / 6 from ans.Time complexity O(n2 * logn).C++11 code Wild_HamsterJava code Wild_HamsterJava code ZloboberUPD: I am sorry, that O(n3 / 6) solutions passed, my solution with O(n3 / 6) didn't pass before the contest, so I decided, that TL 4 sec is good(it was for Java TL).552E - Vanya and BracketsWe can see, that we can reach maximal answer, when brackets will be between two signs  * , or between one sign  *  and the end of expression. For convenience we will add in the begin of expression 1 * , and in the end of expression  * 1.After that we can iterate all possible pairs of signs  *  and count the expression with putting brackets between two signs  *  for each pair.We can use two variables x and y to count the value of expression, in the begin x = 0, y = firstnumber, where firstnumber is first digit of expression, then if next sign is  + , then x = y, y = nextnumber, and if next sign is  * , then x = x, y = y * nextnumber. The value of expression will be x + y, we can create function, like that, to count expressions inside and outside the brackets.Time complexity O(|s| * 172).C++ code Wild_HamsterJava code Wild_HamsterJava code ZloboberP.S. Sorry for my bad english, I will try to correct mistakes in the near time.UPD: Editorial from hsk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 552\\s*B"
          },
          "content_length": 3972
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 1",
          "code": "long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 2",
          "code": "res += (n-99999999) * 9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 3",
          "code": "res += (n-999999999) * 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 4",
          "code": "n = 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 5",
          "code": "(n-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 6",
          "code": "= (999999999-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 7",
          "code": "= (900000000) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 8",
          "code": "= 8100000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 9",
          "code": "long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 10",
          "code": "long long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 11",
          "code": "Happy Coding!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 12",
          "code": "(long long int)pow(10,(double)x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "ceil(pow(a,b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "(pow(a,b)+0.01)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "w^1, w^2, w^3, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "position_of_found_sum & i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Dynamic Programming",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "SQRT Decomposition",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n; // n comes from 1 to 10^9\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"power10\") {\n        // Randomly pick k from 1 to 9\n        int k = rnd.next(1, 9);\n        int tenk = 1;\n        while (k--) tenk *= 10;\n        n = tenk;\n    } else if (type == \"beforepower\") {\n        int k = rnd.next(1, 9);\n        int tenk = 1;\n        for(int i = 0; i < k; i++) tenk *= 10;\n        n = tenk - 1;\n    } else if (type == \"afterpower\") {\n        int k = rnd.next(1, 9);\n        int tenk = 1;\n        for(int i = 0; i < k; i++) tenk *= 10;\n        n = tenk + 1;\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"middle\") {\n        n = 500000000;\n    } else if (type == \"large_random\") {\n        n = rnd.next(100000000, 1000000000);\n    } else if (type == \"small_random\") {\n        n = rnd.next(1, 100);\n    } else if (type == \"single_digit\") {\n        n = rnd.next(1, 9);\n    } else if (type == \"double_digit\") {\n        n = rnd.next(10, 99);\n    } else if (type == \"triple_digit\") {\n        n = rnd.next(100, 999);\n    } else if (type == \"near_max\") {\n        n = 1000000000 - rnd.next(0, 10);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000000000);\n    } else {\n        // Default to random\n        n = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n; // n comes from 1 to 10^9\n\n    if (type == \"min\") {\n        n = 1;\n    } else if (type == \"max\") {\n        n = 1000000000;\n    } else if (type == \"power10\") {\n        // Randomly pick k from 1 to 9\n        int k = rnd.next(1, 9);\n        int tenk = 1;\n        while (k--) tenk *= 10;\n        n = tenk;\n    } else if (type == \"beforepower\") {\n        int k = rnd.next(1, 9);\n        int tenk = 1;\n        for(int i = 0; i < k; i++) tenk *= 10;\n        n = tenk - 1;\n    } else if (type == \"afterpower\") {\n        int k = rnd.next(1, 9);\n        int tenk = 1;\n        for(int i = 0; i < k; i++) tenk *= 10;\n        n = tenk + 1;\n        if (n > 1000000000) n = 1000000000;\n    } else if (type == \"middle\") {\n        n = 500000000;\n    } else if (type == \"large_random\") {\n        n = rnd.next(100000000, 1000000000);\n    } else if (type == \"small_random\") {\n        n = rnd.next(1, 100);\n    } else if (type == \"single_digit\") {\n        n = rnd.next(1, 9);\n    } else if (type == \"double_digit\") {\n        n = rnd.next(10, 99);\n    } else if (type == \"triple_digit\") {\n        n = rnd.next(100, 999);\n    } else if (type == \"near_max\") {\n        n = 1000000000 - rnd.next(0, 10);\n    } else if (type == \"random\") {\n        n = rnd.next(1, 1000000000);\n    } else {\n        // Default to random\n        n = rnd.next(1, 1000000000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type small_random\n./gen -type small_random\n./gen -type large_random\n./gen -type large_random\n./gen -type single_digit\n./gen -type single_digit\n./gen -type double_digit\n./gen -type double_digit\n./gen -type triple_digit\n./gen -type triple_digit\n./gen -type power10\n./gen -type power10\n./gen -type beforepower\n./gen -type beforepower\n./gen -type afterpower\n./gen -type afterpower\n./gen -type near_max\n./gen -type near_max\n./gen -type middle\n./gen -type middle\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:57.329708",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "552/C",
      "title": "C. Vanya and Scales",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers w, m (2 ≤ w ≤ 109, 1 ≤ m ≤ 109) — the number defining the masses of the weights and the mass of the item.",
      "output_spec": "OutputPrint word 'YES' if the item can be weighted and 'NO' if it cannot.",
      "sample_tests": "ExamplesInputCopy3 7OutputCopyYESInputCopy100 99OutputCopyYESInputCopy100 50OutputCopyNO",
      "description": "C. Vanya and Scales\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers w, m (2 ≤ w ≤ 109, 1 ≤ m ≤ 109) — the number defining the masses of the weights and the mass of the item.\n\nOutputPrint word 'YES' if the item can be weighted and 'NO' if it cannot.\n\nInputCopy3 7OutputCopyYESInputCopy100 99OutputCopyYESInputCopy100 50OutputCopyNO\n\nInputCopy3 7\n\nOutputCopyYES\n\nInputCopy100 99\n\nOutputCopyYES\n\nInputCopy100 50\n\nOutputCopyNO\n\nNoteNote to the first sample test. One pan can have an item of mass 7 and a weight of mass 3, and the second pan can have two weights of masses 9 and 1, correspondingly. Then 7 + 3 = 9 + 1.Note to the second sample test. One pan of the scales can have an item of mass 99 and the weight of mass 1, and the second pan can have the weight of mass 100.Note to the third sample test. It is impossible to measure the weight of the item in the manner described in the input.",
      "solutions": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #308 for participants from the second division will take place on 18 June, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my second round on Codeforces(First round — Codeforces Round 280 (Div. 2)). Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard: 500-1000-1500-2000-2500.UPD: Congratulation to the winners: Ttocs45 RNS_JKS RNS_CUS kouekosita grenade UPD: Contest is over. Thanks for participating :)UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18659",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 825
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces",
          "content": "552A - Vanya and TableIn this problem we can get AC with many solutions:1) With every new rectangle we will add his area to the result, so for each line x1, y1, x2, y2 we will add to answer (x2 - x1 + 1) * (y2 - y1 + 1)Time complexity O(n).2) We can just do all, that is written in the statement: create an array and with each new rectangle we can just increment every element inside rectangle. In the end we can just add all elements inside this array.Time complexity O(n * x * y)C++ code Wild_Hamster Java code Wild_HamsterPython code Zlobober 552B - Vanya and BooksWe can find out a formula for this problem:for n < 10 answer will be n = n - 1 + 1 = 1 * (n + 1) - 1;for n < 100 answer will be 2 * (n - 9) + 9 = 2 * n - 9 = 2 * n - 10 - 1 + 2 = 2 * (n + 1) - 11;for n < 1000 answer will be 3 * (n - 99) + 2 * (99 - 9) + 9 = 3 * n - 99 - 9 = 3 * n - 100 - 10 - 1 + 3 = 3 * (n + 1) - 111;so for n < 10sz answer will be ;Time complexity O(sz), where sz is the length of n.We also could just try 10 options n < 10, n < 100, ..., n < 109, n = 109 and solve problem for each option.UPD: Don't use function pow() to find powers of 10, because it doesn't work right sometimes.C++ code Wild_HamsterJava code Wild_HamsterPython code Zlobober552C - Vanya and ScalesConvert m to number system of base w. If all digits of number – 0 or 1, then we can measure the weight of the item with putting weights, that have digits equal to 1, on one pan, and our item on another one.If this condition isn't satisfied, then we should iterate from lower digit to high and if digit is not equal to 0 or 1, we try to substract w from it and increment higher digit. If it becomes equal to  - 1, then we can put weight with number of this digit on the same pan with our item, if it becomes equal to 0, then we don't put weight, in another case we can't measure the weight of our item and answer is .Time complexity O(logm).C++ code Wild_HamsterJava code Wild_HamsterJava code Zlobober552D - Vanya and TrianglesWe can look through all pair of points, draw line through each pair and write, that this line includes these 2 points. We can do it with map. If some line includes x points, then in fact we counted, that it has 2 * x * (x - 1) points, because we included each point 2*(x-1) times in this line.We can create an array and add to him values b[2 * x * (x - 1)] = x, so we can define, how many points is on the line. Then we can iterate through all lanes and for each line with x points we will loose x * (x - 1) * (x - 2) / 6 possible triangles from all possible n * (n - 1) * (n - 2) / 6 triangles. Decide, that at first ans = n * (n - 1) * (n - 2) / 6. So for every line, that includes x points, we will substract x * (x - 1) * (x - 2) / 6 from ans.Time complexity O(n2 * logn).C++11 code Wild_HamsterJava code Wild_HamsterJava code ZloboberUPD: I am sorry, that O(n3 / 6) solutions passed, my solution with O(n3 / 6) didn't pass before the contest, so I decided, that TL 4 sec is good(it was for Java TL).552E - Vanya and BracketsWe can see, that we can reach maximal answer, when brackets will be between two signs  * , or between one sign  *  and the end of expression. For convenience we will add in the begin of expression 1 * , and in the end of expression  * 1.After that we can iterate all possible pairs of signs  *  and count the expression with putting brackets between two signs  *  for each pair.We can use two variables x and y to count the value of expression, in the begin x = 0, y = firstnumber, where firstnumber is first digit of expression, then if next sign is  + , then x = y, y = nextnumber, and if next sign is  * , then x = x, y = y * nextnumber. The value of expression will be x + y, we can create function, like that, to count expressions inside and outside the brackets.Time complexity O(|s| * 172).C++ code Wild_HamsterJava code Wild_HamsterJava code ZloboberP.S. Sorry for my bad english, I will try to correct mistakes in the near time.UPD: Editorial from hsk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 552\\s*C"
          },
          "content_length": 3972
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 1",
          "code": "long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 2",
          "code": "res += (n-99999999) * 9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 3",
          "code": "res += (n-999999999) * 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 4",
          "code": "n = 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 5",
          "code": "(n-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 6",
          "code": "= (999999999-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 7",
          "code": "= (900000000) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 8",
          "code": "= 8100000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 9",
          "code": "long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 10",
          "code": "long long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 11",
          "code": "Happy Coding!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 12",
          "code": "(long long int)pow(10,(double)x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "ceil(pow(a,b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "(pow(a,b)+0.01)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "w^1, w^2, w^3, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "position_of_found_sum & i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Dynamic Programming",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "SQRT Decomposition",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long w = inf.readLong(2LL, 1000000000LL, \"w\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long w = inf.readLong(2LL, 1000000000LL, \"w\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long w = inf.readLong(2LL, 1000000000LL, \"w\");\n    inf.readSpace();\n    long long m = inf.readLong(1LL, 1000000000LL, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n\n    long long w = opt<long long>(\"w\", -1); // default value indicates not set\n    long long m = opt<long long>(\"m\", -1);\n\n    const long long MAX_W = 1e9;\n    const long long MAX_M = 1e9;\n\n    if (type == \"random_large\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        if (m == -1)\n            m = rnd.next(1LL, MAX_M);\n        else\n            m = max(1LL, min(MAX_M, m));\n    } else if (type == \"random_small\") {\n        if (w == -1)\n            w = rnd.next(2LL, 10LL);\n        else\n            w = max(2LL, min(10LL, w));\n        if (m == -1)\n            m = rnd.next(1LL, 100LL);\n        else\n            m = max(1LL, min(100LL, m));\n    } else if (type == \"w2\") {\n        w = 2LL;\n        if (m == -1)\n            m = rnd.next(1LL, MAX_M);\n        else\n            m = max(1LL, min(MAX_M, m));\n    } else if (type == \"w_max\") {\n        w = 1000000000LL;\n        if (m == -1)\n            m = rnd.next(1LL, MAX_M);\n        else\n            m = max(1LL, min(MAX_M, m));\n    } else if (type == \"m_power\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(0, 30); // up to w^30\n        m = 1LL;\n        for (int i = 0; i < k; ++i) {\n            if (m > MAX_M / w) break;\n            m *= w;\n        }\n        m = min(m, MAX_M);\n    } else if (type == \"m_power_minus_one\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(1, 30);\n        m = 1LL;\n        for (int i = 0; i < k; ++i) {\n            if (m > MAX_M / w) break;\n            m *= w;\n        }\n        m = m - 1;\n        if (m < 1) m = 1;\n    } else if (type == \"m_power_plus_one\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(0, 29);\n        m = 1LL;\n        for (int i = 0; i < k; ++i) {\n            if (m > MAX_M / w) break;\n            m *= w;\n        }\n        if (m < MAX_M)\n            m = m + 1;\n    } else if (type == \"unrepresentable\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(10, 20); // ensure intermediate values\n        long long m1 = 0;\n        long long pw = 1;\n        for (int i = 0; i < k; ++i) {\n            if (m1 > MAX_M - pw) break;\n            m1 += pw;\n            if (pw > MAX_M / w) break;\n            pw *= w;\n        }\n        m = m1 + 1; // This should create a digit >= 2 in base w representation\n        m = min(m, MAX_M);\n    } else {\n        // If type not recognized, output an error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output w and m\n    printf(\"%lld %lld\\n\", w, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n\n    long long w = opt<long long>(\"w\", -1); // default value indicates not set\n    long long m = opt<long long>(\"m\", -1);\n\n    const long long MAX_W = 1e9;\n    const long long MAX_M = 1e9;\n\n    if (type == \"random_large\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        if (m == -1)\n            m = rnd.next(1LL, MAX_M);\n        else\n            m = max(1LL, min(MAX_M, m));\n    } else if (type == \"random_small\") {\n        if (w == -1)\n            w = rnd.next(2LL, 10LL);\n        else\n            w = max(2LL, min(10LL, w));\n        if (m == -1)\n            m = rnd.next(1LL, 100LL);\n        else\n            m = max(1LL, min(100LL, m));\n    } else if (type == \"w2\") {\n        w = 2LL;\n        if (m == -1)\n            m = rnd.next(1LL, MAX_M);\n        else\n            m = max(1LL, min(MAX_M, m));\n    } else if (type == \"w_max\") {\n        w = 1000000000LL;\n        if (m == -1)\n            m = rnd.next(1LL, MAX_M);\n        else\n            m = max(1LL, min(MAX_M, m));\n    } else if (type == \"m_power\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(0, 30); // up to w^30\n        m = 1LL;\n        for (int i = 0; i < k; ++i) {\n            if (m > MAX_M / w) break;\n            m *= w;\n        }\n        m = min(m, MAX_M);\n    } else if (type == \"m_power_minus_one\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(1, 30);\n        m = 1LL;\n        for (int i = 0; i < k; ++i) {\n            if (m > MAX_M / w) break;\n            m *= w;\n        }\n        m = m - 1;\n        if (m < 1) m = 1;\n    } else if (type == \"m_power_plus_one\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(0, 29);\n        m = 1LL;\n        for (int i = 0; i < k; ++i) {\n            if (m > MAX_M / w) break;\n            m *= w;\n        }\n        if (m < MAX_M)\n            m = m + 1;\n    } else if (type == \"unrepresentable\") {\n        if (w == -1)\n            w = rnd.next(2LL, MAX_W);\n        else\n            w = max(2LL, min(MAX_W, w));\n        int k = rnd.next(10, 20); // ensure intermediate values\n        long long m1 = 0;\n        long long pw = 1;\n        for (int i = 0; i < k; ++i) {\n            if (m1 > MAX_M - pw) break;\n            m1 += pw;\n            if (pw > MAX_M / w) break;\n            pw *= w;\n        }\n        m = m1 + 1; // This should create a digit >= 2 in base w representation\n        m = min(m, MAX_M);\n    } else {\n        // If type not recognized, output an error\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output w and m\n    printf(\"%lld %lld\\n\", w, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random large w and m\n./gen -type random_large\n./gen -type random_large\n\n# Random small w and m\n./gen -type random_small\n./gen -type random_small\n\n# w = 2, various m\n./gen -type w2 -m 1\n./gen -type w2 -m 1000000000\n./gen -type w2\n\n# w = 10^9, various m\n./gen -type w_max -m 1\n./gen -type w_max -m 1000000000\n./gen -type w_max\n\n# m as power of w\n./gen -type m_power\n./gen -type m_power -w 2\n./gen -type m_power -w 3\n./gen -type m_power -w 1000000000\n\n# m as w^k - 1\n./gen -type m_power_minus_one\n./gen -type m_power_minus_one -w 2\n./gen -type m_power_minus_one -w 3\n./gen -type m_power_minus_one -w 1000000000\n\n# m as w^k + 1\n./gen -type m_power_plus_one\n./gen -type m_power_plus_one -w 2\n./gen -type m_power_plus_one -w 3\n./gen -type m_power_plus_one -w 1000000000\n\n# Unrepresentable m\n./gen -type unrepresentable\n./gen -type unrepresentable -w 2\n./gen -type unrepresentable -w 3\n./gen -type unrepresentable -w 1000000000\n\n# Random with specified w and m\n./gen -type random_large -w 999999937 -m 1000000000\n./gen -type random_small -w 5 -m 99\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:47:59.408258",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "552/D",
      "title": "D. Vanya and Triangles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2000) — the number of the points painted on the plane. Next n lines contain two integers each xi, yi ( - 100 ≤ xi, yi ≤ 100) — the coordinates of the i-th point. It is guaranteed that no two given points coincide.",
      "output_spec": "OutputIn the first line print an integer — the number of triangles with the non-zero area among the painted points.",
      "sample_tests": "ExamplesInputCopy40 01 12 02 2OutputCopy3InputCopy30 01 12 0OutputCopy1InputCopy11 1OutputCopy0",
      "description": "D. Vanya and Triangles\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 2000) — the number of the points painted on the plane. Next n lines contain two integers each xi, yi ( - 100 ≤ xi, yi ≤ 100) — the coordinates of the i-th point. It is guaranteed that no two given points coincide.\n\nOutputIn the first line print an integer — the number of triangles with the non-zero area among the painted points.\n\nInputCopy40 01 12 02 2OutputCopy3InputCopy30 01 12 0OutputCopy1InputCopy11 1OutputCopy0\n\nInputCopy40 01 12 02 2\n\nOutputCopy3\n\nInputCopy30 01 12 0\n\nOutputCopy1\n\nInputCopy11 1\n\nOutputCopy0\n\nNoteNote to the first sample test. There are 3 triangles formed: (0, 0) - (1, 1) - (2, 0); (0, 0) - (2, 2) - (2, 0); (1, 1) - (2, 2) - (2, 0).Note to the second sample test. There is 1 triangle formed: (0, 0) - (1, 1) - (2, 0).Note to the third sample test. A single point doesn't form a single triangle.",
      "solutions": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces",
          "content": "Greetings to the Codeforces community!Regular Codeforces round #308 for participants from the second division will take place on 18 June, 19:30 MSK. Participants from the first division are able to participate out of the contest.It is my second round on Codeforces(First round — Codeforces Round 280 (Div. 2)). Hope you will enjoy this round.I want to thank Max Akhmedov (Zlobober) for help with preparation of this round, Maria Belova (Delinur) for translation of statements and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve these problems.UPD: Scoring is standard: 500-1000-1500-2000-2500.UPD: Congratulation to the winners: Ttocs45 RNS_JKS RNS_CUS kouekosita grenade UPD: Contest is over. Thanks for participating :)UPD: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18659",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 825
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces",
          "content": "552A - Vanya and TableIn this problem we can get AC with many solutions:1) With every new rectangle we will add his area to the result, so for each line x1, y1, x2, y2 we will add to answer (x2 - x1 + 1) * (y2 - y1 + 1)Time complexity O(n).2) We can just do all, that is written in the statement: create an array and with each new rectangle we can just increment every element inside rectangle. In the end we can just add all elements inside this array.Time complexity O(n * x * y)C++ code Wild_Hamster Java code Wild_HamsterPython code Zlobober 552B - Vanya and BooksWe can find out a formula for this problem:for n < 10 answer will be n = n - 1 + 1 = 1 * (n + 1) - 1;for n < 100 answer will be 2 * (n - 9) + 9 = 2 * n - 9 = 2 * n - 10 - 1 + 2 = 2 * (n + 1) - 11;for n < 1000 answer will be 3 * (n - 99) + 2 * (99 - 9) + 9 = 3 * n - 99 - 9 = 3 * n - 100 - 10 - 1 + 3 = 3 * (n + 1) - 111;so for n < 10sz answer will be ;Time complexity O(sz), where sz is the length of n.We also could just try 10 options n < 10, n < 100, ..., n < 109, n = 109 and solve problem for each option.UPD: Don't use function pow() to find powers of 10, because it doesn't work right sometimes.C++ code Wild_HamsterJava code Wild_HamsterPython code Zlobober552C - Vanya and ScalesConvert m to number system of base w. If all digits of number – 0 or 1, then we can measure the weight of the item with putting weights, that have digits equal to 1, on one pan, and our item on another one.If this condition isn't satisfied, then we should iterate from lower digit to high and if digit is not equal to 0 or 1, we try to substract w from it and increment higher digit. If it becomes equal to  - 1, then we can put weight with number of this digit on the same pan with our item, if it becomes equal to 0, then we don't put weight, in another case we can't measure the weight of our item and answer is .Time complexity O(logm).C++ code Wild_HamsterJava code Wild_HamsterJava code Zlobober552D - Vanya and TrianglesWe can look through all pair of points, draw line through each pair and write, that this line includes these 2 points. We can do it with map. If some line includes x points, then in fact we counted, that it has 2 * x * (x - 1) points, because we included each point 2*(x-1) times in this line.We can create an array and add to him values b[2 * x * (x - 1)] = x, so we can define, how many points is on the line. Then we can iterate through all lanes and for each line with x points we will loose x * (x - 1) * (x - 2) / 6 possible triangles from all possible n * (n - 1) * (n - 2) / 6 triangles. Decide, that at first ans = n * (n - 1) * (n - 2) / 6. So for every line, that includes x points, we will substract x * (x - 1) * (x - 2) / 6 from ans.Time complexity O(n2 * logn).C++11 code Wild_HamsterJava code Wild_HamsterJava code ZloboberUPD: I am sorry, that O(n3 / 6) solutions passed, my solution with O(n3 / 6) didn't pass before the contest, so I decided, that TL 4 sec is good(it was for Java TL).552E - Vanya and BracketsWe can see, that we can reach maximal answer, when brackets will be between two signs  * , or between one sign  *  and the end of expression. For convenience we will add in the begin of expression 1 * , and in the end of expression  * 1.After that we can iterate all possible pairs of signs  *  and count the expression with putting brackets between two signs  *  for each pair.We can use two variables x and y to count the value of expression, in the begin x = 0, y = firstnumber, where firstnumber is first digit of expression, then if next sign is  + , then x = y, y = nextnumber, and if next sign is  * , then x = x, y = y * nextnumber. The value of expression will be x + y, we can create function, like that, to count expressions inside and outside the brackets.Time complexity O(|s| * 172).C++ code Wild_HamsterJava code Wild_HamsterJava code ZloboberP.S. Sorry for my bad english, I will try to correct mistakes in the near time.UPD: Editorial from hsk",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 552\\s*D"
          },
          "content_length": 3972
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 1",
          "code": "long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 2",
          "code": "res += (n-99999999) * 9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 3",
          "code": "res += (n-999999999) * 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 4",
          "code": "n = 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 5",
          "code": "(n-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 6",
          "code": "= (999999999-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 7",
          "code": "= (900000000) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 8",
          "code": "= 8100000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 9",
          "code": "long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 10",
          "code": "long long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 11",
          "code": "Happy Coding!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 12",
          "code": "(long long int)pow(10,(double)x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "ceil(pow(a,b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "(pow(a,b)+0.01)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "w^1, w^2, w^3, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "position_of_found_sum & i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Dynamic Programming",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "SQRT Decomposition",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln(); // Ensure end of line after n\n\n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln(); // Ensure end of line after yi\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point #%d (%d, %d) is duplicated\", i + 1, xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof(); // Ensure EOF\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln(); // Ensure end of line after n\n\n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln(); // Ensure end of line after yi\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point #%d (%d, %d) is duplicated\", i + 1, xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof(); // Ensure EOF\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readEoln(); // Ensure end of line after n\n\n    set<pair<int, int>> points;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-100, 100, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(-100, 100, \"y_i\");\n        inf.readEoln(); // Ensure end of line after yi\n\n        pair<int, int> p = make_pair(xi, yi);\n        ensuref(points.count(p) == 0, \"Point #%d (%d, %d) is duplicated\", i + 1, xi, yi);\n        points.insert(p);\n    }\n\n    inf.readEof(); // Ensure EOF\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        /* Generate n unique random points within [-100,100] */\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"colinear\") {\n        /* Generate points on one or multiple lines */\n        if (n <= 201) {\n            /* All points on a single line */\n            int y0 = rnd.next(-100, 100);\n            for (int i = 0; i < n; ++i) {\n                int x = -100 + i;\n                if (x > 100) x -= 201;\n                points.emplace_back(x, y0);\n            }\n        } else {\n            /* Points on multiple lines */\n            int lines = (n + 200 - 1) / 200;\n            int per_line = n / lines;\n            int remaining = n % lines;\n            int y = -100;\n            int y_inc = 200 / (lines + 1);\n            for (int l = 0; l < lines; ++l) {\n                int x_start = -100;\n                int count = per_line + (l < remaining ? 1 : 0);\n                for (int i = 0; i < count; ++i) {\n                    int x = x_start + i;\n                    if (x > 100) x -= 201;\n                    points.emplace_back(x, y);\n                }\n                y += y_inc;\n                if (y > 100) y -= 201;\n            }\n        }\n    } else if (type == \"no_three_colinear\") {\n        /* Generate points with no three colinear (limited to n <= 30) */\n        if (n > 30) n = 30;\n        double angle_increment = 2 * M_PI / n;\n        int R = 99;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = i * angle_increment;\n            int x = (int)(R * cos(angle));\n            int y = (int)(R * sin(angle));\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n            points.assign(point_set.begin(), point_set.end());\n        }\n    } else if (type == \"grid\") {\n        /* Generate points on a grid */\n        int k = sqrt(n);\n        if (k * k < n) k++;\n        int x_start = -100;\n        int y_start = -100;\n        int x_inc = k > 1 ? 200 / (k - 1) : 0;\n        int y_inc = k > 1 ? 200 / (k - 1) : 0;\n        for (int i = 0; i < k && (int)points.size() < n; ++i) {\n            for (int j = 0; j < k && (int)points.size() < n; ++j) {\n                int x = x_start + i * x_inc;\n                int y = y_start + j * y_inc;\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"circle\") {\n        /* Generate points around a circle */\n        double angle_increment = 2 * M_PI / n;\n        int R = 99;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = i * angle_increment;\n            int x = (int)(R * cos(angle));\n            int y = (int)(R * sin(angle));\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n            points.assign(point_set.begin(), point_set.end());\n        }\n    } else if (type == \"line_plus_random\") {\n        /* Generate half points on a line and half random points */\n        int line_points = n / 2;\n        int random_points = n - line_points;\n        int y0 = rnd.next(-100, 100);\n        for (int i = 0; i < line_points; ++i) {\n            int x = -100 + i;\n            if (x > 100) x -= 201;\n            points.emplace_back(x, y0);\n        }\n        set<pair<int, int>> point_set(points.begin(), points.end());\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"few_colinear_groups\") {\n        /* Generate points forming several colinear groups */\n        int groups = 5;\n        int per_group = n / groups;\n        int remaining = n % groups;\n        int x = -100;\n        int x_inc = 200 / (groups + 1);\n        for (int g = 0; g < groups; ++g) {\n            int y_start = -100;\n            int count = per_group + (g < remaining ? 1 : 0);\n            for (int i = 0; i < count; ++i) {\n                int y = y_start + i;\n                if (y > 100) y -= 201;\n                points.emplace_back(x, y);\n            }\n            x += x_inc;\n            if (x > 100) x -= 201;\n        }\n    } else {\n        /* Default to random if unknown type */\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    }\n\n    /* Output according to the problem statement */\n    printf(\"%d\\n\", (int)points.size());\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points;\n\n    if (type == \"random\") {\n        /* Generate n unique random points within [-100,100] */\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"colinear\") {\n        /* Generate points on one or multiple lines */\n        if (n <= 201) {\n            /* All points on a single line */\n            int y0 = rnd.next(-100, 100);\n            for (int i = 0; i < n; ++i) {\n                int x = -100 + i;\n                if (x > 100) x -= 201;\n                points.emplace_back(x, y0);\n            }\n        } else {\n            /* Points on multiple lines */\n            int lines = (n + 200 - 1) / 200;\n            int per_line = n / lines;\n            int remaining = n % lines;\n            int y = -100;\n            int y_inc = 200 / (lines + 1);\n            for (int l = 0; l < lines; ++l) {\n                int x_start = -100;\n                int count = per_line + (l < remaining ? 1 : 0);\n                for (int i = 0; i < count; ++i) {\n                    int x = x_start + i;\n                    if (x > 100) x -= 201;\n                    points.emplace_back(x, y);\n                }\n                y += y_inc;\n                if (y > 100) y -= 201;\n            }\n        }\n    } else if (type == \"no_three_colinear\") {\n        /* Generate points with no three colinear (limited to n <= 30) */\n        if (n > 30) n = 30;\n        double angle_increment = 2 * M_PI / n;\n        int R = 99;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = i * angle_increment;\n            int x = (int)(R * cos(angle));\n            int y = (int)(R * sin(angle));\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n            points.assign(point_set.begin(), point_set.end());\n        }\n    } else if (type == \"grid\") {\n        /* Generate points on a grid */\n        int k = sqrt(n);\n        if (k * k < n) k++;\n        int x_start = -100;\n        int y_start = -100;\n        int x_inc = k > 1 ? 200 / (k - 1) : 0;\n        int y_inc = k > 1 ? 200 / (k - 1) : 0;\n        for (int i = 0; i < k && (int)points.size() < n; ++i) {\n            for (int j = 0; j < k && (int)points.size() < n; ++j) {\n                int x = x_start + i * x_inc;\n                int y = y_start + j * y_inc;\n                points.emplace_back(x, y);\n            }\n        }\n    } else if (type == \"circle\") {\n        /* Generate points around a circle */\n        double angle_increment = 2 * M_PI / n;\n        int R = 99;\n        set<pair<int, int>> point_set;\n        for (int i = 0; i < n; ++i) {\n            double angle = i * angle_increment;\n            int x = (int)(R * cos(angle));\n            int y = (int)(R * sin(angle));\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n        while ((int)points.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n            points.assign(point_set.begin(), point_set.end());\n        }\n    } else if (type == \"line_plus_random\") {\n        /* Generate half points on a line and half random points */\n        int line_points = n / 2;\n        int random_points = n - line_points;\n        int y0 = rnd.next(-100, 100);\n        for (int i = 0; i < line_points; ++i) {\n            int x = -100 + i;\n            if (x > 100) x -= 201;\n            points.emplace_back(x, y0);\n        }\n        set<pair<int, int>> point_set(points.begin(), points.end());\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    } else if (type == \"few_colinear_groups\") {\n        /* Generate points forming several colinear groups */\n        int groups = 5;\n        int per_group = n / groups;\n        int remaining = n % groups;\n        int x = -100;\n        int x_inc = 200 / (groups + 1);\n        for (int g = 0; g < groups; ++g) {\n            int y_start = -100;\n            int count = per_group + (g < remaining ? 1 : 0);\n            for (int i = 0; i < count; ++i) {\n                int y = y_start + i;\n                if (y > 100) y -= 201;\n                points.emplace_back(x, y);\n            }\n            x += x_inc;\n            if (x > 100) x -= 201;\n        }\n    } else {\n        /* Default to random if unknown type */\n        set<pair<int, int>> point_set;\n        while ((int)point_set.size() < n) {\n            int x = rnd.next(-100, 100);\n            int y = rnd.next(-100, 100);\n            point_set.insert({x, y});\n        }\n        points.assign(point_set.begin(), point_set.end());\n    }\n\n    /* Output according to the problem statement */\n    printf(\"%d\\n\", (int)points.size());\n    for (const auto& p : points) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 3 -type colinear\n./gen -n 3 -type no_three_colinear\n./gen -n 4 -type grid\n./gen -n 5 -type circle\n./gen -n 6 -type line_plus_random\n./gen -n 10 -type random\n./gen -n 10 -type colinear\n./gen -n 10 -type grid\n./gen -n 10 -type circle\n./gen -n 10 -type line_plus_random\n./gen -n 10 -type no_three_colinear\n\n./gen -n 20 -type no_three_colinear\n./gen -n 30 -type no_three_colinear\n\n./gen -n 100 -type random\n./gen -n 100 -type colinear\n./gen -n 100 -type grid\n./gen -n 100 -type circle\n./gen -n 100 -type line_plus_random\n\n./gen -n 500 -type random\n./gen -n 500 -type colinear\n./gen -n 500 -type grid\n./gen -n 500 -type circle\n./gen -n 500 -type line_plus_random\n\n./gen -n 1000 -type random\n./gen -n 1000 -type colinear\n./gen -n 1000 -type grid\n./gen -n 1000 -type circle\n./gen -n 1000 -type line_plus_random\n\n./gen -n 2000 -type random\n./gen -n 2000 -type colinear\n./gen -n 2000 -type grid\n./gen -n 2000 -type circle\n./gen -n 2000 -type line_plus_random\n\n./gen -n 1000 -type few_colinear_groups\n./gen -n 2000 -type few_colinear_groups\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:01.115440",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "552/E",
      "title": "E. Ваня и скобки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится выражение s (1 ≤ |s| ≤ 5001, |s| нечётно), в котором на нечетных позициях находятся только цифры от 1 до 9, а на чётных только знаки  +  и  * . Количество знаков  *  не превосходит 15.",
      "output_spec": "Выходные данныеВ первой строке выведите максимальное возможное значение выражения.",
      "sample_tests": "ПримерыВходные данныеСкопировать3+5*7+8*4Выходные данныеСкопировать303Входные данныеСкопировать2+3*5Выходные данныеСкопировать25Входные данныеСкопировать3*4*5Выходные данныеСкопировать60",
      "description": "E. Ваня и скобки\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержится выражение s (1 ≤ |s| ≤ 5001, |s| нечётно), в котором на нечетных позициях находятся только цифры от 1 до 9, а на чётных только знаки  +  и  * . Количество знаков  *  не превосходит 15.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите максимальное возможное значение выражения.\n\nВыходные данные\n\nВходные данныеСкопировать3+5*7+8*4Выходные данныеСкопировать303Входные данныеСкопировать2+3*5Выходные данныеСкопировать25Входные данныеСкопировать3*4*5Выходные данныеСкопировать60\n\nВходные данныеСкопировать3+5*7+8*4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать303\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2+3*5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать25\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3*4*5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать60\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПояснение к первому тесту из условия. 3 + 5 * (7 + 8) * 4 = 303.Пояснение к второму тесту из условия. (2 + 3) * 5 = 25.Пояснение к третьему тесту из условия. (3 * 4) * 5 = 60 (также подходит множество других вариантов, например, (3) * 4 * 5 = 60).",
      "solutions": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces",
          "content": "Приветствую сообщество Codeforces.18 июня 2015 года в 19:30 MSK состоится очередной раунд Codeforces #308 для участников из второго дивизиона. Традиционно, участники из первого дивизиона могут участвовать в соревновании вне конкурса.Это мой второй Codeforces раунд(первым был раунд Codeforces Round 280 (Div. 2)). Надеюсь, он вам понравится.Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено пять задач и два часа на их решение.UPD: Разбаловка стандартная: 500-1000-1500-2000-2500.UPD: Поздравляю победителей: Ttocs45 RNS_JKS RNS_CUS kouekosita grenade UPD: Контест закончен. Всем спасибо за участие :)UPD: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18659",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 803
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces",
          "content": "552A - Ваня и таблицаВ этой задаче проходило множество решений:1) С каждым новым прямоугольником добавляется его площадь к результату, так что будем считать площадь каждого прямоугольника и прибавлять к ответу, т.е. для каждой строки x1, y1, x2, y2 прибавляем к ответу (x2 - x1 + 1) * (y2 - y1 + 1)Асимптотика данного решения по времени O(n).2) Просто сделаем все, что описано в условии, создадим массив и с каждым запросом будем прибавлять прямоугольник к массиву, после чего просто сложим все элементы массива.Асимптотика по времени O(n * x * y)C++ code Wild_Hamster Java code Wild_HamsterPython code Zlobober 552B - Ваня и книгиМожно вывести формулу результата: для n < 10 ответом будет n = n - 1 + 1 = 1 * (n + 1) - 1;для n < 100 ответом будет 2 * (n - 9) + 9 = 2 * n - 9 = 2 * n - 10 - 1 + 2 = 2 * (n + 1) - 11;для n < 1000 ответом будет 3 * (n - 99) + 2 * (99 - 9) + 9 = 3 * n - 99 - 9 = 3 * n - 100 - 10 - 1 + 3 = 3 * (n + 1) - 111;для n < 10sz ответом будет ;Асимптотика по времени O(sz), где sz — длина числа.Так же можно было просто перебрать всех возможных 10 вариантов n < 10, n < 100, ..., n < 109, n = 109 и подсчитывать для каждого результат.C++ code Wild_HamsterJava code Wild_HamsterPython code ZloboberUPD: Don't use function pow() to find powers of 10, because it doesn't work right sometimes.552C - Ваня и весыПереведем число m в w-ичную систему счисления. Если все разряды числа – 0 или 1, то нашу вещь можно взвесить, поставив гири, номера разрядов которых равны 1, на одну чашу весов, а нашу вещь на другую.Если же это условие не выполняется, то пройдемся от младшего разряда к старшему и если он не равен 0 или 1, пытаемся отнять от него w и прибавить к старшему разряду единицу. Если этот разряд становится равен  - 1, то ставим гирю под данным номером на одну чашу с нашей вещью, если 0 — то не ставим гирю никуда, если иначе – то вещь нельзя взвесить по заданным условиям и ответ .Асимптотика по времени O(logm).C++ code Wild_HamsterJava code Wild_HamsterJava code Zlobober552D - Ваня и треугольникиПереберем все возможные пары точек, проведем через каждую из пар прямую и запишем, что этой прямой принадлежат эти 2 точки с помощью map. Если на прямой находится x точек, то на самом деле мы посчитаем нашим перебором, что на ней 2 * x * (x - 1) точек. Таким образом можно завести массив типа b[2 * x * (x - 1)] = x, чтобы определять, сколько точек находится на прямой. Тогда если на прямой находится x точек, то мы теряем x * (x - 1) * (x - 2) / 6 возможных треугольников с возможных n * (n - 1) * (n - 2) / 6 треугольников. Таким образом, для каждой прямой, на которой находится x точек, мы будем отнимать от n * (n - 1) * (n - 2) / 6 значение x * (x - 1) * (x - 2) / 6, таким образом подсчитывая ответ.Асимптотика решения O(n2 * logn).Поскольку map очень медленный, можно было для каждой пары точек каждую прямую заносить в массив, после этого отсортировать его и искать количество точек на каждой прямой нахождением количества подряд идущих одинаковых значений одной и той самой прямой.UPD: I am sorry, that O(n3 / 6) solutions passed, my solution with O(n3 / 6) didn't pass before the contest, so I decided, that TL 4 sec is good(it was for Java TL).C++11 code Wild_HamsterJava code Wild_HamsterJava code Zlobober552E - Ваня и скобкиМожно увидеть, что максимальный ответ будет тогда, когда скобки будут находится между двумя знаками  * , или между знаком  *  и концом выражения. Для удобства прибавим в начало выражения 1 * , а в конец выражения  * 1.Далее переберем все возможные пары знаков  *  и попробуем посчитать выражение, поставив скобки между двумя знаками  *  для каждой пары.Чтобы подсчитать выражение, используем две переменные x и y, в начале x = 0, y = firstnumber, где firstnumber — первая цифра выражения, тогда если следующий знак  + , тогда x = y, y = nextnumber, а если  * , тогда x = x, y = y * nextnumber. Результатом выражения будет x + y, для подсчета выражений в скобках и вне скобок можно написать функцию. Асимптотика по времени O(|s| * 172).C++ code Wild_HamsterJava code Wild_HamsterJava code Zlobober",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18696",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 552\\s*E"
          },
          "content_length": 4060
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 1",
          "code": "long long int",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 2",
          "code": "res += (n-99999999) * 9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 3",
          "code": "res += (n-999999999) * 10;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 4",
          "code": "n = 999999999",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 5",
          "code": "(n-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 6",
          "code": "= (999999999-99999999) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 7",
          "code": "= (900000000) * 9",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 8",
          "code": "= 8100000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 9",
          "code": "long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 10",
          "code": "long long int n = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 11",
          "code": "Happy Coding!",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #308 (Div. 2) - Codeforces - Code 12",
          "code": "(long long int)pow(10,(double)x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18659",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "let ans = 0\n   let sz = numberOfDigits(n)\n   let ans = sz * n\n   for(p=10;p<=n;p*=10)\n      ans -= p-1\n   print (ans)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "c0 + c1*w^1 + c2*w^2 + ... = m      ------ (Equation 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "=> c1*w^1 + c2*w^2 + ... = m - c0\n=> w(c1 + c2*w^1 + c3*w^2 + ... ) = m - c0\n=> c1 + c2*w^1 + c3*w^2 + ...  = (m - c0)/w        ------ (Equation 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "boolean solve(int w, int m) {\n  return w <= 3 || m == 1 || trySolve(w, m-1) || trySolve(w, m) || trySolve(w, m+1)\n}\n\nboolean trySolve(int w, int m) {\n  return m%w == 0 && solve(w, m/w)\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "ceil(pow(a,b))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "(pow(a,b)+0.01)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 12",
          "code": "int *a = new int[201];\nint *b = a + 100; // b[-100...100]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 13",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 14",
          "code": "for open_bracket from 0 to pos[*].size()-1{     //17 times at max\n        for close_bracket from pos[*][open_bracket]+1 to pos[*].size(){   //17 times at max\n             evaluate the expression with the given brackets    //O(|S|)      \n        }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 15",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 16",
          "code": "for (int i = 0; i < n; ++i) {\n\tfor (int j = i + 1; j < n; ++j) {\n\t\tline l = get_line(p[i], p[j]);\n\t\tlines[l] += 2;\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 17",
          "code": "w^1, w^2, w^3, ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 18",
          "code": "position_of_found_sum & i",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 19",
          "code": "Dynamic Programming",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        },
        {
          "title": "Codeforces #308 (Div. 2) Editorial - Codeforces - Code 20",
          "code": "SQRT Decomposition",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18696",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-9](?:[\\\\+\\\\*][1-9])*\", \"s\");\n    ensuref(s.length() >= 1 && s.length() <= 5001, \"Length of s should be between 1 and 5001, but it's %d\", (int)s.length());\n    ensuref(s.length() % 2 == 1, \"Length of s should be odd, but it's %d\", (int)s.length());\n    int star_count = 0;\n    for(int i = 0; i < s.length(); ++i){\n        if(s[i] == '*'){\n            star_count++;\n        }\n    }\n    ensuref(star_count <=15, \"Number of '*' signs should not exceed 15, but found %d\", star_count);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-9](?:[\\\\+\\\\*][1-9])*\", \"s\");\n    ensuref(s.length() >= 1 && s.length() <= 5001, \"Length of s should be between 1 and 5001, but it's %d\", (int)s.length());\n    ensuref(s.length() % 2 == 1, \"Length of s should be odd, but it's %d\", (int)s.length());\n    int star_count = 0;\n    for(int i = 0; i < s.length(); ++i){\n        if(s[i] == '*'){\n            star_count++;\n        }\n    }\n    ensuref(star_count <=15, \"Number of '*' signs should not exceed 15, but found %d\", star_count);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[1-9](?:[\\\\+\\\\*][1-9])*\", \"s\");\n    ensuref(s.length() >= 1 && s.length() <= 5001, \"Length of s should be between 1 and 5001, but it's %d\", (int)s.length());\n    ensuref(s.length() % 2 == 1, \"Length of s should be odd, but it's %d\", (int)s.length());\n    int star_count = 0;\n    for(int i = 0; i < s.length(); ++i){\n        if(s[i] == '*'){\n            star_count++;\n        }\n    }\n    ensuref(star_count <=15, \"Number of '*' signs should not exceed 15, but found %d\", star_count);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\"); // The length of the expression, odd number between 1 and 5001\n    int stars = opt<int>(\"stars\", 0); // Number of '*' operators, default 0\n    string type = opt<string>(\"type\", \"random\"); // Type of the expression\n\n    // Validate len\n    if (len < 1 || len > 5001 || len % 2 == 0) {\n        cerr << \"Invalid len. Must be an odd number between 1 and 5001.\" << endl;\n        exit(1);\n    }\n\n    int num_ops = (len -1)/2; // Number of operators\n    if (stars > min(15, num_ops)) {\n        cerr << \"Number of '*' operators exceeds limit.\" << endl;\n        exit(1);\n    }\n\n    if (stars < 0) {\n        cerr << \"Number of '*' operators cannot be negative.\" << endl;\n        exit(1);\n    }\n\n    int pluses = num_ops - stars; // Number of '+' operators\n    string s; // The expression to generate\n\n    if (type == \"random\") {\n        // Generate random expression with given number of '*' operators\n        // First generate the positions of '*' operators\n        vector<int> positions(num_ops);\n        for (int i = 0; i < num_ops; ++i) {\n            positions[i] = i;\n        }\n        // Shuffle the positions\n        shuffle(positions.begin(), positions.end());\n        // Assign '*' to first 'stars' positions, '+' to the rest\n        vector<char> operators(num_ops, '+');\n        for (int i = 0; i < stars; ++i) {\n            operators[positions[i]] = '*';\n        }\n        // Build the expression\n        for (int i = 0; i < len; ++i) {\n            if (i %2 == 0) {\n                // Digit position\n                char digit = '1' + rnd.next(9);\n                s += digit;\n            } else {\n                // Operator position\n                s += operators[(i -1)/2];\n            }\n        }\n    } else if (type == \"all_plus\") {\n        // All operators are '+'\n        if (stars != 0) {\n            cerr << \"Cannot have '*' operators in all_plus type.\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < len; ++i) {\n            if (i %2 ==0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += '+';\n            }\n        }\n    } else if (type == \"all_star\") {\n        // All operators are '*'\n        if (stars != num_ops) {\n            cerr << \"Number of '*' operators must be equal to number of operators for all_star type.\" << endl;\n            exit(1);\n        }\n        if (stars > 15) {\n            cerr << \"Number of '*' operators cannot exceed 15.\" << endl;\n            exit(1);\n        }\n        if (num_ops > 15) {\n            cerr << \"Number of operators exceeds the maximum allowed '*' operators (15) for all_star type.\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < len; ++i) {\n            if (i %2 ==0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += '*';\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Operators alternate between '+' and '*'\n        if (stars > num_ops) {\n            cerr << \"Number of '*' operators exceeds number of operators.\" << endl;\n            exit(1);\n        }\n        if (stars > 15) {\n            cerr << \"Number of '*' operators cannot exceed 15.\" << endl;\n            exit(1);\n        }\n        vector<char> operators(num_ops, '+');\n        // Assign '*' to positions 0, 2, 4,... up to the number of stars\n        for (int i = 0; i < stars; ++i) {\n            int pos = 2 * i;\n            if (pos >= num_ops) {\n                break;\n            }\n            operators[pos] = '*';\n        }\n        for (int i = 0; i < len; ++i) {\n            if (i %2 == 0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += operators[(i -1)/2];\n            }\n        }\n    } else if (type == \"max_len\") {\n        // Generate expression of maximum length (5001)\n        // 'len' must already be 5001\n        if (len != 5001) {\n            cerr << \"For 'max_len' type, len must be 5001.\" << endl;\n            exit(1);\n        }\n        if (stars > 15) {\n            cerr << \"Number of '*' operators cannot exceed 15.\" << endl;\n            exit(1);\n        }\n        // Distribute stars randomly\n        vector<int> positions(num_ops);\n        for (int i = 0; i < num_ops; ++i) {\n            positions[i] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        vector<char> operators(num_ops, '+');\n        for (int i = 0; i < stars; ++i) {\n            operators[positions[i]] = '*';\n        }\n\n        for (int i = 0; i < len; ++i) {\n            if (i %2 ==0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += operators[(i -1)/2];\n            }\n        }\n    } else if (type == \"min_len\") {\n        // Generate expression of minimal length (1)\n        if (len != 1) {\n            cerr << \"For 'min_len' type, len must be 1.\" << endl;\n            exit(1);\n        }\n        s += '1' + rnd.next(9);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the expression\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\"); // The length of the expression, odd number between 1 and 5001\n    int stars = opt<int>(\"stars\", 0); // Number of '*' operators, default 0\n    string type = opt<string>(\"type\", \"random\"); // Type of the expression\n\n    // Validate len\n    if (len < 1 || len > 5001 || len % 2 == 0) {\n        cerr << \"Invalid len. Must be an odd number between 1 and 5001.\" << endl;\n        exit(1);\n    }\n\n    int num_ops = (len -1)/2; // Number of operators\n    if (stars > min(15, num_ops)) {\n        cerr << \"Number of '*' operators exceeds limit.\" << endl;\n        exit(1);\n    }\n\n    if (stars < 0) {\n        cerr << \"Number of '*' operators cannot be negative.\" << endl;\n        exit(1);\n    }\n\n    int pluses = num_ops - stars; // Number of '+' operators\n    string s; // The expression to generate\n\n    if (type == \"random\") {\n        // Generate random expression with given number of '*' operators\n        // First generate the positions of '*' operators\n        vector<int> positions(num_ops);\n        for (int i = 0; i < num_ops; ++i) {\n            positions[i] = i;\n        }\n        // Shuffle the positions\n        shuffle(positions.begin(), positions.end());\n        // Assign '*' to first 'stars' positions, '+' to the rest\n        vector<char> operators(num_ops, '+');\n        for (int i = 0; i < stars; ++i) {\n            operators[positions[i]] = '*';\n        }\n        // Build the expression\n        for (int i = 0; i < len; ++i) {\n            if (i %2 == 0) {\n                // Digit position\n                char digit = '1' + rnd.next(9);\n                s += digit;\n            } else {\n                // Operator position\n                s += operators[(i -1)/2];\n            }\n        }\n    } else if (type == \"all_plus\") {\n        // All operators are '+'\n        if (stars != 0) {\n            cerr << \"Cannot have '*' operators in all_plus type.\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < len; ++i) {\n            if (i %2 ==0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += '+';\n            }\n        }\n    } else if (type == \"all_star\") {\n        // All operators are '*'\n        if (stars != num_ops) {\n            cerr << \"Number of '*' operators must be equal to number of operators for all_star type.\" << endl;\n            exit(1);\n        }\n        if (stars > 15) {\n            cerr << \"Number of '*' operators cannot exceed 15.\" << endl;\n            exit(1);\n        }\n        if (num_ops > 15) {\n            cerr << \"Number of operators exceeds the maximum allowed '*' operators (15) for all_star type.\" << endl;\n            exit(1);\n        }\n        for (int i = 0; i < len; ++i) {\n            if (i %2 ==0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += '*';\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Operators alternate between '+' and '*'\n        if (stars > num_ops) {\n            cerr << \"Number of '*' operators exceeds number of operators.\" << endl;\n            exit(1);\n        }\n        if (stars > 15) {\n            cerr << \"Number of '*' operators cannot exceed 15.\" << endl;\n            exit(1);\n        }\n        vector<char> operators(num_ops, '+');\n        // Assign '*' to positions 0, 2, 4,... up to the number of stars\n        for (int i = 0; i < stars; ++i) {\n            int pos = 2 * i;\n            if (pos >= num_ops) {\n                break;\n            }\n            operators[pos] = '*';\n        }\n        for (int i = 0; i < len; ++i) {\n            if (i %2 == 0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += operators[(i -1)/2];\n            }\n        }\n    } else if (type == \"max_len\") {\n        // Generate expression of maximum length (5001)\n        // 'len' must already be 5001\n        if (len != 5001) {\n            cerr << \"For 'max_len' type, len must be 5001.\" << endl;\n            exit(1);\n        }\n        if (stars > 15) {\n            cerr << \"Number of '*' operators cannot exceed 15.\" << endl;\n            exit(1);\n        }\n        // Distribute stars randomly\n        vector<int> positions(num_ops);\n        for (int i = 0; i < num_ops; ++i) {\n            positions[i] = i;\n        }\n        shuffle(positions.begin(), positions.end());\n        vector<char> operators(num_ops, '+');\n        for (int i = 0; i < stars; ++i) {\n            operators[positions[i]] = '*';\n        }\n\n        for (int i = 0; i < len; ++i) {\n            if (i %2 ==0) {\n                s += '1' + rnd.next(9);\n            } else {\n                s += operators[(i -1)/2];\n            }\n        }\n    } else if (type == \"min_len\") {\n        // Generate expression of minimal length (1)\n        if (len != 1) {\n            cerr << \"For 'min_len' type, len must be 1.\" << endl;\n            exit(1);\n        }\n        s += '1' + rnd.next(9);\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output the expression\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input\n./gen -len 1 -stars 0 -type min_len\n\n# Small size inputs\n./gen -len 3 -stars 0 -type all_plus\n./gen -len 3 -stars 1 -type all_star\n./gen -len 3 -stars 1 -type alternating\n./gen -len 3 -stars 1 -type random\n\n# All '+' operators\n./gen -len 999 -stars 0 -type all_plus\n./gen -len 5001 -stars 0 -type all_plus\n\n# Maximal number of '*' operators\n./gen -len 31 -stars 15 -type all_star\n./gen -len 31 -stars 15 -type random\n./gen -len 31 -stars 15 -type alternating\n\n# Alternating operators\n./gen -len 101 -stars 15 -type alternating\n./gen -len 501 -stars 15 -type alternating\n\n# Random expressions with maximal stars\n./gen -len 101 -stars 15 -type random\n./gen -len 501 -stars 15 -type random\n\n# Maximal length expressions\n./gen -len 5001 -stars 15 -type max_len\n./gen -len 5001 -stars 15 -type random\n./gen -len 5001 -stars 15 -type alternating\n\n# Expressions with fewer '*' operators\n./gen -len 5001 -stars 10 -type random\n./gen -len 5001 -stars 5 -type random\n\n# Edge cases\n./gen -len 5001 -stars 0 -type all_plus\n./gen -len 31 -stars 0 -type all_plus\n./gen -len 1 -stars 0 -type random\n\n# Max amount of '+' operators in max length\n./gen -len 5001 -stars 0 -type max_len\n\n# Expressions with only '+' operators, varying lengths\n./gen -len 999 -stars 0 -type all_plus\n./gen -len 4999 -stars 0 -type all_plus\n\n# Expressions with varying '*' operators\n./gen -len 1001 -stars 1 -type random\n./gen -len 1001 -stars 5 -type random\n./gen -len 1001 -stars 15 -type random\n\n# Computationally challenging expressions\n./gen -len 5001 -stars 15 -type random\n./gen -len 5001 -stars 15 -type alternating\n\n# Minimal '*' operators\n./gen -len 5001 -stars 1 -type random\n\n# Maximal possible expression with only '+' operators\n./gen -len 5001 -stars 0 -type max_len\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:03.320955",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "553/A",
      "title": "A. Kyoya and Colored Balls",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will have one integer k (1 ≤ k ≤ 1000) the number of colors.Then, k lines will follow. The i-th line will contain ci, the number of balls of the i-th color (1 ≤ ci ≤ 1000).The total number of balls doesn't exceed 1000.",
      "output_spec": "OutputA single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1 000 000 007.",
      "sample_tests": "ExamplesInputCopy3221OutputCopy3InputCopy41234OutputCopy1680",
      "description": "A. Kyoya and Colored Balls\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will have one integer k (1 ≤ k ≤ 1000) the number of colors.Then, k lines will follow. The i-th line will contain ci, the number of balls of the i-th color (1 ≤ ci ≤ 1000).The total number of balls doesn't exceed 1000.\n\nOutputA single integer, the number of ways that Kyoya can draw the balls from the bag as described in the statement, modulo 1 000 000 007.\n\nInputCopy3221OutputCopy3InputCopy41234OutputCopy1680\n\nInputCopy3221\n\nOutputCopy3\n\nInputCopy41234\n\nOutputCopy1680\n\nNoteIn the first sample, we have 2 balls of color 1, 2 balls of color 2, and 1 ball of color 3. The three ways for Kyoya are: 1 2 1 2 31 1 2 2 32 1 1 2 3",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 553 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    \n    int sum_c = 0;\n    for (int i = 1; i <= k; ++i) {\n        int c_i = inf.readInt(1, 1000, \"c_i\");\n        sum_c += c_i;\n        inf.readEoln();\n    }\n    ensuref(sum_c <= 1000, \"Sum of c_i must not exceed 1000, but it is %d\", sum_c);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    \n    int sum_c = 0;\n    for (int i = 1; i <= k; ++i) {\n        int c_i = inf.readInt(1, 1000, \"c_i\");\n        sum_c += c_i;\n        inf.readEoln();\n    }\n    ensuref(sum_c <= 1000, \"Sum of c_i must not exceed 1000, but it is %d\", sum_c);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    \n    int sum_c = 0;\n    for (int i = 1; i <= k; ++i) {\n        int c_i = inf.readInt(1, 1000, \"c_i\");\n        sum_c += c_i;\n        inf.readEoln();\n    }\n    ensuref(sum_c <= 1000, \"Sum of c_i must not exceed 1000, but it is %d\", sum_c);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int k = opt<int>(\"k\"); // Number of colors\n    int max_total = opt<int>(\"max_total\", 1000); // Max total number of balls\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    vector<int> ci(k);\n\n    if (type == \"all_ones\") {\n        // ci = 1 for all colors\n        if (k > max_total) {\n            fprintf(stderr, \"Error: total number of balls exceeds limit\\n\");\n            return 1;\n        }\n        for (int i = 0; i < k; ++i)\n            ci[i] = 1;\n    } else if (type == \"all_equal\") {\n        // All ci are equal\n        int c = max_total / k;\n        if (c == 0) c = 1;\n        for (int i = 0; i < k; ++i)\n            ci[i] = c;\n        // Adjust if sum exceeds max_total\n        int total = c * k;\n        int idx = 0;\n        while (total > max_total) {\n            if (ci[idx] > 1) {\n                ci[idx]--;\n                total--;\n            }\n            idx = (idx + 1) % k;\n        }\n    } else if (type == \"increasing\") {\n        // ci in increasing order\n        int total = 0;\n        int min_c = 1;\n        int max_c = min(1000, max_total - k + 1);\n        for (int i = 0; i < k; ++i) {\n            ci[i] = min_c + (max_c - min_c) * i / (k - 1);\n            ci[i] = max(ci[i], 1);\n            ci[i] = min(ci[i], 1000);\n            total += ci[i];\n        }\n        // Adjust if total exceeds max_total\n        while (total > max_total) {\n            for (int i = k - 1; i >= 0 && total > max_total; --i) {\n                if (ci[i] > 1) {\n                    ci[i]--;\n                    total--;\n                }\n            }\n        }\n    } else if (type == \"decreasing\") {\n        // ci in decreasing order\n        int total = 0;\n        int min_c = 1;\n        int max_c = min(1000, max_total - k + 1);\n        for (int i = 0; i < k; ++i) {\n            ci[i] = max_c - (max_c - min_c) * i / (k - 1);\n            ci[i] = max(ci[i], 1);\n            ci[i] = min(ci[i], 1000);\n            total += ci[i];\n        }\n        // Adjust if total exceeds max_total\n        while (total > max_total) {\n            for (int i = k - 1; i >= 0 && total > max_total; --i) {\n                if (ci[i] > 1) {\n                    ci[i]--;\n                    total--;\n                }\n            }\n        }\n    } else if (type == \"one_large\") {\n        // One ci is large, others are 1\n        int remaining = max_total - (k - 1);\n        if (remaining > 1000) remaining = 1000;\n        ci[0] = remaining;\n        for (int i = 1; i < k; ++i)\n            ci[i] = 1;\n        int total = remaining + (k - 1);\n        while (total > max_total) {\n            if (ci[0] > 1) {\n                ci[0]--;\n                total--;\n            } else {\n                break;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random ci's\n        int total = 0;\n        for (int i = 0; i < k; ++i) {\n            int max_ci = min(1000, max_total - total - (k - i - 1));\n            ci[i] = rnd.next(1, max_ci);\n            total += ci[i];\n        }\n    } else {\n        // Default to random\n        int total = 0;\n        for (int i = 0; i < k; ++i) {\n            int max_ci = min(1000, max_total - total - (k - i - 1));\n            ci[i] = rnd.next(1, max_ci);\n            total += ci[i];\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i)\n        printf(\"%d\\n\", ci[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse arguments\n    int k = opt<int>(\"k\"); // Number of colors\n    int max_total = opt<int>(\"max_total\", 1000); // Max total number of balls\n    string type = opt<string>(\"type\", \"random\"); // Type of test case\n\n    vector<int> ci(k);\n\n    if (type == \"all_ones\") {\n        // ci = 1 for all colors\n        if (k > max_total) {\n            fprintf(stderr, \"Error: total number of balls exceeds limit\\n\");\n            return 1;\n        }\n        for (int i = 0; i < k; ++i)\n            ci[i] = 1;\n    } else if (type == \"all_equal\") {\n        // All ci are equal\n        int c = max_total / k;\n        if (c == 0) c = 1;\n        for (int i = 0; i < k; ++i)\n            ci[i] = c;\n        // Adjust if sum exceeds max_total\n        int total = c * k;\n        int idx = 0;\n        while (total > max_total) {\n            if (ci[idx] > 1) {\n                ci[idx]--;\n                total--;\n            }\n            idx = (idx + 1) % k;\n        }\n    } else if (type == \"increasing\") {\n        // ci in increasing order\n        int total = 0;\n        int min_c = 1;\n        int max_c = min(1000, max_total - k + 1);\n        for (int i = 0; i < k; ++i) {\n            ci[i] = min_c + (max_c - min_c) * i / (k - 1);\n            ci[i] = max(ci[i], 1);\n            ci[i] = min(ci[i], 1000);\n            total += ci[i];\n        }\n        // Adjust if total exceeds max_total\n        while (total > max_total) {\n            for (int i = k - 1; i >= 0 && total > max_total; --i) {\n                if (ci[i] > 1) {\n                    ci[i]--;\n                    total--;\n                }\n            }\n        }\n    } else if (type == \"decreasing\") {\n        // ci in decreasing order\n        int total = 0;\n        int min_c = 1;\n        int max_c = min(1000, max_total - k + 1);\n        for (int i = 0; i < k; ++i) {\n            ci[i] = max_c - (max_c - min_c) * i / (k - 1);\n            ci[i] = max(ci[i], 1);\n            ci[i] = min(ci[i], 1000);\n            total += ci[i];\n        }\n        // Adjust if total exceeds max_total\n        while (total > max_total) {\n            for (int i = k - 1; i >= 0 && total > max_total; --i) {\n                if (ci[i] > 1) {\n                    ci[i]--;\n                    total--;\n                }\n            }\n        }\n    } else if (type == \"one_large\") {\n        // One ci is large, others are 1\n        int remaining = max_total - (k - 1);\n        if (remaining > 1000) remaining = 1000;\n        ci[0] = remaining;\n        for (int i = 1; i < k; ++i)\n            ci[i] = 1;\n        int total = remaining + (k - 1);\n        while (total > max_total) {\n            if (ci[0] > 1) {\n                ci[0]--;\n                total--;\n            } else {\n                break;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random ci's\n        int total = 0;\n        for (int i = 0; i < k; ++i) {\n            int max_ci = min(1000, max_total - total - (k - i - 1));\n            ci[i] = rnd.next(1, max_ci);\n            total += ci[i];\n        }\n    } else {\n        // Default to random\n        int total = 0;\n        for (int i = 0; i < k; ++i) {\n            int max_ci = min(1000, max_total - total - (k - i - 1));\n            ci[i] = rnd.next(1, max_ci);\n            total += ci[i];\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", k);\n    for (int i = 0; i < k; ++i)\n        printf(\"%d\\n\", ci[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1 -max_total 10 -type all_ones\n./gen -k 1 -max_total 10 -type random\n./gen -k 1 -max_total 1000 -type all_equal\n\n./gen -k 2 -max_total 10 -type all_equal\n./gen -k 2 -max_total 10 -type increasing\n./gen -k 2 -max_total 10 -type decreasing\n./gen -k 2 -max_total 10 -type one_large\n\n./gen -k 3 -max_total 10 -type random\n./gen -k 5 -max_total 10 -type all_ones\n\n./gen -k 10 -type random\n./gen -k 10 -type all_equal\n./gen -k 10 -type increasing\n./gen -k 10 -type decreasing\n./gen -k 10 -type one_large\n\n./gen -k 100 -type random\n./gen -k 100 -type all_equal\n./gen -k 100 -type increasing\n./gen -k 100 -type decreasing\n./gen -k 100 -type one_large\n\n./gen -k 500 -type random\n./gen -k 500 -type increasing\n./gen -k 500 -type decreasing\n\n./gen -k 999 -type random\n./gen -k 1000 -max_total 1000 -type all_ones\n./gen -k 1000 -type random\n./gen -k 1000 -type all_equal\n./gen -k 1000 -type increasing\n./gen -k 1000 -type decreasing\n./gen -k 1000 -type one_large\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:05.107153",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "553/B",
      "title": "B. Кёя и перестановка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ min{1018, l}, где l — это длина списка Кёи).",
      "output_spec": "Выходные данныеВыведите через пробел n целых чисел, обозначающих перестановку, являющуюся ответом на вопрос.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 3Выходные данныеСкопировать1 3 2 4Входные данныеСкопировать10 1Выходные данныеСкопировать1 2 3 4 5 6 7 8 9 10",
      "description": "B. Кёя и перестановка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано два целых числа n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ min{1018, l}, где l — это длина списка Кёи).\n\nВходные данные\n\nВыходные данныеВыведите через пробел n целых чисел, обозначающих перестановку, являющуюся ответом на вопрос.\n\nВыходные данные\n\nВходные данныеСкопировать4 3Выходные данныеСкопировать1 3 2 4Входные данныеСкопировать10 1Выходные данныеСкопировать1 2 3 4 5 6 7 8 9 10\n\nВходные данныеСкопировать4 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3 2 4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3 4 5 6 7 8 9 10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия стандартное циклическое разложение выглядит как (1)(32)(4), что дает нам изначальную перестановку после удаления скобок. Первая перестановка в списке равна [1, 2, 3, 4], а вторая перестановка равна [1, 2, 4, 3].",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 553 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL, 1000000000000000000LL, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // default -1, indicating not provided\n    long long k = opt<long long>(\"k\", -1); // default -1, indicating not provided\n    string type = opt<string>(\"type\", \"\");\n\n    if (type == \"min_n\") {\n        n = 1;\n        k = 1;\n    } else if (type == \"max_n_small_k\") {\n        n = 50;\n        k = 1;\n    } else if (type == \"max_n_max_k\") {\n        n = 50;\n        k = 1000000000000000000LL;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 50);\n        k = rnd.next(1LL, 1000000000000000000LL);\n    } else {\n        // if n or k not provided, exit with error\n        if (n == -1 || k == -1) {\n            fprintf(stderr, \"Error: n and k must be provided if type is not specified.\\n\");\n            return 1;\n        }\n    }\n\n    // Check constraints\n    ensuref(1 <= n && n <= 50, \"n must be between 1 and 50\");\n    ensuref(1 <= k && k <= 1000000000000000000LL, \"k must be between 1 and 1e18\");\n\n    printf(\"%d %lld\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1); // default -1, indicating not provided\n    long long k = opt<long long>(\"k\", -1); // default -1, indicating not provided\n    string type = opt<string>(\"type\", \"\");\n\n    if (type == \"min_n\") {\n        n = 1;\n        k = 1;\n    } else if (type == \"max_n_small_k\") {\n        n = 50;\n        k = 1;\n    } else if (type == \"max_n_max_k\") {\n        n = 50;\n        k = 1000000000000000000LL;\n    } else if (type == \"random\") {\n        n = rnd.next(1, 50);\n        k = rnd.next(1LL, 1000000000000000000LL);\n    } else {\n        // if n or k not provided, exit with error\n        if (n == -1 || k == -1) {\n            fprintf(stderr, \"Error: n and k must be provided if type is not specified.\\n\");\n            return 1;\n        }\n    }\n\n    // Check constraints\n    ensuref(1 <= n && n <= 50, \"n must be between 1 and 50\");\n    ensuref(1 <= k && k <= 1000000000000000000LL, \"k must be between 1 and 1e18\");\n\n    printf(\"%d %lld\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Type-based test cases\n./gen -type min_n\n./gen -type max_n_small_k\n./gen -type max_n_max_k\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Specific n and k values\n./gen -n 1 -k 1\n./gen -n 2 -k 1\n./gen -n 2 -k 2\n./gen -n 3 -k 1\n./gen -n 3 -k 6\n./gen -n 4 -k 1\n./gen -n 4 -k 4\n./gen -n 5 -k 1\n./gen -n 5 -k 10\n./gen -n 10 -k 1000\n./gen -n 15 -k 100000\n./gen -n 20 -k 1000000000\n./gen -n 25 -k 1000000000000\n./gen -n 30 -k 1000000000000000\n./gen -n 40 -k 100000000000000000\n./gen -n 50 -k 1\n./gen -n 50 -k 1000\n./gen -n 50 -k 1000000\n./gen -n 50 -k 1000000000\n./gen -n 50 -k 1000000000000000000\n\n# Edge cases\n./gen -n 1 -k 1\n./gen -n 50 -k 1000000000000000000\n./gen -n 50 -k 999999999999999999\n\n# Random test cases\n./gen -n 5 -k 3\n./gen -n 10 -k 7\n./gen -n 15 -k 12\n./gen -n 20 -k 25\n./gen -n 25 -k 50\n./gen -n 30 -k 100\n./gen -n 35 -k 200\n./gen -n 40 -k 400\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:07.121319",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "553/C",
      "title": "C. Любовные треугольники",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входа записано два целых числа n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).В следующих m строках записано описание известных отношений. В i-й строке записано три целых числа ai, bi, ci. Если ci равно 1, тогда ai и bi любят друг друга, в противном случае, они ненавидят друг друга (1 ≤ ai, bi ≤ n, ai ≠ bi, ).Каждая пара людей описана не более, чем один раз.",
      "output_spec": "Выходные данныеВыведите единственное целое число, равное остатку от деления на 1 000 000 007 количества способов заполнения оставшихся пар так, чтобы вы были довольны каждым треугольником.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 0Выходные данныеСкопировать4Входные данныеСкопировать4 41 2 12 3 13 4 04 1 0Выходные данныеСкопировать1Входные данныеСкопировать4 41 2 12 3 13 4 04 1 1Выходные данныеСкопировать0",
      "description": "C. Любовные треугольники\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входа записано два целых числа n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).В следующих m строках записано описание известных отношений. В i-й строке записано три целых числа ai, bi, ci. Если ci равно 1, тогда ai и bi любят друг друга, в противном случае, они ненавидят друг друга (1 ≤ ai, bi ≤ n, ai ≠ bi, ).Каждая пара людей описана не более, чем один раз.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число, равное остатку от деления на 1 000 000 007 количества способов заполнения оставшихся пар так, чтобы вы были довольны каждым треугольником.\n\nВыходные данные\n\nВходные данныеСкопировать3 0Выходные данныеСкопировать4Входные данныеСкопировать4 41 2 12 3 13 4 04 1 0Выходные данныеСкопировать1Входные данныеСкопировать4 41 2 12 3 13 4 04 1 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать3 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 2 12 3 13 4 04 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 2 12 3 13 4 04 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере четыре способа таковы:   Все любят друг друга;  1 и 2 любят друг друга, а 3 ненавидит 1 и 2 (а также два симметричных способа). Во втором примере единственный возможный способ — заставить 1 и 3 любить друг друга, а 2 и 4 — ненавидеть друг друга.",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 553 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n\n        ensuref(a != b, \"ai and bi must be different: ai=%d bi=%d\", a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> key = make_pair(u, v);\n\n        ensuref(edges.count(key) == 0, \"Pair (%d,%d) appears more than once\", u, v);\n        edges.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n\n        ensuref(a != b, \"ai and bi must be different: ai=%d bi=%d\", a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> key = make_pair(u, v);\n\n        ensuref(edges.count(key) == 0, \"Pair (%d,%d) appears more than once\", u, v);\n        edges.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int c = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n\n        ensuref(a != b, \"ai and bi must be different: ai=%d bi=%d\", a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n        pair<int, int> key = make_pair(u, v);\n\n        ensuref(edges.count(key) == 0, \"Pair (%d,%d) appears more than once\", u, v);\n        edges.insert(key);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", 0);\n\n    // To store known relationships\n    vector<tuple<int, int, int>> relationships;\n\n    if (type == \"no_known_relationships\") {\n        m = 0;\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // No relationships to output\n    } else if (type == \"random\") {\n        m = min(m, n*(n-1)/2);\n        set<pair<int,int>> edges;\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (a == b || edges.count({min(a,b), max(a,b)})) {\n                a = rnd.next(1, n);\n                b = rnd.next(1, n);\n            }\n            edges.insert({min(a,b), max(a,b)});\n            int c = rnd.next(0,1); // love or hate\n            relationships.push_back({a, b, c});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else if (type == \"impossible_case\") {\n        // Generate a small component where constraints are inconsistent\n        if (n < 3) n = 3;\n        m = 3;\n        relationships.push_back({1,2,1});\n        relationships.push_back({2,3,1});\n        relationships.push_back({1,3,0});\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else if (type == \"unique_case\") {\n        // Generate constraints that fix all variables\n        m = min((int)(n*(n-1)/2), 100000);\n        set<pair<int,int>> edges;\n        for (int i=1; i<=n && (int)relationships.size()<m; ++i) {\n            for (int j=i+1; j<=n && (int)relationships.size()<m; ++j) {\n                int c = rnd.next(0,1);\n                relationships.push_back({i, j, c});\n                edges.insert({i,j});\n            }\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)relationships.size());\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else if (type == \"multiple_components\") {\n        // Generate multiple disconnected components\n        int num_components = opt<int>(\"components\", 10);\n        vector<int> component_sizes;\n        int remaining = n;\n        for (int i = 0; i < num_components; ++i) {\n            int size = remaining / (num_components - i);\n            component_sizes.push_back(size);\n            remaining -= size;\n        }\n        int id = 1;\n        for (int sz : component_sizes) {\n            // For each component, generate relationships\n            int comp_m = min(sz*(sz-1)/2, m/(int)component_sizes.size());\n            set<pair<int,int>> edges;\n            for (int i = 0; i < comp_m; ++i) {\n                int a = rnd.next(id, id+sz-1);\n                int b = rnd.next(id, id+sz-1);\n                while (a == b || edges.count({min(a,b), max(a,b)})) {\n                    a = rnd.next(id, id+sz-1);\n                    b = rnd.next(id, id+sz-1);\n                }\n                edges.insert({min(a,b), max(a,b)});\n                int c = rnd.next(0,1);\n                relationships.push_back({a, b, c});\n            }\n            id += sz;\n        }\n        m = relationships.size();\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else {\n        // Default case, same as random\n        m = min(m, n*(n-1)/2);\n        set<pair<int,int>> edges;\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (a == b || edges.count({min(a,b), max(a,b)})) {\n                a = rnd.next(1, n);\n                b = rnd.next(1, n);\n            }\n            edges.insert({min(a,b), max(a,b)});\n            int c = rnd.next(0,1); // love or hate\n            relationships.push_back({a, b, c});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int m = opt<int>(\"m\", 0);\n\n    // To store known relationships\n    vector<tuple<int, int, int>> relationships;\n\n    if (type == \"no_known_relationships\") {\n        m = 0;\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // No relationships to output\n    } else if (type == \"random\") {\n        m = min(m, n*(n-1)/2);\n        set<pair<int,int>> edges;\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (a == b || edges.count({min(a,b), max(a,b)})) {\n                a = rnd.next(1, n);\n                b = rnd.next(1, n);\n            }\n            edges.insert({min(a,b), max(a,b)});\n            int c = rnd.next(0,1); // love or hate\n            relationships.push_back({a, b, c});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else if (type == \"impossible_case\") {\n        // Generate a small component where constraints are inconsistent\n        if (n < 3) n = 3;\n        m = 3;\n        relationships.push_back({1,2,1});\n        relationships.push_back({2,3,1});\n        relationships.push_back({1,3,0});\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else if (type == \"unique_case\") {\n        // Generate constraints that fix all variables\n        m = min((int)(n*(n-1)/2), 100000);\n        set<pair<int,int>> edges;\n        for (int i=1; i<=n && (int)relationships.size()<m; ++i) {\n            for (int j=i+1; j<=n && (int)relationships.size()<m; ++j) {\n                int c = rnd.next(0,1);\n                relationships.push_back({i, j, c});\n                edges.insert({i,j});\n            }\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, (int)relationships.size());\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else if (type == \"multiple_components\") {\n        // Generate multiple disconnected components\n        int num_components = opt<int>(\"components\", 10);\n        vector<int> component_sizes;\n        int remaining = n;\n        for (int i = 0; i < num_components; ++i) {\n            int size = remaining / (num_components - i);\n            component_sizes.push_back(size);\n            remaining -= size;\n        }\n        int id = 1;\n        for (int sz : component_sizes) {\n            // For each component, generate relationships\n            int comp_m = min(sz*(sz-1)/2, m/(int)component_sizes.size());\n            set<pair<int,int>> edges;\n            for (int i = 0; i < comp_m; ++i) {\n                int a = rnd.next(id, id+sz-1);\n                int b = rnd.next(id, id+sz-1);\n                while (a == b || edges.count({min(a,b), max(a,b)})) {\n                    a = rnd.next(id, id+sz-1);\n                    b = rnd.next(id, id+sz-1);\n                }\n                edges.insert({min(a,b), max(a,b)});\n                int c = rnd.next(0,1);\n                relationships.push_back({a, b, c});\n            }\n            id += sz;\n        }\n        m = relationships.size();\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    } else {\n        // Default case, same as random\n        m = min(m, n*(n-1)/2);\n        set<pair<int,int>> edges;\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (a == b || edges.count({min(a,b), max(a,b)})) {\n                a = rnd.next(1, n);\n                b = rnd.next(1, n);\n            }\n            edges.insert({min(a,b), max(a,b)});\n            int c = rnd.next(0,1); // love or hate\n            relationships.push_back({a, b, c});\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        for (auto& rel : relationships) {\n            int a, b, c;\n            tie(a,b,c) = rel;\n            printf(\"%d %d %d\\n\", a, b, c);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type no_known_relationships\n./gen -n 4 -type impossible_case\n./gen -n 5 -type unique_case\n./gen -n 100000 -type no_known_relationships\n./gen -n 100000 -type random -m 100000\n./gen -n 50000 -type unique_case\n./gen -n 100000 -type impossible_case\n./gen -n 100000 -type random -m 50000\n./gen -n 100000 -type multiple_components -components 100\n./gen -n 50000 -type random -m 100000\n./gen -n 1000 -type random -m 0\n./gen -n 1000 -type random -m 1000\n./gen -n 1000 -type random -m 10000\n./gen -n 3 -type impossible_case\n./gen -n 4 -type impossible_case\n./gen -n 5 -type impossible_case\n./gen -n 6 -type impossible_case\n./gen -n 7 -type impossible_case\n./gen -n 8 -type impossible_case\n./gen -n 100000 -type multiple_components -components 1\n./gen -n 100000 -type multiple_components -components 2\n./gen -n 99999 -type multiple_components -components 3\n./gen -n 99998 -type multiple_components -components 4\n./gen -n 99997 -type multiple_components -components 5\n./gen -n 100000 -type unique_case\n./gen -n 3 -type unique_case\n./gen -n 4 -type unique_case\n./gen -n 5 -type unique_case\n./gen -n 1000 -type unique_case\n./gen -n 99999 -type random -m 99999\n./gen -n 100000 -type random -m 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:09.557035",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "553/D",
      "title": "D. Nudist Beach",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers n, m, k (2  ≤  n  ≤ 100 000, 1 ≤ m ≤ 100 000, 1 ≤ k ≤ n - 1).The second line of input contains k integers, representing the cities with fortresses. These cities will all be distinct. The next m lines contain the roads. The i-th of these lines will have 2 integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Every city will have at least one road adjacent to it.There is no more than one road between each pair of the cities.",
      "output_spec": "OutputThe first line should contain an integer r, denoting the size of an optimum set (1 ≤ r ≤ n - k). The second line should contain r integers, denoting the cities in the set. Cities may follow in an arbitrary order. This line should not contain any of the cities with fortresses.If there are multiple possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy9 8 43 9 6 81 21 31 41 52 62 72 82 9OutputCopy31 4 5InputCopy10 8 22 91 32 94 55 66 77 88 1010 4OutputCopy81 5 4 8 10 6 3 7",
      "description": "D. Nudist Beach\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers n, m, k (2  ≤  n  ≤ 100 000, 1 ≤ m ≤ 100 000, 1 ≤ k ≤ n - 1).The second line of input contains k integers, representing the cities with fortresses. These cities will all be distinct. The next m lines contain the roads. The i-th of these lines will have 2 integers ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). Every city will have at least one road adjacent to it.There is no more than one road between each pair of the cities.\n\nOutputThe first line should contain an integer r, denoting the size of an optimum set (1 ≤ r ≤ n - k). The second line should contain r integers, denoting the cities in the set. Cities may follow in an arbitrary order. This line should not contain any of the cities with fortresses.If there are multiple possible answers, print any of them.\n\nInputCopy9 8 43 9 6 81 21 31 41 52 62 72 82 9OutputCopy31 4 5InputCopy10 8 22 91 32 94 55 66 77 88 1010 4OutputCopy81 5 4 8 10 6 3 7\n\nInputCopy9 8 43 9 6 81 21 31 41 52 62 72 82 9\n\nOutputCopy31 4 5\n\nInputCopy10 8 22 91 32 94 55 66 77 88 1010 4\n\nOutputCopy81 5 4 8 10 6 3 7\n\nNoteThe first example case achieves a strength of 1/2. No other subset is strictly better.The second example case achieves a strength of 1. Note that the subset doesn't necessarily have to be connected.",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 553 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    unordered_set<int> fortress;\n    for (int i = 0; i < k; ++i) {\n        int city = inf.readInt(1, n, \"fortress_i\");\n        if (i + 1 < k)\n            inf.readSpace();\n        else\n            inf.readEoln();\n\n        ensuref(fortress.count(city) == 0, \"Fortress cities must be distinct\");\n        fortress.insert(city);\n    }\n\n    vector<int> degrees(n + 1, 0);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a city to itself\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between two cities are not allowed\");\n        edges.insert({u, v});\n\n        degrees[a]++;\n        degrees[b]++;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(degrees[i] >= 1, \"Every city must have at least one road adjacent to it\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    unordered_set<int> fortress;\n    for (int i = 0; i < k; ++i) {\n        int city = inf.readInt(1, n, \"fortress_i\");\n        if (i + 1 < k)\n            inf.readSpace();\n        else\n            inf.readEoln();\n\n        ensuref(fortress.count(city) == 0, \"Fortress cities must be distinct\");\n        fortress.insert(city);\n    }\n\n    vector<int> degrees(n + 1, 0);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a city to itself\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between two cities are not allowed\");\n        edges.insert({u, v});\n\n        degrees[a]++;\n        degrees[b]++;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(degrees[i] >= 1, \"Every city must have at least one road adjacent to it\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, n - 1, \"k\");\n    inf.readEoln();\n\n    unordered_set<int> fortress;\n    for (int i = 0; i < k; ++i) {\n        int city = inf.readInt(1, n, \"fortress_i\");\n        if (i + 1 < k)\n            inf.readSpace();\n        else\n            inf.readEoln();\n\n        ensuref(fortress.count(city) == 0, \"Fortress cities must be distinct\");\n        fortress.insert(city);\n    }\n\n    vector<int> degrees(n + 1, 0);\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Edge cannot connect a city to itself\");\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        ensuref(edges.count({u, v}) == 0, \"Multiple edges between two cities are not allowed\");\n        edges.insert({u, v});\n\n        degrees[a]++;\n        degrees[b]++;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(degrees[i] >= 1, \"Every city must have at least one road adjacent to it\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, k;\nset<int> fortressSet;\nvector< set<int> > adj;\n\npair<long long, long long> readAns(InStream& stream) {\n    int r = stream.readInt(1, n - k, \"size of S\");\n    vector<int> S = stream.readInts(r, 1, n, \"cities in S\");\n    set<int> S_set(S.begin(), S.end());\n    if (S.size() != S_set.size()) {\n        stream.quitf(_wa, \"Cities in S are not unique\");\n    }\n    for (int city : S) {\n        if (fortressSet.count(city)) {\n            stream.quitf(_wa, \"City %d in S is a fortress\", city);\n        }\n    }\n\n    long long min_num = -1, min_den = 1;\n    for (int x : S) {\n        int total_neighbors = adj[x].size();\n        int neighbors_in_S = 0;\n        for (int neighbor : adj[x]) {\n            if (S_set.count(neighbor)) {\n                neighbors_in_S++;\n            }\n        }\n        if (total_neighbors == 0) {\n            stream.quitf(_fail, \"City %d has no neighbors\", x);\n        }\n        if (neighbors_in_S > total_neighbors) {\n            stream.quitf(_fail, \"Invalid number of neighbors in S for city %d\", x);\n        }\n        if (min_num == -1 || neighbors_in_S * min_den < min_num * total_neighbors ) {\n            min_num = neighbors_in_S;\n            min_den = total_neighbors;\n        }\n    }\n    return make_pair(min_num, min_den);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(2, 100000, \"n\");\n    m = inf.readInt(1, 100000, \"m\");\n    k = inf.readInt(1, n - 1, \"k\");\n\n    fortressSet = set<int>();\n    vector<int> fortresses = inf.readInts(k, 1, n, \"fortresses\");\n    for (int f : fortresses) {\n        fortressSet.insert(f);\n    }\n\n    adj.resize(n + 1); // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"ai\");\n        int v = inf.readInt(1, n, \"bi\");\n        if (u == v) {\n            quitf(_fail, \"Self-loop edge (%d, %d)\", u, v);\n        }\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    pair<long long, long long> jans = readAns(ans);\n    pair<long long, long long> pans = readAns(ouf);\n\n    long long j_num = jans.first, j_den = jans.second;\n    long long p_num = pans.first, p_den = pans.second;\n\n    if (p_num * j_den < j_num * p_den) {\n        quitf(_wa, \"Participant's minimal strength %.10f is less than jury's minimal strength %.10f\",\n              double(p_num) / p_den, double(j_num) / j_den);\n    } else if (p_num * j_den == j_num * p_den) {\n        quitf(_ok, \"Participant's minimal strength is equal to jury's: %.10f\", double(p_num) / p_den);\n    } else {\n        quitf(_fail, \"Participant's minimal strength %.10f is greater than jury's minimal strength %.10f\",\n              double(p_num) / p_den, double(j_num) / j_den);\n    }\n\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 2 || n > 100000)\n        ensuref(false, \"n must be between 2 and 100000\");\n    if (k < 1 || k > n - 1)\n        ensuref(false, \"k must be between 1 and n - 1\");\n    if (m < (n + 1) / 2)\n        ensuref(false, \"m must be at least ceil(n / 2)\");\n    if (m > min(1LL * n * (n - 1) / 2, 100000LL))\n        m = min(1LL * n * (n - 1) / 2, 100000LL);\n\n    // Generate k distinct fortresses\n    vector<int> cities(n);\n    for (int i = 0; i < n; ++i)\n        cities[i] = i + 1;\n    shuffle(cities.begin(), cities.end());\n    vector<int> fortresses(cities.begin(), cities.begin() + k);\n    sort(fortresses.begin(), fortresses.end());\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output fortresses\n    for (int i = 0; i < k; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", fortresses[i]);\n    }\n    printf(\"\\n\");\n\n    set<pair<int, int>> edge_set;\n    vector<int> degree(n + 1, 0);\n\n    // Ensure every city has at least one road adjacent to it\n    if (type == \"chain\") {\n        // Create a chain\n        for (int i = 1; i < n && (int)edge_set.size() < m; ++i) {\n            int u = i;\n            int v = i + 1;\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else if (type == \"star\") {\n        // Create a star\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n && (int)edge_set.size() < m; ++i) {\n            if (i != center) {\n                edge_set.insert({min(center, i), max(center, i)});\n                degree[center]++;\n                degree[i]++;\n            }\n        }\n    } else if (type == \"complete\") {\n        // Complete graph (small n)\n        for (int u = 1; u <= n && (int)edge_set.size() < m; ++u) {\n            for (int v = u + 1; v <= n && (int)edge_set.size() < m; ++v) {\n                edge_set.insert({u, v});\n                degree[u]++;\n                degree[v]++;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random graph\n        // First ensure each city has degree at least 1\n        vector<int> perm = cities;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = perm[i];\n            int v = perm[i + 1];\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        // Add additional random edges\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else if (type == \"disconnected\") {\n        // Create two disconnected components\n        int comp_size = n / 2;\n        vector<int> comp1(comp_size), comp2(n - comp_size);\n        for (int i = 0; i < comp_size; ++i)\n            comp1[i] = cities[i];\n        for (int i = comp_size; i < n; ++i)\n            comp2[i - comp_size] = cities[i];\n        // Connect nodes within each component\n        for (int i = 0; i < comp1.size() - 1; ++i) {\n            int u = comp1[i];\n            int v = comp1[i + 1];\n            if (edge_set.size() >= (size_t)m) break;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        for (int i = 0; i < comp2.size() - 1; ++i) {\n            int u = comp2[i];\n            int v = comp2[i + 1];\n            if (edge_set.size() >= (size_t)m) break;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        // Add additional random edges within components\n        while ((int)edge_set.size() < m) {\n            int component = rnd.next(1, 2);\n            int u, v;\n            if (component == 1) {\n                u = comp1[rnd.next(0, (int)comp1.size() - 1)];\n                v = comp1[rnd.next(0, (int)comp1.size() - 1)];\n            } else {\n                u = comp2[rnd.next(0, (int)comp2.size() - 1)];\n                v = comp2[rnd.next(0, (int)comp2.size() - 1)];\n            }\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else if (type == \"sparse\") {\n        // Create minimal edges to ensure every city has degree at least 1\n        vector<int> perm = cities;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n && (int)edge_set.size() < m; ++i) {\n            int u = perm[i];\n            int v = perm[(i + 1) % n];\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output edges\n    vector<pair<int, int>> edges(edge_set.begin(), edge_set.end());\n    shuffle(edges.begin(), edges.end());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 2 || n > 100000)\n        ensuref(false, \"n must be between 2 and 100000\");\n    if (k < 1 || k > n - 1)\n        ensuref(false, \"k must be between 1 and n - 1\");\n    if (m < (n + 1) / 2)\n        ensuref(false, \"m must be at least ceil(n / 2)\");\n    if (m > min(1LL * n * (n - 1) / 2, 100000LL))\n        m = min(1LL * n * (n - 1) / 2, 100000LL);\n\n    // Generate k distinct fortresses\n    vector<int> cities(n);\n    for (int i = 0; i < n; ++i)\n        cities[i] = i + 1;\n    shuffle(cities.begin(), cities.end());\n    vector<int> fortresses(cities.begin(), cities.begin() + k);\n    sort(fortresses.begin(), fortresses.end());\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output fortresses\n    for (int i = 0; i < k; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", fortresses[i]);\n    }\n    printf(\"\\n\");\n\n    set<pair<int, int>> edge_set;\n    vector<int> degree(n + 1, 0);\n\n    // Ensure every city has at least one road adjacent to it\n    if (type == \"chain\") {\n        // Create a chain\n        for (int i = 1; i < n && (int)edge_set.size() < m; ++i) {\n            int u = i;\n            int v = i + 1;\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else if (type == \"star\") {\n        // Create a star\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n && (int)edge_set.size() < m; ++i) {\n            if (i != center) {\n                edge_set.insert({min(center, i), max(center, i)});\n                degree[center]++;\n                degree[i]++;\n            }\n        }\n    } else if (type == \"complete\") {\n        // Complete graph (small n)\n        for (int u = 1; u <= n && (int)edge_set.size() < m; ++u) {\n            for (int v = u + 1; v <= n && (int)edge_set.size() < m; ++v) {\n                edge_set.insert({u, v});\n                degree[u]++;\n                degree[v]++;\n            }\n        }\n    } else if (type == \"random\") {\n        // Random graph\n        // First ensure each city has degree at least 1\n        vector<int> perm = cities;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n - 1; ++i) {\n            int u = perm[i];\n            int v = perm[i + 1];\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        // Add additional random edges\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else if (type == \"disconnected\") {\n        // Create two disconnected components\n        int comp_size = n / 2;\n        vector<int> comp1(comp_size), comp2(n - comp_size);\n        for (int i = 0; i < comp_size; ++i)\n            comp1[i] = cities[i];\n        for (int i = comp_size; i < n; ++i)\n            comp2[i - comp_size] = cities[i];\n        // Connect nodes within each component\n        for (int i = 0; i < comp1.size() - 1; ++i) {\n            int u = comp1[i];\n            int v = comp1[i + 1];\n            if (edge_set.size() >= (size_t)m) break;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        for (int i = 0; i < comp2.size() - 1; ++i) {\n            int u = comp2[i];\n            int v = comp2[i + 1];\n            if (edge_set.size() >= (size_t)m) break;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n        // Add additional random edges within components\n        while ((int)edge_set.size() < m) {\n            int component = rnd.next(1, 2);\n            int u, v;\n            if (component == 1) {\n                u = comp1[rnd.next(0, (int)comp1.size() - 1)];\n                v = comp1[rnd.next(0, (int)comp1.size() - 1)];\n            } else {\n                u = comp2[rnd.next(0, (int)comp2.size() - 1)];\n                v = comp2[rnd.next(0, (int)comp2.size() - 1)];\n            }\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else if (type == \"sparse\") {\n        // Create minimal edges to ensure every city has degree at least 1\n        vector<int> perm = cities;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 0; i < n && (int)edge_set.size() < m; ++i) {\n            int u = perm[i];\n            int v = perm[(i + 1) % n];\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n            degree[u]++;\n            degree[v]++;\n        }\n    } else {\n        ensuref(false, \"Unknown type: %s\", type.c_str());\n    }\n\n    // Output edges\n    vector<pair<int, int>> edges(edge_set.begin(), edge_set.end());\n    shuffle(edges.begin(), edges.end());\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small chain graph\n./gen -n 2 -m 1 -k 1 -type chain\n./gen -n 10 -m 9 -k 3 -type chain\n\n# Small star graph\n./gen -n 5 -m 4 -k 2 -type star\n./gen -n 10 -m 9 -k 5 -type star\n\n# Small complete graph\n./gen -n 5 -m 10 -k 2 -type complete\n\n# Random graphs with varying sizes\n./gen -n 100 -m 150 -k 10 -type random\n./gen -n 1000 -m 2000 -k 100 -type random\n./gen -n 10000 -m 50000 -k 500 -type random\n\n# Sparse graphs\n./gen -n 1000 -m 500 -k 200 -type sparse\n./gen -n 2000 -m 1000 -k 500 -type sparse\n\n# Disconnected graphs\n./gen -n 100 -m 100 -k 20 -type disconnected\n./gen -n 1000 -m 2000 -k 100 -type disconnected\n\n# Large star graph\n./gen -n 100000 -m 99999 -k 50000 -type star\n\n# Large chain graph\n./gen -n 100000 -m 99999 -k 1 -type chain\n\n# Random graphs with maximum edges\n./gen -n 100000 -m 100000 -k 1000 -type random\n\n# Graphs with maximal number of fortresses\n./gen -n 1000 -m 2000 -k 999 -type random\n./gen -n 10000 -m 20000 -k 9999 -type random\n\n# Graphs with minimal number of fortresses\n./gen -n 1000 -m 2000 -k 1 -type random\n./gen -n 10000 -m 20000 -k 1 -type random\n\n# Special test cases\n# Test with k = n - 1 (maximum number of fortresses)\n./gen -n 1000 -m 1500 -k 999 -type random\n\n# Test with small n, m and various types\n./gen -n 4 -m 2 -k 1 -type random\n./gen -n 4 -m 2 -k 1 -type chain\n./gen -n 4 -m 2 -k 1 -type star\n./gen -n 4 -m 2 -k 1 -type sparse\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:11.278391",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "553/E",
      "title": "E. Kyoya and Train",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test8 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of input contains four integers n, m, t, x (2  ≤  n  ≤ 50, 1 ≤ m ≤ 100, 1 ≤ t ≤ 20 000, 0 ≤ x ≤ 106).The next 2m lines contain the description of the trains. The 2i-th line will have 3 integers ai, bi, ci, representing a one way train from station ai to bi with ticket cost ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 0 ≤ ci ≤ 106). There will always be at least one path from any station to the school. The (2i + 1)-th line will contain t integers, pi, 1, pi, 2, ..., pi, t where pi, k / 100000 is the probability that this train will take k units of time to traverse (0 ≤ pi, k ≤ 100 000 for 1 ≤ k ≤ t, ). It is guaranteed that there is no more than one train between each pair of platforms in each of the directions.",
      "output_spec": "OutputPrint a single real number that is equal to an optimal expected cost of getting to school. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy4 4 5 11 2 050000 0 50000 0 02 3 010000 0 0 0 900003 4 0100000 0 0 0 02 4 00 0 0 50000 50000OutputCopy0.7000000000InputCopy4 4 5 11 2 10050000 0 50000 0 02 3 10010000 0 0 0 900003 4 100100000 0 0 0 02 4 1000 0 0 50000 50000OutputCopy200.7500000000",
      "description": "E. Kyoya and Train\n\ntime limit per test8 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains four integers n, m, t, x (2  ≤  n  ≤ 50, 1 ≤ m ≤ 100, 1 ≤ t ≤ 20 000, 0 ≤ x ≤ 106).The next 2m lines contain the description of the trains. The 2i-th line will have 3 integers ai, bi, ci, representing a one way train from station ai to bi with ticket cost ci (1 ≤ ai, bi ≤ n, ai ≠ bi, 0 ≤ ci ≤ 106). There will always be at least one path from any station to the school. The (2i + 1)-th line will contain t integers, pi, 1, pi, 2, ..., pi, t where pi, k / 100000 is the probability that this train will take k units of time to traverse (0 ≤ pi, k ≤ 100 000 for 1 ≤ k ≤ t, ). It is guaranteed that there is no more than one train between each pair of platforms in each of the directions.\n\nOutputPrint a single real number that is equal to an optimal expected cost of getting to school. The answer will be considered correct if its relative or absolute error doesn't exceed 10 - 6.\n\nInputCopy4 4 5 11 2 050000 0 50000 0 02 3 010000 0 0 0 900003 4 0100000 0 0 0 02 4 00 0 0 50000 50000OutputCopy0.7000000000InputCopy4 4 5 11 2 10050000 0 50000 0 02 3 10010000 0 0 0 900003 4 100100000 0 0 0 02 4 1000 0 0 50000 50000OutputCopy200.7500000000\n\nInputCopy4 4 5 11 2 050000 0 50000 0 02 3 010000 0 0 0 900003 4 0100000 0 0 0 02 4 00 0 0 50000 50000\n\nOutputCopy0.7000000000\n\nInputCopy4 4 5 11 2 10050000 0 50000 0 02 3 10010000 0 0 0 900003 4 100100000 0 0 0 02 4 1000 0 0 50000 50000\n\nOutputCopy200.7500000000\n\nNoteThe optimal strategy in the first case is as follows:First, travel along first train line. With probability 1 / 2 Kyoya will take 1 time unit. Otherwise, Kyoya will take 3 time units.If the train takes 1 time unit, travel along the 4th train line. Kyoya will make it to school in time with probability 1 / 2. Otherwise, if the train takes 3 time units, travel along the 2nd train line. Kyoya will make it to school in time with probability 1 / 10.Since the cost of all train lines are zero, we can just look at the probability that Kyoya will incur the penalty. The probability that Kyoya will have to pay the penalty is 1 / 2 × 1 / 2 + 1 / 2 × 9 / 10 = 7 / 10. We can show that no other strategy is strictly better.The optimal strategy in the second case is to travel along 1 → 2 → 4 no matter what. Kyoya will incur the penalty with probability 3 / 4, and the cost of the trains is 200, thus the expected cost is 200.75.",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 553 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 20000, \"t\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000, \"x\");\n    inf.readEoln();\n\n    // To keep track of duplicate trains\n    bool train_exists[51][51] = {false}; // 1-based indexing\n    // Build reverse adjacency list for checking connectivity\n    vector<int> rev_adj[51]; // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Train from %d to %d has ai == bi\", ai, bi);\n\n        // Check for duplicate trains\n        ensuref(!train_exists[ai][bi], \"Duplicate train from %d to %d\", ai, bi);\n        train_exists[ai][bi] = true;\n\n        // Build reversed adjacency list\n        rev_adj[bi].push_back(ai);\n\n        // Read t integers for pi_k\n        vector<int> pi = inf.readInts(t, 0, 100000, \"pi_k\");\n        inf.readEoln();\n\n        long long sum_pi = 0;\n        for (int k = 0; k < t; ++k) {\n            sum_pi += pi[k];\n        }\n        ensuref(sum_pi == 100000LL, \"Sum of pi_k for train %d from %d to %d is %lld, expected 100000\", i+1, ai, bi, sum_pi);\n    }\n\n    // Check that from every station, there is a path to station n\n    vector<bool> visited(n+1, false); // 1-based indexing\n\n    queue<int> q;\n    q.push(n);\n    visited[n] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : rev_adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    // Ensure all stations can reach station n\n    for (int s = 1; s <= n; ++s) {\n        ensuref(visited[s], \"Station %d cannot reach station %d\", s, n);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 20000, \"t\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000, \"x\");\n    inf.readEoln();\n\n    // To keep track of duplicate trains\n    bool train_exists[51][51] = {false}; // 1-based indexing\n    // Build reverse adjacency list for checking connectivity\n    vector<int> rev_adj[51]; // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Train from %d to %d has ai == bi\", ai, bi);\n\n        // Check for duplicate trains\n        ensuref(!train_exists[ai][bi], \"Duplicate train from %d to %d\", ai, bi);\n        train_exists[ai][bi] = true;\n\n        // Build reversed adjacency list\n        rev_adj[bi].push_back(ai);\n\n        // Read t integers for pi_k\n        vector<int> pi = inf.readInts(t, 0, 100000, \"pi_k\");\n        inf.readEoln();\n\n        long long sum_pi = 0;\n        for (int k = 0; k < t; ++k) {\n            sum_pi += pi[k];\n        }\n        ensuref(sum_pi == 100000LL, \"Sum of pi_k for train %d from %d to %d is %lld, expected 100000\", i+1, ai, bi, sum_pi);\n    }\n\n    // Check that from every station, there is a path to station n\n    vector<bool> visited(n+1, false); // 1-based indexing\n\n    queue<int> q;\n    q.push(n);\n    visited[n] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : rev_adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    // Ensure all stations can reach station n\n    for (int s = 1; s <= n; ++s) {\n        ensuref(visited[s], \"Station %d cannot reach station %d\", s, n);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 20000, \"t\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000, \"x\");\n    inf.readEoln();\n\n    // To keep track of duplicate trains\n    bool train_exists[51][51] = {false}; // 1-based indexing\n    // Build reverse adjacency list for checking connectivity\n    vector<int> rev_adj[51]; // 1-based indexing\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1000000, \"ci\");\n        inf.readEoln();\n\n        ensuref(ai != bi, \"Train from %d to %d has ai == bi\", ai, bi);\n\n        // Check for duplicate trains\n        ensuref(!train_exists[ai][bi], \"Duplicate train from %d to %d\", ai, bi);\n        train_exists[ai][bi] = true;\n\n        // Build reversed adjacency list\n        rev_adj[bi].push_back(ai);\n\n        // Read t integers for pi_k\n        vector<int> pi = inf.readInts(t, 0, 100000, \"pi_k\");\n        inf.readEoln();\n\n        long long sum_pi = 0;\n        for (int k = 0; k < t; ++k) {\n            sum_pi += pi[k];\n        }\n        ensuref(sum_pi == 100000LL, \"Sum of pi_k for train %d from %d to %d is %lld, expected 100000\", i+1, ai, bi, sum_pi);\n    }\n\n    // Check that from every station, there is a path to station n\n    vector<bool> visited(n+1, false); // 1-based indexing\n\n    queue<int> q;\n    q.push(n);\n    visited[n] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : rev_adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    // Ensure all stations can reach station n\n    for (int s = 1; s <= n; ++s) {\n        ensuref(visited[s], \"Station %d cannot reach station %d\", s, n);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    double juryAnswer = ans.readDouble();\n    double participantAnswer = ouf.readDouble();\n\n    const double MAX_DOUBLE_ERROR = 1E-6;\n    double absoluteError = fabs(juryAnswer - participantAnswer);\n\n    double relativeError = 0.0;\n    if (fabs(juryAnswer) > 1E-9) { // Avoid division by zero\n        relativeError = absoluteError / fabs(juryAnswer);\n    } else {\n        relativeError = absoluteError;\n    }\n\n    if (absoluteError <= MAX_DOUBLE_ERROR || relativeError <= MAX_DOUBLE_ERROR) {\n        if (!ouf.seekEof())\n            quitf(_wa, \"Extra tokens after the answer.\");\n        quitf(_ok, \"Accepted. Absolute error = %.10lf, Relative error = %.10lf.\", absoluteError, relativeError);\n    } else {\n        quitf(_wa, \"Wrong answer. Expected %.10lf, found %.10lf. Absolute error = %.10lf, Relative error = %.10lf.\", juryAnswer, participantAnswer, absoluteError, relativeError);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Revised generator that ensures from each station i (1 <= i < n) there is a path to station n:\n    - Always adds the \"chain\" edges i->(i+1) for i=1..(n-1).\n    - If type == \"star\", also adds edges from 1->i for i=2..n.\n    - If there is remaining capacity (m - currentEdges), we add random edges.\n    - If after adding all these edges we exceed m, we truncate from the end (so the chain remains).\n    - Hence, station n is always reachable from any station i.\n\n  Usage examples (each command prints one test case):\n    ./gen -n 5 -m 6 -t 5 -x 10 -type star\n    ./gen -n 10 -m 20 -t 10 -x 100 -type chain\n    ...\n\n  The parameter \"type\" can be one of:\n    - chain     => only the chain edges will be guaranteed, plus random edges.\n    - star      => chain edges + edges from 1->i for i=2..n, plus random edges.\n    - zeroCost  => all edges cost 0; chain always built, plus random (0-cost) edges if needed.\n    - largeCost => all edges cost 1,000,000; chain always built, plus random edges if needed.\n    - random    => chain with random costs, plus random edges with random costs.\n*/\n\nstatic const int MAX_COST = 1000000; // Per problem constraints\n\n// Decide cost by type\nint getEdgeCost(const string &type) {\n    if (type == \"zeroCost\") {\n        return 0;\n    } else if (type == \"largeCost\") {\n        return MAX_COST;\n    } else {\n        // chain, star, random => random cost\n        return rnd.next(0, MAX_COST);\n    }\n}\n\n// Add an edge if not already used\nvoid addEdge(vector< tuple<int,int,int> > &edges,\n             set< pair<int,int> > &used,\n             int a, int b, int c)\n{\n    // only add if not used\n    if (!used.count({a,b})) {\n        used.insert({a,b});\n        edges.push_back({a,b,c});\n    }\n}\n\n// Always add chain edges i->(i+1) for i=1..(n-1).\nvoid buildChainEdges(int n,\n                     const string &type,\n                     vector< tuple<int,int,int> > &edges,\n                     set< pair<int,int> > &used)\n{\n    for (int i = 1; i < n; i++) {\n        int cost = getEdgeCost(type);\n        addEdge(edges, used, i, i+1, cost);\n    }\n}\n\n// For type \"star\", add edges from 1->i for i=2..n.\nvoid buildStarEdges(int n,\n                    const string &type,\n                    vector< tuple<int,int,int> > &edges,\n                    set< pair<int,int> > &used)\n{\n    for (int i = 2; i <= n; i++) {\n        int cost = getEdgeCost(type);\n        addEdge(edges, used, 1, i, cost);\n    }\n}\n\n// Fill random edges up to \"need\" edges\nvoid buildRandomEdges(int n,\n                      const string &type,\n                      int need,\n                      vector< tuple<int,int,int> > &edges,\n                      set< pair<int,int> > &used)\n{\n    vector<pair<int,int>> allPairs;\n    allPairs.reserve(n*(n-1));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            allPairs.push_back({i,j});\n        }\n    }\n    shuffle(allPairs.begin(), allPairs.end());\n\n    int idx = 0;\n    while (need > 0 && idx < (int)allPairs.size()) {\n        auto [a,b] = allPairs[idx++];\n        if (!used.count({a,b})) {\n            int cost = getEdgeCost(type);\n            addEdge(edges, used, a, b, cost);\n            need--;\n        }\n    }\n}\n\n// Probability distribution: partition 100000 into t integers (>= 0).\nvector<int> randomProbabilityDistribution(int t) {\n    vector<int> cuts(t-1);\n    for (int i = 0; i < t-1; i++) {\n        cuts[i] = rnd.next(100001);\n    }\n    cuts.push_back(0);\n    cuts.push_back(100000);\n    sort(cuts.begin(), cuts.end());\n    vector<int> probs(t);\n    for (int i = 0; i < t; i++) {\n        probs[i] = cuts[i+1] - cuts[i];\n    }\n    return probs;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    int x = opt<int>(\"x\", 0);       // default\n    string type = opt<string>(\"type\", \"random\");\n\n    // We will build edges:\n    //   1) chain edges i->(i+1)\n    //   2) if star, edges from 1->i\n    //   3) random edges until we reach m\n    //   4) if too many edges, truncate from the tail (chain edges remain at front).\n\n    vector< tuple<int,int,int> > edges;\n    edges.reserve(m + 5); // small overhead\n    set< pair<int,int> > used;\n\n    // 1) chain\n    buildChainEdges(n, type, edges, used);\n\n    // 2) star if needed\n    if (type == \"star\") {\n        buildStarEdges(n, type, edges, used);\n    }\n\n    // 3) fill random edges up to m\n    int usedCount = (int)edges.size();\n    if (usedCount < m) {\n        int need = m - usedCount;\n        buildRandomEdges(n, type, need, edges, used);\n    }\n\n    // 4) truncate if we exceed m\n    if ((int)edges.size() > m) {\n        edges.resize(m);\n    }\n\n    // Output\n    cout << n << \" \" << (int)edges.size() << \" \" << t << \" \" << x << \"\\n\";\n    for (auto &e : edges) {\n        int a = get<0>(e);\n        int b = get<1>(e);\n        int c = get<2>(e);\n        cout << a << \" \" << b << \" \" << c << \"\\n\";\n\n        vector<int> probs = randomProbabilityDistribution(t);\n        for (int i = 0; i < t; i++) {\n            cout << probs[i] << (i+1 < t ? ' ' : '\\n');\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  Revised generator that ensures from each station i (1 <= i < n) there is a path to station n:\n    - Always adds the \"chain\" edges i->(i+1) for i=1..(n-1).\n    - If type == \"star\", also adds edges from 1->i for i=2..n.\n    - If there is remaining capacity (m - currentEdges), we add random edges.\n    - If after adding all these edges we exceed m, we truncate from the end (so the chain remains).\n    - Hence, station n is always reachable from any station i.\n\n  Usage examples (each command prints one test case):\n    ./gen -n 5 -m 6 -t 5 -x 10 -type star\n    ./gen -n 10 -m 20 -t 10 -x 100 -type chain\n    ...\n\n  The parameter \"type\" can be one of:\n    - chain     => only the chain edges will be guaranteed, plus random edges.\n    - star      => chain edges + edges from 1->i for i=2..n, plus random edges.\n    - zeroCost  => all edges cost 0; chain always built, plus random (0-cost) edges if needed.\n    - largeCost => all edges cost 1,000,000; chain always built, plus random edges if needed.\n    - random    => chain with random costs, plus random edges with random costs.\n*/\n\nstatic const int MAX_COST = 1000000; // Per problem constraints\n\n// Decide cost by type\nint getEdgeCost(const string &type) {\n    if (type == \"zeroCost\") {\n        return 0;\n    } else if (type == \"largeCost\") {\n        return MAX_COST;\n    } else {\n        // chain, star, random => random cost\n        return rnd.next(0, MAX_COST);\n    }\n}\n\n// Add an edge if not already used\nvoid addEdge(vector< tuple<int,int,int> > &edges,\n             set< pair<int,int> > &used,\n             int a, int b, int c)\n{\n    // only add if not used\n    if (!used.count({a,b})) {\n        used.insert({a,b});\n        edges.push_back({a,b,c});\n    }\n}\n\n// Always add chain edges i->(i+1) for i=1..(n-1).\nvoid buildChainEdges(int n,\n                     const string &type,\n                     vector< tuple<int,int,int> > &edges,\n                     set< pair<int,int> > &used)\n{\n    for (int i = 1; i < n; i++) {\n        int cost = getEdgeCost(type);\n        addEdge(edges, used, i, i+1, cost);\n    }\n}\n\n// For type \"star\", add edges from 1->i for i=2..n.\nvoid buildStarEdges(int n,\n                    const string &type,\n                    vector< tuple<int,int,int> > &edges,\n                    set< pair<int,int> > &used)\n{\n    for (int i = 2; i <= n; i++) {\n        int cost = getEdgeCost(type);\n        addEdge(edges, used, 1, i, cost);\n    }\n}\n\n// Fill random edges up to \"need\" edges\nvoid buildRandomEdges(int n,\n                      const string &type,\n                      int need,\n                      vector< tuple<int,int,int> > &edges,\n                      set< pair<int,int> > &used)\n{\n    vector<pair<int,int>> allPairs;\n    allPairs.reserve(n*(n-1));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            allPairs.push_back({i,j});\n        }\n    }\n    shuffle(allPairs.begin(), allPairs.end());\n\n    int idx = 0;\n    while (need > 0 && idx < (int)allPairs.size()) {\n        auto [a,b] = allPairs[idx++];\n        if (!used.count({a,b})) {\n            int cost = getEdgeCost(type);\n            addEdge(edges, used, a, b, cost);\n            need--;\n        }\n    }\n}\n\n// Probability distribution: partition 100000 into t integers (>= 0).\nvector<int> randomProbabilityDistribution(int t) {\n    vector<int> cuts(t-1);\n    for (int i = 0; i < t-1; i++) {\n        cuts[i] = rnd.next(100001);\n    }\n    cuts.push_back(0);\n    cuts.push_back(100000);\n    sort(cuts.begin(), cuts.end());\n    vector<int> probs(t);\n    for (int i = 0; i < t; i++) {\n        probs[i] = cuts[i+1] - cuts[i];\n    }\n    return probs;\n}\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    int x = opt<int>(\"x\", 0);       // default\n    string type = opt<string>(\"type\", \"random\");\n\n    // We will build edges:\n    //   1) chain edges i->(i+1)\n    //   2) if star, edges from 1->i\n    //   3) random edges until we reach m\n    //   4) if too many edges, truncate from the tail (chain edges remain at front).\n\n    vector< tuple<int,int,int> > edges;\n    edges.reserve(m + 5); // small overhead\n    set< pair<int,int> > used;\n\n    // 1) chain\n    buildChainEdges(n, type, edges, used);\n\n    // 2) star if needed\n    if (type == \"star\") {\n        buildStarEdges(n, type, edges, used);\n    }\n\n    // 3) fill random edges up to m\n    int usedCount = (int)edges.size();\n    if (usedCount < m) {\n        int need = m - usedCount;\n        buildRandomEdges(n, type, need, edges, used);\n    }\n\n    // 4) truncate if we exceed m\n    if ((int)edges.size() > m) {\n        edges.resize(m);\n    }\n\n    // Output\n    cout << n << \" \" << (int)edges.size() << \" \" << t << \" \" << x << \"\\n\";\n    for (auto &e : edges) {\n        int a = get<0>(e);\n        int b = get<1>(e);\n        int c = get<2>(e);\n        cout << a << \" \" << b << \" \" << c << \"\\n\";\n\n        vector<int> probs = randomProbabilityDistribution(t);\n        for (int i = 0; i < t; i++) {\n            cout << probs[i] << (i+1 < t ? ' ' : '\\n');\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Revised set of ~20 distinct commands to run this generator:\n\n# 1) Minimal corner: n=2, m=1, t=1, x=0, chain\n./gen -n 2 -m 1 -t 1 -x 0 -type chain\n\n# 2) Star test with n=5 (previously failed case, now corrected):\n./gen -n 5 -m 6 -t 5 -x 10 -type star\n\n# 3) Another small star\n./gen -n 5 -m 10 -t 5 -x 0 -type star\n\n# 4) Small random\n./gen -n 5 -m 5 -t 5 -x 0 -type random\n\n# 5) Larger n, chain\n./gen -n 10 -m 15 -t 10 -x 100 -type chain\n\n# 6) Larger n, star\n./gen -n 10 -m 20 -t 10 -x 500 -type star\n\n# 7) Larger n, random\n./gen -n 10 -m 25 -t 10 -x 999999 -type random\n\n# 8) Medium n, zeroCost\n./gen -n 12 -m 20 -t 15 -x 0 -type zeroCost\n\n# 9) Medium n, largeCost\n./gen -n 12 -m 20 -t 15 -x 1000 -type largeCost\n\n# 10) Medium random\n./gen -n 12 -m 30 -t 15 -x 500000 -type random\n\n# 11) Another chain test\n./gen -n 8 -m 10 -t 20 -x 100 -type chain\n\n# 12) Another star test\n./gen -n 8 -m 12 -t 20 -x 100 -type star\n\n# 13) n=15, moderately dense random\n./gen -n 15 -m 50 -t 25 -x 100 -type random\n\n# 14) n=20, chain, bigger T\n./gen -n 20 -m 25 -t 200 -x 0 -type chain\n\n# 15) n=20, star, bigger T\n./gen -n 20 -m 30 -t 200 -x 1000000 -type star\n\n# 16) n=20, largeCost, bigger T\n./gen -n 20 -m 35 -t 200 -x 100000 -type largeCost\n\n# 17) n=25, random, even bigger T\n./gen -n 25 -m 40 -t 500 -x 500000 -type random\n\n# 18) n=30, random, T = 1000\n./gen -n 30 -m 60 -t 1000 -x 1000000 -type random\n\n# 19) n=40, chain, T=2000\n./gen -n 40 -m 39 -t 2000 -x 777777 -type chain\n\n# 20) n=50, random, T=5000 \n./gen -n 50 -m 100 -t 5000 -x 1000000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:13.628067",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "554/A",
      "title": "A. Kyoya and Photobooks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will be a single string s (1 ≤ |s| ≤ 20). String s consists only of lowercase English letters.",
      "output_spec": "OutputOutput a single integer equal to the number of distinct photobooks Kyoya Ootori can make.",
      "sample_tests": "ExamplesInputCopyaOutputCopy51InputCopyhiOutputCopy76",
      "description": "A. Kyoya and Photobooks\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input will be a single string s (1 ≤ |s| ≤ 20). String s consists only of lowercase English letters.\n\nOutputOutput a single integer equal to the number of distinct photobooks Kyoya Ootori can make.\n\nInputCopyaOutputCopy51InputCopyhiOutputCopy76\n\nOutputCopy51\n\nInputCopyhi\n\nOutputCopy76\n\nNoteIn the first case, we can make 'ab','ac',...,'az','ba','ca',...,'za', and 'aa', producing a total of 51 distinct photo booklets.",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 554 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,20}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,20}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readToken(\"[a-z]{1,20}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"all_same\") {\n        /* String with all same letters */\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"all_distinct\") {\n        /* String with all distinct letters */\n        vector<char> letters(26);\n        iota(letters.begin(), letters.end(), 'a');\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += letters[i % 26];\n        }\n    } else if (type == \"palindrome\") {\n        /* Palindromic string */\n        string half;\n        for (int i = 0; i < (n + 1) / 2; i++) {\n            char c = rnd.next('a', 'z');\n            half += c;\n        }\n        s = half;\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            s += half[i];\n        }\n    } else if (type == \"alternating\") {\n        /* Alternating letters */\n        char c1 = rnd.next('a', 'z');\n        char c2 = rnd.next('a', 'z');\n        while (c2 == c1) c2 = rnd.next('a', 'z');\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0 ? c1 : c2);\n        }\n    } else {\n        /* Random string */\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"all_same\") {\n        /* String with all same letters */\n        char c = rnd.next('a', 'z');\n        s = string(n, c);\n    } else if (type == \"all_distinct\") {\n        /* String with all distinct letters */\n        vector<char> letters(26);\n        iota(letters.begin(), letters.end(), 'a');\n        shuffle(letters.begin(), letters.end());\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += letters[i % 26];\n        }\n    } else if (type == \"palindrome\") {\n        /* Palindromic string */\n        string half;\n        for (int i = 0; i < (n + 1) / 2; i++) {\n            char c = rnd.next('a', 'z');\n            half += c;\n        }\n        s = half;\n        for (int i = n / 2 - 1; i >= 0; i--) {\n            s += half[i];\n        }\n    } else if (type == \"alternating\") {\n        /* Alternating letters */\n        char c1 = rnd.next('a', 'z');\n        char c2 = rnd.next('a', 'z');\n        while (c2 == c1) c2 = rnd.next('a', 'z');\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += (i % 2 == 0 ? c1 : c2);\n        }\n    } else {\n        /* Random string */\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_same\n./gen -n 1 -type all_distinct\n./gen -n 1 -type palindrome\n./gen -n 1 -type alternating\n./gen -n 1 -type random\n\n./gen -n 2 -type all_same\n./gen -n 2 -type all_distinct\n./gen -n 2 -type palindrome\n./gen -n 2 -type alternating\n./gen -n 2 -type random\n\n./gen -n 5 -type all_same\n./gen -n 5 -type all_distinct\n./gen -n 5 -type palindrome\n./gen -n 5 -type alternating\n./gen -n 5 -type random\n\n./gen -n 10 -type all_same\n./gen -n 10 -type all_distinct\n./gen -n 10 -type palindrome\n./gen -n 10 -type alternating\n./gen -n 10 -type random\n\n./gen -n 15 -type all_same\n./gen -n 15 -type all_distinct\n./gen -n 15 -type palindrome\n./gen -n 15 -type alternating\n./gen -n 15 -type random\n\n./gen -n 20 -type all_same\n./gen -n 20 -type all_distinct\n./gen -n 20 -type palindrome\n./gen -n 20 -type alternating\n./gen -n 20 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:15.872143",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "554/B",
      "title": "B. Охана прибирается в комнате",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода находится единственное целое число n (1 ≤ n ≤ 100).В следующих n строках дано описано состояния комнаты. В i-й строке находится строка из n символов, обозначающих состояние i-й строки комнаты. В этой строке j-й символ равен '1', если j-й квадрат в i-й строке чистый, и '0', если он грязный.",
      "output_spec": "Выходные данныеВыведите целое число, равное максимальному возможному количеству строк, являющихся полностью чистыми.",
      "sample_tests": "ПримерыВходные данныеСкопировать40101100011110101Выходные данныеСкопировать2Входные данныеСкопировать3111111111Выходные данныеСкопировать3",
      "description": "B. Охана прибирается в комнате\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода находится единственное целое число n (1 ≤ n ≤ 100).В следующих n строках дано описано состояния комнаты. В i-й строке находится строка из n символов, обозначающих состояние i-й строки комнаты. В этой строке j-й символ равен '1', если j-й квадрат в i-й строке чистый, и '0', если он грязный.\n\nВходные данные\n\nВыходные данныеВыведите целое число, равное максимальному возможному количеству строк, являющихся полностью чистыми.\n\nВыходные данные\n\nВходные данныеСкопировать40101100011110101Выходные данныеСкопировать2Входные данныеСкопировать3111111111Выходные данныеСкопировать3\n\nВходные данныеСкопировать40101100011110101\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3111111111\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере Охана может подмести 1-й и 3-й столбцы. От этого 1-й и 4-й ряд станут полностью чистыми.Во втором примере комната уже чистая, так что Охане ничего не надо делать.",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 554 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[01]{\" + to_string(n) + \"}\", \"row\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[01]{\" + to_string(n) + \"}\", \"row\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(\"[01]{\" + to_string(n) + \"}\", \"row\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n);\n\n    if (type == \"all_ones\") {\n        // All '1's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, '1');\n        }\n    } else if (type == \"all_zeros\") {\n        // All '0's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, '0');\n        }\n    } else if (type == \"random\") {\n        // Random '0's and '1's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; ++j) {\n                grid[i] += (rnd.next(0,1) == 0 ? '0' : '1');\n            }\n        }\n    } else if (type == \"identical_rows\") {\n        // Generate a random row and repeat it n times\n        string row = \"\";\n        for (int j = 0; j < n; ++j) {\n            row += (rnd.next(0,1) == 0 ? '0' : '1');\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[i] = row;\n        }\n    } else if (type == \"unique_rows\") {\n        // Each row is unique\n        set<string> used_rows;\n        for (int i = 0; i < n; ++i) {\n            string row;\n            do {\n                row = \"\";\n                for (int j = 0; j < n; ++j) {\n                    row += (rnd.next(0,1) == 0 ? '0' : '1');\n                }\n            } while (used_rows.count(row));\n            used_rows.insert(row);\n            grid[i] = row;\n        }\n    } else if (type == \"max_same_flipping_mask\") {\n        // Generate rows with the same flipping mask\n        string mask = \"\";\n        for (int j = 0; j < n; ++j) {\n            mask += (rnd.next(0,1) == 0 ? '0' : '1');\n        }\n        for (int i = 0; i < n; ++i) {\n            string row = \"\";\n            for (int j = 0; j < n; ++j) {\n                if (mask[j] == '0') {\n                    // The cell can be '0' or '1' randomly\n                    row += (rnd.next(0,1) == 0 ? '0' : '1');\n                } else {\n                    // The cell must be '0' to match the flipping mask\n                    row += '0';\n                }\n            }\n            grid[i] = row;\n        }\n    } else if (type == \"max_different_flipping_masks\") {\n        // Generate rows with unique flipping masks\n        set<string> used_masks;\n        for (int i = 0; i < n; ++i) {\n            string row;\n            string mask;\n            do {\n                row = \"\";\n                for (int j = 0; j < n; ++j) {\n                    row += (rnd.next(0,1) == 0 ? '0' : '1');\n                }\n                // Compute flipping mask: '1' where the row has '0's\n                mask = \"\";\n                for (int j = 0; j < n; ++j) {\n                    mask += (row[j] == '0') ? '1' : '0';\n                }\n            } while (used_masks.count(mask));\n            used_masks.insert(mask);\n            grid[i] = row;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; ++j) {\n                grid[i] += (rnd.next(0,1) == 0 ? '0' : '1');\n            }\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        cout << grid[i] << endl;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n);\n\n    if (type == \"all_ones\") {\n        // All '1's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, '1');\n        }\n    } else if (type == \"all_zeros\") {\n        // All '0's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(n, '0');\n        }\n    } else if (type == \"random\") {\n        // Random '0's and '1's\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; ++j) {\n                grid[i] += (rnd.next(0,1) == 0 ? '0' : '1');\n            }\n        }\n    } else if (type == \"identical_rows\") {\n        // Generate a random row and repeat it n times\n        string row = \"\";\n        for (int j = 0; j < n; ++j) {\n            row += (rnd.next(0,1) == 0 ? '0' : '1');\n        }\n        for (int i = 0; i < n; ++i) {\n            grid[i] = row;\n        }\n    } else if (type == \"unique_rows\") {\n        // Each row is unique\n        set<string> used_rows;\n        for (int i = 0; i < n; ++i) {\n            string row;\n            do {\n                row = \"\";\n                for (int j = 0; j < n; ++j) {\n                    row += (rnd.next(0,1) == 0 ? '0' : '1');\n                }\n            } while (used_rows.count(row));\n            used_rows.insert(row);\n            grid[i] = row;\n        }\n    } else if (type == \"max_same_flipping_mask\") {\n        // Generate rows with the same flipping mask\n        string mask = \"\";\n        for (int j = 0; j < n; ++j) {\n            mask += (rnd.next(0,1) == 0 ? '0' : '1');\n        }\n        for (int i = 0; i < n; ++i) {\n            string row = \"\";\n            for (int j = 0; j < n; ++j) {\n                if (mask[j] == '0') {\n                    // The cell can be '0' or '1' randomly\n                    row += (rnd.next(0,1) == 0 ? '0' : '1');\n                } else {\n                    // The cell must be '0' to match the flipping mask\n                    row += '0';\n                }\n            }\n            grid[i] = row;\n        }\n    } else if (type == \"max_different_flipping_masks\") {\n        // Generate rows with unique flipping masks\n        set<string> used_masks;\n        for (int i = 0; i < n; ++i) {\n            string row;\n            string mask;\n            do {\n                row = \"\";\n                for (int j = 0; j < n; ++j) {\n                    row += (rnd.next(0,1) == 0 ? '0' : '1');\n                }\n                // Compute flipping mask: '1' where the row has '0's\n                mask = \"\";\n                for (int j = 0; j < n; ++j) {\n                    mask += (row[j] == '0') ? '1' : '0';\n                }\n            } while (used_masks.count(mask));\n            used_masks.insert(mask);\n            grid[i] = row;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < n; ++j) {\n                grid[i] += (rnd.next(0,1) == 0 ? '0' : '1');\n            }\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        cout << grid[i] << endl;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_ones\n./gen -n 1 -type all_zeros\n./gen -n 1 -type random\n./gen -n 1 -type identical_rows\n\n./gen -n 2 -type all_ones\n./gen -n 2 -type all_zeros\n./gen -n 2 -type random\n./gen -n 2 -type identical_rows\n\n./gen -n 5 -type all_ones\n./gen -n 5 -type all_zeros\n./gen -n 5 -type random\n./gen -n 5 -type identical_rows\n\n./gen -n 10 -type all_ones\n./gen -n 10 -type all_zeros\n./gen -n 10 -type random\n./gen -n 10 -type unique_rows\n./gen -n 10 -type max_same_flipping_mask\n./gen -n 10 -type max_different_flipping_masks\n\n./gen -n 50 -type random\n./gen -n 50 -type identical_rows\n./gen -n 50 -type unique_rows\n./gen -n 50 -type max_same_flipping_mask\n./gen -n 50 -type max_different_flipping_masks\n\n./gen -n 100 -type all_ones\n./gen -n 100 -type all_zeros\n./gen -n 100 -type random\n./gen -n 100 -type identical_rows\n./gen -n 100 -type unique_rows\n./gen -n 100 -type max_same_flipping_mask\n./gen -n 100 -type max_different_flipping_masks\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:17.873984",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "554/C",
      "title": "C. Кёя и цветные мячи",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода находить целое число k (1 ≤ k ≤ 1000) — количество цветов.Затем следуют k строк. В i-й строке находится число ci, количество мячей i-го цвета (1 ≤ ci ≤ 1000).Суммарное количество мячей не превосходит 1000.",
      "output_spec": "Выходные данныеВыведите единственное целое число — остаток от деления на 1 000 000 007 количества различных последовательностей цветов мячей, удовлетворяющих условию.",
      "sample_tests": "ПримерыВходные данныеСкопировать3221Выходные данныеСкопировать3Входные данныеСкопировать41234Выходные данныеСкопировать1680",
      "description": "C. Кёя и цветные мячи\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода находить целое число k (1 ≤ k ≤ 1000) — количество цветов.Затем следуют k строк. В i-й строке находится число ci, количество мячей i-го цвета (1 ≤ ci ≤ 1000).Суммарное количество мячей не превосходит 1000.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — остаток от деления на 1 000 000 007 количества различных последовательностей цветов мячей, удовлетворяющих условию.\n\nВыходные данные\n\nВходные данныеСкопировать3221Выходные данныеСкопировать3Входные данныеСкопировать41234Выходные данныеСкопировать1680\n\nВходные данныеСкопировать3221\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41234\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1680\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере у нас есть два мяча цвета 1, два мяча цвета 2, и один мяч цвета 3. Три возможных способа таковы: 1 2 1 2 31 1 2 2 32 1 1 2 3",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 554 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    int totalBalls = 0;\n    for (int i = 1; i <= k; ++i) {\n        char varName[20];\n        sprintf(varName, \"c_%d\", i);\n        int ci = inf.readInt(1, 1000, varName);\n        totalBalls += ci;\n        inf.readEoln();\n    }\n    ensuref(totalBalls <= 1000, \"Total number of balls should not exceed 1000, but totalBalls = %d\", totalBalls);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    int totalBalls = 0;\n    for (int i = 1; i <= k; ++i) {\n        char varName[20];\n        sprintf(varName, \"c_%d\", i);\n        int ci = inf.readInt(1, 1000, varName);\n        totalBalls += ci;\n        inf.readEoln();\n    }\n    ensuref(totalBalls <= 1000, \"Total number of balls should not exceed 1000, but totalBalls = %d\", totalBalls);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    int totalBalls = 0;\n    for (int i = 1; i <= k; ++i) {\n        char varName[20];\n        sprintf(varName, \"c_%d\", i);\n        int ci = inf.readInt(1, 1000, varName);\n        totalBalls += ci;\n        inf.readEoln();\n    }\n    ensuref(totalBalls <= 1000, \"Total number of balls should not exceed 1000, but totalBalls = %d\", totalBalls);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    int n = opt<int>(\"n\", 0); // n is optional, default to 0 (means we'll compute it)\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k < 1 || k > 1000) {\n        printf(\"Error: k must be between 1 and 1000\\n\");\n        return 1;\n    }\n\n    if (n == 0) {\n        n = 1000; // default maximum total sum of ci\n    }\n\n    if (n > 1000) n = 1000;\n    if (n < k) n = k; // At least ci=1 for each color\n\n    vector<int> c(k);\n\n    int N = 0;\n\n    if (type == \"min\") {\n        // ci = 1 for all i\n        fill(c.begin(), c.end(), 1);\n        N = k;\n    } else if (type == \"max\") {\n        // ci = as big as possible, but ci ≤ 1000\n        int base = min(1000, n / k);\n        if (base == 0) base = 1;\n        int rem = n - base * k;\n        for (int i = 0; i < k; ++i) {\n            c[i] = base;\n            if (i < rem && c[i] < 1000) {\n                c[i]++;\n            }\n            N += c[i];\n        }\n    } else if (type == \"ci_equal\") {\n        int base = n / k;\n        if (base == 0) base = 1;\n        int rem = n - base * k;\n        for (int i = 0; i < k; ++i) {\n            c[i] = base;\n            if (i < rem && c[i] < 1000) c[i]++;\n            N += c[i];\n        }\n    } else if (type == \"ci_increasing\") {\n        // ci increasing from 1\n        N = 0;\n        for (int i = 0; i < k; ++i) {\n            c[i] = i + 1;\n            N += c[i];\n        }\n        if (N > n) {\n            // Scale down ci proportionally\n            double scale = (double)n / N;\n            N = 0;\n            for (int i = 0; i < k; ++i) {\n                c[i] = max(1, (int)(c[i] * scale));\n                N += c[i];\n            }\n        }\n        while (N < n) {\n            for (int i = 0; i < k && N < n; ++i) {\n                if (c[i] < 1000) {\n                    c[i]++;\n                    N++;\n                }\n            }\n        }\n    } else if (type == \"ci_decreasing\") {\n        // ci decreasing from k\n        N = 0;\n        for (int i = 0; i < k; ++i) {\n            c[i] = k - i;\n            N += c[i];\n        }\n        if (N > n) {\n            // Scale down ci proportionally\n            double scale = (double)n / N;\n            N = 0;\n            for (int i = 0; i < k; ++i) {\n                c[i] = max(1, (int)(c[i] * scale));\n                N += c[i];\n            }\n        }\n        while (N < n) {\n            for (int i = 0; i < k && N < n; ++i) {\n                if (c[i] < 1000) {\n                    c[i]++;\n                    N++;\n                }\n            }\n        }\n    } else if (type == \"ci_one_large_rest_small\") {\n        if (k ==1) {\n            c[0] = min(n, 1000);\n            N = c[0];\n        } else {\n            c[0] = min(1000, n - (k - 1));\n            N += c[0];\n            for (int i = 1; i < k; ++i) {\n                c[i] = 1;\n                N += 1;\n            }\n        }\n    } else if (type == \"ci_one_small_rest_large\") {\n        if (k ==1) {\n            c[0] = min(n, 1000);\n            N = c[0];\n        } else {\n            c[0] = 1;\n            N += 1;\n            int base = (n - 1) / (k - 1);\n            if (base == 0) base = 1;\n            int rem = (n - 1) - base * (k - 1);\n            for (int i = 1; i < k; ++i) {\n                c[i] = min(1000, base);\n                if (rem > 0 && c[i] < 1000) {\n                    c[i]++;\n                    rem--;\n                }\n                N += c[i];\n            }\n        }\n    } else if (type == \"ci_random\") {\n        N = 0;\n        int remaining = n;\n        for (int i = 0; i < k; ++i) {\n            int min_ci = 1;\n            int max_ci = min(1000, remaining - (k - i - 1)*1);\n            c[i] = rnd.next(min_ci, max_ci);\n            N += c[i];\n            remaining -= c[i];\n        }\n    } else { // default is random\n        N = 0;\n        int remaining = n;\n        for (int i = 0; i < k; ++i) {\n            int min_ci = 1;\n            int max_ci = min(1000, remaining - (k - i - 1)*1);\n            c[i] = rnd.next(min_ci, max_ci);\n            N += c[i];\n            remaining -= c[i];\n        }\n    }\n\n    // Ensure ci[i] in [1, 1000]\n    for (int i = 0; i < k; ++i) {\n        if (c[i] < 1) c[i] = 1;\n        if (c[i] > 1000) c[i] = 1000;\n    }\n\n    // Ensure N ≤ n and N ≤ 1000\n    if (N > n) {\n        printf(\"Error: Sum of ci exceeds n\\n\");\n        return 1;\n    }\n    if (N > 1000) {\n        printf(\"Error: Sum of ci exceeds 1000\\n\");\n        return 1;\n    }\n\n    // Output k\n    printf(\"%d\\n\", k);\n    // Output ci\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d\\n\", c[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int k = opt<int>(\"k\");\n    int n = opt<int>(\"n\", 0); // n is optional, default to 0 (means we'll compute it)\n    string type = opt<string>(\"type\", \"random\");\n\n    if (k < 1 || k > 1000) {\n        printf(\"Error: k must be between 1 and 1000\\n\");\n        return 1;\n    }\n\n    if (n == 0) {\n        n = 1000; // default maximum total sum of ci\n    }\n\n    if (n > 1000) n = 1000;\n    if (n < k) n = k; // At least ci=1 for each color\n\n    vector<int> c(k);\n\n    int N = 0;\n\n    if (type == \"min\") {\n        // ci = 1 for all i\n        fill(c.begin(), c.end(), 1);\n        N = k;\n    } else if (type == \"max\") {\n        // ci = as big as possible, but ci ≤ 1000\n        int base = min(1000, n / k);\n        if (base == 0) base = 1;\n        int rem = n - base * k;\n        for (int i = 0; i < k; ++i) {\n            c[i] = base;\n            if (i < rem && c[i] < 1000) {\n                c[i]++;\n            }\n            N += c[i];\n        }\n    } else if (type == \"ci_equal\") {\n        int base = n / k;\n        if (base == 0) base = 1;\n        int rem = n - base * k;\n        for (int i = 0; i < k; ++i) {\n            c[i] = base;\n            if (i < rem && c[i] < 1000) c[i]++;\n            N += c[i];\n        }\n    } else if (type == \"ci_increasing\") {\n        // ci increasing from 1\n        N = 0;\n        for (int i = 0; i < k; ++i) {\n            c[i] = i + 1;\n            N += c[i];\n        }\n        if (N > n) {\n            // Scale down ci proportionally\n            double scale = (double)n / N;\n            N = 0;\n            for (int i = 0; i < k; ++i) {\n                c[i] = max(1, (int)(c[i] * scale));\n                N += c[i];\n            }\n        }\n        while (N < n) {\n            for (int i = 0; i < k && N < n; ++i) {\n                if (c[i] < 1000) {\n                    c[i]++;\n                    N++;\n                }\n            }\n        }\n    } else if (type == \"ci_decreasing\") {\n        // ci decreasing from k\n        N = 0;\n        for (int i = 0; i < k; ++i) {\n            c[i] = k - i;\n            N += c[i];\n        }\n        if (N > n) {\n            // Scale down ci proportionally\n            double scale = (double)n / N;\n            N = 0;\n            for (int i = 0; i < k; ++i) {\n                c[i] = max(1, (int)(c[i] * scale));\n                N += c[i];\n            }\n        }\n        while (N < n) {\n            for (int i = 0; i < k && N < n; ++i) {\n                if (c[i] < 1000) {\n                    c[i]++;\n                    N++;\n                }\n            }\n        }\n    } else if (type == \"ci_one_large_rest_small\") {\n        if (k ==1) {\n            c[0] = min(n, 1000);\n            N = c[0];\n        } else {\n            c[0] = min(1000, n - (k - 1));\n            N += c[0];\n            for (int i = 1; i < k; ++i) {\n                c[i] = 1;\n                N += 1;\n            }\n        }\n    } else if (type == \"ci_one_small_rest_large\") {\n        if (k ==1) {\n            c[0] = min(n, 1000);\n            N = c[0];\n        } else {\n            c[0] = 1;\n            N += 1;\n            int base = (n - 1) / (k - 1);\n            if (base == 0) base = 1;\n            int rem = (n - 1) - base * (k - 1);\n            for (int i = 1; i < k; ++i) {\n                c[i] = min(1000, base);\n                if (rem > 0 && c[i] < 1000) {\n                    c[i]++;\n                    rem--;\n                }\n                N += c[i];\n            }\n        }\n    } else if (type == \"ci_random\") {\n        N = 0;\n        int remaining = n;\n        for (int i = 0; i < k; ++i) {\n            int min_ci = 1;\n            int max_ci = min(1000, remaining - (k - i - 1)*1);\n            c[i] = rnd.next(min_ci, max_ci);\n            N += c[i];\n            remaining -= c[i];\n        }\n    } else { // default is random\n        N = 0;\n        int remaining = n;\n        for (int i = 0; i < k; ++i) {\n            int min_ci = 1;\n            int max_ci = min(1000, remaining - (k - i - 1)*1);\n            c[i] = rnd.next(min_ci, max_ci);\n            N += c[i];\n            remaining -= c[i];\n        }\n    }\n\n    // Ensure ci[i] in [1, 1000]\n    for (int i = 0; i < k; ++i) {\n        if (c[i] < 1) c[i] = 1;\n        if (c[i] > 1000) c[i] = 1000;\n    }\n\n    // Ensure N ≤ n and N ≤ 1000\n    if (N > n) {\n        printf(\"Error: Sum of ci exceeds n\\n\");\n        return 1;\n    }\n    if (N > 1000) {\n        printf(\"Error: Sum of ci exceeds 1000\\n\");\n        return 1;\n    }\n\n    // Output k\n    printf(\"%d\\n\", k);\n    // Output ci\n    for(int i = 0; i < k; ++i) {\n        printf(\"%d\\n\", c[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -k 1 -n 1 -type min\n./gen -k 1 -n 1000 -type max\n./gen -k 1000 -type min\n./gen -k 500 -n 1000 -type random\n./gen -k 7 -n 20 -type ci_equal\n./gen -k 5 -n 15 -type ci_increasing\n./gen -k 500 -n 1000 -type ci_increasing\n./gen -k 5 -n 15 -type ci_decreasing\n./gen -k 500 -n 1000 -type ci_decreasing\n./gen -k 5 -n 1000 -type ci_one_large_rest_small\n./gen -k 5 -n 1000 -type ci_one_small_rest_large\n./gen -k 1000 -n 1000 -type ci_one_large_rest_small\n./gen -k 1000 -n 1000 -type ci_one_small_rest_large\n./gen -k 1 -type random\n./gen -k 1000 -n 1000 -type random\n./gen -k 500 -n 500 -type ci_equal\n./gen -k 3 -n 10 -type ci_equal\n./gen -k 10 -n 10 -type ci_one_large_rest_small\n./gen -k 10 -n 10 -type ci_one_small_rest_large\n./gen -k 50 -n 1000 -type ci_increasing\n./gen -k 50 -n 1000 -type ci_decreasing\n./gen -k 2 -n 1000 -type random\n./gen -k 1000 -n 1000 -type ci_equal\n./gen -k 2 -n 1000 -type max\n./gen -k 1000 -type min\n./gen -k 50 -type random\n./gen -k 20 -type ci_increasing\n./gen -k 20 -type ci_decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:19.610783",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "554/D",
      "title": "D. Kyoya and Permutation",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line will contain two integers n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ min{1018, l} where l is the length of the Kyoya's list).",
      "output_spec": "OutputPrint n space-separated integers, representing the permutation that is the answer for the question.",
      "sample_tests": "ExamplesInputCopy4 3OutputCopy1 3 2 4InputCopy10 1OutputCopy1 2 3 4 5 6 7 8 9 10",
      "description": "D. Kyoya and Permutation\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line will contain two integers n, k (1 ≤ n ≤ 50, 1 ≤ k ≤ min{1018, l} where l is the length of the Kyoya's list).\n\nOutputPrint n space-separated integers, representing the permutation that is the answer for the question.\n\nInputCopy4 3OutputCopy1 3 2 4InputCopy10 1OutputCopy1 2 3 4 5 6 7 8 9 10\n\nInputCopy4 3\n\nOutputCopy1 3 2 4\n\nInputCopy10 1\n\nOutputCopy1 2 3 4 5 6 7 8 9 10\n\nNoteThe standard cycle representation is (1)(32)(4), which after removing parenthesis gives us the original permutation. The first permutation on the list would be [1, 2, 3, 4], while the second permutation would be [1, 2, 4, 3].",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 554 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,50,\"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL,1000000000000000000LL,\"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,50,\"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL,1000000000000000000LL,\"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1,50,\"n\");\n    inf.readSpace();\n    long long k = inf.readLong(1LL,1000000000000000000LL,\"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\", 1);\n    // Ensure that n and k are within constraints\n    if (n < 1 || n > 50){\n        fprintf(stderr, \"n is out of bounds\\n\");\n        abort();\n    }\n    if (k < 1 || k > 1000000000000000000LL){\n        fprintf(stderr, \"k is out of bounds\\n\");\n        abort();\n    }\n    printf(\"%d %lld\\n\", n, k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    long long k = opt<long long>(\"k\", 1);\n    // Ensure that n and k are within constraints\n    if (n < 1 || n > 50){\n        fprintf(stderr, \"n is out of bounds\\n\");\n        abort();\n    }\n    if (k < 1 || k > 1000000000000000000LL){\n        fprintf(stderr, \"k is out of bounds\\n\");\n        abort();\n    }\n    printf(\"%d %lld\\n\", n, k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1\n\n./gen -n 2 -k 1\n./gen -n 2 -k 2\n\n./gen -n 3 -k 1\n./gen -n 3 -k 2\n./gen -n 3 -k 3\n\n./gen -n 4 -k 1\n./gen -n 4 -k 6\n\n./gen -n 5 -k 1\n./gen -n 5 -k 10\n\n./gen -n 6 -k 1\n./gen -n 6 -k 20\n\n./gen -n 7 -k 1\n./gen -n 7 -k 36\n\n./gen -n 8 -k 1\n./gen -n 8 -k 70\n\n./gen -n 9 -k 1\n\n./gen -n 10 -k 1\n\n./gen -n 15 -k 1\n\n./gen -n 20 -k 1\n\n./gen -n 25 -k 1\n\n./gen -n 30 -k 1\n\n./gen -n 35 -k 1\n\n./gen -n 40 -k 1\n\n./gen -n 45 -k 1\n\n./gen -n 50 -k 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:21.774461",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "554/E",
      "title": "E. Любовные треугольники",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входа записано два целых числа n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).В следующих m строках записано описание известных отношений. В i-й строке записано три целых числа ai, bi, ci. Если ci равно 1, тогда ai и bi любят друг друга, в противном случае, они ненавидят друг друга (1 ≤ ai, bi ≤ n, ai ≠ bi, ).Каждая пара людей описана не более, чем один раз.",
      "output_spec": "Выходные данныеВыведите единственное целое число, равное остатку от деления на 1 000 000 007 количества способов заполнения оставшихся пар так, чтобы вы были довольны каждым треугольником.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 0Выходные данныеСкопировать4Входные данныеСкопировать4 41 2 12 3 13 4 04 1 0Выходные данныеСкопировать1Входные данныеСкопировать4 41 2 12 3 13 4 04 1 1Выходные данныеСкопировать0",
      "description": "E. Любовные треугольники\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входа записано два целых числа n, m (3 ≤ n ≤ 100 000, 0 ≤ m ≤ 100 000).В следующих m строках записано описание известных отношений. В i-й строке записано три целых числа ai, bi, ci. Если ci равно 1, тогда ai и bi любят друг друга, в противном случае, они ненавидят друг друга (1 ≤ ai, bi ≤ n, ai ≠ bi, ).Каждая пара людей описана не более, чем один раз.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число, равное остатку от деления на 1 000 000 007 количества способов заполнения оставшихся пар так, чтобы вы были довольны каждым треугольником.\n\nВыходные данные\n\nВходные данныеСкопировать3 0Выходные данныеСкопировать4Входные данныеСкопировать4 41 2 12 3 13 4 04 1 0Выходные данныеСкопировать1Входные данныеСкопировать4 41 2 12 3 13 4 04 1 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать3 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 2 12 3 13 4 04 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 2 12 3 13 4 04 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере четыре способа таковы:   Все любят друг друга;  1 и 2 любят друг друга, а 3 ненавидит 1 и 2 (а также два симметричных способа). Во втором примере единственный возможный способ — заставить 1 и 3 любить друг друга, а 2 и 4 — ненавидеть друг друга.",
      "solutions": [
        {
          "title": "Codeforces Round #309 - Codeforces",
          "content": "Hello Codeforces!I invite all of you to participate in regular Codeforces round #309 that will take place on 24 June, 19:30 MSK.Some of you may know me as lg5293 on Topcoder (you can see some of my past problems here), but this is my first time ever writing a Codeforces round. I've designed all the problems myself and I hope you enjoy them.I want to thank ctunoku for helping me come up with stories for the problems, Zlobober for his immense help with preparation for this round, winger for testing the problems, Delinur for translating statements, and of course MikeMirzayanov for the superb Codeforces and Polygon systems.I hope to see you all at the round. Good luck and have fun! :)UPD: Scoring will be dynamic. Problems will be arranged by what I think is increasing difficulty. UPD: Editorial is here. Congratulations to the top 5:Div 1: ecnerwala scott_wu enot110 KADR yeputons Div2: Elsa_Elsa Chenyao cdkrot Shayan M_H_M",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18825",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces",
          "content": "Div2A: Kyoya and PhotobooksSolving this problem just requires us to simulate adding every character at every position at the string, and removing any duplicates. For instance, we can use a HashSet of Strings in Java to do this (a set in C++ or Python works as well). Bonus: Prove that the number of ways is always (length of string + 1) * 25 + 1.Example code: http://codeforces.com/contest/554/submission/11767578Div2B: Ohana Cleans UpFor each row, there is only one set of columns we can sweep so it becomes completely clean. So, there are only n configurations of sweeping columns to look at. Checking a configuration takes O(n2) time to count the number of rows that are completely clean. There are n configurations in all, so this takes O(n3) time total. Alternatively, another way of solving this problem is finding the maximum number of rows that are all the same.Example code: http://codeforces.com/contest/554/submission/11767576Div2C/Div1A: Kyoya and Colored BallsLet fi be the number of ways to solve the problem using only the first i colors. We want to compute fn.Initially, we have f1  =  1, since we only have a single color, and balls of the same color are indistinguishable. Now, to go from fi to fi + 1, we note that we need to put at a ball of color i + 1 at the very end, but the other balls of color i + 1 can go anywhere in the sequence. The number of ways to arrange the balls of color i + 1 is (minus one because we need to put one ball at the very end). Using this recurrence, we can solve for fn. Thus, we need to precompute binomial coefficients then evaluate the product.Example code: http://codeforces.com/contest/553/submission/11767584Div2D/Div1B: Kyoya and PermutationSolving this requires making the observation that only swaps between adjacent elements are allowed, and all of these swaps must be disjoint. This can be discovered by writing a brute force program, or just noticing the pattern for small n.Here's a proof for why this is. Consider the cycle that contains n. Since n is the largest number, it must be the last cycle in the sequence, and it's the first element of the sequence. If this cycle is length 1, then we're obviously ok (we can always append (n) to the end). If the cycle is of length 2, we need n to be involved in a cycle with n - 1. Lastly, if the cycle is of length 3 or more, we will see we run into a problem. We'll only show this for a cycle of length 3 (though this argument does generalize to cycles of larger length). Let (nxy) be the cycle. So that means, n is replaced by x, x is replaced by y and y is replaced by n. So, in other words, the original permutation involving this cycle must look like position: ... y x n\nnumber : ... n y xHowever, we need it to look like (nxy) so this case is impossible.So, once we know that n is a in a cycle of length 1 or 2, we can ignore the last 1 or 2 elements of the permutation and repeat our reasoning. Thus, the only valid cases are when we swap adjacent elements, and all swaps are disjoint. After making this observation, we can see the number of valid permutations of length n is fib(n+1). (to see this, write try writing a recurrence). To reconstruct the kth permutation in the list, we can do this recursively as follows: If k is less than fib(n), then 1 must be the very first element, and append the kth permutation on {1,...,n-1} with 1 added everywhere. Otherwise, add 2, 1 to the very front and append the k-fib(n)th permutation on {1,...,n-2} with 2 added everywhere.Example code: http://codeforces.com/contest/553/submission/11767583Div2E/Div1C: Love TrianglesLet's look at the graph of characters who love each other. Each love-connected component can be collapsed into a single node, since we know that all characters in the same connected component must love each other.Now, we claim that the resulting collapsed graph with the hate edges has a solution if and only if the resulting graph is bipartite.To show this, suppose the graph is not bipartite. Then, there is an odd cycle. If the cycle is of length 1, it is a self edge, which clearly isn't allowed (since a node must love itself). For any odd cycle of length more than 1, let's label the nodes in the cycle a1, a2, a3, ..., ak. Then, in general, we must have ai loves a(i + 2), since ai, a(i + 1) hate each other and a(i + 1), a(i + 2) hate each other (all indicies taken mod k). However, we can use the fact that the cycle is odd and eventually get that ai and ai + 1 love each other. However, this is a contradiction, since we said they must originally hate each other.For the other direction, suppose the graph is bipartite. Let X, Y be an arbitrary bipartition of the graph. If we let all nodes in X love each other and all nodes in Y love each other, and every edge between X and Y hate each other, then we get a solution. (details are omitted, though I can elaborate if needed).Thus, we can see that we have a solution if and only if the graph is bipartite. So, if the graph is not bipartite, the answer is zero. Otherwise, the second part of the proof gives us a way to count. We just need to count the number of different bipartitions of the graph. It's not too hard to see that this is just simply 2^(number of connected components — 1) (once you fix a node, you fix every node connected to it). This entire algorithm takes O(N + M) time. Example code: http://codeforces.com/contest/553/submission/11767582Div1D: Nudist BeachThe algorithm idea works as follows:Start with all allowed nodes. Remove the node with the smallest ratio. Repeat. Take the best ratio over all iterations. It's only necessary to consider these subsets. Proof for why.We say this process finds a ratio of at least p if and only if there exists a subset with ratio at least p.Exists a subset with ratio at least p => algorithm will find answer of at least p. First, observe that the ratio of any particular node only decreases throughout the algorithm. Thus, all nodes in this subset initally have ratio at least p. Then, the very first node that gets removed from this subset must not have ratio smaller than p, thus the above algorithm will record an answer of at least p.Exists no subset with ratio at least p => algorithm finds answer at most p. No subset with ratio at least p implies every subset has ratio at most p. Thus, at every iteration of our algorithm, we'll get an answer of at most p, so we're done.Thus, we can see these are necessary and sufficient conditions, so we're done.Now for efficient implementation, we can use a variant of Dijkstra's. Recording the best subset must be done a bit more carefully as well.Example code: http://codeforces.com/contest/553/submission/11767581Div1E: Kyoya and TrainThe Naive solution is O(MT2). Let Wj(t) be the optimal expected time given we are at node j, with t time units left. Also, let We(t) be the optimal expected time given we use edge e at time t.Now, we have And, if e = (u->v), we have Doing all this naively takes O(MT2).Now, we'll speed this up using FFT. We'll focus on only a single edge for now. The problem here, however, is that not all Wv values are given in advance. Namely, the Wv values require us to compute the We values for all edges at a particular time, and vice versa. So we need some sort of fast \"online\" version of FFT.We do this as follows. Let's abstract away the original problem, and let's say we're given two arrays a,b, where a is only revealed one at a time to us, and b is given up front, and we need to compute c, their convolution (in the original problem b is Pe, and a is Wv, and c is We). Now, when we get the ith value of a, we need to return the ith value of the convolution of c. We can only get the ith value of a when we compute the i-1th values of c for all c.Split up b into a block of size 1, a block of size 1, then a block of size 2, then a block of size 4, then 8, and so on.Now, we get a0, which will allow us to compute c1, which lets us get a1, which allows us to compute c2, and so on. So, now we have the following: b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...We'll describe the processing of a single aiWhen we get ai, we will first convolve it with the first two blocks, and add those to the appropriate entry. Now, suppose ai is multiple of a 2k for some k. Then, we will convolve ai - 2k .. ai - 1 with the block in b with the same size. As an example. b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 \n a0b2This gives us c0, which then allows us to get a1 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1\na_1 a0b2 a1b2This gives us c1, which then allows us to get a2a2 is now a power of 2, so this step will also additionally convolve a0, a1 with b3, b4 b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0 a0b1 a1b1 a2b1\na_1 a0b2 a1b2 a2b2\na_2 a0b3 (a1b3+a0b4) a1b4So, we can see this gives us c2, which then allowus to get a3, and so on and so forth.Thus, this process of breaking into blocks works. As for runtime, we run FFT on a block size of B T/B times, so this term contributes (T/B) * B log B = T log BSo, we sum T log 2 + T log 4 + ... + T log 2\\^(log T) <= T log\\^2 TThus, the overall time per edge is , which gives us a total runtime of .Example code: http://codeforces.com/contest/553/submission/11767579",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18842",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 554 和字母"
          },
          "content_length": 9211
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #309 - Codeforces - Code 1",
          "code": "main(){\n  itoa(2, col, 2);\n  if(strcmp(col, \"10\") == 0) mark ++;\n  else mark --;\n  printf(\"%d\", mark);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 2",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 3",
          "code": "if failed url http://127.0.0.1:8088/profile/tourist\n       and content == \"Grandmaster\"\n       with timeout 10 seconds for 4 times within 5 cycles\n           then restart",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 4",
          "code": "Div1A/Div2C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 5",
          "code": "Out of Range",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 6",
          "code": "ios_base::sync_with_stdio",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 - Codeforces - Code 8",
          "code": "choose(placed_balls, new_balls + placed_balls - 1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18825",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 1",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 2",
          "code": "position:   ... y x n\nnumber  :   ... n y x",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 3",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 4",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 5",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 6",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  \n            a0b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 7",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 8",
          "code": "b_1 | b_2 | b_3 b_4 | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1\na_1         a0b2 a1b2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 9",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 10",
          "code": "b_1 | b_2 | b_3      b_4    | b_5 b_6 b_7 b_8 | ...\na_0   a0b1  a1b1  a2b1\na_1         a0b2  a1b2    a2b2\na_2               a0b3 (a1b3+a0b4)  a1b4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 11",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 12",
          "code": "26 + 25*len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 13",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 14",
          "code": "1 + (len + 1)*25",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 15",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 16",
          "code": "4 5 3 100\n1 2 0\n100000 0 0\n2 3 2\n90000 0 10000\n3 1 0\n100000 0 0\n2 4 0\n0 0 1000000\n3 4 4\n100000 0 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 17",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 18",
          "code": "for(int i=1;i<n;i++){\n        factorial[i]=(i*factorial[i-1])%MOD;\n        invfactorial[i]=expo(factorial[i],MOD-2);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 19",
          "code": "invfactorial[n]=expo(factorial[n],MOD-2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 20",
          "code": "invfactorial[i]=(i + 1) * invfactorial[i + 1] % MOD",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 21",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 22",
          "code": "4\n0101\n1000\n1111\n0101",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 23",
          "code": "b[i]=1 if a[i]<a[i+1] else 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 24",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #309 Editorial - Codeforces - Code 25",
          "code": "a 1 2 4 3 5 7 6\nb   0 0 1 0 0 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18842",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> relationships;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai (%d) and bi (%d) must be different\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(!relationships.count(edge), \"Pair (%d, %d) appears more than once\", u, v);\n        relationships.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> relationships;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai (%d) and bi (%d) must be different\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(!relationships.count(edge), \"Pair (%d, %d) appears more than once\", u, v);\n        relationships.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> relationships;\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readSpace();\n        int ci = inf.readInt(0, 1, \"ci\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai (%d) and bi (%d) must be different\", ai, bi);\n\n        int u = min(ai, bi);\n        int v = max(ai, bi);\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(!relationships.count(edge), \"Pair (%d, %d) appears more than once\", u, v);\n        relationships.insert(edge);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> relationships;\n    vector<tuple<int, int, int>> output_edges;\n    \n    int max_m = n * (n -1) / 2;\n    if (m > max_m) m = max_m;\n    \n    if (type == \"random\") {\n        // Generate m random relationships\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int, int> p = make_pair(a, b);\n            if (relationships.count(p) == 0) {\n                relationships.insert(p);\n                int c = rnd.next(0, 1); // Randomly choose love or hate\n                output_edges.push_back(make_tuple(a, b, c));\n            }\n        }\n    }\n    else if (type == \"conflict\") {\n        // Create a conflict within specified n and m\n        // We can create a conflicting triangle\n        if (n < 3 || m < 3) {\n            fprintf(stderr, \"Too few nodes or edges for conflict\\n\");\n            exit(1);\n        }\n        \n        relationships.insert({1, 2});\n        relationships.insert({2, 3});\n        relationships.insert({1, 3});\n        // Conflicting ci's\n        output_edges.push_back({1,2,1});\n        output_edges.push_back({2,3,1});\n        output_edges.push_back({1,3,0}); // Conflict, forces inconsistency\n        // Now generate the rest of the relationships randomly\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = rnd.next(0,1);\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else if (type == \"complete\") {\n        // All possible pairs\n        m = max_m;\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a+1; b <= n; ++b) {\n                int c = rnd.next(0, 1);\n                output_edges.push_back(make_tuple(a, b, c));\n                relationships.insert({a,b});\n            }\n        }\n    }\n    else if (type == \"empty\") {\n        m = 0; // No known relationships\n        // Do nothing\n    }\n    else if (type == \"bipartite\") {\n        // Generate relationships to form a bipartite graph\n        vector<int> part(n+1);\n        for (int i = 1; i <= n; ++i)\n            part[i] = rnd.next(0,1); // Randomly assign to one of two parts\n\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c;\n            if (part[a] == part[b]) {\n                c = 1; // Love between same part\n            } else {\n                c = 0; // Hate between different parts\n            }\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else if (type == \"nonbipartite\") {\n        // Generate relationships to form non-bipartite graph\n        // We can generate an odd-length cycle\n        if (n < 3 || m < 3) {\n            fprintf(stderr, \"Too few nodes or edges for nonbipartite graph\\n\");\n            exit(1);\n        }\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i+1;\n        shuffle(nodes.begin(), nodes.end());\n\n        int cycle_length = 3; // Create a small odd-length cycle\n        for (int i = 0; i < cycle_length; ++i) {\n            int a = nodes[i];\n            int b = nodes[(i+1)%cycle_length];\n            if (a > b) swap(a, b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = 1; // Love relationship\n            output_edges.push_back({a,b,c});\n        }\n        // Now fill remaining edges\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = rnd.next(0,1); // Random love or hate\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else if (type == \"multiple_components\") {\n        // Generate multiple connected components\n        int k = opt<int>(\"components\", 10); // Default 10 components\n        if (k > n) k = n;\n        vector<int> component_sizes(k, n / k);\n        for (int i = 0; i < n % k; ++i) {\n            component_sizes[i]++;\n        }\n\n        int node_id = 1;\n        for (int i = 0; i < k; ++i) {\n            int comp_size = component_sizes[i];\n            vector<int> nodes_in_comp;\n            for (int j = 0; j < comp_size; ++j) {\n                nodes_in_comp.push_back(node_id++);\n            }\n\n            // Now generate edges within the component\n            // Create a chain to ensure connectedness\n            for (int j = 0; j+1 < nodes_in_comp.size(); ++j) {\n                int a = nodes_in_comp[j];\n                int b = nodes_in_comp[j+1];\n                if (a > b) swap(a,b);\n                relationships.insert({a,b});\n                int c = rnd.next(0,1);\n                output_edges.push_back({a,b,c});\n            }\n        }\n\n        // Now, if m is larger, fill with random relationships\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = rnd.next(0,1);\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else {\n        // Default to random\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int, int> p = make_pair(a, b);\n            if (relationships.count(p) == 0) {\n                relationships.insert(p);\n                int c = rnd.next(0, 1); // Randomly choose love or hate\n                output_edges.push_back(make_tuple(a, b, c));\n            }\n        }\n    }\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the relationships\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        tie(a, b, c) = output_edges[i];\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<int, int>> relationships;\n    vector<tuple<int, int, int>> output_edges;\n    \n    int max_m = n * (n -1) / 2;\n    if (m > max_m) m = max_m;\n    \n    if (type == \"random\") {\n        // Generate m random relationships\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int, int> p = make_pair(a, b);\n            if (relationships.count(p) == 0) {\n                relationships.insert(p);\n                int c = rnd.next(0, 1); // Randomly choose love or hate\n                output_edges.push_back(make_tuple(a, b, c));\n            }\n        }\n    }\n    else if (type == \"conflict\") {\n        // Create a conflict within specified n and m\n        // We can create a conflicting triangle\n        if (n < 3 || m < 3) {\n            fprintf(stderr, \"Too few nodes or edges for conflict\\n\");\n            exit(1);\n        }\n        \n        relationships.insert({1, 2});\n        relationships.insert({2, 3});\n        relationships.insert({1, 3});\n        // Conflicting ci's\n        output_edges.push_back({1,2,1});\n        output_edges.push_back({2,3,1});\n        output_edges.push_back({1,3,0}); // Conflict, forces inconsistency\n        // Now generate the rest of the relationships randomly\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = rnd.next(0,1);\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else if (type == \"complete\") {\n        // All possible pairs\n        m = max_m;\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a+1; b <= n; ++b) {\n                int c = rnd.next(0, 1);\n                output_edges.push_back(make_tuple(a, b, c));\n                relationships.insert({a,b});\n            }\n        }\n    }\n    else if (type == \"empty\") {\n        m = 0; // No known relationships\n        // Do nothing\n    }\n    else if (type == \"bipartite\") {\n        // Generate relationships to form a bipartite graph\n        vector<int> part(n+1);\n        for (int i = 1; i <= n; ++i)\n            part[i] = rnd.next(0,1); // Randomly assign to one of two parts\n\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c;\n            if (part[a] == part[b]) {\n                c = 1; // Love between same part\n            } else {\n                c = 0; // Hate between different parts\n            }\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else if (type == \"nonbipartite\") {\n        // Generate relationships to form non-bipartite graph\n        // We can generate an odd-length cycle\n        if (n < 3 || m < 3) {\n            fprintf(stderr, \"Too few nodes or edges for nonbipartite graph\\n\");\n            exit(1);\n        }\n        vector<int> nodes(n);\n        for (int i = 0; i < n; ++i) nodes[i] = i+1;\n        shuffle(nodes.begin(), nodes.end());\n\n        int cycle_length = 3; // Create a small odd-length cycle\n        for (int i = 0; i < cycle_length; ++i) {\n            int a = nodes[i];\n            int b = nodes[(i+1)%cycle_length];\n            if (a > b) swap(a, b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = 1; // Love relationship\n            output_edges.push_back({a,b,c});\n        }\n        // Now fill remaining edges\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = rnd.next(0,1); // Random love or hate\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else if (type == \"multiple_components\") {\n        // Generate multiple connected components\n        int k = opt<int>(\"components\", 10); // Default 10 components\n        if (k > n) k = n;\n        vector<int> component_sizes(k, n / k);\n        for (int i = 0; i < n % k; ++i) {\n            component_sizes[i]++;\n        }\n\n        int node_id = 1;\n        for (int i = 0; i < k; ++i) {\n            int comp_size = component_sizes[i];\n            vector<int> nodes_in_comp;\n            for (int j = 0; j < comp_size; ++j) {\n                nodes_in_comp.push_back(node_id++);\n            }\n\n            // Now generate edges within the component\n            // Create a chain to ensure connectedness\n            for (int j = 0; j+1 < nodes_in_comp.size(); ++j) {\n                int a = nodes_in_comp[j];\n                int b = nodes_in_comp[j+1];\n                if (a > b) swap(a,b);\n                relationships.insert({a,b});\n                int c = rnd.next(0,1);\n                output_edges.push_back({a,b,c});\n            }\n        }\n\n        // Now, if m is larger, fill with random relationships\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a,b);\n            if (relationships.count({a,b})) continue;\n            relationships.insert({a,b});\n            int c = rnd.next(0,1);\n            output_edges.push_back({a,b,c});\n        }\n    }\n    else {\n        // Default to random\n        while (relationships.size() < m) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            if (a > b) swap(a, b);\n            pair<int, int> p = make_pair(a, b);\n            if (relationships.count(p) == 0) {\n                relationships.insert(p);\n                int c = rnd.next(0, 1); // Randomly choose love or hate\n                output_edges.push_back(make_tuple(a, b, c));\n            }\n        }\n    }\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the relationships\n    for (int i = 0; i < m; ++i) {\n        int a, b, c;\n        tie(a, b, c) = output_edges[i];\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -type conflict\n./gen -n 3 -m 0 -type empty\n./gen -n 3 -m 3 -type complete\n./gen -n 5 -m 10 -type complete\n./gen -n 10 -m 15 -type random\n./gen -n 10 -m 15 -type bipartite\n./gen -n 10 -m 15 -type nonbipartite\n./gen -n 20 -m 30 -type multiple_components -components 5\n\n./gen -n 100 -m 500 -type random\n./gen -n 100 -m 1000 -type bipartite\n./gen -n 100 -m 1000 -type nonbipartite\n./gen -n 100 -m 4950 -type complete\n./gen -n 200 -m 0 -type empty\n\n./gen -n 1000 -m 5000 -type random\n./gen -n 1000 -m 10000 -type bipartite\n./gen -n 1000 -m 10000 -type nonbipartite\n./gen -n 1000 -m 5000 -type multiple_components -components 10\n./gen -n 1000 -m 5000 -type multiple_components -components 100\n./gen -n 1000 -m 5000 -type multiple_components -components 500\n\n./gen -n 10000 -m 0 -type empty\n./gen -n 10000 -m 9990 -type random\n\n./gen -n 50000 -m 50000 -type random\n./gen -n 50000 -m 50000 -type bipartite\n./gen -n 50000 -m 50000 -type nonbipartite\n\n./gen -n 100000 -m 0 -type empty\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type bipartite\n./gen -n 100000 -m 100000 -type multiple_components -components 1000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:23.798759",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "555/A",
      "title": "A. Case of Matryoshkas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n (1 ≤ n ≤ 105) and k (1 ≤ k ≤ 105) — the number of matryoshkas and matryoshka chains in the initial configuration.The next k lines contain the descriptions of the chains: the i-th line first contains number mi (1 ≤ mi ≤ n), and then mi numbers ai1, ai2, ..., aimi — the numbers of matryoshkas in the chain (matryoshka ai1 is nested into matryoshka ai2, that is nested into matryoshka ai3, and so on till the matryoshka aimi that isn't nested into any other matryoshka).It is guaranteed that m1 + m2 + ... + mk = n, the numbers of matryoshkas in all the chains are distinct, in each chain the numbers of matryoshkas follow in the ascending order.",
      "output_spec": "OutputIn the single line print the minimum number of seconds needed to assemble one large chain from the initial configuration.",
      "sample_tests": "ExamplesInputCopy3 22 1 21 3OutputCopy1InputCopy7 33 1 3 72 2 52 4 6OutputCopy10",
      "description": "A. Case of Matryoshkas\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n (1 ≤ n ≤ 105) and k (1 ≤ k ≤ 105) — the number of matryoshkas and matryoshka chains in the initial configuration.The next k lines contain the descriptions of the chains: the i-th line first contains number mi (1 ≤ mi ≤ n), and then mi numbers ai1, ai2, ..., aimi — the numbers of matryoshkas in the chain (matryoshka ai1 is nested into matryoshka ai2, that is nested into matryoshka ai3, and so on till the matryoshka aimi that isn't nested into any other matryoshka).It is guaranteed that m1 + m2 + ... + mk = n, the numbers of matryoshkas in all the chains are distinct, in each chain the numbers of matryoshkas follow in the ascending order.\n\nOutputIn the single line print the minimum number of seconds needed to assemble one large chain from the initial configuration.\n\nInputCopy3 22 1 21 3OutputCopy1InputCopy7 33 1 3 72 2 52 4 6OutputCopy10\n\nInputCopy3 22 1 21 3\n\nOutputCopy1\n\nInputCopy7 33 1 3 72 2 52 4 6\n\nOutputCopy10\n\nNoteIn the first sample test there are two chains: 1 → 2 and 3. In one second you can nest the first chain into the second one and get 1 → 2 → 3.In the second sample test you need to disassemble all the three chains into individual matryoshkas in 2 + 1 + 1 = 4 seconds and then assemble one big chain in 6 seconds.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 555\\s*A"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    int total_m = 0;\n    vector<bool> used(n + 1, false);  // Matryoshka numbers from 1 to n\n\n    for (int chain_idx = 0; chain_idx < k; ++chain_idx) {\n        // Read mi\n        int mi = inf.readInt(1, n, \"mi\");\n        total_m += mi;\n        // After mi, there should be a space\n        inf.readSpace();\n\n        // Read mi integers ai1,..., aimi\n        vector<int> a = inf.readInts(mi, 1, n, \"ai\");\n\n        // Check that ai's are increasing\n        for (int j = 0; j < mi; ++j) {\n            if (j > 0) {\n                ensuref(a[j - 1] < a[j], \"Numbers in chain %d must be increasing, but found %d >= %d\", chain_idx + 1, a[j - 1], a[j]);\n            }\n            int val = a[j];\n            ensuref(!used[val], \"Matryoshka number %d is used more than once\", val);\n            used[val] = true;\n        }\n\n        inf.readEoln();\n    }\n\n    // Check that total_m == n\n    ensuref(total_m == n, \"Total number of matryoshkas %d does not equal n=%d\", total_m, n);\n\n    // Check that all matryoshkas from 1 to n are used\n    for (int i = 1; i <= n; ++i) {\n        ensuref(used[i], \"Matryoshka number %d is missing\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    int total_m = 0;\n    vector<bool> used(n + 1, false);  // Matryoshka numbers from 1 to n\n\n    for (int chain_idx = 0; chain_idx < k; ++chain_idx) {\n        // Read mi\n        int mi = inf.readInt(1, n, \"mi\");\n        total_m += mi;\n        // After mi, there should be a space\n        inf.readSpace();\n\n        // Read mi integers ai1,..., aimi\n        vector<int> a = inf.readInts(mi, 1, n, \"ai\");\n\n        // Check that ai's are increasing\n        for (int j = 0; j < mi; ++j) {\n            if (j > 0) {\n                ensuref(a[j - 1] < a[j], \"Numbers in chain %d must be increasing, but found %d >= %d\", chain_idx + 1, a[j - 1], a[j]);\n            }\n            int val = a[j];\n            ensuref(!used[val], \"Matryoshka number %d is used more than once\", val);\n            used[val] = true;\n        }\n\n        inf.readEoln();\n    }\n\n    // Check that total_m == n\n    ensuref(total_m == n, \"Total number of matryoshkas %d does not equal n=%d\", total_m, n);\n\n    // Check that all matryoshkas from 1 to n are used\n    for (int i = 1; i <= n; ++i) {\n        ensuref(used[i], \"Matryoshka number %d is missing\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and k\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    int total_m = 0;\n    vector<bool> used(n + 1, false);  // Matryoshka numbers from 1 to n\n\n    for (int chain_idx = 0; chain_idx < k; ++chain_idx) {\n        // Read mi\n        int mi = inf.readInt(1, n, \"mi\");\n        total_m += mi;\n        // After mi, there should be a space\n        inf.readSpace();\n\n        // Read mi integers ai1,..., aimi\n        vector<int> a = inf.readInts(mi, 1, n, \"ai\");\n\n        // Check that ai's are increasing\n        for (int j = 0; j < mi; ++j) {\n            if (j > 0) {\n                ensuref(a[j - 1] < a[j], \"Numbers in chain %d must be increasing, but found %d >= %d\", chain_idx + 1, a[j - 1], a[j]);\n            }\n            int val = a[j];\n            ensuref(!used[val], \"Matryoshka number %d is used more than once\", val);\n            used[val] = true;\n        }\n\n        inf.readEoln();\n    }\n\n    // Check that total_m == n\n    ensuref(total_m == n, \"Total number of matryoshkas %d does not equal n=%d\", total_m, n);\n\n    // Check that all matryoshkas from 1 to n are used\n    for (int i = 1; i <= n; ++i) {\n        ensuref(used[i], \"Matryoshka number %d is missing\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to output the chains\nvoid print_chains(vector<vector<int>>& chains) {\n    int n = 0;\n    int k = chains.size();\n\n    for (auto &chain : chains) {\n        n += chain.size();\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (auto &chain : chains) {\n        printf(\"%d\", chain.size());\n        for (auto &mat : chain) {\n            printf(\" %d\", mat);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> mats(n);\n    for (int i = 0; i < n; ++i) {\n        mats[i] = i + 1;\n    }\n\n    vector<vector<int>> chains;\n\n    if (type == \"single_chain\") {\n        // One chain containing all matryoshkas in order\n        vector<int> chain(n);\n        for (int i = 0; i < n; ++i) {\n            chain[i] = i + 1;\n        }\n        chains.push_back(chain);\n        k = 1; // Since there is only one chain\n    }\n    else if (type == \"separate_chains\") {\n        // Each matryoshka is in its own chain\n        k = n;\n        for (int i = 0; i < n; ++i) {\n            chains.push_back(vector<int>(1, i + 1));\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly distribute matryoshkas among k chains\n        if (k > n) k = n; // k cannot be greater than n\n        vector<int> chain_sizes(k, 1);\n        int remaining = n - k;\n        for (int i = 0; i < remaining; ++i) {\n            int index = rnd.next(0, k - 1);\n            chain_sizes[index]++;\n        }\n        // Optional: shuffle chain_sizes\n        shuffle(chain_sizes.begin(), chain_sizes.end());\n        // Shuffle mats\n        shuffle(mats.begin(), mats.end());\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int sz = chain_sizes[i];\n            vector<int> chain(sz);\n            for (int j = 0; j < sz; ++j) {\n                chain[j] = mats[idx++];\n            }\n            sort(chain.begin(), chain.end());\n            chains.push_back(chain);\n        }\n    }\n    else if (type == \"partial_order\") {\n        int p = opt<int>(\"p\", n/2);\n        // Create one chain with matryoshkas from 1 to p\n        vector<int> chain;\n        for (int i = 1; i <= p; ++i) {\n            chain.push_back(i);\n        }\n        chains.push_back(chain);\n        // Now, the rest matryoshkas from p+1 to n\n        vector<int> rest_mats;\n        for (int i = p; i < n; ++i) {\n            rest_mats.push_back(i + 1);\n        }\n        shuffle(rest_mats.begin(), rest_mats.end());\n        int remaining_mats = n - p;\n        int remaining_k = k - 1;\n        if (remaining_k <= 0) {\n            remaining_k = remaining_mats; // Each matryoshka as its own chain\n        }\n        vector<int> chain_sizes(remaining_k, 1);\n        int more = remaining_mats - remaining_k;\n        for (int i = 0; i < more; ++i) {\n            int index = rnd.next(0, remaining_k - 1);\n            chain_sizes[index]++;\n        }\n        int idx = 0;\n        for (int i = 0; i < remaining_k; ++i) {\n            int sz = chain_sizes[i];\n            vector<int> chain(sz);\n            for (int j = 0; j < sz; ++j) {\n                chain[j] = rest_mats[idx++];\n            }\n            sort(chain.begin(), chain.end());\n            chains.push_back(chain);\n        }\n    }\n    else {\n        // Default to random if unknown type\n        // Similar code as for \"random\" type\n        if (k > n) k = n;\n        vector<int> chain_sizes(k, 1);\n        int remaining = n - k;\n        for (int i = 0; i < remaining; ++i) {\n            int index = rnd.next(0, k - 1);\n            chain_sizes[index]++;\n        }\n        shuffle(chain_sizes.begin(), chain_sizes.end());\n        shuffle(mats.begin(), mats.end());\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int sz = chain_sizes[i];\n            vector<int> chain(sz);\n            for (int j = 0; j < sz; ++j) {\n                chain[j] = mats[idx++];\n            }\n            sort(chain.begin(), chain.end());\n            chains.push_back(chain);\n        }\n    }\n\n    print_chains(chains);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to output the chains\nvoid print_chains(vector<vector<int>>& chains) {\n    int n = 0;\n    int k = chains.size();\n\n    for (auto &chain : chains) {\n        n += chain.size();\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (auto &chain : chains) {\n        printf(\"%d\", chain.size());\n        for (auto &mat : chain) {\n            printf(\" %d\", mat);\n        }\n        printf(\"\\n\");\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> mats(n);\n    for (int i = 0; i < n; ++i) {\n        mats[i] = i + 1;\n    }\n\n    vector<vector<int>> chains;\n\n    if (type == \"single_chain\") {\n        // One chain containing all matryoshkas in order\n        vector<int> chain(n);\n        for (int i = 0; i < n; ++i) {\n            chain[i] = i + 1;\n        }\n        chains.push_back(chain);\n        k = 1; // Since there is only one chain\n    }\n    else if (type == \"separate_chains\") {\n        // Each matryoshka is in its own chain\n        k = n;\n        for (int i = 0; i < n; ++i) {\n            chains.push_back(vector<int>(1, i + 1));\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly distribute matryoshkas among k chains\n        if (k > n) k = n; // k cannot be greater than n\n        vector<int> chain_sizes(k, 1);\n        int remaining = n - k;\n        for (int i = 0; i < remaining; ++i) {\n            int index = rnd.next(0, k - 1);\n            chain_sizes[index]++;\n        }\n        // Optional: shuffle chain_sizes\n        shuffle(chain_sizes.begin(), chain_sizes.end());\n        // Shuffle mats\n        shuffle(mats.begin(), mats.end());\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int sz = chain_sizes[i];\n            vector<int> chain(sz);\n            for (int j = 0; j < sz; ++j) {\n                chain[j] = mats[idx++];\n            }\n            sort(chain.begin(), chain.end());\n            chains.push_back(chain);\n        }\n    }\n    else if (type == \"partial_order\") {\n        int p = opt<int>(\"p\", n/2);\n        // Create one chain with matryoshkas from 1 to p\n        vector<int> chain;\n        for (int i = 1; i <= p; ++i) {\n            chain.push_back(i);\n        }\n        chains.push_back(chain);\n        // Now, the rest matryoshkas from p+1 to n\n        vector<int> rest_mats;\n        for (int i = p; i < n; ++i) {\n            rest_mats.push_back(i + 1);\n        }\n        shuffle(rest_mats.begin(), rest_mats.end());\n        int remaining_mats = n - p;\n        int remaining_k = k - 1;\n        if (remaining_k <= 0) {\n            remaining_k = remaining_mats; // Each matryoshka as its own chain\n        }\n        vector<int> chain_sizes(remaining_k, 1);\n        int more = remaining_mats - remaining_k;\n        for (int i = 0; i < more; ++i) {\n            int index = rnd.next(0, remaining_k - 1);\n            chain_sizes[index]++;\n        }\n        int idx = 0;\n        for (int i = 0; i < remaining_k; ++i) {\n            int sz = chain_sizes[i];\n            vector<int> chain(sz);\n            for (int j = 0; j < sz; ++j) {\n                chain[j] = rest_mats[idx++];\n            }\n            sort(chain.begin(), chain.end());\n            chains.push_back(chain);\n        }\n    }\n    else {\n        // Default to random if unknown type\n        // Similar code as for \"random\" type\n        if (k > n) k = n;\n        vector<int> chain_sizes(k, 1);\n        int remaining = n - k;\n        for (int i = 0; i < remaining; ++i) {\n            int index = rnd.next(0, k - 1);\n            chain_sizes[index]++;\n        }\n        shuffle(chain_sizes.begin(), chain_sizes.end());\n        shuffle(mats.begin(), mats.end());\n        int idx = 0;\n        for (int i = 0; i < k; ++i) {\n            int sz = chain_sizes[i];\n            vector<int> chain(sz);\n            for (int j = 0; j < sz; ++j) {\n                chain[j] = mats[idx++];\n            }\n            sort(chain.begin(), chain.end());\n            chains.push_back(chain);\n        }\n    }\n\n    print_chains(chains);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 1 -k 1 -type single_chain\n./gen -n 2 -k 2 -type separate_chains\n./gen -n 5 -k 3 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 1 -type single_chain\n\n# Medium test cases\n./gen -n 100 -k 50 -type random\n./gen -n 1000 -k 100 -type random\n./gen -n 1000 -k 1 -type single_chain\n./gen -n 1000 -k 1000 -type separate_chains\n\n# Large test cases\n./gen -n 100000 -k 100000 -type separate_chains\n./gen -n 100000 -k 1 -type single_chain\n./gen -n 100000 -k 50000 -type random\n\n# Partial order test cases\n./gen -n 10000 -k 100 -type partial_order -p 5000\n./gen -n 100000 -k 1000 -type partial_order -p 50000\n\n# Random test cases with varying k\n./gen -n 100000 -k 2 -type random\n./gen -n 100000 -k 1000 -type random\n./gen -n 100000 -k 10000 -type random\n\n# Edge cases\n./gen -n 1 -k 1 -type separate_chains\n./gen -n 1 -k 1 -type random\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 2 -type random\n\n# Similar numbers of chains and matryoshkas\n./gen -n 99999 -k 99999 -type random\n./gen -n 100000 -k 99999 -type random\n\n# Special test cases\n./gen -n 100000 -k 2 -type partial_order -p 1\n./gen -n 100000 -k 1 -type partial_order -p 50000\n./gen -n 100000 -k 100000 -type partial_order -p 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:25.591132",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "555/B",
      "title": "B. Case of Fugitive",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n (2 ≤ n ≤ 2·105) and m (1 ≤ m ≤ 2·105) — the number of islands and bridges.Next n lines each contain two integers li and ri (1 ≤ li ≤ ri ≤ 1018) — the coordinates of the island endpoints.The last line contains m integer numbers a1, a2, ..., am (1 ≤ ai ≤ 1018) — the lengths of the bridges that Andrewid got.",
      "output_spec": "OutputIf it is impossible to place a bridge between each pair of adjacent islands in the required manner, print on a single line \"No\" (without the quotes), otherwise print in the first line \"Yes\" (without the quotes), and in the second line print n - 1 numbers b1, b2, ..., bn - 1, which mean that between islands i and i + 1 there must be used a bridge number bi. If there are multiple correct answers, print any of them. Note that in this problem it is necessary to print \"Yes\" and \"No\" in correct case.",
      "sample_tests": "ExamplesInputCopy4 41 47 89 1012 144 5 3 8OutputCopyYes2 3 1 InputCopy2 211 1417 182 9OutputCopyNoInputCopy2 11 11000000000000000000 1000000000000000000999999999999999999OutputCopyYes1",
      "description": "B. Case of Fugitive\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n (2 ≤ n ≤ 2·105) and m (1 ≤ m ≤ 2·105) — the number of islands and bridges.Next n lines each contain two integers li and ri (1 ≤ li ≤ ri ≤ 1018) — the coordinates of the island endpoints.The last line contains m integer numbers a1, a2, ..., am (1 ≤ ai ≤ 1018) — the lengths of the bridges that Andrewid got.\n\nOutputIf it is impossible to place a bridge between each pair of adjacent islands in the required manner, print on a single line \"No\" (without the quotes), otherwise print in the first line \"Yes\" (without the quotes), and in the second line print n - 1 numbers b1, b2, ..., bn - 1, which mean that between islands i and i + 1 there must be used a bridge number bi. If there are multiple correct answers, print any of them. Note that in this problem it is necessary to print \"Yes\" and \"No\" in correct case.\n\nInputCopy4 41 47 89 1012 144 5 3 8OutputCopyYes2 3 1 InputCopy2 211 1417 182 9OutputCopyNoInputCopy2 11 11000000000000000000 1000000000000000000999999999999999999OutputCopyYes1\n\nInputCopy4 41 47 89 1012 144 5 3 8\n\nOutputCopyYes2 3 1\n\nInputCopy2 211 1417 182 9\n\nOutputCopyNo\n\nInputCopy2 11 11000000000000000000 1000000000000000000999999999999999999\n\nOutputCopyYes1\n\nNoteIn the first sample test you can, for example, place the second bridge between points 3 and 8, place the third bridge between points 7 and 10 and place the first bridge between points 10 and 14.In the second sample test the first bridge is too short and the second bridge is too long, so the solution doesn't exist.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 555\\s*B"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    long long prev_ri = -1;\n    for (int i = 0; i < n; ++i) {\n        long long li = inf.readLong(1, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000000000000LL, \"ri\");\n        inf.readEoln();\n        if (i > 0) {\n            ensuref(prev_ri < li, \"Islands must be non-overlapping and in order: ri[%d]=%lld >= li[%d]=%lld\", i - 1, prev_ri, i, li);\n        }\n        prev_ri = ri;\n    }\n\n    vector<long long> ai = inf.readLongs(m, 1, 1000000000000000000LL, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    long long prev_ri = -1;\n    for (int i = 0; i < n; ++i) {\n        long long li = inf.readLong(1, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000000000000LL, \"ri\");\n        inf.readEoln();\n        if (i > 0) {\n            ensuref(prev_ri < li, \"Islands must be non-overlapping and in order: ri[%d]=%lld >= li[%d]=%lld\", i - 1, prev_ri, i, li);\n        }\n        prev_ri = ri;\n    }\n\n    vector<long long> ai = inf.readLongs(m, 1, 1000000000000000000LL, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    long long prev_ri = -1;\n    for (int i = 0; i < n; ++i) {\n        long long li = inf.readLong(1, 1000000000000000000LL, \"li\");\n        inf.readSpace();\n        long long ri = inf.readLong(li, 1000000000000000000LL, \"ri\");\n        inf.readEoln();\n        if (i > 0) {\n            ensuref(prev_ri < li, \"Islands must be non-overlapping and in order: ri[%d]=%lld >= li[%d]=%lld\", i - 1, prev_ri, i, li);\n        }\n        prev_ri = ri;\n    }\n\n    vector<long long> ai = inf.readLongs(m, 1, 1000000000000000000LL, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const string NO_TOKEN  = \"No\";\nstatic const string YES_TOKEN = \"Yes\";\n\n// Reads a solution from the given stream.\n//   - If EOF, interpret as \"No\" (return false).\n//   - Otherwise read a token: must be \"No\" or \"Yes\".\n//   - If \"Yes\", read exactly (n - 1) bridge indices in [1..m], checking constraints.\nbool readSolution(\n    InStream &stream,\n    const vector<long long> &bridges, \n    const vector<pair<long long,long long>> &adjRanges, // [minLen, maxLen] for each adjacent island pair\n    int n,\n    int m,\n    bool isOfficial // whether reading from ans (official) or ouf (participant)\n) {\n    if (stream.eof()) {\n        // If stream is empty, interpret as \"No\"\n        return false;\n    }\n\n    // Read token: \"No\" or \"Yes\"\n    string token = stream.readToken();\n    if (token == NO_TOKEN) {\n        return false; // \"No\"\n    }\n    else if (token != YES_TOKEN) {\n        stream.quitf(isOfficial ? _fail : _wa,\n                     \"Expected \\\"%s\\\" or \\\"%s\\\" but got \\\"%s\\\"\",\n                     NO_TOKEN.c_str(), YES_TOKEN.c_str(), token.c_str());\n    }\n\n    // Must read (n-1) indices if \"Yes\"\n    vector<bool> used(m,false);\n    for (int i = 0; i < n - 1; i++) {\n        int idx = stream.readInt(1, m, \"bridge_index\");\n        if (used[idx - 1]) {\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Bridge index %d is used more than once\", idx);\n        }\n        used[idx - 1] = true;\n\n        long long length = bridges[idx - 1];\n        long long minLen = adjRanges[i].first;\n        long long maxLen = adjRanges[i].second;\n        if (length < minLen || length > maxLen) {\n            stream.quitf(isOfficial ? _fail : _wa,\n                         \"Bridge #%d length %lld not in [%lld..%lld] for adjacency %d\",\n                         idx, length, minLen, maxLen, i+1);\n        }\n    }\n\n    // Passed all checks => valid \"Yes\"\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the original problem input from inf\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    vector<long long> L(n), R(n);\n    for (int i = 0; i < n; i++) {\n        L[i] = inf.readLong();\n        R[i] = inf.readLong();\n    }\n\n    vector<long long> bridges(m);\n    for (int i = 0; i < m; i++) {\n        bridges[i] = inf.readLong();\n    }\n\n    // For each adjacent pair (i, i+1), valid bridge length is [L[i+1] - R[i], R[i+1] - L[i]]\n    vector<pair<long long,long long>> adjRanges(n - 1);\n    for (int i = 0; i + 1 < n; i++) {\n        adjRanges[i] = { L[i + 1] - R[i], R[i + 1] - L[i] };\n    }\n\n    // Read the official solution (ans)\n    bool officialYes = readSolution(ans, bridges, adjRanges, n, m, true);\n\n    // Read the participant solution (ouf)\n    bool participantYes = readSolution(ouf, bridges, adjRanges, n, m, false);\n\n    // Compare the verdicts\n    if (!officialYes && !participantYes) {\n        quitf(_ok, \"Both solutions say 'No'.\");\n    }\n    if (officialYes && !participantYes) {\n        quitf(_wa, \"Official solution says 'Yes' but participant says 'No'.\");\n    }\n    if (!officialYes && participantYes) {\n        quitf(_fail, \"Participant found a solution but official says 'No'.\");\n    }\n\n    // Both solutions say \"Yes\"\n    quitf(_ok, \"Both solutions say 'Yes' and participant's bridging is valid.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MAX_COORD = 1000000000000000000LL;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<ll, ll>> islands(n);\n    vector<ll> bridges;\n\n    if (type == \"random\") {\n        // Generate random islands\n        ll l_prev = rnd.next(1LL, MAX_COORD / 2);\n        ll r_prev = rnd.next(l_prev, min(l_prev + 1000000LL, MAX_COORD));\n        islands[0] = make_pair(l_prev, r_prev);\n\n        for (int i = 1; i < n; ++i) {\n            // Ensure l_i > r_{i-1}\n            ll min_li = r_prev + 1LL;\n            ll max_li = min(min_li + 1000000LL, MAX_COORD);\n            ll l_i = rnd.next(min_li, max_li);\n            ll max_ri = min(l_i + 1000000LL, MAX_COORD);\n            ll r_i = rnd.next(l_i, max_ri);\n            islands[i] = make_pair(l_i, r_i);\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        // Compute required bridge lengths for each pair\n        vector<ll> required_lengths(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            ll min_length = islands[i+1].first - islands[i].second;\n            ll max_length = islands[i+1].second - islands[i].first;\n            if (min_length > max_length) {\n                // Impossible case, adjust min_length\n                min_length = max_length;\n            }\n            ll bridge_length = rnd.next(min_length, max_length);\n            required_lengths[i] = bridge_length;\n        }\n\n        // Generate m bridge lengths including required lengths\n        bridges = required_lengths;\n        while ((int)bridges.size() < m) {\n            bridges.push_back(rnd.next(1LL, MAX_COORD));\n        }\n        shuffle(bridges.begin(), bridges.end());\n\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        ll l_prev = 1LL;\n        ll r_prev = 1LL;\n        islands[0] = {l_prev, r_prev};\n\n        for (int i = 1; i < n; ++i) {\n            ll l_i = r_prev + 1LL;\n            ll r_i = l_i + 0;\n            islands[i] = {l_i, r_i};\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        // Bridges that cannot satisfy the requirements\n        bridges.resize(m);\n        for (int i = 0; i < m; ++i) {\n            bridges[i] = MAX_COORD / 2LL + rnd.next(1LL, MAX_COORD / 2);\n        }\n\n    } else if (type == \"max_coordinates\") {\n        // Islands with maximum coordinates\n        ll l_i = MAX_COORD - n * 1000000LL;\n        ll r_i = l_i + rnd.next(0LL, 1000000LL);\n        islands[0] = {l_i, r_i};\n\n        for (int i = 1; i < n; ++i) {\n            l_i = islands[i-1].second + rnd.next(1LL, 10LL);\n            ll max_ri = min(l_i + 1000000LL, MAX_COORD);\n            r_i = rnd.next(l_i, max_ri);\n            islands[i] = {l_i, r_i};\n        }\n\n        // Compute required bridge lengths for each pair\n        vector<ll> required_lengths(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            ll min_length = islands[i+1].first - islands[i].second;\n            ll max_length = islands[i+1].second - islands[i].first;\n            if (min_length > max_length) {\n                min_length = max_length;\n            }\n            ll bridge_length = rnd.next(min_length, max_length);\n            required_lengths[i] = bridge_length;\n        }\n\n        // Generate m bridge lengths including required lengths\n        bridges = required_lengths;\n        while ((int)bridges.size() < m) {\n            bridges.push_back(rnd.next(1LL, MAX_COORD));\n        }\n        shuffle(bridges.begin(), bridges.end());\n\n    } else if (type == \"same_bridge_lengths\") {\n        // All bridges have the same length\n        // Generate islands ensuring that the required bridge lengths are the same\n        ll l_prev = 1LL;\n        ll r_prev = l_prev + rnd.next(0LL, 1000000LL);\n        islands[0] = {l_prev, r_prev};\n\n        ll bridge_length = rnd.next(1LL, MAX_COORD / n);\n\n        for (int i = 1; i < n; ++i) {\n            ll l_i = r_prev + bridge_length;\n            ll r_i = l_i + rnd.next(0LL, 1000000LL);\n            islands[i] = {l_i, r_i};\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        bridges.resize(m, bridge_length);\n        shuffle(bridges.begin(), bridges.end());\n\n    } else {\n        // Default is random\n        // (Same as the \"random\" case)\n        ll l_prev = rnd.next(1LL, MAX_COORD / 2);\n        ll r_prev = rnd.next(l_prev, min(l_prev + 1000000LL, MAX_COORD));\n        islands[0] = make_pair(l_prev, r_prev);\n\n        for (int i = 1; i < n; ++i) {\n            ll min_li = r_prev + 1LL;\n            ll max_li = min(min_li + 1000000LL, MAX_COORD);\n            ll l_i = rnd.next(min_li, max_li);\n            ll max_ri = min(l_i + 1000000LL, MAX_COORD);\n            ll r_i = rnd.next(l_i, max_ri);\n            islands[i] = make_pair(l_i, r_i);\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        // Compute required bridge lengths for each pair\n        vector<ll> required_lengths(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            ll min_length = islands[i+1].first - islands[i].second;\n            ll max_length = islands[i+1].second - islands[i].first;\n            if (min_length > max_length) {\n                min_length = max_length;\n            }\n            ll bridge_length = rnd.next(min_length, max_length);\n            required_lengths[i] = bridge_length;\n        }\n\n        bridges = required_lengths;\n        while ((int)bridges.size() < m) {\n            bridges.push_back(rnd.next(1LL, MAX_COORD));\n        }\n        shuffle(bridges.begin(), bridges.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output islands\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", islands[i].first, islands[i].second);\n    }\n\n    // Output bridges\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld%c\", bridges[i], \" \\n\"[i == m - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MAX_COORD = 1000000000000000000LL;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<pair<ll, ll>> islands(n);\n    vector<ll> bridges;\n\n    if (type == \"random\") {\n        // Generate random islands\n        ll l_prev = rnd.next(1LL, MAX_COORD / 2);\n        ll r_prev = rnd.next(l_prev, min(l_prev + 1000000LL, MAX_COORD));\n        islands[0] = make_pair(l_prev, r_prev);\n\n        for (int i = 1; i < n; ++i) {\n            // Ensure l_i > r_{i-1}\n            ll min_li = r_prev + 1LL;\n            ll max_li = min(min_li + 1000000LL, MAX_COORD);\n            ll l_i = rnd.next(min_li, max_li);\n            ll max_ri = min(l_i + 1000000LL, MAX_COORD);\n            ll r_i = rnd.next(l_i, max_ri);\n            islands[i] = make_pair(l_i, r_i);\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        // Compute required bridge lengths for each pair\n        vector<ll> required_lengths(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            ll min_length = islands[i+1].first - islands[i].second;\n            ll max_length = islands[i+1].second - islands[i].first;\n            if (min_length > max_length) {\n                // Impossible case, adjust min_length\n                min_length = max_length;\n            }\n            ll bridge_length = rnd.next(min_length, max_length);\n            required_lengths[i] = bridge_length;\n        }\n\n        // Generate m bridge lengths including required lengths\n        bridges = required_lengths;\n        while ((int)bridges.size() < m) {\n            bridges.push_back(rnd.next(1LL, MAX_COORD));\n        }\n        shuffle(bridges.begin(), bridges.end());\n\n    } else if (type == \"impossible\") {\n        // Generate impossible test case\n        ll l_prev = 1LL;\n        ll r_prev = 1LL;\n        islands[0] = {l_prev, r_prev};\n\n        for (int i = 1; i < n; ++i) {\n            ll l_i = r_prev + 1LL;\n            ll r_i = l_i + 0;\n            islands[i] = {l_i, r_i};\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        // Bridges that cannot satisfy the requirements\n        bridges.resize(m);\n        for (int i = 0; i < m; ++i) {\n            bridges[i] = MAX_COORD / 2LL + rnd.next(1LL, MAX_COORD / 2);\n        }\n\n    } else if (type == \"max_coordinates\") {\n        // Islands with maximum coordinates\n        ll l_i = MAX_COORD - n * 1000000LL;\n        ll r_i = l_i + rnd.next(0LL, 1000000LL);\n        islands[0] = {l_i, r_i};\n\n        for (int i = 1; i < n; ++i) {\n            l_i = islands[i-1].second + rnd.next(1LL, 10LL);\n            ll max_ri = min(l_i + 1000000LL, MAX_COORD);\n            r_i = rnd.next(l_i, max_ri);\n            islands[i] = {l_i, r_i};\n        }\n\n        // Compute required bridge lengths for each pair\n        vector<ll> required_lengths(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            ll min_length = islands[i+1].first - islands[i].second;\n            ll max_length = islands[i+1].second - islands[i].first;\n            if (min_length > max_length) {\n                min_length = max_length;\n            }\n            ll bridge_length = rnd.next(min_length, max_length);\n            required_lengths[i] = bridge_length;\n        }\n\n        // Generate m bridge lengths including required lengths\n        bridges = required_lengths;\n        while ((int)bridges.size() < m) {\n            bridges.push_back(rnd.next(1LL, MAX_COORD));\n        }\n        shuffle(bridges.begin(), bridges.end());\n\n    } else if (type == \"same_bridge_lengths\") {\n        // All bridges have the same length\n        // Generate islands ensuring that the required bridge lengths are the same\n        ll l_prev = 1LL;\n        ll r_prev = l_prev + rnd.next(0LL, 1000000LL);\n        islands[0] = {l_prev, r_prev};\n\n        ll bridge_length = rnd.next(1LL, MAX_COORD / n);\n\n        for (int i = 1; i < n; ++i) {\n            ll l_i = r_prev + bridge_length;\n            ll r_i = l_i + rnd.next(0LL, 1000000LL);\n            islands[i] = {l_i, r_i};\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        bridges.resize(m, bridge_length);\n        shuffle(bridges.begin(), bridges.end());\n\n    } else {\n        // Default is random\n        // (Same as the \"random\" case)\n        ll l_prev = rnd.next(1LL, MAX_COORD / 2);\n        ll r_prev = rnd.next(l_prev, min(l_prev + 1000000LL, MAX_COORD));\n        islands[0] = make_pair(l_prev, r_prev);\n\n        for (int i = 1; i < n; ++i) {\n            ll min_li = r_prev + 1LL;\n            ll max_li = min(min_li + 1000000LL, MAX_COORD);\n            ll l_i = rnd.next(min_li, max_li);\n            ll max_ri = min(l_i + 1000000LL, MAX_COORD);\n            ll r_i = rnd.next(l_i, max_ri);\n            islands[i] = make_pair(l_i, r_i);\n            l_prev = l_i;\n            r_prev = r_i;\n        }\n\n        // Compute required bridge lengths for each pair\n        vector<ll> required_lengths(n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            ll min_length = islands[i+1].first - islands[i].second;\n            ll max_length = islands[i+1].second - islands[i].first;\n            if (min_length > max_length) {\n                min_length = max_length;\n            }\n            ll bridge_length = rnd.next(min_length, max_length);\n            required_lengths[i] = bridge_length;\n        }\n\n        bridges = required_lengths;\n        while ((int)bridges.size() < m) {\n            bridges.push_back(rnd.next(1LL, MAX_COORD));\n        }\n        shuffle(bridges.begin(), bridges.end());\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output islands\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", islands[i].first, islands[i].second);\n    }\n\n    // Output bridges\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld%c\", bridges[i], \" \\n\"[i == m - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input size, random case\n./gen -n 2 -m 1 -type random\n\n# Small input size, random case\n./gen -n 10 -m 5 -type random\n\n# Medium input size, random case\n./gen -n 1000 -m 1000 -type random\n\n# Large input size, random case\n./gen -n 200000 -m 200000 -type random\n\n# Maximal coordinates\n./gen -n 200000 -m 200000 -type max_coordinates\n\n# All bridges have the same length\n./gen -n 1000 -m 500 -type same_bridge_lengths\n./gen -n 200000 -m 150000 -type same_bridge_lengths\n\n# Impossible case\n./gen -n 2 -m 1 -type impossible\n./gen -n 10 -m 5 -type impossible\n./gen -n 1000 -m 1000 -type impossible\n./gen -n 200000 -m 200000 -type impossible\n\n# Maximal input size with random data\n./gen -n 200000 -m 200000 -type random\n\n# Minimal possible bridge lengths\n./gen -n 200000 -m 200000 -type minimal_lengths\n\n# Maximal possible bridge lengths\n./gen -n 200000 -m 200000 -type maximal_lengths\n\n# Islands with same coordinates (edge cases)\n./gen -n 10 -m 10 -type same_islands\n./gen -n 1000 -m 500 -type same_islands\n\n# Islands far apart (large bridge lengths)\n./gen -n 1000 -m 1000 -type islands_far_apart\n./gen -n 200000 -m 200000 -type islands_far_apart\n\n# Edge case with minimal bridge lengths and extra bridges\n./gen -n 200000 -m 199999 -type minimal_lengths\n./gen -n 200000 -m 200001 -type minimal_lengths\n\n# Test cases with bridges length zero (if allowed)\n# Note: If zero-length bridges are not allowed, skip these\n./gen -n 10 -m 5 -type zero_bridge_lengths\n./gen -n 1000 -m 1000 -type zero_bridge_lengths\n\n# Random cases with small bridge lengths\n./gen -n 200000 -m 200000 -type small_bridge_lengths\n\n# Random cases with large bridge lengths\n./gen -n 200000 -m 200000 -type large_bridge_lengths\n\n# Random cases with varying bridge lengths\n./gen -n 100000 -m 150000 -type random\n\n# Random cases with minimum number of bridges\n./gen -n 200000 -m 199999 -type random\n\n# Random cases with maximum number of bridges\n./gen -n 200000 -m 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:27.327291",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "555/C",
      "title": "C. Дело о шоколаде",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы целые числа n (1 ≤ n ≤ 109) и q (1 ≤ q ≤ 2·105) — размер таблицы и количество действий.В следующих q строках даны описания действий: в i-й из них идут числа xi и yi (1 ≤ xi, yi ≤ n, xi + yi = n + 1) — номера столбца и строки выбранной клетки, а также символ, означающий направление (L — влево, U — вверх).",
      "output_spec": "Выходные данныеВыведите q строк, на i-й из них должно быть количество съеденных долек в результате i-го действия.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 53 4 U6 1 L2 5 L1 6 U4 3 UВыходные данныеСкопировать43212Входные данныеСкопировать10 62 9 U10 1 U1 10 U8 3 L10 1 L6 5 UВыходные данныеСкопировать9110602",
      "description": "C. Дело о шоколаде\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке заданы целые числа n (1 ≤ n ≤ 109) и q (1 ≤ q ≤ 2·105) — размер таблицы и количество действий.В следующих q строках даны описания действий: в i-й из них идут числа xi и yi (1 ≤ xi, yi ≤ n, xi + yi = n + 1) — номера столбца и строки выбранной клетки, а также символ, означающий направление (L — влево, U — вверх).\n\nВходные данные\n\nВыходные данныеВыведите q строк, на i-й из них должно быть количество съеденных долек в результате i-го действия.\n\nВыходные данные\n\nВходные данныеСкопировать6 53 4 U6 1 L2 5 L1 6 U4 3 UВыходные данныеСкопировать43212Входные данныеСкопировать10 62 9 U10 1 U1 10 U8 3 L10 1 L6 5 UВыходные данныеСкопировать9110602\n\nВходные данныеСкопировать6 53 4 U6 1 L2 5 L1 6 U4 3 U\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать43212\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 62 9 U10 1 U1 10 U8 3 L10 1 L6 5 U\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9110602\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеИллюстрации к тестам из условия:Дольки, съеденные в одном и том же действии закрашены одинаковым цветом. На дольках, лежащих на побочной диагонали, написаны номера действий, в результате которых эти дольки были съедены.Во втором тесте из условия пятым действием Андреид пытается во второй раз начать есть шоколад, начиная с клетки на пересечении 10-го столбца и 1-й строки, но эта клетка уже пуста, поэтому он не съедает ничего.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Привет, Codeforces.Скоро, 27 июня в 17:00 MSK состоится очередной, 310-й раунд Codeforces, задачи для которого готовили я, Андрей Сергунин, и Егор Щербин (Lord_F).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено пять задач и два часа на их решение. Разбаловка будет объявлена позже.Желаем всем удачи!В раунде будет использована динамическая разбалловка.UPD: По техническим причинам раунд перенесён на 10 минут.UPD: Добавлена предварительная версия разбора.UPD: Поздравляем победителей:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 754
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Привет всем!556A - Дело о нулях и единицахЕсли в последовательности остались хотя бы одни единица и ноль, тогда существует подстрока 01 или 10, которую можно удалить. При этом порядок удаления не важен: в любом случае мы сделаем min(#единиц, #нулей) операций, так как за раз удаляется один ноль и одна единица. Поэтому ответ: #единиц + #нулей - 2min(#единиц, #нулей) = |#единиц - #нулей|.Время: O(n).556B - Дело о поддельных шестеренкахЗаметим, что через n нажатий кнопки система приходит в исходное положение. Поэтому самое простое решение — это промоделировать процесс из n шагов и, если на одном из них встретится последовательность 0, 1, ... , n - 1, выдать \"Yes\", иначе \"No\". Но можно это решение ускорить. Например, сразу по значению первого элемента определить нужное количество нажатий, перейти в это положение и один раз проверить.Время: O(n) или O(n2); решения: O(n) и O(n^2)555A - Дело о матрешкахПредположим нам не нужно разбирать некоторую последовательность. Тогда ни в одну из матрешек этой последовательности не нужно вставить другую. Поэтому нам не нужно разбирать последовательность матрешек лишь в случае, если они идут подряд, начиная с 1. Пусть длина этой последовательности равна l. Тогда вытащить одну из другой нам нужно будет n - k - l + 1 раз, при этом останется одна цепочка из l матрешек 1 → 2 → ... → l и остальные цепочки по одной матрешке. Всего n - k + 1 цепочка, поэтому вложить одну в другую нужно n - k раз. Всего будет сделано 2n - l - 2k + 1 операций.Время: O(n); решение.555B - Дело о беглецеМежду островами i и i + 1 мы можем положить мост, длина которого попадает в отрезок [li + 1 - ri;ri + 1 - li]. Получаем задачу: есть n - 1 отрезков и m точек на прямой, необходимо каждому отрезку сопоставить какую-то точку, лежащую в нем, причем каждую точку можно сопоставить только одному отрезку. Будем идти по точкам слева направо, и хранить в сете отрезки, которые еще ничему не сопоставлены и которые содержат рассматриваемую точку. Пусть мы обрабатываем очередную точку. Сначала добавим в сет все отрезки, которые начинаются в этой точке. Далее выберем из них тот, чей правый конец имеет наименьшую координату. Утверждается, что этот алгоритм находит ответ, если он есть. Предположим это не так. Пусть мы на каком-то шаге выбрали для точки A другой отрезок (пропускать точку не имеет смысла). Тогда посмотрим, какая точка B сопоставлена отрезку, который был бы выбран нашим решением. Точка B лежит заведомо правее A. Поэтому мы можем поменять точки для этих отрезков и снова получить ответ.Время: O((n + m)log(n + m)); решение.555C - Дело о шоколадеРешим задачу с помощью двух деревьев отрезков: для столбцов и для строк. Будем хранить для каждого столбца самую нижнюю съеденную дольку, а для каждой строки — самую левую. Пусть приходит запрос x y L. Находим значение в дереве отрезков для строк на месте y. Пусть это значение равно ans. Теперь нужно вывести x - ans и в дереве для столбцов обновить значения на отрезке [ans + 1, x] до y, а в горизонтальном обновить значение в элементе y дo x. Аналогично с запросами типа U. Чтобы разобраться с большими ограничениями на n нужно писать либо неявное дерево отрезков, либо сжатие координат.Время: O(qlogq) или O(qlogn); решения: 1 and 2.555D - Дело повышенной секретностиНазовем активной длиной La длину части веревки от груза до последнего встреченного колышка. После каждого встреченного колышка активная длина уменьшается. Будем моделировать процесс для каждой длины веревки независимо. На каждом шаге будем бинарным поиском находить, за какой колышек зацепится груз сейчас. При этом если активная длина при этом уменьшается хотя бы вдвое или мы делаем первый шаг, то просто переходим к следующему шагу. А иначе пусть текущий колышек имеет номер i, следующий — j (без ограничения общности i < j). Тогда заметим, что после колышка j мы снова зацепимся именно за колышек i. Действительно, 2(xj - xi) ≤ La, поэтому веревка зацепится не правее чем за i-й колышек. И либо i = 1, либо La ≤ xi - xi - 1, поэтому левее, чем за i-й колышек она тоже зацепиться не может. И вообще, пока активная длина будет не меньше, чем xj - xi, груз будет наматываться на эту пару колышков, следовательно, можно сделать сразу несколько ходов. При этом после этих ходов длина веревки уменьшится хотя бы вдвое. Поэтому всего таких будет сделано не больше log(L), где L — изначальная длина веревки.Решение: O(mlogLlogn); решение.555E - Дело о компьютерной сетиДля начала, сведем задачу к задаче на дереве. В каждой компоненте двусвязности ориентируем ребра в порядке обхода DFS. Утверждается, что мы получим компоненту сильной связности. Пусть это не так. Тогда граф можно разбить на два подграфа A и B так, что не существует ребер, идущих из B в A. Причем изначально ребер между A и B хотя бы два. Но это невозможно, так как, зайдя в эту компоненту B, мы должны будем выйти по одному из ребер между A и B, а это невозможно. Противоречие. Поэтому мы можем сжать все компоненты двусвязности.Теперь надо обработать несколько запросов вида “ориентировать ребра на пути” и проследить за отсутствием конфликтов. Подвесим дерево за некоторую вершину и предподсчитаем LCA для исходных пар вершин. Запустим dfs из корня и для каждого поддерева посчитаем количество вершин, являющихся началами исходных путей (переменная а), вершин, являющихся концами исходных путей (переменная b), и предпосчитанных LCA (переменная c). По этой информации можно ориентировать ребро из корня поддерева в предка: если a - c положительно, тогда вверх, если b - c положительно, тогда вниз, если оба положительны, тогда решения нет, если оба нули, то как угодно.Время: O(n + qlq) где lq это время подсчета LCA на запрос; решение, использующее немного другой метод для последней части.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 555\\s*C"
          },
          "content_length": 5716
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000000); // Read n (1 ≤ n ≤ 1e9)\n    inf.readSpace();\n    int q = inf.readInt(1, 200000); // Read q (1 ≤ q ≤ 2e5)\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, n); // Read xi (1 ≤ xi ≤ n)\n        inf.readSpace();\n        int yi = inf.readInt(1, n); // Read yi (1 ≤ yi ≤ n)\n        inf.readSpace();\n        char dir = inf.readChar(); // Read direction character\n        ensuref(dir == 'L' || dir == 'U', \"Direction must be 'L' or 'U'\"); // Check direction\n        inf.readEoln();\n        \n        ensuref(xi + yi == n + 1, \"xi + yi must equal n + 1\"); // Check that xi + yi = n + 1\n    }\n    \n    inf.readEof(); // Ensure EOF\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000000); // Read n (1 ≤ n ≤ 1e9)\n    inf.readSpace();\n    int q = inf.readInt(1, 200000); // Read q (1 ≤ q ≤ 2e5)\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, n); // Read xi (1 ≤ xi ≤ n)\n        inf.readSpace();\n        int yi = inf.readInt(1, n); // Read yi (1 ≤ yi ≤ n)\n        inf.readSpace();\n        char dir = inf.readChar(); // Read direction character\n        ensuref(dir == 'L' || dir == 'U', \"Direction must be 'L' or 'U'\"); // Check direction\n        inf.readEoln();\n        \n        ensuref(xi + yi == n + 1, \"xi + yi must equal n + 1\"); // Check that xi + yi = n + 1\n    }\n    \n    inf.readEof(); // Ensure EOF\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 1000000000); // Read n (1 ≤ n ≤ 1e9)\n    inf.readSpace();\n    int q = inf.readInt(1, 200000); // Read q (1 ≤ q ≤ 2e5)\n    inf.readEoln();\n    \n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, n); // Read xi (1 ≤ xi ≤ n)\n        inf.readSpace();\n        int yi = inf.readInt(1, n); // Read yi (1 ≤ yi ≤ n)\n        inf.readSpace();\n        char dir = inf.readChar(); // Read direction character\n        ensuref(dir == 'L' || dir == 'U', \"Direction must be 'L' or 'U'\"); // Check direction\n        inf.readEoln();\n        \n        ensuref(xi + yi == n + 1, \"xi + yi must equal n + 1\"); // Check that xi + yi = n + 1\n    }\n    \n    inf.readEof(); // Ensure EOF\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse input parameters\n    long long n = opt<long long>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<long long, long long, char>> actions;\n\n    if (type == \"random\") {\n        // Generate random starting positions and directions\n        for (int i = 0; i < q; i++) {\n            long long x = rnd.next(1LL, n);\n            long long y = n + 1 - x;\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    } else if (type == \"maxEat\") {\n        // Actions that potentially eat the maximum number of pieces\n        for (int i = 0; i < q; i++) {\n            long long x = rnd.next(1LL, n);\n            long long y = n + 1 - x;\n            char dir = (x >= y) ? 'L' : 'U';\n            actions.emplace_back(x, y, dir);\n        }\n    } else if (type == \"repeatedStarts\") {\n        // Repeatedly use the same starting point\n        long long x = rnd.next(1LL, n);\n        long long y = n + 1 - x;\n        for (int i = 0; i < q; i++) {\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    } else if (type == \"noEat\") {\n        // Start from an already eaten piece after the first action\n        long long x = rnd.next(1LL, n);\n        long long y = n + 1 - x;\n        char initialDir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n        actions.emplace_back(x, y, initialDir); // First action\n        for (int i = 1; i < q; i++) {\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir); // Subsequent actions from the same spot\n        }\n    } else if (type == \"edgeCases\") {\n        // Start from edge positions on the anti-diagonal\n        vector<long long> xOptions = {1, n / 2, n};\n        for (int i = 0; i < q; i++) {\n            long long x = xOptions[i % xOptions.size()];\n            long long y = n + 1 - x;\n            char dir = (i % 2 == 0) ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    } else {\n        // Default to random actions if type is unrecognized\n        for (int i = 0; i < q; i++) {\n            long long x = rnd.next(1LL, n);\n            long long y = n + 1 - x;\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    }\n\n    // Output the test case\n    printf(\"%lld %d\\n\", n, q);\n    for (const auto& action : actions) {\n        long long x, y;\n        char dir;\n        tie(x, y, dir) = action;\n        printf(\"%lld %lld %c\\n\", x, y, dir);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse input parameters\n    long long n = opt<long long>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<tuple<long long, long long, char>> actions;\n\n    if (type == \"random\") {\n        // Generate random starting positions and directions\n        for (int i = 0; i < q; i++) {\n            long long x = rnd.next(1LL, n);\n            long long y = n + 1 - x;\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    } else if (type == \"maxEat\") {\n        // Actions that potentially eat the maximum number of pieces\n        for (int i = 0; i < q; i++) {\n            long long x = rnd.next(1LL, n);\n            long long y = n + 1 - x;\n            char dir = (x >= y) ? 'L' : 'U';\n            actions.emplace_back(x, y, dir);\n        }\n    } else if (type == \"repeatedStarts\") {\n        // Repeatedly use the same starting point\n        long long x = rnd.next(1LL, n);\n        long long y = n + 1 - x;\n        for (int i = 0; i < q; i++) {\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    } else if (type == \"noEat\") {\n        // Start from an already eaten piece after the first action\n        long long x = rnd.next(1LL, n);\n        long long y = n + 1 - x;\n        char initialDir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n        actions.emplace_back(x, y, initialDir); // First action\n        for (int i = 1; i < q; i++) {\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir); // Subsequent actions from the same spot\n        }\n    } else if (type == \"edgeCases\") {\n        // Start from edge positions on the anti-diagonal\n        vector<long long> xOptions = {1, n / 2, n};\n        for (int i = 0; i < q; i++) {\n            long long x = xOptions[i % xOptions.size()];\n            long long y = n + 1 - x;\n            char dir = (i % 2 == 0) ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    } else {\n        // Default to random actions if type is unrecognized\n        for (int i = 0; i < q; i++) {\n            long long x = rnd.next(1LL, n);\n            long long y = n + 1 - x;\n            char dir = rnd.next(0, 1) == 0 ? 'U' : 'L';\n            actions.emplace_back(x, y, dir);\n        }\n    }\n\n    // Output the test case\n    printf(\"%lld %d\\n\", n, q);\n    for (const auto& action : actions) {\n        long long x, y;\n        char dir;\n        tie(x, y, dir) = action;\n        printf(\"%lld %lld %c\\n\", x, y, dir);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -q 5 -type random\n./gen -n 100 -q 10 -type random\n./gen -n 1000 -q 100 -type random\n./gen -n 1000000 -q 100000 -type random\n./gen -n 1000000000 -q 200000 -type random\n\n./gen -n 1 -q 1 -type random\n./gen -n 1 -q 200000 -type random\n\n./gen -n 10 -q 5 -type maxEat\n./gen -n 100 -q 10 -type maxEat\n./gen -n 1000 -q 100 -type maxEat\n./gen -n 1000000 -q 100000 -type maxEat\n./gen -n 1000000000 -q 200000 -type maxEat\n\n./gen -n 10 -q 5 -type repeatedStarts\n./gen -n 100 -q 10 -type repeatedStarts\n./gen -n 1000 -q 100 -type repeatedStarts\n./gen -n 1000000 -q 100000 -type repeatedStarts\n\n./gen -n 10 -q 5 -type noEat\n./gen -n 100 -q 10 -type noEat\n./gen -n 1000 -q 100 -type noEat\n./gen -n 1000000 -q 100000 -type noEat\n\n./gen -n 10 -q 5 -type edgeCases\n./gen -n 100 -q 10 -type edgeCases\n./gen -n 1000 -q 100 -type edgeCases\n./gen -n 1000000000 -q 200000 -type edgeCases\n\n./gen -n 10 -q 200000 -type random\n./gen -n 1000 -q 200000 -type random\n./gen -n 1000000000 -q 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:29.435763",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "555/D",
      "title": "D. Дело повышенной секретности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны целые числа n и m (1 ≤ n, m ≤ 2·105) — количество колышков и вариантов запуска.В следующей строке даны n целых чисел x1, x2, ..., xn ( - 109 ≤ xi ≤ 109) — координаты колышков. Гарантируется, что координаты всех колышков — различные целые числа.В следующих m строках даны описания вариантов запусков груза, каждое состоит из двух целых чисел ai (1 ≤ ai ≤ n) и li (1 ≤ li ≤ 109) — номера стартового колышка и длины веревки.",
      "output_spec": "Выходные данныеВыведите m строк, в i-й из них должен быть номер колышка, вокруг которого в конце концов будет вращаться груз после i-го запуска.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 20 3 52 31 8Выходные данныеСкопировать32Входные данныеСкопировать4 41 5 7 151 42 153 161 28Выходные данныеСкопировать2431",
      "description": "D. Дело повышенной секретности\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке даны целые числа n и m (1 ≤ n, m ≤ 2·105) — количество колышков и вариантов запуска.В следующей строке даны n целых чисел x1, x2, ..., xn ( - 109 ≤ xi ≤ 109) — координаты колышков. Гарантируется, что координаты всех колышков — различные целые числа.В следующих m строках даны описания вариантов запусков груза, каждое состоит из двух целых чисел ai (1 ≤ ai ≤ n) и li (1 ≤ li ≤ 109) — номера стартового колышка и длины веревки.\n\nВходные данные\n\nВыходные данныеВыведите m строк, в i-й из них должен быть номер колышка, вокруг которого в конце концов будет вращаться груз после i-го запуска.\n\nВыходные данные\n\nВходные данныеСкопировать3 20 3 52 31 8Выходные данныеСкопировать32Входные данныеСкопировать4 41 5 7 151 42 153 161 28Выходные данныеСкопировать2431\n\nВходные данныеСкопировать3 20 3 52 31 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 41 5 7 151 42 153 161 28\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2431\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеИллюстрация к первому тесту из условия: Иллюстрация ко второму тесту из условия:Обратите внимание, что в последнем запуске груз в итоге начинает вращаться вокруг первого колышка на отрезке верёвки длины 0.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Привет, Codeforces.Скоро, 27 июня в 17:00 MSK состоится очередной, 310-й раунд Codeforces, задачи для которого готовили я, Андрей Сергунин, и Егор Щербин (Lord_F).Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за переводы на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon.Участникам будет предложено пять задач и два часа на их решение. Разбаловка будет объявлена позже.Желаем всем удачи!В раунде будет использована динамическая разбалловка.UPD: По техническим причинам раунд перенесён на 10 минут.UPD: Добавлена предварительная версия разбора.UPD: Поздравляем победителей:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 754
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Привет всем!556A - Дело о нулях и единицахЕсли в последовательности остались хотя бы одни единица и ноль, тогда существует подстрока 01 или 10, которую можно удалить. При этом порядок удаления не важен: в любом случае мы сделаем min(#единиц, #нулей) операций, так как за раз удаляется один ноль и одна единица. Поэтому ответ: #единиц + #нулей - 2min(#единиц, #нулей) = |#единиц - #нулей|.Время: O(n).556B - Дело о поддельных шестеренкахЗаметим, что через n нажатий кнопки система приходит в исходное положение. Поэтому самое простое решение — это промоделировать процесс из n шагов и, если на одном из них встретится последовательность 0, 1, ... , n - 1, выдать \"Yes\", иначе \"No\". Но можно это решение ускорить. Например, сразу по значению первого элемента определить нужное количество нажатий, перейти в это положение и один раз проверить.Время: O(n) или O(n2); решения: O(n) и O(n^2)555A - Дело о матрешкахПредположим нам не нужно разбирать некоторую последовательность. Тогда ни в одну из матрешек этой последовательности не нужно вставить другую. Поэтому нам не нужно разбирать последовательность матрешек лишь в случае, если они идут подряд, начиная с 1. Пусть длина этой последовательности равна l. Тогда вытащить одну из другой нам нужно будет n - k - l + 1 раз, при этом останется одна цепочка из l матрешек 1 → 2 → ... → l и остальные цепочки по одной матрешке. Всего n - k + 1 цепочка, поэтому вложить одну в другую нужно n - k раз. Всего будет сделано 2n - l - 2k + 1 операций.Время: O(n); решение.555B - Дело о беглецеМежду островами i и i + 1 мы можем положить мост, длина которого попадает в отрезок [li + 1 - ri;ri + 1 - li]. Получаем задачу: есть n - 1 отрезков и m точек на прямой, необходимо каждому отрезку сопоставить какую-то точку, лежащую в нем, причем каждую точку можно сопоставить только одному отрезку. Будем идти по точкам слева направо, и хранить в сете отрезки, которые еще ничему не сопоставлены и которые содержат рассматриваемую точку. Пусть мы обрабатываем очередную точку. Сначала добавим в сет все отрезки, которые начинаются в этой точке. Далее выберем из них тот, чей правый конец имеет наименьшую координату. Утверждается, что этот алгоритм находит ответ, если он есть. Предположим это не так. Пусть мы на каком-то шаге выбрали для точки A другой отрезок (пропускать точку не имеет смысла). Тогда посмотрим, какая точка B сопоставлена отрезку, который был бы выбран нашим решением. Точка B лежит заведомо правее A. Поэтому мы можем поменять точки для этих отрезков и снова получить ответ.Время: O((n + m)log(n + m)); решение.555C - Дело о шоколадеРешим задачу с помощью двух деревьев отрезков: для столбцов и для строк. Будем хранить для каждого столбца самую нижнюю съеденную дольку, а для каждой строки — самую левую. Пусть приходит запрос x y L. Находим значение в дереве отрезков для строк на месте y. Пусть это значение равно ans. Теперь нужно вывести x - ans и в дереве для столбцов обновить значения на отрезке [ans + 1, x] до y, а в горизонтальном обновить значение в элементе y дo x. Аналогично с запросами типа U. Чтобы разобраться с большими ограничениями на n нужно писать либо неявное дерево отрезков, либо сжатие координат.Время: O(qlogq) или O(qlogn); решения: 1 and 2.555D - Дело повышенной секретностиНазовем активной длиной La длину части веревки от груза до последнего встреченного колышка. После каждого встреченного колышка активная длина уменьшается. Будем моделировать процесс для каждой длины веревки независимо. На каждом шаге будем бинарным поиском находить, за какой колышек зацепится груз сейчас. При этом если активная длина при этом уменьшается хотя бы вдвое или мы делаем первый шаг, то просто переходим к следующему шагу. А иначе пусть текущий колышек имеет номер i, следующий — j (без ограничения общности i < j). Тогда заметим, что после колышка j мы снова зацепимся именно за колышек i. Действительно, 2(xj - xi) ≤ La, поэтому веревка зацепится не правее чем за i-й колышек. И либо i = 1, либо La ≤ xi - xi - 1, поэтому левее, чем за i-й колышек она тоже зацепиться не может. И вообще, пока активная длина будет не меньше, чем xj - xi, груз будет наматываться на эту пару колышков, следовательно, можно сделать сразу несколько ходов. При этом после этих ходов длина веревки уменьшится хотя бы вдвое. Поэтому всего таких будет сделано не больше log(L), где L — изначальная длина веревки.Решение: O(mlogLlogn); решение.555E - Дело о компьютерной сетиДля начала, сведем задачу к задаче на дереве. В каждой компоненте двусвязности ориентируем ребра в порядке обхода DFS. Утверждается, что мы получим компоненту сильной связности. Пусть это не так. Тогда граф можно разбить на два подграфа A и B так, что не существует ребер, идущих из B в A. Причем изначально ребер между A и B хотя бы два. Но это невозможно, так как, зайдя в эту компоненту B, мы должны будем выйти по одному из ребер между A и B, а это невозможно. Противоречие. Поэтому мы можем сжать все компоненты двусвязности.Теперь надо обработать несколько запросов вида “ориентировать ребра на пути” и проследить за отсутствием конфликтов. Подвесим дерево за некоторую вершину и предподсчитаем LCA для исходных пар вершин. Запустим dfs из корня и для каждого поддерева посчитаем количество вершин, являющихся началами исходных путей (переменная а), вершин, являющихся концами исходных путей (переменная b), и предпосчитанных LCA (переменная c). По этой информации можно ориентировать ребро из корня поддерева в предка: если a - c положительно, тогда вверх, если b - c положительно, тогда вниз, если оба положительны, тогда решения нет, если оба нули, то как угодно.Время: O(n + qlq) где lq это время подсчета LCA на запрос; решение, использующее немного другой метод для последней части.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 555\\s*D"
          },
          "content_length": 5716
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, -1000000000, 1000000000, \"x\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == n, \"Coordinates xi must be distinct\");\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, -1000000000, 1000000000, \"x\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == n, \"Coordinates xi must be distinct\");\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<int> x = inf.readInts(n, -1000000000, 1000000000, \"x\");\n    inf.readEoln();\n\n    set<int> x_set(x.begin(), x.end());\n    ensuref((int)x_set.size() == n, \"Coordinates xi must be distinct\");\n\n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000000000, \"li\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_coordinate = opt<int>(\"max_coordinate\", int(1e9));\n    int max_l = opt<int>(\"max_l\", int(1e9));\n    int fixed_a = opt<int>(\"fixed_a\", -1);\n    int fixed_l = opt<int>(\"fixed_l\", -1);\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        // Generate random distinct x_i\n        set<int> x_set;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-max_coordinate, max_coordinate);\n            } while (x_set.count(xi));\n            x_set.insert(xi);\n            x[i] = xi;\n        }\n    } else if (type == \"close\") {\n        // Pegs close together\n        x[0] = rnd.next(-max_coordinate, max_coordinate - n);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + 1; // Ensure they are distinct and close\n        }\n    } else if (type == \"wide\") {\n        // Pegs widely spread\n        x[0] = -max_coordinate + 1;\n        int delta = (2 * max_coordinate - 2) / n;\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + delta;\n            if (x[i] >= max_coordinate) x[i] = max_coordinate - n + i;\n        }\n    } else if (type == \"max_interaction\") {\n        // Designed to maximize interactions\n        x[0] = rnd.next(-max_coordinate / 2, max_coordinate / 2);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + 1; // Pegs are close together\n        }\n    } else if (type == \"min_interaction\") {\n        // Pegs are far apart\n        x[0] = rnd.next(-max_coordinate + n, max_coordinate - n);\n        int delta = max_coordinate / n;\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + delta;\n        }\n    } else if (type == \"random_extreme\") {\n        // Pegs at extreme positions\n        set<int> x_set;\n        x[0] = -max_coordinate;\n        x[1] = max_coordinate;\n        x_set.insert(x[0]);\n        x_set.insert(x[1]);\n        for (int i = 2; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-max_coordinate + 1, max_coordinate - 1);\n            } while (x_set.count(xi));\n            x_set.insert(xi);\n            x[i] = xi;\n        }\n    } else {\n        // Default random\n        set<int> x_set;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-max_coordinate, max_coordinate);\n            } while (x_set.count(xi));\n            x_set.insert(xi);\n            x[i] = xi;\n        }\n    }\n\n    // Shuffle pegs to avoid any ordering assumptions\n    shuffle(x.begin(), x.end());\n\n    // Prepare queries\n    vector<int> a(m), l(m);\n\n    for (int i = 0; i < m; ++i) {\n        if (fixed_a != -1)\n            a[i] = fixed_a;\n        else\n            a[i] = rnd.next(1, n);\n\n        if (fixed_l != -1)\n            l[i] = fixed_l;\n        else\n            l[i] = rnd.next(1, max_l);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", a[i], l[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_coordinate = opt<int>(\"max_coordinate\", int(1e9));\n    int max_l = opt<int>(\"max_l\", int(1e9));\n    int fixed_a = opt<int>(\"fixed_a\", -1);\n    int fixed_l = opt<int>(\"fixed_l\", -1);\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        // Generate random distinct x_i\n        set<int> x_set;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-max_coordinate, max_coordinate);\n            } while (x_set.count(xi));\n            x_set.insert(xi);\n            x[i] = xi;\n        }\n    } else if (type == \"close\") {\n        // Pegs close together\n        x[0] = rnd.next(-max_coordinate, max_coordinate - n);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + 1; // Ensure they are distinct and close\n        }\n    } else if (type == \"wide\") {\n        // Pegs widely spread\n        x[0] = -max_coordinate + 1;\n        int delta = (2 * max_coordinate - 2) / n;\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + delta;\n            if (x[i] >= max_coordinate) x[i] = max_coordinate - n + i;\n        }\n    } else if (type == \"max_interaction\") {\n        // Designed to maximize interactions\n        x[0] = rnd.next(-max_coordinate / 2, max_coordinate / 2);\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + 1; // Pegs are close together\n        }\n    } else if (type == \"min_interaction\") {\n        // Pegs are far apart\n        x[0] = rnd.next(-max_coordinate + n, max_coordinate - n);\n        int delta = max_coordinate / n;\n        for (int i = 1; i < n; ++i) {\n            x[i] = x[i - 1] + delta;\n        }\n    } else if (type == \"random_extreme\") {\n        // Pegs at extreme positions\n        set<int> x_set;\n        x[0] = -max_coordinate;\n        x[1] = max_coordinate;\n        x_set.insert(x[0]);\n        x_set.insert(x[1]);\n        for (int i = 2; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-max_coordinate + 1, max_coordinate - 1);\n            } while (x_set.count(xi));\n            x_set.insert(xi);\n            x[i] = xi;\n        }\n    } else {\n        // Default random\n        set<int> x_set;\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-max_coordinate, max_coordinate);\n            } while (x_set.count(xi));\n            x_set.insert(xi);\n            x[i] = xi;\n        }\n    }\n\n    // Shuffle pegs to avoid any ordering assumptions\n    shuffle(x.begin(), x.end());\n\n    // Prepare queries\n    vector<int> a(m), l(m);\n\n    for (int i = 0; i < m; ++i) {\n        if (fixed_a != -1)\n            a[i] = fixed_a;\n        else\n            a[i] = rnd.next(1, n);\n\n        if (fixed_l != -1)\n            l[i] = fixed_l;\n        else\n            l[i] = rnd.next(1, max_l);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", a[i], l[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -type random\n\n./gen -n 10 -m 10 -type random\n\n./gen -n 10 -m 10 -type close\n\n./gen -n 10 -m 10 -type wide\n\n./gen -n 10 -m 10 -type max_interaction\n\n./gen -n 10 -m 10 -type min_interaction\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 100 -m 100 -type close\n\n./gen -n 100 -m 100 -type max_interaction\n\n./gen -n 100 -m 100 -type min_interaction\n\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 1000 -m 1000 -type close\n\n./gen -n 1000 -m 1000 -type max_interaction\n\n./gen -n 1000 -m 1000 -type min_interaction\n\n./gen -n 200000 -m 200000 -type random\n\n./gen -n 200000 -m 200000 -type close\n\n./gen -n 200000 -m 200000 -type wide\n\n./gen -n 200000 -m 200000 -type max_interaction\n\n./gen -n 200000 -m 200000 -type min_interaction\n\n./gen -n 200000 -m 200000 -type random -max_l 1\n\n./gen -n 200000 -m 200000 -type random -max_l 1000000000\n\n./gen -n 200000 -m 200000 -type random -fixed_a 1\n\n./gen -n 200000 -m 200000 -type random -fixed_l 1\n\n./gen -n 200000 -m 200000 -type random_extreme\n\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 1000 -m 200000 -type random\n\n./gen -n 200000 -m 1000 -type random\n\n./gen -n 200000 -m 200000 -type random -max_coordinate 1000000000\n\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 2 -type random\n\n./gen -n 10 -m 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:31.388189",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "555/E",
      "title": "E. Case of Computer Network",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and q (1 ≤ n, m, q ≤ 2·105) — the number of nodes, channels and important messages.Next m lines contain two integers each, vi and ui (1 ≤ vi, ui ≤ n, vi ≠ ui), that means that between nodes vi and ui is a channel. Between a pair of nodes can exist more than one channel.Next q lines contain two integers si and di (1 ≤ si, di ≤ n, si ≠ di) — the numbers of the nodes of the source and destination of the corresponding message.It is not guaranteed that in it initially possible to transmit all the messages.",
      "output_spec": "OutputIf a solution exists, print on a single line \"Yes\" (without the quotes). Otherwise, print \"No\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy4 4 21 21 32 33 41 34 2OutputCopyYesInputCopy3 2 21 23 21 32 1OutputCopyNoInputCopy3 3 21 21 23 21 32 1OutputCopyYes",
      "description": "E. Case of Computer Network\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, m and q (1 ≤ n, m, q ≤ 2·105) — the number of nodes, channels and important messages.Next m lines contain two integers each, vi and ui (1 ≤ vi, ui ≤ n, vi ≠ ui), that means that between nodes vi and ui is a channel. Between a pair of nodes can exist more than one channel.Next q lines contain two integers si and di (1 ≤ si, di ≤ n, si ≠ di) — the numbers of the nodes of the source and destination of the corresponding message.It is not guaranteed that in it initially possible to transmit all the messages.\n\nOutputIf a solution exists, print on a single line \"Yes\" (without the quotes). Otherwise, print \"No\" (without the quotes).\n\nInputCopy4 4 21 21 32 33 41 34 2OutputCopyYesInputCopy3 2 21 23 21 32 1OutputCopyNoInputCopy3 3 21 21 23 21 32 1OutputCopyYes\n\nInputCopy4 4 21 21 32 33 41 34 2\n\nOutputCopyYes\n\nInputCopy3 2 21 23 21 32 1\n\nOutputCopyNo\n\nInputCopy3 3 21 21 23 21 32 1\n\nOutputCopyYes\n\nNoteIn the first sample test you can assign directions, for example, as follows: 1 → 2, 1 → 3, 3 → 2, 4 → 3. Then the path for for the first message will be 1 → 3, and for the second one — 4 → 3 → 2.In the third sample test you can assign directions, for example, as follows: 1 → 2, 2 → 1, 2 → 3. Then the path for the first message will be 1 → 2 → 3, and for the second one — 2 → 1.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 555\\s*E"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        ensuref(vi != ui, \"vi (%d) should not equal ui (%d)\", vi, ui);\n    }\n\n    for (int i = 0; i < q; i++) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int di = inf.readInt(1, n, \"di\");\n        inf.readEoln();\n        ensuref(si != di, \"si (%d) should not equal di (%d)\", si, di);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        ensuref(vi != ui, \"vi (%d) should not equal ui (%d)\", vi, ui);\n    }\n\n    for (int i = 0; i < q; i++) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int di = inf.readInt(1, n, \"di\");\n        inf.readEoln();\n        ensuref(si != di, \"si (%d) should not equal di (%d)\", si, di);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int vi = inf.readInt(1, n, \"vi\");\n        inf.readSpace();\n        int ui = inf.readInt(1, n, \"ui\");\n        inf.readEoln();\n        ensuref(vi != ui, \"vi (%d) should not equal ui (%d)\", vi, ui);\n    }\n\n    for (int i = 0; i < q; i++) {\n        int si = inf.readInt(1, n, \"si\");\n        inf.readSpace();\n        int di = inf.readInt(1, n, \"di\");\n        inf.readEoln();\n        ensuref(si != di, \"si (%d) should not equal di (%d)\", si, di);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    int connected_components = opt<int>(\"cc\", 1); // number of connected components\n\n    vector<pair<int, int>> edges;\n    vector<pair<int, int>> messages;\n\n    if (type == \"random\") {\n        // Generate random edges\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"chain\") {\n        // Generate a chain\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        // Add extra edges if m > n - 1\n        for (int i = n - 1; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"star\") {\n        // Generate a star graph\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Add extra edges if m > n - 1\n        for (int i = n - 1; i < m; ++i) {\n            int u = rnd.next(2, n);\n            int v = rnd.next(2, n);\n            while (u == v) {\n                v = rnd.next(2, n);\n            }\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"disconnected\") {\n        // Generate a graph with multiple connected components\n        int nodes_per_component = n / connected_components;\n        int node_counter = 1;\n        for (int cc = 0; cc < connected_components; ++cc) {\n            int component_size = nodes_per_component;\n            if (cc == connected_components - 1) {\n                // Last component takes any remaining nodes\n                component_size = n - node_counter + 1;\n            }\n            // Create a chain in this component\n            for (int i = 0; i < component_size - 1; ++i) {\n                edges.push_back({node_counter + i, node_counter + i + 1});\n            }\n            node_counter += component_size;\n        }\n        // Add extra edges if m > total edges so far\n        int current_m = edges.size();\n        for (int i = current_m; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else if (type == \"multiple_edges\") {\n        // Generate a graph with multiple edges between same nodes\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else if (type == \"clique\") {\n        // Create a clique (complete graph)\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back({u, v});\n                if (edges.size() == m)\n                    break;\n            }\n            if (edges.size() == m)\n                break;\n        }\n        // Add random edges if m > edges in clique\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else if (type == \"tree\") {\n        // Generate a tree\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n        // Add extra edges if m > n - 1\n        for (int i = n - 1; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    }\n\n    // Ensure we have exactly m edges\n    if (edges.size() > m)\n        edges.resize(m);\n\n    // Generate messages (si, di)\n    for (int i = 0; i < q; ++i) {\n        int s = rnd.next(1, n);\n        int d = rnd.next(1, n);\n        while (s == d) {\n            d = rnd.next(1, n);\n        }\n        messages.push_back({s, d});\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output messages\n    for (auto msg : messages) {\n        printf(\"%d %d\\n\", msg.first, msg.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    int connected_components = opt<int>(\"cc\", 1); // number of connected components\n\n    vector<pair<int, int>> edges;\n    vector<pair<int, int>> messages;\n\n    if (type == \"random\") {\n        // Generate random edges\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"chain\") {\n        // Generate a chain\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        // Add extra edges if m > n - 1\n        for (int i = n - 1; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"star\") {\n        // Generate a star graph\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n        // Add extra edges if m > n - 1\n        for (int i = n - 1; i < m; ++i) {\n            int u = rnd.next(2, n);\n            int v = rnd.next(2, n);\n            while (u == v) {\n                v = rnd.next(2, n);\n            }\n            edges.push_back({u, v});\n        }\n\n    } else if (type == \"disconnected\") {\n        // Generate a graph with multiple connected components\n        int nodes_per_component = n / connected_components;\n        int node_counter = 1;\n        for (int cc = 0; cc < connected_components; ++cc) {\n            int component_size = nodes_per_component;\n            if (cc == connected_components - 1) {\n                // Last component takes any remaining nodes\n                component_size = n - node_counter + 1;\n            }\n            // Create a chain in this component\n            for (int i = 0; i < component_size - 1; ++i) {\n                edges.push_back({node_counter + i, node_counter + i + 1});\n            }\n            node_counter += component_size;\n        }\n        // Add extra edges if m > total edges so far\n        int current_m = edges.size();\n        for (int i = current_m; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else if (type == \"multiple_edges\") {\n        // Generate a graph with multiple edges between same nodes\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else if (type == \"clique\") {\n        // Create a clique (complete graph)\n        for (int u = 1; u <= n; ++u) {\n            for (int v = u + 1; v <= n; ++v) {\n                edges.push_back({u, v});\n                if (edges.size() == m)\n                    break;\n            }\n            if (edges.size() == m)\n                break;\n        }\n        // Add random edges if m > edges in clique\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else if (type == \"tree\") {\n        // Generate a tree\n        vector<int> perm(n);\n        for (int i = 0; i < n; ++i)\n            perm[i] = i + 1;\n        shuffle(perm.begin(), perm.end());\n        for (int i = 1; i < n; ++i) {\n            int u = perm[i];\n            int v = perm[rnd.next(0, i - 1)];\n            edges.push_back({u, v});\n        }\n        // Add extra edges if m > n - 1\n        for (int i = n - 1; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) {\n                v = rnd.next(1, n);\n            }\n            edges.push_back({u, v});\n        }\n    }\n\n    // Ensure we have exactly m edges\n    if (edges.size() > m)\n        edges.resize(m);\n\n    // Generate messages (si, di)\n    for (int i = 0; i < q; ++i) {\n        int s = rnd.next(1, n);\n        int d = rnd.next(1, n);\n        while (s == d) {\n            d = rnd.next(1, n);\n        }\n        messages.push_back({s, d});\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output messages\n    for (auto msg : messages) {\n        printf(\"%d %d\\n\", msg.first, msg.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 3 -m 2 -q 2 -type chain\n./gen -n 5 -m 4 -q 3 -type star\n./gen -n 5 -m 5 -q 4 -type random\n\n# Test cases with maximum sizes\n./gen -n 200000 -m 200000 -q 200000 -type random\n./gen -n 200000 -m 200000 -q 200000 -type chain\n./gen -n 200000 -m 200000 -q 200000 -type star\n./gen -n 200000 -m 200000 -q 200000 -type tree\n./gen -n 200000 -m 200000 -q 200000 -type multiple_edges\n\n# Test cases with multiple edges\n./gen -n 100000 -m 200000 -q 100000 -type multiple_edges\n\n# Test cases with disconnected graphs\n./gen -n 100000 -m 99999 -q 100000 -type disconnected -cc 2\n./gen -n 100000 -m 100000 -q 100000 -type disconnected -cc 10\n\n# Test cases with fully connected small graph\n./gen -n 500 -m 124750 -q 1000 -type clique\n\n# Test cases where answer is likely 'No'\n./gen -n 1000 -m 500 -q 1000 -type disconnected -cc 5\n\n# Test cases where answer is likely 'Yes'\n./gen -n 100000 -m 99999 -q 100000 -type tree\n\n# Test cases with combined structures\n./gen -n 100000 -m 150000 -q 100000 -type random\n\n# Test cases with specific structures\n./gen -n 100000 -m 150000 -q 100000 -type chain\n\n# Repeated maximum size random test case\n./gen -n 200000 -m 200000 -q 200000 -type random\n\n# Minimal test cases\n./gen -n 2 -m 1 -q 1 -type chain\n\n# Test for messages between random nodes\n./gen -n 100000 -m 100000 -q 200000 -type random\n\n# Test cases with maximum edges (multiple edges)\n./gen -n 200000 -m 200000 -q 200000 -type multiple_edges\n\n# Test cases with minimum edges (m = n -1)\n./gen -n 200000 -m 199999 -q 200000 -type chain\n\n# Test cases with n = 2e5, m = 2e5, q = 1\n./gen -n 200000 -m 200000 -q 1 -type random\n\n# Test cases with q small\n./gen -n 200000 -m 200000 -q 1000 -type random\n\n# Test cases with m small\n./gen -n 200000 -m 1000 -q 200000 -type random\n\n# Test cases with n small\n./gen -n 1000 -m 200000 -q 200000 -type multiple_edges\n\n# Test cases with cycles\n./gen -n 10000 -m 20000 -q 10000 -type random\n\n# Test cases with duplicate edges\n./gen -n 100000 -m 200000 -q 100000 -type multiple_edges\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:33.760462",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "556/A",
      "title": "A. Case of the Zeros and Ones",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains a single integer n (1 ≤ n ≤ 2·105), the length of the string that Andreid has.The second line contains the string of length n consisting only from zeros and ones.",
      "output_spec": "OutputOutput the minimum length of the string that may remain after applying the described operations several times.",
      "sample_tests": "ExamplesInputCopy41100OutputCopy0InputCopy501010OutputCopy1InputCopy811101111OutputCopy6",
      "description": "A. Case of the Zeros and Ones\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputFirst line of the input contains a single integer n (1 ≤ n ≤ 2·105), the length of the string that Andreid has.The second line contains the string of length n consisting only from zeros and ones.\n\nOutputOutput the minimum length of the string that may remain after applying the described operations several times.\n\nInputCopy41100OutputCopy0InputCopy501010OutputCopy1InputCopy811101111OutputCopy6\n\nInputCopy41100\n\nOutputCopy0\n\nInputCopy501010\n\nOutputCopy1\n\nInputCopy811101111\n\nOutputCopy6\n\nNoteIn the first sample test it is possible to change the string like the following: .In the second sample test it is possible to change the string like the following: .In the third sample test it is possible to change the string like the following: .",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 556\\s*A"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\"+ to_string(n) +\"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\"+ to_string(n) +\"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    string pattern = \"[01]{\"+ to_string(n) +\"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = '0' + rnd.next(2);  // Generates '0' or '1'\n    } else if (type == \"all_zero\") {\n        s = string(n, '0');\n    } else if (type == \"all_one\") {\n        s = string(n, '1');\n    } else if (type == \"alternating\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? '0' : '1';\n    } else if (type == \"alternating1\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? '1' : '0';\n    } else if (type == \"half_half\") {\n        int zeros = n / 2;\n        int ones = n - zeros;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"zeros_more\") {\n        int zeros = n * 2 / 3;\n        int ones = n - zeros;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"ones_more\") {\n        int ones = n * 2 / 3;\n        int zeros = n - ones;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"equal\") {\n        int zeros = n / 2;\n        int ones = n - zeros;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"max_adjacent_pairs\") {\n        s.resize(n);\n        char start = '0' + rnd.next(2);  // Randomly choose '0' or '1' to start\n        for (int i = 0; i < n; ++i) {\n            s[i] = start;\n            start = (start == '0') ? '1' : '0';\n        }\n    } else if (type == \"min_adjacent_pairs\") {\n        if (rnd.next(2)) {\n            // All zeros followed by all ones\n            int zeros = n / 2;\n            int ones = n - zeros;\n            s = string(zeros, '0') + string(ones, '1');\n        } else {\n            // All ones followed by all zeros\n            int ones = n / 2;\n            int zeros = n - ones;\n            s = string(ones, '1') + string(zeros, '0');\n        }\n    } else {\n        // Default case\n        s = string(n, '0');\n    }\n\n    printf(\"%d\\n%s\\n\", n, s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = '0' + rnd.next(2);  // Generates '0' or '1'\n    } else if (type == \"all_zero\") {\n        s = string(n, '0');\n    } else if (type == \"all_one\") {\n        s = string(n, '1');\n    } else if (type == \"alternating\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? '0' : '1';\n    } else if (type == \"alternating1\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? '1' : '0';\n    } else if (type == \"half_half\") {\n        int zeros = n / 2;\n        int ones = n - zeros;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"zeros_more\") {\n        int zeros = n * 2 / 3;\n        int ones = n - zeros;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"ones_more\") {\n        int ones = n * 2 / 3;\n        int zeros = n - ones;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"equal\") {\n        int zeros = n / 2;\n        int ones = n - zeros;\n        vector<char> vec(zeros, '0');\n        vec.insert(vec.end(), ones, '1');\n        shuffle(vec.begin(), vec.end());\n        s.assign(vec.begin(), vec.end());\n    } else if (type == \"max_adjacent_pairs\") {\n        s.resize(n);\n        char start = '0' + rnd.next(2);  // Randomly choose '0' or '1' to start\n        for (int i = 0; i < n; ++i) {\n            s[i] = start;\n            start = (start == '0') ? '1' : '0';\n        }\n    } else if (type == \"min_adjacent_pairs\") {\n        if (rnd.next(2)) {\n            // All zeros followed by all ones\n            int zeros = n / 2;\n            int ones = n - zeros;\n            s = string(zeros, '0') + string(ones, '1');\n        } else {\n            // All ones followed by all zeros\n            int ones = n / 2;\n            int zeros = n - ones;\n            s = string(ones, '1') + string(zeros, '0');\n        }\n    } else {\n        // Default case\n        s = string(n, '0');\n    }\n\n    printf(\"%d\\n%s\\n\", n, s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_zero\n./gen -n 1 -type all_one\n\n./gen -n 2 -type max_adjacent_pairs\n./gen -n 2 -type min_adjacent_pairs\n\n./gen -n 3 -type random\n./gen -n 3 -type alternating\n\n./gen -n 10 -type random\n./gen -n 10 -type zeros_more\n./gen -n 10 -type ones_more\n./gen -n 10 -type equal\n\n./gen -n 50 -type alternating\n./gen -n 50 -type alternating1\n./gen -n 50 -type max_adjacent_pairs\n./gen -n 50 -type min_adjacent_pairs\n\n./gen -n 1000 -type random\n./gen -n 1000 -type zeros_more\n./gen -n 1000 -type ones_more\n./gen -n 1000 -type equal\n\n./gen -n 99999 -type random\n./gen -n 99999 -type zeros_more\n\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_one\n\n./gen -n 199999 -type max_adjacent_pairs\n./gen -n 199999 -type min_adjacent_pairs\n\n./gen -n 200000 -type random\n./gen -n 200000 -type zeros_more\n./gen -n 200000 -type ones_more\n./gen -n 200000 -type equal\n\n./gen -n 200000 -type alternating\n./gen -n 200000 -type alternating1\n\n./gen -n 199998 -type equal\n./gen -n 199997 -type zeros_more\n./gen -n 199996 -type ones_more\n\n./gen -n 200000 -type zeros_more\n./gen -n 200000 -type ones_more\n\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:35.520298",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "556/B",
      "title": "Problem 556/B",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, n - 1, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"yes\") {\n        // Generate a \"Yes\" test case\n        int ri = rnd.next(n);\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 1) {\n                a[i - 1] = ((i - 1) - ri + n) % n;\n            } else {\n                a[i - 1] = (ri + i - 1) % n;\n            }\n        }\n    } else if (type == \"no\") {\n        // Generate a \"No\" test case\n        if (n == 1) {\n            // Only one gear, cannot make ri differ\n            // So we set ai arbitrarily\n            a[0] = rnd.next(n);\n        } else {\n            // Generate two different ri\n            int ri1 = rnd.next(n);\n            int ri2 = (ri1 + rnd.next(1, n - 1)) % n; // ensure ri1 != ri2\n\n            int split = rnd.next(1, n - 1); // split point\n\n            for (int i = 1; i <= split; ++i) {\n                int ri = ri1;\n                if (i % 2 == 1) {\n                    a[i - 1] = ((i - 1) - ri + n) % n;\n                } else {\n                    a[i - 1] = (ri + i - 1) % n;\n                }\n            }\n\n            for (int i = split + 1; i <= n; ++i) {\n                int ri = ri2;\n                if (i % 2 == 1) {\n                    a[i - 1] = ((i - 1) - ri + n) % n;\n                } else {\n                    a[i - 1] = (ri + i - 1) % n;\n                }\n            }\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(n);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"yes\") {\n        // Generate a \"Yes\" test case\n        int ri = rnd.next(n);\n        for (int i = 1; i <= n; ++i) {\n            if (i % 2 == 1) {\n                a[i - 1] = ((i - 1) - ri + n) % n;\n            } else {\n                a[i - 1] = (ri + i - 1) % n;\n            }\n        }\n    } else if (type == \"no\") {\n        // Generate a \"No\" test case\n        if (n == 1) {\n            // Only one gear, cannot make ri differ\n            // So we set ai arbitrarily\n            a[0] = rnd.next(n);\n        } else {\n            // Generate two different ri\n            int ri1 = rnd.next(n);\n            int ri2 = (ri1 + rnd.next(1, n - 1)) % n; // ensure ri1 != ri2\n\n            int split = rnd.next(1, n - 1); // split point\n\n            for (int i = 1; i <= split; ++i) {\n                int ri = ri1;\n                if (i % 2 == 1) {\n                    a[i - 1] = ((i - 1) - ri + n) % n;\n                } else {\n                    a[i - 1] = (ri + i - 1) % n;\n                }\n            }\n\n            for (int i = split + 1; i <= n; ++i) {\n                int ri = ri2;\n                if (i % 2 == 1) {\n                    a[i - 1] = ((i - 1) - ri + n) % n;\n                } else {\n                    a[i - 1] = (ri + i - 1) % n;\n                }\n            }\n        }\n    } else {\n        // Random test case\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(n);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type yes\n./gen -n 1 -type no\n./gen -n 1 -type random\n\n./gen -n 2 -type yes\n./gen -n 2 -type no\n./gen -n 2 -type random\n\n./gen -n 3 -type yes\n./gen -n 3 -type no\n./gen -n 3 -type random\n\n./gen -n 5 -type yes\n./gen -n 5 -type no\n./gen -n 5 -type random\n\n./gen -n 10 -type yes\n./gen -n 10 -type no\n./gen -n 10 -type random\n\n./gen -n 50 -type yes\n./gen -n 50 -type no\n./gen -n 50 -type random\n\n./gen -n 100 -type yes\n./gen -n 100 -type no\n./gen -n 100 -type random\n\n./gen -n 200 -type yes\n./gen -n 200 -type no\n./gen -n 200 -type random\n\n./gen -n 500 -type yes\n./gen -n 500 -type no\n./gen -n 500 -type random\n\n./gen -n 999 -type yes\n./gen -n 999 -type no\n./gen -n 999 -type random\n\n./gen -n 1000 -type yes\n./gen -n 1000 -type no\n./gen -n 1000 -type random\n\n# Additional tests for specific edge cases\n./gen -n 4 -type yes\n./gen -n 4 -type no\n\n./gen -n 10 -type yes\n./gen -n 10 -type no\n\n./gen -n 1000 -type yes\n./gen -n 1000 -type no\n\n# Tests with n = 1000 and random types\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n\n# Tests with small n and random types\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 3 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:37.816637",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "556/C",
      "title": "C. Case of Matryoshkas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n (1 ≤ n ≤ 105) and k (1 ≤ k ≤ 105) — the number of matryoshkas and matryoshka chains in the initial configuration.The next k lines contain the descriptions of the chains: the i-th line first contains number mi (1 ≤ mi ≤ n), and then mi numbers ai1, ai2, ..., aimi — the numbers of matryoshkas in the chain (matryoshka ai1 is nested into matryoshka ai2, that is nested into matryoshka ai3, and so on till the matryoshka aimi that isn't nested into any other matryoshka).It is guaranteed that m1 + m2 + ... + mk = n, the numbers of matryoshkas in all the chains are distinct, in each chain the numbers of matryoshkas follow in the ascending order.",
      "output_spec": "OutputIn the single line print the minimum number of seconds needed to assemble one large chain from the initial configuration.",
      "sample_tests": "ExamplesInputCopy3 22 1 21 3OutputCopy1InputCopy7 33 1 3 72 2 52 4 6OutputCopy10",
      "description": "C. Case of Matryoshkas\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integers n (1 ≤ n ≤ 105) and k (1 ≤ k ≤ 105) — the number of matryoshkas and matryoshka chains in the initial configuration.The next k lines contain the descriptions of the chains: the i-th line first contains number mi (1 ≤ mi ≤ n), and then mi numbers ai1, ai2, ..., aimi — the numbers of matryoshkas in the chain (matryoshka ai1 is nested into matryoshka ai2, that is nested into matryoshka ai3, and so on till the matryoshka aimi that isn't nested into any other matryoshka).It is guaranteed that m1 + m2 + ... + mk = n, the numbers of matryoshkas in all the chains are distinct, in each chain the numbers of matryoshkas follow in the ascending order.\n\nOutputIn the single line print the minimum number of seconds needed to assemble one large chain from the initial configuration.\n\nInputCopy3 22 1 21 3OutputCopy1InputCopy7 33 1 3 72 2 52 4 6OutputCopy10\n\nInputCopy3 22 1 21 3\n\nOutputCopy1\n\nInputCopy7 33 1 3 72 2 52 4 6\n\nOutputCopy10\n\nNoteIn the first sample test there are two chains: 1 → 2 and 3. In one second you can nest the first chain into the second one and get 1 → 2 → 3.In the second sample test you need to disassemble all the three chains into individual matryoshkas in 2 + 1 + 1 = 4 seconds and then assemble one big chain in 6 seconds.",
      "solutions": [
        {
          "title": "Codeforces Round #310 - Codeforces",
          "content": "Hello, Codeforces.Soon, on 27 june at 17:00 MSK regular, 310-th Codeforces round will take place. Problems have been prepared by me, Andrey Sergunin, and Egor Shcherbin (Lord_F).We want to thank Max Akhmedov (Zlobober) for helping us preparing the contest, Maria Belova (Delinur) for translating statements in English and Mike Mirzayanov (MikeMirzayanov) for great Codeforces and Polygon systems.Participants will be given five problems and two hours to solve them. Scoring will be announced later.Good luck everyone!This round will use the dynamic scoring.UPD: Due to technical reasons round is delayed by 10 minutes.UPD: The preliminary version of an editorial was posted. UPD: Congratulation to the winners:Div 1 qwerty787788 Petr Haghani KADR zxqfl Div 2 onufryw munaiyi _h_ Chenyao mhadih",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18896",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 793
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces",
          "content": "Hello, everyone!556A - Case of the Zeros and OnesIf there still exist at least one 0 and at least one 1 in the string then there obviously exists either substring 01 or substring 10 (or both) and we can remove it. The order in which we remove substrings is unimportant: in any case we will make min(#zeros, #ones) such operations. Thus the answer is #ones + #zeros - 2min(#ones, #zeros) = |#ones - #zeros|.Time: O(n).556B - Case of Fake NumbersNotice that after pressing the button n times gears return to initial state. So the easiest solution is to simulate the process of pressing the button n times and if at some step the active teeth sequence is 0, 1, ... , n - 1 output \"Yes\" else \"No\". But this solution can be improved. For instance, knowing the active tooth of the first gear you can quickly determine how many times pressing the button is necessary, go to that state and check the sequence only once.Time: O(n) or O(n2); solutions: O(n) and O(n^2)555A - Case of MatryoshkasSuppose we don't need to disassemble some sequence of dolls. Then no doll can be inserted into no doll from this chain. So we don't need to disassemble a sequence of dolls only if they are consecutive and start from 1. Let the length of this chain be l. Then we will need to get one doll from another n - k - l + 1 times. Now we have a sequence 1 → 2 → ... → l and all other dolls by themselves. n - l + 1 chains in total so we need to put one doll into another n - l times. 2n - k - 2l + 1 operations in total.Time: O(n); solution.555B - Case of FugitiveWe can put a bridge between bridges i and i + 1 if its length lies in the segment [li + 1 - ri;ri + 1 - li]. Now we have a well-known problem: there are n - 1 segments and m points on a plane, for every segment we need to assign a point which lies in it to this segment and every point can be assigned only once. Let's call a segment open if no point is assigned to it. Let's go through all points from left to right and at every moment keep all open segments that contain current point in a BST (std::set). When processing a point it should be assigned to the segment (from our set) that has the leftmost right end.This algorithm will find the answer if there is one. Suppose this solution is wrong and suppose there is a solution in which point A is assigned to another open segment (there's no sense in skipping this point). Then some point B is assigned to the segment which A was assigned to. B is to the right of A so we can swap them and come to our answer again. Time: O((n + m)log(n + m)); solution.555C - Case of ChocolateLet's solve this problem with two segment trees: we'll keep the lowest eaten piece for each column in one of them and the leftmost eaten piece for each row in another. Suppose we have a query x y L. Position where we'll stop eating chocolate is stored in the row segment tree so we can easily find the number of eaten pieces. After that we need to update both segment trees.n is rather big in this problem. One way to deal with it is to use coordinate compression. Another is to use implicit segment trees.Time: O(qlogq) or O(qlogn); solutions: 1 and 2.555D - Case of a Top SecretI call the length of the part of the rope from the weight to the last met peg the active length (denoted as La). After each met peg active length is reduced. Let's process queries separately: at each step we can find next peg with using binary search. If active length becomes at least two times shorter or current step is the first one we proceed to the next step. Otherwise say current peg is peg i and the next one is peg j (without loss of generality i < j). Then after peg j the rope will again touch peg i and the weight will again rotate around peg i. Indeed, 2(xj - xi) ≤ La so the weight will rotate around a peg not to the right to peg i. And either i = 1 or La ≤ xi - xi - 1 so it won't also rotate around a peg to the left to peg i. As long as La ≥ xj - xi the weight will rotate around these two pegs so we can skip through several steps momentarily. This way active length is shortened at least twice so there will be no more than logL steps.Time: O(mlogLlogn); solution.555E - Case of Computer NetworkFirst of all, let's reduce this problem to a problem on a tree. In order to achieve this let's orient edges in all biconnected components according to a DFS-order. We'll get a strongly connected component. Suppose it's false. Then this component can be divided into parts A and B such that there's no edge from B to A. As initially there are at least two edges between A and B this situation is impossible because after entering B in our DFS we'll have to exit via one of these edges. Contradiction. We can compress all biconnected components.Now we need to handle several queries \"orient edges on a simple path in a tree\" and to check if there are no conflicts. For this let's hang our tree and find LCA's for queries' pairs of vertices. Start another DFS and for every subtree count vertices in this subtree that are beginnings of queries' paths (call it a), that are ends of queries' paths (call it b) and that are precalculated LCAs (call it c). Now we can orient the edge connecting the root of the subtree and its parent: if a - c is positive then it should be oriented up, if b - c is positive then it should be oriented down, if both are positive there's no solution, if both are zeros the direction does not matter.Time: O(n + qlq) where lq is the time of calculating LCA per query; solution that uses slightly other method for the last part.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/18919",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 556 和字母"
          },
          "content_length": 5518
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #310 - Codeforces - Code 1",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 2",
          "code": "3 2\n1 10\n11 12\n14 15\n2 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 3",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 4",
          "code": "cin>>n>>k;\n  for(i=1;i<=n;i++) {",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 5",
          "code": "for(auto& v: adj[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 6",
          "code": "for(auto& v: adj2[u]) if(v!=p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 7",
          "code": "for(auto it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 8",
          "code": "for(auto &it:M)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 9",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 10",
          "code": "20 6\n3 8 9 13\n3 4 14 20\n2 15 17\n3 2 5 11\n5 7 10 12 18 19\n4 1 3 6 16",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 11",
          "code": "int n = 5;\nn = n--;\ncout << n;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 12",
          "code": "std::lower_bound",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 13",
          "code": "b.lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 14",
          "code": "lower_bound(set.begin(), set.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 - Codeforces - Code 15",
          "code": "set.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18896",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 1",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 2",
          "code": "### ^ \n      ### h\n      ### v\n######@@@\n######@@\n######@\n<--w->",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 3",
          "code": "555A - Case of Matryoshkas",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 4",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 5",
          "code": "3 2\n2 1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 6",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 7",
          "code": "n = 3\nk = 2\nl = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 8",
          "code": "ans = 2*3 - 2 - 2*2 + 2 = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 9",
          "code": "2n - k - 2l + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 10",
          "code": "1 2 3 6 4 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 11",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 12",
          "code": "14 13 2\n1 2\n1 3\n2 4\n3 4\n5 6\n7 8\n7 9\n9 10\n9 11\n11 12\n12 13\n12 14\n13 14\n7 10\n11 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 13",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 14",
          "code": "X.put(n - le.getValue() + 1, X.floorEntry(n - le.getValue() + 1).getValue());\nX.put(x, x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #310 Editorial - Codeforces - Code 15",
          "code": "Case of Chocolate",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/18919",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    set<int> used_numbers;\n    long long sum_mi = 0;\n\n    for (int i = 0; i < k; ++i) {\n        int mi = inf.readInt(1, n, \"mi\");\n        sum_mi += mi;\n        inf.readSpace();\n\n        vector<int> chain;\n        chain.reserve(mi);\n\n        for (int j = 0; j < mi; ++j) {\n            int aij = inf.readInt(1, n, \"aij\");\n\n            if (j > 0) {\n                // Ensure that the numbers in the chain are in ascending order\n                ensuref(chain[j - 1] < aij,\n                        \"Matryoshka numbers in chain %d are not in ascending order at position %d: %d >= %d\",\n                        i + 1, j + 1, chain[j - 1], aij);\n            }\n            chain.push_back(aij);\n\n            // Ensure that each matryoshka appears only once\n            ensuref(used_numbers.count(aij) == 0,\n                    \"Matryoshka number %d appears in more than one chain\",\n                    aij);\n            used_numbers.insert(aij);\n\n            if (j != mi - 1) {\n                inf.readSpace();\n            }\n        }\n\n        inf.readEoln();\n    }\n\n    // Ensure that the total number of matryoshkas is n\n    ensuref(sum_mi == n, \"Total number of matryoshkas is %lld, expected %d\", sum_mi, n);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    set<int> used_numbers;\n    long long sum_mi = 0;\n\n    for (int i = 0; i < k; ++i) {\n        int mi = inf.readInt(1, n, \"mi\");\n        sum_mi += mi;\n        inf.readSpace();\n\n        vector<int> chain;\n        chain.reserve(mi);\n\n        for (int j = 0; j < mi; ++j) {\n            int aij = inf.readInt(1, n, \"aij\");\n\n            if (j > 0) {\n                // Ensure that the numbers in the chain are in ascending order\n                ensuref(chain[j - 1] < aij,\n                        \"Matryoshka numbers in chain %d are not in ascending order at position %d: %d >= %d\",\n                        i + 1, j + 1, chain[j - 1], aij);\n            }\n            chain.push_back(aij);\n\n            // Ensure that each matryoshka appears only once\n            ensuref(used_numbers.count(aij) == 0,\n                    \"Matryoshka number %d appears in more than one chain\",\n                    aij);\n            used_numbers.insert(aij);\n\n            if (j != mi - 1) {\n                inf.readSpace();\n            }\n        }\n\n        inf.readEoln();\n    }\n\n    // Ensure that the total number of matryoshkas is n\n    ensuref(sum_mi == n, \"Total number of matryoshkas is %lld, expected %d\", sum_mi, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    set<int> used_numbers;\n    long long sum_mi = 0;\n\n    for (int i = 0; i < k; ++i) {\n        int mi = inf.readInt(1, n, \"mi\");\n        sum_mi += mi;\n        inf.readSpace();\n\n        vector<int> chain;\n        chain.reserve(mi);\n\n        for (int j = 0; j < mi; ++j) {\n            int aij = inf.readInt(1, n, \"aij\");\n\n            if (j > 0) {\n                // Ensure that the numbers in the chain are in ascending order\n                ensuref(chain[j - 1] < aij,\n                        \"Matryoshka numbers in chain %d are not in ascending order at position %d: %d >= %d\",\n                        i + 1, j + 1, chain[j - 1], aij);\n            }\n            chain.push_back(aij);\n\n            // Ensure that each matryoshka appears only once\n            ensuref(used_numbers.count(aij) == 0,\n                    \"Matryoshka number %d appears in more than one chain\",\n                    aij);\n            used_numbers.insert(aij);\n\n            if (j != mi - 1) {\n                inf.readSpace();\n            }\n        }\n\n        inf.readEoln();\n    }\n\n    // Ensure that the total number of matryoshkas is n\n    ensuref(sum_mi == n, \"Total number of matryoshkas is %lld, expected %d\", sum_mi, n);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"one_chain\") {\n        // All matryoshkas in one chain\n        k = 1;\n        printf(\"%d %d\\n\", n, k);\n        printf(\"%d\", n);\n        for(int i = 1; i <= n; ++i) {\n            printf(\" %d\", i);\n        }\n        printf(\"\\n\");\n    }\n    else if (type == \"separate\") {\n        // Each matryoshka is in its own chain\n        k = n;\n        printf(\"%d %d\\n\", n, k);\n        for(int i = 1; i <= n; ++i) {\n            printf(\"1 %d\\n\", i);\n        }\n    }\n    else if (type == \"ordered\") {\n        // Chains have matryoshkas in order starting from 1\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1) k = 1;\n        if(k > n) k = n;\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, n / k);\n        int remaining = n - (n / k) * k;\n        for(int i = 0; i < remaining; ++i) {\n            mi[i]++;\n        }\n        int index = 1;\n        for(int i = 0; i < k; ++i) {\n            printf(\"%d\", mi[i]);\n            for(int j = 0; j < mi[i]; ++j) {\n                printf(\" %d\", index++);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"reverse\") {\n        // Chains have matryoshkas in reverse order\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1) k = 1;\n        if(k > n) k = n;\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, n / k);\n        int remaining = n - (n / k) * k;\n        for(int i = 0; i < remaining; ++i) {\n            mi[i]++;\n        }\n        int index = n;\n        for(int i = 0; i < k; ++i) {\n            printf(\"%d\", mi[i]);\n            for(int j = 0; j < mi[i]; ++j) {\n                printf(\" %d\", index--);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly distribute matryoshkas into k chains\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1 || k > n) k = rnd.next(1, n);\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, 1);\n        int remaining = n - k;\n        for(int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, k - 1);\n            mi[idx]++;\n        }\n\n        vector<int> dolls(n);\n        for(int i = 0; i < n; ++i)\n            dolls[i] = i + 1;\n\n        shuffle(dolls.begin(), dolls.end());\n\n        int index = 0;\n        for(int i = 0; i < k; ++i) {\n            vector<int> chain;\n            for(int j = 0; j < mi[i]; ++j) {\n                chain.push_back(dolls[index++]);\n            }\n            sort(chain.begin(), chain.end());\n            printf(\"%d\", mi[i]);\n            for(int num : chain) {\n                printf(\" %d\", num);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else {\n        // Default to random if type is unrecognized\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1 || k > n) k = rnd.next(1, n);\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, 1);\n        int remaining = n - k;\n        for(int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, k - 1);\n            mi[idx]++;\n        }\n\n        vector<int> dolls(n);\n        for(int i = 0; i < n; ++i)\n            dolls[i] = i + 1;\n\n        shuffle(dolls.begin(), dolls.end());\n\n        int index = 0;\n        for(int i = 0; i < k; ++i) {\n            vector<int> chain;\n            for(int j = 0; j < mi[i]; ++j) {\n                chain.push_back(dolls[index++]);\n            }\n            sort(chain.begin(), chain.end());\n            printf(\"%d\", mi[i]);\n            for(int num : chain) {\n                printf(\" %d\", num);\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"one_chain\") {\n        // All matryoshkas in one chain\n        k = 1;\n        printf(\"%d %d\\n\", n, k);\n        printf(\"%d\", n);\n        for(int i = 1; i <= n; ++i) {\n            printf(\" %d\", i);\n        }\n        printf(\"\\n\");\n    }\n    else if (type == \"separate\") {\n        // Each matryoshka is in its own chain\n        k = n;\n        printf(\"%d %d\\n\", n, k);\n        for(int i = 1; i <= n; ++i) {\n            printf(\"1 %d\\n\", i);\n        }\n    }\n    else if (type == \"ordered\") {\n        // Chains have matryoshkas in order starting from 1\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1) k = 1;\n        if(k > n) k = n;\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, n / k);\n        int remaining = n - (n / k) * k;\n        for(int i = 0; i < remaining; ++i) {\n            mi[i]++;\n        }\n        int index = 1;\n        for(int i = 0; i < k; ++i) {\n            printf(\"%d\", mi[i]);\n            for(int j = 0; j < mi[i]; ++j) {\n                printf(\" %d\", index++);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"reverse\") {\n        // Chains have matryoshkas in reverse order\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1) k = 1;\n        if(k > n) k = n;\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, n / k);\n        int remaining = n - (n / k) * k;\n        for(int i = 0; i < remaining; ++i) {\n            mi[i]++;\n        }\n        int index = n;\n        for(int i = 0; i < k; ++i) {\n            printf(\"%d\", mi[i]);\n            for(int j = 0; j < mi[i]; ++j) {\n                printf(\" %d\", index--);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly distribute matryoshkas into k chains\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1 || k > n) k = rnd.next(1, n);\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, 1);\n        int remaining = n - k;\n        for(int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, k - 1);\n            mi[idx]++;\n        }\n\n        vector<int> dolls(n);\n        for(int i = 0; i < n; ++i)\n            dolls[i] = i + 1;\n\n        shuffle(dolls.begin(), dolls.end());\n\n        int index = 0;\n        for(int i = 0; i < k; ++i) {\n            vector<int> chain;\n            for(int j = 0; j < mi[i]; ++j) {\n                chain.push_back(dolls[index++]);\n            }\n            sort(chain.begin(), chain.end());\n            printf(\"%d\", mi[i]);\n            for(int num : chain) {\n                printf(\" %d\", num);\n            }\n            printf(\"\\n\");\n        }\n    }\n    else {\n        // Default to random if type is unrecognized\n        if(k == -1) k = rnd.next(1, n);\n        if(k < 1 || k > n) k = rnd.next(1, n);\n        printf(\"%d %d\\n\", n, k);\n\n        vector<int> mi(k, 1);\n        int remaining = n - k;\n        for(int i = 0; i < remaining; ++i) {\n            int idx = rnd.next(0, k - 1);\n            mi[idx]++;\n        }\n\n        vector<int> dolls(n);\n        for(int i = 0; i < n; ++i)\n            dolls[i] = i + 1;\n\n        shuffle(dolls.begin(), dolls.end());\n\n        int index = 0;\n        for(int i = 0; i < k; ++i) {\n            vector<int> chain;\n            for(int j = 0; j < mi[i]; ++j) {\n                chain.push_back(dolls[index++]);\n            }\n            sort(chain.begin(), chain.end());\n            printf(\"%d\", mi[i]);\n            for(int num : chain) {\n                printf(\" %d\", num);\n            }\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random k, random type\n./gen -n 10 -k 5 -type random\n\n# Small n, one chain\n./gen -n 10 -type one_chain\n\n# Small n, each matryoshka in its own chain\n./gen -n 10 -type separate\n\n# Medium n, random k, ordered chains\n./gen -n 100 -k 10 -type ordered\n\n# Medium n, random k, reverse chains\n./gen -n 100 -k 10 -type reverse\n\n# Medium n, one chain\n./gen -n 100 -type one_chain\n\n# Medium n, each matryoshka in its own chain\n./gen -n 100 -type separate\n\n# Large n, random k, random type\n./gen -n 1000 -k 100 -type random\n\n# Large n, random k, ordered chains\n./gen -n 1000 -k 50 -type ordered\n\n# Large n, random k, reverse chains\n./gen -n 1000 -k 100 -type reverse\n\n# Large n, one chain\n./gen -n 1000 -type one_chain\n\n# Large n, each matryoshka in its own chain\n./gen -n 1000 -type separate\n\n# Very large n, random k, random type\n./gen -n 10000 -k 500 -type random\n\n# Very large n, random k, ordered chains\n./gen -n 10000 -k 500 -type ordered\n\n# Very large n, random k, reverse chains\n./gen -n 10000 -k 1000 -type reverse\n\n# Very large n, one chain\n./gen -n 10000 -type one_chain\n\n# Very large n, each matryoshka in its own chain\n./gen -n 10000 -type separate\n\n# Max n, random k, random type\n./gen -n 100000 -k 50000 -type random\n\n# Max n, random k, ordered chains\n./gen -n 100000 -k 50000 -type ordered\n\n# Max n, random k, reverse chains\n./gen -n 100000 -k 50000 -type reverse\n\n# Max n, one chain\n./gen -n 100000 -type one_chain\n\n# Max n, each matryoshka in its own chain\n./gen -n 100000 -type separate\n\n# Small n, k = 1, ordered chains\n./gen -n 50 -k 1 -type ordered\n\n# Small n, k = n, reverse chains\n./gen -n 50 -k 50 -type reverse\n\n# Medium n, k = n/2, random type\n./gen -n 200 -k 100 -type random\n\n# Large n, k = n/4, random type\n./gen -n 4000 -k 1000 -type random\n\n# Very large n, k = n/10, ordered chains\n./gen -n 100000 -k 10000 -type ordered\n\n# Max n, k = n/2, reverse chains\n./gen -n 100000 -k 50000 -type reverse\n\n# Max n, random k, random type\n./gen -n 100000 -k 12345 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:48:40.018581",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}