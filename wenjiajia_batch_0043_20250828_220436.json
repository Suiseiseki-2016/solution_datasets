{
  "metadata": {
    "batch_number": 43,
    "total_batches": 73,
    "problems_in_batch": 100,
    "total_problems": 7261,
    "created_at": "2025-08-28T22:04:41.510244",
    "format": "wenjiajia_v1.0"
  },
  "problems": [
    {
      "problem_id": "417/C",
      "title": "C. Футбол",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано два целых числа — n и k (1 ≤ n, k ≤ 1000).",
      "output_spec": "Выходные данныеВ первой строке выведите целое число m — количество сыгранных матчей. В следующих m строках должна содержаться информация обо всех матчах, по матчу в строке. В i-й строке выведите два целых числа ai bi (1 ≤ ai, bi ≤ n; ai ≠ bi). Числа ai, bi обозначают, что в i-м матче команда с номером ai победила команду с номером bi. Считайте, что команды пронумерованы от 1 до n.Если не существует турнира, удовлетворяющего условию задачи, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1Выходные данныеСкопировать31 22 33 1",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано два целых числа — n и k (1 ≤ n, k ≤ 1000).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число m — количество сыгранных матчей. В следующих m строках должна содержаться информация обо всех матчах, по матчу в строке. В i-й строке выведите два целых числа ai bi (1 ≤ ai, bi ≤ n; ai ≠ bi). Числа ai, bi обозначают, что в i-м матче команда с номером ai победила команду с номером bi. Считайте, что команды пронумерованы от 1 до n.Если не существует турнира, удовлетворяющего условию задачи, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать3 1Выходные данныеСкопировать31 22 33 1\n\nВходные данныеСкопировать3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 22 33 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Очередной сезон крупнейшей российской олимпиады Russian Code Cup стартует в субботу. Впереди новые интересные и нетривиальные задания, бескомпромиссная борьба и самые крутые призы.Но мы подготовили вам еще один сюрприз: 17 апреля у каждого из вас есть возможность оценить свои силы. В 19:30 по московскому времени на площадке http://codeforces.ru состоится тренировочный раунд олимпиады со свежей порцией задач от создателей RCC.RCC 2014 Warmup – это тест, который даст возможность попробовать свои силы и понять, к чему готовиться в раундах чемпионата. А для «бывалых» участников это идеальная возможность потренироваться и разогреться перед первыми сражениями RCC 2014!Автором большинства задач этого раунда является Aksenov239 — постоянный автор задач RCC. Конечно же ему помогали и другие члены жюри RCC-2014. Раунд пройдет как в div-1, так и в div-2, так что все найдут себе задачи по силам.Ждем вас в четверг в 19:30 на площадке http://codeforces.ruUPD: Итак, разбалловка раунда: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Всем удачи!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1059
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "417A - Отбор. Автор и реализация Aksenov239.Сначала нужно заметить, что если k больше либо равно, чем n·m, то ответ — 0. Нам осталось набрать n·m - k человек. Есть три способа их набрать: Взять раунды только первого типа: . Взять чуть раундов второго типа до числа, делящегося на n: . Взять только раунды второго типа: d(n·m - k). Также в данной задаче можно было написать переборное решение — сколько мы берём раундов первого типа, и сколько раундов второго.Код: 6396283417B - Сбой. Автор и реализация Aksenov239.Заведём массив a на 105 элементов, изначально заполненный  - 1, и в ячейке с номером k будем хранить максимальный номер посылки k-го участника, который сейчас есть. Будем обрабатывать посылки последовательно. Пусть обрабатывается посылка x k. Если a[k] < x - 1, то очевидно, что ответ NO, иначе обновляем массив — a[k] = max(a[k], x).Код: 6396297418A - Футбол. Автор и реализация Aksenov239.Представим турнир себе как граф. Из каждой вершины ровно k выходящих рёбер. Тогда всего nk рёбер. В полном графе максимум рёбер, поэтому если n < 2k + 1, тогда ответ  - 1. Иначе, соединим i-ую вершину с i + 1, ..., i + k, зациклим если нужно.Код: 6396331418B - Хитрый Гена. Автор и реализация Aksenov239.Давайте отсортируем друзей по возрастанию требуемого количества мониторов. Будем считать динамику на масках — какое минимальное число денег нужно заплатить, чтобы решить такие-то задачи, если мы взяли первых i друзей. Тогда ответ надо сравнить с ответом для i первых друзей плюс количество мониторов, которое требует i-ый друг. Не трудно заметить, что если брать друзей последовательно, то пересчитывать динамику можно как рюкзак. Время работы данного алгоритма O(nlog(n) + n2m).Код pashka: 6396347418C - Квадратная таблица. Автор и реализация Aksenov239.Давайте для любого n построим массив длины n, что сумма квадратов чисел на нём является квадратом: Если n = 1, то берём [1]. Если n = 2, то берём [3, 4]. Если n чётно, то берём . Если n нечётно, то берём . Нам дано 2 числа n и m. Пусть массив a соответствует числу n, а b соответствует числу m.Тогда итоговый массив c построим следующим способом — cij = ai·bj.Код: 6396358418D - Большие проблемы организаторов. Автор chavit, реализация Aksenov239.В данной задаче есть два решения.Первое. Подвесим за какую-нибудь вершину. Предподсчитаем для каждой, 3 самые удалённые вершины в её поддереве, а также для каждой вершины её глубину. Также предподсчитаем массивы для двоичного подъёма. Для каждой вершины i и степени двойки 2j предподсчитаем следующие массивы — p[i][j], up[i][j] и down[i][j]. p[i][j] — это предок вершины i на расстоянии 2j. В up[i][j] будет храниться наидлиннейший путь из i, до вершин, которые находятся в поддереве вершин, которые находятся на пути между i и p[i][j]. down[i][j] отличается от up[i][j], что хранит путь из вершины p[i][j].Теперь осталось дело за малым. Нам приходит запрос u v, мы ищем его наименьшего общего предка — w. Осталось найти вершину hu, которая будет находиться на середине это пути. Обрезать дерево по этой вершине, и посчитать длиннейшее расстояние от вершины u в её дереве и длиннейшее расстояние от вершины v в её дереве. Представляя на дереве это, если мы не будем удалять, то можно воспользовавшись нашими предподсчитанными массивами аккуратно пересчитать значение длиннейшего пути.Решение за O(nlog(n)).Код: 6396376Второе. Вкратце. Найдём диаметр этого дерева. Предподсчитаем там ответ на префиксе для каждой вершины. Тогда при ответе на запрос — мы находим, когда путь вливается диаметр. На это отрезке находим среднюю вершину, а далее отвечаем на запрос на префиксе или суффиксе.Код cerealguy: 6396390418E - Хитрый пароль. Авторы enot110, Aksenov239, реализация Aksenov239Ключевая теоретическая идея данной задачи заключается в том, что 2 строка совпадает с 4, 3 с 5 и т. д. Поэтому нам нужно уметь менять что-то только на первых трёх строках.Теперь дело остаётся за практической частью. В первую очередь сожмём все значения, чтобы они не превосходили 105. Разобьём массив на отрезки длиной LEN. На каждом отрезке будем считать следующее — для каждого значения будем хранить сколько раз он встречался на префиксе cnt, а так же дерево Фенвика, в котором в ячейке f[k] будет храниться количество чисел на данном префиксе, встречающихся ровно k раз. Несложно заметить, что в первом массиве хранится ответ на запросы ко второй строке, а чтобы получить ответ для третьей строки, нужно посчитать f[cnt[k]... 105]. Понятно так же, как делать пересчёт данной динамики.Итого, получаем время на запрос за . Если мы возьмём , то время ответа на запрос составит .Код: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 417 和字母"
          },
          "content_length": 4580
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 13",
          "code": "static base a[100005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 14",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 15",
          "code": "printf(\"%d \", j+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 16",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 17",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 18",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 1",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 2",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input\n    int n = inf.readInt();\n    int k = inf.readInt();\n\n    // Calculate maximum possible k\n    int maxK = (n - 1) / 2;\n\n    // Read participant's output\n    int m = ouf.readInt();\n\n    if (m == -1) {\n        if (k > maxK) {\n            quitf(_ok, \"Correctly reported impossibility\");\n        } else {\n            quitf(_wa, \"Solution exists but participant reported -1\");\n        }\n    } else {\n        if (k > maxK) {\n            quitf(_wa, \"Participant provided solution but it's impossible for given k\");\n        }\n        if (m != n * k) {\n            quitf(_wa, \"Incorrect number of matches: expected %d, found %d\", n * k, m);\n        }\n        set<pair<int, int>> matches;\n        vector<int> wins(n + 1, 0);\n\n        for (int i = 0; i < m; i++) {\n            int a = ouf.readInt(1, n, format(\"a[%d]\", i + 1).c_str());\n            int b = ouf.readInt(1, n, format(\"b[%d]\", i + 1).c_str());\n            if (a == b) {\n                quitf(_wa, \"Match %d: team cannot play against itself\", i + 1);\n            }\n            if (matches.count({a, b}) || matches.count({b, a})) {\n                quitf(_wa, \"Match %d: teams %d and %d have already played\", i + 1, a, b);\n            }\n            matches.insert({a, b});\n            wins[a]++;\n        }\n\n        // Each team should have exactly k wins\n        for (int i = 1; i <= n; i++) {\n            if (wins[i] != k) {\n                quitf(_wa, \"Team %d has %d wins, expected %d\", i, wins[i], k);\n            }\n        }\n\n        quitf(_ok, \"Correct solution\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"valid\"); // default type is \"valid\"\n\n    if (type == \"valid\") {\n        // Ensure that k is between 0 and n-1 inclusive\n        ensuref(k >= 0 && k <= n - 1, \"Invalid parameters for valid test case: k must be between 0 and n-1 inclusive.\");\n\n        // Output n and k\n        printf(\"%d %d\\n\", n, k);\n    }\n    else if (type == \"invalid\") {\n        // Ensure that k is less than 0 or greater than n-1\n        ensuref(k < 0 || k > n - 1, \"Invalid parameters for invalid test case: k must be less than 0 or greater than n-1.\");\n\n        // Output n and k\n        printf(\"%d %d\\n\", n, k);\n    }\n    else {\n        // For any other types, you can add more code here\n        printf(\"%d %d\\n\", n, k);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"valid\"); // default type is \"valid\"\n\n    if (type == \"valid\") {\n        // Ensure that k is between 0 and n-1 inclusive\n        ensuref(k >= 0 && k <= n - 1, \"Invalid parameters for valid test case: k must be between 0 and n-1 inclusive.\");\n\n        // Output n and k\n        printf(\"%d %d\\n\", n, k);\n    }\n    else if (type == \"invalid\") {\n        // Ensure that k is less than 0 or greater than n-1\n        ensuref(k < 0 || k > n - 1, \"Invalid parameters for invalid test case: k must be less than 0 or greater than n-1.\");\n\n        // Output n and k\n        printf(\"%d %d\\n\", n, k);\n    }\n    else {\n        // For any other types, you can add more code here\n        printf(\"%d %d\\n\", n, k);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type valid\n./gen -n 1 -k 1 -type invalid\n\n./gen -n 2 -k 0 -type valid\n./gen -n 2 -k 1 -type valid\n./gen -n 2 -k 2 -type invalid\n\n./gen -n 3 -k 1 -type valid\n./gen -n 3 -k 2 -type valid\n./gen -n 3 -k 3 -type invalid\n\n./gen -n 4 -k 0 -type valid\n./gen -n 4 -k 2 -type valid\n./gen -n 4 -k 3 -type valid\n./gen -n 4 -k 4 -type invalid\n\n./gen -n 5 -k 0 -type valid\n./gen -n 5 -k 1 -type valid\n./gen -n 5 -k 4 -type valid\n./gen -n 5 -k 5 -type invalid\n\n./gen -n 10 -k 0 -type valid\n./gen -n 10 -k 5 -type valid\n./gen -n 10 -k 9 -type valid\n./gen -n 10 -k 10 -type invalid\n\n./gen -n 100 -k 0 -type valid\n./gen -n 100 -k 50 -type valid\n./gen -n 100 -k 99 -type valid\n./gen -n 100 -k 100 -type invalid\n\n./gen -n 500 -k 0 -type valid\n./gen -n 500 -k 250 -type valid\n./gen -n 500 -k 499 -type valid\n./gen -n 500 -k 500 -type invalid\n\n./gen -n 1000 -k 0 -type valid\n./gen -n 1000 -k 500 -type valid\n./gen -n 1000 -k 999 -type valid\n./gen -n 1000 -k 1000 -type invalid\n\n./gen -n 1 -k -1 -type invalid\n./gen -n 1 -k 1000 -type invalid\n\n./gen -n 1000 -k -1 -type invalid\n./gen -n 1000 -k 1001 -type invalid\n\n./gen -n 500 -k -1 -type invalid\n./gen -n 500 -k 501 -type invalid\n\n# Random valid cases\n./gen -n 123 -k 45 -type valid\n./gen -n 789 -k 456 -type valid\n./gen -n 987 -k 654 -type valid\n./gen -n 654 -k 321 -type valid\n\n# Random invalid cases\n./gen -n 123 -k 124 -type invalid\n./gen -n 789 -k 790 -type invalid\n./gen -n 987 -k 988 -type invalid\n./gen -n 654 -k 655 -type invalid\n\n# Edge cases\n./gen -n 1 -k 0 -type valid\n./gen -n 1 -k 1 -type invalid\n./gen -n 2 -k -1 -type invalid\n./gen -n 2 -k 2 -type invalid\n\n# Zero k valid cases\n./gen -n 50 -k 0 -type valid\n./gen -n 100 -k 0 -type valid\n./gen -n 500 -k 0 -type valid\n./gen -n 1000 -k 0 -type valid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:01.735628",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "417/D",
      "title": "D. Cunning Gena",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and b (1 ≤ n ≤ 100; 1 ≤ m ≤ 20; 1 ≤ b ≤ 109) — the number of Gena's friends, the number of problems and the cost of a single monitor.The following 2n lines describe the friends. Lines number 2i and (2i + 1) contain the information about the i-th friend. The 2i-th line contains three integers xi, ki and mi (1 ≤ xi ≤ 109; 1 ≤ ki ≤ 109; 1 ≤ mi ≤ m) — the desired amount of money, monitors and the number of problems the friend can solve. The (2i + 1)-th line contains mi distinct positive integers — the numbers of problems that the i-th friend can solve. The problems are numbered from 1 to m.",
      "output_spec": "OutputPrint the minimum amount of money Gena needs to spend to solve all the problems. Or print -1, if this cannot be achieved.",
      "sample_tests": "ExamplesInputCopy2 2 1100 1 12100 2 11OutputCopy202InputCopy3 2 5100 1 11100 1 12200 1 21 2OutputCopy205InputCopy1 2 11 1 11OutputCopy-1",
      "description": "D. Cunning Gena\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and b (1 ≤ n ≤ 100; 1 ≤ m ≤ 20; 1 ≤ b ≤ 109) — the number of Gena's friends, the number of problems and the cost of a single monitor.The following 2n lines describe the friends. Lines number 2i and (2i + 1) contain the information about the i-th friend. The 2i-th line contains three integers xi, ki and mi (1 ≤ xi ≤ 109; 1 ≤ ki ≤ 109; 1 ≤ mi ≤ m) — the desired amount of money, monitors and the number of problems the friend can solve. The (2i + 1)-th line contains mi distinct positive integers — the numbers of problems that the i-th friend can solve. The problems are numbered from 1 to m.\n\nOutputPrint the minimum amount of money Gena needs to spend to solve all the problems. Or print -1, if this cannot be achieved.\n\nInputCopy2 2 1100 1 12100 2 11OutputCopy202InputCopy3 2 5100 1 11100 1 12200 1 21 2OutputCopy205InputCopy1 2 11 1 11OutputCopy-1\n\nInputCopy2 2 1100 1 12100 2 11\n\nOutputCopy202\n\nInputCopy3 2 5100 1 11100 1 12200 1 21 2\n\nOutputCopy205\n\nInputCopy1 2 11 1 11\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Russian Code Cup is a competition organized by Mail.Ru Group for Russian-speaking programmers. This year the competition will run for the fourth time to gather top 50 to great finals in Moscow in October.Though Russian Code Cup is open only for those who speak Russian, the team that is working on problems for Russian Code Cup has decided to make a present to all CodeForces users and set up an extra round for everyone.The round will be held on April 17 at 19-30 Moscow time. The round will be open for everyone and will have both div-1 and div-2 tasks. It will use standard CodeForces rules. The writer of most problems is Aksenov239 — author of many Russian Code Cup problems.We wish all participants good luck and see you on Thursday at http://codeforces.comUPD: Score for problems: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Good luck!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 860
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "I want to say thanks to whom can help me to make this round: for testing pashka and cerealguy, for problems chavit and enot110 and andrewzta for supervising.417A - Elimination. Author and realization Aksenov239.The first thing, that you need to mention, is that if k ≤ n·m, then the answer is equal to 0. After that you need to take at least n·m - k people. There's three possibilities to do that: To consider only main rounds: . To take additional rounds to the number, which is divisible by n: . To take only rounds of the second type: d(n·m - k). Also in this problem it is possible to write the solution, which check every possible combinations of the numbers of main and elimination rounds.Solution: 6396283417B - Crash. Author and realization Aksenov239.Let us create array a with 105 elements, which is filled with  - 1. In the cell a[k] we will contain the maximal number of the submissions of the participant with identifier k. We will process submissions in the given order. Let us process submission x k. If a[k] < x - 1, then the answer is NO, else we will update array a: a[k] = max(a[k], x).Solution: 6396297418A - Football. Author and realization Aksenov239.Let's consider this tournir as graph. Each vertex should have out-degree k. Then the graph should contain exactly nk edges. But the full-graph contains , because of that if n < 2k + 1 then the answer is  - 1, otherwise we will connect the i-th vertex with i + 1, ..., i + k, taking modulo n if needed.Solution: 6396331418B - Cunning Gena. Author and realization Aksenov239.Let us sort the friends by the number of the monitors in the increasing order. Afterwards we will calculate the dp on the masks: the minimal amount of money Gena should spend to solve some subset of problems, if we take first n friends. Then the answer we should compare with the answer for first i friends plus the number of the monitors, which the i-th friend needs. Is is not hard to see, that if we consider the friends in this order consequently, then we can recalc dp like in the knapsack problem. The running time of this algorithm is O(nlog(n) + n2m).Solution pashka: 6396347418C - Square Table. Author and realization Aksenov239.Let's build array of the length n for each n, that the sum of the squares of its elements is the square: If n = 1, then take [1]. If n = 2, then take [3, 4]. If n is even, then take . If n is odd, then take . We are given two numbers n and m. Let array a corresponds to n, and array b corresponds to m. The we will build the answer array c as follows cij = ai·bj.Solution: 6396358418D - Big Problems for Organizers. Author chavit, realization Aksenov239.This problem has two solutions.The first one. Let's hang the tree on some vertex. Afterwards, let us calculate for eah vertex it's height and 3 most distant vertices in its subtree. Also let's calculate arrays for the lowest common ancestors problem. For each vertex i and the power of two 2j we have p[i][j], up[i][j] and down[i][j]: p[i][j] is the ancestor on the distance of 2j, up[i][j] is equal to the longest path from i to the vertices, which are situated in subtrees of the vertices on the path between i and p[i][j]. down[i][j] is equal the same, but from the vertex p[i][j]. And the last part of this solution. Let us be given the query u v. Firstly, we find w = LCA(u, v). Afterwards, we need to find vertex hu, which is situated on the middle of the path between u and v. Really, we need to split the tree by this vertex, count the longest path from u in its tree and count the longest path from v in its tree. If we can imagine in the main tree, we can not delete this vertex, but with our precalculated arrays recalc this two values.First solution: 6396376The second solution. In a few words. Let's find the diameter of the tree. Precalc the answer for each vertices on the prefix. Then on the query we find two distant vertices on this diameter and the path. Obviously, diameter should contain the middle of the path, when we find it, using precalculated results on the prefixes and suffixes we can obtain the answer.Second solution cerealguy: 6396390418E - Tricky Password. Authors enot110, Aksenov239, realization Aksenov239.The key theoretical idea of this problem is that the $2$nd row is exactly the same as the $4$th row, $3$rd row is exactly the same as $5$th row and so on. Because of that we need only to answer queries on the first three rows.Let's move on to the practical part. In the first place we will compress coordinates, that any value will not exceed 2·105. Afterwards, let's split the array into parts of the length LEN. On each part we will calculate the following values: cnt[k] — the number of occurences of the number k on this prefix, also f[k] — the total number of the values, which occur exactly k times on this prefix. Array f we will store in the Fenwick data structure.It is not hard to see, that array cnt contains the answer for the queries to the 2nd row. To get the answer for the queries to the 3rd row we need to calculate f[cnt[k]... 105]. Also it's quite understandable how to recalc this dp.In summary, we will get per query. And we take , then we will get per query. Solution: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 417 和字母"
          },
          "content_length": 5178
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readSpace();\n        int mi = inf.readInt(1, m, \"mi\");\n        inf.readEoln();\n\n        vector<int> probs = inf.readInts(mi, 1, m, \"problems\");\n        inf.readEoln();\n\n        set<int> s(probs.begin(), probs.end());\n        ensuref((int)s.size() == mi, \"Problem numbers for friend %d are not distinct\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readSpace();\n        int mi = inf.readInt(1, m, \"mi\");\n        inf.readEoln();\n\n        vector<int> probs = inf.readInts(mi, 1, m, \"problems\");\n        inf.readEoln();\n\n        set<int> s(probs.begin(), probs.end());\n        ensuref((int)s.size() == mi, \"Problem numbers for friend %d are not distinct\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readSpace();\n        int mi = inf.readInt(1, m, \"mi\");\n        inf.readEoln();\n\n        vector<int> probs = inf.readInts(mi, 1, m, \"problems\");\n        inf.readEoln();\n\n        set<int> s(probs.begin(), probs.end());\n        ensuref((int)s.size() == mi, \"Problem numbers for friend %d are not distinct\", i+1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> ki(n);\n    vector<vector<int>> problems(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"impossible\") {\n        /* Ensure that at least one problem cannot be solved by any friend */\n        if (m <= 1) {\n            fprintf(stderr, \"Cannot create impossible test case with m <= 1\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(0, m - 1);\n            vector<int> probs;\n            for(int j = 1; j <= m - 1; ++j)\n                probs.push_back(j);\n            shuffle(probs.begin(), probs.end());\n            if (mi > 0) {\n                probs.resize(mi);\n                sort(probs.begin(), probs.end());\n                problems[i] = probs;\n            } else {\n                problems[i] = vector<int>();\n            }\n        }\n    } else if (type == \"max_monitors\") {\n        /* Friends require maximum number of monitors */\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1000000000 - 1000, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"min_monitors\") {\n        /* Friends require minimum number of monitors */\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 5);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"expensive_friends\") {\n        /* Need at least 2 friends for this type */\n        if (n < 2) {\n            fprintf(stderr, \"Need at least 2 friends for expensive_friends type\\n\");\n            return 1;\n        }\n        /* Friend 1: cheap but cannot solve all problems */\n        xi[0] = rnd.next(1, 1000);\n        ki[0] = rnd.next(1, 5);\n        int mi1 = m - 1;\n        vector<int> probs1;\n        for(int j = 1; j <= m - 1; ++j)\n            probs1.push_back(j);\n        shuffle(probs1.begin(), probs1.end());\n        probs1.resize(mi1);\n        sort(probs1.begin(), probs1.end());\n        problems[0] = probs1;\n        /* Friend 2: expensive but can solve the last problem */\n        xi[1] = rnd.next(999999000, 1000000000);\n        ki[1] = rnd.next(1, 5);\n        problems[1] = vector<int>{m};\n        /* Other friends: random */\n        for(int i = 2; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"edge_n_min\") {\n        /* n is minimal */\n        n = 1;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        xi[0] = rnd.next(1, 1000000000);\n        ki[0] = rnd.next(1, 1000000000);\n        int mi = rnd.next(1, m);\n        vector<int> probs(m);\n        for(int j = 0; j < m; ++j) probs[j] = j + 1;\n        shuffle(probs.begin(), probs.end());\n        probs.resize(mi);\n        sort(probs.begin(), probs.end());\n        problems[0] = probs;\n    } else if (type == \"edge_n_max\") {\n        /* n is maximal */\n        n = 100;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"edge_m_min\") {\n        /* m is minimal */\n        m = 1;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            problems[i] = vector<int>{1};\n        }\n    } else if (type == \"edge_m_max\") {\n        /* m is maximal */\n        m = 20;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Output the test case */\n    printf(\"%d %d %d\\n\", n, m, b);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], ki[i], (int)problems[i].size());\n        for(int j = 0; j < problems[i].size(); ++j) {\n            printf(\"%d%c\", problems[i][j], j + 1 == problems[i].size() ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> ki(n);\n    vector<vector<int>> problems(n);\n\n    if (type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"impossible\") {\n        /* Ensure that at least one problem cannot be solved by any friend */\n        if (m <= 1) {\n            fprintf(stderr, \"Cannot create impossible test case with m <= 1\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(0, m - 1);\n            vector<int> probs;\n            for(int j = 1; j <= m - 1; ++j)\n                probs.push_back(j);\n            shuffle(probs.begin(), probs.end());\n            if (mi > 0) {\n                probs.resize(mi);\n                sort(probs.begin(), probs.end());\n                problems[i] = probs;\n            } else {\n                problems[i] = vector<int>();\n            }\n        }\n    } else if (type == \"max_monitors\") {\n        /* Friends require maximum number of monitors */\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1000000000 - 1000, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"min_monitors\") {\n        /* Friends require minimum number of monitors */\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 5);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"expensive_friends\") {\n        /* Need at least 2 friends for this type */\n        if (n < 2) {\n            fprintf(stderr, \"Need at least 2 friends for expensive_friends type\\n\");\n            return 1;\n        }\n        /* Friend 1: cheap but cannot solve all problems */\n        xi[0] = rnd.next(1, 1000);\n        ki[0] = rnd.next(1, 5);\n        int mi1 = m - 1;\n        vector<int> probs1;\n        for(int j = 1; j <= m - 1; ++j)\n            probs1.push_back(j);\n        shuffle(probs1.begin(), probs1.end());\n        probs1.resize(mi1);\n        sort(probs1.begin(), probs1.end());\n        problems[0] = probs1;\n        /* Friend 2: expensive but can solve the last problem */\n        xi[1] = rnd.next(999999000, 1000000000);\n        ki[1] = rnd.next(1, 5);\n        problems[1] = vector<int>{m};\n        /* Other friends: random */\n        for(int i = 2; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"edge_n_min\") {\n        /* n is minimal */\n        n = 1;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        xi[0] = rnd.next(1, 1000000000);\n        ki[0] = rnd.next(1, 1000000000);\n        int mi = rnd.next(1, m);\n        vector<int> probs(m);\n        for(int j = 0; j < m; ++j) probs[j] = j + 1;\n        shuffle(probs.begin(), probs.end());\n        probs.resize(mi);\n        sort(probs.begin(), probs.end());\n        problems[0] = probs;\n    } else if (type == \"edge_n_max\") {\n        /* n is maximal */\n        n = 100;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else if (type == \"edge_m_min\") {\n        /* m is minimal */\n        m = 1;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            problems[i] = vector<int>{1};\n        }\n    } else if (type == \"edge_m_max\") {\n        /* m is maximal */\n        m = 20;\n        xi.resize(n); ki.resize(n); problems.resize(n);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j) probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            sort(probs.begin(), probs.end());\n            problems[i] = probs;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    /* Output the test case */\n    printf(\"%d %d %d\\n\", n, m, b);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], ki[i], (int)problems[i].size());\n        for(int j = 0; j < problems[i].size(); ++j) {\n            printf(\"%d%c\", problems[i][j], j + 1 == problems[i].size() ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -b 1 -type edge_n_min\n./gen -n 100 -m 5 -b 1000000000 -type edge_n_max\n./gen -n 5 -m 1 -b 100 -type edge_m_min\n./gen -n 5 -m 20 -b 100 -type edge_m_max\n./gen -n 10 -m 10 -b 1000 -type random\n./gen -n 10 -m 10 -b 500000000 -type random\n./gen -n 50 -m 15 -b 10 -type random\n./gen -n 100 -m 20 -b 1000000000 -type random\n./gen -n 3 -m 2 -b 5 -type impossible\n./gen -n 5 -m 5 -b 100 -type impossible\n./gen -n 10 -m 10 -b 100 -type impossible\n./gen -n 2 -m 5 -b 1000 -type expensive_friends\n./gen -n 3 -m 5 -b 10 -type expensive_friends\n./gen -n 5 -m 6 -b 100 -type expensive_friends\n./gen -n 10 -m 10 -b 1000 -type max_monitors\n./gen -n 10 -m 10 -b 1000 -type min_monitors\n./gen -n 20 -m 15 -b 500 -type max_monitors\n./gen -n 20 -m 15 -b 500 -type min_monitors\n./gen -n 1 -m 1 -b 1 -type random\n./gen -n 1 -m 2 -b 100 -type random\n./gen -n 100 -m 15 -b 1000 -type random\n./gen -n 100 -m 20 -b 1000000000 -type random\n./gen -n 100 -m 20 -b 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:04.024818",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "417/E",
      "title": "E. Квадратная таблица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны два целых числа n и m (1 ≤ n, m ≤ 100) — размеры таблицы.",
      "output_spec": "Выходные данныеВыведите таблицу, удовлетворяющую условию: n строк по m целых чисел, разделенных пробелами. Если существует несколько правильных ответов, разрешается вывести любой. Гарантируется, что хотя бы один ответ на задачу существует.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать1 2Выходные данныеСкопировать3 4",
      "description": "E. Квадратная таблица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке даны два целых числа n и m (1 ≤ n, m ≤ 100) — размеры таблицы.\n\nВходные данные\n\nВыходные данныеВыведите таблицу, удовлетворяющую условию: n строк по m целых чисел, разделенных пробелами. Если существует несколько правильных ответов, разрешается вывести любой. Гарантируется, что хотя бы один ответ на задачу существует.\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать1 2Выходные данныеСкопировать3 4\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Очередной сезон крупнейшей российской олимпиады Russian Code Cup стартует в субботу. Впереди новые интересные и нетривиальные задания, бескомпромиссная борьба и самые крутые призы.Но мы подготовили вам еще один сюрприз: 17 апреля у каждого из вас есть возможность оценить свои силы. В 19:30 по московскому времени на площадке http://codeforces.ru состоится тренировочный раунд олимпиады со свежей порцией задач от создателей RCC.RCC 2014 Warmup – это тест, который даст возможность попробовать свои силы и понять, к чему готовиться в раундах чемпионата. А для «бывалых» участников это идеальная возможность потренироваться и разогреться перед первыми сражениями RCC 2014!Автором большинства задач этого раунда является Aksenov239 — постоянный автор задач RCC. Конечно же ему помогали и другие члены жюри RCC-2014. Раунд пройдет как в div-1, так и в div-2, так что все найдут себе задачи по силам.Ждем вас в четверг в 19:30 на площадке http://codeforces.ruUPD: Итак, разбалловка раунда: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Всем удачи!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1059
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "417A - Отбор. Автор и реализация Aksenov239.Сначала нужно заметить, что если k больше либо равно, чем n·m, то ответ — 0. Нам осталось набрать n·m - k человек. Есть три способа их набрать: Взять раунды только первого типа: . Взять чуть раундов второго типа до числа, делящегося на n: . Взять только раунды второго типа: d(n·m - k). Также в данной задаче можно было написать переборное решение — сколько мы берём раундов первого типа, и сколько раундов второго.Код: 6396283417B - Сбой. Автор и реализация Aksenov239.Заведём массив a на 105 элементов, изначально заполненный  - 1, и в ячейке с номером k будем хранить максимальный номер посылки k-го участника, который сейчас есть. Будем обрабатывать посылки последовательно. Пусть обрабатывается посылка x k. Если a[k] < x - 1, то очевидно, что ответ NO, иначе обновляем массив — a[k] = max(a[k], x).Код: 6396297418A - Футбол. Автор и реализация Aksenov239.Представим турнир себе как граф. Из каждой вершины ровно k выходящих рёбер. Тогда всего nk рёбер. В полном графе максимум рёбер, поэтому если n < 2k + 1, тогда ответ  - 1. Иначе, соединим i-ую вершину с i + 1, ..., i + k, зациклим если нужно.Код: 6396331418B - Хитрый Гена. Автор и реализация Aksenov239.Давайте отсортируем друзей по возрастанию требуемого количества мониторов. Будем считать динамику на масках — какое минимальное число денег нужно заплатить, чтобы решить такие-то задачи, если мы взяли первых i друзей. Тогда ответ надо сравнить с ответом для i первых друзей плюс количество мониторов, которое требует i-ый друг. Не трудно заметить, что если брать друзей последовательно, то пересчитывать динамику можно как рюкзак. Время работы данного алгоритма O(nlog(n) + n2m).Код pashka: 6396347418C - Квадратная таблица. Автор и реализация Aksenov239.Давайте для любого n построим массив длины n, что сумма квадратов чисел на нём является квадратом: Если n = 1, то берём [1]. Если n = 2, то берём [3, 4]. Если n чётно, то берём . Если n нечётно, то берём . Нам дано 2 числа n и m. Пусть массив a соответствует числу n, а b соответствует числу m.Тогда итоговый массив c построим следующим способом — cij = ai·bj.Код: 6396358418D - Большие проблемы организаторов. Автор chavit, реализация Aksenov239.В данной задаче есть два решения.Первое. Подвесим за какую-нибудь вершину. Предподсчитаем для каждой, 3 самые удалённые вершины в её поддереве, а также для каждой вершины её глубину. Также предподсчитаем массивы для двоичного подъёма. Для каждой вершины i и степени двойки 2j предподсчитаем следующие массивы — p[i][j], up[i][j] и down[i][j]. p[i][j] — это предок вершины i на расстоянии 2j. В up[i][j] будет храниться наидлиннейший путь из i, до вершин, которые находятся в поддереве вершин, которые находятся на пути между i и p[i][j]. down[i][j] отличается от up[i][j], что хранит путь из вершины p[i][j].Теперь осталось дело за малым. Нам приходит запрос u v, мы ищем его наименьшего общего предка — w. Осталось найти вершину hu, которая будет находиться на середине это пути. Обрезать дерево по этой вершине, и посчитать длиннейшее расстояние от вершины u в её дереве и длиннейшее расстояние от вершины v в её дереве. Представляя на дереве это, если мы не будем удалять, то можно воспользовавшись нашими предподсчитанными массивами аккуратно пересчитать значение длиннейшего пути.Решение за O(nlog(n)).Код: 6396376Второе. Вкратце. Найдём диаметр этого дерева. Предподсчитаем там ответ на префиксе для каждой вершины. Тогда при ответе на запрос — мы находим, когда путь вливается диаметр. На это отрезке находим среднюю вершину, а далее отвечаем на запрос на префиксе или суффиксе.Код cerealguy: 6396390418E - Хитрый пароль. Авторы enot110, Aksenov239, реализация Aksenov239Ключевая теоретическая идея данной задачи заключается в том, что 2 строка совпадает с 4, 3 с 5 и т. д. Поэтому нам нужно уметь менять что-то только на первых трёх строках.Теперь дело остаётся за практической частью. В первую очередь сожмём все значения, чтобы они не превосходили 105. Разобьём массив на отрезки длиной LEN. На каждом отрезке будем считать следующее — для каждого значения будем хранить сколько раз он встречался на префиксе cnt, а так же дерево Фенвика, в котором в ячейке f[k] будет храниться количество чисел на данном префиксе, встречающихся ровно k раз. Несложно заметить, что в первом массиве хранится ответ на запросы ко второй строке, а чтобы получить ответ для третьей строки, нужно посчитать f[cnt[k]... 105]. Понятно так же, как делать пересчёт данной динамики.Итого, получаем время на запрос за . Если мы возьмём , то время ответа на запрос составит .Код: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 417 和字母"
          },
          "content_length": 4580
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 13",
          "code": "static base a[100005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 14",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 15",
          "code": "printf(\"%d \", j+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 16",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 17",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 18",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 1",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 2",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(long long x) {\n    if (x < 0) return false;\n    long long s = (long long)(sqrt((double)x) + 0.5);\n    return s * s == x;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 100);\n    int m = inf.readInt(1, 100);\n    vector<vector<int>> table(n, vector<int>(m));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            table[i][j] = ouf.readInt(1, 100000000, format(\"table[%d][%d]\", i+1, j+1).c_str());\n        }\n    }\n    vector<long long> rowSums(n, 0);\n    vector<long long> colSums(m, 0);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int x = table[i][j];\n            long long sq = (long long)x * x;\n            rowSums[i] += sq;\n            colSums[j] += sq;\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        if (!isPerfectSquare(rowSums[i])) {\n            quitf(_wa, \"sum of squares in row %d is not a perfect square\", i+1);\n        }\n    }\n    for (int j = 0; j < m; ++j) {\n        if (!isPerfectSquare(colSums[j])) {\n            quitf(_wa, \"sum of squares in column %d is not a perfect square\", j+1);\n        }\n    }\n    quitf(_ok, \"Correct table\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_n = opt<int>(\"max_n\", 100);\n    int max_m = opt<int>(\"max_m\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, m;\n\n    if (type == \"min\") {\n        // Minimum values for n and m\n        n = 1;\n        m = 1;\n    } else if (type == \"max\") {\n        // Maximum values for n and m\n        n = max_n;\n        m = max_m;\n    } else if (type == \"square\") {\n        // Generate n and m as perfect squares less than or equal to max_n and max_m\n        vector<int> squares;\n        for (int i = 1; i * i <= max(max_n, max_m); ++i) {\n            squares.push_back(i * i);\n        }\n        n = squares[rnd.next(0, (int)squares.size() - 1)];\n        m = squares[rnd.next(0, (int)squares.size() - 1)];\n        n = min(n, max_n);\n        m = min(m, max_m);\n    } else if (type == \"prime\") {\n        // Generate n and m as prime numbers less than or equal to max_n and max_m\n        vector<int> primes;\n        vector<bool> is_prime(max(max_n, max_m) + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= max(max_n, max_m); ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j <= max(max_n, max_m); j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n        m = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"ones\") {\n        // Generate n and m that are not perfect squares\n        vector<int> non_squares_n, non_squares_m;\n        vector<bool> is_square(max(max_n, max_m) + 1, false);\n        for (int i = 1; i * i <= max(max_n, max_m); ++i) {\n            is_square[i * i] = true;\n        }\n        for (int i = 1; i <= max_n; ++i) {\n            if (!is_square[i]) non_squares_n.push_back(i);\n        }\n        for (int i = 1; i <= max_m; ++i) {\n            if (!is_square[i]) non_squares_m.push_back(i);\n        }\n        n = non_squares_n[rnd.next(0, (int)non_squares_n.size() - 1)];\n        m = non_squares_m[rnd.next(0, (int)non_squares_m.size() - 1)];\n    } else if (type == \"special\") {\n        // Special test cases\n        vector<pair<int, int>> special_cases = {\n            {50, 50},\n            {99, 100},\n            {100, 1},\n            {1, 100},\n            {97, 97},\n            {2, 2},\n            {3, 5}\n        };\n        int idx = rnd.next(0, (int)special_cases.size() - 1);\n        n = special_cases[idx].first;\n        m = special_cases[idx].second;\n    } else { // random\n        // Random n and m within the given bounds\n        n = rnd.next(1, max_n);\n        m = rnd.next(1, max_m);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_n = opt<int>(\"max_n\", 100);\n    int max_m = opt<int>(\"max_m\", 100);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, m;\n\n    if (type == \"min\") {\n        // Minimum values for n and m\n        n = 1;\n        m = 1;\n    } else if (type == \"max\") {\n        // Maximum values for n and m\n        n = max_n;\n        m = max_m;\n    } else if (type == \"square\") {\n        // Generate n and m as perfect squares less than or equal to max_n and max_m\n        vector<int> squares;\n        for (int i = 1; i * i <= max(max_n, max_m); ++i) {\n            squares.push_back(i * i);\n        }\n        n = squares[rnd.next(0, (int)squares.size() - 1)];\n        m = squares[rnd.next(0, (int)squares.size() - 1)];\n        n = min(n, max_n);\n        m = min(m, max_m);\n    } else if (type == \"prime\") {\n        // Generate n and m as prime numbers less than or equal to max_n and max_m\n        vector<int> primes;\n        vector<bool> is_prime(max(max_n, max_m) + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i <= max(max_n, max_m); ++i) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n                for (int j = i * 2; j <= max(max_n, max_m); j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        n = primes[rnd.next(0, (int)primes.size() - 1)];\n        m = primes[rnd.next(0, (int)primes.size() - 1)];\n    } else if (type == \"ones\") {\n        // Generate n and m that are not perfect squares\n        vector<int> non_squares_n, non_squares_m;\n        vector<bool> is_square(max(max_n, max_m) + 1, false);\n        for (int i = 1; i * i <= max(max_n, max_m); ++i) {\n            is_square[i * i] = true;\n        }\n        for (int i = 1; i <= max_n; ++i) {\n            if (!is_square[i]) non_squares_n.push_back(i);\n        }\n        for (int i = 1; i <= max_m; ++i) {\n            if (!is_square[i]) non_squares_m.push_back(i);\n        }\n        n = non_squares_n[rnd.next(0, (int)non_squares_n.size() - 1)];\n        m = non_squares_m[rnd.next(0, (int)non_squares_m.size() - 1)];\n    } else if (type == \"special\") {\n        // Special test cases\n        vector<pair<int, int>> special_cases = {\n            {50, 50},\n            {99, 100},\n            {100, 1},\n            {1, 100},\n            {97, 97},\n            {2, 2},\n            {3, 5}\n        };\n        int idx = rnd.next(0, (int)special_cases.size() - 1);\n        n = special_cases[idx].first;\n        m = special_cases[idx].second;\n    } else { // random\n        // Random n and m within the given bounds\n        n = rnd.next(1, max_n);\n        m = rnd.next(1, max_m);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -max_n 1 -max_m 1 -type min\n./gen -max_n 100 -max_m 100 -type max\n./gen -max_n 100 -max_m 100 -type square\n./gen -max_n 100 -max_m 100 -type square\n./gen -max_n 100 -max_m 100 -type square\n./gen -max_n 100 -max_m 100 -type prime\n./gen -max_n 100 -max_m 100 -type prime\n./gen -max_n 100 -max_m 100 -type prime\n./gen -max_n 100 -max_m 100 -type ones\n./gen -max_n 100 -max_m 100 -type ones\n./gen -max_n 100 -max_m 100 -type ones\n./gen -max_n 100 -max_m 100 -type special\n./gen -max_n 100 -max_m 100 -type special\n./gen -max_n 100 -max_m 100 -type special\n./gen -max_n 100 -max_m 1 -type random\n./gen -max_n 1 -max_m 100 -type random\n./gen -max_n 2 -max_m 100 -type random\n./gen -max_n 100 -max_m 2 -type random\n./gen -max_n 50 -max_m 50 -type random\n./gen -max_n 75 -max_m 60 -type random\n./gen -max_n 100 -max_m 100 -type random\n./gen -max_n 100 -max_m 100 -type random\n./gen -max_n 15 -max_m 15 -type square\n./gen -max_n 15 -max_m 15 -type ones\n./gen -max_n 15 -max_m 15 -type prime\n./gen -max_n 99 -max_m 99 -type special\n./gen -max_n 97 -max_m 97 -type special\n./gen -max_n 100 -max_m 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:06.035189",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "418/A",
      "title": "A. Футбол",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано два целых числа — n и k (1 ≤ n, k ≤ 1000).",
      "output_spec": "Выходные данныеВ первой строке выведите целое число m — количество сыгранных матчей. В следующих m строках должна содержаться информация обо всех матчах, по матчу в строке. В i-й строке выведите два целых числа ai bi (1 ≤ ai, bi ≤ n; ai ≠ bi). Числа ai, bi обозначают, что в i-м матче команда с номером ai победила команду с номером bi. Считайте, что команды пронумерованы от 1 до n.Если не существует турнира, удовлетворяющего условию задачи, выведите -1.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1Выходные данныеСкопировать31 22 33 1",
      "description": "ограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке задано два целых числа — n и k (1 ≤ n, k ≤ 1000).\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число m — количество сыгранных матчей. В следующих m строках должна содержаться информация обо всех матчах, по матчу в строке. В i-й строке выведите два целых числа ai bi (1 ≤ ai, bi ≤ n; ai ≠ bi). Числа ai, bi обозначают, что в i-м матче команда с номером ai победила команду с номером bi. Считайте, что команды пронумерованы от 1 до n.Если не существует турнира, удовлетворяющего условию задачи, выведите -1.\n\nВыходные данные\n\nВходные данныеСкопировать3 1Выходные данныеСкопировать31 22 33 1\n\nВходные данныеСкопировать3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 22 33 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Очередной сезон крупнейшей российской олимпиады Russian Code Cup стартует в субботу. Впереди новые интересные и нетривиальные задания, бескомпромиссная борьба и самые крутые призы.Но мы подготовили вам еще один сюрприз: 17 апреля у каждого из вас есть возможность оценить свои силы. В 19:30 по московскому времени на площадке http://codeforces.ru состоится тренировочный раунд олимпиады со свежей порцией задач от создателей RCC.RCC 2014 Warmup – это тест, который даст возможность попробовать свои силы и понять, к чему готовиться в раундах чемпионата. А для «бывалых» участников это идеальная возможность потренироваться и разогреться перед первыми сражениями RCC 2014!Автором большинства задач этого раунда является Aksenov239 — постоянный автор задач RCC. Конечно же ему помогали и другие члены жюри RCC-2014. Раунд пройдет как в div-1, так и в div-2, так что все найдут себе задачи по силам.Ждем вас в четверг в 19:30 на площадке http://codeforces.ruUPD: Итак, разбалловка раунда: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Всем удачи!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1059
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "417A - Отбор. Автор и реализация Aksenov239.Сначала нужно заметить, что если k больше либо равно, чем n·m, то ответ — 0. Нам осталось набрать n·m - k человек. Есть три способа их набрать: Взять раунды только первого типа: . Взять чуть раундов второго типа до числа, делящегося на n: . Взять только раунды второго типа: d(n·m - k). Также в данной задаче можно было написать переборное решение — сколько мы берём раундов первого типа, и сколько раундов второго.Код: 6396283417B - Сбой. Автор и реализация Aksenov239.Заведём массив a на 105 элементов, изначально заполненный  - 1, и в ячейке с номером k будем хранить максимальный номер посылки k-го участника, который сейчас есть. Будем обрабатывать посылки последовательно. Пусть обрабатывается посылка x k. Если a[k] < x - 1, то очевидно, что ответ NO, иначе обновляем массив — a[k] = max(a[k], x).Код: 6396297418A - Футбол. Автор и реализация Aksenov239.Представим турнир себе как граф. Из каждой вершины ровно k выходящих рёбер. Тогда всего nk рёбер. В полном графе максимум рёбер, поэтому если n < 2k + 1, тогда ответ  - 1. Иначе, соединим i-ую вершину с i + 1, ..., i + k, зациклим если нужно.Код: 6396331418B - Хитрый Гена. Автор и реализация Aksenov239.Давайте отсортируем друзей по возрастанию требуемого количества мониторов. Будем считать динамику на масках — какое минимальное число денег нужно заплатить, чтобы решить такие-то задачи, если мы взяли первых i друзей. Тогда ответ надо сравнить с ответом для i первых друзей плюс количество мониторов, которое требует i-ый друг. Не трудно заметить, что если брать друзей последовательно, то пересчитывать динамику можно как рюкзак. Время работы данного алгоритма O(nlog(n) + n2m).Код pashka: 6396347418C - Квадратная таблица. Автор и реализация Aksenov239.Давайте для любого n построим массив длины n, что сумма квадратов чисел на нём является квадратом: Если n = 1, то берём [1]. Если n = 2, то берём [3, 4]. Если n чётно, то берём . Если n нечётно, то берём . Нам дано 2 числа n и m. Пусть массив a соответствует числу n, а b соответствует числу m.Тогда итоговый массив c построим следующим способом — cij = ai·bj.Код: 6396358418D - Большие проблемы организаторов. Автор chavit, реализация Aksenov239.В данной задаче есть два решения.Первое. Подвесим за какую-нибудь вершину. Предподсчитаем для каждой, 3 самые удалённые вершины в её поддереве, а также для каждой вершины её глубину. Также предподсчитаем массивы для двоичного подъёма. Для каждой вершины i и степени двойки 2j предподсчитаем следующие массивы — p[i][j], up[i][j] и down[i][j]. p[i][j] — это предок вершины i на расстоянии 2j. В up[i][j] будет храниться наидлиннейший путь из i, до вершин, которые находятся в поддереве вершин, которые находятся на пути между i и p[i][j]. down[i][j] отличается от up[i][j], что хранит путь из вершины p[i][j].Теперь осталось дело за малым. Нам приходит запрос u v, мы ищем его наименьшего общего предка — w. Осталось найти вершину hu, которая будет находиться на середине это пути. Обрезать дерево по этой вершине, и посчитать длиннейшее расстояние от вершины u в её дереве и длиннейшее расстояние от вершины v в её дереве. Представляя на дереве это, если мы не будем удалять, то можно воспользовавшись нашими предподсчитанными массивами аккуратно пересчитать значение длиннейшего пути.Решение за O(nlog(n)).Код: 6396376Второе. Вкратце. Найдём диаметр этого дерева. Предподсчитаем там ответ на префиксе для каждой вершины. Тогда при ответе на запрос — мы находим, когда путь вливается диаметр. На это отрезке находим среднюю вершину, а далее отвечаем на запрос на префиксе или суффиксе.Код cerealguy: 6396390418E - Хитрый пароль. Авторы enot110, Aksenov239, реализация Aksenov239Ключевая теоретическая идея данной задачи заключается в том, что 2 строка совпадает с 4, 3 с 5 и т. д. Поэтому нам нужно уметь менять что-то только на первых трёх строках.Теперь дело остаётся за практической частью. В первую очередь сожмём все значения, чтобы они не превосходили 105. Разобьём массив на отрезки длиной LEN. На каждом отрезке будем считать следующее — для каждого значения будем хранить сколько раз он встречался на префиксе cnt, а так же дерево Фенвика, в котором в ячейке f[k] будет храниться количество чисел на данном префиксе, встречающихся ровно k раз. Несложно заметить, что в первом массиве хранится ответ на запросы ко второй строке, а чтобы получить ответ для третьей строки, нужно посчитать f[cnt[k]... 105]. Понятно так же, как делать пересчёт данной динамики.Итого, получаем время на запрос за . Если мы возьмём , то время ответа на запрос составит .Код: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 418\\s*A"
          },
          "content_length": 4580
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 13",
          "code": "static base a[100005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 14",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 15",
          "code": "printf(\"%d \", j+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 16",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 17",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 18",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 1",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 2",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000);\n    inf.readSpace();\n    int k = inf.readInt(1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000);\n    inf.readSpace();\n    int k = inf.readInt(1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000);\n    inf.readSpace();\n    int k = inf.readInt(1, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, k;\n\nint readAns(InStream& stream, int n, int k)\n{\n    int max_matches = n * (n - 1); // Max matches since ai != bi\n    int m = stream.readInt(-1, max_matches, \"m\");\n    if (m == -1)\n    {\n        return -1;\n    }\n    else if (m < -1)\n    {\n        stream.quitf(_wa, \"Invalid m: m = %d\", m);\n    }\n\n    set<pair<int, int>> matches; // To store played matches\n    vector<int> wins(n + 1, 0);  // Wins for each team\n\n    for (int i = 0; i < m; i++)\n    {\n        int ai = stream.readInt(1, n, \"ai\");\n        int bi = stream.readInt(1, n, \"bi\");\n\n        if (ai == bi)\n        {\n            stream.quitf(_wa, \"Match %d: team %d cannot play against itself\", i + 1, ai);\n        }\n        if (matches.count(make_pair(ai, bi)))\n        {\n            stream.quitf(_wa, \"Match %d: duplicate match between teams %d and %d\", i + 1, ai, bi);\n        }\n        if (matches.count(make_pair(bi, ai)))\n        {\n            // Since matches are one-way, this is acceptable\n        }\n        matches.insert(make_pair(ai, bi));\n        wins[ai]++;\n    }\n\n    for (int i = 1; i <= n; i++)\n    {\n        if (wins[i] != k)\n        {\n            stream.quitf(_wa, \"Team %d has %d wins, expected %d\", i, wins[i], k);\n        }\n    }\n    return 0; // Valid\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 1000);\n    k = inf.readInt(1, 1000);\n\n    int juryAns = readAns(ans, n, k);\n    int participantAns = readAns(ouf, n, k);\n\n    if (juryAns == -1)\n    {\n        if (participantAns == -1)\n        {\n            quitf(_ok, \"Correctly reported impossible\");\n        }\n        else\n        {\n            quitf(_fail, \"Participant found a solution but jury says impossible\");\n        }\n    }\n    else\n    {\n        if (participantAns == -1)\n        {\n            quitf(_wa, \"Participant reported impossible but solution exists\");\n        }\n        else\n        {\n            quitf(_ok, \"Valid solution\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Initialize the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters n and type\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    int k;\n\n    if (type == \"possible\") {\n        // For possible cases, we'll set k = (n - 1) / 2 if n is odd\n        if (n % 2 == 1) {\n            k = (n - 1) / 2;\n        } else {\n            // For even n, set k = n / 2 - 1 if n > 2\n            if (n > 2) {\n                k = n / 2 - 1;\n            } else {\n                // For n = 2, k = 0\n                k = 0;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // For impossible cases, set k such that n * k is odd, or k > n - 1\n        if (n % 2 == 0) {\n            k = n / 2; // n even, k such that n * k is even\n            if (n * k % 2 == 0) {\n                k++; // Make n * k odd\n                if (k > n - 1) {\n                    k = n - 1;\n                }\n            }\n        } else {\n            k = (n - 1) / 2;\n            k++; // Set k greater than (n - 1) / 2\n            if (k >= n) {\n                k = n - 1;\n            }\n            if (n * k % 2 == 0) {\n                k++; // Make n * k odd\n                if (k >= n) {\n                    k = n - 1;\n                }\n            }\n        }\n    } else {\n        // Random k within [1, n - 1]\n        k = rnd.next(1, n - 1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Initialize the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters n and type\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"possible\");\n\n    int k;\n\n    if (type == \"possible\") {\n        // For possible cases, we'll set k = (n - 1) / 2 if n is odd\n        if (n % 2 == 1) {\n            k = (n - 1) / 2;\n        } else {\n            // For even n, set k = n / 2 - 1 if n > 2\n            if (n > 2) {\n                k = n / 2 - 1;\n            } else {\n                // For n = 2, k = 0\n                k = 0;\n            }\n        }\n    } else if (type == \"impossible\") {\n        // For impossible cases, set k such that n * k is odd, or k > n - 1\n        if (n % 2 == 0) {\n            k = n / 2; // n even, k such that n * k is even\n            if (n * k % 2 == 0) {\n                k++; // Make n * k odd\n                if (k > n - 1) {\n                    k = n - 1;\n                }\n            }\n        } else {\n            k = (n - 1) / 2;\n            k++; // Set k greater than (n - 1) / 2\n            if (k >= n) {\n                k = n - 1;\n            }\n            if (n * k % 2 == 0) {\n                k++; // Make n * k odd\n                if (k >= n) {\n                    k = n - 1;\n                }\n            }\n        }\n    } else {\n        // Random k within [1, n - 1]\n        k = rnd.next(1, n - 1);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Possible cases with odd n\n./gen -n 3 -type possible\n./gen -n 5 -type possible\n./gen -n 7 -type possible\n./gen -n 9 -type possible\n./gen -n 11 -type possible\n./gen -n 99 -type possible\n./gen -n 101 -type possible\n./gen -n 999 -type possible\n\n# Possible cases with even n\n./gen -n 4 -type possible\n./gen -n 6 -type possible\n./gen -n 8 -type possible\n./gen -n 10 -type possible\n./gen -n 100 -type possible\n./gen -n 1000 -type possible\n\n# Impossible cases due to n * k being odd\n./gen -n 3 -type impossible\n./gen -n 5 -type impossible\n./gen -n 7 -type impossible\n./gen -n 9 -type impossible\n./gen -n 11 -type impossible\n./gen -n 99 -type impossible\n./gen -n 101 -type impossible\n./gen -n 999 -type impossible\n\n# Impossible cases due to k > n - 1\n./gen -n 2 -type impossible\n./gen -n 4 -type impossible\n./gen -n 100 -type impossible\n./gen -n 1000 -type impossible\n\n# Random cases\n./gen -n 10 -type random\n./gen -n 15 -type random\n./gen -n 20 -type random\n./gen -n 50 -type random\n./gen -n 100 -type random\n./gen -n 200 -type random\n./gen -n 500 -type random\n./gen -n 750 -type random\n./gen -n 1000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:08.432820",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "418/B",
      "title": "B. Cunning Gena",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and b (1 ≤ n ≤ 100; 1 ≤ m ≤ 20; 1 ≤ b ≤ 109) — the number of Gena's friends, the number of problems and the cost of a single monitor.The following 2n lines describe the friends. Lines number 2i and (2i + 1) contain the information about the i-th friend. The 2i-th line contains three integers xi, ki and mi (1 ≤ xi ≤ 109; 1 ≤ ki ≤ 109; 1 ≤ mi ≤ m) — the desired amount of money, monitors and the number of problems the friend can solve. The (2i + 1)-th line contains mi distinct positive integers — the numbers of problems that the i-th friend can solve. The problems are numbered from 1 to m.",
      "output_spec": "OutputPrint the minimum amount of money Gena needs to spend to solve all the problems. Or print -1, if this cannot be achieved.",
      "sample_tests": "ExamplesInputCopy2 2 1100 1 12100 2 11OutputCopy202InputCopy3 2 5100 1 11100 1 12200 1 21 2OutputCopy205InputCopy1 2 11 1 11OutputCopy-1",
      "description": "B. Cunning Gena\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and b (1 ≤ n ≤ 100; 1 ≤ m ≤ 20; 1 ≤ b ≤ 109) — the number of Gena's friends, the number of problems and the cost of a single monitor.The following 2n lines describe the friends. Lines number 2i and (2i + 1) contain the information about the i-th friend. The 2i-th line contains three integers xi, ki and mi (1 ≤ xi ≤ 109; 1 ≤ ki ≤ 109; 1 ≤ mi ≤ m) — the desired amount of money, monitors and the number of problems the friend can solve. The (2i + 1)-th line contains mi distinct positive integers — the numbers of problems that the i-th friend can solve. The problems are numbered from 1 to m.\n\nOutputPrint the minimum amount of money Gena needs to spend to solve all the problems. Or print -1, if this cannot be achieved.\n\nInputCopy2 2 1100 1 12100 2 11OutputCopy202InputCopy3 2 5100 1 11100 1 12200 1 21 2OutputCopy205InputCopy1 2 11 1 11OutputCopy-1\n\nInputCopy2 2 1100 1 12100 2 11\n\nOutputCopy202\n\nInputCopy3 2 5100 1 11100 1 12200 1 21 2\n\nOutputCopy205\n\nInputCopy1 2 11 1 11\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Russian Code Cup is a competition organized by Mail.Ru Group for Russian-speaking programmers. This year the competition will run for the fourth time to gather top 50 to great finals in Moscow in October.Though Russian Code Cup is open only for those who speak Russian, the team that is working on problems for Russian Code Cup has decided to make a present to all CodeForces users and set up an extra round for everyone.The round will be held on April 17 at 19-30 Moscow time. The round will be open for everyone and will have both div-1 and div-2 tasks. It will use standard CodeForces rules. The writer of most problems is Aksenov239 — author of many Russian Code Cup problems.We wish all participants good luck and see you on Thursday at http://codeforces.comUPD: Score for problems: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Good luck!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 860
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "I want to say thanks to whom can help me to make this round: for testing pashka and cerealguy, for problems chavit and enot110 and andrewzta for supervising.417A - Elimination. Author and realization Aksenov239.The first thing, that you need to mention, is that if k ≤ n·m, then the answer is equal to 0. After that you need to take at least n·m - k people. There's three possibilities to do that: To consider only main rounds: . To take additional rounds to the number, which is divisible by n: . To take only rounds of the second type: d(n·m - k). Also in this problem it is possible to write the solution, which check every possible combinations of the numbers of main and elimination rounds.Solution: 6396283417B - Crash. Author and realization Aksenov239.Let us create array a with 105 elements, which is filled with  - 1. In the cell a[k] we will contain the maximal number of the submissions of the participant with identifier k. We will process submissions in the given order. Let us process submission x k. If a[k] < x - 1, then the answer is NO, else we will update array a: a[k] = max(a[k], x).Solution: 6396297418A - Football. Author and realization Aksenov239.Let's consider this tournir as graph. Each vertex should have out-degree k. Then the graph should contain exactly nk edges. But the full-graph contains , because of that if n < 2k + 1 then the answer is  - 1, otherwise we will connect the i-th vertex with i + 1, ..., i + k, taking modulo n if needed.Solution: 6396331418B - Cunning Gena. Author and realization Aksenov239.Let us sort the friends by the number of the monitors in the increasing order. Afterwards we will calculate the dp on the masks: the minimal amount of money Gena should spend to solve some subset of problems, if we take first n friends. Then the answer we should compare with the answer for first i friends plus the number of the monitors, which the i-th friend needs. Is is not hard to see, that if we consider the friends in this order consequently, then we can recalc dp like in the knapsack problem. The running time of this algorithm is O(nlog(n) + n2m).Solution pashka: 6396347418C - Square Table. Author and realization Aksenov239.Let's build array of the length n for each n, that the sum of the squares of its elements is the square: If n = 1, then take [1]. If n = 2, then take [3, 4]. If n is even, then take . If n is odd, then take . We are given two numbers n and m. Let array a corresponds to n, and array b corresponds to m. The we will build the answer array c as follows cij = ai·bj.Solution: 6396358418D - Big Problems for Organizers. Author chavit, realization Aksenov239.This problem has two solutions.The first one. Let's hang the tree on some vertex. Afterwards, let us calculate for eah vertex it's height and 3 most distant vertices in its subtree. Also let's calculate arrays for the lowest common ancestors problem. For each vertex i and the power of two 2j we have p[i][j], up[i][j] and down[i][j]: p[i][j] is the ancestor on the distance of 2j, up[i][j] is equal to the longest path from i to the vertices, which are situated in subtrees of the vertices on the path between i and p[i][j]. down[i][j] is equal the same, but from the vertex p[i][j]. And the last part of this solution. Let us be given the query u v. Firstly, we find w = LCA(u, v). Afterwards, we need to find vertex hu, which is situated on the middle of the path between u and v. Really, we need to split the tree by this vertex, count the longest path from u in its tree and count the longest path from v in its tree. If we can imagine in the main tree, we can not delete this vertex, but with our precalculated arrays recalc this two values.First solution: 6396376The second solution. In a few words. Let's find the diameter of the tree. Precalc the answer for each vertices on the prefix. Then on the query we find two distant vertices on this diameter and the path. Obviously, diameter should contain the middle of the path, when we find it, using precalculated results on the prefixes and suffixes we can obtain the answer.Second solution cerealguy: 6396390418E - Tricky Password. Authors enot110, Aksenov239, realization Aksenov239.The key theoretical idea of this problem is that the $2$nd row is exactly the same as the $4$th row, $3$rd row is exactly the same as $5$th row and so on. Because of that we need only to answer queries on the first three rows.Let's move on to the practical part. In the first place we will compress coordinates, that any value will not exceed 2·105. Afterwards, let's split the array into parts of the length LEN. On each part we will calculate the following values: cnt[k] — the number of occurences of the number k on this prefix, also f[k] — the total number of the values, which occur exactly k times on this prefix. Array f we will store in the Fenwick data structure.It is not hard to see, that array cnt contains the answer for the queries to the 2nd row. To get the answer for the queries to the 3rd row we need to calculate f[cnt[k]... 105]. Also it's quite understandable how to recalc this dp.In summary, we will get per query. And we take , then we will get per query. Solution: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 418\\s*B"
          },
          "content_length": 5178
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readSpace();\n        int mi = inf.readInt(1, m, \"mi\");\n        inf.readEoln();\n\n        vector<int> problems = inf.readInts(mi, 1, m, \"problems\");\n        inf.readEoln();\n        ensuref(set<int>(problems.begin(), problems.end()).size() == mi, \n                \"Problem numbers must be distinct for friend %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readSpace();\n        int mi = inf.readInt(1, m, \"mi\");\n        inf.readEoln();\n\n        vector<int> problems = inf.readInts(mi, 1, m, \"problems\");\n        inf.readEoln();\n        ensuref(set<int>(problems.begin(), problems.end()).size() == mi, \n                \"Problem numbers must be distinct for friend %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readSpace();\n    int b = inf.readInt(1, 1000000000, \"b\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 1000000000, \"xi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 1000000000, \"ki\");\n        inf.readSpace();\n        int mi = inf.readInt(1, m, \"mi\");\n        inf.readEoln();\n\n        vector<int> problems = inf.readInts(mi, 1, m, \"problems\");\n        inf.readEoln();\n        ensuref(set<int>(problems.begin(), problems.end()).size() == mi, \n                \"Problem numbers must be distinct for friend %d\", i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> ki(n);\n    vector<vector<int>> problem_lists(n);\n\n    if (type == \"random\") {\n        // Randomly generate xi, ki, mi, and problem lists\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate a test case where not all problems can be solved\n        if(m == 1) {\n            // Edge case when m = 1\n            for(int i = 0; i < n; ++i) {\n                xi[i] = rnd.next(1, 1000000000);\n                ki[i] = rnd.next(1, 1000000000);\n                problem_lists[i].clear(); // No problems can be solved\n            }\n        } else {\n            int p_missing = rnd.next(1, m);\n            vector<int> available_problems;\n            for(int i = 1; i <= m; ++i)\n                if(i != p_missing)\n                    available_problems.push_back(i);\n\n            for(int i = 0; i < n; ++i) {\n                xi[i] = rnd.next(1, 1000000000);\n                ki[i] = rnd.next(1, 1000000000);\n                int mi = rnd.next(1, m - 1);\n                shuffle(available_problems.begin(), available_problems.end());\n                mi = min(mi, int(available_problems.size()));\n                vector<int> problems(available_problems.begin(), available_problems.begin() + mi);\n                problem_lists[i] = problems;\n            }\n        }\n    }\n    else if (type == \"max_monitors\") {\n        // All friends require maximum ki\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = 1000000000;\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            mi = min(mi, m);\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n    else if (type == \"min_monitors\") {\n        // All friends require ki = 1\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = 1;\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            mi = min(mi, m);\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n    else if (type == \"single_friend\") {\n        // First friend can solve all problems, but with high cost\n        xi[0] = 1000000000; // High cost\n        ki[0] = rnd.next(1, 10);\n        vector<int> problems(m);\n        for(int j = 0; j < m; ++j)\n            problems[j] = j + 1;\n        problem_lists[0] = problems;\n\n        // Other friends\n        for(int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = rnd.next(1, 10);\n            int mi = rnd.next(1, m - 1);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j)\n                probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            problem_lists[i] = probs;\n        }\n    }\n    else if (type == \"overlap_friends\") {\n        // Generate overlapping subsets\n        vector<bool> problem_covered(m+1, false);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = rnd.next(1, 10);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j)\n                probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n\n            for(int p : probs) {\n                problem_covered[p] = true;\n            }\n            problem_lists[i] = probs;\n        }\n\n        // Ensure all problems are covered\n        for(int p = 1; p <= m; ++p) {\n            if(!problem_covered[p]) {\n                int friend_idx = rnd.next(0, n - 1);\n                problem_lists[friend_idx].push_back(p);\n                problem_covered[p] = true;\n            }\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, b);\n    for(int i = 0; i < n; ++i) {\n        int mi = problem_lists[i].size();\n        printf(\"%d %d %d\\n\", xi[i], ki[i], mi);\n        for(int j = 0; j < mi; ++j) {\n            if(j > 0) printf(\" \");\n            printf(\"%d\", problem_lists[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int b = opt<int>(\"b\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi(n);\n    vector<int> ki(n);\n    vector<vector<int>> problem_lists(n);\n\n    if (type == \"random\") {\n        // Randomly generate xi, ki, mi, and problem lists\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n    else if (type == \"impossible\") {\n        // Generate a test case where not all problems can be solved\n        if(m == 1) {\n            // Edge case when m = 1\n            for(int i = 0; i < n; ++i) {\n                xi[i] = rnd.next(1, 1000000000);\n                ki[i] = rnd.next(1, 1000000000);\n                problem_lists[i].clear(); // No problems can be solved\n            }\n        } else {\n            int p_missing = rnd.next(1, m);\n            vector<int> available_problems;\n            for(int i = 1; i <= m; ++i)\n                if(i != p_missing)\n                    available_problems.push_back(i);\n\n            for(int i = 0; i < n; ++i) {\n                xi[i] = rnd.next(1, 1000000000);\n                ki[i] = rnd.next(1, 1000000000);\n                int mi = rnd.next(1, m - 1);\n                shuffle(available_problems.begin(), available_problems.end());\n                mi = min(mi, int(available_problems.size()));\n                vector<int> problems(available_problems.begin(), available_problems.begin() + mi);\n                problem_lists[i] = problems;\n            }\n        }\n    }\n    else if (type == \"max_monitors\") {\n        // All friends require maximum ki\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = 1000000000;\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            mi = min(mi, m);\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n    else if (type == \"min_monitors\") {\n        // All friends require ki = 1\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = 1;\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            mi = min(mi, m);\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n    else if (type == \"single_friend\") {\n        // First friend can solve all problems, but with high cost\n        xi[0] = 1000000000; // High cost\n        ki[0] = rnd.next(1, 10);\n        vector<int> problems(m);\n        for(int j = 0; j < m; ++j)\n            problems[j] = j + 1;\n        problem_lists[0] = problems;\n\n        // Other friends\n        for(int i = 1; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = rnd.next(1, 10);\n            int mi = rnd.next(1, m - 1);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j)\n                probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n            problem_lists[i] = probs;\n        }\n    }\n    else if (type == \"overlap_friends\") {\n        // Generate overlapping subsets\n        vector<bool> problem_covered(m+1, false);\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000);\n            ki[i] = rnd.next(1, 10);\n            int mi = rnd.next(1, m);\n            vector<int> probs(m);\n            for(int j = 0; j < m; ++j)\n                probs[j] = j + 1;\n            shuffle(probs.begin(), probs.end());\n            probs.resize(mi);\n\n            for(int p : probs) {\n                problem_covered[p] = true;\n            }\n            problem_lists[i] = probs;\n        }\n\n        // Ensure all problems are covered\n        for(int p = 1; p <= m; ++p) {\n            if(!problem_covered[p]) {\n                int friend_idx = rnd.next(0, n - 1);\n                problem_lists[friend_idx].push_back(p);\n                problem_covered[p] = true;\n            }\n        }\n    }\n    else {\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            xi[i] = rnd.next(1, 1000000000);\n            ki[i] = rnd.next(1, 1000000000);\n            int mi = rnd.next(1, m);\n            vector<int> problems(m);\n            for(int j = 0; j < m; ++j)\n                problems[j] = j + 1;\n            shuffle(problems.begin(), problems.end());\n            problems.resize(mi);\n            problem_lists[i] = problems;\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, b);\n    for(int i = 0; i < n; ++i) {\n        int mi = problem_lists[i].size();\n        printf(\"%d %d %d\\n\", xi[i], ki[i], mi);\n        for(int j = 0; j < mi; ++j) {\n            if(j > 0) printf(\" \");\n            printf(\"%d\", problem_lists[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -b 1 -type random\n./gen -n 5 -m 5 -b 1 -type impossible\n./gen -n 5 -m 5 -b 1 -type max_monitors\n./gen -n 5 -m 5 -b 1 -type min_monitors\n./gen -n 5 -m 5 -b 1 -type single_friend\n./gen -n 5 -m 5 -b 1 -type overlap_friends\n\n./gen -n 10 -m 10 -b 10 -type random\n./gen -n 10 -m 10 -b 10 -type impossible\n./gen -n 10 -m 10 -b 10 -type max_monitors\n./gen -n 10 -m 10 -b 10 -type min_monitors\n./gen -n 10 -m 10 -b 10 -type single_friend\n./gen -n 10 -m 10 -b 10 -type overlap_friends\n\n./gen -n 50 -m 20 -b 1000000 -type random\n./gen -n 50 -m 20 -b 1000000 -type impossible\n./gen -n 50 -m 20 -b 1000000 -type max_monitors\n./gen -n 50 -m 20 -b 1000000 -type min_monitors\n./gen -n 50 -m 20 -b 1000000 -type single_friend\n./gen -n 50 -m 20 -b 1000000 -type overlap_friends\n\n./gen -n 100 -m 20 -b 1000000000 -type random\n./gen -n 100 -m 20 -b 1000000000 -type impossible\n./gen -n 100 -m 20 -b 1000000000 -type max_monitors\n./gen -n 100 -m 20 -b 1000000000 -type min_monitors\n./gen -n 100 -m 20 -b 1000000000 -type single_friend\n./gen -n 100 -m 20 -b 1000000000 -type overlap_friends\n\n# Edge cases\n./gen -n 1 -m 1 -b 1 -type random\n./gen -n 1 -m 1 -b 1 -type impossible\n\n./gen -n 2 -m 2 -b 2 -type random\n./gen -n 2 -m 2 -b 2 -type impossible\n\n./gen -n 100 -m 1 -b 1 -type random\n./gen -n 100 -m 1 -b 1 -type impossible\n\n./gen -n 1 -m 20 -b 1000000000 -type random\n./gen -n 1 -m 20 -b 1000000000 -type impossible\n\n./gen -n 100 -m 20 -b 1 -type random\n./gen -n 100 -m 20 -b 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:10.194652",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "418/C",
      "title": "C. Квадратная таблица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке даны два целых числа n и m (1 ≤ n, m ≤ 100) — размеры таблицы.",
      "output_spec": "Выходные данныеВыведите таблицу, удовлетворяющую условию: n строк по m целых чисел, разделенных пробелами. Если существует несколько правильных ответов, разрешается вывести любой. Гарантируется, что хотя бы один ответ на задачу существует.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать1 2Выходные данныеСкопировать3 4",
      "description": "C. Квадратная таблица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке даны два целых числа n и m (1 ≤ n, m ≤ 100) — размеры таблицы.\n\nВходные данные\n\nВыходные данныеВыведите таблицу, удовлетворяющую условию: n строк по m целых чисел, разделенных пробелами. Если существует несколько правильных ответов, разрешается вывести любой. Гарантируется, что хотя бы один ответ на задачу существует.\n\nВыходные данные\n\nВходные данныеСкопировать1 1Выходные данныеСкопировать1Входные данныеСкопировать1 2Выходные данныеСкопировать3 4\n\nВходные данныеСкопировать1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Очередной сезон крупнейшей российской олимпиады Russian Code Cup стартует в субботу. Впереди новые интересные и нетривиальные задания, бескомпромиссная борьба и самые крутые призы.Но мы подготовили вам еще один сюрприз: 17 апреля у каждого из вас есть возможность оценить свои силы. В 19:30 по московскому времени на площадке http://codeforces.ru состоится тренировочный раунд олимпиады со свежей порцией задач от создателей RCC.RCC 2014 Warmup – это тест, который даст возможность попробовать свои силы и понять, к чему готовиться в раундах чемпионата. А для «бывалых» участников это идеальная возможность потренироваться и разогреться перед первыми сражениями RCC 2014!Автором большинства задач этого раунда является Aksenov239 — постоянный автор задач RCC. Конечно же ему помогали и другие члены жюри RCC-2014. Раунд пройдет как в div-1, так и в div-2, так что все найдут себе задачи по силам.Ждем вас в четверг в 19:30 на площадке http://codeforces.ruUPD: Итак, разбалловка раунда: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Всем удачи!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1059
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "417A - Отбор. Автор и реализация Aksenov239.Сначала нужно заметить, что если k больше либо равно, чем n·m, то ответ — 0. Нам осталось набрать n·m - k человек. Есть три способа их набрать: Взять раунды только первого типа: . Взять чуть раундов второго типа до числа, делящегося на n: . Взять только раунды второго типа: d(n·m - k). Также в данной задаче можно было написать переборное решение — сколько мы берём раундов первого типа, и сколько раундов второго.Код: 6396283417B - Сбой. Автор и реализация Aksenov239.Заведём массив a на 105 элементов, изначально заполненный  - 1, и в ячейке с номером k будем хранить максимальный номер посылки k-го участника, который сейчас есть. Будем обрабатывать посылки последовательно. Пусть обрабатывается посылка x k. Если a[k] < x - 1, то очевидно, что ответ NO, иначе обновляем массив — a[k] = max(a[k], x).Код: 6396297418A - Футбол. Автор и реализация Aksenov239.Представим турнир себе как граф. Из каждой вершины ровно k выходящих рёбер. Тогда всего nk рёбер. В полном графе максимум рёбер, поэтому если n < 2k + 1, тогда ответ  - 1. Иначе, соединим i-ую вершину с i + 1, ..., i + k, зациклим если нужно.Код: 6396331418B - Хитрый Гена. Автор и реализация Aksenov239.Давайте отсортируем друзей по возрастанию требуемого количества мониторов. Будем считать динамику на масках — какое минимальное число денег нужно заплатить, чтобы решить такие-то задачи, если мы взяли первых i друзей. Тогда ответ надо сравнить с ответом для i первых друзей плюс количество мониторов, которое требует i-ый друг. Не трудно заметить, что если брать друзей последовательно, то пересчитывать динамику можно как рюкзак. Время работы данного алгоритма O(nlog(n) + n2m).Код pashka: 6396347418C - Квадратная таблица. Автор и реализация Aksenov239.Давайте для любого n построим массив длины n, что сумма квадратов чисел на нём является квадратом: Если n = 1, то берём [1]. Если n = 2, то берём [3, 4]. Если n чётно, то берём . Если n нечётно, то берём . Нам дано 2 числа n и m. Пусть массив a соответствует числу n, а b соответствует числу m.Тогда итоговый массив c построим следующим способом — cij = ai·bj.Код: 6396358418D - Большие проблемы организаторов. Автор chavit, реализация Aksenov239.В данной задаче есть два решения.Первое. Подвесим за какую-нибудь вершину. Предподсчитаем для каждой, 3 самые удалённые вершины в её поддереве, а также для каждой вершины её глубину. Также предподсчитаем массивы для двоичного подъёма. Для каждой вершины i и степени двойки 2j предподсчитаем следующие массивы — p[i][j], up[i][j] и down[i][j]. p[i][j] — это предок вершины i на расстоянии 2j. В up[i][j] будет храниться наидлиннейший путь из i, до вершин, которые находятся в поддереве вершин, которые находятся на пути между i и p[i][j]. down[i][j] отличается от up[i][j], что хранит путь из вершины p[i][j].Теперь осталось дело за малым. Нам приходит запрос u v, мы ищем его наименьшего общего предка — w. Осталось найти вершину hu, которая будет находиться на середине это пути. Обрезать дерево по этой вершине, и посчитать длиннейшее расстояние от вершины u в её дереве и длиннейшее расстояние от вершины v в её дереве. Представляя на дереве это, если мы не будем удалять, то можно воспользовавшись нашими предподсчитанными массивами аккуратно пересчитать значение длиннейшего пути.Решение за O(nlog(n)).Код: 6396376Второе. Вкратце. Найдём диаметр этого дерева. Предподсчитаем там ответ на префиксе для каждой вершины. Тогда при ответе на запрос — мы находим, когда путь вливается диаметр. На это отрезке находим среднюю вершину, а далее отвечаем на запрос на префиксе или суффиксе.Код cerealguy: 6396390418E - Хитрый пароль. Авторы enot110, Aksenov239, реализация Aksenov239Ключевая теоретическая идея данной задачи заключается в том, что 2 строка совпадает с 4, 3 с 5 и т. д. Поэтому нам нужно уметь менять что-то только на первых трёх строках.Теперь дело остаётся за практической частью. В первую очередь сожмём все значения, чтобы они не превосходили 105. Разобьём массив на отрезки длиной LEN. На каждом отрезке будем считать следующее — для каждого значения будем хранить сколько раз он встречался на префиксе cnt, а так же дерево Фенвика, в котором в ячейке f[k] будет храниться количество чисел на данном префиксе, встречающихся ровно k раз. Несложно заметить, что в первом массиве хранится ответ на запросы ко второй строке, а чтобы получить ответ для третьей строки, нужно посчитать f[cnt[k]... 105]. Понятно так же, как делать пересчёт данной динамики.Итого, получаем время на запрос за . Если мы возьмём , то время ответа на запрос составит .Код: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 418\\s*C"
          },
          "content_length": 4580
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 13",
          "code": "static base a[100005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 14",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 15",
          "code": "printf(\"%d \", j+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 16",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 17",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 18",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 1",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 2",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(long long n) {\n    if (n < 0)\n        return false;\n    long long root = (long long)(sqrtl((long double)n) + 1e-8);\n    for (long long r = root - 1; r <= root + 1; ++r) {\n        if (r >= 0 && r * r == n)\n            return true;\n    }\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    vector<vector<int> > table(n, vector<int>(m));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            table[i][j] = ouf.readInt(1, 100000000, format(\"table[%d][%d]\", i + 1, j + 1).c_str());\n        }\n    }\n\n    // Check rows\n    for (int i = 0; i < n; ++i) {\n        long long sum_row = 0;\n        for (int j = 0; j < m; ++j) {\n            sum_row += 1LL * table[i][j] * table[i][j];\n        }\n        if (!isPerfectSquare(sum_row)) {\n            quitf(_wa, \"Row %d: sum of squares %lld is not a perfect square\", i + 1, sum_row);\n        }\n    }\n\n    // Check columns\n    for (int j = 0; j < m; ++j) {\n        long long sum_col = 0;\n        for (int i = 0; i < n; ++i) {\n            sum_col += 1LL * table[i][j] * table[i][j];\n        }\n        if (!isPerfectSquare(sum_col)) {\n            quitf(_wa, \"Column %d: sum of squares %lld is not a perfect square\", j + 1, sum_col);\n        }\n    }\n\n    quitf(_ok, \"Table is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1\n./gen -n 1 -m 2\n./gen -n 2 -m 1\n./gen -n 2 -m 2\n\n./gen -n 10 -m 10\n./gen -n 10 -m 20\n./gen -n 20 -m 10\n./gen -n 20 -m 20\n\n./gen -n 50 -m 50\n./gen -n 50 -m 100\n./gen -n 100 -m 50\n./gen -n 100 -m 100\n\n./gen -n 99 -m 100\n./gen -n 100 -m 99\n./gen -n 99 -m 99\n\n./gen -n 1 -m 100\n./gen -n 100 -m 1\n\n./gen -n 13 -m 17\n./gen -n 17 -m 13\n\n./gen -n 25 -m 25\n./gen -n 36 -m 36\n./gen -n 49 -m 49\n\n./gen -n 64 -m 64\n./gen -n 81 -m 81\n./gen -n 100 -m 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:12.525765",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "418/D",
      "title": "D. Большие проблемы организаторов",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке находится целое число n (2 ≤ n ≤ 100000) — количество гостиниц. В последующих n - 1 строках содержится по два целых числа — номера гостиниц между которыми есть дорога. Считайте, что гостиницы нумеруются от 1 до n.Следующая строка содержит целое число m (1 ≤ m ≤ 100000) — количество запросов. В следующих m строках содержится по два различных целых числа — номера предполагаемых главных гостиниц.",
      "output_spec": "Выходные данныеНа каждый запрос организаторов выведите одно целое число — время, которое понадобится, чтобы все участники добрались до главных гостиниц.",
      "sample_tests": "ПримерыВходные данныеСкопировать32 33 132 12 33 1Выходные данныеСкопировать111Входные данныеСкопировать41 41 22 331 41 32 3Выходные данныеСкопировать212",
      "description": "D. Большие проблемы организаторов\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке находится целое число n (2 ≤ n ≤ 100000) — количество гостиниц. В последующих n - 1 строках содержится по два целых числа — номера гостиниц между которыми есть дорога. Считайте, что гостиницы нумеруются от 1 до n.Следующая строка содержит целое число m (1 ≤ m ≤ 100000) — количество запросов. В следующих m строках содержится по два различных целых числа — номера предполагаемых главных гостиниц.\n\nВходные данные\n\nВыходные данныеНа каждый запрос организаторов выведите одно целое число — время, которое понадобится, чтобы все участники добрались до главных гостиниц.\n\nВыходные данные\n\nВходные данныеСкопировать32 33 132 12 33 1Выходные данныеСкопировать111Входные данныеСкопировать41 41 22 331 41 32 3Выходные данныеСкопировать212\n\nВходные данныеСкопировать32 33 132 12 33 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать111\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать41 41 22 331 41 32 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать212\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Очередной сезон крупнейшей российской олимпиады Russian Code Cup стартует в субботу. Впереди новые интересные и нетривиальные задания, бескомпромиссная борьба и самые крутые призы.Но мы подготовили вам еще один сюрприз: 17 апреля у каждого из вас есть возможность оценить свои силы. В 19:30 по московскому времени на площадке http://codeforces.ru состоится тренировочный раунд олимпиады со свежей порцией задач от создателей RCC.RCC 2014 Warmup – это тест, который даст возможность попробовать свои силы и понять, к чему готовиться в раундах чемпионата. А для «бывалых» участников это идеальная возможность потренироваться и разогреться перед первыми сражениями RCC 2014!Автором большинства задач этого раунда является Aksenov239 — постоянный автор задач RCC. Конечно же ему помогали и другие члены жюри RCC-2014. Раунд пройдет как в div-1, так и в div-2, так что все найдут себе задачи по силам.Ждем вас в четверг в 19:30 на площадке http://codeforces.ruUPD: Итак, разбалловка раунда: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Всем удачи!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1059
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "417A - Отбор. Автор и реализация Aksenov239.Сначала нужно заметить, что если k больше либо равно, чем n·m, то ответ — 0. Нам осталось набрать n·m - k человек. Есть три способа их набрать: Взять раунды только первого типа: . Взять чуть раундов второго типа до числа, делящегося на n: . Взять только раунды второго типа: d(n·m - k). Также в данной задаче можно было написать переборное решение — сколько мы берём раундов первого типа, и сколько раундов второго.Код: 6396283417B - Сбой. Автор и реализация Aksenov239.Заведём массив a на 105 элементов, изначально заполненный  - 1, и в ячейке с номером k будем хранить максимальный номер посылки k-го участника, который сейчас есть. Будем обрабатывать посылки последовательно. Пусть обрабатывается посылка x k. Если a[k] < x - 1, то очевидно, что ответ NO, иначе обновляем массив — a[k] = max(a[k], x).Код: 6396297418A - Футбол. Автор и реализация Aksenov239.Представим турнир себе как граф. Из каждой вершины ровно k выходящих рёбер. Тогда всего nk рёбер. В полном графе максимум рёбер, поэтому если n < 2k + 1, тогда ответ  - 1. Иначе, соединим i-ую вершину с i + 1, ..., i + k, зациклим если нужно.Код: 6396331418B - Хитрый Гена. Автор и реализация Aksenov239.Давайте отсортируем друзей по возрастанию требуемого количества мониторов. Будем считать динамику на масках — какое минимальное число денег нужно заплатить, чтобы решить такие-то задачи, если мы взяли первых i друзей. Тогда ответ надо сравнить с ответом для i первых друзей плюс количество мониторов, которое требует i-ый друг. Не трудно заметить, что если брать друзей последовательно, то пересчитывать динамику можно как рюкзак. Время работы данного алгоритма O(nlog(n) + n2m).Код pashka: 6396347418C - Квадратная таблица. Автор и реализация Aksenov239.Давайте для любого n построим массив длины n, что сумма квадратов чисел на нём является квадратом: Если n = 1, то берём [1]. Если n = 2, то берём [3, 4]. Если n чётно, то берём . Если n нечётно, то берём . Нам дано 2 числа n и m. Пусть массив a соответствует числу n, а b соответствует числу m.Тогда итоговый массив c построим следующим способом — cij = ai·bj.Код: 6396358418D - Большие проблемы организаторов. Автор chavit, реализация Aksenov239.В данной задаче есть два решения.Первое. Подвесим за какую-нибудь вершину. Предподсчитаем для каждой, 3 самые удалённые вершины в её поддереве, а также для каждой вершины её глубину. Также предподсчитаем массивы для двоичного подъёма. Для каждой вершины i и степени двойки 2j предподсчитаем следующие массивы — p[i][j], up[i][j] и down[i][j]. p[i][j] — это предок вершины i на расстоянии 2j. В up[i][j] будет храниться наидлиннейший путь из i, до вершин, которые находятся в поддереве вершин, которые находятся на пути между i и p[i][j]. down[i][j] отличается от up[i][j], что хранит путь из вершины p[i][j].Теперь осталось дело за малым. Нам приходит запрос u v, мы ищем его наименьшего общего предка — w. Осталось найти вершину hu, которая будет находиться на середине это пути. Обрезать дерево по этой вершине, и посчитать длиннейшее расстояние от вершины u в её дереве и длиннейшее расстояние от вершины v в её дереве. Представляя на дереве это, если мы не будем удалять, то можно воспользовавшись нашими предподсчитанными массивами аккуратно пересчитать значение длиннейшего пути.Решение за O(nlog(n)).Код: 6396376Второе. Вкратце. Найдём диаметр этого дерева. Предподсчитаем там ответ на префиксе для каждой вершины. Тогда при ответе на запрос — мы находим, когда путь вливается диаметр. На это отрезке находим среднюю вершину, а далее отвечаем на запрос на префиксе или суффиксе.Код cerealguy: 6396390418E - Хитрый пароль. Авторы enot110, Aksenov239, реализация Aksenov239Ключевая теоретическая идея данной задачи заключается в том, что 2 строка совпадает с 4, 3 с 5 и т. д. Поэтому нам нужно уметь менять что-то только на первых трёх строках.Теперь дело остаётся за практической частью. В первую очередь сожмём все значения, чтобы они не превосходили 105. Разобьём массив на отрезки длиной LEN. На каждом отрезке будем считать следующее — для каждого значения будем хранить сколько раз он встречался на префиксе cnt, а так же дерево Фенвика, в котором в ячейке f[k] будет храниться количество чисел на данном префиксе, встречающихся ровно k раз. Несложно заметить, что в первом массиве хранится ответ на запросы ко второй строке, а чтобы получить ответ для третьей строки, нужно посчитать f[cnt[k]... 105]. Понятно так же, как делать пересчёт данной динамики.Итого, получаем время на запрос за . Если мы возьмём , то время ответа на запрос составит .Код: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 418\\s*D"
          },
          "content_length": 4580
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 13",
          "code": "static base a[100005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 14",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 15",
          "code": "printf(\"%d \", j+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 16",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 17",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 18",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 1",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 2",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y) parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d connects the same node %d\", i + 1, u);\n        unite(u, v);\n    }\n\n    // After processing all edges, check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Query %d has the same nodes %d and %d\", i + 1, u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y) parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d connects the same node %d\", i + 1, u);\n        unite(u, v);\n    }\n\n    // After processing all edges, check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Query %d has the same nodes %d and %d\", i + 1, u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 5;\nint parent[MAXN];\n\nint find(int x) {\n    if (parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y) parent[x] = y;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Edge %d connects the same node %d\", i + 1, u);\n        unite(u, v);\n    }\n\n    // After processing all edges, check that the graph is connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    // Read m\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n        ensuref(u != v, \"Query %d has the same nodes %d and %d\", i + 1, u, v);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Build a chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Build a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Build a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (type == \"skewed\") {\n        // Build a skewed tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - rnd.next(1, min(i - 1, 10)), i});\n        }\n    } else {\n        // Build a random tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({rnd.next(1, i - 1), i});\n        }\n    }\n\n    // Shuffle the edges to randomize their order\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Now generate m queries\n    printf(\"%d\\n\", m);\n\n    vector<pair<int, int>> queries;\n\n    if (qtype == \"adjacent\") {\n        // Use edges as queries\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, int(edges.size()) - 1);\n            int a = edges[idx].first;\n            int b = edges[idx].second;\n            if (a == b) b = (b % n) + 1;\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"far_apart\") {\n        // Use nodes that are far apart\n        for (int i = 0; i < m; ++i) {\n            int a = 1;\n            int b = n;\n            queries.push_back({a, b});\n        }\n    } else {\n        // Random queries\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) {\n                b = rnd.next(1, n);\n            }\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output the queries\n    for (auto& q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    string qtype = opt<string>(\"qtype\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Build a chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (type == \"star\") {\n        // Build a star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"binary\") {\n        // Build a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (type == \"skewed\") {\n        // Build a skewed tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - rnd.next(1, min(i - 1, 10)), i});\n        }\n    } else {\n        // Build a random tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({rnd.next(1, i - 1), i});\n        }\n    }\n\n    // Shuffle the edges to randomize their order\n    shuffle(edges.begin(), edges.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Now generate m queries\n    printf(\"%d\\n\", m);\n\n    vector<pair<int, int>> queries;\n\n    if (qtype == \"adjacent\") {\n        // Use edges as queries\n        for (int i = 0; i < m; ++i) {\n            int idx = rnd.next(0, int(edges.size()) - 1);\n            int a = edges[idx].first;\n            int b = edges[idx].second;\n            if (a == b) b = (b % n) + 1;\n            queries.push_back({a, b});\n        }\n    } else if (qtype == \"far_apart\") {\n        // Use nodes that are far apart\n        for (int i = 0; i < m; ++i) {\n            int a = 1;\n            int b = n;\n            queries.push_back({a, b});\n        }\n    } else {\n        // Random queries\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            while (b == a) {\n                b = rnd.next(1, n);\n            }\n            queries.push_back({a, b});\n        }\n    }\n\n    // Output the queries\n    for (auto& q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small size trees\n./gen -n 2 -m 1 -type chain -qtype random\n./gen -n 2 -m 1 -type star -qtype adjacent\n./gen -n 2 -m 1 -type random -qtype far_apart\n\n./gen -n 5 -m 3 -type chain -qtype random\n./gen -n 5 -m 3 -type star -qtype adjacent\n./gen -n 5 -m 3 -type binary -qtype far_apart\n./gen -n 5 -m 3 -type skewed -qtype random\n./gen -n 5 -m 3 -type random -qtype random\n\n# Medium size trees\n./gen -n 100 -m 50 -type chain -qtype far_apart\n./gen -n 100 -m 50 -type star -qtype adjacent\n./gen -n 100 -m 50 -type binary -qtype random\n./gen -n 100 -m 50 -type skewed -qtype random\n./gen -n 100 -m 50 -type random -qtype random\n\n# Large size trees\n./gen -n 1000 -m 500 -type chain -qtype random\n./gen -n 1000 -m 500 -type star -qtype adjacent\n./gen -n 1000 -m 500 -type binary -qtype far_apart\n./gen -n 1000 -m 500 -type skewed -qtype random\n./gen -n 1000 -m 500 -type random -qtype random\n\n# Very large size trees\n./gen -n 10000 -m 10000 -type chain -qtype random\n./gen -n 10000 -m 10000 -type star -qtype adjacent\n./gen -n 10000 -m 10000 -type binary -qtype far_apart\n./gen -n 10000 -m 10000 -type skewed -qtype random\n./gen -n 10000 -m 10000 -type random -qtype random\n\n# Maximum size trees\n./gen -n 100000 -m 100000 -type chain -qtype random\n./gen -n 100000 -m 100000 -type star -qtype adjacent\n./gen -n 100000 -m 100000 -type binary -qtype far_apart\n./gen -n 100000 -m 100000 -type skewed -qtype random\n./gen -n 100000 -m 100000 -type random -qtype random\n\n# Edge cases with m = 1\n./gen -n 100000 -m 1 -type chain -qtype random\n./gen -n 100000 -m 1 -type star -qtype adjacent\n./gen -n 100000 -m 1 -type random -qtype far_apart\n\n# Edge cases with m = n - 1\n./gen -n 100000 -m 99999 -type chain -qtype random\n./gen -n 100000 -m 99999 -type star -qtype adjacent\n./gen -n 100000 -m 99999 -type random -qtype random\n\n# Random trees with random queries\n./gen -n 100000 -m 100000 -type random -qtype random\n./gen -n 50000 -m 50000 -type random -qtype random\n./gen -n 25000 -m 25000 -type random -qtype random\n\n# Skewed trees\n./gen -n 100000 -m 100000 -type skewed -qtype random\n./gen -n 100000 -m 1 -type skewed -qtype far_apart\n\n# Trees with special patterns\n./gen -n 100000 -m 100000 -type chain -qtype far_apart\n./gen -n 100000 -m 100000 -type star -qtype far_apart\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:14.186400",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "418/E",
      "title": "E. Хитрый пароль",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3.5 секунд",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 100000) — количество столбцов. Вторая строка содержит описание первой строки таблицы, то есть n чисел, каждое из которых не меньше 1 и не превосходят 109.Третья строка содержит целое число m (1 ≤ m ≤ 100000) — количество запросов.Далее каждая строка содержит описание запроса, состоящее из трех чисел:   Если первое число равно 1, то оставшиеся два — целые числа v, p (1 ≤ v ≤ 109; 1 ≤ p ≤ n). В этом случае значение v нужно поставить в позицию p в первой строке.  Если первое число равно 2, то оставшиеся два — целые числа x, y (1 ≤ x ≤ 105; 1 ≤ y ≤ n) — строка и столбец ячейки таблицы, из которой нужно получить значениe.",
      "output_spec": "Выходные данныеВыведите ответ на каждый запрос второго типа, в порядке поступления запросов.",
      "sample_tests": "ПримерыВходные данныеСкопировать61 2 2 2 3 132 2 31 3 32 3 4Выходные данныеСкопировать21",
      "description": "E. Хитрый пароль\n\nограничение по времени на тест3.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 100000) — количество столбцов. Вторая строка содержит описание первой строки таблицы, то есть n чисел, каждое из которых не меньше 1 и не превосходят 109.Третья строка содержит целое число m (1 ≤ m ≤ 100000) — количество запросов.Далее каждая строка содержит описание запроса, состоящее из трех чисел:   Если первое число равно 1, то оставшиеся два — целые числа v, p (1 ≤ v ≤ 109; 1 ≤ p ≤ n). В этом случае значение v нужно поставить в позицию p в первой строке.  Если первое число равно 2, то оставшиеся два — целые числа x, y (1 ≤ x ≤ 105; 1 ≤ y ≤ n) — строка и столбец ячейки таблицы, из которой нужно получить значениe.\n\nВходные данные\n\nВыходные данныеВыведите ответ на каждый запрос второго типа, в порядке поступления запросов.\n\nВыходные данные\n\nВходные данныеСкопировать61 2 2 2 3 132 2 31 3 32 3 4Выходные данныеСкопировать21\n\nВходные данныеСкопировать61 2 2 2 3 132 2 31 3 32 3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать21\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "RCC 2014 Warmup - Codeforces",
          "content": "Очередной сезон крупнейшей российской олимпиады Russian Code Cup стартует в субботу. Впереди новые интересные и нетривиальные задания, бескомпромиссная борьба и самые крутые призы.Но мы подготовили вам еще один сюрприз: 17 апреля у каждого из вас есть возможность оценить свои силы. В 19:30 по московскому времени на площадке http://codeforces.ru состоится тренировочный раунд олимпиады со свежей порцией задач от создателей RCC.RCC 2014 Warmup – это тест, который даст возможность попробовать свои силы и понять, к чему готовиться в раундах чемпионата. А для «бывалых» участников это идеальная возможность потренироваться и разогреться перед первыми сражениями RCC 2014!Автором большинства задач этого раунда является Aksenov239 — постоянный автор задач RCC. Конечно же ему помогали и другие члены жюри RCC-2014. Раунд пройдет как в div-1, так и в div-2, так что все найдут себе задачи по силам.Ждем вас в четверг в 19:30 на площадке http://codeforces.ruUPD: Итак, разбалловка раунда: Div1: 500-1000-1500-2500-2500, Div2: 500-1000-1500-2000-2500. Всем удачи!",
          "author": "andrewzta",
          "url": "https://codeforces.com/blog/entry/11632",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1059
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces",
          "content": "417A - Отбор. Автор и реализация Aksenov239.Сначала нужно заметить, что если k больше либо равно, чем n·m, то ответ — 0. Нам осталось набрать n·m - k человек. Есть три способа их набрать: Взять раунды только первого типа: . Взять чуть раундов второго типа до числа, делящегося на n: . Взять только раунды второго типа: d(n·m - k). Также в данной задаче можно было написать переборное решение — сколько мы берём раундов первого типа, и сколько раундов второго.Код: 6396283417B - Сбой. Автор и реализация Aksenov239.Заведём массив a на 105 элементов, изначально заполненный  - 1, и в ячейке с номером k будем хранить максимальный номер посылки k-го участника, который сейчас есть. Будем обрабатывать посылки последовательно. Пусть обрабатывается посылка x k. Если a[k] < x - 1, то очевидно, что ответ NO, иначе обновляем массив — a[k] = max(a[k], x).Код: 6396297418A - Футбол. Автор и реализация Aksenov239.Представим турнир себе как граф. Из каждой вершины ровно k выходящих рёбер. Тогда всего nk рёбер. В полном графе максимум рёбер, поэтому если n < 2k + 1, тогда ответ  - 1. Иначе, соединим i-ую вершину с i + 1, ..., i + k, зациклим если нужно.Код: 6396331418B - Хитрый Гена. Автор и реализация Aksenov239.Давайте отсортируем друзей по возрастанию требуемого количества мониторов. Будем считать динамику на масках — какое минимальное число денег нужно заплатить, чтобы решить такие-то задачи, если мы взяли первых i друзей. Тогда ответ надо сравнить с ответом для i первых друзей плюс количество мониторов, которое требует i-ый друг. Не трудно заметить, что если брать друзей последовательно, то пересчитывать динамику можно как рюкзак. Время работы данного алгоритма O(nlog(n) + n2m).Код pashka: 6396347418C - Квадратная таблица. Автор и реализация Aksenov239.Давайте для любого n построим массив длины n, что сумма квадратов чисел на нём является квадратом: Если n = 1, то берём [1]. Если n = 2, то берём [3, 4]. Если n чётно, то берём . Если n нечётно, то берём . Нам дано 2 числа n и m. Пусть массив a соответствует числу n, а b соответствует числу m.Тогда итоговый массив c построим следующим способом — cij = ai·bj.Код: 6396358418D - Большие проблемы организаторов. Автор chavit, реализация Aksenov239.В данной задаче есть два решения.Первое. Подвесим за какую-нибудь вершину. Предподсчитаем для каждой, 3 самые удалённые вершины в её поддереве, а также для каждой вершины её глубину. Также предподсчитаем массивы для двоичного подъёма. Для каждой вершины i и степени двойки 2j предподсчитаем следующие массивы — p[i][j], up[i][j] и down[i][j]. p[i][j] — это предок вершины i на расстоянии 2j. В up[i][j] будет храниться наидлиннейший путь из i, до вершин, которые находятся в поддереве вершин, которые находятся на пути между i и p[i][j]. down[i][j] отличается от up[i][j], что хранит путь из вершины p[i][j].Теперь осталось дело за малым. Нам приходит запрос u v, мы ищем его наименьшего общего предка — w. Осталось найти вершину hu, которая будет находиться на середине это пути. Обрезать дерево по этой вершине, и посчитать длиннейшее расстояние от вершины u в её дереве и длиннейшее расстояние от вершины v в её дереве. Представляя на дереве это, если мы не будем удалять, то можно воспользовавшись нашими предподсчитанными массивами аккуратно пересчитать значение длиннейшего пути.Решение за O(nlog(n)).Код: 6396376Второе. Вкратце. Найдём диаметр этого дерева. Предподсчитаем там ответ на префиксе для каждой вершины. Тогда при ответе на запрос — мы находим, когда путь вливается диаметр. На это отрезке находим среднюю вершину, а далее отвечаем на запрос на префиксе или суффиксе.Код cerealguy: 6396390418E - Хитрый пароль. Авторы enot110, Aksenov239, реализация Aksenov239Ключевая теоретическая идея данной задачи заключается в том, что 2 строка совпадает с 4, 3 с 5 и т. д. Поэтому нам нужно уметь менять что-то только на первых трёх строках.Теперь дело остаётся за практической частью. В первую очередь сожмём все значения, чтобы они не превосходили 105. Разобьём массив на отрезки длиной LEN. На каждом отрезке будем считать следующее — для каждого значения будем хранить сколько раз он встречался на префиксе cnt, а так же дерево Фенвика, в котором в ячейке f[k] будет храниться количество чисел на данном префиксе, встречающихся ровно k раз. Несложно заметить, что в первом массиве хранится ответ на запросы ко второй строке, а чтобы получить ответ для третьей строки, нужно посчитать f[cnt[k]... 105]. Понятно так же, как делать пересчёт данной динамики.Итого, получаем время на запрос за . Если мы возьмём , то время ответа на запрос составит .Код: 6396412",
          "author": "Aksenov239",
          "url": "https://codeforces.com/blog/entry/11730",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 418\\s*E"
          },
          "content_length": 4580
        }
      ],
      "code_examples": [
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 1",
          "code": "ios_base::sync_with_stdio(false); cin.tie(NULL);\n#define endl '\\n'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 2",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 3",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 4",
          "code": "// to convert prefix to postfix\nmain() {\n  char c = getchar();\n  (c == '+' || c == '-' || c == '*' || c == '/') ? main(), main() : 0;\n  putchar(c);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 5",
          "code": "cin.tie(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 6",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 7",
          "code": "x x x x x y\nx x x x x y\nx x x x x y\nz z z z z t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 8",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 9",
          "code": "{ 50, 68 }, { 50, 72 }, { 50, 83 }, { 50, 84 }, { 50, 87 }, { 50, 90 } \n{ 82, 68 }, { 82, 72 }, { 82, 80 }, { 82, 83 }, { 82, 84 }, { 82, 87 }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 10",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 11",
          "code": "Test: #34, время: 935 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: OK\nВвод\n999 499\nTest: #41, время: 1000 мс., память: 0 КБ, код возврата: 0, код возврата чекера: 0, вердикт: TIME_LIMIT_EXCEEDED\nВвод\n999 499",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(false);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 13",
          "code": "static base a[100005];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 14",
          "code": "printf(\"%d\", x);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 15",
          "code": "printf(\"%d \", j+1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 16",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 17",
          "code": "if (i != n - 1)\n        cout << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 Warmup - Codeforces - Code 18",
          "code": "n*i+j>=n*m-k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11632",
          "author": "andrewzta"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 1",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        },
        {
          "title": "RCC 2014 WarmUp Analysis - Codeforces - Code 2",
          "code": "aaaabb\naaaabb\nccccdd\nccccdd\nccccdd",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11730",
          "author": "Aksenov239"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, 1000000000, \"v\");\n            inf.readSpace();\n            int p = inf.readInt(1, n, \"p\");\n        } else if (t == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, 100000, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, n, \"y\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, 1000000000, \"v\");\n            inf.readSpace();\n            int p = inf.readInt(1, n, \"p\");\n        } else if (t == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, 100000, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, n, \"y\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        int t = inf.readInt(1, 2, \"t\");\n\n        if (t == 1) {\n            inf.readSpace();\n            int v = inf.readInt(1, 1000000000, \"v\");\n            inf.readSpace();\n            int p = inf.readInt(1, n, \"p\");\n        } else if (t == 2) {\n            inf.readSpace();\n            int x = inf.readInt(1, 100000, \"x\");\n            inf.readSpace();\n            int y = inf.readInt(1, n, \"y\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // default value 0 if not provided\n    string type = opt<string>(\"type\", \"random\");\n    int maxValue = opt<int>(\"maxValue\", 1000000000);\n    int ratioQueries = opt<int>(\"q\", 50); // percentage of queries, default 50%\n    int maxX = opt<int>(\"maxX\", 100000); // maximum value of x in queries\n\n    vector<int> a(n);\n\n    if (type == \"allones\") {\n        // First row is all ones\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"smallnumbers\") {\n        // First row is random numbers between 1 and 10\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"maxnumbers\") {\n        // First row is random large numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(max(1, maxValue / 2), maxValue);\n        }\n    } else if (type == \"small\") {\n        // Small n and m\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxValue);\n        }\n    } else {\n        // Default is random numbers between 1 and maxValue\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxValue);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the first row\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    // Output m\n    if (m == 0) {\n        m = rnd.next(1, 100000);\n    }\n    printf(\"%d\\n\", m);\n\n    // Generate m commands according to type\n    vector<int> cmdType(m); // 1 for update, 2 for query\n    if (type == \"onlyqueries\") {\n        fill(cmdType.begin(), cmdType.end(), 2);\n    } else if (type == \"onlyupdates\") {\n        fill(cmdType.begin(), cmdType.end(), 1);\n    } else if (type == \"maxdepth\") {\n        fill(cmdType.begin(), cmdType.end(), 2);\n    } else if (type == \"maxupdates\") {\n        fill(cmdType.begin(), cmdType.end(), 1);\n    } else {\n        for (int i = 0; i < m; ++i) {\n            int prob = rnd.next(100);\n            if (prob < ratioQueries) {\n                cmdType[i] = 2; // query\n            } else {\n                cmdType[i] = 1; // update\n            }\n        }\n    }\n\n    // Now generate commands\n    for (int i = 0; i < m; ++i) {\n        if (cmdType[i] == 1) {\n            // update command: 1 v p\n            int p = rnd.next(1, n);\n            int v;\n            if (type == \"smallnumbers\") {\n                v = rnd.next(1, 10);\n            } else {\n                v = rnd.next(1, maxValue);\n            }\n            printf(\"1 %d %d\\n\", v, p);\n        } else {\n            // query command: 2 x y\n            int x, y;\n            if (type == \"maxdepth\") {\n                x = maxX;\n            } else {\n                x = rnd.next(1, maxX);\n            }\n            y = rnd.next(1, n);\n            printf(\"2 %d %d\\n\", x, y);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0); // default value 0 if not provided\n    string type = opt<string>(\"type\", \"random\");\n    int maxValue = opt<int>(\"maxValue\", 1000000000);\n    int ratioQueries = opt<int>(\"q\", 50); // percentage of queries, default 50%\n    int maxX = opt<int>(\"maxX\", 100000); // maximum value of x in queries\n\n    vector<int> a(n);\n\n    if (type == \"allones\") {\n        // First row is all ones\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"smallnumbers\") {\n        // First row is random numbers between 1 and 10\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"maxnumbers\") {\n        // First row is random large numbers\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(max(1, maxValue / 2), maxValue);\n        }\n    } else if (type == \"small\") {\n        // Small n and m\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n        a.resize(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxValue);\n        }\n    } else {\n        // Default is random numbers between 1 and maxValue\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, maxValue);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the first row\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    // Output m\n    if (m == 0) {\n        m = rnd.next(1, 100000);\n    }\n    printf(\"%d\\n\", m);\n\n    // Generate m commands according to type\n    vector<int> cmdType(m); // 1 for update, 2 for query\n    if (type == \"onlyqueries\") {\n        fill(cmdType.begin(), cmdType.end(), 2);\n    } else if (type == \"onlyupdates\") {\n        fill(cmdType.begin(), cmdType.end(), 1);\n    } else if (type == \"maxdepth\") {\n        fill(cmdType.begin(), cmdType.end(), 2);\n    } else if (type == \"maxupdates\") {\n        fill(cmdType.begin(), cmdType.end(), 1);\n    } else {\n        for (int i = 0; i < m; ++i) {\n            int prob = rnd.next(100);\n            if (prob < ratioQueries) {\n                cmdType[i] = 2; // query\n            } else {\n                cmdType[i] = 1; // update\n            }\n        }\n    }\n\n    // Now generate commands\n    for (int i = 0; i < m; ++i) {\n        if (cmdType[i] == 1) {\n            // update command: 1 v p\n            int p = rnd.next(1, n);\n            int v;\n            if (type == \"smallnumbers\") {\n                v = rnd.next(1, 10);\n            } else {\n                v = rnd.next(1, maxValue);\n            }\n            printf(\"1 %d %d\\n\", v, p);\n        } else {\n            // query command: 2 x y\n            int x, y;\n            if (type == \"maxdepth\") {\n                x = maxX;\n            } else {\n                x = rnd.next(1, maxX);\n            }\n            y = rnd.next(1, n);\n            printf(\"2 %d %d\\n\", x, y);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type small\n./gen -n 1 -m 1 -type allones\n./gen -n 10 -m 10 -type smallnumbers\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type onlyqueries -maxX 100000\n./gen -n 100000 -m 100000 -type onlyupdates\n./gen -n 100000 -m 100000 -type maxnumbers\n./gen -n 100000 -m 100000 -type allones\n./gen -n 100000 -m 100000 -type maxdepth -maxX 100000\n./gen -n 100000 -m 100000 -type updates\n./gen -n 100000 -m 100000 -type smallnumbers -q 70\n./gen -n 100000 -m 100000 -type random -q 30\n./gen -n 100000 -m 100000 -type random -q 90\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type random -maxValue 10\n./gen -n 2 -m 2 -type small\n./gen -n 99999 -m 50000 -type random\n./gen -n 50000 -m 99999 -type random\n./gen -n 1 -m 100000 -type onlyqueries -maxX 1\n./gen -n 1 -m 100000 -type onlyupdates\n./gen -n 100000 -m 100000 -type maxdepth -maxX 1\n./gen -n 50 -m 50 -type smallnumbers\n./gen -n 100000 -m 100000 -type random -q 100 -maxX 100000\n./gen -n 100000 -m 100000 -type random -q 0\n./gen -n 100000 -m 100000 -type maxupdates\n./gen -n 100 -m 100 -type smallnumbers -q 80\n./gen -n 100000 -m 100000 -type smallnumbers -q 20\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:16.235938",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "42/A",
      "title": "A. Guilty — to the kitchen!",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two space-separated integers n and V (1 ≤ n ≤ 20, 1 ≤ V ≤ 10000). The next line contains n space-separated integers ai (1 ≤ ai ≤ 100). Finally, the last line contains n space-separated integers bi (0 ≤ bi ≤ 100).",
      "output_spec": "OutputYour program should output just one real number — the volume of soup that Volodya will cook. Your answer must have a relative or absolute error less than 10 - 4.",
      "sample_tests": "ExamplesInputCopy1 100140OutputCopy40.0InputCopy2 1001 125 30OutputCopy50.0InputCopy2 1001 160 60OutputCopy100.0",
      "description": "A. Guilty — to the kitchen!\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two space-separated integers n and V (1 ≤ n ≤ 20, 1 ≤ V ≤ 10000). The next line contains n space-separated integers ai (1 ≤ ai ≤ 100). Finally, the last line contains n space-separated integers bi (0 ≤ bi ≤ 100).\n\nOutputYour program should output just one real number — the volume of soup that Volodya will cook. Your answer must have a relative or absolute error less than 10 - 4.\n\nInputCopy1 100140OutputCopy40.0InputCopy2 1001 125 30OutputCopy50.0InputCopy2 1001 160 60OutputCopy100.0\n\nInputCopy1 100140\n\nOutputCopy40.0\n\nInputCopy2 1001 125 30\n\nOutputCopy50.0\n\nInputCopy2 1001 160 60\n\nOutputCopy100.0",
      "solutions": [
        {
          "title": "Codeforces beta round #41 - Codeforces",
          "content": "Hi everyone.The today's contest is presented by us: cerealguy and yaro. We used to study in school together and Volodya studied there with us. So he will be the contest's hero: Volodya is going to cook in a kitchen, visit a museum, try to crack a safe, travel to an unusual city and even use his magical abilities.We are grateful to the Codeforces team and especially to Artem Rakhov who helped us to prepare the contest and wrote alternative solutions.We hope problems will suit your taste.Good luck!Update: Solutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/882",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 518
        },
        {
          "title": "Solutions for Сodeforces Beta Round #41 - Codeforces",
          "content": "А. Guilty — to the kitchen!Let us reformulate the statement: we need to find the maximum possible value of x (mentioned in the statement) so that the amount of each ingredient will be enough. Clearly, such x equals min(b_i / a_i). Now it suffices to take minimum of the two values: soup volume we gained and the volume of the pan.В. Game of chess unfinished.In this problem you are to check exactly what the statement says: if the king's position and all the positions reachable by him in one turn are \"beaten\", — that's a mate. Thus, we have to determine \"beaten\" positions correctly. Let us remove the black king from the chessboard, leave the positions of  the rooks \"unbeaten\" (not to forget about possible taking of the rook by the black king), mark positions reachable by rooks \"beaten\" and then mark positions reachable by white king as \"beaten\".С. Safe cracking.The answer in this problem is always affirmative, which means it is always possible to make all the numbers equal to one. Greedy approach (here we somehow make two adjacent numbers even and then divide them by two) leads the sum of numbers to become less or equal to six in logarithmic (and certainly less than 1000) number of operations. There are several ways do deal with extremal cases: for instance, many of the participants coped with this by the analysis of all of the cases left. The greedy approach only is not sufficient: the crucial test for hacks was (1 1 1 2).D. Strange town.Let us associate some numbers a_i with the vertices of the graph. If, for each edge, we assign it the sum of its endpoints' numbers, then the sum of prices along arbitrary hamiltonian cycle will be equal to the doubled sum of a_i. Therefore, it suffices us to devise such numbers a_i so that their pairwise sums will be distinct (as the edge prices should be distinct). As all of the edge prices are bounded above by 1000, we have to think of an efficient strategy to obtain such a_i. Let's choose them in greedy way, so that newly added a_i should not be equal to (a_p + a_q - a_k) for each triple of already chosen a_p, a_q, a_k. It is clear that a_n = O(n^3) as there are O(n^3) \"blocking\" triples (p, q, k).Another idea lies in that equality AB+CD=AC+BD should hold for every quadruple of distinct vertices A, B, C, D (summands stay for edge prices), because a hamiltonial cycle with edges AB and CD can be easily rearranged in the cycle with edges AC and BD and the sums of these cycles should be equal.You may think of how this idea was used by jury to check your solutions in exact and fast way.The solution of the problem E will appear soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/884",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2608
        },
        {
          "title": "Solution of task е, Codeforces beta round #41 - Codeforces",
          "content": "First note that a valid graph of wormholes is either connected or consists of two connectivity components with one exit in each. The proof is in the end of this text. Also note that the first option is never optimal because one edge can be removed to get the second option. Let's build a minimal spanning tree of the input graph. If it contains more than two components, the answer for each query is -1. If it contains two components, the answer is -1 if both objects are in the same component, and the weight of the spanning tree otherwise. The most interesting case is one component: we need to cut the spanning tree into two trees containing one exit each and having minimal sum of weights (not actually cut but get the sum of weights of the resulting trees). It can be done by (virtually) removing the most heavy edge on the path between the exits; so the only thing we need to know is the weight of such edge. It can be done with LCA algorithm: for each node precalculate upward jumps of height 2^k, k=0..log n, but also for each jump calculate the maximum weight of an edge on the path of this jump. Then you can split the path a-b in paths a-lca(a,b) and b-lca(a,b) and calculate the maximum weight on each of them in O(log n) using the precalculated values.Now the proof:First, it's easy to see that such graph of wormholes is valid: we can enter any exit, cross all tunnels in this component, go to another component (there is always an edge between components because tunnel graph is connected), cross all tunnels there, cross all remaining tunnels between components and leave using one of the exits. Besides these components A and B let there be another component C (and maybe some other components) and the number of tunnels between A and C is odd, between B and C - even; in this case it's impossible to traverse all tunnels once and return to A or B, so this wormhole graph is invalid. If both exits are in the same component and there is another component and the number of tunnels between them is odd, it's invalid too. So the only options left are those mentioned in the beginning.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/887",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2099
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int V = inf.readInt(1, 10000, \"V\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 0, 100, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int V = inf.readInt(1, 10000, \"V\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 0, 100, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 20, \"n\");\n    inf.readSpace();\n    int V = inf.readInt(1, 10000, \"V\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 100, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(n, 0, 100, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int V = opt<int>(\"V\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"zero_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = 0;\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = 100;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n            bi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 100;\n            bi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"matching_bi_ai_x\") {\n        double x = opt<double>(\"x\", 1.0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = min(100, (int)(ai[i] * x + 0.5));\n        }\n    } else if (type == \"pan_limit\") {\n        int total_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = 100;\n            total_ai += ai[i];\n        }\n    } else if (type == \"ingredient_limit\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(0, ai[i]);\n        }\n    } else if (type == \"random_zero_bi_some\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = (rnd.next(0, 1) == 0) ? rnd.next(0, 100) : 0;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(0, 100);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, V);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int V = opt<int>(\"V\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"zero_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = 0;\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = 100;\n        }\n    } else if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 1;\n            bi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 100;\n            bi[i] = rnd.next(0, 100);\n        }\n    } else if (type == \"matching_bi_ai_x\") {\n        double x = opt<double>(\"x\", 1.0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = min(100, (int)(ai[i] * x + 0.5));\n        }\n    } else if (type == \"pan_limit\") {\n        int total_ai = 0;\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = 100;\n            total_ai += ai[i];\n        }\n    } else if (type == \"ingredient_limit\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(0, ai[i]);\n        }\n    } else if (type == \"random_zero_bi_some\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = (rnd.next(0, 1) == 0) ? rnd.next(0, 100) : 0;\n        }\n    } else {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(1, 100);\n            bi[i] = rnd.next(0, 100);\n        }\n    }\n\n    printf(\"%d %d\\n\", n, V);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -V 1 -type random\n./gen -n 1 -V 10000 -type random\n./gen -n 5 -V 500 -type random\n./gen -n 10 -V 1000 -type random\n./gen -n 20 -V 10000 -type random\n\n./gen -n 5 -V 500 -type zero_bi\n./gen -n 10 -V 1000 -type zero_bi\n./gen -n 20 -V 10000 -type zero_bi\n\n./gen -n 5 -V 500 -type max_bi\n./gen -n 10 -V 1000 -type max_bi\n./gen -n 20 -V 10000 -type max_bi\n\n./gen -n 5 -V 500 -type min_ai\n./gen -n 10 -V 1000 -type min_ai\n./gen -n 20 -V 10000 -type min_ai\n\n./gen -n 5 -V 500 -type max_ai\n./gen -n 10 -V 1000 -type max_ai\n./gen -n 20 -V 10000 -type max_ai\n\n./gen -n 5 -V 500 -type matching_bi_ai_x -x 1.0\n./gen -n 10 -V 1000 -type matching_bi_ai_x -x 0.5\n./gen -n 20 -V 10000 -type matching_bi_ai_x -x 10.0\n\n./gen -n 5 -V 10 -type pan_limit\n./gen -n 10 -V 50 -type pan_limit\n./gen -n 20 -V 100 -type pan_limit\n\n./gen -n 5 -V 10000 -type ingredient_limit\n./gen -n 10 -V 10000 -type ingredient_limit\n./gen -n 20 -V 10000 -type ingredient_limit\n\n./gen -n 1 -V 100 -type random\n./gen -n 5 -V 1 -type random\n\n./gen -n 5 -V 1000 -type matching_bi_ai_x -x 1.0\n./gen -n 5 -V 1000 -type matching_bi_ai_x -x 2.0\n\n./gen -n 5 -V 500 -type random_zero_bi_some\n./gen -n 10 -V 1000 -type random_zero_bi_some\n\n./gen -n 20 -V 10000 -type random\n\n./gen -n 5 -V 10 -type pan_limit\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:18.020611",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "42/B",
      "title": "B. Game of chess unfinished",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains 4 space-separated piece positions: positions of the two rooks, the white king and the black king. Each position on 8 × 8 chessboard is denoted by two symbols — ('a' - 'h') and ('1' - '8') — which stand for horizontal and vertical coordinates of the cell occupied by the piece. It is guaranteed, that no two pieces occupy the same cell, and kings cannot take each other.",
      "output_spec": "OutputOutput should contain one word: \"CHECKMATE\" if whites mate blacks, and \"OTHER\" otherwise.",
      "sample_tests": "ExamplesInputCopya6 b4 c8 a8OutputCopyCHECKMATEInputCopya6 c4 b6 b8OutputCopyOTHERInputCopya2 b1 a3 a1OutputCopyOTHER",
      "description": "B. Game of chess unfinished\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains 4 space-separated piece positions: positions of the two rooks, the white king and the black king. Each position on 8 × 8 chessboard is denoted by two symbols — ('a' - 'h') and ('1' - '8') — which stand for horizontal and vertical coordinates of the cell occupied by the piece. It is guaranteed, that no two pieces occupy the same cell, and kings cannot take each other.\n\nOutputOutput should contain one word: \"CHECKMATE\" if whites mate blacks, and \"OTHER\" otherwise.\n\nInputCopya6 b4 c8 a8OutputCopyCHECKMATEInputCopya6 c4 b6 b8OutputCopyOTHERInputCopya2 b1 a3 a1OutputCopyOTHER\n\nInputCopya6 b4 c8 a8\n\nOutputCopyCHECKMATE\n\nInputCopya6 c4 b6 b8\n\nOutputCopyOTHER\n\nInputCopya2 b1 a3 a1\n\nOutputCopyOTHER",
      "solutions": [
        {
          "title": "Codeforces beta round #41 - Codeforces",
          "content": "Hi everyone.The today's contest is presented by us: cerealguy and yaro. We used to study in school together and Volodya studied there with us. So he will be the contest's hero: Volodya is going to cook in a kitchen, visit a museum, try to crack a safe, travel to an unusual city and even use his magical abilities.We are grateful to the Codeforces team and especially to Artem Rakhov who helped us to prepare the contest and wrote alternative solutions.We hope problems will suit your taste.Good luck!Update: Solutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/882",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 518
        },
        {
          "title": "Solutions for Сodeforces Beta Round #41 - Codeforces",
          "content": "А. Guilty — to the kitchen!Let us reformulate the statement: we need to find the maximum possible value of x (mentioned in the statement) so that the amount of each ingredient will be enough. Clearly, such x equals min(b_i / a_i). Now it suffices to take minimum of the two values: soup volume we gained and the volume of the pan.В. Game of chess unfinished.In this problem you are to check exactly what the statement says: if the king's position and all the positions reachable by him in one turn are \"beaten\", — that's a mate. Thus, we have to determine \"beaten\" positions correctly. Let us remove the black king from the chessboard, leave the positions of  the rooks \"unbeaten\" (not to forget about possible taking of the rook by the black king), mark positions reachable by rooks \"beaten\" and then mark positions reachable by white king as \"beaten\".С. Safe cracking.The answer in this problem is always affirmative, which means it is always possible to make all the numbers equal to one. Greedy approach (here we somehow make two adjacent numbers even and then divide them by two) leads the sum of numbers to become less or equal to six in logarithmic (and certainly less than 1000) number of operations. There are several ways do deal with extremal cases: for instance, many of the participants coped with this by the analysis of all of the cases left. The greedy approach only is not sufficient: the crucial test for hacks was (1 1 1 2).D. Strange town.Let us associate some numbers a_i with the vertices of the graph. If, for each edge, we assign it the sum of its endpoints' numbers, then the sum of prices along arbitrary hamiltonian cycle will be equal to the doubled sum of a_i. Therefore, it suffices us to devise such numbers a_i so that their pairwise sums will be distinct (as the edge prices should be distinct). As all of the edge prices are bounded above by 1000, we have to think of an efficient strategy to obtain such a_i. Let's choose them in greedy way, so that newly added a_i should not be equal to (a_p + a_q - a_k) for each triple of already chosen a_p, a_q, a_k. It is clear that a_n = O(n^3) as there are O(n^3) \"blocking\" triples (p, q, k).Another idea lies in that equality AB+CD=AC+BD should hold for every quadruple of distinct vertices A, B, C, D (summands stay for edge prices), because a hamiltonial cycle with edges AB and CD can be easily rearranged in the cycle with edges AC and BD and the sums of these cycles should be equal.You may think of how this idea was used by jury to check your solutions in exact and fast way.The solution of the problem E will appear soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/884",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2608
        },
        {
          "title": "Solution of task е, Codeforces beta round #41 - Codeforces",
          "content": "First note that a valid graph of wormholes is either connected or consists of two connectivity components with one exit in each. The proof is in the end of this text. Also note that the first option is never optimal because one edge can be removed to get the second option. Let's build a minimal spanning tree of the input graph. If it contains more than two components, the answer for each query is -1. If it contains two components, the answer is -1 if both objects are in the same component, and the weight of the spanning tree otherwise. The most interesting case is one component: we need to cut the spanning tree into two trees containing one exit each and having minimal sum of weights (not actually cut but get the sum of weights of the resulting trees). It can be done by (virtually) removing the most heavy edge on the path between the exits; so the only thing we need to know is the weight of such edge. It can be done with LCA algorithm: for each node precalculate upward jumps of height 2^k, k=0..log n, but also for each jump calculate the maximum weight of an edge on the path of this jump. Then you can split the path a-b in paths a-lca(a,b) and b-lca(a,b) and calculate the maximum weight on each of them in O(log n) using the precalculated values.Now the proof:First, it's easy to see that such graph of wormholes is valid: we can enter any exit, cross all tunnels in this component, go to another component (there is always an edge between components because tunnel graph is connected), cross all tunnels there, cross all remaining tunnels between components and leave using one of the exits. Besides these components A and B let there be another component C (and maybe some other components) and the number of tunnels between A and C is odd, between B and C - even; in this case it's impossible to traverse all tunnels once and return to A or B, so this wormhole graph is invalid. If both exits are in the same component and there is another component and the number of tunnels between them is odd, it's invalid too. So the only options left are those mentioned in the beginning.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/887",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2099
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read four positions: two rooks, white king, black king\n    vector<string> positions(4);\n\n    for (int i = 0; i < 4; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        // Each position must be two characters: a-h and 1-8\n        positions[i] = inf.readToken(\"[a-h][1-8]\", \"position\");\n    }\n\n    inf.readEoln();\n    inf.readEof();\n\n    // Ensure all positions are unique\n    std::set<string> unique_positions(positions.begin(), positions.end());\n    ensuref(unique_positions.size() == 4, \"All positions must be unique\");\n\n    // Convert positions to coordinates\n    auto get_coord = [](const string& pos) {\n        int x = pos[0] - 'a';\n        int y = pos[1] - '1';\n        return make_pair(x, y);\n    };\n\n    pair<int, int> w_king = get_coord(positions[2]);\n    pair<int, int> b_king = get_coord(positions[3]);\n\n    // Ensure kings cannot take each other (they are not adjacent)\n    int dx = abs(w_king.first - b_king.first);\n    int dy = abs(w_king.second - b_king.second);\n    ensuref(dx > 1 || dy > 1, \"Kings cannot be adjacent\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read four positions: two rooks, white king, black king\n    vector<string> positions(4);\n\n    for (int i = 0; i < 4; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        // Each position must be two characters: a-h and 1-8\n        positions[i] = inf.readToken(\"[a-h][1-8]\", \"position\");\n    }\n\n    inf.readEoln();\n    inf.readEof();\n\n    // Ensure all positions are unique\n    std::set<string> unique_positions(positions.begin(), positions.end());\n    ensuref(unique_positions.size() == 4, \"All positions must be unique\");\n\n    // Convert positions to coordinates\n    auto get_coord = [](const string& pos) {\n        int x = pos[0] - 'a';\n        int y = pos[1] - '1';\n        return make_pair(x, y);\n    };\n\n    pair<int, int> w_king = get_coord(positions[2]);\n    pair<int, int> b_king = get_coord(positions[3]);\n\n    // Ensure kings cannot take each other (they are not adjacent)\n    int dx = abs(w_king.first - b_king.first);\n    int dy = abs(w_king.second - b_king.second);\n    ensuref(dx > 1 || dy > 1, \"Kings cannot be adjacent\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read four positions: two rooks, white king, black king\n    vector<string> positions(4);\n\n    for (int i = 0; i < 4; ++i) {\n        if (i > 0)\n            inf.readSpace();\n        // Each position must be two characters: a-h and 1-8\n        positions[i] = inf.readToken(\"[a-h][1-8]\", \"position\");\n    }\n\n    inf.readEoln();\n    inf.readEof();\n\n    // Ensure all positions are unique\n    std::set<string> unique_positions(positions.begin(), positions.end());\n    ensuref(unique_positions.size() == 4, \"All positions must be unique\");\n\n    // Convert positions to coordinates\n    auto get_coord = [](const string& pos) {\n        int x = pos[0] - 'a';\n        int y = pos[1] - '1';\n        return make_pair(x, y);\n    };\n\n    pair<int, int> w_king = get_coord(positions[2]);\n    pair<int, int> b_king = get_coord(positions[3]);\n\n    // Ensure kings cannot take each other (they are not adjacent)\n    int dx = abs(w_king.first - b_king.first);\n    int dy = abs(w_king.second - b_king.second);\n    ensuref(dx > 1 || dy > 1, \"Kings cannot be adjacent\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int BOARD_SIZE = 8;\n\n/* Convert (x, y) in [0..7, 0..7] to standard chess notation, e.g. (0, 0) -> \"a1\", (7, 7)-> \"h8\". */\nstring toChessNotation(int x, int y) {\n    // x -> 'a' + x, y -> '1' + y\n    // x: 0..7 -> 'a'..'h'\n    // y: 0..7 -> '1'..'8'\n    string notation;\n    notation.push_back(char('a' + x));      // file\n    notation.push_back(char('1' + y));      // rank\n    return notation;\n}\n\n/* Check if two squares are adjacent (for the kings).  Adjacent means |dx|<=1 and |dy|<=1. */\nbool kingsAdjacent(int x1, int y1, int x2, int y2) {\n    return (abs(x1 - x2) <= 1 && abs(y1 - y2) <= 1);\n}\n\n/* Generate a random square: (x, y) in [0..7, 0..7]. */\npair<int,int> randomSquare() {\n    int x = rnd.next(BOARD_SIZE); // [0..7]\n    int y = rnd.next(BOARD_SIZE); // [0..7]\n    return make_pair(x, y);\n}\n\n/* Check if a square is already used. */\nbool usedSquare(const vector<pair<int,int>>& used, int x, int y) {\n    for (auto &sq: used) {\n        if (sq.first == x && sq.second == y) return true;\n    }\n    return false;\n}\n\n/* \n   Generate a fully random valid configuration.\n   - 2 White Rooks (WR)\n   - 1 White King (WK)\n   - 1 Black King (BK)\n   - All on distinct squares\n   - BK not adjacent to WK\n*/\nvector<string> generateRandomPosition() {\n    vector<pair<int,int>> used;\n    used.reserve(4);\n\n    // Place black king (BK) first\n    int bx, by;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            bx = sq.first;\n            by = sq.second;\n            used.push_back({bx, by});\n            break;\n        }\n    }\n\n    // Place white king (WK), not adjacent to black king\n    int wx, wy;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second) &&\n            !kingsAdjacent(bx, by, sq.first, sq.second)) \n        {\n            wx = sq.first;\n            wy = sq.second;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // Place 2 white rooks (WR)\n    // No adjacency constraints for rooks, only distinct squares\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            used.push_back({rx2, ry2});\n            break;\n        }\n    }\n\n    // We want to output 2 rooks, then white king, then black king\n    // but the problem statement format is: \"R1 R2 WK BK\"\n    // Positions must be space-separated.\n    vector<string> ret(4);\n    // Rook 1\n    ret[0] = toChessNotation(rx1, ry1);\n    // Rook 2\n    ret[1] = toChessNotation(rx2, ry2);\n    // White King\n    ret[2] = toChessNotation(wx, wy);\n    // Black King\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/*\n   Generate a configuration with black king in a corner or near corner.\n   This might stress some corner-case logic.\n*/\nvector<string> generateCornerPosition() {\n    // Possible corners\n    vector<pair<int,int>> corners = {\n        {0,0}, {0,7}, {7,0}, {7,7}\n    };\n    // Pick a random corner for black king\n    auto corner = corners[rnd.next((int)corners.size())];\n    int bx = corner.first;\n    int by = corner.second;\n\n    vector<pair<int,int>> used;\n    used.push_back({bx, by});\n\n    // White King (not adjacent)\n    int wx, wy;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second) &&\n            !kingsAdjacent(bx, by, sq.first, sq.second)) \n        {\n            wx = sq.first;\n            wy = sq.second;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // 2 Rooks\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            used.push_back({rx2, ry2});\n            break;\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rx1, ry1);\n    ret[1] = toChessNotation(rx2, ry2);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/*\n   Generate a configuration where pieces are somewhat \"clustered\"\n   (BK, WK, rooks near each other) but still valid (kings not adjacent).\n*/\nvector<string> generateClusterPosition() {\n    // We'll pick a random center square for the black king,\n    // then cluster everything around it, but still respecting adjacency (for kings).\n    // center squares are typically from x in [2..5], y in [2..5] to reduce boundary issues\n    int bx = rnd.next(2, 5);\n    int by = rnd.next(2, 5);\n\n    vector<pair<int,int>> used;\n    used.push_back({bx, by});\n\n    // White King: must not be adjacent to BK, \n    // but let's keep it within distance ~2 or ~3 in x & y\n    int wx, wy;\n    for (int attempt = 0; attempt < 10000; attempt++) {\n        int dx = rnd.next(-3, 3);\n        int dy = rnd.next(-3, 3);\n        int xx = bx + dx;\n        int yy = by + dy;\n        if (xx < 0 || xx >= BOARD_SIZE || yy < 0 || yy >= BOARD_SIZE) continue;\n        if (!kingsAdjacent(bx, by, xx, yy) && !usedSquare(used, xx, yy)) {\n            wx = xx;\n            wy = yy;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // Now place 2 rooks near the black king or white king\n    vector<pair<int,int>> rookPositions;\n    while ((int)rookPositions.size() < 2) {\n        // Try a small bounding box around the black/white king\n        // but no overlap with used squares\n        int xx = rnd.next(min(bx, wx) - 2, max(bx, wx) + 2);\n        int yy = rnd.next(min(by, wy) - 2, max(by, wy) + 2);\n        if (xx < 0 || xx >= BOARD_SIZE || yy < 0 || yy >= BOARD_SIZE) continue;\n        if (!usedSquare(used, xx, yy)) {\n            rookPositions.push_back({xx, yy});\n            used.push_back({xx, yy});\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rookPositions[0].first, rookPositions[0].second);\n    ret[1] = toChessNotation(rookPositions[1].first, rookPositions[1].second);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/* \n   Generate a configuration where black king is forced onto an edge (but not corner). \n   White king and rooks placed randomly (valid).\n*/\nvector<string> generateEdgePosition() {\n    // We pick a random edge but not corner: e.g. (0, y), (7, y), (x, 0), (x, 7) but\n    // x,y in [1..6] for non-corner edges in the relevant dimension.\n    // We do a random side:\n    //   0 means left edge (x=0, y in [1..6])\n    //   1 means right edge (x=7, y in [1..6])\n    //   2 means top edge (y=7, x in [1..6])\n    //   3 means bottom edge (y=0, x in [1..6])\n    int side = rnd.next(4);\n    int bx, by;\n    if (side == 0) {\n        bx = 0;\n        by = rnd.next(1, 6);\n    } else if (side == 1) {\n        bx = 7;\n        by = rnd.next(1, 6);\n    } else if (side == 2) {\n        by = 7;\n        bx = rnd.next(1, 6);\n    } else {\n        by = 0;\n        bx = rnd.next(1, 6);\n    }\n\n    vector<pair<int,int>> used;\n    used.push_back({bx, by});\n\n    // White king\n    int wx, wy;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second) &&\n            !kingsAdjacent(bx, by, sq.first, sq.second))\n        {\n            wx = sq.first;\n            wy = sq.second;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // 2 rooks\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            break;\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rx1, ry1);\n    ret[1] = toChessNotation(rx2, ry2);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/* \n   A configuration that tries to place the black king and white king in almost-adjacent squares \n   (but still not truly adjacent), to test borderline adjacency constraints.\n*/\nvector<string> generateNearKingsPosition() {\n    // We'll place black king randomly, then place white king \"near\" but not adjacent,\n    // e.g. with Manhattan distance ~2 or so.\n    vector<pair<int,int>> used;\n    int bx, by;\n    auto bksq = randomSquare();\n    bx = bksq.first;\n    by = bksq.second;\n    used.push_back({bx, by});\n\n    // pick a square that is close but not within immediate adjacency.\n    // We'll do a BFS of rings around (bx,by) from distance=2..4\n    // or just random picks from a limited bounding box.\n    int wx, wy;\n    bool placed = false;\n    for (int attempt = 0; attempt < 10000 && !placed; attempt++) {\n        int dx = rnd.next(-4, 4);\n        int dy = rnd.next(-4, 4);\n        int xx = bx + dx;\n        int yy = by + dy;\n        if (xx < 0 || xx >= BOARD_SIZE || yy < 0 || yy >= BOARD_SIZE) continue;\n        if (!usedSquare(used, xx, yy) && !kingsAdjacent(bx, by, xx, yy)) {\n            // Also let's require that the distance is less than or equal to 3 in Manhattan sense\n            if (abs(dx) + abs(dy) <= 3 && (dx != 0 || dy != 0)) {\n                wx = xx;\n                wy = yy;\n                used.push_back({wx, wy});\n                placed = true;\n            }\n        }\n    }\n    // if still not placed, fallback to a normal random approach\n    if(!placed) {\n        while(true) {\n            auto sq = randomSquare();\n            if (!usedSquare(used, sq.first, sq.second) &&\n                !kingsAdjacent(bx, by, sq.first, sq.second)) {\n                wx = sq.first;\n                wy = sq.second;\n                used.push_back({wx, wy});\n                break;\n            }\n        }\n    }\n\n    // now place 2 rooks\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            break;\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rx1, ry1);\n    ret[1] = toChessNotation(rx2, ry2);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // We'll allow a single parameter 'mode' to pick how we generate the board.\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // We only generate and print ONE test case per execution.\n    // The user will run this multiple times with different modes / seeds.\n    vector<string> ans;\n    if (mode == \"random\") {\n        ans = generateRandomPosition();\n    } else if (mode == \"corner\") {\n        ans = generateCornerPosition();\n    } else if (mode == \"cluster\") {\n        ans = generateClusterPosition();\n    } else if (mode == \"edge\") {\n        ans = generateEdgePosition();\n    } else if (mode == \"nearkings\") {\n        ans = generateNearKingsPosition();\n    } else {\n        // fallback\n        ans = generateRandomPosition();\n    }\n\n    // Output the four positions in the order: R1 R2 WhiteKing BlackKing\n    // space-separated on one line.\n    // e.g. \"a1 h8 c5 d4\"\n    printf(\"%s %s %s %s\\n\", ans[0].c_str(), ans[1].c_str(), ans[2].c_str(), ans[3].c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int BOARD_SIZE = 8;\n\n/* Convert (x, y) in [0..7, 0..7] to standard chess notation, e.g. (0, 0) -> \"a1\", (7, 7)-> \"h8\". */\nstring toChessNotation(int x, int y) {\n    // x -> 'a' + x, y -> '1' + y\n    // x: 0..7 -> 'a'..'h'\n    // y: 0..7 -> '1'..'8'\n    string notation;\n    notation.push_back(char('a' + x));      // file\n    notation.push_back(char('1' + y));      // rank\n    return notation;\n}\n\n/* Check if two squares are adjacent (for the kings).  Adjacent means |dx|<=1 and |dy|<=1. */\nbool kingsAdjacent(int x1, int y1, int x2, int y2) {\n    return (abs(x1 - x2) <= 1 && abs(y1 - y2) <= 1);\n}\n\n/* Generate a random square: (x, y) in [0..7, 0..7]. */\npair<int,int> randomSquare() {\n    int x = rnd.next(BOARD_SIZE); // [0..7]\n    int y = rnd.next(BOARD_SIZE); // [0..7]\n    return make_pair(x, y);\n}\n\n/* Check if a square is already used. */\nbool usedSquare(const vector<pair<int,int>>& used, int x, int y) {\n    for (auto &sq: used) {\n        if (sq.first == x && sq.second == y) return true;\n    }\n    return false;\n}\n\n/* \n   Generate a fully random valid configuration.\n   - 2 White Rooks (WR)\n   - 1 White King (WK)\n   - 1 Black King (BK)\n   - All on distinct squares\n   - BK not adjacent to WK\n*/\nvector<string> generateRandomPosition() {\n    vector<pair<int,int>> used;\n    used.reserve(4);\n\n    // Place black king (BK) first\n    int bx, by;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            bx = sq.first;\n            by = sq.second;\n            used.push_back({bx, by});\n            break;\n        }\n    }\n\n    // Place white king (WK), not adjacent to black king\n    int wx, wy;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second) &&\n            !kingsAdjacent(bx, by, sq.first, sq.second)) \n        {\n            wx = sq.first;\n            wy = sq.second;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // Place 2 white rooks (WR)\n    // No adjacency constraints for rooks, only distinct squares\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            used.push_back({rx2, ry2});\n            break;\n        }\n    }\n\n    // We want to output 2 rooks, then white king, then black king\n    // but the problem statement format is: \"R1 R2 WK BK\"\n    // Positions must be space-separated.\n    vector<string> ret(4);\n    // Rook 1\n    ret[0] = toChessNotation(rx1, ry1);\n    // Rook 2\n    ret[1] = toChessNotation(rx2, ry2);\n    // White King\n    ret[2] = toChessNotation(wx, wy);\n    // Black King\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/*\n   Generate a configuration with black king in a corner or near corner.\n   This might stress some corner-case logic.\n*/\nvector<string> generateCornerPosition() {\n    // Possible corners\n    vector<pair<int,int>> corners = {\n        {0,0}, {0,7}, {7,0}, {7,7}\n    };\n    // Pick a random corner for black king\n    auto corner = corners[rnd.next((int)corners.size())];\n    int bx = corner.first;\n    int by = corner.second;\n\n    vector<pair<int,int>> used;\n    used.push_back({bx, by});\n\n    // White King (not adjacent)\n    int wx, wy;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second) &&\n            !kingsAdjacent(bx, by, sq.first, sq.second)) \n        {\n            wx = sq.first;\n            wy = sq.second;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // 2 Rooks\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            used.push_back({rx2, ry2});\n            break;\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rx1, ry1);\n    ret[1] = toChessNotation(rx2, ry2);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/*\n   Generate a configuration where pieces are somewhat \"clustered\"\n   (BK, WK, rooks near each other) but still valid (kings not adjacent).\n*/\nvector<string> generateClusterPosition() {\n    // We'll pick a random center square for the black king,\n    // then cluster everything around it, but still respecting adjacency (for kings).\n    // center squares are typically from x in [2..5], y in [2..5] to reduce boundary issues\n    int bx = rnd.next(2, 5);\n    int by = rnd.next(2, 5);\n\n    vector<pair<int,int>> used;\n    used.push_back({bx, by});\n\n    // White King: must not be adjacent to BK, \n    // but let's keep it within distance ~2 or ~3 in x & y\n    int wx, wy;\n    for (int attempt = 0; attempt < 10000; attempt++) {\n        int dx = rnd.next(-3, 3);\n        int dy = rnd.next(-3, 3);\n        int xx = bx + dx;\n        int yy = by + dy;\n        if (xx < 0 || xx >= BOARD_SIZE || yy < 0 || yy >= BOARD_SIZE) continue;\n        if (!kingsAdjacent(bx, by, xx, yy) && !usedSquare(used, xx, yy)) {\n            wx = xx;\n            wy = yy;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // Now place 2 rooks near the black king or white king\n    vector<pair<int,int>> rookPositions;\n    while ((int)rookPositions.size() < 2) {\n        // Try a small bounding box around the black/white king\n        // but no overlap with used squares\n        int xx = rnd.next(min(bx, wx) - 2, max(bx, wx) + 2);\n        int yy = rnd.next(min(by, wy) - 2, max(by, wy) + 2);\n        if (xx < 0 || xx >= BOARD_SIZE || yy < 0 || yy >= BOARD_SIZE) continue;\n        if (!usedSquare(used, xx, yy)) {\n            rookPositions.push_back({xx, yy});\n            used.push_back({xx, yy});\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rookPositions[0].first, rookPositions[0].second);\n    ret[1] = toChessNotation(rookPositions[1].first, rookPositions[1].second);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/* \n   Generate a configuration where black king is forced onto an edge (but not corner). \n   White king and rooks placed randomly (valid).\n*/\nvector<string> generateEdgePosition() {\n    // We pick a random edge but not corner: e.g. (0, y), (7, y), (x, 0), (x, 7) but\n    // x,y in [1..6] for non-corner edges in the relevant dimension.\n    // We do a random side:\n    //   0 means left edge (x=0, y in [1..6])\n    //   1 means right edge (x=7, y in [1..6])\n    //   2 means top edge (y=7, x in [1..6])\n    //   3 means bottom edge (y=0, x in [1..6])\n    int side = rnd.next(4);\n    int bx, by;\n    if (side == 0) {\n        bx = 0;\n        by = rnd.next(1, 6);\n    } else if (side == 1) {\n        bx = 7;\n        by = rnd.next(1, 6);\n    } else if (side == 2) {\n        by = 7;\n        bx = rnd.next(1, 6);\n    } else {\n        by = 0;\n        bx = rnd.next(1, 6);\n    }\n\n    vector<pair<int,int>> used;\n    used.push_back({bx, by});\n\n    // White king\n    int wx, wy;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second) &&\n            !kingsAdjacent(bx, by, sq.first, sq.second))\n        {\n            wx = sq.first;\n            wy = sq.second;\n            used.push_back({wx, wy});\n            break;\n        }\n    }\n\n    // 2 rooks\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            break;\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rx1, ry1);\n    ret[1] = toChessNotation(rx2, ry2);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\n/* \n   A configuration that tries to place the black king and white king in almost-adjacent squares \n   (but still not truly adjacent), to test borderline adjacency constraints.\n*/\nvector<string> generateNearKingsPosition() {\n    // We'll place black king randomly, then place white king \"near\" but not adjacent,\n    // e.g. with Manhattan distance ~2 or so.\n    vector<pair<int,int>> used;\n    int bx, by;\n    auto bksq = randomSquare();\n    bx = bksq.first;\n    by = bksq.second;\n    used.push_back({bx, by});\n\n    // pick a square that is close but not within immediate adjacency.\n    // We'll do a BFS of rings around (bx,by) from distance=2..4\n    // or just random picks from a limited bounding box.\n    int wx, wy;\n    bool placed = false;\n    for (int attempt = 0; attempt < 10000 && !placed; attempt++) {\n        int dx = rnd.next(-4, 4);\n        int dy = rnd.next(-4, 4);\n        int xx = bx + dx;\n        int yy = by + dy;\n        if (xx < 0 || xx >= BOARD_SIZE || yy < 0 || yy >= BOARD_SIZE) continue;\n        if (!usedSquare(used, xx, yy) && !kingsAdjacent(bx, by, xx, yy)) {\n            // Also let's require that the distance is less than or equal to 3 in Manhattan sense\n            if (abs(dx) + abs(dy) <= 3 && (dx != 0 || dy != 0)) {\n                wx = xx;\n                wy = yy;\n                used.push_back({wx, wy});\n                placed = true;\n            }\n        }\n    }\n    // if still not placed, fallback to a normal random approach\n    if(!placed) {\n        while(true) {\n            auto sq = randomSquare();\n            if (!usedSquare(used, sq.first, sq.second) &&\n                !kingsAdjacent(bx, by, sq.first, sq.second)) {\n                wx = sq.first;\n                wy = sq.second;\n                used.push_back({wx, wy});\n                break;\n            }\n        }\n    }\n\n    // now place 2 rooks\n    int rx1, ry1;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx1 = sq.first;\n            ry1 = sq.second;\n            used.push_back({rx1, ry1});\n            break;\n        }\n    }\n\n    int rx2, ry2;\n    while(true) {\n        auto sq = randomSquare();\n        if (!usedSquare(used, sq.first, sq.second)) {\n            rx2 = sq.first;\n            ry2 = sq.second;\n            break;\n        }\n    }\n\n    vector<string> ret(4);\n    ret[0] = toChessNotation(rx1, ry1);\n    ret[1] = toChessNotation(rx2, ry2);\n    ret[2] = toChessNotation(wx, wy);\n    ret[3] = toChessNotation(bx, by);\n    return ret;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // We'll allow a single parameter 'mode' to pick how we generate the board.\n    string mode = opt<string>(\"mode\", \"random\");\n\n    // We only generate and print ONE test case per execution.\n    // The user will run this multiple times with different modes / seeds.\n    vector<string> ans;\n    if (mode == \"random\") {\n        ans = generateRandomPosition();\n    } else if (mode == \"corner\") {\n        ans = generateCornerPosition();\n    } else if (mode == \"cluster\") {\n        ans = generateClusterPosition();\n    } else if (mode == \"edge\") {\n        ans = generateEdgePosition();\n    } else if (mode == \"nearkings\") {\n        ans = generateNearKingsPosition();\n    } else {\n        // fallback\n        ans = generateRandomPosition();\n    }\n\n    // Output the four positions in the order: R1 R2 WhiteKing BlackKing\n    // space-separated on one line.\n    // e.g. \"a1 h8 c5 d4\"\n    printf(\"%s %s %s %s\\n\", ans[0].c_str(), ans[1].c_str(), ans[2].c_str(), ans[3].c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -mode random\n./gen -mode random\n./gen -mode random\n./gen -mode corner\n./gen -mode corner\n./gen -mode edge\n./gen -mode edge\n./gen -mode cluster\n./gen -mode cluster\n./gen -mode nearkings\n./gen -mode nearkings\n\n./gen -mode random\n./gen -mode corner\n./gen -mode cluster\n./gen -mode edge\n./gen -mode nearkings\n./gen -mode random\n./gen -mode cluster\n./gen -mode corner\n./gen -mode nearkings\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:20.112413",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "42/C",
      "title": "C. Safe cracking",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line of the input contains four space-separated integer positive numbers not greater than 109 each — four numbers on the circle in consecutive order.",
      "output_spec": "OutputThe output should contain \"-1\" (quotes for clarity) if the safe is secure, that is it's impossible to crack it. Otherwise, output should contain the sequence of operations (one operations per line) leading to unlocking the safe. You don't have to minimize the number of operations, but it should not exceed 1000. To make things clear, assume numbers stand on positions 1 through 4. Each operation is encoded by two symbols. If the following operation is dividing then first symbol is '/'; otherwise it's '+' (addition). The second symbol is the position of the first number in pair in consecutive order. (see samples for clarification).If there are several solutions, output any of them.",
      "sample_tests": "ExamplesInputCopy1 1 1 1OutputCopyInputCopy1 2 4 2OutputCopy/2/3InputCopy3 3 1 1OutputCopy+1/1/1InputCopy2 1 2 4OutputCopy/3/4",
      "description": "C. Safe cracking\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line of the input contains four space-separated integer positive numbers not greater than 109 each — four numbers on the circle in consecutive order.\n\nOutputThe output should contain \"-1\" (quotes for clarity) if the safe is secure, that is it's impossible to crack it. Otherwise, output should contain the sequence of operations (one operations per line) leading to unlocking the safe. You don't have to minimize the number of operations, but it should not exceed 1000. To make things clear, assume numbers stand on positions 1 through 4. Each operation is encoded by two symbols. If the following operation is dividing then first symbol is '/'; otherwise it's '+' (addition). The second symbol is the position of the first number in pair in consecutive order. (see samples for clarification).If there are several solutions, output any of them.\n\nInputCopy1 1 1 1OutputCopyInputCopy1 2 4 2OutputCopy/2/3InputCopy3 3 1 1OutputCopy+1/1/1InputCopy2 1 2 4OutputCopy/3/4\n\nInputCopy1 1 1 1\n\nInputCopy1 2 4 2\n\nOutputCopy/2/3\n\nInputCopy3 3 1 1\n\nOutputCopy+1/1/1\n\nInputCopy2 1 2 4\n\nOutputCopy/3/4",
      "solutions": [
        {
          "title": "Codeforces beta round #41 - Codeforces",
          "content": "Hi everyone.The today's contest is presented by us: cerealguy and yaro. We used to study in school together and Volodya studied there with us. So he will be the contest's hero: Volodya is going to cook in a kitchen, visit a museum, try to crack a safe, travel to an unusual city and even use his magical abilities.We are grateful to the Codeforces team and especially to Artem Rakhov who helped us to prepare the contest and wrote alternative solutions.We hope problems will suit your taste.Good luck!Update: Solutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/882",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 518
        },
        {
          "title": "Solutions for Сodeforces Beta Round #41 - Codeforces",
          "content": "А. Guilty — to the kitchen!Let us reformulate the statement: we need to find the maximum possible value of x (mentioned in the statement) so that the amount of each ingredient will be enough. Clearly, such x equals min(b_i / a_i). Now it suffices to take minimum of the two values: soup volume we gained and the volume of the pan.В. Game of chess unfinished.In this problem you are to check exactly what the statement says: if the king's position and all the positions reachable by him in one turn are \"beaten\", — that's a mate. Thus, we have to determine \"beaten\" positions correctly. Let us remove the black king from the chessboard, leave the positions of  the rooks \"unbeaten\" (not to forget about possible taking of the rook by the black king), mark positions reachable by rooks \"beaten\" and then mark positions reachable by white king as \"beaten\".С. Safe cracking.The answer in this problem is always affirmative, which means it is always possible to make all the numbers equal to one. Greedy approach (here we somehow make two adjacent numbers even and then divide them by two) leads the sum of numbers to become less or equal to six in logarithmic (and certainly less than 1000) number of operations. There are several ways do deal with extremal cases: for instance, many of the participants coped with this by the analysis of all of the cases left. The greedy approach only is not sufficient: the crucial test for hacks was (1 1 1 2).D. Strange town.Let us associate some numbers a_i with the vertices of the graph. If, for each edge, we assign it the sum of its endpoints' numbers, then the sum of prices along arbitrary hamiltonian cycle will be equal to the doubled sum of a_i. Therefore, it suffices us to devise such numbers a_i so that their pairwise sums will be distinct (as the edge prices should be distinct). As all of the edge prices are bounded above by 1000, we have to think of an efficient strategy to obtain such a_i. Let's choose them in greedy way, so that newly added a_i should not be equal to (a_p + a_q - a_k) for each triple of already chosen a_p, a_q, a_k. It is clear that a_n = O(n^3) as there are O(n^3) \"blocking\" triples (p, q, k).Another idea lies in that equality AB+CD=AC+BD should hold for every quadruple of distinct vertices A, B, C, D (summands stay for edge prices), because a hamiltonial cycle with edges AB and CD can be easily rearranged in the cycle with edges AC and BD and the sums of these cycles should be equal.You may think of how this idea was used by jury to check your solutions in exact and fast way.The solution of the problem E will appear soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/884",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2608
        },
        {
          "title": "Solution of task е, Codeforces beta round #41 - Codeforces",
          "content": "First note that a valid graph of wormholes is either connected or consists of two connectivity components with one exit in each. The proof is in the end of this text. Also note that the first option is never optimal because one edge can be removed to get the second option. Let's build a minimal spanning tree of the input graph. If it contains more than two components, the answer for each query is -1. If it contains two components, the answer is -1 if both objects are in the same component, and the weight of the spanning tree otherwise. The most interesting case is one component: we need to cut the spanning tree into two trees containing one exit each and having minimal sum of weights (not actually cut but get the sum of weights of the resulting trees). It can be done by (virtually) removing the most heavy edge on the path between the exits; so the only thing we need to know is the weight of such edge. It can be done with LCA algorithm: for each node precalculate upward jumps of height 2^k, k=0..log n, but also for each jump calculate the maximum weight of an edge on the path of this jump. Then you can split the path a-b in paths a-lca(a,b) and b-lca(a,b) and calculate the maximum weight on each of them in O(log n) using the precalculated values.Now the proof:First, it's easy to see that such graph of wormholes is valid: we can enter any exit, cross all tunnels in this component, go to another component (there is always an edge between components because tunnel graph is connected), cross all tunnels there, cross all remaining tunnels between components and leave using one of the exits. Besides these components A and B let there be another component C (and maybe some other components) and the number of tunnels between A and C is odd, between B and C - even; in this case it's impossible to traverse all tunnels once and return to A or B, so this wormhole graph is invalid. If both exits are in the same component and there is another component and the number of tunnels between them is odd, it's invalid too. So the only options left are those mentioned in the beginning.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/887",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2099
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> numbers = inf.readInts(4, 1, 1000000000, \"numbers\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> numbers = inf.readInts(4, 1, 1000000000, \"numbers\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <vector>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> numbers = inf.readInts(4, 1, 1000000000, \"numbers\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    // Register the testlib checker\n    registerTestlibCmd(argc, argv);\n\n    // Read the initial four numbers from the input file\n    vector<int> nums(4);\n    for (int i = 0; i < 4; ++i) {\n        nums[i] = inf.readInt(1, 1000000000, format(\"initial number #%d\", i + 1).c_str());\n    }\n\n    // Read the contestant's output\n    vector<string> operations;\n    while (!ouf.eof()) {\n        string line = ouf.readLine();\n        if (line == \"\") continue;  // Skip empty lines\n        operations.push_back(line);\n    }\n\n    // If the contestant outputs '-1', it's incorrect since the safe can always be cracked\n    if (operations.size() == 1 && operations[0] == \"-1\") {\n        quitf(_wa, \"Incorrectly claimed that the safe is secure (output '-1')\");\n    }\n\n    // If no operations are provided\n    if (operations.empty()) {\n        // Accept if the initial numbers are all ones\n        if (nums == vector<int>{1, 1, 1, 1}) {\n            quitf(_ok, \"No operations needed, safe is already cracked\");\n        } else {\n            quitf(_wa, \"No operations provided but the initial numbers are not all ones\");\n        }\n    }\n\n    // Ensure the number of operations does not exceed 1000\n    if ((int)operations.size() > 1000) {\n        quitf(_wa, \"Number of operations exceeds 1000\");\n    }\n\n    // Apply each operation\n    for (size_t idx = 0; idx < operations.size(); ++idx) {\n        string op = operations[idx];\n        if (op.size() != 2) {\n            quitf(_wa, \"Invalid format in operation #%d: '%s'\", idx + 1, op.c_str());\n        }\n        char action = op[0];\n        char posChar = op[1];\n\n        if (action != '+' && action != '/') {\n            quitf(_wa, \"Invalid action '%c' in operation #%d\", action, idx + 1);\n        }\n        if (posChar < '1' || posChar > '4') {\n            quitf(_wa, \"Invalid position '%c' in operation #%d\", posChar, idx + 1);\n        }\n\n        int pos = posChar - '1'; // Convert '1'-'4' to 0-3\n        int next_pos = (pos + 1) % 4;\n\n        if (action == '+') {\n            // Increase both numbers by 1\n            nums[pos] += 1;\n            nums[next_pos] += 1;\n        } else {\n            // Division operation\n            if (nums[pos] % 2 != 0 || nums[next_pos] % 2 != 0) {\n                quitf(_wa, \"Cannot divide numbers at positions %d and %d in operation #%d as they are not both even\", pos + 1, next_pos + 1, idx + 1);\n            }\n            nums[pos] /= 2;\n            nums[next_pos] /= 2;\n        }\n    }\n\n    // Check if all numbers are ones\n    if (nums == vector<int>{1, 1, 1, 1}) {\n        quitf(_ok, \"Safe cracked successfully\");\n    } else {\n        quitf(_wa, \"After applying all operations, numbers are not all ones\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000000000); // Default maximum value is 1e9\n\n    // Optional parameters to specify custom numbers\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    int d = opt<int>(\"d\", -1);\n\n    // If custom numbers are provided, use them\n    if (a != -1 && b != -1 && c != -1 && d != -1) {\n        // Ensure the numbers are within the allowed range\n        ensure(1 <= a && a <= max_value);\n        ensure(1 <= b && b <= max_value);\n        ensure(1 <= c && c <= max_value);\n        ensure(1 <= d && d <= max_value);\n\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    } else if (type == \"ones\") {\n        // All numbers are 1\n        printf(\"1 1 1 1\\n\");\n    } else if (type == \"max\") {\n        // All numbers are the maximum value\n        printf(\"%d %d %d %d\\n\", max_value, max_value, max_value, max_value);\n    } else if (type == \"impossible\") {\n        // An example of a potentially impossible test case\n        printf(\"1 1 1 2\\n\");\n    } else if (type == \"impossible2\") {\n        printf(\"1 1 1 3\\n\");\n    } else if (type == \"impossible3\") {\n        printf(\"7 7 7 7\\n\");\n    } else if (type == \"impossible4\") {\n        printf(\"2 3 5 7\\n\");\n    } else {\n        // Default: generate random numbers within the specified range\n        int a = rnd.next(1, max_value);\n        int b = rnd.next(1, max_value);\n        int c = rnd.next(1, max_value);\n        int d = rnd.next(1, max_value);\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 1000000000); // Default maximum value is 1e9\n\n    // Optional parameters to specify custom numbers\n    int a = opt<int>(\"a\", -1);\n    int b = opt<int>(\"b\", -1);\n    int c = opt<int>(\"c\", -1);\n    int d = opt<int>(\"d\", -1);\n\n    // If custom numbers are provided, use them\n    if (a != -1 && b != -1 && c != -1 && d != -1) {\n        // Ensure the numbers are within the allowed range\n        ensure(1 <= a && a <= max_value);\n        ensure(1 <= b && b <= max_value);\n        ensure(1 <= c && c <= max_value);\n        ensure(1 <= d && d <= max_value);\n\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    } else if (type == \"ones\") {\n        // All numbers are 1\n        printf(\"1 1 1 1\\n\");\n    } else if (type == \"max\") {\n        // All numbers are the maximum value\n        printf(\"%d %d %d %d\\n\", max_value, max_value, max_value, max_value);\n    } else if (type == \"impossible\") {\n        // An example of a potentially impossible test case\n        printf(\"1 1 1 2\\n\");\n    } else if (type == \"impossible2\") {\n        printf(\"1 1 1 3\\n\");\n    } else if (type == \"impossible3\") {\n        printf(\"7 7 7 7\\n\");\n    } else if (type == \"impossible4\") {\n        printf(\"2 3 5 7\\n\");\n    } else {\n        // Default: generate random numbers within the specified range\n        int a = rnd.next(1, max_value);\n        int b = rnd.next(1, max_value);\n        int c = rnd.next(1, max_value);\n        int d = rnd.next(1, max_value);\n        printf(\"%d %d %d %d\\n\", a, b, c, d);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type ones\n\n./gen -type max -max_value 1000000000\n./gen -type max -max_value 999999999\n./gen -type max -max_value 100000000\n./gen -type max -max_value 10000000\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -a 1 -b 1 -c 2 -d 3\n./gen -a 1 -b 2 -c 4 -d 8\n./gen -a 1 -b 1 -c 1 -d 2\n./gen -a 1000000000 -b 1 -c 1 -d 1\n./gen -a 1 -b 1000000000 -c 1 -d 1\n./gen -a 1 -b 1 -c 1 -d 1000000000\n./gen -a 1 -b 1 -c 999999999 -d 999999999\n\n./gen -type impossible\n./gen -type impossible2\n./gen -type impossible3\n./gen -type impossible4\n\n./gen -a 2 -b 3 -c 2 -d 3\n./gen -a 2 -b 4 -c 8 -d 16\n\n./gen -a 123456789 -b 987654321 -c 111111111 -d 999999999\n./gen -a 2 -b 2 -c 2 -d 3\n\n./gen -type random -max_value 1\n./gen -type random -max_value 2\n./gen -type random -max_value 3\n\n./gen -type random -max_value 10\n./gen -type random -max_value 100\n./gen -type random -max_value 1000\n./gen -type random -max_value 10000\n\n./gen -type random\n./gen -type random\n\n./gen -a 1 -b 1 -c 1 -d 1\n\n# Note: All numbers must be positive integers, so ensure that when providing custom numbers, they are greater than or equal to 1 and do not exceed the specified 'max_value'.\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:22.244089",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "42/D",
      "title": "D. Strange town",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputInput contains just one natural number (3 ≤ N ≤ 20) — the number of town attractions.",
      "output_spec": "OutputOutput should contain N rows containing N positive integer numbers each — the adjacency matrix of the prices graph (thus, j-th number in i-th row should be equal to the price of the road between the j-th and the i-th attraction). Diagonal numbers should be equal to zero. All numbers should not be greater than 1000. All prices should be positive and pairwise distinct. If there are several solutions, output any of them.",
      "sample_tests": "ExamplesInputCopy3OutputCopy0 3 4 3 0 5 4 5 0",
      "description": "D. Strange town\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputInput contains just one natural number (3 ≤ N ≤ 20) — the number of town attractions.\n\nOutputOutput should contain N rows containing N positive integer numbers each — the adjacency matrix of the prices graph (thus, j-th number in i-th row should be equal to the price of the road between the j-th and the i-th attraction). Diagonal numbers should be equal to zero. All numbers should not be greater than 1000. All prices should be positive and pairwise distinct. If there are several solutions, output any of them.\n\nInputCopy3OutputCopy0 3 4 3 0 5 4 5 0\n\nOutputCopy0 3 4 3 0 5 4 5 0",
      "solutions": [
        {
          "title": "Codeforces beta round #41 - Codeforces",
          "content": "Hi everyone.The today's contest is presented by us: cerealguy and yaro. We used to study in school together and Volodya studied there with us. So he will be the contest's hero: Volodya is going to cook in a kitchen, visit a museum, try to crack a safe, travel to an unusual city and even use his magical abilities.We are grateful to the Codeforces team and especially to Artem Rakhov who helped us to prepare the contest and wrote alternative solutions.We hope problems will suit your taste.Good luck!Update: Solutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/882",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 518
        },
        {
          "title": "Solutions for Сodeforces Beta Round #41 - Codeforces",
          "content": "А. Guilty — to the kitchen!Let us reformulate the statement: we need to find the maximum possible value of x (mentioned in the statement) so that the amount of each ingredient will be enough. Clearly, such x equals min(b_i / a_i). Now it suffices to take minimum of the two values: soup volume we gained and the volume of the pan.В. Game of chess unfinished.In this problem you are to check exactly what the statement says: if the king's position and all the positions reachable by him in one turn are \"beaten\", — that's a mate. Thus, we have to determine \"beaten\" positions correctly. Let us remove the black king from the chessboard, leave the positions of  the rooks \"unbeaten\" (not to forget about possible taking of the rook by the black king), mark positions reachable by rooks \"beaten\" and then mark positions reachable by white king as \"beaten\".С. Safe cracking.The answer in this problem is always affirmative, which means it is always possible to make all the numbers equal to one. Greedy approach (here we somehow make two adjacent numbers even and then divide them by two) leads the sum of numbers to become less or equal to six in logarithmic (and certainly less than 1000) number of operations. There are several ways do deal with extremal cases: for instance, many of the participants coped with this by the analysis of all of the cases left. The greedy approach only is not sufficient: the crucial test for hacks was (1 1 1 2).D. Strange town.Let us associate some numbers a_i with the vertices of the graph. If, for each edge, we assign it the sum of its endpoints' numbers, then the sum of prices along arbitrary hamiltonian cycle will be equal to the doubled sum of a_i. Therefore, it suffices us to devise such numbers a_i so that their pairwise sums will be distinct (as the edge prices should be distinct). As all of the edge prices are bounded above by 1000, we have to think of an efficient strategy to obtain such a_i. Let's choose them in greedy way, so that newly added a_i should not be equal to (a_p + a_q - a_k) for each triple of already chosen a_p, a_q, a_k. It is clear that a_n = O(n^3) as there are O(n^3) \"blocking\" triples (p, q, k).Another idea lies in that equality AB+CD=AC+BD should hold for every quadruple of distinct vertices A, B, C, D (summands stay for edge prices), because a hamiltonial cycle with edges AB and CD can be easily rearranged in the cycle with edges AC and BD and the sums of these cycles should be equal.You may think of how this idea was used by jury to check your solutions in exact and fast way.The solution of the problem E will appear soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/884",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2608
        },
        {
          "title": "Solution of task е, Codeforces beta round #41 - Codeforces",
          "content": "First note that a valid graph of wormholes is either connected or consists of two connectivity components with one exit in each. The proof is in the end of this text. Also note that the first option is never optimal because one edge can be removed to get the second option. Let's build a minimal spanning tree of the input graph. If it contains more than two components, the answer for each query is -1. If it contains two components, the answer is -1 if both objects are in the same component, and the weight of the spanning tree otherwise. The most interesting case is one component: we need to cut the spanning tree into two trees containing one exit each and having minimal sum of weights (not actually cut but get the sum of weights of the resulting trees). It can be done by (virtually) removing the most heavy edge on the path between the exits; so the only thing we need to know is the weight of such edge. It can be done with LCA algorithm: for each node precalculate upward jumps of height 2^k, k=0..log n, but also for each jump calculate the maximum weight of an edge on the path of this jump. Then you can split the path a-b in paths a-lca(a,b) and b-lca(a,b) and calculate the maximum weight on each of them in O(log n) using the precalculated values.Now the proof:First, it's easy to see that such graph of wormholes is valid: we can enter any exit, cross all tunnels in this component, go to another component (there is always an edge between components because tunnel graph is connected), cross all tunnels there, cross all remaining tunnels between components and leave using one of the exits. Besides these components A and B let there be another component C (and maybe some other components) and the number of tunnels between A and C is odd, between B and C - even; in this case it's impossible to traverse all tunnels once and return to A or B, so this wormhole graph is invalid. If both exits are in the same component and there is another component and the number of tunnels between them is odd, it's invalid too. So the only options left are those mentioned in the beginning.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/887",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2099
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 20, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 20, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int N = inf.readInt(3, 20, \"N\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read N from the input file\n    int N = inf.readInt(3, 20, \"N\");\n\n    // Read the adjacency matrix from the contestant's output\n    vector<vector<int>> adj(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        // Read N integers for each row\n        for (int j = 0; j < N; j++) {\n            adj[i][j] = ouf.readInt(0, 1000, format(\"adj[%d][%d]\", i + 1, j + 1).c_str());\n            if (i == j && adj[i][j] != 0) {\n                quitf(_wa, \"Diagonal entries must be zero, but adj[%d][%d]=%d\", i + 1, j + 1, adj[i][j]);\n            }\n            if (i != j && adj[i][j] <= 0) {\n                quitf(_wa, \"Edge weights must be positive, but adj[%d][%d]=%d\", i + 1, j + 1, adj[i][j]);\n            }\n        }\n    }\n\n    // Check that the adjacency matrix is symmetric\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (adj[i][j] != adj[j][i]) {\n                quitf(_wa, \"Adjacency matrix is not symmetric at adj[%d][%d]=%d and adj[%d][%d]=%d\",\n                      i + 1, j + 1, adj[i][j], j + 1, i + 1, adj[j][i]);\n            }\n        }\n    }\n\n    // Collect all edge weights and ensure they are pairwise distinct\n    set<int> weights;\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            int w = adj[i][j];\n            if (weights.count(w)) {\n                quitf(_wa, \"Edge weights are not pairwise distinct; duplicate weight %d found\", w);\n            }\n            weights.insert(w);\n        }\n    }\n\n    // Generate random Hamiltonian cycles and check that their total weights are the same\n    const int NUM_CYCLES = 10000; // Number of cycles to check\n    vector<int64_t> cycle_weights;\n    mt19937 rng(239); // Fixed seed for reproducibility\n\n    for (int k = 0; k < NUM_CYCLES; k++) {\n        vector<int> perm(N);\n        iota(perm.begin(), perm.end(), 0); // Fill with 0 to N-1\n        shuffle(perm.begin(), perm.end(), rng);\n\n        // Compute total weight along this cycle\n        int64_t total_weight = 0;\n        for (int i = 0; i < N; i++) {\n            int u = perm[i];\n            int v = perm[(i + 1) % N]; // Next node in the cycle (wrap around)\n            total_weight += adj[u][v];\n        }\n        cycle_weights.push_back(total_weight);\n    }\n\n    // Check that all cycle weights are the same\n    for (int i = 1; i < (int)cycle_weights.size(); i++) {\n        if (cycle_weights[i] != cycle_weights[0]) {\n            quitf(_wa, \"The total weights of cycles differ: %lld vs %lld\", cycle_weights[0], cycle_weights[i]);\n        }\n    }\n\n    quitf(_ok, \"All cycles have the same total weight %lld\", cycle_weights[0]);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    assert(3 <= n && n <= 20);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    assert(3 <= n && n <= 20);\n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 6\n./gen -n 7\n./gen -n 8\n./gen -n 9\n./gen -n 10\n./gen -n 11\n./gen -n 12\n./gen -n 13\n./gen -n 14\n./gen -n 15\n./gen -n 16\n./gen -n 17\n./gen -n 18\n./gen -n 19\n./gen -n 20\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:24.437368",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "42/E",
      "title": "E. Baldman and the military",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputFirst line of the input contains a single natural number n (2 ≤ n ≤ 100000) — the number of objects on the military base. The second line — one number m (1 ≤ m ≤ 200000) — the number of the wormholes Baldman can make. The following m lines describe the wormholes: each line contains three integer numbers a, b, c (1 ≤ a, b ≤ n, 1 ≤ c ≤ 100000) — the numbers of objects which can be connected and the number of hair Baldman has to spend to make this wormhole.The next line contains one natural number q (1 ≤ q ≤ 100000) — the number of queries. Finally, the last q lines contain a description of one query each — a pair of numbers of different objects ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). There could be more than one wormhole between a pair of objects.",
      "output_spec": "OutputYour program should output q lines, one for each query. The i-th line should contain a single integer number — the answer for i-th query: the minimum cost (in hair) of a system of wormholes allowing the optimal patrol for any system of tunnels (satisfying the given conditions) if ai and bi are the two objects connected with surface, or \"-1\" if such system of wormholes cannot be made.",
      "sample_tests": "ExamplesInputCopy211 2 311 2OutputCopy0InputCopy311 2 321 21 3OutputCopy-13",
      "description": "E. Baldman and the military\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputFirst line of the input contains a single natural number n (2 ≤ n ≤ 100000) — the number of objects on the military base. The second line — one number m (1 ≤ m ≤ 200000) — the number of the wormholes Baldman can make. The following m lines describe the wormholes: each line contains three integer numbers a, b, c (1 ≤ a, b ≤ n, 1 ≤ c ≤ 100000) — the numbers of objects which can be connected and the number of hair Baldman has to spend to make this wormhole.The next line contains one natural number q (1 ≤ q ≤ 100000) — the number of queries. Finally, the last q lines contain a description of one query each — a pair of numbers of different objects ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi). There could be more than one wormhole between a pair of objects.\n\nOutputYour program should output q lines, one for each query. The i-th line should contain a single integer number — the answer for i-th query: the minimum cost (in hair) of a system of wormholes allowing the optimal patrol for any system of tunnels (satisfying the given conditions) if ai and bi are the two objects connected with surface, or \"-1\" if such system of wormholes cannot be made.\n\nInputCopy211 2 311 2OutputCopy0InputCopy311 2 321 21 3OutputCopy-13\n\nInputCopy211 2 311 2\n\nOutputCopy0\n\nInputCopy311 2 321 21 3\n\nOutputCopy-13",
      "solutions": [
        {
          "title": "Codeforces beta round #41 - Codeforces",
          "content": "Hi everyone.The today's contest is presented by us: cerealguy and yaro. We used to study in school together and Volodya studied there with us. So he will be the contest's hero: Volodya is going to cook in a kitchen, visit a museum, try to crack a safe, travel to an unusual city and even use his magical abilities.We are grateful to the Codeforces team and especially to Artem Rakhov who helped us to prepare the contest and wrote alternative solutions.We hope problems will suit your taste.Good luck!Update: Solutions",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/882",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 518
        },
        {
          "title": "Solutions for Сodeforces Beta Round #41 - Codeforces",
          "content": "А. Guilty — to the kitchen!Let us reformulate the statement: we need to find the maximum possible value of x (mentioned in the statement) so that the amount of each ingredient will be enough. Clearly, such x equals min(b_i / a_i). Now it suffices to take minimum of the two values: soup volume we gained and the volume of the pan.В. Game of chess unfinished.In this problem you are to check exactly what the statement says: if the king's position and all the positions reachable by him in one turn are \"beaten\", — that's a mate. Thus, we have to determine \"beaten\" positions correctly. Let us remove the black king from the chessboard, leave the positions of  the rooks \"unbeaten\" (not to forget about possible taking of the rook by the black king), mark positions reachable by rooks \"beaten\" and then mark positions reachable by white king as \"beaten\".С. Safe cracking.The answer in this problem is always affirmative, which means it is always possible to make all the numbers equal to one. Greedy approach (here we somehow make two adjacent numbers even and then divide them by two) leads the sum of numbers to become less or equal to six in logarithmic (and certainly less than 1000) number of operations. There are several ways do deal with extremal cases: for instance, many of the participants coped with this by the analysis of all of the cases left. The greedy approach only is not sufficient: the crucial test for hacks was (1 1 1 2).D. Strange town.Let us associate some numbers a_i with the vertices of the graph. If, for each edge, we assign it the sum of its endpoints' numbers, then the sum of prices along arbitrary hamiltonian cycle will be equal to the doubled sum of a_i. Therefore, it suffices us to devise such numbers a_i so that their pairwise sums will be distinct (as the edge prices should be distinct). As all of the edge prices are bounded above by 1000, we have to think of an efficient strategy to obtain such a_i. Let's choose them in greedy way, so that newly added a_i should not be equal to (a_p + a_q - a_k) for each triple of already chosen a_p, a_q, a_k. It is clear that a_n = O(n^3) as there are O(n^3) \"blocking\" triples (p, q, k).Another idea lies in that equality AB+CD=AC+BD should hold for every quadruple of distinct vertices A, B, C, D (summands stay for edge prices), because a hamiltonial cycle with edges AB and CD can be easily rearranged in the cycle with edges AC and BD and the sums of these cycles should be equal.You may think of how this idea was used by jury to check your solutions in exact and fast way.The solution of the problem E will appear soon.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/884",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2608
        },
        {
          "title": "Solution of task е, Codeforces beta round #41 - Codeforces",
          "content": "First note that a valid graph of wormholes is either connected or consists of two connectivity components with one exit in each. The proof is in the end of this text. Also note that the first option is never optimal because one edge can be removed to get the second option. Let's build a minimal spanning tree of the input graph. If it contains more than two components, the answer for each query is -1. If it contains two components, the answer is -1 if both objects are in the same component, and the weight of the spanning tree otherwise. The most interesting case is one component: we need to cut the spanning tree into two trees containing one exit each and having minimal sum of weights (not actually cut but get the sum of weights of the resulting trees). It can be done by (virtually) removing the most heavy edge on the path between the exits; so the only thing we need to know is the weight of such edge. It can be done with LCA algorithm: for each node precalculate upward jumps of height 2^k, k=0..log n, but also for each jump calculate the maximum weight of an edge on the path of this jump. Then you can split the path a-b in paths a-lca(a,b) and b-lca(a,b) and calculate the maximum weight on each of them in O(log n) using the precalculated values.Now the proof:First, it's easy to see that such graph of wormholes is valid: we can enter any exit, cross all tunnels in this component, go to another component (there is always an edge between components because tunnel graph is connected), cross all tunnels there, cross all remaining tunnels between components and leave using one of the exits. Besides these components A and B let there be another component C (and maybe some other components) and the number of tunnels between A and C is odd, between B and C - even; in this case it's impossible to traverse all tunnels once and return to A or B, so this wormhole graph is invalid. If both exits are in the same component and there is another component and the number of tunnels between them is odd, it's invalid too. So the only options left are those mentioned in the beginning.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/887",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2099
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100000, \"c\");\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100000, \"c\");\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    \n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b\");\n        inf.readSpace();\n        int c = inf.readInt(1, 100000, \"c\");\n        inf.readEoln();\n    }\n\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"ai (%d) should not be equal to bi (%d)\", ai, bi);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 2 * n);\n    int q = opt<int>(\"q\", n);\n    int minc = opt<int>(\"minc\", 1);\n    int maxc = opt<int>(\"maxc\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    int is_n_odd = opt<int>(\"n_odd\", 0);\n\n    if (is_n_odd) {\n        if (n % 2 == 0) n += 1;\n    } else {\n        if (n % 2 == 1) n += 1;\n    }\n\n    vector<tuple<int, int, int>> wormholes;\n\n    if (type == \"random\") {\n        // Generate m random wormholes\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(minc, maxc);\n            wormholes.emplace_back(a, b, c);\n        }\n    } else if (type == \"complete\") {\n        // Generate wormholes between all pairs of nodes\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a+1; b <= n; ++b) {\n                int c = rnd.next(minc, maxc);\n                wormholes.emplace_back(a, b, c);\n            }\n        }\n        m = wormholes.size();\n    } else if (type == \"multiple_edges\") {\n        // Generate multiple wormholes between the same pairs\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            int c = rnd.next(minc, maxc);\n            int num_edges = rnd.next(2, 5);\n            for (int j = 0; j < num_edges; ++j) {\n                wormholes.emplace_back(a, b, c);\n            }\n        }\n        m = wormholes.size();\n    } else if (type == \"max_cost\") {\n        // Generate m random wormholes with maximum cost\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = maxc;\n            wormholes.emplace_back(a, b, c);\n        }\n    }\n\n    // Shuffle wormholes\n    shuffle(wormholes.begin(), wormholes.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output wormholes\n    for (auto &[a, b, c] : wormholes) {\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    // Generate q queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int ai, bi;\n        do {\n            ai = rnd.next(1, n);\n            bi = rnd.next(1, n);\n        } while (ai == bi);\n        printf(\"%d %d\\n\", ai, bi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 2 * n);\n    int q = opt<int>(\"q\", n);\n    int minc = opt<int>(\"minc\", 1);\n    int maxc = opt<int>(\"maxc\", 100000);\n    string type = opt<string>(\"type\", \"random\");\n    int is_n_odd = opt<int>(\"n_odd\", 0);\n\n    if (is_n_odd) {\n        if (n % 2 == 0) n += 1;\n    } else {\n        if (n % 2 == 1) n += 1;\n    }\n\n    vector<tuple<int, int, int>> wormholes;\n\n    if (type == \"random\") {\n        // Generate m random wormholes\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = rnd.next(minc, maxc);\n            wormholes.emplace_back(a, b, c);\n        }\n    } else if (type == \"complete\") {\n        // Generate wormholes between all pairs of nodes\n        for (int a = 1; a <= n; ++a) {\n            for (int b = a+1; b <= n; ++b) {\n                int c = rnd.next(minc, maxc);\n                wormholes.emplace_back(a, b, c);\n            }\n        }\n        m = wormholes.size();\n    } else if (type == \"multiple_edges\") {\n        // Generate multiple wormholes between the same pairs\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            if (a == b) continue;\n            int c = rnd.next(minc, maxc);\n            int num_edges = rnd.next(2, 5);\n            for (int j = 0; j < num_edges; ++j) {\n                wormholes.emplace_back(a, b, c);\n            }\n        }\n        m = wormholes.size();\n    } else if (type == \"max_cost\") {\n        // Generate m random wormholes with maximum cost\n        for (int i = 0; i < m; ++i) {\n            int a = rnd.next(1, n);\n            int b = rnd.next(1, n);\n            int c = maxc;\n            wormholes.emplace_back(a, b, c);\n        }\n    }\n\n    // Shuffle wormholes\n    shuffle(wormholes.begin(), wormholes.end());\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output wormholes\n    for (auto &[a, b, c] : wormholes) {\n        printf(\"%d %d %d\\n\", a, b, c);\n    }\n\n    // Generate q queries\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        int ai, bi;\n        do {\n            ai = rnd.next(1, n);\n            bi = rnd.next(1, n);\n        } while (ai == bi);\n        printf(\"%d %d\\n\", ai, bi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -q 1 -type random\n./gen -n 3 -m 2 -q 2 -type random\n./gen -n 4 -m 3 -q 2 -type random\n./gen -n 5 -m 4 -q 3 -type random\n\n./gen -n 10 -m 15 -q 5 -type complete\n./gen -n 100 -m 1000 -q 50 -type complete\n./gen -n 1000 -m 1000 -q 100 -type multiple_edges\n\n./gen -n 99999 -q 100000 -type random\n./gen -n 100000 -m 200000 -q 100000 -type random\n\n./gen -n 99999 -m 199998 -q 99999 -type max_cost\n\n./gen -n 100000 -m 200000 -q 100000 -type random -minc 1 -maxc 1\n\n./gen -n 100000 -m 200000 -q 100000 -type random -minc 100000 -maxc 100000\n\n./gen -n 100000 -m 200000 -q 100000 -type random -n_odd 1\n\n./gen -n 100000 -m 200000 -q 100000 -type random -n_odd 1\n\n./gen -n 100000 -m 200000 -q 100000 -type random -n_odd 0\n\n./gen -n 50000 -m 100000 -q 50000 -type random\n\n./gen -n 100000 -m 1 -q 1 -type random\n\n./gen -n 2 -m 1 -q 1 -type random -minc 1 -maxc 1\n\n./gen -n 3 -m 1 -q 1 -type random -minc 1 -maxc 1\n\n./gen -n 4 -m 1 -q 1 -type random -minc 1 -maxc 1\n\n./gen -n 5 -m 1 -q 1 -type random -minc 1 -maxc 1\n\n./gen -n 100000 -m 0 -q 100000 -type random\n\n./gen -n 1000 -m 100000 -q 1000 -type complete\n\n./gen -n 100000 -m 200000 -q 100000 -type multiple_edges\n\n./gen -n 100000 -m 200000 -q 100000 -type random -n_odd 1 -minc 1 -maxc 100000\n\n./gen -n 99999 -m 199998 -q 50000 -type random -n_odd 1\n\n./gen -n 100000 -m 195000 -q 100000 -type random -minc 50000 -maxc 100000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:26.548191",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "420/A",
      "title": "A. Start Up",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:",
      "output_spec": "OutputPrint 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).",
      "sample_tests": "ExamplesInputCopyAHAOutputCopyYESInputCopyZOutputCopyNOInputCopyXOOutputCopyNO",
      "description": "A. Start Up\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:\n\nOutputPrint 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).\n\nInputCopyAHAOutputCopyYESInputCopyZOutputCopyNOInputCopyXOOutputCopyNO\n\nInputCopyAHA\n\nOutputCopyYES\n\nOutputCopyNO\n\nInputCopyXO\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 420\\s*A"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]+\", \"name\");\n    ensuref(s.length() >= 1 && s.length() <= 100000, \"Name length must be between 1 and 1e5, but found %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]+\", \"name\");\n    ensuref(s.length() >= 1 && s.length() <= 100000, \"Name length must be between 1 and 1e5, but found %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[A-Z]+\", \"name\");\n    ensuref(s.length() >= 1 && s.length() <= 100000, \"Name length must be between 1 and 1e5, but found %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string acceptable_letters = \"AHIMTUVWY\";\n    set<char> acceptable_set(acceptable_letters.begin(), acceptable_letters.end());\n\n    vector<char> acceptable_vec(acceptable_letters.begin(), acceptable_letters.end());\n    vector<char> unacceptable_letters;\n    for(char c = 'A'; c <= 'Z'; ++c) {\n        if (acceptable_set.find(c) == acceptable_set.end())\n            unacceptable_letters.push_back(c);\n    }\n\n    string s;\n\n    if (type == \"palindrome_accept\") {\n        // Generate a palindrome with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = acceptable_vec[rnd.next(acceptable_vec.size())];\n            s[i] = s[n - 1 - i] = c;\n        }\n    } else if (type == \"palindrome_reject\") {\n        // Generate a palindrome with unacceptable letters\n        s.resize(n);\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = unacceptable_letters[rnd.next(unacceptable_letters.size())];\n            s[i] = s[n - 1 - i] = c;\n        }\n    } else if (type == \"nonpalindrome_accept\") {\n        // Generate a non-palindromic string with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = acceptable_vec[rnd.next(acceptable_vec.size())];\n        }\n        // Ensure it's not a palindrome\n        if (n > 1 && s == string(s.rbegin(), s.rend())) {\n            s[n/2] = acceptable_vec[(acceptable_vec.size()-1) - rnd.next(acceptable_vec.size())];\n        }\n    } else if (type == \"nonpalindrome_mixed\") {\n        // Generate a non-palindromic string with acceptable and unacceptable letters\n        s.resize(n);\n        vector<char> all_letters;\n        all_letters.insert(all_letters.end(), acceptable_vec.begin(), acceptable_vec.end());\n        all_letters.insert(all_letters.end(), unacceptable_letters.begin(), unacceptable_letters.end());\n        for (int i = 0; i < n; ++i) {\n            s[i] = all_letters[rnd.next(all_letters.size())];\n        }\n        // Ensure it's not a palindrome\n        if (n > 1 && s == string(s.rbegin(), s.rend())) {\n            s[n/2] = all_letters[(all_letters.size()-1) - rnd.next(all_letters.size())];\n        }\n    } else if (type == \"all_unacceptable\") {\n        // Generate a string with only unacceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = unacceptable_letters[rnd.next(unacceptable_letters.size())];\n        }\n    } else if (type == \"O_and_X\") {\n        // Generate a string with 'O' and 'X' letters\n        vector<char> OX = {'O', 'X'};\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = OX[rnd.next(2)];\n        }\n    } else if (type == \"random\") {\n        // Generate a random string with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = acceptable_vec[rnd.next(acceptable_vec.size())];\n        }\n    } else if (type == \"mixed_random\") {\n        // Generate a random string with both acceptable and unacceptable letters\n        vector<char> all_letters;\n        all_letters.insert(all_letters.end(), acceptable_vec.begin(), acceptable_vec.end());\n        all_letters.insert(all_letters.end(), unacceptable_letters.begin(), unacceptable_letters.end());\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = all_letters[rnd.next(all_letters.size())];\n        }\n    } else if (type == \"single_letter\") {\n        // Generate a string with a single repeated letter\n        vector<char> all_letters;\n        all_letters.insert(all_letters.end(), acceptable_vec.begin(), acceptable_vec.end());\n        all_letters.insert(all_letters.end(), unacceptable_letters.begin(), unacceptable_letters.end());\n        char c = all_letters[rnd.next(all_letters.size())];\n        s = string(n, c);\n    } else {\n        // Default: Generate a random string with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = acceptable_vec[rnd.next(acceptable_vec.size())];\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string acceptable_letters = \"AHIMTUVWY\";\n    set<char> acceptable_set(acceptable_letters.begin(), acceptable_letters.end());\n\n    vector<char> acceptable_vec(acceptable_letters.begin(), acceptable_letters.end());\n    vector<char> unacceptable_letters;\n    for(char c = 'A'; c <= 'Z'; ++c) {\n        if (acceptable_set.find(c) == acceptable_set.end())\n            unacceptable_letters.push_back(c);\n    }\n\n    string s;\n\n    if (type == \"palindrome_accept\") {\n        // Generate a palindrome with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = acceptable_vec[rnd.next(acceptable_vec.size())];\n            s[i] = s[n - 1 - i] = c;\n        }\n    } else if (type == \"palindrome_reject\") {\n        // Generate a palindrome with unacceptable letters\n        s.resize(n);\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = unacceptable_letters[rnd.next(unacceptable_letters.size())];\n            s[i] = s[n - 1 - i] = c;\n        }\n    } else if (type == \"nonpalindrome_accept\") {\n        // Generate a non-palindromic string with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = acceptable_vec[rnd.next(acceptable_vec.size())];\n        }\n        // Ensure it's not a palindrome\n        if (n > 1 && s == string(s.rbegin(), s.rend())) {\n            s[n/2] = acceptable_vec[(acceptable_vec.size()-1) - rnd.next(acceptable_vec.size())];\n        }\n    } else if (type == \"nonpalindrome_mixed\") {\n        // Generate a non-palindromic string with acceptable and unacceptable letters\n        s.resize(n);\n        vector<char> all_letters;\n        all_letters.insert(all_letters.end(), acceptable_vec.begin(), acceptable_vec.end());\n        all_letters.insert(all_letters.end(), unacceptable_letters.begin(), unacceptable_letters.end());\n        for (int i = 0; i < n; ++i) {\n            s[i] = all_letters[rnd.next(all_letters.size())];\n        }\n        // Ensure it's not a palindrome\n        if (n > 1 && s == string(s.rbegin(), s.rend())) {\n            s[n/2] = all_letters[(all_letters.size()-1) - rnd.next(all_letters.size())];\n        }\n    } else if (type == \"all_unacceptable\") {\n        // Generate a string with only unacceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = unacceptable_letters[rnd.next(unacceptable_letters.size())];\n        }\n    } else if (type == \"O_and_X\") {\n        // Generate a string with 'O' and 'X' letters\n        vector<char> OX = {'O', 'X'};\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = OX[rnd.next(2)];\n        }\n    } else if (type == \"random\") {\n        // Generate a random string with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = acceptable_vec[rnd.next(acceptable_vec.size())];\n        }\n    } else if (type == \"mixed_random\") {\n        // Generate a random string with both acceptable and unacceptable letters\n        vector<char> all_letters;\n        all_letters.insert(all_letters.end(), acceptable_vec.begin(), acceptable_vec.end());\n        all_letters.insert(all_letters.end(), unacceptable_letters.begin(), unacceptable_letters.end());\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = all_letters[rnd.next(all_letters.size())];\n        }\n    } else if (type == \"single_letter\") {\n        // Generate a string with a single repeated letter\n        vector<char> all_letters;\n        all_letters.insert(all_letters.end(), acceptable_vec.begin(), acceptable_vec.end());\n        all_letters.insert(all_letters.end(), unacceptable_letters.begin(), unacceptable_letters.end());\n        char c = all_letters[rnd.next(all_letters.size())];\n        s = string(n, c);\n    } else {\n        // Default: Generate a random string with acceptable letters\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = acceptable_vec[rnd.next(acceptable_vec.size())];\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum length palindrome with acceptable letters\n./gen -n 1 -type palindrome_accept\n\n# Minimum length palindrome with unacceptable letters\n./gen -n 1 -type palindrome_reject\n\n# Small length palindrome with acceptable letters\n./gen -n 2 -type palindrome_accept\n\n# Small length palindrome with unacceptable letters\n./gen -n 2 -type palindrome_reject\n\n# Small length non-palindrome with acceptable letters\n./gen -n 2 -type nonpalindrome_accept\n\n# Small length non-palindrome with mixed letters\n./gen -n 2 -type nonpalindrome_mixed\n\n# Small length with all unacceptable letters\n./gen -n 2 -type all_unacceptable\n\n# Random string with acceptable letters\n./gen -n 10 -type random\n\n# Random string with mixed acceptable and unacceptable letters\n./gen -n 10 -type mixed_random\n\n# Palindrome with acceptable letters, medium length\n./gen -n 100 -type palindrome_accept\n\n# Non-palindrome with acceptable letters, medium length\n./gen -n 100 -type nonpalindrome_accept\n\n# Palindrome with unacceptable letters, medium length\n./gen -n 100 -type palindrome_reject\n\n# Non-palindrome with mixed letters, medium length\n./gen -n 100 -type nonpalindrome_mixed\n\n# String of 'O's and 'X's\n./gen -n 100 -type O_and_X\n\n# String of maximum length with acceptable palindrome\n./gen -n 100000 -type palindrome_accept\n\n# String of maximum length with acceptable non-palindrome\n./gen -n 100000 -type nonpalindrome_accept\n\n# String of maximum length with all unacceptable letters\n./gen -n 100000 -type all_unacceptable\n\n# String of maximum length with mixed acceptable and unacceptable letters\n./gen -n 100000 -type nonpalindrome_mixed\n\n# String of maximum length with 'O's and 'X's\n./gen -n 100000 -type O_and_X\n\n# String of maximum length with random letters\n./gen -n 100000 -type mixed_random\n\n# String of maximum length with a single acceptable letter\n./gen -n 100000 -type single_letter\n\n# String of maximum length with a single unacceptable letter\n./gen -n 100000 -type single_letter\n\n# Random string of length 99999\n./gen -n 99999 -type mixed_random\n\n# Random string of length 99998\n./gen -n 99998 -type mixed_random\n\n# Palindrome with acceptable letters, length 1000\n./gen -n 1000 -type palindrome_accept\n\n# Palindrome with unacceptable letters, length 1000\n./gen -n 1000 -type palindrome_reject\n\n# Non-palindrome with acceptable letters, length 1000\n./gen -n 1000 -type nonpalindrome_accept\n\n# Non-palindrome with mixed letters, length 1000\n./gen -n 1000 -type nonpalindrome_mixed\n\n# Random string with acceptable letters, length 1000\n./gen -n 1000 -type random\n\n# Random string with mixed letters, length 1000\n./gen -n 1000 -type mixed_random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:28.233810",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "420/B",
      "title": "B. Онлайн митинг",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 105) — количество участников команды и количество сообщений. В каждой из следующих m строк записано сообщение в формате:  «+ id»: запись обозначает, что человек с номером id (1 ≤ id ≤ n) подключился к митингу.  «- id»: запись обозначает, что человек с номером id (1 ≤ id ≤ n) отключился от митинга. Считайте, что все люди команды пронумерованы от 1 до n, а сообщения заданы в хронологическом порядке. Гарантируется, что заданная последовательность является корректной записью непрерывной части митинга. Гарантируется, что никакие два события подключения/отключения не произошли одновременно.",
      "output_spec": "Выходные данныеВ первой строке выведите целое число k (0 ≤ k ≤ n) — количество людей, которые могут быть лидерами. В следующей строке выведите k целых чисел в возрастающем порядке — номера людей, которые могут быть лидерами.Если данные таковы, что ни один человек команды не может являться лидером, выведите единственное число 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 4+ 1+ 2- 2- 1Выходные данныеСкопировать41 3 4 5 Входные данныеСкопировать3 2+ 1- 2Выходные данныеСкопировать13 Входные данныеСкопировать2 4+ 1- 1+ 2- 2Выходные данныеСкопировать0Входные данныеСкопировать5 6+ 1- 1- 3+ 3+ 4- 4Выходные данныеСкопировать32 3 5 Входные данныеСкопировать2 4+ 1- 2+ 2- 1Выходные данныеСкопировать0",
      "description": "B. Онлайн митинг\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 105) — количество участников команды и количество сообщений. В каждой из следующих m строк записано сообщение в формате:  «+ id»: запись обозначает, что человек с номером id (1 ≤ id ≤ n) подключился к митингу.  «- id»: запись обозначает, что человек с номером id (1 ≤ id ≤ n) отключился от митинга. Считайте, что все люди команды пронумерованы от 1 до n, а сообщения заданы в хронологическом порядке. Гарантируется, что заданная последовательность является корректной записью непрерывной части митинга. Гарантируется, что никакие два события подключения/отключения не произошли одновременно.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число k (0 ≤ k ≤ n) — количество людей, которые могут быть лидерами. В следующей строке выведите k целых чисел в возрастающем порядке — номера людей, которые могут быть лидерами.Если данные таковы, что ни один человек команды не может являться лидером, выведите единственное число 0.\n\nВыходные данные\n\nВходные данныеСкопировать5 4+ 1+ 2- 2- 1Выходные данныеСкопировать41 3 4 5 Входные данныеСкопировать3 2+ 1- 2Выходные данныеСкопировать13 Входные данныеСкопировать2 4+ 1- 1+ 2- 2Выходные данныеСкопировать0Входные данныеСкопировать5 6+ 1- 1- 3+ 3+ 4- 4Выходные данныеСкопировать32 3 5 Входные данныеСкопировать2 4+ 1- 2+ 2- 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать5 4+ 1+ 2- 2- 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать41 3 4 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2+ 1- 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 4+ 1- 1+ 2- 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 6+ 1- 1- 3+ 3+ 4- 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32 3 5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 4+ 1- 2+ 2- 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Чемпионат школьников Москвы и МО - Codeforces",
          "content": "Компания КРОК и Министерство Обороны РФ приглашают учащихся 9-11 классов принять участие в чемпионате школьников Москвы и МО по спортивному программированию \"Coder-Strike 2014\". Чемпионат будет проведён на базе Codeforces.Цель чемпионатаМы хотим поддержать талантливых ребят, помочь формированию сообщества энтузиастов программирования, развитию будущих профессионалов IT-отрасли. Современная индустрия ставит наукоёмкие задачи, решение которых невозможно без глубоких знаний в области алгоритмов и структур данных. Мы хотим показать участникам потенциальные пути развития, и возможности, открывающиеся перед высококвалифицированными профессионалами.УчастникиПринять участие в чемпионате могут учащиеся 9-11 классов образовательных учреждений Москвы и Московской области, которым уже исполнилось 14 лет на момент регистрации в чемпионате. Чтобы стать участником чемпионата, необходимо пройти регистрацию до участия в квалификационном раунде по адресу http://crocok.ru/championship/. Заявка на участие обязательна для официального участия в чемпионате.Зарегистрироваться →Расписание этапов Этап Время проведения Участники этапа Регистрация 15-е марта — 15-е апреля Учащиеся 9-11 классов образовательных организаций Москвы и Московской области, которым уже исполнилось 14 лет на момент регистрации в чемпионате Квалификационный раунд 15 апреля с 00:00:00 до 23:59:59 (24 часа) Для прохождения квалификации будет необходимо решить хотя бы одну задачу в любое время в течении суток от начала раунда. Все участники, зарегистрированные на чемпионат Первый отборочный раунд 18 апреля с 20:00:00 до 21:59:59 (2 часа) Участники, решившие хотя бы одну задачу в квалификационном раунде Второй отборочный раунд 20 апреля с 11:00:00 до 12:59:59 (2 часа) Лучшие 200 участников первого отборочного раунда Финал 22 апреля (время будет уточнено) Лучшие 25 участников второго отборочного раунд Квалификационный раунд будет состоять из 2-3 несложных задач по программированию, решения по которым будут проверяться во время раунда. Отборочные раунды и финал будут проведены по традиционным правилам соревнований Codeforces, с которым вы можете ознакомиться по ссылкам: правила соревнований Codeforces правила соревнований Codeforces Финал чемпионатаФинал чемпионата состоится 22 апреля в офисе компании КРОК по адресу ул. Волочаевская, 5. Финалистов ждет экскурсия по офису компании и знакомство с ведущими специалистами КРОК и представителями Министерства Обороны РФ. Время финала будет уточнено позднее.Торжественное награждение победителей состоится 20-23 мая на выставке Минобороны \"Комплексная Безопасность\".ПризыВсе участники, дошедшие до финала, получат памятные призы от компании КРОК и Министерства Обороны РФ.Участие вне конкурсаВсе желающие могут также поучаствовать в чемпионате вне конкурса. В этом случае заявка на участие не требуется. Отборочные раунды и финал будут рейтинговыми раундами Codeforces.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2896
        },
        {
          "title": "Разбор задач Coder-Strike 2014 Финал - Codeforces",
          "content": "421A - Паша и хомякиВ данной задаче нужно было для каждого яблока определить, кому оно нравится, и отдать его этому хомяку. Так как гарантировалось, что ответ существует, то каждое яблоко нравилось либо Александру, либо Артуру.420A - СтартапВ данной задаче нужно было проверить, что заданная строка является палиндромом, и что она состоит только из симметричных символов. Симметричные символы — AHIMOTUVWXY.420B - Онлайн митингПрежде всего, добавим в ответ всех людей, которые ни разу не упоминались в сообщениях. Далее рассмотрим два случая.1) Есть участник с номером i такой, что первое сообщение с его участием  - i.Рассмотрим всех таких участников. Среди них выберем того, первое упоминание о котором встречается позже остальных. Тогда лишь он может быть лидером, так как другие ушли раньше, а те участники, о которых первое сообщение начинается с « + », не могут быть лидерами, так как когда они пришли i уже был. Но нужно проверить, может ли он на самом деле быть лидером (так как например, может он ушел, а потом сразу пришел кто-то другой). Для этого добавим в начало сообщений всех участников, для которых первое сообщение начинается с « - » в порядке их появления. То есть сначала добавим того, кто ушел раньше остальных (он упоминается первым), затем того, кто ушел вторым, и так далее. В конце добавим нашего кандидата на лидера (то есть в итоге он будет первым в списке сообщений). После добавления проверим описанным ниже алгоритмом по списку сообщений и кандидату, может ли он быть лидером.2) Для всех участников первая запись о них начинается с « + ».Тогда, очевидно, кандидатом на лидера может быть только участник, который появился в митинге самым первым. Проверим алгоритмом его.Алгоритм проверки, может ли заданный кандидат быть лидером, очень прост. Поддерживаем set участников, которые в данный момент есть в митинге. Идем по списку сообщений и добавляем или удаляем соответствующих участников. Перед и после каждой операцией проверяем, что если список участников не пуст, то наш кандидат должен в нем присутствовать.Хитрыми тестами в этой задаче оказались тесты 33 и 34, на которых упали решения многих участников. Тест 33 выглядит так.4 4+ 2- 1- 3- 2Здесь лидером может быть только 4-ый участник (в предположении, что он всегда находится на митинге). Второй не может быть лидером, так как изначально он не участвовал в митинге, а первый и третий участвовали. Но они тоже не могут быть лидерами, так как вышли из митинга в то время, когда там находился второй участник.Тест 34 следующий.3 3- 2+ 1+ 2В данном тесте лидером может быть только 3-ий участник. Второй изначально находится на митинге, потом уходит, но далее приходит первый, поэтому второй не может быть лидером. Первый не может быть лидером, потому что он изначально не находится на митинге, а второй участник находится.420C - Баг в кодеДавайте построим неориентированный граф, вершины которого — это люди, а ребро между двумя людьми a, b есть, если существует высказывание человека (виноват a или b). Как теперь переформулируется задача в терминах этого графа? Нужно посчитать количество таких пар вершин, что им инцидентно как минимум p ребер.Сделаем следующее. Сохраним граф в виде списков смежности, а также создадим массив степеней всех вершин графа и отсортируем его. Будем перебирать одну вершину и считать, сколько существует вершин в пару ей, чтобы получилась нужная пара вершин. Первое, что приходит в голову — это для каждой вершины v добавить к ответу количество вершин u таких, что d[u] + d[v] ≥ p (количество таких вершин можно просто посчитать бинарным поиском, например). К сожалению, это неправильно, поскольку в сумме d[u] + d[v] ребра между v и u учитываются два раза.Но, давайте посчитаем ответ неправильно, а потом учтем все то, что мы неправильно посчитали. А именно, для каждой вершины пройдемся по списку ее соседей и для каждого уникального соседа вычтем его из ответ, если он добавился туда (если d[v] + d[u] ≥ p). Теперь осталось учесть в ответе все вершины, которые смежны в графе. Это делается простым проходом по ребрам.Обратите внимание, что в этой задаче в графе могут получиться мультиребра, их нужно аккуратно обрабатывать.420D - Фокус со стаканчикамиРешение состоит из двух этапов.1) Определим возможную исходную перестановку.Будем идти по заданным запросам. Пусть текущий запрос утверждает, что число a стоит на позиции b. Если a уже раньше встречалось, то пропустим такой запрос. Иначе определим, на какой позиции находится a в искомой перестановке.Пусть мы уже знаем, что в искомой перестановке число a1 стоит на позиции b1, a2 на позиции b2, ..., ak на позиции bk (b1 < b2 < ... < bk). Так как после объявления позиции числа оно перемещается в самое начало перестановки, то значит до того как мы объявили о позиции a все ai (1 ≤ i ≤ k) уже находятся перед a. Но при этом некоторые из этих ai уже находились раньше a в искомой перестановке, а остальные находились позже, но переместились вперед. Найдем их количество. Для этого нужно найти такую свободную позицию p в исходной перестановке, что p + x = b, где x — количество bi таких, что bi > x. Это можно найти с помощью дерева отрезков следующим образом. Будем хранить в вершине дерева отрезков количество уже занятых позиций искомой перестановки на соответствующем подотрезке. Предположим, мы хотим найти p в некотором поддереве. Посмотрим на минимальную позицию в правом поддереве prg и на количество занятых там позиций xrg. Тогда если prg + xrg ≤ b, то нужно продолжать искать в правом поддереве. Если же prg + xrg > b, то нужно продолжать искать в левом поддереве, уменьшив при этом b на величину xrg. Когда мы нашли p, проверим выполнение условия p + x = b. Если оно не выполняется, то ответ  - 1.2) Проверим, что последовательность операций корректная.Пусть мы рассматриваем i-ый запрос, утверждающий, что число a стоит на позиции b. Нужно проверить, что он верен. Если a раньше не встречалось в запросах, то запрос верен, так как мы проверили b еще на первом этапе. Если оно раньше встречалось, найдем такое максимальное j < i, что j-ый запрос также объявляет, в какой позиции находится a. После j-го запроса a перемещается в начало перестановки, а далее другие числа могут передвигать его вправо. Найдем количество различных таких чисел на отрезке запросов [j + 1, i - 1], их должно быть ровно b - 1.420E - Игра в мячСкажем, что в данной задаче у нас есть луч, на котором есть бесконечное число шариков, находящихся на расстояниях, кратных d от начала луча. Заметим, что хотя бы один шарик, который будет посчитан в ответе должен упираться в границу какого-нибудь круга. Также заметим, что если мы рассмотрим любой круг, то количество углов a на которые нужно повернуть наш луч так, чтобы какой-нибудь из шариков лежал на границе этого круга не превосходит 4 * r / d. Назовем такие углы критическими.Выпишем все возможные критические углы от всех окружностей в массив B и отсортируем его. Далее для каждой окружности выпишем ее критические углы и отсортируем. Тогда между двумя соседними критическими углами количество шаров, попадающих в круг будет постоянно. Посчитаем k это количество, найдем данные углы в B. Тогда повернув луч на любой угол, находящийся между ними, к ответу будет прибавляться k.Заведем массив C такой, что Ci — ответ, если мы повернули луч на угол Bi. Тогда после того как мы нашли k и позиции углов в B, нужно сделать прибавление на отрезке в массиве C. После того как мы обработаем все критические углы всех кругов нужно найти максимум в массиве C.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 420\\s*B"
          },
          "content_length": 7457
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        char op = inf.readChar();\n        ensuref(op == '+' || op == '-', \"Operation must be '+' or '-'\");\n        inf.readChar(' ');\n        int id = inf.readInt(1, n, \"id\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        char op = inf.readChar();\n        ensuref(op == '+' || op == '-', \"Operation must be '+' or '-'\");\n        inf.readChar(' ');\n        int id = inf.readInt(1, n, \"id\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        char op = inf.readChar();\n        ensuref(op == '+' || op == '-', \"Operation must be '+' or '-'\");\n        inf.readChar(' ');\n        int id = inf.readInt(1, n, \"id\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output_events(const vector<pair<char, int>>& events) {\n    for (const auto& e : events) {\n        printf(\"%c %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<char, int>> events;\n    map<int, int> status; // 0: logged off, 1: logged on\n\n    if (type == \"random\") {\n        // Generate random events\n        set<int> participants;\n        for (int i = 1; i <= n; ++i) {\n            participants.insert(i);\n        }\n\n        for (int i = 0; i < m; ++i) {\n            char action = (rnd.next(2) == 0) ? '+' : '-';\n            int id = rnd.next(1, n);\n\n            if (action == '+') {\n                if (status[id] != 1) {\n                    events.push_back({'+', id});\n                    status[id] = 1;\n                } else {\n                    // Already logged on, try to pick a different action\n                    --i;\n                    continue;\n                }\n            } else { // action == '-'\n                // Allowed to log off even if status is unknown or 1\n                events.push_back({'-', id});\n                status[id] = 0;\n            }\n        }\n    } else if (type == \"single_candidate\") {\n        // Only participant 1 can be leader\n        // Participant 1 is always present when others are present\n        // Generate events where other participants are not present when participant 1 is absent\n\n        // Participant 1 logs on at the beginning\n        events.push_back({'+', 1});\n        status[1] = 1;\n\n        // For other participants\n        for (int i = 2; i <= n; ++i) {\n            // Participant i logs on\n            events.push_back({'+', i});\n            status[i] = 1;\n\n            // Participant i logs off\n            events.push_back({'-', i});\n            status[i] = 0;\n\n            m -= 2;\n        }\n\n        // Participant 1 logs off at the end\n        events.push_back({'-', 1});\n        status[1] = 0;\n        m -= 2;\n\n        // Fill remaining events with random actions involving participant 1\n        while (m > 0) {\n            events.push_back({'+', 1});\n            events.push_back({'-', 1});\n            m -= 2;\n        }\n    } else if (type == \"no_candidate\") {\n        // No one can be leader\n        // Ensure that every participant is absent at some time when someone else is present\n\n        // Alternate log on and log off for participants\n        for (int i = 1; i <= n && m > 0; ++i) {\n            // Participant i logs on\n            events.push_back({'+', i});\n            status[i] = 1;\n            --m;\n\n            // Next participant logs on if possible\n            if (i + 1 <= n && m > 0) {\n                events.push_back({'+', i + 1});\n                status[i + 1] = 1;\n                --m;\n            }\n\n            // Participant i logs off\n            if (m > 0) {\n                events.push_back({'-', i});\n                status[i] = 0;\n                --m;\n            }\n\n            // Participant i+1 logs off\n            if (i + 1 <= n && m > 0) {\n                events.push_back({'-', i + 1});\n                status[i + 1] = 0;\n                --m;\n            }\n            ++i;\n        }\n    } else if (type == \"all_candidates\") {\n        // All participants can be leaders\n        // No events involve other participants being present when someone is absent\n\n        // Minimal events, only involving one participant\n        // Participant 1 logs on and off\n        events.push_back({'+', 1});\n        events.push_back({'-', 1});\n        m -= 2;\n\n        // Fill remaining events with random log off events for participants not logged on\n        for (int i = 0; i < m; ++i) {\n            int id = rnd.next(2, n);\n            events.push_back({'-', id});\n            status[id] = 0;\n        }\n    } else {\n        // Default to random if unknown type\n        // Generate random events\n        for (int i = 0; i < m; ++i) {\n            char action = (rnd.next(2) == 0) ? '+' : '-';\n            int id = rnd.next(1, n);\n\n            if (action == '+') {\n                if (status[id] != 1) {\n                    events.push_back({'+', id});\n                    status[id] = 1;\n                } else {\n                    // Already logged on, try to pick a different action\n                    --i;\n                    continue;\n                }\n            } else { // action == '-'\n                // Allowed to log off even if status is unknown or 1\n                events.push_back({'-', id});\n                status[id] = 0;\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, int(events.size()));\n    // Output events\n    output_events(events);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid output_events(const vector<pair<char, int>>& events) {\n    for (const auto& e : events) {\n        printf(\"%c %d\\n\", e.first, e.second);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<char, int>> events;\n    map<int, int> status; // 0: logged off, 1: logged on\n\n    if (type == \"random\") {\n        // Generate random events\n        set<int> participants;\n        for (int i = 1; i <= n; ++i) {\n            participants.insert(i);\n        }\n\n        for (int i = 0; i < m; ++i) {\n            char action = (rnd.next(2) == 0) ? '+' : '-';\n            int id = rnd.next(1, n);\n\n            if (action == '+') {\n                if (status[id] != 1) {\n                    events.push_back({'+', id});\n                    status[id] = 1;\n                } else {\n                    // Already logged on, try to pick a different action\n                    --i;\n                    continue;\n                }\n            } else { // action == '-'\n                // Allowed to log off even if status is unknown or 1\n                events.push_back({'-', id});\n                status[id] = 0;\n            }\n        }\n    } else if (type == \"single_candidate\") {\n        // Only participant 1 can be leader\n        // Participant 1 is always present when others are present\n        // Generate events where other participants are not present when participant 1 is absent\n\n        // Participant 1 logs on at the beginning\n        events.push_back({'+', 1});\n        status[1] = 1;\n\n        // For other participants\n        for (int i = 2; i <= n; ++i) {\n            // Participant i logs on\n            events.push_back({'+', i});\n            status[i] = 1;\n\n            // Participant i logs off\n            events.push_back({'-', i});\n            status[i] = 0;\n\n            m -= 2;\n        }\n\n        // Participant 1 logs off at the end\n        events.push_back({'-', 1});\n        status[1] = 0;\n        m -= 2;\n\n        // Fill remaining events with random actions involving participant 1\n        while (m > 0) {\n            events.push_back({'+', 1});\n            events.push_back({'-', 1});\n            m -= 2;\n        }\n    } else if (type == \"no_candidate\") {\n        // No one can be leader\n        // Ensure that every participant is absent at some time when someone else is present\n\n        // Alternate log on and log off for participants\n        for (int i = 1; i <= n && m > 0; ++i) {\n            // Participant i logs on\n            events.push_back({'+', i});\n            status[i] = 1;\n            --m;\n\n            // Next participant logs on if possible\n            if (i + 1 <= n && m > 0) {\n                events.push_back({'+', i + 1});\n                status[i + 1] = 1;\n                --m;\n            }\n\n            // Participant i logs off\n            if (m > 0) {\n                events.push_back({'-', i});\n                status[i] = 0;\n                --m;\n            }\n\n            // Participant i+1 logs off\n            if (i + 1 <= n && m > 0) {\n                events.push_back({'-', i + 1});\n                status[i + 1] = 0;\n                --m;\n            }\n            ++i;\n        }\n    } else if (type == \"all_candidates\") {\n        // All participants can be leaders\n        // No events involve other participants being present when someone is absent\n\n        // Minimal events, only involving one participant\n        // Participant 1 logs on and off\n        events.push_back({'+', 1});\n        events.push_back({'-', 1});\n        m -= 2;\n\n        // Fill remaining events with random log off events for participants not logged on\n        for (int i = 0; i < m; ++i) {\n            int id = rnd.next(2, n);\n            events.push_back({'-', id});\n            status[id] = 0;\n        }\n    } else {\n        // Default to random if unknown type\n        // Generate random events\n        for (int i = 0; i < m; ++i) {\n            char action = (rnd.next(2) == 0) ? '+' : '-';\n            int id = rnd.next(1, n);\n\n            if (action == '+') {\n                if (status[id] != 1) {\n                    events.push_back({'+', id});\n                    status[id] = 1;\n                } else {\n                    // Already logged on, try to pick a different action\n                    --i;\n                    continue;\n                }\n            } else { // action == '-'\n                // Allowed to log off even if status is unknown or 1\n                events.push_back({'-', id});\n                status[id] = 0;\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, int(events.size()));\n    // Output events\n    output_events(events);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random small test cases\n./gen -n 5 -m 10 -type random\n./gen -n 10 -m 20 -type random\n\n# Random medium test cases\n./gen -n 100 -m 200 -type random\n./gen -n 200 -m 500 -type random\n\n# Random large test cases\n./gen -n 1000 -m 5000 -type random\n./gen -n 10000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type random\n\n# All candidates can be leaders\n./gen -n 5 -m 5 -type all_candidates\n./gen -n 100 -m 10 -type all_candidates\n./gen -n 1000 -m 20 -type all_candidates\n\n# No candidate can be leader\n./gen -n 5 -m 10 -type no_candidate\n./gen -n 100 -m 200 -type no_candidate\n./gen -n 1000 -m 5000 -type no_candidate\n\n# Only one candidate can be leader\n./gen -n 5 -m 10 -type single_candidate\n./gen -n 100 -m 200 -type single_candidate\n./gen -n 1000 -m 5000 -type single_candidate\n\n# Edge cases with minimum n and m\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type all_candidates\n./gen -n 1 -m 1 -type no_candidate\n./gen -n 1 -m 1 -type single_candidate\n\n# Edge cases with maximum n and m\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type all_candidates\n./gen -n 100000 -m 100000 -type no_candidate\n./gen -n 100000 -m 100000 -type single_candidate\n\n# Special test cases\n# Participants not mentioned in events\n./gen -n 100 -m 50 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 10000 -m 5000 -type random\n\n# Participants logging off without logging on during observed period\n./gen -n 100 -m 100 -type special_logoff_only\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:29.834739",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "420/C",
      "title": "C. Bug in Code",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and p (3 ≤ n ≤ 3·105; 0 ≤ p ≤ n) — the number of coders in the F company and the minimum number of agreed people.Each of the next n lines contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the numbers of coders named by the i-th coder. It is guaranteed that xi ≠ i,  yi ≠ i,  xi ≠ yi.",
      "output_spec": "OutputPrint a single integer –– the number of possible two-suspect sets. Note that the order of the suspects doesn't matter, that is, sets (1, 2) и (2, 1) are considered identical.",
      "sample_tests": "ExamplesInputCopy4 22 31 41 42 1OutputCopy6InputCopy8 65 65 75 86 22 17 31 31 4OutputCopy1",
      "description": "C. Bug in Code\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and p (3 ≤ n ≤ 3·105; 0 ≤ p ≤ n) — the number of coders in the F company and the minimum number of agreed people.Each of the next n lines contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the numbers of coders named by the i-th coder. It is guaranteed that xi ≠ i,  yi ≠ i,  xi ≠ yi.\n\nOutputPrint a single integer –– the number of possible two-suspect sets. Note that the order of the suspects doesn't matter, that is, sets (1, 2) и (2, 1) are considered identical.\n\nInputCopy4 22 31 41 42 1OutputCopy6InputCopy8 65 65 75 86 22 17 31 31 4OutputCopy1\n\nInputCopy4 22 31 41 42 1\n\nOutputCopy6\n\nInputCopy8 65 65 75 86 22 17 31 31 4\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 420\\s*C"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300000, \"n\"); // 3 ≤ n ≤ 3e5\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\"); // 0 ≤ p ≤ n\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        // xi ≠ i\n        ensuref(xi != i, \"xi (%d) must not be equal to i (%d)\", xi, i);\n\n        // yi ≠ i\n        ensuref(yi != i, \"yi (%d) must not be equal to i (%d)\", yi, i);\n\n        // xi ≠ yi\n        ensuref(xi != yi, \"xi (%d) must not be equal to yi (%d)\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300000, \"n\"); // 3 ≤ n ≤ 3e5\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\"); // 0 ≤ p ≤ n\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        // xi ≠ i\n        ensuref(xi != i, \"xi (%d) must not be equal to i (%d)\", xi, i);\n\n        // yi ≠ i\n        ensuref(yi != i, \"yi (%d) must not be equal to i (%d)\", yi, i);\n\n        // xi ≠ yi\n        ensuref(xi != yi, \"xi (%d) must not be equal to yi (%d)\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 300000, \"n\"); // 3 ≤ n ≤ 3e5\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\"); // 0 ≤ p ≤ n\n    inf.readEoln();\n\n    for (int i = 1; i <= n; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        // xi ≠ i\n        ensuref(xi != i, \"xi (%d) must not be equal to i (%d)\", xi, i);\n\n        // yi ≠ i\n        ensuref(yi != i, \"yi (%d) must not be equal to i (%d)\", yi, i);\n\n        // xi ≠ yi\n        ensuref(xi != yi, \"xi (%d) must not be equal to yi (%d)\", xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n + 1), y(n + 1); // Use 1-based indexing\n\n    if (type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            x[i] = rnd.next(1, n);\n            while (x[i] == i)\n                x[i] = rnd.next(1, n);\n\n            y[i] = rnd.next(1, n);\n            while (y[i] == i || y[i] == x[i])\n                y[i] = rnd.next(1, n);\n        }\n    } else if (type == \"all_same\") {\n        int s1 = rnd.next(1, n);\n        int s2 = rnd.next(1, n);\n        while (s2 == s1)\n            s2 = rnd.next(1, n);\n\n        int other = rnd.next(1, n);\n        while (other == s1 || other == s2)\n            other = rnd.next(1, n);\n\n        for (int i = 1; i <= n; ++i) {\n            if (i != s1 && i != s2) {\n                x[i] = s1;\n                y[i] = s2;\n            } else if (i == s1) {\n                x[i] = s2;\n                y[i] = other;\n                if (y[i] == i)\n                    y[i] = s1; // Ensure y_i != i\n            } else { // i == s2\n                x[i] = s1;\n                y[i] = other;\n                if (y[i] == i)\n                    y[i] = s2; // Ensure y_i != i\n            }\n            // Ensure x_i != i\n            if (x[i] == i)\n                x[i] = other;\n\n            // Ensure x_i != y_i\n            if (x[i] == y[i]) {\n                y[i] = other;\n                if (y[i] == i || y[i] == x[i])\n                    y[i] = s1;\n            }\n        }\n    } else if (type == \"impossible\") {\n        for (int i = 1; i <= n; ++i) {\n            x[i] = (i % n) + 1;\n            if (x[i] == i)\n                x[i] = (x[i] % n) + 1; // Ensure x_i != i\n\n            y[i] = (x[i] % n) + 1;\n            if (y[i] == i || y[i] == x[i])\n                y[i] = (y[i] % n) + 1; // Ensure y_i != i and y_i != x_i\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 1; i <= n; ++i) {\n            x[i] = rnd.next(1, n);\n            while (x[i] == i)\n                x[i] = rnd.next(1, n);\n\n            y[i] = rnd.next(1, n);\n            while (y[i] == i || y[i] == x[i])\n                y[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    // Output the pairs x_i and y_i\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d %d\\n\", x[i], y[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> x(n + 1), y(n + 1); // Use 1-based indexing\n\n    if (type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            x[i] = rnd.next(1, n);\n            while (x[i] == i)\n                x[i] = rnd.next(1, n);\n\n            y[i] = rnd.next(1, n);\n            while (y[i] == i || y[i] == x[i])\n                y[i] = rnd.next(1, n);\n        }\n    } else if (type == \"all_same\") {\n        int s1 = rnd.next(1, n);\n        int s2 = rnd.next(1, n);\n        while (s2 == s1)\n            s2 = rnd.next(1, n);\n\n        int other = rnd.next(1, n);\n        while (other == s1 || other == s2)\n            other = rnd.next(1, n);\n\n        for (int i = 1; i <= n; ++i) {\n            if (i != s1 && i != s2) {\n                x[i] = s1;\n                y[i] = s2;\n            } else if (i == s1) {\n                x[i] = s2;\n                y[i] = other;\n                if (y[i] == i)\n                    y[i] = s1; // Ensure y_i != i\n            } else { // i == s2\n                x[i] = s1;\n                y[i] = other;\n                if (y[i] == i)\n                    y[i] = s2; // Ensure y_i != i\n            }\n            // Ensure x_i != i\n            if (x[i] == i)\n                x[i] = other;\n\n            // Ensure x_i != y_i\n            if (x[i] == y[i]) {\n                y[i] = other;\n                if (y[i] == i || y[i] == x[i])\n                    y[i] = s1;\n            }\n        }\n    } else if (type == \"impossible\") {\n        for (int i = 1; i <= n; ++i) {\n            x[i] = (i % n) + 1;\n            if (x[i] == i)\n                x[i] = (x[i] % n) + 1; // Ensure x_i != i\n\n            y[i] = (x[i] % n) + 1;\n            if (y[i] == i || y[i] == x[i])\n                y[i] = (y[i] % n) + 1; // Ensure y_i != i and y_i != x_i\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 1; i <= n; ++i) {\n            x[i] = rnd.next(1, n);\n            while (x[i] == i)\n                x[i] = rnd.next(1, n);\n\n            y[i] = rnd.next(1, n);\n            while (y[i] == i || y[i] == x[i])\n                y[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n\n    // Output the pairs x_i and y_i\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d %d\\n\", x[i], y[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -p 0 -type random\n./gen -n 3 -p 3 -type all_same\n./gen -n 3 -p 2 -type random\n\n./gen -n 10 -p 0 -type random\n./gen -n 10 -p 5 -type random\n./gen -n 10 -p 10 -type all_same\n\n./gen -n 50 -p 25 -type random\n./gen -n 50 -p 50 -type all_same\n\n./gen -n 100 -p 0 -type random\n./gen -n 100 -p 50 -type random\n./gen -n 100 -p 90 -type all_same\n./gen -n 100 -p 100 -type all_same\n\n./gen -n 1000 -p 500 -type random\n./gen -n 1000 -p 1000 -type all_same\n\n./gen -n 5000 -p 2500 -type random\n./gen -n 5000 -p 5000 -type all_same\n\n./gen -n 10000 -p 0 -type random\n./gen -n 10000 -p 5000 -type random\n./gen -n 10000 -p 10000 -type all_same\n\n./gen -n 50000 -p 25000 -type random\n./gen -n 50000 -p 50000 -type all_same\n\n./gen -n 100000 -p 50000 -type random\n./gen -n 100000 -p 100000 -type all_same\n./gen -n 100000 -p 99999 -type random\n\n./gen -n 300000 -p 0 -type random\n./gen -n 300000 -p 150000 -type random\n./gen -n 300000 -p 300000 -type all_same\n./gen -n 300000 -p 290000 -type random\n\n# Impossible cases\n./gen -n 3 -p 3 -type impossible\n./gen -n 10 -p 9 -type impossible\n./gen -n 100 -p 90 -type impossible\n./gen -n 1000 -p 990 -type impossible\n./gen -n 100000 -p 99999 -type impossible\n./gen -n 300000 -p 299999 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:31.807832",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "420/D",
      "title": "D. Фокус со стаканчиками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 106). В каждой из следующих m строк записана пара целых чисел. В i-й строке записаны целые числа xi, yi (1 ≤ xi, yi ≤ n) — описание i-й операции фокусника. Обратите внимание, что операции заданы в том порядке, в котором их выполнял фокусник, программист хочет выполнить эти операции в таком же порядке.",
      "output_spec": "Выходные данныеЕсли описанной перестановки не существует (программист ошибся в своих воспоминаниях), выведите -1. Иначе выведите n различных целых чисел, каждое от 1 до n: i-е число должно обозначать пометку на стаканчике, который изначально стоит в ряду на позиции i.Если существует несколько правильных ответов, нужно вывести лексикографически наименьший.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 12 1Выходные данныеСкопировать2 1 Входные данныеСкопировать3 21 21 1Выходные данныеСкопировать2 1 3 Входные данныеСкопировать3 31 32 31 3Выходные данныеСкопировать-1",
      "description": "D. Фокус со стаканчиками\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 106). В каждой из следующих m строк записана пара целых чисел. В i-й строке записаны целые числа xi, yi (1 ≤ xi, yi ≤ n) — описание i-й операции фокусника. Обратите внимание, что операции заданы в том порядке, в котором их выполнял фокусник, программист хочет выполнить эти операции в таком же порядке.\n\nВходные данные\n\nВыходные данныеЕсли описанной перестановки не существует (программист ошибся в своих воспоминаниях), выведите -1. Иначе выведите n различных целых чисел, каждое от 1 до n: i-е число должно обозначать пометку на стаканчике, который изначально стоит в ряду на позиции i.Если существует несколько правильных ответов, нужно вывести лексикографически наименьший.\n\nВыходные данные\n\nВходные данныеСкопировать2 12 1Выходные данныеСкопировать2 1 Входные данныеСкопировать3 21 21 1Выходные данныеСкопировать2 1 3 Входные данныеСкопировать3 31 32 31 3Выходные данныеСкопировать-1\n\nВходные данныеСкопировать2 12 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 21 21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 32 31 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Чемпионат школьников Москвы и МО - Codeforces",
          "content": "Компания КРОК и Министерство Обороны РФ приглашают учащихся 9-11 классов принять участие в чемпионате школьников Москвы и МО по спортивному программированию \"Coder-Strike 2014\". Чемпионат будет проведён на базе Codeforces.Цель чемпионатаМы хотим поддержать талантливых ребят, помочь формированию сообщества энтузиастов программирования, развитию будущих профессионалов IT-отрасли. Современная индустрия ставит наукоёмкие задачи, решение которых невозможно без глубоких знаний в области алгоритмов и структур данных. Мы хотим показать участникам потенциальные пути развития, и возможности, открывающиеся перед высококвалифицированными профессионалами.УчастникиПринять участие в чемпионате могут учащиеся 9-11 классов образовательных учреждений Москвы и Московской области, которым уже исполнилось 14 лет на момент регистрации в чемпионате. Чтобы стать участником чемпионата, необходимо пройти регистрацию до участия в квалификационном раунде по адресу http://crocok.ru/championship/. Заявка на участие обязательна для официального участия в чемпионате.Зарегистрироваться →Расписание этапов Этап Время проведения Участники этапа Регистрация 15-е марта — 15-е апреля Учащиеся 9-11 классов образовательных организаций Москвы и Московской области, которым уже исполнилось 14 лет на момент регистрации в чемпионате Квалификационный раунд 15 апреля с 00:00:00 до 23:59:59 (24 часа) Для прохождения квалификации будет необходимо решить хотя бы одну задачу в любое время в течении суток от начала раунда. Все участники, зарегистрированные на чемпионат Первый отборочный раунд 18 апреля с 20:00:00 до 21:59:59 (2 часа) Участники, решившие хотя бы одну задачу в квалификационном раунде Второй отборочный раунд 20 апреля с 11:00:00 до 12:59:59 (2 часа) Лучшие 200 участников первого отборочного раунда Финал 22 апреля (время будет уточнено) Лучшие 25 участников второго отборочного раунд Квалификационный раунд будет состоять из 2-3 несложных задач по программированию, решения по которым будут проверяться во время раунда. Отборочные раунды и финал будут проведены по традиционным правилам соревнований Codeforces, с которым вы можете ознакомиться по ссылкам: правила соревнований Codeforces правила соревнований Codeforces Финал чемпионатаФинал чемпионата состоится 22 апреля в офисе компании КРОК по адресу ул. Волочаевская, 5. Финалистов ждет экскурсия по офису компании и знакомство с ведущими специалистами КРОК и представителями Министерства Обороны РФ. Время финала будет уточнено позднее.Торжественное награждение победителей состоится 20-23 мая на выставке Минобороны \"Комплексная Безопасность\".ПризыВсе участники, дошедшие до финала, получат памятные призы от компании КРОК и Министерства Обороны РФ.Участие вне конкурсаВсе желающие могут также поучаствовать в чемпионате вне конкурса. В этом случае заявка на участие не требуется. Отборочные раунды и финал будут рейтинговыми раундами Codeforces.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2896
        },
        {
          "title": "Разбор задач Coder-Strike 2014 Финал - Codeforces",
          "content": "421A - Паша и хомякиВ данной задаче нужно было для каждого яблока определить, кому оно нравится, и отдать его этому хомяку. Так как гарантировалось, что ответ существует, то каждое яблоко нравилось либо Александру, либо Артуру.420A - СтартапВ данной задаче нужно было проверить, что заданная строка является палиндромом, и что она состоит только из симметричных символов. Симметричные символы — AHIMOTUVWXY.420B - Онлайн митингПрежде всего, добавим в ответ всех людей, которые ни разу не упоминались в сообщениях. Далее рассмотрим два случая.1) Есть участник с номером i такой, что первое сообщение с его участием  - i.Рассмотрим всех таких участников. Среди них выберем того, первое упоминание о котором встречается позже остальных. Тогда лишь он может быть лидером, так как другие ушли раньше, а те участники, о которых первое сообщение начинается с « + », не могут быть лидерами, так как когда они пришли i уже был. Но нужно проверить, может ли он на самом деле быть лидером (так как например, может он ушел, а потом сразу пришел кто-то другой). Для этого добавим в начало сообщений всех участников, для которых первое сообщение начинается с « - » в порядке их появления. То есть сначала добавим того, кто ушел раньше остальных (он упоминается первым), затем того, кто ушел вторым, и так далее. В конце добавим нашего кандидата на лидера (то есть в итоге он будет первым в списке сообщений). После добавления проверим описанным ниже алгоритмом по списку сообщений и кандидату, может ли он быть лидером.2) Для всех участников первая запись о них начинается с « + ».Тогда, очевидно, кандидатом на лидера может быть только участник, который появился в митинге самым первым. Проверим алгоритмом его.Алгоритм проверки, может ли заданный кандидат быть лидером, очень прост. Поддерживаем set участников, которые в данный момент есть в митинге. Идем по списку сообщений и добавляем или удаляем соответствующих участников. Перед и после каждой операцией проверяем, что если список участников не пуст, то наш кандидат должен в нем присутствовать.Хитрыми тестами в этой задаче оказались тесты 33 и 34, на которых упали решения многих участников. Тест 33 выглядит так.4 4+ 2- 1- 3- 2Здесь лидером может быть только 4-ый участник (в предположении, что он всегда находится на митинге). Второй не может быть лидером, так как изначально он не участвовал в митинге, а первый и третий участвовали. Но они тоже не могут быть лидерами, так как вышли из митинга в то время, когда там находился второй участник.Тест 34 следующий.3 3- 2+ 1+ 2В данном тесте лидером может быть только 3-ий участник. Второй изначально находится на митинге, потом уходит, но далее приходит первый, поэтому второй не может быть лидером. Первый не может быть лидером, потому что он изначально не находится на митинге, а второй участник находится.420C - Баг в кодеДавайте построим неориентированный граф, вершины которого — это люди, а ребро между двумя людьми a, b есть, если существует высказывание человека (виноват a или b). Как теперь переформулируется задача в терминах этого графа? Нужно посчитать количество таких пар вершин, что им инцидентно как минимум p ребер.Сделаем следующее. Сохраним граф в виде списков смежности, а также создадим массив степеней всех вершин графа и отсортируем его. Будем перебирать одну вершину и считать, сколько существует вершин в пару ей, чтобы получилась нужная пара вершин. Первое, что приходит в голову — это для каждой вершины v добавить к ответу количество вершин u таких, что d[u] + d[v] ≥ p (количество таких вершин можно просто посчитать бинарным поиском, например). К сожалению, это неправильно, поскольку в сумме d[u] + d[v] ребра между v и u учитываются два раза.Но, давайте посчитаем ответ неправильно, а потом учтем все то, что мы неправильно посчитали. А именно, для каждой вершины пройдемся по списку ее соседей и для каждого уникального соседа вычтем его из ответ, если он добавился туда (если d[v] + d[u] ≥ p). Теперь осталось учесть в ответе все вершины, которые смежны в графе. Это делается простым проходом по ребрам.Обратите внимание, что в этой задаче в графе могут получиться мультиребра, их нужно аккуратно обрабатывать.420D - Фокус со стаканчикамиРешение состоит из двух этапов.1) Определим возможную исходную перестановку.Будем идти по заданным запросам. Пусть текущий запрос утверждает, что число a стоит на позиции b. Если a уже раньше встречалось, то пропустим такой запрос. Иначе определим, на какой позиции находится a в искомой перестановке.Пусть мы уже знаем, что в искомой перестановке число a1 стоит на позиции b1, a2 на позиции b2, ..., ak на позиции bk (b1 < b2 < ... < bk). Так как после объявления позиции числа оно перемещается в самое начало перестановки, то значит до того как мы объявили о позиции a все ai (1 ≤ i ≤ k) уже находятся перед a. Но при этом некоторые из этих ai уже находились раньше a в искомой перестановке, а остальные находились позже, но переместились вперед. Найдем их количество. Для этого нужно найти такую свободную позицию p в исходной перестановке, что p + x = b, где x — количество bi таких, что bi > x. Это можно найти с помощью дерева отрезков следующим образом. Будем хранить в вершине дерева отрезков количество уже занятых позиций искомой перестановки на соответствующем подотрезке. Предположим, мы хотим найти p в некотором поддереве. Посмотрим на минимальную позицию в правом поддереве prg и на количество занятых там позиций xrg. Тогда если prg + xrg ≤ b, то нужно продолжать искать в правом поддереве. Если же prg + xrg > b, то нужно продолжать искать в левом поддереве, уменьшив при этом b на величину xrg. Когда мы нашли p, проверим выполнение условия p + x = b. Если оно не выполняется, то ответ  - 1.2) Проверим, что последовательность операций корректная.Пусть мы рассматриваем i-ый запрос, утверждающий, что число a стоит на позиции b. Нужно проверить, что он верен. Если a раньше не встречалось в запросах, то запрос верен, так как мы проверили b еще на первом этапе. Если оно раньше встречалось, найдем такое максимальное j < i, что j-ый запрос также объявляет, в какой позиции находится a. После j-го запроса a перемещается в начало перестановки, а далее другие числа могут передвигать его вправо. Найдем количество различных таких чисел на отрезке запросов [j + 1, i - 1], их должно быть ровно b - 1.420E - Игра в мячСкажем, что в данной задаче у нас есть луч, на котором есть бесконечное число шариков, находящихся на расстояниях, кратных d от начала луча. Заметим, что хотя бы один шарик, который будет посчитан в ответе должен упираться в границу какого-нибудь круга. Также заметим, что если мы рассмотрим любой круг, то количество углов a на которые нужно повернуть наш луч так, чтобы какой-нибудь из шариков лежал на границе этого круга не превосходит 4 * r / d. Назовем такие углы критическими.Выпишем все возможные критические углы от всех окружностей в массив B и отсортируем его. Далее для каждой окружности выпишем ее критические углы и отсортируем. Тогда между двумя соседними критическими углами количество шаров, попадающих в круг будет постоянно. Посчитаем k это количество, найдем данные углы в B. Тогда повернув луч на любой угол, находящийся между ними, к ответу будет прибавляться k.Заведем массив C такой, что Ci — ответ, если мы повернули луч на угол Bi. Тогда после того как мы нашли k и позиции углов в B, нужно сделать прибавление на отрезке в массиве C. После того как мы обработаем все критические углы всех кругов нужно найти максимум в массиве C.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 420\\s*D"
          },
          "content_length": 7457
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random_valid\") {\n        if (n > 100000) {\n            n = 100000; // Limit n to 1e5 for efficient simulation\n        }\n        if (m > n) {\n            m = n;\n        }\n        // Generate the lex smallest initial permutation\n        vector<int> cups(n);\n        for (int i = 0; i < n; ++i) {\n            cups[i] = i + 1;\n        }\n        vector<pair<int, int>> operations;\n        for (int i = 0; i < m; ++i) {\n            int yi = rnd.next(1, n);\n            int xi = cups[yi - 1];\n            operations.push_back(make_pair(xi, yi));\n            // Move cup at position yi to front\n            int cup = cups[yi - 1];\n            cups.erase(cups.begin() + yi - 1);\n            cups.insert(cups.begin(), cup);\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the operations\n        for (auto op : operations) {\n            printf(\"%d %d\\n\", op.first, op.second);\n        }\n    } else if (type == \"invalid\") {\n        // Generate operations that make the problem impossible\n        printf(\"%d %d\\n\", n, m);\n        map<int, set<int>> xi_positions;\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            if (xi_positions[xi].count(yi)) {\n                yi = (yi % n) + 1; // Ensure yi is different to create conflict\n            }\n            xi_positions[xi].insert(yi);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else if (type == \"same_xi\") {\n        // All xi are the same\n        int xi = rnd.next(1, n);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else if (type == \"max_size\") {\n        n = 1000000;\n        m = 1000000;\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else if (type == \"small_n\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(0, n);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else { // Default random type\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"random_valid\") {\n        if (n > 100000) {\n            n = 100000; // Limit n to 1e5 for efficient simulation\n        }\n        if (m > n) {\n            m = n;\n        }\n        // Generate the lex smallest initial permutation\n        vector<int> cups(n);\n        for (int i = 0; i < n; ++i) {\n            cups[i] = i + 1;\n        }\n        vector<pair<int, int>> operations;\n        for (int i = 0; i < m; ++i) {\n            int yi = rnd.next(1, n);\n            int xi = cups[yi - 1];\n            operations.push_back(make_pair(xi, yi));\n            // Move cup at position yi to front\n            int cup = cups[yi - 1];\n            cups.erase(cups.begin() + yi - 1);\n            cups.insert(cups.begin(), cup);\n        }\n        // Output n and m\n        printf(\"%d %d\\n\", n, m);\n        // Output the operations\n        for (auto op : operations) {\n            printf(\"%d %d\\n\", op.first, op.second);\n        }\n    } else if (type == \"invalid\") {\n        // Generate operations that make the problem impossible\n        printf(\"%d %d\\n\", n, m);\n        map<int, set<int>> xi_positions;\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            if (xi_positions[xi].count(yi)) {\n                yi = (yi % n) + 1; // Ensure yi is different to create conflict\n            }\n            xi_positions[xi].insert(yi);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else if (type == \"same_xi\") {\n        // All xi are the same\n        int xi = rnd.next(1, n);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else if (type == \"max_size\") {\n        n = 1000000;\n        m = 1000000;\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else if (type == \"small_n\") {\n        n = rnd.next(1, 10);\n        m = rnd.next(0, n);\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else { // Default random type\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = rnd.next(1, n);\n            int yi = rnd.next(1, n);\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random_valid\n./gen -n 100 -m 50 -type random_valid\n./gen -n 1000 -m 500 -type random_valid\n./gen -n 10000 -m 5000 -type random_valid\n./gen -n 100000 -m 50000 -type random_valid\n\n./gen -n 10 -m 5 -type invalid\n./gen -n 1000 -m 1000 -type invalid\n./gen -n 1000000 -m 1000000 -type invalid\n\n./gen -n 10 -m 7 -type same_xi\n./gen -n 1000 -m 700 -type same_xi\n./gen -n 1000000 -m 700000 -type same_xi\n\n./gen -n 5 -m 3 -type small_n\n./gen -n 10 -m 5 -type small_n\n./gen -n 15 -m 7 -type small_n\n\n./gen -n 1000000 -m 1000000 -type max_size\n\n./gen -n 10 -m 10 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000000 -m 1000000 -type random\n\n./gen -n 100 -m 50 -type random_valid\n./gen -n 500 -m 250 -type random_valid\n./gen -n 10000 -m 8000 -type random_valid\n./gen -n 50000 -m 40000 -type random_valid\n\n./gen -n 10 -m 10 -type invalid\n./gen -n 100 -m 100 -type invalid\n./gen -n 1000 -m 1000 -type invalid\n\n./gen -n 2 -m 1 -type small_n\n./gen -n 3 -m 2 -type small_n\n./gen -n 5 -m 5 -type small_n\n\n./gen -n 1000 -m 500 -type same_xi\n./gen -n 5000 -m 2500 -type same_xi\n./gen -n 10000 -m 5000 -type same_xi\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:34.418912",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "420/E",
      "title": "E. Playing the ball",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers — n и d (1 ≤ n ≤ 2·104; 5 ≤ d ≤ 10). Next n lines contain the circles' description. The i-th line contains three space-separated integers xi, yi, ri ( - 10000 ≤ xi, yi ≤ 10000; 1 ≤ r ≤ 50), where (xi, yi, ri) are the coordinates of the center and the radius of the circle, correspondingly. The point (0, 0) is not inside or on the border of some circle.",
      "output_spec": "OutputPrint a single integer — the maximum number of points you can get.",
      "sample_tests": "ExamplesInputCopy2 51 1 15 0 1OutputCopy1InputCopy2 54 0 35 3 1OutputCopy2InputCopy1 1020 0 10OutputCopy3",
      "description": "E. Playing the ball\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers — n и d (1 ≤ n ≤ 2·104; 5 ≤ d ≤ 10). Next n lines contain the circles' description. The i-th line contains three space-separated integers xi, yi, ri ( - 10000 ≤ xi, yi ≤ 10000; 1 ≤ r ≤ 50), where (xi, yi, ri) are the coordinates of the center and the radius of the circle, correspondingly. The point (0, 0) is not inside or on the border of some circle.\n\nOutputPrint a single integer — the maximum number of points you can get.\n\nInputCopy2 51 1 15 0 1OutputCopy1InputCopy2 54 0 35 3 1OutputCopy2InputCopy1 1020 0 10OutputCopy3\n\nInputCopy2 51 1 15 0 1\n\nOutputCopy1\n\nInputCopy2 54 0 35 3 1\n\nOutputCopy2\n\nInputCopy1 1020 0 10\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 420\\s*E"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(5, 10, \"d\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000, 10000);\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000);\n        inf.readSpace();\n        int ri = inf.readInt(1, 50);\n        inf.readEoln();\n        long long x2_y2 = 1LL * xi * xi + 1LL * yi * yi;\n        long long r2 = 1LL * ri * ri;\n        ensuref(x2_y2 > r2, \"Circle %d: The point (0,0) must not be inside or on the border of any circle\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(5, 10, \"d\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000, 10000);\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000);\n        inf.readSpace();\n        int ri = inf.readInt(1, 50);\n        inf.readEoln();\n        long long x2_y2 = 1LL * xi * xi + 1LL * yi * yi;\n        long long r2 = 1LL * ri * ri;\n        ensuref(x2_y2 > r2, \"Circle %d: The point (0,0) must not be inside or on the border of any circle\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(5, 10, \"d\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000, 10000);\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000);\n        inf.readSpace();\n        int ri = inf.readInt(1, 50);\n        inf.readEoln();\n        long long x2_y2 = 1LL * xi * xi + 1LL * yi * yi;\n        long long r2 = 1LL * ri * ri;\n        ensuref(x2_y2 > r2, \"Circle %d: The point (0,0) must not be inside or on the border of any circle\", i+1);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Circle {\n    int x;\n    int y;\n    int r;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", 7); // default value of d is 7\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 20000);\n    ensure(5 <= d && d <= 10);\n\n    vector<Circle> circles;\n\n    if (type == \"random\") {\n        // generate random circles\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (hypot(xi, yi) <= ri + 1.0);\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"max_points\") {\n        // generate a circle that covers as many hits as possible\n        int ri = 50; // maximum radius\n        int xi = ri + 1; // to ensure origin is outside circle\n        circles.push_back({xi, 0, ri});\n        n = 1;\n    } else if (type == \"multiple_hits\") {\n        // generate circle to be hit multiple times\n        int ri = 50;\n        int xi = ri + d; // position to allow multiple hits\n        circles.push_back({xi, 0, ri});\n        n = 1;\n    } else if (type == \"line\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = i * (20000 / max(1, n - 1)) - 10000; // distribute from -10000 to 10000\n            int yi = 0;\n            int ri = rnd.next(1, 50);\n            if (hypot(xi, yi) <= ri + 1.0) {\n                yi += ri + 2; // Shift to ensure not containing origin\n            }\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"overlap\") {\n        int xi = rnd.next(-10000, 10000);\n        int yi = rnd.next(-10000, 10000);\n        if (hypot(xi, yi) <= 50 + 1.0) {\n            xi += 50 + 2; // Shift to ensure not containing origin\n        }\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"near_origin\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            double distance = ri + 1 + rnd.next(1, 10); // slightly more than ri + 1\n            double angle = rnd.next(0.0, 2 * acos(-1.0));\n            int xi = int(distance * cos(angle));\n            int yi = int(distance * sin(angle));\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"far_away\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            int xi = rnd.next(-10000, -9000);\n            int yi = rnd.next(-10000, -9000);\n            if (hypot(xi, yi) <= ri + 1.0) {\n                xi -= (ri + 2); // Ensure not containing origin\n            }\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"minimal_radius\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = 1;\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (hypot(xi, yi) <= ri + 1.0);\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"maximal_radius\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = 50;\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (hypot(xi, yi) <= ri + 1.0);\n            circles.push_back({xi, yi, ri});\n        }\n    } else {\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, d);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", circles[i].x, circles[i].y, circles[i].r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Circle {\n    int x;\n    int y;\n    int r;\n};\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int d = opt<int>(\"d\", 7); // default value of d is 7\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(1 <= n && n <= 20000);\n    ensure(5 <= d && d <= 10);\n\n    vector<Circle> circles;\n\n    if (type == \"random\") {\n        // generate random circles\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (hypot(xi, yi) <= ri + 1.0);\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"max_points\") {\n        // generate a circle that covers as many hits as possible\n        int ri = 50; // maximum radius\n        int xi = ri + 1; // to ensure origin is outside circle\n        circles.push_back({xi, 0, ri});\n        n = 1;\n    } else if (type == \"multiple_hits\") {\n        // generate circle to be hit multiple times\n        int ri = 50;\n        int xi = ri + d; // position to allow multiple hits\n        circles.push_back({xi, 0, ri});\n        n = 1;\n    } else if (type == \"line\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = i * (20000 / max(1, n - 1)) - 10000; // distribute from -10000 to 10000\n            int yi = 0;\n            int ri = rnd.next(1, 50);\n            if (hypot(xi, yi) <= ri + 1.0) {\n                yi += ri + 2; // Shift to ensure not containing origin\n            }\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"overlap\") {\n        int xi = rnd.next(-10000, 10000);\n        int yi = rnd.next(-10000, 10000);\n        if (hypot(xi, yi) <= 50 + 1.0) {\n            xi += 50 + 2; // Shift to ensure not containing origin\n        }\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"near_origin\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            double distance = ri + 1 + rnd.next(1, 10); // slightly more than ri + 1\n            double angle = rnd.next(0.0, 2 * acos(-1.0));\n            int xi = int(distance * cos(angle));\n            int yi = int(distance * sin(angle));\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"far_away\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = rnd.next(1, 50);\n            int xi = rnd.next(-10000, -9000);\n            int yi = rnd.next(-10000, -9000);\n            if (hypot(xi, yi) <= ri + 1.0) {\n                xi -= (ri + 2); // Ensure not containing origin\n            }\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"minimal_radius\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = 1;\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (hypot(xi, yi) <= ri + 1.0);\n            circles.push_back({xi, yi, ri});\n        }\n    } else if (type == \"maximal_radius\") {\n        for (int i = 0; i < n; ++i) {\n            int ri = 50;\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (hypot(xi, yi) <= ri + 1.0);\n            circles.push_back({xi, yi, ri});\n        }\n    } else {\n        fprintf(stderr, \"Invalid type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", n, d);\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", circles[i].x, circles[i].y, circles[i].r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d 5 -type random\n./gen -n 1 -d 10 -type max_points\n./gen -n 2 -d 7 -type multiple_hits\n./gen -n 2 -d 6 -type line\n./gen -n 10 -d 5 -type random\n./gen -n 10 -d 9 -type overlap\n./gen -n 100 -d 6 -type near_origin\n./gen -n 100 -d 10 -type far_away\n./gen -n 1000 -d 5 -type maximal_radius\n./gen -n 1000 -d 8 -type minimal_radius\n./gen -n 20000 -d 7 -type random\n./gen -n 20000 -d 5 -type max_points\n./gen -n 20000 -d 10 -type multiple_hits\n./gen -n 20000 -d 6 -type line\n./gen -n 20000 -d 8 -type near_origin\n./gen -n 20000 -d 5 -type far_away\n./gen -n 10000 -d 10 -type overlap\n./gen -n 10000 -d 7 -type maximal_radius\n./gen -n 5000 -d 5 -type minimal_radius\n./gen -n 300 -d 9 -type random\n./gen -n 1000 -d 8 -type random\n./gen -n 15000 -d 7 -type random\n./gen -n 20000 -d 5 -type overlap\n./gen -n 20000 -d 10 -type near_origin\n./gen -n 1 -d 6 -type max_points\n./gen -n 5 -d 5 -type multiple_hits\n./gen -n 20000 -d 5 -type random\n./gen -n 20000 -d 7 -type maximal_radius\n./gen -n 20000 -d 6 -type minimal_radius\n./gen -n 100 -d 5 -type random\n./gen -n 20000 -d 10 -type max_points\n./gen -n 20000 -d 5 -type multiple_hits\n./gen -n 20000 -d 7 -type line\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:36.581511",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "421/A",
      "title": "A. Pasha and Hamsters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, a, b (1 ≤ n ≤ 100; 1 ≤ a, b ≤ n) — the number of apples Pasha has, the number of apples Arthur likes and the number of apples Alexander likes, correspondingly.The next line contains a distinct integers — the numbers of the apples Arthur likes. The next line contains b distinct integers — the numbers of the apples Alexander likes.Assume that the apples are numbered from 1 to n. The input is such that the answer exists.",
      "output_spec": "OutputPrint n characters, each of them equals either 1 or 2. If the i-h character equals 1, then the i-th apple should be given to Arthur, otherwise it should be given to Alexander. If there are multiple correct answers, you are allowed to print any of them.",
      "sample_tests": "ExamplesInputCopy4 2 31 22 3 4OutputCopy1 1 2 2InputCopy5 5 23 4 1 2 52 3OutputCopy1 1 1 1 1",
      "description": "A. Pasha and Hamsters\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, a, b (1 ≤ n ≤ 100; 1 ≤ a, b ≤ n) — the number of apples Pasha has, the number of apples Arthur likes and the number of apples Alexander likes, correspondingly.The next line contains a distinct integers — the numbers of the apples Arthur likes. The next line contains b distinct integers — the numbers of the apples Alexander likes.Assume that the apples are numbered from 1 to n. The input is such that the answer exists.\n\nOutputPrint n characters, each of them equals either 1 or 2. If the i-h character equals 1, then the i-th apple should be given to Arthur, otherwise it should be given to Alexander. If there are multiple correct answers, you are allowed to print any of them.\n\nInputCopy4 2 31 22 3 4OutputCopy1 1 2 2InputCopy5 5 23 4 1 2 52 3OutputCopy1 1 1 1 1\n\nInputCopy4 2 31 22 3 4\n\nOutputCopy1 1 2 2\n\nInputCopy5 5 23 4 1 2 52 3\n\nOutputCopy1 1 1 1 1",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 421\\s*A"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n\n    vector<int> arthurApples = inf.readInts(a, 1, n, \"arthurApples\");\n    inf.readEoln();\n\n    ensuref(set<int>(arthurApples.begin(), arthurApples.end()).size() == a, \"Arthur's apples are not distinct\");\n\n    vector<int> alexanderApples = inf.readInts(b, 1, n, \"alexanderApples\");\n    inf.readEoln();\n\n    ensuref(set<int>(alexanderApples.begin(), alexanderApples.end()).size() == b, \"Alexander's apples are not distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n\n    vector<int> arthurApples = inf.readInts(a, 1, n, \"arthurApples\");\n    inf.readEoln();\n\n    ensuref(set<int>(arthurApples.begin(), arthurApples.end()).size() == a, \"Arthur's apples are not distinct\");\n\n    vector<int> alexanderApples = inf.readInts(b, 1, n, \"alexanderApples\");\n    inf.readEoln();\n\n    ensuref(set<int>(alexanderApples.begin(), alexanderApples.end()).size() == b, \"Alexander's apples are not distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int a = inf.readInt(1, n, \"a\");\n    inf.readSpace();\n    int b = inf.readInt(1, n, \"b\");\n    inf.readEoln();\n\n    vector<int> arthurApples = inf.readInts(a, 1, n, \"arthurApples\");\n    inf.readEoln();\n\n    ensuref(set<int>(arthurApples.begin(), arthurApples.end()).size() == a, \"Arthur's apples are not distinct\");\n\n    vector<int> alexanderApples = inf.readInts(b, 1, n, \"alexanderApples\");\n    inf.readEoln();\n\n    ensuref(set<int>(alexanderApples.begin(), alexanderApples.end()).size() == b, \"Alexander's apples are not distinct\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n, a, b from the input file\n    int n = inf.readInt(1, 100, \"n\"); \n    int a = inf.readInt(1, n, \"a\");\n    int b = inf.readInt(1, n, \"b\");\n\n    // Read the list of apples Arthur likes\n    set<int> arthurLikes;\n    for (int i = 0; i < a; i++) {\n        int ai = inf.readInt(1, n, format(\"Arthur's apple %d\", i + 1).c_str());\n        if (!arthurLikes.insert(ai).second) {\n            quitf(_fail, \"Arthur likes apple %d multiple times\", ai);\n        }\n    }\n\n    // Read the list of apples Alexander likes\n    set<int> alexLikes;\n    for (int i = 0; i < b; i++) {\n        int bi = inf.readInt(1, n, format(\"Alexander's apple %d\", i + 1).c_str());\n        if (!alexLikes.insert(bi).second) {\n            quitf(_fail, \"Alexander likes apple %d multiple times\", bi);\n        }\n    }\n\n    // Read the contestant's output\n    vector<int> assignment = ouf.readInts(n, 1, 2, \"assignment\");\n\n    // Check the validity of the assignment\n    for (int i = 0; i < n; i++) {\n        int assignedHamster = assignment[i];\n        int appleNumber = i + 1;\n        if (assignedHamster == 1) {\n            if (arthurLikes.count(appleNumber) == 0) {\n                quitf(_wa, \"Apple %d assigned to Arthur but he doesn't like it\", appleNumber);\n            }\n        } else { // assignedHamster == 2\n            if (alexLikes.count(appleNumber) == 0) {\n                quitf(_wa, \"Apple %d assigned to Alexander but he doesn't like it\", appleNumber);\n            }\n        }\n    }\n\n    // If all checks pass, the answer is correct\n    quitf(_ok, \"Correct assignment\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> arthur_likes, alexander_likes;\n\n    if (type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            int k = rnd.next(0, 2); // 0: Arthur only, 1: Alexander only, 2: both\n            if (k == 0 || k == 2) arthur_likes.push_back(i);\n            if (k == 1 || k == 2) alexander_likes.push_back(i);\n        }\n    } else if (type == \"max_overlap\") {\n        for (int i = 1; i <= n; ++i) {\n            arthur_likes.push_back(i);\n            alexander_likes.push_back(i);\n        }\n    } else if (type == \"no_overlap\") {\n        for (int i = 1; i <= n; ++i) {\n            int k = rnd.next(0, 1); // 0: Arthur, 1: Alexander\n            if (k == 0) arthur_likes.push_back(i);\n            else alexander_likes.push_back(i);\n        }\n    } else if (type == \"one_likes_all\") {\n        // Decide which hamster likes all apples\n        int k = rnd.next(0, 1); // 0: Arthur likes all, 1: Alexander likes all\n\n        if (k == 0) {\n            // Arthur likes all, Alexander likes some apples\n            for (int i = 1; i <= n; ++i) {\n                arthur_likes.push_back(i);\n            }\n            // Alexander likes at least one apple\n            int b_size = rnd.next(1, n);\n            vector<int> apples(n);\n            iota(apples.begin(), apples.end(), 1);\n            shuffle(apples.begin(), apples.end());\n            for (int i = 0; i < b_size; ++i) {\n                alexander_likes.push_back(apples[i]);\n            }\n        } else {\n            // Alexander likes all, Arthur likes some apples\n            for (int i = 1; i <= n; ++i) {\n                alexander_likes.push_back(i);\n            }\n            // Arthur likes at least one apple\n            int a_size = rnd.next(1, n);\n            vector<int> apples(n);\n            iota(apples.begin(), apples.end(), 1);\n            shuffle(apples.begin(), apples.end());\n            for (int i = 0; i < a_size; ++i) {\n                arthur_likes.push_back(apples[i]);\n            }\n        }\n    } else {\n        printf(\"Unknown type\\n\");\n        return 1;\n    }\n\n    // Ensure that both hamsters like at least one apple\n    if (arthur_likes.empty()) {\n        arthur_likes.push_back(rnd.next(1, n));\n    }\n    if (alexander_likes.empty()) {\n        alexander_likes.push_back(rnd.next(1, n));\n    }\n\n    // Remove duplicates and sort\n    sort(arthur_likes.begin(), arthur_likes.end());\n    arthur_likes.erase(unique(arthur_likes.begin(), arthur_likes.end()), arthur_likes.end());\n    sort(alexander_likes.begin(), alexander_likes.end());\n    alexander_likes.erase(unique(alexander_likes.begin(), alexander_likes.end()), alexander_likes.end());\n\n    // Output n, a, b\n    int a = arthur_likes.size();\n    int b = alexander_likes.size();\n    printf(\"%d %d %d\\n\", n, a, b);\n\n    // Output Arthur's liked apples\n    for (int i = 0; i < a; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", arthur_likes[i]);\n    }\n    printf(\"\\n\");\n\n    // Output Alexander's liked apples\n    for (int i = 0; i < b; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", alexander_likes[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> arthur_likes, alexander_likes;\n\n    if (type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            int k = rnd.next(0, 2); // 0: Arthur only, 1: Alexander only, 2: both\n            if (k == 0 || k == 2) arthur_likes.push_back(i);\n            if (k == 1 || k == 2) alexander_likes.push_back(i);\n        }\n    } else if (type == \"max_overlap\") {\n        for (int i = 1; i <= n; ++i) {\n            arthur_likes.push_back(i);\n            alexander_likes.push_back(i);\n        }\n    } else if (type == \"no_overlap\") {\n        for (int i = 1; i <= n; ++i) {\n            int k = rnd.next(0, 1); // 0: Arthur, 1: Alexander\n            if (k == 0) arthur_likes.push_back(i);\n            else alexander_likes.push_back(i);\n        }\n    } else if (type == \"one_likes_all\") {\n        // Decide which hamster likes all apples\n        int k = rnd.next(0, 1); // 0: Arthur likes all, 1: Alexander likes all\n\n        if (k == 0) {\n            // Arthur likes all, Alexander likes some apples\n            for (int i = 1; i <= n; ++i) {\n                arthur_likes.push_back(i);\n            }\n            // Alexander likes at least one apple\n            int b_size = rnd.next(1, n);\n            vector<int> apples(n);\n            iota(apples.begin(), apples.end(), 1);\n            shuffle(apples.begin(), apples.end());\n            for (int i = 0; i < b_size; ++i) {\n                alexander_likes.push_back(apples[i]);\n            }\n        } else {\n            // Alexander likes all, Arthur likes some apples\n            for (int i = 1; i <= n; ++i) {\n                alexander_likes.push_back(i);\n            }\n            // Arthur likes at least one apple\n            int a_size = rnd.next(1, n);\n            vector<int> apples(n);\n            iota(apples.begin(), apples.end(), 1);\n            shuffle(apples.begin(), apples.end());\n            for (int i = 0; i < a_size; ++i) {\n                arthur_likes.push_back(apples[i]);\n            }\n        }\n    } else {\n        printf(\"Unknown type\\n\");\n        return 1;\n    }\n\n    // Ensure that both hamsters like at least one apple\n    if (arthur_likes.empty()) {\n        arthur_likes.push_back(rnd.next(1, n));\n    }\n    if (alexander_likes.empty()) {\n        alexander_likes.push_back(rnd.next(1, n));\n    }\n\n    // Remove duplicates and sort\n    sort(arthur_likes.begin(), arthur_likes.end());\n    arthur_likes.erase(unique(arthur_likes.begin(), arthur_likes.end()), arthur_likes.end());\n    sort(alexander_likes.begin(), alexander_likes.end());\n    alexander_likes.erase(unique(alexander_likes.begin(), alexander_likes.end()), alexander_likes.end());\n\n    // Output n, a, b\n    int a = arthur_likes.size();\n    int b = alexander_likes.size();\n    printf(\"%d %d %d\\n\", n, a, b);\n\n    // Output Arthur's liked apples\n    for (int i = 0; i < a; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", arthur_likes[i]);\n    }\n    printf(\"\\n\");\n\n    // Output Alexander's liked apples\n    for (int i = 0; i < b; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", alexander_likes[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type max_overlap\n./gen -n 1 -type no_overlap\n./gen -n 1 -type one_likes_all\n\n./gen -n 2 -type random\n./gen -n 2 -type max_overlap\n./gen -n 2 -type no_overlap\n./gen -n 2 -type one_likes_all\n\n./gen -n 5 -type random\n./gen -n 5 -type no_overlap\n\n./gen -n 10 -type random\n./gen -n 10 -type max_overlap\n./gen -n 10 -type no_overlap\n./gen -n 10 -type one_likes_all\n\n./gen -n 50 -type random\n./gen -n 50 -type max_overlap\n./gen -n 50 -type no_overlap\n./gen -n 50 -type one_likes_all\n\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n\n./gen -n 100 -type max_overlap\n./gen -n 100 -type no_overlap\n./gen -n 100 -type one_likes_all\n\n./gen -n 99 -type one_likes_all\n./gen -n 100 -type one_likes_all\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:38.178014",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "421/B",
      "title": "B. Start Up",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:",
      "output_spec": "OutputPrint 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).",
      "sample_tests": "ExamplesInputCopyAHAOutputCopyYESInputCopyZOutputCopyNOInputCopyXOOutputCopyNO",
      "description": "B. Start Up\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a non-empty name that needs to be checked. The name contains at most 105 large English letters. The name will be written with the next sans serif font:\n\nOutputPrint 'YES' (without the quotes), if the given name matches its mirror reflection. Otherwise, print 'NO' (without the quotes).\n\nInputCopyAHAOutputCopyYESInputCopyZOutputCopyNOInputCopyXOOutputCopyNO\n\nInputCopyAHA\n\nOutputCopyYES\n\nOutputCopyNO\n\nInputCopyXO\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 421 和字母"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    // Read the first line and ensure it contains only uppercase letters and length is between 1 and 1e5\n    string name = inf.readLine(\"[A-Z]{1,100000}\", \"name\");\n\n    // Ensure that there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    // Read the first line and ensure it contains only uppercase letters and length is between 1 and 1e5\n    string name = inf.readLine(\"[A-Z]{1,100000}\", \"name\");\n\n    // Ensure that there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n\n    // Read the first line and ensure it contains only uppercase letters and length is between 1 and 1e5\n    string name = inf.readLine(\"[A-Z]{1,100000}\", \"name\");\n\n    // Ensure that there is no extra input\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    \n    vector<char> valid_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'};\n    vector<char> invalid_letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        if (find(valid_letters.begin(), valid_letters.end(), c) == valid_letters.end()) {\n            invalid_letters.push_back(c);\n        }\n    }\n\n    string s(n, ' ');\n\n    if (type == \"valid_mirror\") {\n        // Generate a valid mirror string\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n            s[i] = c;\n            s[n - i -1] = c;\n        }\n    } else if (type == \"invalid_letter\") {\n        // Generate a string containing invalid letters\n        for (int i = 0; i < n; ++i) {\n            char c = invalid_letters[rnd.next(0, (int)invalid_letters.size()-1)];\n            s[i] = c;\n        }\n    } else if (type == \"valid_non_mirror\") {\n        // Generate a string with valid letters but not a mirror string\n        for (int i = 0; i < n; ++i) {\n            s[i] = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n        }\n        // Ensure it's not a mirror string\n        bool is_mirror = true;\n        for (int i = 0; i < n/2; ++i) {\n            if (s[i] != s[n - i -1]) {\n                is_mirror = false;\n                break;\n            }\n        }\n        if (is_mirror) {\n            // Make it not a mirror string\n            int pos = rnd.next(0, n/2);\n            char c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n            while (c == s[pos]) {\n                c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n            }\n            s[pos] = c;\n        }\n    } else if (type == \"palindrome_invalid\") {\n        // Generate a palindrome containing invalid letters\n        for (int i = 0; i < (n+1)/2; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                char c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n                s[i] = c;\n                s[n - i -1] = c;\n            } else {\n                char c = invalid_letters[rnd.next(0, (int)invalid_letters.size()-1)];\n                s[i] = c;\n                s[n - i -1] = c;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random string of uppercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(0, 25);\n            s[i] = c;\n        }\n    } else {\n        // Default: random string\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(0, 25);\n            s[i] = c;\n        }\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    \n    vector<char> valid_letters = {'A', 'H', 'I', 'M', 'O', 'T', 'U', 'V', 'W', 'X', 'Y'};\n    vector<char> invalid_letters;\n    for (char c = 'A'; c <= 'Z'; ++c) {\n        if (find(valid_letters.begin(), valid_letters.end(), c) == valid_letters.end()) {\n            invalid_letters.push_back(c);\n        }\n    }\n\n    string s(n, ' ');\n\n    if (type == \"valid_mirror\") {\n        // Generate a valid mirror string\n        for (int i = 0; i < (n+1)/2; ++i) {\n            char c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n            s[i] = c;\n            s[n - i -1] = c;\n        }\n    } else if (type == \"invalid_letter\") {\n        // Generate a string containing invalid letters\n        for (int i = 0; i < n; ++i) {\n            char c = invalid_letters[rnd.next(0, (int)invalid_letters.size()-1)];\n            s[i] = c;\n        }\n    } else if (type == \"valid_non_mirror\") {\n        // Generate a string with valid letters but not a mirror string\n        for (int i = 0; i < n; ++i) {\n            s[i] = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n        }\n        // Ensure it's not a mirror string\n        bool is_mirror = true;\n        for (int i = 0; i < n/2; ++i) {\n            if (s[i] != s[n - i -1]) {\n                is_mirror = false;\n                break;\n            }\n        }\n        if (is_mirror) {\n            // Make it not a mirror string\n            int pos = rnd.next(0, n/2);\n            char c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n            while (c == s[pos]) {\n                c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n            }\n            s[pos] = c;\n        }\n    } else if (type == \"palindrome_invalid\") {\n        // Generate a palindrome containing invalid letters\n        for (int i = 0; i < (n+1)/2; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                char c = valid_letters[rnd.next(0, (int)valid_letters.size()-1)];\n                s[i] = c;\n                s[n - i -1] = c;\n            } else {\n                char c = invalid_letters[rnd.next(0, (int)invalid_letters.size()-1)];\n                s[i] = c;\n                s[n - i -1] = c;\n            }\n        }\n    } else if (type == \"random\") {\n        // Generate a random string of uppercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(0, 25);\n            s[i] = c;\n        }\n    } else {\n        // Default: random string\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(0, 25);\n            s[i] = c;\n        }\n    }\n\n    // Output the string\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type valid_mirror\n./gen -n 1 -type invalid_letter\n./gen -n 1 -type random\n\n./gen -n 2 -type valid_mirror\n./gen -n 2 -type invalid_letter\n./gen -n 2 -type palindrome_invalid\n./gen -n 2 -type valid_non_mirror\n\n./gen -n 5 -type valid_mirror\n./gen -n 5 -type valid_non_mirror\n./gen -n 5 -type palindrome_invalid\n\n./gen -n 10 -type valid_mirror\n./gen -n 10 -type invalid_letter\n./gen -n 10 -type valid_non_mirror\n./gen -n 10 -type random\n\n./gen -n 50 -type valid_mirror\n./gen -n 50 -type valid_non_mirror\n./gen -n 50 -type palindrome_invalid\n\n./gen -n 100 -type valid_mirror\n./gen -n 100 -type invalid_letter\n./gen -n 100 -type random\n\n./gen -n 1000 -type valid_mirror\n./gen -n 1000 -type valid_non_mirror\n./gen -n 1000 -type palindrome_invalid\n\n./gen -n 10000 -type valid_mirror\n./gen -n 10000 -type invalid_letter\n\n./gen -n 50000 -type valid_mirror\n./gen -n 50000 -type valid_non_mirror\n\n./gen -n 100000 -type valid_mirror\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:40.433420",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "421/C",
      "title": "C. Online Meeting",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and m (1 ≤ n, m ≤ 105) — the number of team participants and the number of messages. Each of the next m lines contains a message in the format:  '+ id': the record means that the person with number id (1 ≤ id ≤ n) has logged on to the meeting.  '- id': the record means that the person with number id (1 ≤ id ≤ n) has logged off from the meeting. Assume that all the people of the team are numbered from 1 to n and the messages are given in the chronological order. It is guaranteed that the given sequence is the correct record of a continuous part of the meeting. It is guaranteed that no two log on/log off events occurred simultaneously.",
      "output_spec": "OutputIn the first line print integer k (0 ≤ k ≤ n) — how many people can be leaders. In the next line, print k integers in the increasing order — the numbers of the people who can be leaders.If the data is such that no member of the team can be a leader, print a single number 0.",
      "sample_tests": "ExamplesInputCopy5 4+ 1+ 2- 2- 1OutputCopy41 3 4 5 InputCopy3 2+ 1- 2OutputCopy13 InputCopy2 4+ 1- 1+ 2- 2OutputCopy0InputCopy5 6+ 1- 1- 3+ 3+ 4- 4OutputCopy32 3 5 InputCopy2 4+ 1- 2+ 2- 1OutputCopy0",
      "description": "C. Online Meeting\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and m (1 ≤ n, m ≤ 105) — the number of team participants and the number of messages. Each of the next m lines contains a message in the format:  '+ id': the record means that the person with number id (1 ≤ id ≤ n) has logged on to the meeting.  '- id': the record means that the person with number id (1 ≤ id ≤ n) has logged off from the meeting. Assume that all the people of the team are numbered from 1 to n and the messages are given in the chronological order. It is guaranteed that the given sequence is the correct record of a continuous part of the meeting. It is guaranteed that no two log on/log off events occurred simultaneously.\n\nOutputIn the first line print integer k (0 ≤ k ≤ n) — how many people can be leaders. In the next line, print k integers in the increasing order — the numbers of the people who can be leaders.If the data is such that no member of the team can be a leader, print a single number 0.\n\nInputCopy5 4+ 1+ 2- 2- 1OutputCopy41 3 4 5 InputCopy3 2+ 1- 2OutputCopy13 InputCopy2 4+ 1- 1+ 2- 2OutputCopy0InputCopy5 6+ 1- 1- 3+ 3+ 4- 4OutputCopy32 3 5 InputCopy2 4+ 1- 2+ 2- 1OutputCopy0\n\nInputCopy5 4+ 1+ 2- 2- 1\n\nOutputCopy41 3 4 5\n\nInputCopy3 2+ 1- 2\n\nOutputCopy13\n\nInputCopy2 4+ 1- 1+ 2- 2\n\nOutputCopy0\n\nInputCopy5 6+ 1- 1- 3+ 3+ 4- 4\n\nOutputCopy32 3 5\n\nInputCopy2 4+ 1- 2+ 2- 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 421 和字母"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        char c = inf.readChar();\n        ensuref(c == '+' || c == '-', \"Expected '+' or '-', but found '%c'\", c);\n        inf.readSpace();\n        int id = inf.readInt(1, n, \"id\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        char c = inf.readChar();\n        ensuref(c == '+' || c == '-', \"Expected '+' or '-', but found '%c'\", c);\n        inf.readSpace();\n        int id = inf.readInt(1, n, \"id\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        char c = inf.readChar();\n        ensuref(c == '+' || c == '-', \"Expected '+' or '-', but found '%c'\", c);\n        inf.readSpace();\n        int id = inf.readInt(1, n, \"id\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<char, int>> messages;\n\n    // online status\n    vector<bool> online(n + 1, false);\n\n    if (type == \"random\") {\n        vector<int> online_users;\n        vector<int> offline_users;\n        for (int id = 1; id <= n; ++id) {\n            if (rnd.next(0, 1)) {\n                online[id] = true;\n                online_users.push_back(id);\n            } else {\n                online[id] = false;\n                offline_users.push_back(id);\n            }\n        }\n        int current_m = 0;\n        while (current_m < m) {\n            int action; // 0 for log on, 1 for log off\n            if (!online_users.empty() && !offline_users.empty()) {\n                action = rnd.next(0, 1);\n            } else if (online_users.empty()) {\n                action = 0; // must log on\n            } else {\n                action = 1; // must log off\n            }\n            if (action == 0) {\n                // log on\n                int idx = rnd.next(0, (int)offline_users.size() - 1);\n                int id = offline_users[idx];\n                messages.push_back(make_pair('+', id));\n                online_users.push_back(id);\n                online[id] = true;\n                offline_users[idx] = offline_users.back();\n                offline_users.pop_back();\n            } else {\n                // log off\n                int idx = rnd.next(0, (int)online_users.size() - 1);\n                int id = online_users[idx];\n                messages.push_back(make_pair('-', id));\n                offline_users.push_back(id);\n                online[id] = false;\n                online_users[idx] = online_users.back();\n                online_users.pop_back();\n            }\n            ++current_m;\n        }\n    } else if (type == \"logoff_at_start\") {\n        int k = min(n, m); // number of users to log off at start\n        // All users are initially online\n        vector<int> initial_online_users(n);\n        for (int id = 1; id <= n; ++id) {\n            initial_online_users[id - 1] = id;\n            online[id] = true;\n        }\n        shuffle(initial_online_users.begin(), initial_online_users.end());\n        for (int i = 0; i < k; ++i) {\n            int id = initial_online_users[i];\n            messages.push_back(make_pair('-', id));\n            online[id] = false;\n        }\n        m -= k;\n        int current_m = 0;\n        vector<int> online_users;\n        vector<int> offline_users;\n        for (int id = 1; id <= n; ++id) {\n            if (online[id]) {\n                online_users.push_back(id);\n            } else {\n                offline_users.push_back(id);\n            }\n        }\n        while (current_m < m) {\n            int action;\n            if (!online_users.empty() && !offline_users.empty()) {\n                action = rnd.next(0, 1);\n            } else if (online_users.empty()) {\n                action = 0; // must log on\n            } else {\n                action = 1; // must log off\n            }\n            if (action == 0) {\n                int idx = rnd.next(0, (int)offline_users.size() - 1);\n                int id = offline_users[idx];\n                messages.push_back(make_pair('+', id));\n                online_users.push_back(id);\n                online[id] = true;\n                offline_users[idx] = offline_users.back();\n                offline_users.pop_back();\n            } else {\n                int idx = rnd.next(0, (int)online_users.size() - 1);\n                int id = online_users[idx];\n                messages.push_back(make_pair('-', id));\n                offline_users.push_back(id);\n                online[id] = false;\n                online_users[idx] = online_users.back();\n                online_users.pop_back();\n            }\n            ++current_m;\n        }\n    } else if (type == \"logon_at_end\") {\n        int k = min(n, m);\n        int messages_to_generate = m - k;\n        int current_m = 0;\n        vector<int> online_users;\n        vector<int> offline_users;\n        for (int id = 1; id <= n; ++id) {\n            online[id] = false;\n            offline_users.push_back(id);\n        }\n        while (current_m < messages_to_generate) {\n            int action;\n            if (!online_users.empty() && !offline_users.empty()) {\n                action = rnd.next(0, 1);\n            } else if (online_users.empty()) {\n                action = 0; // must log on\n            } else {\n                action = 1; // must log off\n            }\n            if (action == 0) {\n                int idx = rnd.next(0, (int)offline_users.size() - 1);\n                int id = offline_users[idx];\n                messages.push_back(make_pair('+', id));\n                online_users.push_back(id);\n                online[id] = true;\n                offline_users[idx] = offline_users.back();\n                offline_users.pop_back();\n            } else {\n                int idx = rnd.next(0, (int)online_users.size() - 1);\n                int id = online_users[idx];\n                messages.push_back(make_pair('-', id));\n                offline_users.push_back(id);\n                online[id] = false;\n                online_users[idx] = online_users.back();\n                online_users.pop_back();\n            }\n            ++current_m;\n        }\n        shuffle(offline_users.begin(), offline_users.end());\n        for (int i = 0; i < k && i < offline_users.size(); ++i) {\n            int id = offline_users[i];\n            messages.push_back(make_pair('+', id));\n            ++current_m;\n        }\n    } else if (type == \"only_logon\") {\n        vector<int> offline_users(n);\n        for (int id = 1; id <= n; ++id) {\n            offline_users[id - 1] = id;\n            online[id] = false;\n        }\n        shuffle(offline_users.begin(), offline_users.end());\n        int current_m = 0;\n        for (int i = 0; i < m && i < offline_users.size(); ++i) {\n            int id = offline_users[i];\n            messages.push_back(make_pair('+', id));\n            online[id] = true;\n            ++current_m;\n        }\n    } else if (type == \"only_logoff\") {\n        vector<int> online_users(n);\n        for (int id = 1; id <= n; ++id) {\n            online_users[id - 1] = id;\n            online[id] = true;\n        }\n        shuffle(online_users.begin(), online_users.end());\n        int current_m = 0;\n        for (int i = 0; i < m && i < online_users.size(); ++i) {\n            int id = online_users[i];\n            messages.push_back(make_pair('-', id));\n            online[id] = false;\n            ++current_m;\n        }\n    } else if (type == \"alternate\") {\n        vector<int> users(n);\n        for (int id = 1; id <= n; ++id) {\n            users[id - 1] = id;\n            online[id] = false;\n        }\n        int current_m = 0;\n        while (current_m < m) {\n            shuffle(users.begin(), users.end());\n            for (int idx = 0; idx < users.size() && current_m < m; ++idx) {\n                int id = users[idx];\n                messages.push_back(make_pair('+', id));\n                online[id] = true;\n                ++current_m;\n                if (current_m >= m) break;\n                messages.push_back(make_pair('-', id));\n                online[id] = false;\n                ++current_m;\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, (int)messages.size());\n    for (auto& msg : messages) {\n        printf(\"%c %d\\n\", msg.first, msg.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<char, int>> messages;\n\n    // online status\n    vector<bool> online(n + 1, false);\n\n    if (type == \"random\") {\n        vector<int> online_users;\n        vector<int> offline_users;\n        for (int id = 1; id <= n; ++id) {\n            if (rnd.next(0, 1)) {\n                online[id] = true;\n                online_users.push_back(id);\n            } else {\n                online[id] = false;\n                offline_users.push_back(id);\n            }\n        }\n        int current_m = 0;\n        while (current_m < m) {\n            int action; // 0 for log on, 1 for log off\n            if (!online_users.empty() && !offline_users.empty()) {\n                action = rnd.next(0, 1);\n            } else if (online_users.empty()) {\n                action = 0; // must log on\n            } else {\n                action = 1; // must log off\n            }\n            if (action == 0) {\n                // log on\n                int idx = rnd.next(0, (int)offline_users.size() - 1);\n                int id = offline_users[idx];\n                messages.push_back(make_pair('+', id));\n                online_users.push_back(id);\n                online[id] = true;\n                offline_users[idx] = offline_users.back();\n                offline_users.pop_back();\n            } else {\n                // log off\n                int idx = rnd.next(0, (int)online_users.size() - 1);\n                int id = online_users[idx];\n                messages.push_back(make_pair('-', id));\n                offline_users.push_back(id);\n                online[id] = false;\n                online_users[idx] = online_users.back();\n                online_users.pop_back();\n            }\n            ++current_m;\n        }\n    } else if (type == \"logoff_at_start\") {\n        int k = min(n, m); // number of users to log off at start\n        // All users are initially online\n        vector<int> initial_online_users(n);\n        for (int id = 1; id <= n; ++id) {\n            initial_online_users[id - 1] = id;\n            online[id] = true;\n        }\n        shuffle(initial_online_users.begin(), initial_online_users.end());\n        for (int i = 0; i < k; ++i) {\n            int id = initial_online_users[i];\n            messages.push_back(make_pair('-', id));\n            online[id] = false;\n        }\n        m -= k;\n        int current_m = 0;\n        vector<int> online_users;\n        vector<int> offline_users;\n        for (int id = 1; id <= n; ++id) {\n            if (online[id]) {\n                online_users.push_back(id);\n            } else {\n                offline_users.push_back(id);\n            }\n        }\n        while (current_m < m) {\n            int action;\n            if (!online_users.empty() && !offline_users.empty()) {\n                action = rnd.next(0, 1);\n            } else if (online_users.empty()) {\n                action = 0; // must log on\n            } else {\n                action = 1; // must log off\n            }\n            if (action == 0) {\n                int idx = rnd.next(0, (int)offline_users.size() - 1);\n                int id = offline_users[idx];\n                messages.push_back(make_pair('+', id));\n                online_users.push_back(id);\n                online[id] = true;\n                offline_users[idx] = offline_users.back();\n                offline_users.pop_back();\n            } else {\n                int idx = rnd.next(0, (int)online_users.size() - 1);\n                int id = online_users[idx];\n                messages.push_back(make_pair('-', id));\n                offline_users.push_back(id);\n                online[id] = false;\n                online_users[idx] = online_users.back();\n                online_users.pop_back();\n            }\n            ++current_m;\n        }\n    } else if (type == \"logon_at_end\") {\n        int k = min(n, m);\n        int messages_to_generate = m - k;\n        int current_m = 0;\n        vector<int> online_users;\n        vector<int> offline_users;\n        for (int id = 1; id <= n; ++id) {\n            online[id] = false;\n            offline_users.push_back(id);\n        }\n        while (current_m < messages_to_generate) {\n            int action;\n            if (!online_users.empty() && !offline_users.empty()) {\n                action = rnd.next(0, 1);\n            } else if (online_users.empty()) {\n                action = 0; // must log on\n            } else {\n                action = 1; // must log off\n            }\n            if (action == 0) {\n                int idx = rnd.next(0, (int)offline_users.size() - 1);\n                int id = offline_users[idx];\n                messages.push_back(make_pair('+', id));\n                online_users.push_back(id);\n                online[id] = true;\n                offline_users[idx] = offline_users.back();\n                offline_users.pop_back();\n            } else {\n                int idx = rnd.next(0, (int)online_users.size() - 1);\n                int id = online_users[idx];\n                messages.push_back(make_pair('-', id));\n                offline_users.push_back(id);\n                online[id] = false;\n                online_users[idx] = online_users.back();\n                online_users.pop_back();\n            }\n            ++current_m;\n        }\n        shuffle(offline_users.begin(), offline_users.end());\n        for (int i = 0; i < k && i < offline_users.size(); ++i) {\n            int id = offline_users[i];\n            messages.push_back(make_pair('+', id));\n            ++current_m;\n        }\n    } else if (type == \"only_logon\") {\n        vector<int> offline_users(n);\n        for (int id = 1; id <= n; ++id) {\n            offline_users[id - 1] = id;\n            online[id] = false;\n        }\n        shuffle(offline_users.begin(), offline_users.end());\n        int current_m = 0;\n        for (int i = 0; i < m && i < offline_users.size(); ++i) {\n            int id = offline_users[i];\n            messages.push_back(make_pair('+', id));\n            online[id] = true;\n            ++current_m;\n        }\n    } else if (type == \"only_logoff\") {\n        vector<int> online_users(n);\n        for (int id = 1; id <= n; ++id) {\n            online_users[id - 1] = id;\n            online[id] = true;\n        }\n        shuffle(online_users.begin(), online_users.end());\n        int current_m = 0;\n        for (int i = 0; i < m && i < online_users.size(); ++i) {\n            int id = online_users[i];\n            messages.push_back(make_pair('-', id));\n            online[id] = false;\n            ++current_m;\n        }\n    } else if (type == \"alternate\") {\n        vector<int> users(n);\n        for (int id = 1; id <= n; ++id) {\n            users[id - 1] = id;\n            online[id] = false;\n        }\n        int current_m = 0;\n        while (current_m < m) {\n            shuffle(users.begin(), users.end());\n            for (int idx = 0; idx < users.size() && current_m < m; ++idx) {\n                int id = users[idx];\n                messages.push_back(make_pair('+', id));\n                online[id] = true;\n                ++current_m;\n                if (current_m >= m) break;\n                messages.push_back(make_pair('-', id));\n                online[id] = false;\n                ++current_m;\n            }\n        }\n    }\n\n    printf(\"%d %d\\n\", n, (int)messages.size());\n    for (auto& msg : messages) {\n        printf(\"%c %d\\n\", msg.first, msg.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 5 -m 10 -type random\n./gen -n 100 -m 1000 -type random\n./gen -n 1000 -m 10000 -type random\n./gen -n 10000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100 -m 100 -type logoff_at_start\n./gen -n 1000 -m 1000 -type logoff_at_start\n./gen -n 10000 -m 10000 -type logoff_at_start\n./gen -n 100000 -m 100000 -type logoff_at_start\n\n./gen -n 100 -m 100 -type logon_at_end\n./gen -n 1000 -m 1000 -type logon_at_end\n./gen -n 10000 -m 10000 -type logon_at_end\n./gen -n 100000 -m 100000 -type logon_at_end\n\n./gen -n 10 -m 20 -type alternate\n./gen -n 100 -m 200 -type alternate\n./gen -n 1000 -m 2000 -type alternate\n\n./gen -n 1000 -m 5000 -type only_logon\n./gen -n 1000 -m 2000 -type only_logoff\n\n./gen -n 100000 -m 100000 -type only_logon\n./gen -n 100000 -m 100000 -type only_logoff\n\n./gen -n 50000 -m 50000 -type random\n\n# Edge cases\n./gen -n 1 -m 1 -type only_logon\n./gen -n 1 -m 1 -type only_logoff\n./gen -n 1 -m 1 -type alternate\n\n# Max input\n./gen -n 100000 -m 100000 -type random\n\n# Minimal input\n./gen -n 1 -m 1 -type random\n\n# m smaller than n\n./gen -n 100000 -m 50000 -type random\n\n# m larger than n\n./gen -n 100 -m 1000 -type random\n./gen -n 1000 -m 10000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:42.332138",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "421/D",
      "title": "D. Bug in Code",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and p (3 ≤ n ≤ 3·105; 0 ≤ p ≤ n) — the number of coders in the F company and the minimum number of agreed people.Each of the next n lines contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the numbers of coders named by the i-th coder. It is guaranteed that xi ≠ i,  yi ≠ i,  xi ≠ yi.",
      "output_spec": "OutputPrint a single integer — the number of possible two-suspect sets. Note that the order of the suspects doesn't matter, that is, sets (1, 2) and (2, 1) are considered identical.",
      "sample_tests": "ExamplesInputCopy4 22 31 41 42 1OutputCopy6InputCopy8 65 65 75 86 22 17 31 31 4OutputCopy1",
      "description": "D. Bug in Code\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and p (3 ≤ n ≤ 3·105; 0 ≤ p ≤ n) — the number of coders in the F company and the minimum number of agreed people.Each of the next n lines contains two integers xi, yi (1 ≤ xi, yi ≤ n) — the numbers of coders named by the i-th coder. It is guaranteed that xi ≠ i,  yi ≠ i,  xi ≠ yi.\n\nOutputPrint a single integer — the number of possible two-suspect sets. Note that the order of the suspects doesn't matter, that is, sets (1, 2) and (2, 1) are considered identical.\n\nInputCopy4 22 31 41 42 1OutputCopy6InputCopy8 65 65 75 86 22 17 31 31 4OutputCopy1\n\nInputCopy4 22 31 41 42 1\n\nOutputCopy6\n\nInputCopy8 65 65 75 86 22 17 31 31 4\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Coder-Strike 2014: High School Championship in Moscow and Moscow Region - Codeforces",
          "content": "The CROC company and the Ministry of Defense of Russian Federation invite the schoolchildren of the 9-11th years of education in Moscow and the Moscow region to take part in a school programming championship. The championship is called Coder-Strike 2014. The championship will be held based on Codeforces.GoalsWe aim to support talented high school children, help to form the community of programming enthusiasts, develop future IT professionals. The modern industry offers scientific challenges that cannot be solved without profound knowledge in the field of algorithms and data structures. We want to provide out participants with potential ways of development of with the opportunities that open in front of high qualified professionals.ParticipantsYou can participate if you study at 9-11th school year of one of a high school of Moscow or Moscow region. You should also be over 14 years old at the moment of registration to the championship. In order to become a participant of the championship, you need to register before you take part in the qualifying round at http://crocok.ru/championship/. You should submit the participant application form to take part in the championship officially. Schedule Stage Date / Time Participants Registration March, 15 — April, 15 9-11th form of Moscow or Moscow region high school, who are over 14 at the moment of registration for the championship Qualification Round April, 15 00:00:00 AM till 11:59:59 PM (24 hours) You will need to solve at least one problem at any time during the 24-hour period of the round to pass it. All the participants who registered for the championship Round 1 April, 18 8:00:00 PM till 9:59:59 PM (2 hours) The participants who solved at least one problem in the qualification Round 2 April, 20 11:00:00 AM till 12:59:59 PM (2 hours) The top 200 participants of the Round 1 Finals April. 22 (time will be specified later) The top 25 participants of the Round 2 The qualification round will consist of 2-3 easy programming problems, your solutions will be checked during the round. The rounds 1-2 and the finals will be conducted by the traditional Codeforces rules, you can learn more about them by these links: rules rules Championship FinalsThe championship finals will take place on April, 22 in the CROC company office on 5, Volochayevskaya street. The finalists will have an excursion along the company office an meet the leading specialists of CROC and the Ministry of Defence of Russian Federation. The time of the finals will be specified later.The award ceremony will be on May, 20-23 on the exhibition by the Ministry of Defense called 'Complex Safety'.PrizesAll the participants who make it to the finals get souvenirs from the CROC company and the Ministry of Defense of Russian Federation.Participation Out-of-CompetitionAll the willing users can participate in the championship out of competition. In this case the application form is not required. The sorting rounds and the finals will be Codeforces rating rounds.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3005
        },
        {
          "title": "Editorial Coder-Strike 2014 Finals - Codeforces",
          "content": "421A - Pasha and HamstersFor each apple you just need to determine who like it. If Alexander likes apple, then he should eat it, if Artur likes the apple, then he should eat it. If they both like the apply anyone can eat the apple.420A - Start UpOne should firstly recognize that the required string should be palindrome and each character of the string should be symmetric. All the symmetric characters are — AHIMOTUVWXY.420B - Online MeetingFirstly lets add to the answer all the persons, that didn't appear in the log messages. Then we should consider two cases:1) If there is a person (with number i), that the first log message with him is in form  - i. We will call such persons X-persons.Consider all X-persons. Pick the one from them that has the last first occurrence in the sequence of messages. This person can be a leader, all others cannot be. Now we should check if the picked person is a leader or not. For that reason we will use the algorithm that is described below. This algorithm works fine only on special sequences of messages. So, we need to add all the X-persons to the beginning of the our list in the order they appear in input (in the resulting sequence the picked person should be the first).2) There is no X-persons.That case only the first person from the list can be a leader. Others cannot be. Check that person with the algorithm described below.The Algorithm of check:The algorithm is very simple. Just to iterate throughout the sequence of messages and maintain set-structure for the persons that are currently on the meeting. If we consider log-on message, add the person to the set, if we consider log-off message, erase the person from the set. Each time we perform an operation with set, we should check: either the set is empty or the leader is in set.The most tricky cases are 33 and 34. Will look at them, the 33-th test:4 4+ 2- 1- 3- 2Here the leader can be only 4-th person. Others cannot be.The 34-th test:3 3- 2+ 1+ 2The answer for that test is only the 3-rd participant.420C - Bug in CodeLets construct an undirected graph, the vertices of the graph are the persons, there is an edge between two persons if there are claim of some person about these two persons. Now we can describe the problem on this graph. We need to find the number of such pairs of vertices that at least p edges are adjacent to them.How to count such pairs. Just for each vertex v to calculate the number of vertices u such that d[v] + d[u] ≥ p, then we should consider all the adjacent vertices correctly. Iterate through all the edges and subtract such the vertices from the answer. Then iterate through adjacent vertices and add only such of them that is needed to be added.Pay attention to multiple edges, they should be considered very carefully.420D - Cup TrickThe solution consists of two parts.1) Find the valid permutation.Let's go through the given queries. Suppose the current query tells us that the number a is placed on b-th position. If we already met a then we are going to skip this query. Otherwise let's find the position of a in the sought permutation.Suppose we already know that in the sought permutation the number a1 is on position b1, a2 is on position b2, ..., ak is on position bk (b1 < b2 < ... < bk). After every query the number from that query goes to the begging of the permutation, so all ai (1 ≤ i ≤ k) are already placed to the left of a before the current query. But some of these ai stood to the left of a in the sought permutation, and the other stood to the right of a, but went forward to the begging. Let's find the number of these numbers. In order to do this we should find such position p, that is not occupied by any of ai and p + x = b, where x is the number of such bi that bi > p.We can do it by using the segment tree in the following manner. Let's store in the vertex of segment tree the number of already occupied positions on the correspond subsegment. Suppose we want to find p in the some subtree. Let's find the minimal position in the right subtree prg and the number of occupied positions xrg there. So if prg + xrg ≤ b then we should continue finding p in the right subtree. Otherwise we should decrease b by xrg and try to find p in the left subtree. When we find p we need to check that p + x = b. If this equation isn't correct then the answer is  - 1.2) Check that the sequence of the operations is correct.Let's consider i-th query. Suppose it tells us that a is placed on position b. We should check whether it is correct. If we haven't already seen a in queries then this statement is correct because we checked it in the first part of the solution. Otherwise, let's find the such maximal j < i that it is given the position of a in j-th query. After j-th query a goes to the begging of the permutation and the other numbers can move it to the right. Let's find the number of such different numbers on the queries' segment [j + 1, i - 1]. We should get exactly b - 1.420E - Playing the ballLet's claim that we have ray and the infinite number of balls on it in this problem. The k-th ball is placed on the distance k·d from the begging of the ray. Let's note that in the answer must be the ball which is placed on the border of some cirlce. The second observation is the following. Let's consider any circle. The number of angles, on which we can rotate our ray so that any ball will be on the border of this cirlce, doesn't exceed 4 * r / d. Let's call these angles critical.Let's put all critical angles from each circle to the array B and sort. After that let's consider every cirlce one-by-one. When we consider some cirlce we are going to find all critical angles and sort them. So the number of balls, which will be inside of the cirlce, will be the constant if we rotate our ray on every angle between the two neighbour critical angles. Let's find k — the number of these balls.Let's create array C, where Ci is the answer value if we rotate the ray on the angle Bi. So after we find k and the positions of neighbour critical angles in B we need to perform add on the segment query in C. After we processed all critical angles of all circles the maximum in the C will be the answer.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 421 和字母"
          },
          "content_length": 6174
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        int coderNumber = i + 1;\n        int lineNumber = i + 2; // Line number in the input file (since line 1 is n and p)\n\n        ensuref(xi != coderNumber, \"In line %d, xi (%d) should not be equal to coder's own number (%d)\", lineNumber, xi, coderNumber);\n        ensuref(yi != coderNumber, \"In line %d, yi (%d) should not be equal to coder's own number (%d)\", lineNumber, yi, coderNumber);\n        ensuref(xi != yi, \"In line %d, xi (%d) and yi (%d) should not be equal\", lineNumber, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        int coderNumber = i + 1;\n        int lineNumber = i + 2; // Line number in the input file (since line 1 is n and p)\n\n        ensuref(xi != coderNumber, \"In line %d, xi (%d) should not be equal to coder's own number (%d)\", lineNumber, xi, coderNumber);\n        ensuref(yi != coderNumber, \"In line %d, yi (%d) should not be equal to coder's own number (%d)\", lineNumber, yi, coderNumber);\n        ensuref(xi != yi, \"In line %d, xi (%d) and yi (%d) should not be equal\", lineNumber, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 300000, \"n\");\n    inf.readSpace();\n    int p = inf.readInt(0, n, \"p\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        int coderNumber = i + 1;\n        int lineNumber = i + 2; // Line number in the input file (since line 1 is n and p)\n\n        ensuref(xi != coderNumber, \"In line %d, xi (%d) should not be equal to coder's own number (%d)\", lineNumber, xi, coderNumber);\n        ensuref(yi != coderNumber, \"In line %d, yi (%d) should not be equal to coder's own number (%d)\", lineNumber, yi, coderNumber);\n        ensuref(xi != yi, \"In line %d, xi (%d) and yi (%d) should not be equal\", lineNumber, xi, yi);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getRandom(int n, int exclude1 = -1, int exclude2 = -1) {\n    int res = rnd.next(1, n);\n    while(res == exclude1 || res == exclude2)\n        res = rnd.next(1, n);\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure that n and p are within the valid range\n    ensure(n >= 3 && n <= 300000);\n    ensure(p >= 0 && p <= n);\n    \n    vector<int> xi(n + 1), yi(n + 1); // 1-based indexing\n    \n    if(type == \"random\") {\n        // Generate xi and yi randomly\n        for(int i = 1; i <= n; ++i) {\n            xi[i] = getRandom(n, i);\n            yi[i] = getRandom(n, i, xi[i]);\n        }\n    } else if(type == \"full_agreement\") {\n        // Generate xi and yi so that all coders agree with the same pair of suspects\n        int a = 1, b = 2, c = 3;\n        for(int i = 1; i <= n; ++i) {\n            if(i != a) {\n                xi[i] = a;\n                yi[i] = b;\n            } else {\n                xi[i] = b;\n                yi[i] = c;\n            }\n            if(xi[i] == i) xi[i] = getRandom(n, i, yi[i]);\n            if(yi[i] == i || yi[i] == xi[i]) yi[i] = getRandom(n, i, xi[i]);\n        }\n    } else if(type == \"impossible\") {\n        // Generate xi and yi such that it's impossible to satisfy p\n        for(int i = 1; i <= n; ++i) {\n            xi[i] = getRandom(n, i);\n            yi[i] = getRandom(n, i, xi[i]);\n        }\n        p = n; // Set p to n to make it impossible\n    } else if(type == \"special\") {\n        // Generate a special case with sequential xi and yi\n        for(int i = 1; i <= n; ++i) {\n            xi[i] = (i % n) + 1;\n            if(xi[i] == i) xi[i] = (xi[i] % n) + 1;\n            yi[i] = ((i + 1) % n) + 1;\n            if(yi[i] == i || yi[i] == xi[i]) yi[i] = (yi[i] % n) + 1;\n        }\n    }\n    \n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n    // Output xi and yi\n    for(int i = 1; i <= n; ++i) {\n        printf(\"%d %d\\n\", xi[i], yi[i]);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint getRandom(int n, int exclude1 = -1, int exclude2 = -1) {\n    int res = rnd.next(1, n);\n    while(res == exclude1 || res == exclude2)\n        res = rnd.next(1, n);\n    return res;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int p = opt<int>(\"p\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Ensure that n and p are within the valid range\n    ensure(n >= 3 && n <= 300000);\n    ensure(p >= 0 && p <= n);\n    \n    vector<int> xi(n + 1), yi(n + 1); // 1-based indexing\n    \n    if(type == \"random\") {\n        // Generate xi and yi randomly\n        for(int i = 1; i <= n; ++i) {\n            xi[i] = getRandom(n, i);\n            yi[i] = getRandom(n, i, xi[i]);\n        }\n    } else if(type == \"full_agreement\") {\n        // Generate xi and yi so that all coders agree with the same pair of suspects\n        int a = 1, b = 2, c = 3;\n        for(int i = 1; i <= n; ++i) {\n            if(i != a) {\n                xi[i] = a;\n                yi[i] = b;\n            } else {\n                xi[i] = b;\n                yi[i] = c;\n            }\n            if(xi[i] == i) xi[i] = getRandom(n, i, yi[i]);\n            if(yi[i] == i || yi[i] == xi[i]) yi[i] = getRandom(n, i, xi[i]);\n        }\n    } else if(type == \"impossible\") {\n        // Generate xi and yi such that it's impossible to satisfy p\n        for(int i = 1; i <= n; ++i) {\n            xi[i] = getRandom(n, i);\n            yi[i] = getRandom(n, i, xi[i]);\n        }\n        p = n; // Set p to n to make it impossible\n    } else if(type == \"special\") {\n        // Generate a special case with sequential xi and yi\n        for(int i = 1; i <= n; ++i) {\n            xi[i] = (i % n) + 1;\n            if(xi[i] == i) xi[i] = (xi[i] % n) + 1;\n            yi[i] = ((i + 1) % n) + 1;\n            if(yi[i] == i || yi[i] == xi[i]) yi[i] = (yi[i] % n) + 1;\n        }\n    }\n    \n    // Output n and p\n    printf(\"%d %d\\n\", n, p);\n    // Output xi and yi\n    for(int i = 1; i <= n; ++i) {\n        printf(\"%d %d\\n\", xi[i], yi[i]);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -p 0 -type random\n./gen -n 3 -p 1 -type random\n./gen -n 3 -p 2 -type random\n./gen -n 3 -p 3 -type random\n./gen -n 3 -p 3 -type full_agreement\n./gen -n 3 -p 3 -type impossible\n\n./gen -n 10 -p 0 -type random\n./gen -n 10 -p 5 -type random\n./gen -n 10 -p 10 -type random\n./gen -n 10 -p 10 -type full_agreement\n./gen -n 10 -p 10 -type impossible\n\n./gen -n 100 -p 50 -type random\n./gen -n 100 -p 100 -type full_agreement\n./gen -n 100 -p 100 -type impossible\n\n./gen -n 1000 -p 0 -type random\n./gen -n 1000 -p 500 -type random\n./gen -n 1000 -p 1000 -type random\n./gen -n 1000 -p 1000 -type full_agreement\n./gen -n 1000 -p 1000 -type impossible\n\n./gen -n 10000 -p 0 -type random\n./gen -n 10000 -p 5000 -type random\n./gen -n 10000 -p 10000 -type random\n./gen -n 10000 -p 10000 -type full_agreement\n./gen -n 10000 -p 10000 -type impossible\n\n./gen -n 300000 -p 0 -type random\n./gen -n 300000 -p 150000 -type random\n./gen -n 300000 -p 300000 -type random\n./gen -n 300000 -p 300000 -type full_agreement\n./gen -n 300000 -p 300000 -type impossible\n./gen -n 300000 -p 1 -type random\n./gen -n 300000 -p 299999 -type random\n\n./gen -n 3 -p 3 -type full_agreement\n./gen -n 3 -p 3 -type impossible\n./gen -n 3 -p 2 -type random\n./gen -n 3 -p 1 -type random\n\n./gen -n 5 -p 2 -type random\n./gen -n 5 -p 5 -type full_agreement\n\n./gen -n 100000 -p 0 -type random\n./gen -n 100000 -p 100000 -type full_agreement\n./gen -n 100000 -p 100000 -type impossible\n\n./gen -n 200000 -p 0 -type random\n./gen -n 200000 -p 200000 -type special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:44.020247",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "421/E",
      "title": "E. Фокус со стаканчиками",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 106). В каждой из следующих m строк записана пара целых чисел. В i-й строке записаны целые числа xi, yi (1 ≤ xi, yi ≤ n) — описание i-й операции фокусника. Обратите внимание, что операции заданы в том порядке, в котором их выполнял фокусник, программист хочет выполнить эти операции в таком же порядке.",
      "output_spec": "Выходные данныеЕсли описанной перестановки не существует (программист ошибся в своих воспоминаниях), выведите -1. Иначе выведите n различных целых чисел, каждое от 1 до n: i-е число должно обозначать пометку на стаканчике, который изначально стоит в ряду на позиции i.Если существует несколько правильных ответов, нужно вывести лексикографически наименьший.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 12 1Выходные данныеСкопировать2 1 Входные данныеСкопировать3 21 21 1Выходные данныеСкопировать2 1 3 Входные данныеСкопировать3 31 32 31 3Выходные данныеСкопировать-1",
      "description": "E. Фокус со стаканчиками\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны целые числа n и m (1 ≤ n, m ≤ 106). В каждой из следующих m строк записана пара целых чисел. В i-й строке записаны целые числа xi, yi (1 ≤ xi, yi ≤ n) — описание i-й операции фокусника. Обратите внимание, что операции заданы в том порядке, в котором их выполнял фокусник, программист хочет выполнить эти операции в таком же порядке.\n\nВходные данные\n\nВыходные данныеЕсли описанной перестановки не существует (программист ошибся в своих воспоминаниях), выведите -1. Иначе выведите n различных целых чисел, каждое от 1 до n: i-е число должно обозначать пометку на стаканчике, который изначально стоит в ряду на позиции i.Если существует несколько правильных ответов, нужно вывести лексикографически наименьший.\n\nВыходные данные\n\nВходные данныеСкопировать2 12 1Выходные данныеСкопировать2 1 Входные данныеСкопировать3 21 21 1Выходные данныеСкопировать2 1 3 Входные данныеСкопировать3 31 32 31 3Выходные данныеСкопировать-1\n\nВходные данныеСкопировать2 12 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 21 21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 1 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 31 32 31 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Coder-Strike 2014: Чемпионат школьников Москвы и МО - Codeforces",
          "content": "Компания КРОК и Министерство Обороны РФ приглашают учащихся 9-11 классов принять участие в чемпионате школьников Москвы и МО по спортивному программированию \"Coder-Strike 2014\". Чемпионат будет проведён на базе Codeforces.Цель чемпионатаМы хотим поддержать талантливых ребят, помочь формированию сообщества энтузиастов программирования, развитию будущих профессионалов IT-отрасли. Современная индустрия ставит наукоёмкие задачи, решение которых невозможно без глубоких знаний в области алгоритмов и структур данных. Мы хотим показать участникам потенциальные пути развития, и возможности, открывающиеся перед высококвалифицированными профессионалами.УчастникиПринять участие в чемпионате могут учащиеся 9-11 классов образовательных учреждений Москвы и Московской области, которым уже исполнилось 14 лет на момент регистрации в чемпионате. Чтобы стать участником чемпионата, необходимо пройти регистрацию до участия в квалификационном раунде по адресу http://crocok.ru/championship/. Заявка на участие обязательна для официального участия в чемпионате.Зарегистрироваться →Расписание этапов Этап Время проведения Участники этапа Регистрация 15-е марта — 15-е апреля Учащиеся 9-11 классов образовательных организаций Москвы и Московской области, которым уже исполнилось 14 лет на момент регистрации в чемпионате Квалификационный раунд 15 апреля с 00:00:00 до 23:59:59 (24 часа) Для прохождения квалификации будет необходимо решить хотя бы одну задачу в любое время в течении суток от начала раунда. Все участники, зарегистрированные на чемпионат Первый отборочный раунд 18 апреля с 20:00:00 до 21:59:59 (2 часа) Участники, решившие хотя бы одну задачу в квалификационном раунде Второй отборочный раунд 20 апреля с 11:00:00 до 12:59:59 (2 часа) Лучшие 200 участников первого отборочного раунда Финал 22 апреля (время будет уточнено) Лучшие 25 участников второго отборочного раунд Квалификационный раунд будет состоять из 2-3 несложных задач по программированию, решения по которым будут проверяться во время раунда. Отборочные раунды и финал будут проведены по традиционным правилам соревнований Codeforces, с которым вы можете ознакомиться по ссылкам: правила соревнований Codeforces правила соревнований Codeforces Финал чемпионатаФинал чемпионата состоится 22 апреля в офисе компании КРОК по адресу ул. Волочаевская, 5. Финалистов ждет экскурсия по офису компании и знакомство с ведущими специалистами КРОК и представителями Министерства Обороны РФ. Время финала будет уточнено позднее.Торжественное награждение победителей состоится 20-23 мая на выставке Минобороны \"Комплексная Безопасность\".ПризыВсе участники, дошедшие до финала, получат памятные призы от компании КРОК и Министерства Обороны РФ.Участие вне конкурсаВсе желающие могут также поучаствовать в чемпионате вне конкурса. В этом случае заявка на участие не требуется. Отборочные раунды и финал будут рейтинговыми раундами Codeforces.",
          "author": "MDovzhenko",
          "url": "https://codeforces.com/blog/entry/11011",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2896
        },
        {
          "title": "Разбор задач Coder-Strike 2014 Финал - Codeforces",
          "content": "421A - Паша и хомякиВ данной задаче нужно было для каждого яблока определить, кому оно нравится, и отдать его этому хомяку. Так как гарантировалось, что ответ существует, то каждое яблоко нравилось либо Александру, либо Артуру.420A - СтартапВ данной задаче нужно было проверить, что заданная строка является палиндромом, и что она состоит только из симметричных символов. Симметричные символы — AHIMOTUVWXY.420B - Онлайн митингПрежде всего, добавим в ответ всех людей, которые ни разу не упоминались в сообщениях. Далее рассмотрим два случая.1) Есть участник с номером i такой, что первое сообщение с его участием  - i.Рассмотрим всех таких участников. Среди них выберем того, первое упоминание о котором встречается позже остальных. Тогда лишь он может быть лидером, так как другие ушли раньше, а те участники, о которых первое сообщение начинается с « + », не могут быть лидерами, так как когда они пришли i уже был. Но нужно проверить, может ли он на самом деле быть лидером (так как например, может он ушел, а потом сразу пришел кто-то другой). Для этого добавим в начало сообщений всех участников, для которых первое сообщение начинается с « - » в порядке их появления. То есть сначала добавим того, кто ушел раньше остальных (он упоминается первым), затем того, кто ушел вторым, и так далее. В конце добавим нашего кандидата на лидера (то есть в итоге он будет первым в списке сообщений). После добавления проверим описанным ниже алгоритмом по списку сообщений и кандидату, может ли он быть лидером.2) Для всех участников первая запись о них начинается с « + ».Тогда, очевидно, кандидатом на лидера может быть только участник, который появился в митинге самым первым. Проверим алгоритмом его.Алгоритм проверки, может ли заданный кандидат быть лидером, очень прост. Поддерживаем set участников, которые в данный момент есть в митинге. Идем по списку сообщений и добавляем или удаляем соответствующих участников. Перед и после каждой операцией проверяем, что если список участников не пуст, то наш кандидат должен в нем присутствовать.Хитрыми тестами в этой задаче оказались тесты 33 и 34, на которых упали решения многих участников. Тест 33 выглядит так.4 4+ 2- 1- 3- 2Здесь лидером может быть только 4-ый участник (в предположении, что он всегда находится на митинге). Второй не может быть лидером, так как изначально он не участвовал в митинге, а первый и третий участвовали. Но они тоже не могут быть лидерами, так как вышли из митинга в то время, когда там находился второй участник.Тест 34 следующий.3 3- 2+ 1+ 2В данном тесте лидером может быть только 3-ий участник. Второй изначально находится на митинге, потом уходит, но далее приходит первый, поэтому второй не может быть лидером. Первый не может быть лидером, потому что он изначально не находится на митинге, а второй участник находится.420C - Баг в кодеДавайте построим неориентированный граф, вершины которого — это люди, а ребро между двумя людьми a, b есть, если существует высказывание человека (виноват a или b). Как теперь переформулируется задача в терминах этого графа? Нужно посчитать количество таких пар вершин, что им инцидентно как минимум p ребер.Сделаем следующее. Сохраним граф в виде списков смежности, а также создадим массив степеней всех вершин графа и отсортируем его. Будем перебирать одну вершину и считать, сколько существует вершин в пару ей, чтобы получилась нужная пара вершин. Первое, что приходит в голову — это для каждой вершины v добавить к ответу количество вершин u таких, что d[u] + d[v] ≥ p (количество таких вершин можно просто посчитать бинарным поиском, например). К сожалению, это неправильно, поскольку в сумме d[u] + d[v] ребра между v и u учитываются два раза.Но, давайте посчитаем ответ неправильно, а потом учтем все то, что мы неправильно посчитали. А именно, для каждой вершины пройдемся по списку ее соседей и для каждого уникального соседа вычтем его из ответ, если он добавился туда (если d[v] + d[u] ≥ p). Теперь осталось учесть в ответе все вершины, которые смежны в графе. Это делается простым проходом по ребрам.Обратите внимание, что в этой задаче в графе могут получиться мультиребра, их нужно аккуратно обрабатывать.420D - Фокус со стаканчикамиРешение состоит из двух этапов.1) Определим возможную исходную перестановку.Будем идти по заданным запросам. Пусть текущий запрос утверждает, что число a стоит на позиции b. Если a уже раньше встречалось, то пропустим такой запрос. Иначе определим, на какой позиции находится a в искомой перестановке.Пусть мы уже знаем, что в искомой перестановке число a1 стоит на позиции b1, a2 на позиции b2, ..., ak на позиции bk (b1 < b2 < ... < bk). Так как после объявления позиции числа оно перемещается в самое начало перестановки, то значит до того как мы объявили о позиции a все ai (1 ≤ i ≤ k) уже находятся перед a. Но при этом некоторые из этих ai уже находились раньше a в искомой перестановке, а остальные находились позже, но переместились вперед. Найдем их количество. Для этого нужно найти такую свободную позицию p в исходной перестановке, что p + x = b, где x — количество bi таких, что bi > x. Это можно найти с помощью дерева отрезков следующим образом. Будем хранить в вершине дерева отрезков количество уже занятых позиций искомой перестановки на соответствующем подотрезке. Предположим, мы хотим найти p в некотором поддереве. Посмотрим на минимальную позицию в правом поддереве prg и на количество занятых там позиций xrg. Тогда если prg + xrg ≤ b, то нужно продолжать искать в правом поддереве. Если же prg + xrg > b, то нужно продолжать искать в левом поддереве, уменьшив при этом b на величину xrg. Когда мы нашли p, проверим выполнение условия p + x = b. Если оно не выполняется, то ответ  - 1.2) Проверим, что последовательность операций корректная.Пусть мы рассматриваем i-ый запрос, утверждающий, что число a стоит на позиции b. Нужно проверить, что он верен. Если a раньше не встречалось в запросах, то запрос верен, так как мы проверили b еще на первом этапе. Если оно раньше встречалось, найдем такое максимальное j < i, что j-ый запрос также объявляет, в какой позиции находится a. После j-го запроса a перемещается в начало перестановки, а далее другие числа могут передвигать его вправо. Найдем количество различных таких чисел на отрезке запросов [j + 1, i - 1], их должно быть ровно b - 1.420E - Игра в мячСкажем, что в данной задаче у нас есть луч, на котором есть бесконечное число шариков, находящихся на расстояниях, кратных d от начала луча. Заметим, что хотя бы один шарик, который будет посчитан в ответе должен упираться в границу какого-нибудь круга. Также заметим, что если мы рассмотрим любой круг, то количество углов a на которые нужно повернуть наш луч так, чтобы какой-нибудь из шариков лежал на границе этого круга не превосходит 4 * r / d. Назовем такие углы критическими.Выпишем все возможные критические углы от всех окружностей в массив B и отсортируем его. Далее для каждой окружности выпишем ее критические углы и отсортируем. Тогда между двумя соседними критическими углами количество шаров, попадающих в круг будет постоянно. Посчитаем k это количество, найдем данные углы в B. Тогда повернув луч на любой угол, находящийся между ними, к ответу будет прибавляться k.Заведем массив C такой, что Ci — ответ, если мы повернули луч на угол Bi. Тогда после того как мы нашли k и позиции углов в B, нужно сделать прибавление на отрезке в массиве C. После того как мы обработаем все критические углы всех кругов нужно найти максимум в массиве C.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11871",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 421 和字母"
          },
          "content_length": 7457
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    if (type == \"random_possible\") {\n        vector<int> cup_marks(n);\n        for (int i = 0; i < n; ++i) {\n            cup_marks[i] = i + 1;\n        }\n        shuffle(cup_marks.begin(), cup_marks.end());\n\n        vector<int> cup_positions = cup_marks;\n        vector<pair<int, int>> operations;\n\n        for (int op = 0; op < m; ++op) {\n            int yi = rnd.next(1, n); \n            int xi = cup_positions[yi - 1];\n\n            operations.emplace_back(xi, yi);\n\n            int cup = cup_positions[yi - 1];\n            cup_positions.erase(cup_positions.begin() + yi - 1);\n            cup_positions.insert(cup_positions.begin(), cup);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (const auto& op : operations) {\n            printf(\"%d %d\\n\", op.first, op.second);\n        }\n    } else if (type == \"random_impossible\") {\n        vector<int> cup_marks(n);\n        for (int i = 0; i < n; ++i) {\n            cup_marks[i] = i + 1;\n        }\n        shuffle(cup_marks.begin(), cup_marks.end());\n\n        vector<int> cup_positions = cup_marks;\n        vector<pair<int, int>> operations;\n\n        for (int op = 0; op < m; ++op) {\n            int yi = rnd.next(1, n); \n            int xi = cup_positions[yi - 1];\n\n            operations.emplace_back(xi, yi);\n\n            int cup = cup_positions[yi - 1];\n            cup_positions.erase(cup_positions.begin() + yi - 1);\n            cup_positions.insert(cup_positions.begin(), cup);\n        }\n\n        if (m > 0) {\n            int idx = rnd.next(0, m - 1);\n            int old_xi = operations[idx].first;\n            int new_xi = rnd.next(1, n);\n            while (new_xi == old_xi) {\n                new_xi = rnd.next(1, n);\n            }\n            operations[idx].first = new_xi;\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (const auto& op : operations) {\n            printf(\"%d %d\\n\", op.first, op.second);\n        }\n    } else if (type == \"edge\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = 1;\n            int yi = 1;\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random_possible\");\n\n    if (type == \"random_possible\") {\n        vector<int> cup_marks(n);\n        for (int i = 0; i < n; ++i) {\n            cup_marks[i] = i + 1;\n        }\n        shuffle(cup_marks.begin(), cup_marks.end());\n\n        vector<int> cup_positions = cup_marks;\n        vector<pair<int, int>> operations;\n\n        for (int op = 0; op < m; ++op) {\n            int yi = rnd.next(1, n); \n            int xi = cup_positions[yi - 1];\n\n            operations.emplace_back(xi, yi);\n\n            int cup = cup_positions[yi - 1];\n            cup_positions.erase(cup_positions.begin() + yi - 1);\n            cup_positions.insert(cup_positions.begin(), cup);\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (const auto& op : operations) {\n            printf(\"%d %d\\n\", op.first, op.second);\n        }\n    } else if (type == \"random_impossible\") {\n        vector<int> cup_marks(n);\n        for (int i = 0; i < n; ++i) {\n            cup_marks[i] = i + 1;\n        }\n        shuffle(cup_marks.begin(), cup_marks.end());\n\n        vector<int> cup_positions = cup_marks;\n        vector<pair<int, int>> operations;\n\n        for (int op = 0; op < m; ++op) {\n            int yi = rnd.next(1, n); \n            int xi = cup_positions[yi - 1];\n\n            operations.emplace_back(xi, yi);\n\n            int cup = cup_positions[yi - 1];\n            cup_positions.erase(cup_positions.begin() + yi - 1);\n            cup_positions.insert(cup_positions.begin(), cup);\n        }\n\n        if (m > 0) {\n            int idx = rnd.next(0, m - 1);\n            int old_xi = operations[idx].first;\n            int new_xi = rnd.next(1, n);\n            while (new_xi == old_xi) {\n                new_xi = rnd.next(1, n);\n            }\n            operations[idx].first = new_xi;\n        }\n\n        printf(\"%d %d\\n\", n, m);\n        for (const auto& op : operations) {\n            printf(\"%d %d\\n\", op.first, op.second);\n        }\n    } else if (type == \"edge\") {\n        printf(\"%d %d\\n\", n, m);\n        for (int i = 0; i < m; ++i) {\n            int xi = 1;\n            int yi = 1;\n            printf(\"%d %d\\n\", xi, yi);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type random_possible\n./gen -n 1 -m 1 -type random_possible\n\n./gen -n 5 -m 5 -type random_possible\n./gen -n 5 -m 5 -type random_impossible\n\n./gen -n 10 -m 15 -type random_possible\n./gen -n 10 -m 15 -type random_impossible\n\n./gen -n 100 -m 100 -type random_possible\n./gen -n 100 -m 100 -type random_impossible\n\n./gen -n 1000 -m 1000 -type random_possible\n./gen -n 1000 -m 1000 -type random_impossible\n\n./gen -n 10000 -m 10000 -type random_possible\n./gen -n 10000 -m 10000 -type random_impossible\n\n./gen -n 100000 -m 100000 -type random_possible\n./gen -n 100000 -m 100000 -type random_impossible\n\n./gen -n 1000000 -m 1000000 -type random_possible\n./gen -n 1000000 -m 1000000 -type random_impossible\n\n# Edge cases\n./gen -n 1 -m 0 -type edge\n./gen -n 1 -m 1 -type edge\n./gen -n 1000000 -m 0 -type edge\n./gen -n 1000000 -m 1000000 -type edge\n\n# Special impossible cases\n./gen -n 3 -m 3 -type random_impossible\n./gen -n 10 -m 20 -type random_impossible\n./gen -n 1000 -m 5000 -type random_impossible\n\n# Additional random possible cases with maximum sizes\n./gen -n 1000000 -m 1000000 -type random_possible\n./gen -n 999999 -m 999999 -type random_possible\n./gen -n 1000000 -m 999999 -type random_possible\n\n# Some more moderate test cases\n./gen -n 50000 -m 50000 -type random_possible\n./gen -n 50000 -m 50000 -type random_impossible\n\n# Edge case with maximum m and minimum n\n./gen -n 1 -m 1000000 -type random_possible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:45.934233",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "424/A",
      "title": "A. Паша и приседания",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 200; n — четное). В следующей строке записано n символов без пробелов. Эти символы описывают положение хомяков: i-й символ равен «X», если i-й в ряду хомяк стоит, и равен «x», если он сидит.",
      "output_spec": "Выходные данныеВ первой строке выведите единственное целое число — минимальное требуемое количество минут. Во второй строке выведите строку описывающее положение хомяков, после того как Паша выполнит требуемые действия. Если существует несколько оптимальных положений, выведите любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать4xxXxВыходные данныеСкопировать1XxXxВходные данныеСкопировать2XXВыходные данныеСкопировать1xXВходные данныеСкопировать6xXXxXxВыходные данныеСкопировать0xXXxXx",
      "description": "A. Паша и приседания\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 200; n — четное). В следующей строке записано n символов без пробелов. Эти символы описывают положение хомяков: i-й символ равен «X», если i-й в ряду хомяк стоит, и равен «x», если он сидит.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите единственное целое число — минимальное требуемое количество минут. Во второй строке выведите строку описывающее положение хомяков, после того как Паша выполнит требуемые действия. Если существует несколько оптимальных положений, выведите любое.\n\nВыходные данные\n\nВходные данныеСкопировать4xxXxВыходные данныеСкопировать1XxXxВходные данныеСкопировать2XXВыходные данныеСкопировать1xXВходные данныеСкопировать6xXXxXxВыходные данныеСкопировать0xXXxXx\n\nВходные данныеСкопировать4xxXx\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1XxXx\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2XX\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1xX\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6xXXxXx\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0xXXxXx\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces",
          "content": "424A - Паша и приседанияВ задаче требуется найти количество хомяков, которые стоят. Если оно меньше половины от общего числа, то требуется заставить некоторых сидящих хомяков встать. Иначе — требуется посадить некоторых из стоящих хомяков. Если есть выбор какого из сидячих хомяков заставить встать или какого из стоячих хомяков посадить, то можно выбрать любого.424B - Город-миллионерМожно отсортировать все города по возрастанию расстояния до города Томска. После чего требуется найти наименьший индекс t, для которого общее население p0 + p1 + ... + pt >  = 106. Для такого t значение dt является ответом. Ограничения на N позволяют использовать сортировку с асимптотикой O(N2) или любое другое решение с такой асимптотикой.424C - Волшебные формулыРассмотрим следующие формулы: Пусть . Посчитаем значение этой функции для всех значений i (0 ≤ i ≤ n). Это можно сделать за O(n), используя соотношение .Преобразуем ci: Также: Таким образом: Это означает, что если n / i нечетно, , иначе — . ci может быть вычислено за O(1), благодаря чему итоговая асимптотика решения — O(n).424D - Биатлонная трассаИз-за лояльных ограничений по времени для Java, некоторые решения с асимптотикой O(N4) были зачтены. Авторское решение имеет сложность O(N3logN). Основная идея — зафиксировать верхнюю и нижнюю границы. Затем, используя какой-либо абстрактный тип данных, для каждой правой границы найти наиболее подходящую левую границу за время не хуже O(logN). Например, можно использовать контейнер set в языке программирования C++ и его метод lower_bound. Для лучшего понимания можно посмотреть на следующее изображение.Для показанного прямоугольника мы зафиксировали верхнюю границу строкой номер 2, нижнюю — строкой номер 5. Так же мы зафиксировали правую границу столбцом номер 6. Теперь требуется найти наиболее подходящую левую границу. Для этого мы можем разделить значение времени для любого прямоугольника на слагаемое, которое зависит только от правой границы, и на слагаемое, которое зависит только от левой границы.Синим цветом подсвечено слагаемое, которое зависит только от правой границы. Красным и желтым — только от левой. Значение выделенное красным необходимо вычесть из общего значения времени, желтое, как и синее, требуется добавить. Для любого синего значения для правой границы можно найти ближайшее по абсолютному значению красно-желтое значение для левой границы. Для этого и требуется использовать какой-либо абстрактный тип данных.424E - Цветная JengaКлассическая задача на динамическое программирование для нахождения математического ожидания.Определим некоторую функцию F(S) для некоторого состояния S — математическое ожидание количества минут до конца игры, если мы находимся в этом состоянии. Для каждого цвета мы можем вычислить вероятность, с которой этот цвет выпадет при броске кубика по тривиальной формуле , где c — количество граней такого цвета на кубике. Теперь требуется найти вероятность того, что мы останемся в том же состоянии еще хотя бы на одну минуту. Это можно сделать сложив вероятность выпадения черной грани и вероятности выпадения цветов, блоки цвета которых нельзя достать из башни на данный момент. Теперь мы можем найти значение это функции используя формулу: Далее требуется придумать как закодировать состояния. Для того, чтобы уменьшить количество различных состояний можно воспользоваться тем фактом, что имеется всего-лишь 18 различных уровней, а не 27 (некоторые комбинации являются отражением друг друга). Для лучшей производительности рекомендуется использовать хеширование. Решение данной задачи требует хорошего понимания динамического программирования и достаточно хороших реализаторских навыков.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 424\\s*A"
          },
          "content_length": 3651
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200, \"n\");\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n    inf.readEoln();\n\n    string pattern = \"[Xx]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"hamsters\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200, \"n\");\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n    inf.readEoln();\n\n    string pattern = \"[Xx]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"hamsters\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 200, \"n\");\n    ensuref(n % 2 == 0, \"n must be even, but n=%d\", n);\n    inf.readEoln();\n\n    string pattern = \"[Xx]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"hamsters\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char * argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read n from the input file\n    int n = inf.readInt();\n    if(n % 2 != 0)\n        quitf(_fail, \"n is not even\");\n\n    // Read initial positions from the input file\n    std::string initial = inf.readToken();\n    if ((int)initial.size() != n)\n        quitf(_fail, \"Initial positions have incorrect length, expected %d, found %d\", n, (int)initial.size());\n\n    int initialStanding = 0;\n    for (char c : initial) {\n        if (c == 'X')\n            initialStanding++;\n        else if (c != 'x')\n            quitf(_fail, \"Invalid character '%c' in initial positions\", c);\n    }\n\n    int requiredStanding = n / 2;\n    int minimalMinutes = abs(initialStanding - requiredStanding);\n\n    // Read participant's output\n    int m = ouf.readInt();\n    if (m != minimalMinutes)\n        quitf(_wa, \"Minimum number of minutes is incorrect, expected %d, found %d\", minimalMinutes, m);\n\n    std::string finalPositions = ouf.readToken();\n    if ((int)finalPositions.size() != n)\n        quitf(_wa, \"Final positions have incorrect length, expected %d, found %d\", n, (int)finalPositions.size());\n\n    int finalStanding = 0;\n    for (char c : finalPositions) {\n        if (c == 'X')\n            finalStanding++;\n        else if (c != 'x')\n            quitf(_wa, \"Invalid character '%c' in final positions\", c);\n    }\n\n    if (finalStanding != requiredStanding)\n        quitf(_wa, \"Incorrect number of standing hamsters in final positions, expected %d, found %d\", requiredStanding, finalStanding);\n\n    int changes = 0;\n    for (int i = 0; i < n; i++) {\n        if (initial[i] != finalPositions[i])\n            changes++;\n    }\n\n    if (changes > m)\n        quitf(_wa, \"Number of changes exceeds the number of minutes, changes: %d, minutes: %d\", changes, m);\n\n    quitf(_ok, \"Answer is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 2 || n > 200 || n % 2 != 0) {\n        fprintf(stderr, \"Error: n must be even and between 2 and 200\\n\");\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(0, 1) ? 'X' : 'x';\n    } else if (type == \"all_standing\") {\n        s = string(n, 'X');\n    } else if (type == \"all_sitting\") {\n        s = string(n, 'x');\n    } else if (type == \"half_standing\") {\n        s = string(n / 2, 'X') + string(n / 2, 'x');\n        shuffle(s.begin(), s.end());\n    } else if (type == \"alternate\") {\n        char firstChar = rnd.next(0,1) ? 'X' : 'x';\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? firstChar : (firstChar == 'X' ? 'x' : 'X');\n    } else if (type == \"max_changes\") {\n        char c = rnd.next(0, 1) ? 'X' : 'x';\n        s = string(n, c);\n    } else if (type == \"min_changes\") {\n        s = string(n / 2, 'X') + string(n / 2, 'x');\n        shuffle(s.begin(), s.end());\n    } else {\n        fprintf(stderr, \"Error: unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the configuration\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 2 || n > 200 || n % 2 != 0) {\n        fprintf(stderr, \"Error: n must be even and between 2 and 200\\n\");\n        return 1;\n    }\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = rnd.next(0, 1) ? 'X' : 'x';\n    } else if (type == \"all_standing\") {\n        s = string(n, 'X');\n    } else if (type == \"all_sitting\") {\n        s = string(n, 'x');\n    } else if (type == \"half_standing\") {\n        s = string(n / 2, 'X') + string(n / 2, 'x');\n        shuffle(s.begin(), s.end());\n    } else if (type == \"alternate\") {\n        char firstChar = rnd.next(0,1) ? 'X' : 'x';\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? firstChar : (firstChar == 'X' ? 'x' : 'X');\n    } else if (type == \"max_changes\") {\n        char c = rnd.next(0, 1) ? 'X' : 'x';\n        s = string(n, c);\n    } else if (type == \"min_changes\") {\n        s = string(n / 2, 'X') + string(n / 2, 'x');\n        shuffle(s.begin(), s.end());\n    } else {\n        fprintf(stderr, \"Error: unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the configuration\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type all_standing\n./gen -n 2 -type all_sitting\n./gen -n 2 -type half_standing\n\n./gen -n 4 -type random\n./gen -n 4 -type alternate\n./gen -n 4 -type max_changes\n./gen -n 4 -type min_changes\n\n./gen -n 10 -type random\n./gen -n 10 -type all_standing\n./gen -n 10 -type all_sitting\n./gen -n 10 -type half_standing\n./gen -n 10 -type alternate\n./gen -n 10 -type max_changes\n./gen -n 10 -type min_changes\n\n./gen -n 50 -type random\n./gen -n 50 -type all_standing\n./gen -n 50 -type all_sitting\n./gen -n 50 -type half_standing\n./gen -n 50 -type alternate\n./gen -n 50 -type max_changes\n./gen -n 50 -type min_changes\n\n./gen -n 100 -type random\n./gen -n 100 -type max_changes\n./gen -n 100 -type min_changes\n\n./gen -n 200 -type random\n./gen -n 200 -type min_changes\n./gen -n 200 -type alternate\n./gen -n 200 -type all_standing\n./gen -n 200 -type all_sitting\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:48.081584",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "424/B",
      "title": "B. Megacity",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and s (1 ≤ n ≤ 103; 1 ≤ s < 106) — the number of locatons around Tomsk city and the population of the city. Then n lines follow. The i-th line contains three integers — the xi and yi coordinate values of the i-th location and the number ki of people in it (1 ≤ ki < 106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.It is guaranteed that no two locations are at the same point and no location is at point (0; 0).",
      "output_spec": "OutputIn the output, print \"-1\" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.The answer is considered correct if the absolute or relative error don't exceed 10 - 6.",
      "sample_tests": "ExamplesInputCopy4 9999981 1 12 2 13 3 12 -2 1OutputCopy2.8284271InputCopy4 9999981 1 22 2 13 3 12 -2 1OutputCopy1.4142136InputCopy2 11 1 9999972 2 1OutputCopy-1",
      "description": "B. Megacity\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and s (1 ≤ n ≤ 103; 1 ≤ s < 106) — the number of locatons around Tomsk city and the population of the city. Then n lines follow. The i-th line contains three integers — the xi and yi coordinate values of the i-th location and the number ki of people in it (1 ≤ ki < 106). Each coordinate is an integer and doesn't exceed 104 in its absolute value.It is guaranteed that no two locations are at the same point and no location is at point (0; 0).\n\nOutputIn the output, print \"-1\" (without the quotes), if Tomsk won't be able to become a megacity. Otherwise, in the first line print a single real number — the minimum radius of the circle that the city needs to expand to in order to become a megacity.The answer is considered correct if the absolute or relative error don't exceed 10 - 6.\n\nInputCopy4 9999981 1 12 2 13 3 12 -2 1OutputCopy2.8284271InputCopy4 9999981 1 22 2 13 3 12 -2 1OutputCopy1.4142136InputCopy2 11 1 9999972 2 1OutputCopy-1\n\nInputCopy4 9999981 1 12 2 13 3 12 -2 1\n\nOutputCopy2.8284271\n\nInputCopy4 9999981 1 22 2 13 3 12 -2 1\n\nOutputCopy1.4142136\n\nInputCopy2 11 1 9999972 2 1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Hello everyone!Codeforces Round #243 will take place on Sunday, April 27th at 19:30 MSK. This is my eleventh Codeforces round and I hope not the last.I'd like to thank Gerald and KADR for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values in first division 500-1000-1500-2000-2000. In second division — standard.Gl & hf ! :)Tutorial.Statistics.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 478
        },
        {
          "title": "Codeforces Round #242 (Div. 2) Editorial - Codeforces",
          "content": "424A - SquatsThe problem is to find the number of standing hamsters. If it is less than half, we should make the required number of hamsters standing. Otherwise we should make some hamsters sitting.424B - MegacityWe can sort all the cities by their distance to the Tomsk city di. After that we are to find the smallest index t for which the total population p0 + p1 + ... + pt >  = 106. In such case the answer is dt. We can sort all cities in O(NlogN) and find the value of t in O(N). Limits for N allow O(N2) sorting or any other O(N2) solution.424C - Magic FormulasConsider the following formulas: Let . Lets compute the following function for each i (0 ≤ i ≤ n). One can do it in O(n) using .Lets transform ci: Also: Thus: That means, if n / i is odd, , otherwise — . ci can be computed in O(1), that's why the complexity of the whole solution — O(n).424D - Biathlon TrackDue to the time limit for Java some of O(N4) solution got Accepted. The authors solution has complexity O(N3·logN). The main idea is to fix the top-border and bottom-border. Then, using some abstract data type, for each right-border we can find the most suitable left-border in O(logN) time. For example we can use set in C++ and its method lower_bound. For better understanding lets have a look at the following figure:For such rectangle we fix the upper-border as row number 2 and bottom-border as row number 5. Also, we fix right-border as column number 6, and now we are to find some left-border. Now we can split the time value for any rectangle for two summands. One of them depends only on left-border and another one — on the right-border.With the blue color the summand that depends only on the right-border is highlighted. With the red and yellow color — the other summand is highlighted. The red-colored value should be subtracted and the yellow-colored should be added. For any blue right-border's value we are to find the closest red-yellow left-border. That is the problem to be solved with the help of STL Set or any other similar abstract data type.424E - Colored JengaA classical DP-problem on finding expected number.Lets define some function F(S) for some state — the expected number of minutes to finish the game from this state. For each color we can compute the probability of showing this color by the simple formula , where c — the number of dice's faces of this color. Now we are to find the probability PL to stay in this state for the next minutes. That is the probabilty of showing black color plus the probabilities of showing colors with no blocks of that color to be removed from the tower. Now we can find the value via the following formula: The only problem is to find how to encode the state. To reduce the number of states we can assume that there is only 18 different type of levels, but not 27. For better time-performance it is better to use hashing. The solution for this problem requires good understanding of DP and quite good implementing skills.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 424\\s*B"
          },
          "content_length": 2965
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #242 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #242 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 999999, \"s\");\n    inf.readEoln();\n\n    set< pair<int,int> > coords;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 999999, \"ki\");\n        inf.readEoln();\n\n        ensuref(xi != 0 || yi != 0, \"No location can be at point (0, 0)\");\n\n        pair<int,int> point = make_pair(xi, yi);\n        ensuref(coords.count(point) == 0, \"No two locations can be at the same point (%d, %d)\", xi, yi);\n        coords.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 999999, \"s\");\n    inf.readEoln();\n\n    set< pair<int,int> > coords;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 999999, \"ki\");\n        inf.readEoln();\n\n        ensuref(xi != 0 || yi != 0, \"No location can be at point (0, 0)\");\n\n        pair<int,int> point = make_pair(xi, yi);\n        ensuref(coords.count(point) == 0, \"No two locations can be at the same point (%d, %d)\", xi, yi);\n        coords.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 999999, \"s\");\n    inf.readEoln();\n\n    set< pair<int,int> > coords;\n\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readSpace();\n        int ki = inf.readInt(1, 999999, \"ki\");\n        inf.readEoln();\n\n        ensuref(xi != 0 || yi != 0, \"No location can be at point (0, 0)\");\n\n        pair<int,int> point = make_pair(xi, yi);\n        ensuref(coords.count(point) == 0, \"No two locations can be at the same point (%d, %d)\", xi, yi);\n        coords.insert(point);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi, yi, ki;\n    set<pair<int, int>> points;\n\n    if (type == \"random\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-10000, 10000);\n                y = rnd.next(-10000, 10000);\n            } while ((x == 0 && y == 0) || points.count({x, y}));\n            points.insert({x, y});\n            xi[i] = x;\n            yi[i] = y;\n            ki[i] = rnd.next(1, 999999); // ki ∈ [1, 999999]\n        }\n    } else if (type == \"impossible\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        // Set sum of ki = 1e6 - s - 1\n        int sum_ki = 1000000 - s - 1;\n        if (sum_ki <= 0) {\n            fprintf(stderr, \"Cannot create 'impossible' test case with s=%d\\n\", s);\n            exit(1);\n        }\n        int avg_ki = sum_ki / n;\n        int rem = sum_ki % n;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = avg_ki;\n        }\n        for (int i = 0; i < rem; ++i) {\n            ki[i]++;\n        }\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-10000, 10000);\n                y = rnd.next(-10000, 10000);\n            } while ((x == 0 && y == 0) || points.count({x, y}));\n            points.insert({x, y});\n            xi.push_back(x);\n            yi.push_back(y);\n        }\n    } else if (type == \"just_enough\") {\n        xi.resize(1);\n        yi.resize(1);\n        ki.resize(1);\n        // s = s (from parameter)\n        // create one location with ki = 1e6 - s\n        int ki_needed = 1000000 - s;\n        if (ki_needed < 1 || ki_needed > 999999) {\n            fprintf(stderr, \"Cannot create 'just_enough' test case with s=%d\\n\", s);\n            exit(1);\n        }\n        n = 1;\n        xi[0] = 1; // Minimal distance from (0,0)\n        yi[0] = 0;\n        ki[0] = ki_needed;\n    } else if (type == \"precision\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        int x0 = 10000; // Max coordinate\n        int y0 = 0;\n        for (int i = 0; i < n; ++i) {\n            int x = x0 - i;\n            int y = 1;\n            xi[i] = x;\n            yi[i] = y;\n            ki[i] = rnd.next(1, 999999);\n        }\n    } else if (type == \"same_distance\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        vector<pair<int, int>> coords = {\n            {7,24}, {-7,24}, {7,-24}, {-7,-24},\n            {24,7}, {-24,7}, {24,-7}, {-24,-7},\n            {15,20}, {-15,20}, {15,-20}, {-15,-20},\n            {20,15}, {-20,15}, {20,-15}, {-20,-15}\n        };\n        if (n > (int)coords.size()) {\n            fprintf(stderr, \"Cannot create 'same_distance' test case with n=%d\\n\", n);\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            xi[i] = coords[i].first;\n            yi[i] = coords[i].second;\n            ki[i] = rnd.next(1, 999999);\n        }\n    } else if (type == \"max_coord\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int x = 10000 * ((i % 2 == 0) ? 1 : -1);\n            int y = 10000 * ((i % 3 == 0) ? 1 : -1);\n            if (x == 0 && y == 0) x = 1; // Avoid (0,0)\n            if (points.count({x, y})) {\n                x += rnd.next(1, 100);\n                y += rnd.next(1, 100);\n            }\n            xi[i] = x;\n            yi[i] = y;\n            ki[i] = rnd.next(1, 999999);\n            points.insert({x, y});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output s and n\n    printf(\"%d %d\\n\", n, s);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], yi[i], ki[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> xi, yi, ki;\n    set<pair<int, int>> points;\n\n    if (type == \"random\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-10000, 10000);\n                y = rnd.next(-10000, 10000);\n            } while ((x == 0 && y == 0) || points.count({x, y}));\n            points.insert({x, y});\n            xi[i] = x;\n            yi[i] = y;\n            ki[i] = rnd.next(1, 999999); // ki ∈ [1, 999999]\n        }\n    } else if (type == \"impossible\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        // Set sum of ki = 1e6 - s - 1\n        int sum_ki = 1000000 - s - 1;\n        if (sum_ki <= 0) {\n            fprintf(stderr, \"Cannot create 'impossible' test case with s=%d\\n\", s);\n            exit(1);\n        }\n        int avg_ki = sum_ki / n;\n        int rem = sum_ki % n;\n        for (int i = 0; i < n; ++i) {\n            ki[i] = avg_ki;\n        }\n        for (int i = 0; i < rem; ++i) {\n            ki[i]++;\n        }\n        for (int i = 0; i < n; ++i) {\n            int x, y;\n            do {\n                x = rnd.next(-10000, 10000);\n                y = rnd.next(-10000, 10000);\n            } while ((x == 0 && y == 0) || points.count({x, y}));\n            points.insert({x, y});\n            xi.push_back(x);\n            yi.push_back(y);\n        }\n    } else if (type == \"just_enough\") {\n        xi.resize(1);\n        yi.resize(1);\n        ki.resize(1);\n        // s = s (from parameter)\n        // create one location with ki = 1e6 - s\n        int ki_needed = 1000000 - s;\n        if (ki_needed < 1 || ki_needed > 999999) {\n            fprintf(stderr, \"Cannot create 'just_enough' test case with s=%d\\n\", s);\n            exit(1);\n        }\n        n = 1;\n        xi[0] = 1; // Minimal distance from (0,0)\n        yi[0] = 0;\n        ki[0] = ki_needed;\n    } else if (type == \"precision\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        int x0 = 10000; // Max coordinate\n        int y0 = 0;\n        for (int i = 0; i < n; ++i) {\n            int x = x0 - i;\n            int y = 1;\n            xi[i] = x;\n            yi[i] = y;\n            ki[i] = rnd.next(1, 999999);\n        }\n    } else if (type == \"same_distance\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        vector<pair<int, int>> coords = {\n            {7,24}, {-7,24}, {7,-24}, {-7,-24},\n            {24,7}, {-24,7}, {24,-7}, {-24,-7},\n            {15,20}, {-15,20}, {15,-20}, {-15,-20},\n            {20,15}, {-20,15}, {20,-15}, {-20,-15}\n        };\n        if (n > (int)coords.size()) {\n            fprintf(stderr, \"Cannot create 'same_distance' test case with n=%d\\n\", n);\n            exit(1);\n        }\n        for (int i = 0; i < n; ++i) {\n            xi[i] = coords[i].first;\n            yi[i] = coords[i].second;\n            ki[i] = rnd.next(1, 999999);\n        }\n    } else if (type == \"max_coord\") {\n        xi.resize(n);\n        yi.resize(n);\n        ki.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int x = 10000 * ((i % 2 == 0) ? 1 : -1);\n            int y = 10000 * ((i % 3 == 0) ? 1 : -1);\n            if (x == 0 && y == 0) x = 1; // Avoid (0,0)\n            if (points.count({x, y})) {\n                x += rnd.next(1, 100);\n                y += rnd.next(1, 100);\n            }\n            xi[i] = x;\n            yi[i] = y;\n            ki[i] = rnd.next(1, 999999);\n            points.insert({x, y});\n        }\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output s and n\n    printf(\"%d %d\\n\", n, s);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", xi[i], yi[i], ki[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -s 1 -type random\n./gen -n 10 -s 500000 -type random\n./gen -n 10 -s 999999 -type random\n\n./gen -n 100 -s 1 -type random\n./gen -n 100 -s 500000 -type random\n./gen -n 100 -s 999999 -type random\n\n./gen -n 1000 -s 1 -type random\n./gen -n 1000 -s 500000 -type random\n./gen -n 1000 -s 999999 -type random\n\n./gen -n 1 -s 999999 -type just_enough\n./gen -n 2 -s 999998 -type just_enough\n./gen -n 3 -s 999997 -type just_enough\n\n./gen -n 10 -s 1 -type impossible\n./gen -n 100 -s 100000 -type impossible\n./gen -n 1000 -s 500000 -type impossible\n\n./gen -n 15 -s 500000 -type same_distance\n./gen -n 8 -s 999995 -type same_distance\n\n./gen -n 10 -s 999990 -type precision\n./gen -n 100 -s 999900 -type precision\n\n./gen -n 10 -s 400000 -type max_coord\n./gen -n 100 -s 700000 -type max_coord\n./gen -n 1000 -s 900000 -type max_coord\n\n./gen -n 1 -s 999999 -type just_enough\n./gen -n 1 -s 999999 -type impossible\n\n./gen -n 5 -s 999995 -type precision\n./gen -n 10 -s 1 -type same_distance\n\n./gen -n 1000 -s 1 -type random\n./gen -n 1000 -s 999999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:50.313277",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "424/C",
      "title": "C. Magic Formulas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains the only integer n (1 ≤ n ≤ 106). The next line contains n integers: p1, p2, ..., pn (0 ≤ pi ≤ 2·109).",
      "output_spec": "OutputThe only line of output should contain a single integer — the value of Q.",
      "sample_tests": "ExamplesInputCopy31 2 3OutputCopy3",
      "description": "C. Magic Formulas\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains the only integer n (1 ≤ n ≤ 106). The next line contains n integers: p1, p2, ..., pn (0 ≤ pi ≤ 2·109).\n\nOutputThe only line of output should contain a single integer — the value of Q.\n\nInputCopy31 2 3OutputCopy3\n\nInputCopy31 2 3\n\nOutputCopy3",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Hello everyone!Codeforces Round #243 will take place on Sunday, April 27th at 19:30 MSK. This is my eleventh Codeforces round and I hope not the last.I'd like to thank Gerald and KADR for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values in first division 500-1000-1500-2000-2000. In second division — standard.Gl & hf ! :)Tutorial.Statistics.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 478
        },
        {
          "title": "Codeforces Round #242 (Div. 2) Editorial - Codeforces",
          "content": "424A - SquatsThe problem is to find the number of standing hamsters. If it is less than half, we should make the required number of hamsters standing. Otherwise we should make some hamsters sitting.424B - MegacityWe can sort all the cities by their distance to the Tomsk city di. After that we are to find the smallest index t for which the total population p0 + p1 + ... + pt >  = 106. In such case the answer is dt. We can sort all cities in O(NlogN) and find the value of t in O(N). Limits for N allow O(N2) sorting or any other O(N2) solution.424C - Magic FormulasConsider the following formulas: Let . Lets compute the following function for each i (0 ≤ i ≤ n). One can do it in O(n) using .Lets transform ci: Also: Thus: That means, if n / i is odd, , otherwise — . ci can be computed in O(1), that's why the complexity of the whole solution — O(n).424D - Biathlon TrackDue to the time limit for Java some of O(N4) solution got Accepted. The authors solution has complexity O(N3·logN). The main idea is to fix the top-border and bottom-border. Then, using some abstract data type, for each right-border we can find the most suitable left-border in O(logN) time. For example we can use set in C++ and its method lower_bound. For better understanding lets have a look at the following figure:For such rectangle we fix the upper-border as row number 2 and bottom-border as row number 5. Also, we fix right-border as column number 6, and now we are to find some left-border. Now we can split the time value for any rectangle for two summands. One of them depends only on left-border and another one — on the right-border.With the blue color the summand that depends only on the right-border is highlighted. With the red and yellow color — the other summand is highlighted. The red-colored value should be subtracted and the yellow-colored should be added. For any blue right-border's value we are to find the closest red-yellow left-border. That is the problem to be solved with the help of STL Set or any other similar abstract data type.424E - Colored JengaA classical DP-problem on finding expected number.Lets define some function F(S) for some state — the expected number of minutes to finish the game from this state. For each color we can compute the probability of showing this color by the simple formula , where c — the number of dice's faces of this color. Now we are to find the probability PL to stay in this state for the next minutes. That is the probabilty of showing black color plus the probabilities of showing colors with no blocks of that color to be removed from the tower. Now we can find the value via the following formula: The only problem is to find how to encode the state. To reduce the number of states we can assume that there is only 18 different type of levels, but not 27. For better time-performance it is better to use hashing. The solution for this problem requires good understanding of DP and quite good implementing skills.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 424\\s*C"
          },
          "content_length": 2965
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #242 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #242 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\"); // n between 1 and 1e6\n    inf.readEoln();\n    \n    inf.readInts(n, 0, 2000000000, \"p_i\"); // p_i between 0 and 2e9\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\"); // n between 1 and 1e6\n    inf.readEoln();\n    \n    inf.readInts(n, 0, 2000000000, \"p_i\"); // p_i between 0 and 2e9\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\"); // n between 1 and 1e6\n    inf.readEoln();\n    \n    inf.readInts(n, 0, 2000000000, \"p_i\"); // p_i between 0 and 2e9\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"small_n_random\") {\n        /* Generate small n random sequence */\n        ensure(n <= 10);\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    } else if (type == \"large_n_random\") {\n        /* Generate large n random sequence */\n        ensure(n >= 100000 && n <= 1000000);\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    } else if (type == \"all_same\") {\n        /* Generate a sequence where all pi are the same number */\n        int k = opt<int>(\"k\");\n        ensure(1 <= k && k <= 2000000000);\n        for (int i = 0; i < n; ++i)\n            p[i] = k;\n    } else if (type == \"pi_equal_1\") {\n        /* All pi = 1 */\n        for (int i = 0; i < n; ++i)\n            p[i] = 1;\n    } else if (type == \"pi_max\") {\n        /* All pi = 2000000000 */\n        for (int i = 0; i < n; ++i)\n            p[i] = 2000000000;\n    } else if (type == \"increasing\") {\n        /* Generate increasing sequence */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        /* Generate decreasing sequence */\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"early_mod_zero\") {\n        /* Generate sequence where p2=1 to cause mod chain to zero early */\n        p[0] = rnd.next(1, 2000000000);\n        p[1] = 1; // p1 mod p2 = p1 mod 1 = 0\n        for (int i = 2; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    } else if (type == \"xor_zero\") {\n        /* Generate sequence where xor of all pi is zero */\n        for (int i = 0; i < n; i += 2) {\n            int val = rnd.next(1, 2000000000);\n            p[i] = val;\n            if(i + 1 < n)\n                p[i + 1] = val;\n        }\n    } else {\n        /* Default to random sequence */\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output p1, p2, ..., pn */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> p(n);\n\n    if (type == \"small_n_random\") {\n        /* Generate small n random sequence */\n        ensure(n <= 10);\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    } else if (type == \"large_n_random\") {\n        /* Generate large n random sequence */\n        ensure(n >= 100000 && n <= 1000000);\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    } else if (type == \"all_same\") {\n        /* Generate a sequence where all pi are the same number */\n        int k = opt<int>(\"k\");\n        ensure(1 <= k && k <= 2000000000);\n        for (int i = 0; i < n; ++i)\n            p[i] = k;\n    } else if (type == \"pi_equal_1\") {\n        /* All pi = 1 */\n        for (int i = 0; i < n; ++i)\n            p[i] = 1;\n    } else if (type == \"pi_max\") {\n        /* All pi = 2000000000 */\n        for (int i = 0; i < n; ++i)\n            p[i] = 2000000000;\n    } else if (type == \"increasing\") {\n        /* Generate increasing sequence */\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n    } else if (type == \"decreasing\") {\n        /* Generate decreasing sequence */\n        for (int i = 0; i < n; ++i)\n            p[i] = n - i;\n    } else if (type == \"early_mod_zero\") {\n        /* Generate sequence where p2=1 to cause mod chain to zero early */\n        p[0] = rnd.next(1, 2000000000);\n        p[1] = 1; // p1 mod p2 = p1 mod 1 = 0\n        for (int i = 2; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    } else if (type == \"xor_zero\") {\n        /* Generate sequence where xor of all pi is zero */\n        for (int i = 0; i < n; i += 2) {\n            int val = rnd.next(1, 2000000000);\n            p[i] = val;\n            if(i + 1 < n)\n                p[i + 1] = val;\n        }\n    } else {\n        /* Default to random sequence */\n        for (int i = 0; i < n; ++i)\n            p[i] = rnd.next(1, 2000000000);\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output p1, p2, ..., pn */\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", p[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type pi_equal_1\n./gen -n 2 -type all_same -k 2\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n./gen -n 3 -type early_mod_zero\n./gen -n 3 -type xor_zero\n./gen -n 10 -type pi_equal_1\n./gen -n 10 -type all_same -k 2000000000\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type random\n./gen -n 100 -type pi_equal_1\n./gen -n 100 -type pi_max\n./gen -n 100 -type early_mod_zero\n./gen -n 100 -type xor_zero\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type increasing\n./gen -n 50000 -type decreasing\n./gen -n 100000 -type pi_equal_1\n./gen -n 100000 -type pi_max\n./gen -n 100000 -type all_same -k 123456789\n./gen -n 100000 -type early_mod_zero\n./gen -n 100000 -type xor_zero\n./gen -n 200000 -type random\n./gen -n 500000 -type random\n./gen -n 1000000 -type random\n./gen -n 1000000 -type early_mod_zero\n./gen -n 1000000 -type xor_zero\n./gen -n 1000000 -type pi_max\n./gen -n 1000000 -type pi_equal_1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:52.708347",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "424/D",
      "title": "D. Биатлонная трасса",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных содержатся три целых числа n, m и t (3 ≤ n, m ≤ 300, 1 ≤ t ≤ 109) — размеры земельного участка и желательное время прохождения.Во второй строке так же содержатся три целых числа tp, tu и td (1 ≤ tp, tu, td ≤ 100) — время прохождения среднестатистическим биатлонистом ровного участка трассы, подъема и спуска соответственно.Далее следует n строк по m целых чисел, задающих высоты каждого из квадратов выделенного земельного участка. Каждое из значений высот — целое положительное число, не превышающее 106.",
      "output_spec": "Выходные данныеВ единственной строке выходных данных требуется вывести четыре целых положительных числа — номер строки и номер столбца левого верхнего угла, а также номер строки и номер столбца правого нижнего угла выбранного для трассы прямоугольника.",
      "sample_tests": "ПримерыВходные данныеСкопировать6 7 483 6 25 4 8 3 3 7 94 1 6 8 7 1 11 6 4 6 4 8 67 2 6 1 6 9 41 9 8 6 3 9 24 5 6 8 4 3 7Выходные данныеСкопировать4 3 6 7",
      "description": "D. Биатлонная трасса\n\nограничение по времени на тест4.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных содержатся три целых числа n, m и t (3 ≤ n, m ≤ 300, 1 ≤ t ≤ 109) — размеры земельного участка и желательное время прохождения.Во второй строке так же содержатся три целых числа tp, tu и td (1 ≤ tp, tu, td ≤ 100) — время прохождения среднестатистическим биатлонистом ровного участка трассы, подъема и спуска соответственно.Далее следует n строк по m целых чисел, задающих высоты каждого из квадратов выделенного земельного участка. Каждое из значений высот — целое положительное число, не превышающее 106.\n\nВходные данные\n\nВыходные данныеВ единственной строке выходных данных требуется вывести четыре целых положительных числа — номер строки и номер столбца левого верхнего угла, а также номер строки и номер столбца правого нижнего угла выбранного для трассы прямоугольника.\n\nВыходные данные\n\nВходные данныеСкопировать6 7 483 6 25 4 8 3 3 7 94 1 6 8 7 1 11 6 4 6 4 8 67 2 6 1 6 9 41 9 8 6 3 9 24 5 6 8 4 3 7Выходные данныеСкопировать4 3 6 7\n\nВходные данныеСкопировать6 7 483 6 25 4 8 3 3 7 94 1 6 8 7 1 11 6 4 6 4 8 67 2 6 1 6 9 41 9 8 6 3 9 24 5 6 8 4 3 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4 3 6 7\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces",
          "content": "424A - Паша и приседанияВ задаче требуется найти количество хомяков, которые стоят. Если оно меньше половины от общего числа, то требуется заставить некоторых сидящих хомяков встать. Иначе — требуется посадить некоторых из стоящих хомяков. Если есть выбор какого из сидячих хомяков заставить встать или какого из стоячих хомяков посадить, то можно выбрать любого.424B - Город-миллионерМожно отсортировать все города по возрастанию расстояния до города Томска. После чего требуется найти наименьший индекс t, для которого общее население p0 + p1 + ... + pt >  = 106. Для такого t значение dt является ответом. Ограничения на N позволяют использовать сортировку с асимптотикой O(N2) или любое другое решение с такой асимптотикой.424C - Волшебные формулыРассмотрим следующие формулы: Пусть . Посчитаем значение этой функции для всех значений i (0 ≤ i ≤ n). Это можно сделать за O(n), используя соотношение .Преобразуем ci: Также: Таким образом: Это означает, что если n / i нечетно, , иначе — . ci может быть вычислено за O(1), благодаря чему итоговая асимптотика решения — O(n).424D - Биатлонная трассаИз-за лояльных ограничений по времени для Java, некоторые решения с асимптотикой O(N4) были зачтены. Авторское решение имеет сложность O(N3logN). Основная идея — зафиксировать верхнюю и нижнюю границы. Затем, используя какой-либо абстрактный тип данных, для каждой правой границы найти наиболее подходящую левую границу за время не хуже O(logN). Например, можно использовать контейнер set в языке программирования C++ и его метод lower_bound. Для лучшего понимания можно посмотреть на следующее изображение.Для показанного прямоугольника мы зафиксировали верхнюю границу строкой номер 2, нижнюю — строкой номер 5. Так же мы зафиксировали правую границу столбцом номер 6. Теперь требуется найти наиболее подходящую левую границу. Для этого мы можем разделить значение времени для любого прямоугольника на слагаемое, которое зависит только от правой границы, и на слагаемое, которое зависит только от левой границы.Синим цветом подсвечено слагаемое, которое зависит только от правой границы. Красным и желтым — только от левой. Значение выделенное красным необходимо вычесть из общего значения времени, желтое, как и синее, требуется добавить. Для любого синего значения для правой границы можно найти ближайшее по абсолютному значению красно-желтое значение для левой границы. Для этого и требуется использовать какой-либо абстрактный тип данных.424E - Цветная JengaКлассическая задача на динамическое программирование для нахождения математического ожидания.Определим некоторую функцию F(S) для некоторого состояния S — математическое ожидание количества минут до конца игры, если мы находимся в этом состоянии. Для каждого цвета мы можем вычислить вероятность, с которой этот цвет выпадет при броске кубика по тривиальной формуле , где c — количество граней такого цвета на кубике. Теперь требуется найти вероятность того, что мы останемся в том же состоянии еще хотя бы на одну минуту. Это можно сделать сложив вероятность выпадения черной грани и вероятности выпадения цветов, блоки цвета которых нельзя достать из башни на данный момент. Теперь мы можем найти значение это функции используя формулу: Далее требуется придумать как закодировать состояния. Для того, чтобы уменьшить количество различных состояний можно воспользоваться тем фактом, что имеется всего-лишь 18 различных уровней, а не 27 (некоторые комбинации являются отражением друг друга). Для лучшей производительности рекомендуется использовать хеширование. Решение данной задачи требует хорошего понимания динамического программирования и достаточно хороших реализаторских навыков.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 424\\s*D"
          },
          "content_length": 3651
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 300, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n    \n    int tp = inf.readInt(1, 100, \"tp\");\n    inf.readSpace();\n    int tu = inf.readInt(1, 100, \"tu\");\n    inf.readSpace();\n    int td = inf.readInt(1, 100, \"td\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 1, 1000000);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 300, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n    \n    int tp = inf.readInt(1, 100, \"tp\");\n    inf.readSpace();\n    int tu = inf.readInt(1, 100, \"tu\");\n    inf.readSpace();\n    int td = inf.readInt(1, 100, \"td\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 1, 1000000);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 300, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 300, \"m\");\n    inf.readSpace();\n    int t = inf.readInt(1, 1000000000, \"t\");\n    inf.readEoln();\n    \n    int tp = inf.readInt(1, 100, \"tp\");\n    inf.readSpace();\n    int tu = inf.readInt(1, 100, \"tu\");\n    inf.readSpace();\n    int td = inf.readInt(1, 100, \"td\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 1, 1000000);\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, t;\nint tp, tu, td;\nvector<vector<int>> heights;\n\nlong long readAns(InStream& stream) {\n    int a1 = stream.readInt(1, n, \"a1\");\n    int b1 = stream.readInt(1, m, \"b1\");\n    int a2 = stream.readInt(1, n, \"a2\");\n    int b2 = stream.readInt(1, m, \"b2\");\n    \n    if (a1 > a2)\n        stream.quitf(_wa, \"a1(%d) > a2(%d)\", a1, a2);\n    if (b1 > b2)\n        stream.quitf(_wa, \"b1(%d) > b2(%d)\", b1, b2);\n    int width = b2 - b1 + 1;\n    int height_r = a2 - a1 + 1;\n    if (width < 3)\n        stream.quitf(_wa, \"rectangle width (%d) less than 3\", width);\n    if (height_r < 3)\n        stream.quitf(_wa, \"rectangle height (%d) less than 3\", height_r);\n    // Build the path in clockwise order\n    vector<pair<int, int>> path;\n    // Top edge\n    for (int b = b1; b <= b2; ++b)\n        path.push_back({a1, b});\n    // Right edge\n    for (int a = a1+1; a <= a2; ++a)\n        path.push_back({a, b2});\n    // Bottom edge\n    for (int b = b2-1; b >= b1; --b)\n        path.push_back({a2, b});\n    // Left edge\n    for (int a = a2-1; a >= a1+1; --a)\n        path.push_back({a, b1});\n    // Compute ts\n    long long ts = 0;\n    int sz = path.size();\n    for (int i = 0; i < sz; ++i) {\n        int x1 = path[i].first;\n        int y1 = path[i].second;\n        int x2 = path[(i+1)%sz].first;\n        int y2 = path[(i+1)%sz].second;\n        int h1 = heights[x1-1][y1-1];\n        int h2 = heights[x2-1][y2-1];\n        if (abs(x1 - x2) + abs(y1 - y2) != 1)\n            stream.quitf(_fail, \"Invalid movement between (%d,%d) and (%d,%d)\", x1, y1, x2, y2);\n        if (h1 < h2)\n            ts += tu;\n        else if (h1 > h2)\n            ts += td;\n        else\n            ts += tp;\n    }\n    return ts;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    n = inf.readInt(3, 300);\n    m = inf.readInt(3, 300);\n    t = inf.readInt(1, 1000000000);\n    tp = inf.readInt(1, 100);\n    tu = inf.readInt(1, 100);\n    td = inf.readInt(1, 100);\n    heights.resize(n, vector<int>(m));\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < m; ++j)\n            heights[i][j] = inf.readInt(1, 1000000);\n    long long ts_jury = readAns(ans);\n    long long ts_contestant = readAns(ouf);\n    long long diff_jury = abs(ts_jury - t);\n    long long diff_contestant = abs(ts_contestant - t);\n    if (diff_contestant > diff_jury)\n        quitf(_wa, \"Contestant's solution is not optimal (diff = %lld, optimal diff = %lld)\", diff_contestant, diff_jury);\n    else if (diff_contestant == diff_jury)\n        quitf(_ok, \"Accepted, ts = %lld, diff = %lld\", ts_contestant, diff_contestant);\n    else // diff_contestant < diff_jury\n        quitf(_fail, \"Contestant's solution is better than jury's (contestant diff = %lld, jury diff = %lld)\", diff_contestant, diff_jury);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    int tp = opt<int>(\"tp\");\n    int tu = opt<int>(\"tu\");\n    int td = opt<int>(\"td\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> heights(n, vector<int>(m));\n\n    if (type == \"flat\") {\n        // All heights are the same\n        int h = opt<int>(\"h\", rnd.next(1, 1000000));\n        for(int i = 0; i < n; ++i)\n            fill(heights[i].begin(), heights[i].end(), h);\n    } else if (type == \"random\") {\n        // Random heights between 1 and 1e6\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                heights[i][j] = rnd.next(1, 1000000);\n    } else if (type == \"increasing_row\") {\n        // Heights increase along the row\n        int h_start = rnd.next(1, 1000000 - m + 1);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j)\n                heights[i][j] = h_start + j;\n        }\n    } else if (type == \"increasing_column\") {\n        // Heights increase along the column\n        int h_start = rnd.next(1, 1000000 - n + 1);\n        for(int j = 0; j < m; ++j) {\n            for(int i = 0; i < n; ++i)\n                heights[i][j] = h_start + i;\n        }\n    } else if (type == \"checkerboard\") {\n        // Heights alternate between two values\n        int h1 = opt<int>(\"h1\", rnd.next(1, 1000000));\n        int h2 = opt<int>(\"h2\", rnd.next(1, 1000000));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                heights[i][j] = ((i + j) % 2 == 0) ? h1 : h2;\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, t);\n    printf(\"%d %d %d\\n\", tp, tu, td);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", heights[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int t = opt<int>(\"t\");\n    int tp = opt<int>(\"tp\");\n    int tu = opt<int>(\"tu\");\n    int td = opt<int>(\"td\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> heights(n, vector<int>(m));\n\n    if (type == \"flat\") {\n        // All heights are the same\n        int h = opt<int>(\"h\", rnd.next(1, 1000000));\n        for(int i = 0; i < n; ++i)\n            fill(heights[i].begin(), heights[i].end(), h);\n    } else if (type == \"random\") {\n        // Random heights between 1 and 1e6\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                heights[i][j] = rnd.next(1, 1000000);\n    } else if (type == \"increasing_row\") {\n        // Heights increase along the row\n        int h_start = rnd.next(1, 1000000 - m + 1);\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < m; ++j)\n                heights[i][j] = h_start + j;\n        }\n    } else if (type == \"increasing_column\") {\n        // Heights increase along the column\n        int h_start = rnd.next(1, 1000000 - n + 1);\n        for(int j = 0; j < m; ++j) {\n            for(int i = 0; i < n; ++i)\n                heights[i][j] = h_start + i;\n        }\n    } else if (type == \"checkerboard\") {\n        // Heights alternate between two values\n        int h1 = opt<int>(\"h1\", rnd.next(1, 1000000));\n        int h2 = opt<int>(\"h2\", rnd.next(1, 1000000));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                heights[i][j] = ((i + j) % 2 == 0) ? h1 : h2;\n    } else {\n        fprintf(stderr, \"Unknown type '%s'\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", n, m, t);\n    printf(\"%d %d %d\\n\", tp, tu, td);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", heights[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grid, flat heights\n./gen -n 3 -m 3 -t 10 -tp 1 -tu 1 -td 1 -type flat -h 5\n\n# Small grid, random heights\n./gen -n 3 -m 3 -t 15 -tp 5 -tu 5 -td 5 -type random\n\n# Small grid, increasing_row\n./gen -n 3 -m 3 -t 12 -tp 2 -tu 3 -td 1 -type increasing_row\n\n# Medium grid, random heights\n./gen -n 100 -m 100 -t 5000 -tp 3 -tu 6 -td 2 -type random\n\n# Medium grid, flat heights\n./gen -n 100 -m 100 -t 10000 -tp 5 -tu 5 -td 5 -type flat -h 100\n\n# Medium grid, checkerboard heights\n./gen -n 100 -m 100 -t 10000 -tp 1 -tu 1 -td 1 -type checkerboard -h1 100 -h2 200\n\n# Large grid, random heights\n./gen -n 300 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type random\n\n# Edge case: Max n, m, minimal t\n./gen -n 300 -m 300 -t 1 -tp 1 -tu 1 -td 1 -type flat -h 1\n\n# Edge case: n small, m large\n./gen -n 3 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type increasing_column\n\n# Edge case: n large, m small\n./gen -n 300 -m 3 -t 1000000000 -tp 100 -tu 100 -td 100 -type increasing_row\n\n# Checkerboard pattern with max heights\n./gen -n 300 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type checkerboard -h1 1000000 -h2 1000000\n\n# Flat heights with minimal height\n./gen -n 300 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type flat -h 1\n\n# Increasing row heights with minimal starting height\n./gen -n 300 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type increasing_row\n\n# Increasing column heights with maximal starting height\n./gen -n 300 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type increasing_column\n\n# Small grid, checkerboard pattern\n./gen -n 10 -m 10 -t 100 -tp 5 -tu 5 -td 5 -type checkerboard -h1 100 -h2 101\n\n# Medium grid, heights alternating between min and max\n./gen -n 100 -m 100 -t 1000 -tp 10 -tu 20 -td 15 -type checkerboard -h1 1 -h2 1000000\n\n# Random heights with small tp, large tu, td\n./gen -n 100 -m 100 -t 10000 -tp 1 -tu 100 -td 100 -type random\n\n# Random heights with large tp, small tu, td\n./gen -n 100 -m 100 -t 10000 -tp 100 -tu 1 -td 1 -type random\n\n# Random heights with all times equal\n./gen -n 200 -m 200 -t 50000 -tp 50 -tu 50 -td 50 -type random\n\n# Checkerboard with small h1 and large h2\n./gen -n 200 -m 200 -t 50000 -tp 5 -tu 10 -td 5 -type checkerboard -h1 1 -h2 1000\n\n# Increasing_row with small starting height\n./gen -n 200 -m 200 -t 50000 -tp 5 -tu 10 -td 5 -type increasing_row\n\n# Increasing_column with small starting height\n./gen -n 200 -m 200 -t 50000 -tp 5 -tu 10 -td 5 -type increasing_column\n\n# Flat grid with random height\n./gen -n 150 -m 150 -t 20000 -tp 1 -tu 1 -td 1 -type flat\n\n# Random grid with minimal heights\n./gen -n 150 -m 150 -t 20000 -tp 1 -tu 1 -td 1 -type random\n\n# Random grid with maximal heights\n./gen -n 150 -m 150 -t 20000 -tp 1 -tu 1 -td 1 -type random\n\n# Flat grid with maximal heights\n./gen -n 300 -m 300 -t 1000000000 -tp 100 -tu 100 -td 100 -type flat -h 1000000\n\n# Checkerboard with equal heights\n./gen -n 300 -m 300 -t 1000000000 -tp 50 -tu 50 -td 50 -type checkerboard -h1 123456 -h2 123456\n\n# Edge case: minimal n and m\n./gen -n 3 -m 3 -t 20 -tp 2 -tu 2 -td 2 -type random\n\n# Edge case: n and m at maximum with t minimum\n./gen -n 300 -m 300 -t 1 -tp 100 -tu 100 -td 100 -type flat -h 1000000\n\n# Random grid with t in mid-range\n./gen -n 250 -m 250 -t 500000000 -tp 100 -tu 100 -td 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:54.620666",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "424/E",
      "title": "E. Цветная Jenga",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных задано единственное целое число n — количество уровней в башне (2 ≤ n ≤ 6).Далее следует n строк, описывающих уровни башни снизу вверх (первая строка — самый нижний уровень). Каждый из уровней описывается тремя символами, первый и третий из которых задают крайние блоки уровня, а второй — средний блок. Символ, описывающий блок, может принимать значения «R» (красный блок), «G» (зеленый блок) и «B» (синий блок).",
      "output_spec": "Выходные данныеВ единственной строке выходных данных требуется вывести искомое значение математического ожидания. Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превысит 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать6RGBGRGBBBGGRBRGBRBВыходные данныеСкопировать17.119213696601992",
      "description": "E. Цветная Jenga\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных задано единственное целое число n — количество уровней в башне (2 ≤ n ≤ 6).Далее следует n строк, описывающих уровни башни снизу вверх (первая строка — самый нижний уровень). Каждый из уровней описывается тремя символами, первый и третий из которых задают крайние блоки уровня, а второй — средний блок. Символ, описывающий блок, может принимать значения «R» (красный блок), «G» (зеленый блок) и «B» (синий блок).\n\nВходные данные\n\nВыходные данныеВ единственной строке выходных данных требуется вывести искомое значение математического ожидания. Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превысит 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать6RGBGRGBBBGGRBRGBRBВыходные данныеСкопировать17.119213696601992\n\nВходные данныеСкопировать6RGBGRGBBBGGRBRGBRB\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать17.119213696601992\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces",
          "content": "424A - Паша и приседанияВ задаче требуется найти количество хомяков, которые стоят. Если оно меньше половины от общего числа, то требуется заставить некоторых сидящих хомяков встать. Иначе — требуется посадить некоторых из стоящих хомяков. Если есть выбор какого из сидячих хомяков заставить встать или какого из стоячих хомяков посадить, то можно выбрать любого.424B - Город-миллионерМожно отсортировать все города по возрастанию расстояния до города Томска. После чего требуется найти наименьший индекс t, для которого общее население p0 + p1 + ... + pt >  = 106. Для такого t значение dt является ответом. Ограничения на N позволяют использовать сортировку с асимптотикой O(N2) или любое другое решение с такой асимптотикой.424C - Волшебные формулыРассмотрим следующие формулы: Пусть . Посчитаем значение этой функции для всех значений i (0 ≤ i ≤ n). Это можно сделать за O(n), используя соотношение .Преобразуем ci: Также: Таким образом: Это означает, что если n / i нечетно, , иначе — . ci может быть вычислено за O(1), благодаря чему итоговая асимптотика решения — O(n).424D - Биатлонная трассаИз-за лояльных ограничений по времени для Java, некоторые решения с асимптотикой O(N4) были зачтены. Авторское решение имеет сложность O(N3logN). Основная идея — зафиксировать верхнюю и нижнюю границы. Затем, используя какой-либо абстрактный тип данных, для каждой правой границы найти наиболее подходящую левую границу за время не хуже O(logN). Например, можно использовать контейнер set в языке программирования C++ и его метод lower_bound. Для лучшего понимания можно посмотреть на следующее изображение.Для показанного прямоугольника мы зафиксировали верхнюю границу строкой номер 2, нижнюю — строкой номер 5. Так же мы зафиксировали правую границу столбцом номер 6. Теперь требуется найти наиболее подходящую левую границу. Для этого мы можем разделить значение времени для любого прямоугольника на слагаемое, которое зависит только от правой границы, и на слагаемое, которое зависит только от левой границы.Синим цветом подсвечено слагаемое, которое зависит только от правой границы. Красным и желтым — только от левой. Значение выделенное красным необходимо вычесть из общего значения времени, желтое, как и синее, требуется добавить. Для любого синего значения для правой границы можно найти ближайшее по абсолютному значению красно-желтое значение для левой границы. Для этого и требуется использовать какой-либо абстрактный тип данных.424E - Цветная JengaКлассическая задача на динамическое программирование для нахождения математического ожидания.Определим некоторую функцию F(S) для некоторого состояния S — математическое ожидание количества минут до конца игры, если мы находимся в этом состоянии. Для каждого цвета мы можем вычислить вероятность, с которой этот цвет выпадет при броске кубика по тривиальной формуле , где c — количество граней такого цвета на кубике. Теперь требуется найти вероятность того, что мы останемся в том же состоянии еще хотя бы на одну минуту. Это можно сделать сложив вероятность выпадения черной грани и вероятности выпадения цветов, блоки цвета которых нельзя достать из башни на данный момент. Теперь мы можем найти значение это функции используя формулу: Далее требуется придумать как закодировать состояния. Для того, чтобы уменьшить количество различных состояний можно воспользоваться тем фактом, что имеется всего-лишь 18 различных уровней, а не 27 (некоторые комбинации являются отражением друг друга). Для лучшей производительности рекомендуется использовать хеширование. Решение данной задачи требует хорошего понимания динамического программирования и достаточно хороших реализаторских навыков.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11944",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 424\\s*E"
          },
          "content_length": 3651
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #242 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%.07Lf\")  does not works here but\n\ncout << fixed << setprecision(7) << R; works",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11944",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 6, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.size() == 3, \"Line %d must contain exactly 3 characters\", i + 2);\n\n        for (int j = 0; j < 3; ++j) {\n            char c = s[j];\n            ensuref(c == 'R' || c == 'G' || c == 'B', \"Invalid character '%c' at line %d position %d\", c, i + 2, j + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 6, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.size() == 3, \"Line %d must contain exactly 3 characters\", i + 2);\n\n        for (int j = 0; j < 3; ++j) {\n            char c = s[j];\n            ensuref(c == 'R' || c == 'G' || c == 'B', \"Invalid character '%c' at line %d position %d\", c, i + 2, j + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 6, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(s.size() == 3, \"Line %d must contain exactly 3 characters\", i + 2);\n\n        for (int j = 0; j < 3; ++j) {\n            char c = s[j];\n            ensuref(c == 'R' || c == 'G' || c == 'B', \"Invalid character '%c' at line %d position %d\", c, i + 2, j + 1);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-6;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative  error = %.7f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.7f', found: '%.7f', error = '%.7f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.7f', expected '%.7f', error '%.7f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize tower levels\n    vector<string> tower(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            string level = \"\";\n            for (int j = 0; j < 3; ++j) {\n                int c = rnd.next(3); // 0,1,2\n                if (c == 0) level += 'R';\n                else if (c == 1) level += 'G';\n                else level += 'B';\n            }\n            tower[i] = level;\n        }\n    } else if (type == \"single_color\") {\n        char colors[] = {'R', 'G', 'B'};\n        char color = colors[rnd.next(3)];\n        for (int i = 0; i < n; ++i) {\n            tower[i] = string(3, color);\n        }\n    } else if (type == \"alternate_colors\") {\n        // Alternate among the possible permutations of 'RGB'\n        vector<string> sequences = {\"RGB\", \"RBG\", \"GRB\", \"GBR\", \"BRG\", \"BGR\"};\n        int idx = rnd.next(sequences.size());\n        for (int i = 0; i < n; ++i) {\n            tower[i] = sequences[(idx + i) % sequences.size()];\n        }\n    } else if (type == \"impossible_to_remove\") {\n        // Construct a tower such that no blocks can be removed without causing the tower to fall\n        // Levels with only one side block (not middle) left\n        for (int i = 0; i < n; ++i) {\n            string level = \"   \"; // Initialize with spaces\n            if (i == n - 1) {\n                // Bottom level, place a block at a side position\n                level[rnd.next(2) * 2] = 'R';\n            } else {\n                // Other levels, also place a block at a side position\n                level[rnd.next(2) * 2] = 'G';\n            }\n            tower[i] = level;\n        }\n    } else if (type == \"maximal_moves\") {\n        // Construct a tower with all blocks present to maximize game duration\n        for (int i = 0; i < n; ++i) {\n            tower[i] = \"RGB\";\n        }\n    } else if (type == \"minimal_moves\") {\n        // Construct a tower with minimal possible moves\n        // Only one block can be removed safely\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                // Bottom level has three blocks\n                tower[i] = \"RRR\";\n            } else {\n                // Other levels are empty (no blocks to remove)\n                tower[i] = \"   \";\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            string level = \"\";\n            for (int j = 0; j < 3; ++j) {\n                int c = rnd.next(3); // 0,1,2\n                if (c == 0) level += 'R';\n                else if (c == 1) level += 'G';\n                else level += 'B';\n            }\n            tower[i] = level;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = n - 1; i >= 0; --i) {\n        printf(\"%s\\n\", tower[i].c_str());\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize tower levels\n    vector<string> tower(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            string level = \"\";\n            for (int j = 0; j < 3; ++j) {\n                int c = rnd.next(3); // 0,1,2\n                if (c == 0) level += 'R';\n                else if (c == 1) level += 'G';\n                else level += 'B';\n            }\n            tower[i] = level;\n        }\n    } else if (type == \"single_color\") {\n        char colors[] = {'R', 'G', 'B'};\n        char color = colors[rnd.next(3)];\n        for (int i = 0; i < n; ++i) {\n            tower[i] = string(3, color);\n        }\n    } else if (type == \"alternate_colors\") {\n        // Alternate among the possible permutations of 'RGB'\n        vector<string> sequences = {\"RGB\", \"RBG\", \"GRB\", \"GBR\", \"BRG\", \"BGR\"};\n        int idx = rnd.next(sequences.size());\n        for (int i = 0; i < n; ++i) {\n            tower[i] = sequences[(idx + i) % sequences.size()];\n        }\n    } else if (type == \"impossible_to_remove\") {\n        // Construct a tower such that no blocks can be removed without causing the tower to fall\n        // Levels with only one side block (not middle) left\n        for (int i = 0; i < n; ++i) {\n            string level = \"   \"; // Initialize with spaces\n            if (i == n - 1) {\n                // Bottom level, place a block at a side position\n                level[rnd.next(2) * 2] = 'R';\n            } else {\n                // Other levels, also place a block at a side position\n                level[rnd.next(2) * 2] = 'G';\n            }\n            tower[i] = level;\n        }\n    } else if (type == \"maximal_moves\") {\n        // Construct a tower with all blocks present to maximize game duration\n        for (int i = 0; i < n; ++i) {\n            tower[i] = \"RGB\";\n        }\n    } else if (type == \"minimal_moves\") {\n        // Construct a tower with minimal possible moves\n        // Only one block can be removed safely\n        for (int i = 0; i < n; ++i) {\n            if (i == n - 1) {\n                // Bottom level has three blocks\n                tower[i] = \"RRR\";\n            } else {\n                // Other levels are empty (no blocks to remove)\n                tower[i] = \"   \";\n            }\n        }\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i) {\n            string level = \"\";\n            for (int j = 0; j < 3; ++j) {\n                int c = rnd.next(3); // 0,1,2\n                if (c == 0) level += 'R';\n                else if (c == 1) level += 'G';\n                else level += 'B';\n            }\n            tower[i] = level;\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = n - 1; i >= 0; --i) {\n        printf(\"%s\\n\", tower[i].c_str());\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 6 -type random\n\n./gen -n 2 -type single_color\n./gen -n 3 -type single_color\n./gen -n 4 -type single_color\n./gen -n 5 -type single_color\n./gen -n 6 -type single_color\n\n./gen -n 2 -type alternate_colors\n./gen -n 3 -type alternate_colors\n./gen -n 4 -type alternate_colors\n./gen -n 5 -type alternate_colors\n./gen -n 6 -type alternate_colors\n\n./gen -n 2 -type impossible_to_remove\n./gen -n 3 -type impossible_to_remove\n./gen -n 4 -type impossible_to_remove\n./gen -n 5 -type impossible_to_remove\n./gen -n 6 -type impossible_to_remove\n\n./gen -n 2 -type maximal_moves\n./gen -n 3 -type maximal_moves\n./gen -n 4 -type maximal_moves\n./gen -n 5 -type maximal_moves\n./gen -n 6 -type maximal_moves\n\n./gen -n 2 -type minimal_moves\n./gen -n 3 -type minimal_moves\n./gen -n 4 -type minimal_moves\n./gen -n 5 -type minimal_moves\n./gen -n 6 -type minimal_moves\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:56.319489",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "425/A",
      "title": "A. Sereja and Swaps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 200; 1 ≤ k ≤ 10). The next line contains n integers a[1], a[2], ..., a[n] ( - 1000 ≤ a[i] ≤ 1000).",
      "output_spec": "OutputIn a single line print the maximum value of m(a) that Sereja can get if he is allowed to perform at most k swap operations.",
      "sample_tests": "ExamplesInputCopy10 210 -1 2 2 2 2 2 2 -1 10OutputCopy32InputCopy5 10-1 -1 -1 -1 -1OutputCopy-1",
      "description": "A. Sereja and Swaps\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 200; 1 ≤ k ≤ 10). The next line contains n integers a[1], a[2], ..., a[n] ( - 1000 ≤ a[i] ≤ 1000).\n\nOutputIn a single line print the maximum value of m(a) that Sereja can get if he is allowed to perform at most k swap operations.\n\nInputCopy10 210 -1 2 2 2 2 2 2 -1 10OutputCopy32InputCopy5 10-1 -1 -1 -1 -1OutputCopy-1\n\nInputCopy10 210 -1 2 2 2 2 2 2 -1 10\n\nOutputCopy32\n\nInputCopy5 10-1 -1 -1 -1 -1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Hello everyone!Codeforces Round #243 will take place on Sunday, April 27th at 19:30 MSK. This is my eleventh Codeforces round and I hope not the last.I'd like to thank Gerald and KADR for helping me to prepare the round. Special thanks to Delinur for translation of all problem statements into English.I strongly recommend you to read ALL the problems.Problem point values in first division 500-1000-1500-2000-2000. In second division — standard.Gl & hf ! :)Tutorial.Statistics.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 478
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Sereja and MugsLets count the sum of all elements Sum and value of the maximal element M. If Sum - M ≤ S then answer is yes, otherwise — no.426B - Sereja and MirroringLets solve problem from another side. We will try to cut of matix as many times as we can. Cut means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Sereja and SwapsLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3·log(n)). Is there some ideas how to solve this problem in time O(n) or O(n·log(n)) ? 425B - Sereja and Table Note, that if we have two arrays x[1..n], 0 ≤ xi ≤ 1 and y[1..m], 0 ≤ yi ≤ 1, then described matrix can be showed as next one: ai, j = xi xor yj.If n ≤ k, then we can backtrack array x and using greedy find best y. Otherwise there will be atleast one i, such that we will not change any cell in row number i. So we can simply bruteforce some row and use it like x. Then we use greedy and find y. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn't possible to have atleast one mistake in each row. Greedy means next algorithm: for every element of y we will look, will it be better to choose it like 0 or 1. To find better choise, we will count number of different bits in x and current(lets it be j) column. If number of different if lower then count of same cells we will set yj = 0, otherwise yj = 1.425C - Sereja and Two SequencesIn thgis problem we will use dynamic programming: dpi, j — minimal pozition of deleted element in second array, such that we have made first operation j times and have deleted not more then i elements from first array. Lets decided how to calculate transfers. Standing in pozition dpi, j we can change nothing and go to pozition dpi + 1, j, by other words make transfer dpi + 1, j:  = min(dpi + 1, j, dpi, j). What happens when we make first operation with fixed prefix(by i-th element) in first array? We should find element in second array with number greater dpi, j and value equal to ai, lets its pozition is t, so we need to make transfer dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). How to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. 425D - Sereja and SquaresLets line x = k contain not more then points. Then for each pair of points on this line (lets it be (k, y1) and (k, y2)) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points (k - |y2 - y1|, y1) and (k - |y2 - y1|, y2), or pair (k + |y2 - y1|, y1) and (k + |y2 - y1|, y2). Lets delete all watched points, and reverse points about line x = y. Then each line x = k will contain not more then points. Will solve problem in the same way. Now we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number k. Lets mark in some array u for all points with x-coordinate equal to k uy = k. Now to check is our pair with y-coordinates (y1, y2) on line we can simply check following condition: uy1 = uy2 = k.425E - Sereja and SetsFirst, lets look at F(S). First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don't intersected with last taken to the optimal set, we get our current to the set.Our solution will be based on this greedy. Solution of the problem is next dynamic:1). number of position of second coordinte of interval2). number of intervals in good set3). second coordinate of last taken interval to the optimal set How should we make transfers? Lets note that when we know dpi, count, last we can change last by i, or not change at all. Lets look what happens in every case. In first case last is changed by i, so we should take to optimal set atleast one of the inervals: [last + 1, i], [last + 2, i], ..., [i, i], number of such intervals i - last, number of ways to get at least one of them is 2i - last - 1. All other intervals: [1, i], [2, i], ..., [last, i] we could get as we wish, so we have 2last ways. So total number of transfers from dpi, count, last to dpi + 1, count + 1, i is (2i - last - 1)·(2last). If we count number of transfers from dpi, count, last to dpi + 1, count, last, we can simply use number 2last(as described early). Also we shouldn't forget about trivial case dpi, 0, 0. So now we have quite easy solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 425\\s*A"
          },
          "content_length": 5266
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -1000, 1000);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"positive\") {\n        // All positive integers between 1 and 1000\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else if (type == \"negative\") {\n        // All negative integers between -1000 and -1\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, -1);\n    } else if (type == \"mixed\") {\n        // Elements are both positive and negative\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i] = rnd.next(1, 1000);\n            } else {\n                a[i] = rnd.next(-1000, -1);\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Elements alternate between positive and negative\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 1000);\n            } else {\n                a[i] = rnd.next(-1000, -1);\n            }\n        }\n    } else if (type == \"sorted\") {\n        // Elements sorted in increasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n        sort(a.begin(), a.end());\n    } else if (type == \"reversed\") {\n        // Elements sorted in decreasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n        sort(a.begin(), a.end(), greater<int>());\n    } else if (type == \"constant\") {\n        // All elements are the same integer\n        int val = rnd.next(-1000, 1000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"extremes\") {\n        // Elements are at the extremes -1000 or 1000\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1) ? -1000 : 1000;\n    } else {\n        // Random elements between -1000 and 1000\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"positive\") {\n        // All positive integers between 1 and 1000\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else if (type == \"negative\") {\n        // All negative integers between -1000 and -1\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, -1);\n    } else if (type == \"mixed\") {\n        // Elements are both positive and negative\n        for(int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1)) {\n                a[i] = rnd.next(1, 1000);\n            } else {\n                a[i] = rnd.next(-1000, -1);\n            }\n        }\n    } else if (type == \"alternating\") {\n        // Elements alternate between positive and negative\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = rnd.next(1, 1000);\n            } else {\n                a[i] = rnd.next(-1000, -1);\n            }\n        }\n    } else if (type == \"sorted\") {\n        // Elements sorted in increasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n        sort(a.begin(), a.end());\n    } else if (type == \"reversed\") {\n        // Elements sorted in decreasing order\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n        sort(a.begin(), a.end(), greater<int>());\n    } else if (type == \"constant\") {\n        // All elements are the same integer\n        int val = rnd.next(-1000, 1000);\n        for(int i = 0; i < n; ++i)\n            a[i] = val;\n    } else if (type == \"extremes\") {\n        // Elements are at the extremes -1000 or 1000\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 1) ? -1000 : 1000;\n    } else {\n        // Random elements between -1000 and 1000\n        for(int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -k 1 -type positive\n./gen -n 1 -k 1 -type negative\n./gen -n 2 -k 1 -type mixed\n./gen -n 2 -k 1 -type alternating\n\n# Medium n\n./gen -n 10 -k 5 -type positive\n./gen -n 10 -k 5 -type negative\n./gen -n 10 -k 5 -type mixed\n./gen -n 10 -k 5 -type sorted\n./gen -n 10 -k 5 -type reversed\n./gen -n 10 -k 5 -type constant\n./gen -n 10 -k 5 -type extremes\n./gen -n 10 -k 5 -type random\n\n# Larger n\n./gen -n 50 -k 10 -type positive\n./gen -n 50 -k 10 -type negative\n./gen -n 50 -k 10 -type mixed\n./gen -n 50 -k 10 -type alternating\n./gen -n 50 -k 10 -type sorted\n./gen -n 50 -k 10 -type reversed\n./gen -n 50 -k 10 -type constant\n./gen -n 50 -k 10 -type extremes\n./gen -n 50 -k 10 -type random\n\n# Near maximum n\n./gen -n 200 -k 10 -type positive\n./gen -n 200 -k 10 -type negative\n./gen -n 200 -k 10 -type mixed\n./gen -n 200 -k 10 -type alternating\n./gen -n 200 -k 10 -type sorted\n./gen -n 200 -k 10 -type reversed\n./gen -n 200 -k 10 -type constant\n./gen -n 200 -k 10 -type extremes\n./gen -n 200 -k 10 -type random\n\n# Edge cases for k\n./gen -n 200 -k 1 -type random\n./gen -n 200 -k 1 -type extremes\n\n# Edge cases for n\n./gen -n 199 -k 10 -type mixed\n./gen -n 1 -k 10 -type random\n\n# Random types with random k\n./gen -n 100 -k 7 -type random\n./gen -n 150 -k 3 -type mixed\n./gen -n 100 -k 5 -type constant\n./gen -n 100 -k 2 -type extremes\n\n# Special cases\n./gen -n 50 -k 1 -type random    # Minimum k\n./gen -n 200 -k 10 -type constant # All elements same\n./gen -n 200 -k 10 -type extremes # Only -1000 and 1000\n./gen -n 200 -k 10 -type alternating # Positive and negative alternating\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:25:58.060090",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "425/B",
      "title": "B. Сережа и таблица",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целые числа n, m и k (1 ≤ n, m ≤ 100; 1 ≤ k ≤ 10). Следующие n строк описывают таблицу a: i-я из них содержит m целых чисел ai1, ai2, ..., aim (0 ≤ ai, j ≤ 1) — элементы i-й строки таблицы.",
      "output_spec": "Выходные данныеВыведите -1, если сделать задуманное невозможно. В противном случае выведите минимальное количество ячеек, в которых нужно поменять значение на противоположное, чтобы таблица удовлетворяла описанному свойству.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 5 21 1 1 1 11 1 1 1 11 1 0 1 11 1 1 1 11 1 1 1 1Выходные данныеСкопировать1Входные данныеСкопировать3 4 11 0 0 00 1 1 11 1 1 0Выходные данныеСкопировать-1Входные данныеСкопировать3 4 11 0 0 10 1 1 01 0 0 1Выходные данныеСкопировать0",
      "description": "B. Сережа и таблица\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целые числа n, m и k (1 ≤ n, m ≤ 100; 1 ≤ k ≤ 10). Следующие n строк описывают таблицу a: i-я из них содержит m целых чисел ai1, ai2, ..., aim (0 ≤ ai, j ≤ 1) — элементы i-й строки таблицы.\n\nВходные данные\n\nВыходные данныеВыведите -1, если сделать задуманное невозможно. В противном случае выведите минимальное количество ячеек, в которых нужно поменять значение на противоположное, чтобы таблица удовлетворяла описанному свойству.\n\nВыходные данные\n\nВходные данныеСкопировать5 5 21 1 1 1 11 1 1 1 11 1 0 1 11 1 1 1 11 1 1 1 1Выходные данныеСкопировать1Входные данныеСкопировать3 4 11 0 0 00 1 1 11 1 1 0Выходные данныеСкопировать-1Входные данныеСкопировать3 4 11 0 0 10 1 1 01 0 0 1Выходные данныеСкопировать0\n\nВходные данныеСкопировать5 5 21 1 1 1 11 1 1 1 11 1 0 1 11 1 1 1 11 1 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4 11 0 0 00 1 1 11 1 1 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4 11 0 0 10 1 1 01 0 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Сережа и кружкиПосчитаем сумму всех элементов Sum и значение максимального элемента M. Если Sum - M ≤ S то ответ — да, иначе — нет.426B - Сережа и разворотыРешим задачу с обратной стороны. Будем пытаться свернуть нашу матрицу как можно больше число раз. Свернуть означает операцию, обратную к описанной в условии. Для проверки, можно ли свернуть матрицу нужно, что бы выполнялись следующие условия:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Сережа и обменыПереберем интервал, на котором будет находится максимальная сумма. Для улучшения суммы, мы можем поменять не более K минимальных элемента из интервала на не более K максимальных элементов, не принадлежащих отрезку. Так как n не большое мы можем делать это любым образом, например отсортировать все элементы на интервале по возрастанию и вне интервала по убыванию, а дальше будем менять максимальный элемент из вне интервала на минимальный в интервале по тех пор, пока не поменяем k элементов или не останется не замененных элементов в отрезке или не останется не замененных элементов вне отрезка или операция обмена вообще не будет оптимальной. Сложность авторского решения O(n3·log(n)). Есть ли у Вас идеи о ток, как решать эту задачу за время O(N) или O(N·log(N)) ? 425B - Сережа и таблицаЗаметим, что если у нас есть массив x[1..n], 0 ≤ xi ≤ 1 и y[1..m], 0 ≤ yi ≤ 1, то матрица описанная в условии имеет следующий вид ai, j = xi xor yj.Если n ≤ k, то мы можем перебрать массив x и с помощью жадного алгоритма найти наилучший y. Иначе у нас найдется хотя бы одно i, что мы не должны менять ничего в строке номер i. Таким образом мы можем просто перебрать строку и выбрав ее за x жадно посчитать y. Из всех строк выберем самую оптимальную. Такая строка найдется, потому что ошибок меньше, чем количество столбцов в которых они могут быть. Под жадным алгоритмом понимается следующий: будем для каждого элемента из y смотреть: лучше ли будет ответ, если определенный бит будет равен 0 или 1. Что бы проще проверять, что оптимальнее можно просто взять текущую строку(i) и посмотреть: сколько бит в ней совпадают с x, а сколько нет. Если совпадающих больше, то yi = 0, иначе yi = 1.425C - Сережа и две последовательностиДля этой задачи будем использовать динамическое программирование: dpi, j — минимальный номер позиции удаленного элемента во втором массиве, что мы провели первую операцию j раз и удалили из первого массива не более i элементов. Разберемся теперь как делать переходы. Находясь в состоянии dpi, j мы можем оставить все как есть и перейти в состояние dpi + 1, j, иными словами сделать dpi + 1, j:  = min(dpi + 1, j, dpi, j). Что происходит, когда мы делаем первую операцию, при фиксированном префиксе по элемент номер i? Нам нужно найти элемент второго массива с номером больше dpi, j и равный ai, пусть это будет элемент номер t, тогда нужно сделать переход dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). Как быстро искать нужный элемент: просто сделаем вектор вхождений во второй массив для каждого числа и по нему будем запускать бинарный поиск. 425D - Сережа и квадратыПускай прямая x = k содержит не более точек. Тогда мы можем просто для каждой пары точек на ней (пускай они будут (k, y1) и (k, y2)) проверить: есть ли квадрат, который содержит их как вершины. То есть на нужно проверить: есть ли в наших входных данных пара точек (k - |y2 - y1|, y1) и (k - |y2 - y1|, y2), или пара (k + |y2 - y1|, y1) и (k + |y2 - y1|, y2). Удалим все просмотренные точки и отразим оставшиеся относительно прямой x = y. Мы получили ситуацию, что каждая прямая x = k содержит не более точек. Решим задачу так же как и в первый раз. Теперь нужно научится проверять: есть ли пара точек на некоторой прямой. Запишем все эти пары в вектора для тех прямых, где мы хотим проверить. Допустим, мы проверяем все пары для прямой номер k. Пометим в некотором массиве u для всех точек с абсциссой k uy = k. Теперь пройдем по всем интересующим нас парам (y1, y2). Пара нам подходит, только если uy1 = uy2 = k.425E - Сережа и множестваСначала посмотрим на то, как мы считаем величину F(S). Сперва мы сортируем все интервалы по правому концу, а затем при обходе их в отсортированном порядке смотрим: если текущий интервал не пересекается с последним взятым в множество, то просто возьмем его. Решение нашей задачи будет использовать эту жадность. Решение задачи, это динамика с параметрами:1). номер позиции, в которой будут заканчиваться поставленные интервалы.2). количество поставленных интервалов3). правая позиция последнего поставленного интервала Как делать переходы: заметим, что считая dpi, count, last мы можем изменить last только на i, либо вообще не изменять. Давайте посмотрим, что произойдет в обеих случаях. В первом случае last меняется на i, тогда мы должны поставить хотя бы один из интервалов [last + 1, i], [last + 2, i], ..., [i, i], таких интервалов ровно i - last. Что бы узнать количество способов поставить их как нам нужно, можно использовать метод включений-исключений, но на самом деле можно просто взять число 2i - last - 1. Все остальные интервалы: [1, i], [2, i], ..., [last, i] мы можем брать как хотим, таким образом имеем 2last способов. Перемножим количества и получим количество переходов из dpi, count, last в dpi + 1, count + 1, i. Если же мы считаем количество переходов из dpi, count, last в dpi + 1, count, last, то просто будем брать число 2last. Так же стоит не забыть про случай dpi, 0, 0. Из которого тоже нужно делать переходы, которые по своей сути тривиальны. Таким образом мы получили очень простое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 425\\s*B"
          },
          "content_length": 5539
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate a random grid of zeros and ones\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                grid[x][y] = rnd.next(0,1);\n            }\n        }\n    } else if (type == \"already_good\") {\n        // Generate a grid that already meets the requirement\n        int num_row_splits = rnd.next(1, min(n, 10));\n        int num_col_splits = rnd.next(1, min(m, 10));\n\n        vector<int> row_splits = {0, n};\n        vector<int> col_splits = {0, m};\n\n        // Randomly select split positions along rows\n        set<int> row_positions;\n        while (row_positions.size() < num_row_splits - 1) {\n            row_positions.insert(rnd.next(1, n-1));\n        }\n        for (int pos : row_positions) {\n            row_splits.push_back(pos);\n        }\n\n        // Randomly select split positions along columns\n        set<int> col_positions;\n        while (col_positions.size() < num_col_splits -1) {\n            col_positions.insert(rnd.next(1, m-1));\n        }\n        for (int pos : col_positions) {\n            col_splits.push_back(pos);\n        }\n\n        sort(row_splits.begin(), row_splits.end());\n        sort(col_splits.begin(), col_splits.end());\n\n        // For each rectangle formed by the splits, assign a random value 0 or 1\n        for (int i = 0; i < (int)row_splits.size() - 1; ++i) {\n            for (int j = 0; j < (int)col_splits.size() -1; ++j) {\n                int val = rnd.next(0, 1);\n                int x_start = row_splits[i];\n                int x_end = row_splits[i+1];\n                int y_start = col_splits[j];\n                int y_end = col_splits[j+1];\n\n                for (int x = x_start; x < x_end; ++x) {\n                    for (int y = y_start; y < y_end; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n\n    } else if (type == \"requires_exact_k_changes\") {\n        // Generate a grid that requires exactly k changes to meet the requirement\n        // Start with an already_good grid\n        int num_row_splits = rnd.next(1, min(n, 10));\n        int num_col_splits = rnd.next(1, min(m, 10));\n\n        vector<int> row_splits = {0, n};\n        vector<int> col_splits = {0, m};\n\n        // Randomly select split positions along rows\n        set<int> row_positions;\n        while (row_positions.size() < num_row_splits - 1) {\n            row_positions.insert(rnd.next(1, n-1));\n        }\n        for (int pos : row_positions) {\n            row_splits.push_back(pos);\n        }\n\n        // Randomly select split positions along columns\n        set<int> col_positions;\n        while (col_positions.size() < num_col_splits -1) {\n            col_positions.insert(rnd.next(1, m-1));\n        }\n        for (int pos : col_positions) {\n            col_splits.push_back(pos);\n        }\n\n        sort(row_splits.begin(), row_splits.end());\n        sort(col_splits.begin(), col_splits.end());\n\n        // For each rectangle formed by the splits, assign a random value 0 or 1\n        for (int i = 0; i < (int)row_splits.size() - 1; ++i) {\n            for (int j = 0; j < (int)col_splits.size() -1; ++j) {\n                int val = rnd.next(0, 1);\n                int x_start = row_splits[i];\n                int x_end = row_splits[i+1];\n                int y_start = col_splits[j];\n                int y_end = col_splits[j+1];\n\n                for (int x = x_start; x < x_end; ++x) {\n                    for (int y = y_start; y < y_end; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n        // Now, change exactly k cells to their opposite value\n        // Select k random cells and flip their values\n        vector<pair<int,int>> cells;\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                cells.push_back({x,y});\n            }\n        }\n        shuffle(cells.begin(), cells.end());\n        for (int idx = 0; idx < k; ++idx) {\n            int x = cells[idx].first;\n            int y = cells[idx].second;\n            grid[x][y] ^= 1; // Flip the value\n        }\n    } else if (type == \"cannot_be_fixed_within_k\") {\n        // Generate a grid that cannot be fixed within k changes\n        // For example, a checkerboard pattern\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                grid[x][y] = (x + y) % 2;\n            }\n        }\n    } else {\n        // Default: generate a random grid\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                grid[x][y] = rnd.next(0,1);\n            }\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output the grid\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            printf(\"%d\", grid[x][y]);\n            if (y + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate a random grid of zeros and ones\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                grid[x][y] = rnd.next(0,1);\n            }\n        }\n    } else if (type == \"already_good\") {\n        // Generate a grid that already meets the requirement\n        int num_row_splits = rnd.next(1, min(n, 10));\n        int num_col_splits = rnd.next(1, min(m, 10));\n\n        vector<int> row_splits = {0, n};\n        vector<int> col_splits = {0, m};\n\n        // Randomly select split positions along rows\n        set<int> row_positions;\n        while (row_positions.size() < num_row_splits - 1) {\n            row_positions.insert(rnd.next(1, n-1));\n        }\n        for (int pos : row_positions) {\n            row_splits.push_back(pos);\n        }\n\n        // Randomly select split positions along columns\n        set<int> col_positions;\n        while (col_positions.size() < num_col_splits -1) {\n            col_positions.insert(rnd.next(1, m-1));\n        }\n        for (int pos : col_positions) {\n            col_splits.push_back(pos);\n        }\n\n        sort(row_splits.begin(), row_splits.end());\n        sort(col_splits.begin(), col_splits.end());\n\n        // For each rectangle formed by the splits, assign a random value 0 or 1\n        for (int i = 0; i < (int)row_splits.size() - 1; ++i) {\n            for (int j = 0; j < (int)col_splits.size() -1; ++j) {\n                int val = rnd.next(0, 1);\n                int x_start = row_splits[i];\n                int x_end = row_splits[i+1];\n                int y_start = col_splits[j];\n                int y_end = col_splits[j+1];\n\n                for (int x = x_start; x < x_end; ++x) {\n                    for (int y = y_start; y < y_end; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n\n    } else if (type == \"requires_exact_k_changes\") {\n        // Generate a grid that requires exactly k changes to meet the requirement\n        // Start with an already_good grid\n        int num_row_splits = rnd.next(1, min(n, 10));\n        int num_col_splits = rnd.next(1, min(m, 10));\n\n        vector<int> row_splits = {0, n};\n        vector<int> col_splits = {0, m};\n\n        // Randomly select split positions along rows\n        set<int> row_positions;\n        while (row_positions.size() < num_row_splits - 1) {\n            row_positions.insert(rnd.next(1, n-1));\n        }\n        for (int pos : row_positions) {\n            row_splits.push_back(pos);\n        }\n\n        // Randomly select split positions along columns\n        set<int> col_positions;\n        while (col_positions.size() < num_col_splits -1) {\n            col_positions.insert(rnd.next(1, m-1));\n        }\n        for (int pos : col_positions) {\n            col_splits.push_back(pos);\n        }\n\n        sort(row_splits.begin(), row_splits.end());\n        sort(col_splits.begin(), col_splits.end());\n\n        // For each rectangle formed by the splits, assign a random value 0 or 1\n        for (int i = 0; i < (int)row_splits.size() - 1; ++i) {\n            for (int j = 0; j < (int)col_splits.size() -1; ++j) {\n                int val = rnd.next(0, 1);\n                int x_start = row_splits[i];\n                int x_end = row_splits[i+1];\n                int y_start = col_splits[j];\n                int y_end = col_splits[j+1];\n\n                for (int x = x_start; x < x_end; ++x) {\n                    for (int y = y_start; y < y_end; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n        // Now, change exactly k cells to their opposite value\n        // Select k random cells and flip their values\n        vector<pair<int,int>> cells;\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                cells.push_back({x,y});\n            }\n        }\n        shuffle(cells.begin(), cells.end());\n        for (int idx = 0; idx < k; ++idx) {\n            int x = cells[idx].first;\n            int y = cells[idx].second;\n            grid[x][y] ^= 1; // Flip the value\n        }\n    } else if (type == \"cannot_be_fixed_within_k\") {\n        // Generate a grid that cannot be fixed within k changes\n        // For example, a checkerboard pattern\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                grid[x][y] = (x + y) % 2;\n            }\n        }\n    } else {\n        // Default: generate a random grid\n        for (int x = 0; x < n; ++x) {\n            for (int y = 0; y < m; ++y) {\n                grid[x][y] = rnd.next(0,1);\n            }\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n    // Output the grid\n    for (int x = 0; x < n; ++x) {\n        for (int y = 0; y < m; ++y) {\n            printf(\"%d\", grid[x][y]);\n            if (y + 1 < m)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -k 2 -type random\n./gen -n 5 -m 5 -k 2 -type already_good\n./gen -n 5 -m 5 -k 2 -type requires_exact_k_changes\n./gen -n 5 -m 5 -k 2 -type cannot_be_fixed_within_k\n\n./gen -n 10 -m 10 -k 5 -type random\n./gen -n 10 -m 10 -k 5 -type already_good\n./gen -n 10 -m 10 -k 5 -type requires_exact_k_changes\n./gen -n 10 -m 10 -k 5 -type cannot_be_fixed_within_k\n\n./gen -n 30 -m 30 -k 10 -type random\n./gen -n 30 -m 30 -k 10 -type already_good\n./gen -n 30 -m 30 -k 10 -type requires_exact_k_changes\n./gen -n 30 -m 30 -k 10 -type cannot_be_fixed_within_k\n\n./gen -n 50 -m 50 -k 5 -type random\n./gen -n 50 -m 50 -k 5 -type cannot_be_fixed_within_k\n\n./gen -n 100 -m 100 -k 10 -type random\n./gen -n 100 -m 100 -k 10 -type already_good\n./gen -n 100 -m 100 -k 10 -type requires_exact_k_changes\n./gen -n 100 -m 100 -k 10 -type cannot_be_fixed_within_k\n\n./gen -n 100 -m 1 -k 1 -type random\n./gen -n 100 -m 1 -k 1 -type already_good\n\n./gen -n 1 -m 100 -k 1 -type random\n./gen -n 1 -m 100 -k 1 -type already_good\n\n./gen -n 1 -m 1 -k 1 -type random\n\n./gen -n 10 -m 10 -k 1 -type random\n./gen -n 10 -m 10 -k 1 -type cannot_be_fixed_within_k\n./gen -n 10 -m 10 -k 10 -type requires_exact_k_changes\n\n./gen -n 20 -m 30 -k 1 -type random\n./gen -n 20 -m 30 -k 1 -type cannot_be_fixed_within_k\n./gen -n 20 -m 30 -k 1 -type already_good\n\n./gen -n 100 -m 100 -k 1 -type random\n./gen -n 100 -m 100 -k 1 -type cannot_be_fixed_within_k\n\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 2 -m 2 -k 1 -type cannot_be_fixed_within_k\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:00.395864",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "425/C",
      "title": "C. Сережа и две последовательности",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест4 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целые числа n, m, s, e (1 ≤ n, m ≤ 105; 1 ≤ s ≤ 3·105; 103 ≤ e ≤ 104). Вторая строка содержит n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 105). Третья строка содержит m целых чисел b1, b2, ..., bm (1 ≤ bi ≤ 105).",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальную сумму в долларах, которую Сережа может получить.",
      "sample_tests": "ПримерыВходные данныеСкопировать5 5 100000 10001 2 3 4 53 2 4 5 1Выходные данныеСкопировать3Входные данныеСкопировать3 4 3006 10001 2 31 2 4 3Выходные данныеСкопировать2",
      "description": "C. Сережа и две последовательности\n\nограничение по времени на тест4 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целые числа n, m, s, e (1 ≤ n, m ≤ 105; 1 ≤ s ≤ 3·105; 103 ≤ e ≤ 104). Вторая строка содержит n целых чисел a1, a2, ..., an (1 ≤ ai ≤ 105). Третья строка содержит m целых чисел b1, b2, ..., bm (1 ≤ bi ≤ 105).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальную сумму в долларах, которую Сережа может получить.\n\nВыходные данные\n\nВходные данныеСкопировать5 5 100000 10001 2 3 4 53 2 4 5 1Выходные данныеСкопировать3Входные данныеСкопировать3 4 3006 10001 2 31 2 4 3Выходные данныеСкопировать2\n\nВходные данныеСкопировать5 5 100000 10001 2 3 4 53 2 4 5 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4 3006 10001 2 31 2 4 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Сережа и кружкиПосчитаем сумму всех элементов Sum и значение максимального элемента M. Если Sum - M ≤ S то ответ — да, иначе — нет.426B - Сережа и разворотыРешим задачу с обратной стороны. Будем пытаться свернуть нашу матрицу как можно больше число раз. Свернуть означает операцию, обратную к описанной в условии. Для проверки, можно ли свернуть матрицу нужно, что бы выполнялись следующие условия:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Сережа и обменыПереберем интервал, на котором будет находится максимальная сумма. Для улучшения суммы, мы можем поменять не более K минимальных элемента из интервала на не более K максимальных элементов, не принадлежащих отрезку. Так как n не большое мы можем делать это любым образом, например отсортировать все элементы на интервале по возрастанию и вне интервала по убыванию, а дальше будем менять максимальный элемент из вне интервала на минимальный в интервале по тех пор, пока не поменяем k элементов или не останется не замененных элементов в отрезке или не останется не замененных элементов вне отрезка или операция обмена вообще не будет оптимальной. Сложность авторского решения O(n3·log(n)). Есть ли у Вас идеи о ток, как решать эту задачу за время O(N) или O(N·log(N)) ? 425B - Сережа и таблицаЗаметим, что если у нас есть массив x[1..n], 0 ≤ xi ≤ 1 и y[1..m], 0 ≤ yi ≤ 1, то матрица описанная в условии имеет следующий вид ai, j = xi xor yj.Если n ≤ k, то мы можем перебрать массив x и с помощью жадного алгоритма найти наилучший y. Иначе у нас найдется хотя бы одно i, что мы не должны менять ничего в строке номер i. Таким образом мы можем просто перебрать строку и выбрав ее за x жадно посчитать y. Из всех строк выберем самую оптимальную. Такая строка найдется, потому что ошибок меньше, чем количество столбцов в которых они могут быть. Под жадным алгоритмом понимается следующий: будем для каждого элемента из y смотреть: лучше ли будет ответ, если определенный бит будет равен 0 или 1. Что бы проще проверять, что оптимальнее можно просто взять текущую строку(i) и посмотреть: сколько бит в ней совпадают с x, а сколько нет. Если совпадающих больше, то yi = 0, иначе yi = 1.425C - Сережа и две последовательностиДля этой задачи будем использовать динамическое программирование: dpi, j — минимальный номер позиции удаленного элемента во втором массиве, что мы провели первую операцию j раз и удалили из первого массива не более i элементов. Разберемся теперь как делать переходы. Находясь в состоянии dpi, j мы можем оставить все как есть и перейти в состояние dpi + 1, j, иными словами сделать dpi + 1, j:  = min(dpi + 1, j, dpi, j). Что происходит, когда мы делаем первую операцию, при фиксированном префиксе по элемент номер i? Нам нужно найти элемент второго массива с номером больше dpi, j и равный ai, пусть это будет элемент номер t, тогда нужно сделать переход dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). Как быстро искать нужный элемент: просто сделаем вектор вхождений во второй массив для каждого числа и по нему будем запускать бинарный поиск. 425D - Сережа и квадратыПускай прямая x = k содержит не более точек. Тогда мы можем просто для каждой пары точек на ней (пускай они будут (k, y1) и (k, y2)) проверить: есть ли квадрат, который содержит их как вершины. То есть на нужно проверить: есть ли в наших входных данных пара точек (k - |y2 - y1|, y1) и (k - |y2 - y1|, y2), или пара (k + |y2 - y1|, y1) и (k + |y2 - y1|, y2). Удалим все просмотренные точки и отразим оставшиеся относительно прямой x = y. Мы получили ситуацию, что каждая прямая x = k содержит не более точек. Решим задачу так же как и в первый раз. Теперь нужно научится проверять: есть ли пара точек на некоторой прямой. Запишем все эти пары в вектора для тех прямых, где мы хотим проверить. Допустим, мы проверяем все пары для прямой номер k. Пометим в некотором массиве u для всех точек с абсциссой k uy = k. Теперь пройдем по всем интересующим нас парам (y1, y2). Пара нам подходит, только если uy1 = uy2 = k.425E - Сережа и множестваСначала посмотрим на то, как мы считаем величину F(S). Сперва мы сортируем все интервалы по правому концу, а затем при обходе их в отсортированном порядке смотрим: если текущий интервал не пересекается с последним взятым в множество, то просто возьмем его. Решение нашей задачи будет использовать эту жадность. Решение задачи, это динамика с параметрами:1). номер позиции, в которой будут заканчиваться поставленные интервалы.2). количество поставленных интервалов3). правая позиция последнего поставленного интервала Как делать переходы: заметим, что считая dpi, count, last мы можем изменить last только на i, либо вообще не изменять. Давайте посмотрим, что произойдет в обеих случаях. В первом случае last меняется на i, тогда мы должны поставить хотя бы один из интервалов [last + 1, i], [last + 2, i], ..., [i, i], таких интервалов ровно i - last. Что бы узнать количество способов поставить их как нам нужно, можно использовать метод включений-исключений, но на самом деле можно просто взять число 2i - last - 1. Все остальные интервалы: [1, i], [2, i], ..., [last, i] мы можем брать как хотим, таким образом имеем 2last способов. Перемножим количества и получим количество переходов из dpi, count, last в dpi + 1, count + 1, i. Если же мы считаем количество переходов из dpi, count, last в dpi + 1, count, last, то просто будем брать число 2last. Так же стоит не забыть про случай dpi, 0, 0. Из которого тоже нужно делать переходы, которые по своей сути тривиальны. Таким образом мы получили очень простое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 425\\s*C"
          },
          "content_length": 5539
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readSpace();\n    int s = inf.readInt(1, 300000);\n    inf.readSpace();\n    int e = inf.readInt(1000, 10000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readSpace();\n    int s = inf.readInt(1, 300000);\n    inf.readSpace();\n    int e = inf.readInt(1000, 10000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000);\n    inf.readSpace();\n    int m = inf.readInt(1, 100000);\n    inf.readSpace();\n    int s = inf.readInt(1, 300000);\n    inf.readSpace();\n    int e = inf.readInt(1000, 10000);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(m, 1, 100000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\");\n    int e_cost = opt<int>(\"e\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(m);\n\n    if (type == \"random\") {\n        // Fill a and b with random integers in [1, 100000]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 100000);\n\n    } else if (type == \"same\") {\n        int val = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        for (int i = 0; i < m; ++i)\n            b[i] = val;\n\n    } else if (type == \"maxaction\") {\n        int k = min(n, m);\n        int max_actions = min(k, s / e_cost);\n        for (int i = 0; i < max_actions; ++i) {\n            int val = rnd.next(1, 100000);\n            a[i] = val;\n            b[i] = val;\n        }\n        for (int i = max_actions; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n        for (int i = max_actions; i < m; ++i)\n            b[i] = rnd.next(1, 100000);\n\n    } else if (type == \"noaction\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        for (int i = 0; i < m; ++i)\n            b[i] = n + i + 1;\n\n    } else if (type == \"edge\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 100000);\n\n    } else if (type == \"maxvalues\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100000;\n        for (int i = 0; i < m; ++i)\n            b[i] = 100000;\n    }\n\n    // Output n, m, s, e_cost\n    printf(\"%d %d %d %d\\n\", n, m, s, e_cost);\n\n    // Output sequence a\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Output sequence b\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int s = opt<int>(\"s\");\n    int e_cost = opt<int>(\"e\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(m);\n\n    if (type == \"random\") {\n        // Fill a and b with random integers in [1, 100000]\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 100000);\n\n    } else if (type == \"same\") {\n        int val = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i)\n            a[i] = val;\n        for (int i = 0; i < m; ++i)\n            b[i] = val;\n\n    } else if (type == \"maxaction\") {\n        int k = min(n, m);\n        int max_actions = min(k, s / e_cost);\n        for (int i = 0; i < max_actions; ++i) {\n            int val = rnd.next(1, 100000);\n            a[i] = val;\n            b[i] = val;\n        }\n        for (int i = max_actions; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n        for (int i = max_actions; i < m; ++i)\n            b[i] = rnd.next(1, 100000);\n\n    } else if (type == \"noaction\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        for (int i = 0; i < m; ++i)\n            b[i] = n + i + 1;\n\n    } else if (type == \"edge\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 100000);\n        for (int i = 0; i < m; ++i)\n            b[i] = rnd.next(1, 100000);\n\n    } else if (type == \"maxvalues\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = 100000;\n        for (int i = 0; i < m; ++i)\n            b[i] = 100000;\n    }\n\n    // Output n, m, s, e_cost\n    printf(\"%d %d %d %d\\n\", n, m, s, e_cost);\n\n    // Output sequence a\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Output sequence b\n    for (int i = 0; i < m; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", b[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -s 1 -e 1000 -type random\n./gen -n 5 -m 5 -s 10000 -e 5000 -type random\n./gen -n 10 -m 10 -s 100000 -e 10000 -type random\n./gen -n 1000 -m 1000 -s 300000 -e 10000 -type random\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type random\n\n./gen -n 1 -m 1 -s 1 -e 1000 -type same\n./gen -n 1000 -m 1000 -s 100000 -e 10000 -type same\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type same\n\n./gen -n 1000 -m 1000 -s 100000 -e 10000 -type maxaction\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type maxaction\n\n./gen -n 10 -m 10 -s 1000 -e 1000 -type noaction\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type noaction\n\n./gen -n 100000 -m 100000 -s 1 -e 10000 -type edge\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type edge\n\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type maxvalues\n\n./gen -n 2 -m 2 -s 5000 -e 1000 -type random\n./gen -n 3 -m 3 -s 3006 -e 1000 -type same\n\n./gen -n 5 -m 5 -s 50000 -e 1000 -type maxaction\n./gen -n 5 -m 5 -s 50000 -e 1000 -type noaction\n\n./gen -n 1 -m 100000 -s 300000 -e 1000 -type random\n./gen -n 100000 -m 1 -s 300000 -e 10000 -type random\n\n./gen -n 100000 -m 100000 -s 1 -e 10000 -type maxaction\n./gen -n 100000 -m 100000 -s 300000 -e 1000 -type maxaction\n\n./gen -n 50000 -m 50000 -s 150000 -e 10000 -type same\n./gen -n 50000 -m 50000 -s 150000 -e 10000 -type noaction\n\n./gen -n 99999 -m 99999 -s 299997 -e 9999 -type maxvalues\n./gen -n 1 -m 100000 -s 1 -e 10000 -type noaction\n\n./gen -n 100000 -m 1 -s 1 -e 10000 -type noaction\n\n./gen -n 100000 -m 100000 -s 3 -e 1000 -type edge\n./gen -n 100000 -m 100000 -s 3 -e 300000 -type edge\n\n./gen -n 1 -m 1 -s 3 -e 1000 -type maxvalues\n\n./gen -n 99999 -m 100000 -s 299997 -e 10000 -type random\n\n./gen -n 88888 -m 99999 -s 300000 -e 10000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:02.180829",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "425/D",
      "title": "D. Сережа и квадраты",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105). В каждой из n следующих строк записана пара целых чисел xi, yi (0 ≤ xi, yi ≤ 105) — координаты i-й точки. Гарантируется, что все заданные точки различны.",
      "output_spec": "Выходные данныеВ единственную строку выведите искомое количество квадратов.",
      "sample_tests": "ПримерыВходные данныеСкопировать50 00 22 02 21 1Выходные данныеСкопировать1Входные данныеСкопировать90 01 12 20 11 00 22 01 22 1Выходные данныеСкопировать5",
      "description": "D. Сережа и квадраты\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целое число n (1 ≤ n ≤ 105). В каждой из n следующих строк записана пара целых чисел xi, yi (0 ≤ xi, yi ≤ 105) — координаты i-й точки. Гарантируется, что все заданные точки различны.\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите искомое количество квадратов.\n\nВыходные данные\n\nВходные данныеСкопировать50 00 22 02 21 1Выходные данныеСкопировать1Входные данныеСкопировать90 01 12 20 11 00 22 01 22 1Выходные данныеСкопировать5\n\nВходные данныеСкопировать50 00 22 02 21 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать90 01 12 20 11 00 22 01 22 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Сережа и кружкиПосчитаем сумму всех элементов Sum и значение максимального элемента M. Если Sum - M ≤ S то ответ — да, иначе — нет.426B - Сережа и разворотыРешим задачу с обратной стороны. Будем пытаться свернуть нашу матрицу как можно больше число раз. Свернуть означает операцию, обратную к описанной в условии. Для проверки, можно ли свернуть матрицу нужно, что бы выполнялись следующие условия:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Сережа и обменыПереберем интервал, на котором будет находится максимальная сумма. Для улучшения суммы, мы можем поменять не более K минимальных элемента из интервала на не более K максимальных элементов, не принадлежащих отрезку. Так как n не большое мы можем делать это любым образом, например отсортировать все элементы на интервале по возрастанию и вне интервала по убыванию, а дальше будем менять максимальный элемент из вне интервала на минимальный в интервале по тех пор, пока не поменяем k элементов или не останется не замененных элементов в отрезке или не останется не замененных элементов вне отрезка или операция обмена вообще не будет оптимальной. Сложность авторского решения O(n3·log(n)). Есть ли у Вас идеи о ток, как решать эту задачу за время O(N) или O(N·log(N)) ? 425B - Сережа и таблицаЗаметим, что если у нас есть массив x[1..n], 0 ≤ xi ≤ 1 и y[1..m], 0 ≤ yi ≤ 1, то матрица описанная в условии имеет следующий вид ai, j = xi xor yj.Если n ≤ k, то мы можем перебрать массив x и с помощью жадного алгоритма найти наилучший y. Иначе у нас найдется хотя бы одно i, что мы не должны менять ничего в строке номер i. Таким образом мы можем просто перебрать строку и выбрав ее за x жадно посчитать y. Из всех строк выберем самую оптимальную. Такая строка найдется, потому что ошибок меньше, чем количество столбцов в которых они могут быть. Под жадным алгоритмом понимается следующий: будем для каждого элемента из y смотреть: лучше ли будет ответ, если определенный бит будет равен 0 или 1. Что бы проще проверять, что оптимальнее можно просто взять текущую строку(i) и посмотреть: сколько бит в ней совпадают с x, а сколько нет. Если совпадающих больше, то yi = 0, иначе yi = 1.425C - Сережа и две последовательностиДля этой задачи будем использовать динамическое программирование: dpi, j — минимальный номер позиции удаленного элемента во втором массиве, что мы провели первую операцию j раз и удалили из первого массива не более i элементов. Разберемся теперь как делать переходы. Находясь в состоянии dpi, j мы можем оставить все как есть и перейти в состояние dpi + 1, j, иными словами сделать dpi + 1, j:  = min(dpi + 1, j, dpi, j). Что происходит, когда мы делаем первую операцию, при фиксированном префиксе по элемент номер i? Нам нужно найти элемент второго массива с номером больше dpi, j и равный ai, пусть это будет элемент номер t, тогда нужно сделать переход dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). Как быстро искать нужный элемент: просто сделаем вектор вхождений во второй массив для каждого числа и по нему будем запускать бинарный поиск. 425D - Сережа и квадратыПускай прямая x = k содержит не более точек. Тогда мы можем просто для каждой пары точек на ней (пускай они будут (k, y1) и (k, y2)) проверить: есть ли квадрат, который содержит их как вершины. То есть на нужно проверить: есть ли в наших входных данных пара точек (k - |y2 - y1|, y1) и (k - |y2 - y1|, y2), или пара (k + |y2 - y1|, y1) и (k + |y2 - y1|, y2). Удалим все просмотренные точки и отразим оставшиеся относительно прямой x = y. Мы получили ситуацию, что каждая прямая x = k содержит не более точек. Решим задачу так же как и в первый раз. Теперь нужно научится проверять: есть ли пара точек на некоторой прямой. Запишем все эти пары в вектора для тех прямых, где мы хотим проверить. Допустим, мы проверяем все пары для прямой номер k. Пометим в некотором массиве u для всех точек с абсциссой k uy = k. Теперь пройдем по всем интересующим нас парам (y1, y2). Пара нам подходит, только если uy1 = uy2 = k.425E - Сережа и множестваСначала посмотрим на то, как мы считаем величину F(S). Сперва мы сортируем все интервалы по правому концу, а затем при обходе их в отсортированном порядке смотрим: если текущий интервал не пересекается с последним взятым в множество, то просто возьмем его. Решение нашей задачи будет использовать эту жадность. Решение задачи, это динамика с параметрами:1). номер позиции, в которой будут заканчиваться поставленные интервалы.2). количество поставленных интервалов3). правая позиция последнего поставленного интервала Как делать переходы: заметим, что считая dpi, count, last мы можем изменить last только на i, либо вообще не изменять. Давайте посмотрим, что произойдет в обеих случаях. В первом случае last меняется на i, тогда мы должны поставить хотя бы один из интервалов [last + 1, i], [last + 2, i], ..., [i, i], таких интервалов ровно i - last. Что бы узнать количество способов поставить их как нам нужно, можно использовать метод включений-исключений, но на самом деле можно просто взять число 2i - last - 1. Все остальные интервалы: [1, i], [2, i], ..., [last, i] мы можем брать как хотим, таким образом имеем 2last способов. Перемножим количества и получим количество переходов из dpi, count, last в dpi + 1, count + 1, i. Если же мы считаем количество переходов из dpi, count, last в dpi + 1, count, last, то просто будем брать число 2last. Так же стоит не забыть про случай dpi, 0, 0. Из которого тоже нужно делать переходы, которые по своей сути тривиальны. Таким образом мы получили очень простое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 425\\s*D"
          },
          "content_length": 5539
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> points;\n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(0, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 100000, \"yi\");\n        inf.readEoln();\n        pair<int, int> point = make_pair(xi, yi);\n        ensuref(points.find(point) == points.end(), \"Point (%d, %d) occurs multiple times\", xi, yi);\n        points.insert(point);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> points;\n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(0, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 100000, \"yi\");\n        inf.readEoln();\n        pair<int, int> point = make_pair(xi, yi);\n        ensuref(points.find(point) == points.end(), \"Point (%d, %d) occurs multiple times\", xi, yi);\n        points.insert(point);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    set<pair<int, int>> points;\n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(0, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(0, 100000, \"yi\");\n        inf.readEoln();\n        pair<int, int> point = make_pair(xi, yi);\n        ensuref(points.find(point) == points.end(), \"Point (%d, %d) occurs multiple times\", xi, yi);\n        points.insert(point);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int param = opt<int>(\"param\", -1);\n\n    if (type == \"random\") {\n        // Generate n random distinct points\n        set<pair<int,int>> points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            points.insert({x, y});\n        }\n        printf(\"%d\\n\", n);\n        for(auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"line_x\") {\n        // All points with the same x, varying y\n        int x = rnd.next(0, 100000);\n        set<int> y_values;\n        while ((int)y_values.size() < n) {\n            int y = rnd.next(0, 100000);\n            y_values.insert(y);\n        }\n        printf(\"%d\\n\", n);\n        for(auto y : y_values) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"line_y\") {\n        // All points with the same y, varying x\n        int y = rnd.next(0, 100000);\n        set<int> x_values;\n        while ((int)x_values.size() < n) {\n            int x = rnd.next(0, 100000);\n            x_values.insert(x);\n        }\n        printf(\"%d\\n\", n);\n        for(auto x : x_values) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"grid\") {\n        int k = opt<int>(\"k\", -1);\n        if (k == -1) {\n            k = ceil(sqrt(n));\n        }\n        \n        set<int> xs_set;\n        set<int> ys_set;\n        while ((int)xs_set.size() < k) {\n            int x = rnd.next(0, 100000);\n            xs_set.insert(x);\n        }\n        while ((int)ys_set.size() < k) {\n            int y = rnd.next(0, 100000);\n            ys_set.insert(y);\n        }\n        vector<int> xs(xs_set.begin(), xs_set.end());\n        vector<int> ys(ys_set.begin(), ys_set.end());\n        vector<pair<int,int>> points;\n        for(int i = 0; i < k && (int)points.size() < n; ++i) {\n            for(int j = 0; j < k && (int)points.size() < n; ++j) {\n                points.push_back({xs[i], ys[j]});\n            }\n        }\n        // Shuffle points\n        shuffle(points.begin(), points.end());\n        // Output\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", points[i].first, points[i].second);\n        }\n    } else if (type == \"no_squares\") {\n        set<pair<int,int>> points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(0, 100000);\n            int y = x + rnd.next(1, 10); // Ensure x != y, avoid forming squares\n            if (y > 100000) y -= 100000;\n            points.insert({x, y});\n        }\n        printf(\"%d\\n\", n);\n        for(auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int param = opt<int>(\"param\", -1);\n\n    if (type == \"random\") {\n        // Generate n random distinct points\n        set<pair<int,int>> points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(0, 100000);\n            int y = rnd.next(0, 100000);\n            points.insert({x, y});\n        }\n        printf(\"%d\\n\", n);\n        for(auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else if (type == \"line_x\") {\n        // All points with the same x, varying y\n        int x = rnd.next(0, 100000);\n        set<int> y_values;\n        while ((int)y_values.size() < n) {\n            int y = rnd.next(0, 100000);\n            y_values.insert(y);\n        }\n        printf(\"%d\\n\", n);\n        for(auto y : y_values) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"line_y\") {\n        // All points with the same y, varying x\n        int y = rnd.next(0, 100000);\n        set<int> x_values;\n        while ((int)x_values.size() < n) {\n            int x = rnd.next(0, 100000);\n            x_values.insert(x);\n        }\n        printf(\"%d\\n\", n);\n        for(auto x : x_values) {\n            printf(\"%d %d\\n\", x, y);\n        }\n    } else if (type == \"grid\") {\n        int k = opt<int>(\"k\", -1);\n        if (k == -1) {\n            k = ceil(sqrt(n));\n        }\n        \n        set<int> xs_set;\n        set<int> ys_set;\n        while ((int)xs_set.size() < k) {\n            int x = rnd.next(0, 100000);\n            xs_set.insert(x);\n        }\n        while ((int)ys_set.size() < k) {\n            int y = rnd.next(0, 100000);\n            ys_set.insert(y);\n        }\n        vector<int> xs(xs_set.begin(), xs_set.end());\n        vector<int> ys(ys_set.begin(), ys_set.end());\n        vector<pair<int,int>> points;\n        for(int i = 0; i < k && (int)points.size() < n; ++i) {\n            for(int j = 0; j < k && (int)points.size() < n; ++j) {\n                points.push_back({xs[i], ys[j]});\n            }\n        }\n        // Shuffle points\n        shuffle(points.begin(), points.end());\n        // Output\n        printf(\"%d\\n\", n);\n        for(int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", points[i].first, points[i].second);\n        }\n    } else if (type == \"no_squares\") {\n        set<pair<int,int>> points;\n        while ((int)points.size() < n) {\n            int x = rnd.next(0, 100000);\n            int y = x + rnd.next(1, 10); // Ensure x != y, avoid forming squares\n            if (y > 100000) y -= 100000;\n            points.insert({x, y});\n        }\n        printf(\"%d\\n\", n);\n        for(auto p : points) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 500 -type random\n./gen -n 1000 -type random\n./gen -n 5000 -type random\n./gen -n 10000 -type random\n./gen -n 50000 -type random\n./gen -n 100000 -type random\n\n./gen -n 10 -type line_x\n./gen -n 100000 -type line_x\n./gen -n 10 -type line_y\n./gen -n 100000 -type line_y\n\n./gen -n 100 -type grid -k 10\n./gen -n 10000 -type grid -k 100\n./gen -n 100000 -type grid -k 316\n\n./gen -n 16 -type grid -k 4\n./gen -n 50000 -type grid\n\n./gen -n 10 -type no_squares\n./gen -n 1000 -type no_squares\n./gen -n 100000 -type no_squares\n\n./gen -n 1000 -type random\n./gen -n 1 -type random\n./gen -n 100000 -type random\n\n./gen -n 99999 -type random\n./gen -n 2 -type line_x\n./gen -n 3 -type no_squares\n\n./gen -n 1000 -type grid\n./gen -n 50000 -type grid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:04.284831",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "425/E",
      "title": "E. Сережа и множества",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1.5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит целые числа n, k (1 ≤ n ≤ 500; 0 ≤ k ≤ 500).",
      "output_spec": "Выходные данныеВ единственную строку выведите ответ на задачу по модулю 1000000007 (109 + 7).",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1Выходные данныеСкопировать23Входные данныеСкопировать3 2Выходные данныеСкопировать32Входные данныеСкопировать2 0Выходные данныеСкопировать1Входные данныеСкопировать2 2Выходные данныеСкопировать2",
      "description": "E. Сережа и множества\n\nограничение по времени на тест1.5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит целые числа n, k (1 ≤ n ≤ 500; 0 ≤ k ≤ 500).\n\nВходные данные\n\nВыходные данныеВ единственную строку выведите ответ на задачу по модулю 1000000007 (109 + 7).\n\nВыходные данные\n\nВходные данныеСкопировать3 1Выходные данныеСкопировать23Входные данныеСкопировать3 2Выходные данныеСкопировать32Входные данныеСкопировать2 0Выходные данныеСкопировать1Входные данныеСкопировать2 2Выходные данныеСкопировать2\n\nВходные данныеСкопировать3 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать23\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #243 - Codeforces",
          "content": "Всем привет!Совсем скоро, 27 апреля в 19:30 MSK состоится Codeforces Round #243, автором которого являюсь я. Это мой одиннадцатый раунд на Codeforces и я надеюсь, что не последний.Спасибо Геральду Агапову (Gerald) и Ярославу Твердохлебу (KADR) за помощь в подготовке раунда и Марии Беловой (Delinur) за перевод условий на английский.Настоятельно рекомендую прочитать условия ВСЕХ задач.Разбалловка в первом дивизионе 500-1000-1500-2000-2000. Во втором стандарт.Gl & hf ! :)Разбор.Статистика.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11969",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 491
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Сережа и кружкиПосчитаем сумму всех элементов Sum и значение максимального элемента M. Если Sum - M ≤ S то ответ — да, иначе — нет.426B - Сережа и разворотыРешим задачу с обратной стороны. Будем пытаться свернуть нашу матрицу как можно больше число раз. Свернуть означает операцию, обратную к описанной в условии. Для проверки, можно ли свернуть матрицу нужно, что бы выполнялись следующие условия:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Сережа и обменыПереберем интервал, на котором будет находится максимальная сумма. Для улучшения суммы, мы можем поменять не более K минимальных элемента из интервала на не более K максимальных элементов, не принадлежащих отрезку. Так как n не большое мы можем делать это любым образом, например отсортировать все элементы на интервале по возрастанию и вне интервала по убыванию, а дальше будем менять максимальный элемент из вне интервала на минимальный в интервале по тех пор, пока не поменяем k элементов или не останется не замененных элементов в отрезке или не останется не замененных элементов вне отрезка или операция обмена вообще не будет оптимальной. Сложность авторского решения O(n3·log(n)). Есть ли у Вас идеи о ток, как решать эту задачу за время O(N) или O(N·log(N)) ? 425B - Сережа и таблицаЗаметим, что если у нас есть массив x[1..n], 0 ≤ xi ≤ 1 и y[1..m], 0 ≤ yi ≤ 1, то матрица описанная в условии имеет следующий вид ai, j = xi xor yj.Если n ≤ k, то мы можем перебрать массив x и с помощью жадного алгоритма найти наилучший y. Иначе у нас найдется хотя бы одно i, что мы не должны менять ничего в строке номер i. Таким образом мы можем просто перебрать строку и выбрав ее за x жадно посчитать y. Из всех строк выберем самую оптимальную. Такая строка найдется, потому что ошибок меньше, чем количество столбцов в которых они могут быть. Под жадным алгоритмом понимается следующий: будем для каждого элемента из y смотреть: лучше ли будет ответ, если определенный бит будет равен 0 или 1. Что бы проще проверять, что оптимальнее можно просто взять текущую строку(i) и посмотреть: сколько бит в ней совпадают с x, а сколько нет. Если совпадающих больше, то yi = 0, иначе yi = 1.425C - Сережа и две последовательностиДля этой задачи будем использовать динамическое программирование: dpi, j — минимальный номер позиции удаленного элемента во втором массиве, что мы провели первую операцию j раз и удалили из первого массива не более i элементов. Разберемся теперь как делать переходы. Находясь в состоянии dpi, j мы можем оставить все как есть и перейти в состояние dpi + 1, j, иными словами сделать dpi + 1, j:  = min(dpi + 1, j, dpi, j). Что происходит, когда мы делаем первую операцию, при фиксированном префиксе по элемент номер i? Нам нужно найти элемент второго массива с номером больше dpi, j и равный ai, пусть это будет элемент номер t, тогда нужно сделать переход dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). Как быстро искать нужный элемент: просто сделаем вектор вхождений во второй массив для каждого числа и по нему будем запускать бинарный поиск. 425D - Сережа и квадратыПускай прямая x = k содержит не более точек. Тогда мы можем просто для каждой пары точек на ней (пускай они будут (k, y1) и (k, y2)) проверить: есть ли квадрат, который содержит их как вершины. То есть на нужно проверить: есть ли в наших входных данных пара точек (k - |y2 - y1|, y1) и (k - |y2 - y1|, y2), или пара (k + |y2 - y1|, y1) и (k + |y2 - y1|, y2). Удалим все просмотренные точки и отразим оставшиеся относительно прямой x = y. Мы получили ситуацию, что каждая прямая x = k содержит не более точек. Решим задачу так же как и в первый раз. Теперь нужно научится проверять: есть ли пара точек на некоторой прямой. Запишем все эти пары в вектора для тех прямых, где мы хотим проверить. Допустим, мы проверяем все пары для прямой номер k. Пометим в некотором массиве u для всех точек с абсциссой k uy = k. Теперь пройдем по всем интересующим нас парам (y1, y2). Пара нам подходит, только если uy1 = uy2 = k.425E - Сережа и множестваСначала посмотрим на то, как мы считаем величину F(S). Сперва мы сортируем все интервалы по правому концу, а затем при обходе их в отсортированном порядке смотрим: если текущий интервал не пересекается с последним взятым в множество, то просто возьмем его. Решение нашей задачи будет использовать эту жадность. Решение задачи, это динамика с параметрами:1). номер позиции, в которой будут заканчиваться поставленные интервалы.2). количество поставленных интервалов3). правая позиция последнего поставленного интервала Как делать переходы: заметим, что считая dpi, count, last мы можем изменить last только на i, либо вообще не изменять. Давайте посмотрим, что произойдет в обеих случаях. В первом случае last меняется на i, тогда мы должны поставить хотя бы один из интервалов [last + 1, i], [last + 2, i], ..., [i, i], таких интервалов ровно i - last. Что бы узнать количество способов поставить их как нам нужно, можно использовать метод включений-исключений, но на самом деле можно просто взять число 2i - last - 1. Все остальные интервалы: [1, i], [2, i], ..., [last, i] мы можем брать как хотим, таким образом имеем 2last способов. Перемножим количества и получим количество переходов из dpi, count, last в dpi + 1, count + 1, i. Если же мы считаем количество переходов из dpi, count, last в dpi + 1, count, last, то просто будем брать число 2last. Так же стоит не забыть про случай dpi, 0, 0. Из которого тоже нужно делать переходы, которые по своей сути тривиальны. Таким образом мы получили очень простое решение.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 425\\s*E"
          },
          "content_length": 5539
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 - Codeforces - Code 1",
          "code": "I strongly recommend you to read ALL the problems.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 2",
          "code": "vx[x[i]].size() < vy[y[i]].size()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 3",
          "code": "x.cpp: В функции «int main()»:\nx.cpp:42:35: предупреждение: «p2» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                                   ^\nx.cpp:42:26: предупреждение: «p1» may be used uninitialized in this function [-Wmaybe-uninitialized]\n   for(i=0; i=p1 && i<=p2) { i=p2;  continue; } else if(a[i]>a[s1]) s1=i;\n                          ^",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 4",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 5",
          "code": "6 1\n1\n0\n1\n1\n0\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 6",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 7",
          "code": "6 1\n1\n1\n1\n1\n1\n1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 8",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 - Codeforces - Code 9",
          "code": "20\n0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n6 1\n6 2\n6 3\n6 4\n6 5\n6 6\n6 7\n6 8\n6 9\n6 10\n6 11\n6 12\n6 13\n6 14",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11969",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 500, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 500, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 500, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, 500, \"k\");\n    inf.readEoln();\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"min_n_min_k\") {\n        n = 1;\n        k = 0;\n    } else if(type == \"min_n_max_k\") {\n        n = 1;\n        k = 1;\n    } else if(type == \"max_n_min_k\") {\n        n = 500;\n        k = 0;\n    } else if(type == \"max_n_max_k\") {\n        n = 500;\n        k = 500;\n    } else if(type == \"n_equals_k\") {\n        n = rnd.next(1, 500);\n        k = n;\n    } else if(type == \"k_is_zero\") {\n        n = rnd.next(1, 500);\n        k = 0;\n    } else if(type == \"k_is_n\") {\n        n = rnd.next(1,500);\n        k = n;\n    } else if(type == \"n_is_1\") {\n        n = 1;\n        k = rnd.next(0,1);\n    } else if(type == \"n_is_max\") {\n        n = 500;\n        k = rnd.next(0, 500);\n    } else if(type == \"k_is_half_n\") {\n        n = rnd.next(2, 500);\n        k = n / 2;\n    } else if(type == \"random\") {\n        if(n == -1) n = rnd.next(1, 500);\n        if(k == -1) k = rnd.next(0, n);\n        else k = min(k, n);\n    } else {\n        // default random\n        if(n == -1) n = rnd.next(1, 500);\n        if(k == -1) k = rnd.next(0, n);\n        else k = min(k, n);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    \n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(type == \"min_n_min_k\") {\n        n = 1;\n        k = 0;\n    } else if(type == \"min_n_max_k\") {\n        n = 1;\n        k = 1;\n    } else if(type == \"max_n_min_k\") {\n        n = 500;\n        k = 0;\n    } else if(type == \"max_n_max_k\") {\n        n = 500;\n        k = 500;\n    } else if(type == \"n_equals_k\") {\n        n = rnd.next(1, 500);\n        k = n;\n    } else if(type == \"k_is_zero\") {\n        n = rnd.next(1, 500);\n        k = 0;\n    } else if(type == \"k_is_n\") {\n        n = rnd.next(1,500);\n        k = n;\n    } else if(type == \"n_is_1\") {\n        n = 1;\n        k = rnd.next(0,1);\n    } else if(type == \"n_is_max\") {\n        n = 500;\n        k = rnd.next(0, 500);\n    } else if(type == \"k_is_half_n\") {\n        n = rnd.next(2, 500);\n        k = n / 2;\n    } else if(type == \"random\") {\n        if(n == -1) n = rnd.next(1, 500);\n        if(k == -1) k = rnd.next(0, n);\n        else k = min(k, n);\n    } else {\n        // default random\n        if(n == -1) n = rnd.next(1, 500);\n        if(k == -1) k = rnd.next(0, n);\n        else k = min(k, n);\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_n_min_k\n./gen -type min_n_max_k\n./gen -type max_n_min_k\n./gen -type max_n_max_k\n./gen -type n_equals_k\n./gen -type k_is_zero\n./gen -type k_is_n\n./gen -type n_is_1\n./gen -type n_is_max\n./gen -type k_is_half_n\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type k_is_zero\n./gen -type k_is_n\n./gen -type n_equals_k\n./gen -type k_is_half_n\n./gen -type n_is_max\n\n./gen -n 100 -k 0\n./gen -n 100 -k 50\n./gen -n 100 -k 100\n./gen -n 250 -k 0\n./gen -n 250 -k 125\n./gen -n 250 -k 250\n./gen -n 500 -k 0\n./gen -n 500 -k 250\n./gen -n 500 -k 500\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:06.219405",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "426/A",
      "title": "A. Sereja and Mugs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n and s (2 ≤ n ≤ 100; 1 ≤ s ≤ 1000) — the number of mugs and the volume of the cup. The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10). Number ai means the volume of the i-th mug.",
      "output_spec": "OutputIn a single line, print \"YES\" (without the quotes) if his friends can play in the described manner, and \"NO\" (without the quotes) otherwise.",
      "sample_tests": "ExamplesInputCopy3 41 1 1OutputCopyYESInputCopy3 43 1 3OutputCopyYESInputCopy3 44 4 4OutputCopyNO",
      "description": "A. Sereja and Mugs\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n and s (2 ≤ n ≤ 100; 1 ≤ s ≤ 1000) — the number of mugs and the volume of the cup. The next line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 10). Number ai means the volume of the i-th mug.\n\nOutputIn a single line, print \"YES\" (without the quotes) if his friends can play in the described manner, and \"NO\" (without the quotes) otherwise.\n\nInputCopy3 41 1 1OutputCopyYESInputCopy3 43 1 3OutputCopyYESInputCopy3 44 4 4OutputCopyNO\n\nInputCopy3 41 1 1\n\nOutputCopyYES\n\nInputCopy3 43 1 3\n\nOutputCopyYES\n\nInputCopy3 44 4 4\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Sereja and MugsLets count the sum of all elements Sum and value of the maximal element M. If Sum - M ≤ S then answer is yes, otherwise — no.426B - Sereja and MirroringLets solve problem from another side. We will try to cut of matix as many times as we can. Cut means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Sereja and SwapsLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3·log(n)). Is there some ideas how to solve this problem in time O(n) or O(n·log(n)) ? 425B - Sereja and Table Note, that if we have two arrays x[1..n], 0 ≤ xi ≤ 1 and y[1..m], 0 ≤ yi ≤ 1, then described matrix can be showed as next one: ai, j = xi xor yj.If n ≤ k, then we can backtrack array x and using greedy find best y. Otherwise there will be atleast one i, such that we will not change any cell in row number i. So we can simply bruteforce some row and use it like x. Then we use greedy and find y. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn't possible to have atleast one mistake in each row. Greedy means next algorithm: for every element of y we will look, will it be better to choose it like 0 or 1. To find better choise, we will count number of different bits in x and current(lets it be j) column. If number of different if lower then count of same cells we will set yj = 0, otherwise yj = 1.425C - Sereja and Two SequencesIn thgis problem we will use dynamic programming: dpi, j — minimal pozition of deleted element in second array, such that we have made first operation j times and have deleted not more then i elements from first array. Lets decided how to calculate transfers. Standing in pozition dpi, j we can change nothing and go to pozition dpi + 1, j, by other words make transfer dpi + 1, j:  = min(dpi + 1, j, dpi, j). What happens when we make first operation with fixed prefix(by i-th element) in first array? We should find element in second array with number greater dpi, j and value equal to ai, lets its pozition is t, so we need to make transfer dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). How to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. 425D - Sereja and SquaresLets line x = k contain not more then points. Then for each pair of points on this line (lets it be (k, y1) and (k, y2)) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points (k - |y2 - y1|, y1) and (k - |y2 - y1|, y2), or pair (k + |y2 - y1|, y1) and (k + |y2 - y1|, y2). Lets delete all watched points, and reverse points about line x = y. Then each line x = k will contain not more then points. Will solve problem in the same way. Now we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number k. Lets mark in some array u for all points with x-coordinate equal to k uy = k. Now to check is our pair with y-coordinates (y1, y2) on line we can simply check following condition: uy1 = uy2 = k.425E - Sereja and SetsFirst, lets look at F(S). First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don't intersected with last taken to the optimal set, we get our current to the set.Our solution will be based on this greedy. Solution of the problem is next dynamic:1). number of position of second coordinte of interval2). number of intervals in good set3). second coordinate of last taken interval to the optimal set How should we make transfers? Lets note that when we know dpi, count, last we can change last by i, or not change at all. Lets look what happens in every case. In first case last is changed by i, so we should take to optimal set atleast one of the inervals: [last + 1, i], [last + 2, i], ..., [i, i], number of such intervals i - last, number of ways to get at least one of them is 2i - last - 1. All other intervals: [1, i], [2, i], ..., [last, i] we could get as we wish, so we have 2last ways. So total number of transfers from dpi, count, last to dpi + 1, count + 1, i is (2i - last - 1)·(2last). If we count number of transfers from dpi, count, last to dpi + 1, count, last, we can simply use number 2last(as described early). Also we shouldn't forget about trivial case dpi, 0, 0. So now we have quite easy solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 426\\s*A"
          },
          "content_length": 5266
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and s\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000, \"s\");\n    inf.readEoln();\n\n    // Read n integers a1, a2, ..., an\n    vector<int> a = inf.readInts(n, 1, 10);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and s\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000, \"s\");\n    inf.readEoln();\n\n    // Read n integers a1, a2, ..., an\n    vector<int> a = inf.readInts(n, 1, 10);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and s\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000, \"s\");\n    inf.readEoln();\n\n    // Read n integers a1, a2, ..., an\n    vector<int> a = inf.readInts(n, 1, 10);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s_input = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    int s;\n    if (type == \"max_yes\") {\n        // We need to generate ai such that total_volume - max(a) = s, and total_volume ≤ 1000\n        int max_volume = rnd.next(1, 10);\n        // Let's set s arbitrarily if not provided\n        if (s_input == -1) {\n            s = rnd.next(1, 1000 - max_volume); // s ≤ 1000 - max_volume\n        } else {\n            s = s_input;\n            if (s > 1000 - max_volume)\n                s = 1000 - max_volume; // adjust s\n        }\n        int total_volume = s + max_volume; // total sum of ai\n        if (total_volume > 1000) {\n            total_volume = 1000;\n            s = total_volume - max_volume;\n        }\n        // Now distribute s among n - 1 mugs, ai between 1 and 10\n        vector<int> other_volumes(n - 1, 1);\n        int remaining = s - (n - 1); // total sum minus initial allocation of 1 to each mug\n        for (int i = 0; i < n - 1 && remaining > 0; ++i) {\n            int add = min(remaining, 9); // max we can add to this mug\n            other_volumes[i] += add;\n            remaining -= add;\n        }\n        a[0] = max_volume;\n        for (int i = 1; i < n; ++i)\n            a[i] = other_volumes[i - 1];\n    } else if (type == \"max_no\") {\n        // We need total_volume - max(a) = s + 1\n        int max_volume = rnd.next(1, 10);\n        // Let's set s arbitrarily if not provided\n        if (s_input == -1) {\n            s = rnd.next(1, 1000 - max_volume - 1); // s ≤ 1000 - max_volume -1\n        } else {\n            s = s_input;\n            if (s > 1000 - max_volume - 1)\n                s = 1000 - max_volume - 1; // adjust s\n        }\n        int total_volume = s + 1 + max_volume; // total sum of ai\n        if (total_volume > 1000) {\n            total_volume = 1000;\n            s = total_volume - max_volume - 1;\n        }\n        // Now distribute s + 1 among n - 1 mugs, ai between 1 and 10\n        int sum_other_volumes = s + 1;\n        vector<int> other_volumes(n - 1, 1);\n        int remaining = sum_other_volumes - (n - 1);\n        for (int i = 0; i < n - 1 && remaining > 0; ++i) {\n            int add = min(remaining, 9);\n            other_volumes[i] += add;\n            remaining -= add;\n        }\n        a[0] = max_volume;\n        for (int i = 1; i < n; ++i)\n            a[i] = other_volumes[i - 1];\n    } else if (type == \"all_max\") {\n        s = s_input;\n        if (s == -1)\n            s = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = 10;\n    } else if (type == \"all_min\") {\n        s = s_input;\n        if (s == -1)\n            s = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else {\n        // Default: random\n        s = s_input;\n        if (s == -1)\n            s = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    }\n\n    // Now, output n and s\n    printf(\"%d %d\\n\", n, s);\n    // Output the ai's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%s\", a[i], (i == n - 1 ? \"\\n\" : \" \"));\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s_input = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n    int s;\n    if (type == \"max_yes\") {\n        // We need to generate ai such that total_volume - max(a) = s, and total_volume ≤ 1000\n        int max_volume = rnd.next(1, 10);\n        // Let's set s arbitrarily if not provided\n        if (s_input == -1) {\n            s = rnd.next(1, 1000 - max_volume); // s ≤ 1000 - max_volume\n        } else {\n            s = s_input;\n            if (s > 1000 - max_volume)\n                s = 1000 - max_volume; // adjust s\n        }\n        int total_volume = s + max_volume; // total sum of ai\n        if (total_volume > 1000) {\n            total_volume = 1000;\n            s = total_volume - max_volume;\n        }\n        // Now distribute s among n - 1 mugs, ai between 1 and 10\n        vector<int> other_volumes(n - 1, 1);\n        int remaining = s - (n - 1); // total sum minus initial allocation of 1 to each mug\n        for (int i = 0; i < n - 1 && remaining > 0; ++i) {\n            int add = min(remaining, 9); // max we can add to this mug\n            other_volumes[i] += add;\n            remaining -= add;\n        }\n        a[0] = max_volume;\n        for (int i = 1; i < n; ++i)\n            a[i] = other_volumes[i - 1];\n    } else if (type == \"max_no\") {\n        // We need total_volume - max(a) = s + 1\n        int max_volume = rnd.next(1, 10);\n        // Let's set s arbitrarily if not provided\n        if (s_input == -1) {\n            s = rnd.next(1, 1000 - max_volume - 1); // s ≤ 1000 - max_volume -1\n        } else {\n            s = s_input;\n            if (s > 1000 - max_volume - 1)\n                s = 1000 - max_volume - 1; // adjust s\n        }\n        int total_volume = s + 1 + max_volume; // total sum of ai\n        if (total_volume > 1000) {\n            total_volume = 1000;\n            s = total_volume - max_volume - 1;\n        }\n        // Now distribute s + 1 among n - 1 mugs, ai between 1 and 10\n        int sum_other_volumes = s + 1;\n        vector<int> other_volumes(n - 1, 1);\n        int remaining = sum_other_volumes - (n - 1);\n        for (int i = 0; i < n - 1 && remaining > 0; ++i) {\n            int add = min(remaining, 9);\n            other_volumes[i] += add;\n            remaining -= add;\n        }\n        a[0] = max_volume;\n        for (int i = 1; i < n; ++i)\n            a[i] = other_volumes[i - 1];\n    } else if (type == \"all_max\") {\n        s = s_input;\n        if (s == -1)\n            s = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = 10;\n    } else if (type == \"all_min\") {\n        s = s_input;\n        if (s == -1)\n            s = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else {\n        // Default: random\n        s = s_input;\n        if (s == -1)\n            s = rnd.next(1, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 10);\n    }\n\n    // Now, output n and s\n    printf(\"%d %d\\n\", n, s);\n    // Output the ai's\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%s\", a[i], (i == n - 1 ? \"\\n\" : \" \"));\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -s 1 -type random\n./gen -n 2 -s 2 -type all_min\n./gen -n 2 -s 2 -type all_max\n./gen -n 2 -s 2 -type max_yes\n./gen -n 2 -s 2 -type max_no\n./gen -n 2 -type random\n\n./gen -n 10 -s 10 -type all_min\n./gen -n 10 -s 100 -type all_max\n./gen -n 10 -s 50 -type random\n./gen -n 10 -s 20 -type random\n./gen -n 10 -type all_max\n\n./gen -n 50 -s 500 -type max_yes\n./gen -n 50 -s 500 -type max_no\n./gen -n 50 -type max_yes\n./gen -n 50 -type max_no\n\n./gen -n 70 -s 70 -type all_min\n./gen -n 70 -s 700 -type all_max\n./gen -n 70 -s 700 -type random\n./gen -n 70 -s 200 -type random\n./gen -n 70 -type random\n\n./gen -n 99 -s 999 -type max_yes\n./gen -n 99 -s 999 -type max_no\n./gen -n 99 -type random\n\n./gen -n 100 -s 1000 -type all_min\n./gen -n 100 -s 1000 -type all_max\n./gen -n 100 -s 1000 -type random\n./gen -n 100 -type all_min\n./gen -n 100 -type all_max\n./gen -n 100 -type random\n\n./gen -n 100 -s 100 -type max_yes\n./gen -n 100 -s 100 -type max_no\n\n./gen -n 50 -s 10 -type max_yes\n./gen -n 50 -s 10 -type max_no\n\n./gen -n 80 -s 1000 -type random\n./gen -n 80 -s 500 -type random\n./gen -n 80 -s 500 -type max_yes\n./gen -n 80 -s 500 -type max_no\n\n./gen -n 100 -s 1 -type max_yes\n./gen -n 100 -s 1 -type max_no\n\n./gen -n 20 -type random\n./gen -n 20 -type max_yes\n./gen -n 20 -type max_no\n\n./gen -n 50 -type all_max\n./gen -n 50 -type all_min\n./gen -n 50 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:08.228734",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "426/B",
      "title": "B. Sereja and Mirroring",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and m (1 ≤ n, m ≤ 100). Each of the next n lines contains m integers — the elements of matrix a. The i-th line contains integers ai1, ai2, ..., aim (0 ≤ aij ≤ 1) — the i-th row of the matrix a.",
      "output_spec": "OutputIn the single line, print the answer to the problem — the minimum number of rows of matrix b.",
      "sample_tests": "ExamplesInputCopy4 30 0 11 1 01 1 00 0 1OutputCopy2InputCopy3 30 0 00 0 00 0 0OutputCopy3InputCopy8 101100110OutputCopy2",
      "description": "B. Sereja and Mirroring\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and m (1 ≤ n, m ≤ 100). Each of the next n lines contains m integers — the elements of matrix a. The i-th line contains integers ai1, ai2, ..., aim (0 ≤ aij ≤ 1) — the i-th row of the matrix a.\n\nOutputIn the single line, print the answer to the problem — the minimum number of rows of matrix b.\n\nInputCopy4 30 0 11 1 01 1 00 0 1OutputCopy2InputCopy3 30 0 00 0 00 0 0OutputCopy3InputCopy8 101100110OutputCopy2\n\nInputCopy4 30 0 11 1 01 1 00 0 1\n\nOutputCopy2\n\nInputCopy3 30 0 00 0 00 0 0\n\nOutputCopy3\n\nInputCopy8 101100110\n\nOutputCopy2\n\nNoteIn the first test sample the answer is a 2 × 3 matrix b:001110If we perform a mirroring operation with this matrix, we get the matrix a that is given in the input:001110110001",
      "solutions": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Sereja and MugsLets count the sum of all elements Sum and value of the maximal element M. If Sum - M ≤ S then answer is yes, otherwise — no.426B - Sereja and MirroringLets solve problem from another side. We will try to cut of matix as many times as we can. Cut means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Sereja and SwapsLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3·log(n)). Is there some ideas how to solve this problem in time O(n) or O(n·log(n)) ? 425B - Sereja and Table Note, that if we have two arrays x[1..n], 0 ≤ xi ≤ 1 and y[1..m], 0 ≤ yi ≤ 1, then described matrix can be showed as next one: ai, j = xi xor yj.If n ≤ k, then we can backtrack array x and using greedy find best y. Otherwise there will be atleast one i, such that we will not change any cell in row number i. So we can simply bruteforce some row and use it like x. Then we use greedy and find y. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn't possible to have atleast one mistake in each row. Greedy means next algorithm: for every element of y we will look, will it be better to choose it like 0 or 1. To find better choise, we will count number of different bits in x and current(lets it be j) column. If number of different if lower then count of same cells we will set yj = 0, otherwise yj = 1.425C - Sereja and Two SequencesIn thgis problem we will use dynamic programming: dpi, j — minimal pozition of deleted element in second array, such that we have made first operation j times and have deleted not more then i elements from first array. Lets decided how to calculate transfers. Standing in pozition dpi, j we can change nothing and go to pozition dpi + 1, j, by other words make transfer dpi + 1, j:  = min(dpi + 1, j, dpi, j). What happens when we make first operation with fixed prefix(by i-th element) in first array? We should find element in second array with number greater dpi, j and value equal to ai, lets its pozition is t, so we need to make transfer dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). How to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. 425D - Sereja and SquaresLets line x = k contain not more then points. Then for each pair of points on this line (lets it be (k, y1) and (k, y2)) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points (k - |y2 - y1|, y1) and (k - |y2 - y1|, y2), or pair (k + |y2 - y1|, y1) and (k + |y2 - y1|, y2). Lets delete all watched points, and reverse points about line x = y. Then each line x = k will contain not more then points. Will solve problem in the same way. Now we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number k. Lets mark in some array u for all points with x-coordinate equal to k uy = k. Now to check is our pair with y-coordinates (y1, y2) on line we can simply check following condition: uy1 = uy2 = k.425E - Sereja and SetsFirst, lets look at F(S). First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don't intersected with last taken to the optimal set, we get our current to the set.Our solution will be based on this greedy. Solution of the problem is next dynamic:1). number of position of second coordinte of interval2). number of intervals in good set3). second coordinate of last taken interval to the optimal set How should we make transfers? Lets note that when we know dpi, count, last we can change last by i, or not change at all. Lets look what happens in every case. In first case last is changed by i, so we should take to optimal set atleast one of the inervals: [last + 1, i], [last + 2, i], ..., [i, i], number of such intervals i - last, number of ways to get at least one of them is 2i - last - 1. All other intervals: [1, i], [2, i], ..., [last, i] we could get as we wish, so we have 2last ways. So total number of transfers from dpi, count, last to dpi + 1, count + 1, i is (2i - last - 1)·(2last). If we count number of transfers from dpi, count, last to dpi + 1, count, last, we can simply use number 2last(as described early). Also we shouldn't forget about trivial case dpi, 0, 0. So now we have quite easy solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 426\\s*B"
          },
          "content_length": 5266
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random matrix\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 1);\n    } else if (type == \"zeros\") {\n        // All zeros\n        // Default initialization is zero, nothing to do\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n    } else if (type == \"symmetric\") {\n        // Generate a symmetric matrix about the horizontal center\n        int mid = (n + 1) / 2;\n        for(int i = 0; i < mid; ++i) {\n            for(int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(0, 1);\n                int symmetricRow = n - i - 1;\n                if (symmetricRow != i) {\n                    a[symmetricRow][j] = a[i][j];\n                }\n            }\n        }\n    } else if (type == \"asymmetric\") {\n        // Generate matrix with an alternating pattern\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = (i * m + j) % 2;\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = (i + j) % 2;\n    } else if (type == \"mirror\") {\n        int x = opt<int>(\"x\");\n        // Compute minimal k such that x * (2^k) >= n\n        int k = 0;\n        while ( (x << k) < n && k <= 7 ) k++; // Limit k to reasonable value\n        int totalRows = x << k;\n        if (totalRows < n) {\n            // Cannot generate matrix with given x, fill with random\n            for(int i = 0; i < n; ++i)\n                for(int j = 0; j < m; ++j)\n                    a[i][j] = rnd.next(0, 1);\n        } else {\n            // Generate base matrix b\n            vector<vector<int>> b(x, vector<int>(m));\n            for(int i = 0; i < x; ++i)\n                for(int j = 0; j < m; ++j)\n                    b[i][j] = rnd.next(0, 1);\n            // Generate c by performing k mirrorings\n            vector<vector<int>> c = b;\n            for(int mirror = 0; mirror < k; ++mirror) {\n                int size = c.size();\n                c.resize(size * 2);\n                for(int i = 0; i < size; ++i)\n                    c[size * 2 - i - 1] = c[i];\n            }\n            // Assign first n rows to a\n            for(int i = 0; i < n; ++i) {\n                a[i] = c[i];\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the matrix a\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random matrix\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 1);\n    } else if (type == \"zeros\") {\n        // All zeros\n        // Default initialization is zero, nothing to do\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n    } else if (type == \"symmetric\") {\n        // Generate a symmetric matrix about the horizontal center\n        int mid = (n + 1) / 2;\n        for(int i = 0; i < mid; ++i) {\n            for(int j = 0; j < m; ++j) {\n                a[i][j] = rnd.next(0, 1);\n                int symmetricRow = n - i - 1;\n                if (symmetricRow != i) {\n                    a[symmetricRow][j] = a[i][j];\n                }\n            }\n        }\n    } else if (type == \"asymmetric\") {\n        // Generate matrix with an alternating pattern\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = (i * m + j) % 2;\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = (i + j) % 2;\n    } else if (type == \"mirror\") {\n        int x = opt<int>(\"x\");\n        // Compute minimal k such that x * (2^k) >= n\n        int k = 0;\n        while ( (x << k) < n && k <= 7 ) k++; // Limit k to reasonable value\n        int totalRows = x << k;\n        if (totalRows < n) {\n            // Cannot generate matrix with given x, fill with random\n            for(int i = 0; i < n; ++i)\n                for(int j = 0; j < m; ++j)\n                    a[i][j] = rnd.next(0, 1);\n        } else {\n            // Generate base matrix b\n            vector<vector<int>> b(x, vector<int>(m));\n            for(int i = 0; i < x; ++i)\n                for(int j = 0; j < m; ++j)\n                    b[i][j] = rnd.next(0, 1);\n            // Generate c by performing k mirrorings\n            vector<vector<int>> c = b;\n            for(int mirror = 0; mirror < k; ++mirror) {\n                int size = c.size();\n                c.resize(size * 2);\n                for(int i = 0; i < size; ++i)\n                    c[size * 2 - i - 1] = c[i];\n            }\n            // Assign first n rows to a\n            for(int i = 0; i < n; ++i) {\n                a[i] = c[i];\n            }\n        }\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 1);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the matrix a\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m)\n                printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type zeros\n./gen -n 1 -m 1 -type ones\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 2 -type symmetric\n./gen -n 3 -m 3 -type symmetric\n./gen -n 4 -m 4 -type symmetric\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type asymmetric\n\n./gen -n 50 -m 50 -type zeros\n./gen -n 50 -m 50 -type ones\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 100 -m 100 -type mirror -x 1\n./gen -n 100 -m 100 -type mirror -x 2\n./gen -n 100 -m 100 -type mirror -x 5\n./gen -n 100 -m 100 -type mirror -x 10\n./gen -n 100 -m 100 -type mirror -x 25\n./gen -n 100 -m 100 -type mirror -x 50\n./gen -n 100 -m 100 -type mirror -x 100\n\n./gen -n 99 -m 99 -type mirror -x 33\n\n./gen -n 97 -m 103 -type random\n\n./gen -n 100 -m 1 -type checkerboard\n./gen -n 1 -m 100 -type checkerboard\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:10.045682",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "426/C",
      "title": "C. Sereja and Swaps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ n ≤ 200; 1 ≤ k ≤ 10). The next line contains n integers a[1], a[2], ..., a[n] ( - 1000 ≤ a[i] ≤ 1000).",
      "output_spec": "OutputIn a single line print the maximum value of m(a) that Sereja can get if he is allowed to perform at most k swap operations.",
      "sample_tests": "ExamplesInputCopy10 210 -1 2 2 2 2 2 2 -1 10OutputCopy32InputCopy5 10-1 -1 -1 -1 -1OutputCopy-1",
      "description": "C. Sereja and Swaps\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ n ≤ 200; 1 ≤ k ≤ 10). The next line contains n integers a[1], a[2], ..., a[n] ( - 1000 ≤ a[i] ≤ 1000).\n\nOutputIn a single line print the maximum value of m(a) that Sereja can get if he is allowed to perform at most k swap operations.\n\nInputCopy10 210 -1 2 2 2 2 2 2 -1 10OutputCopy32InputCopy5 10-1 -1 -1 -1 -1OutputCopy-1\n\nInputCopy10 210 -1 2 2 2 2 2 2 -1 10\n\nOutputCopy32\n\nInputCopy5 10-1 -1 -1 -1 -1\n\nOutputCopy-1",
      "solutions": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Sereja and MugsLets count the sum of all elements Sum and value of the maximal element M. If Sum - M ≤ S then answer is yes, otherwise — no.426B - Sereja and MirroringLets solve problem from another side. We will try to cut of matix as many times as we can. Cut means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Sereja and SwapsLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3·log(n)). Is there some ideas how to solve this problem in time O(n) or O(n·log(n)) ? 425B - Sereja and Table Note, that if we have two arrays x[1..n], 0 ≤ xi ≤ 1 and y[1..m], 0 ≤ yi ≤ 1, then described matrix can be showed as next one: ai, j = xi xor yj.If n ≤ k, then we can backtrack array x and using greedy find best y. Otherwise there will be atleast one i, such that we will not change any cell in row number i. So we can simply bruteforce some row and use it like x. Then we use greedy and find y. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn't possible to have atleast one mistake in each row. Greedy means next algorithm: for every element of y we will look, will it be better to choose it like 0 or 1. To find better choise, we will count number of different bits in x and current(lets it be j) column. If number of different if lower then count of same cells we will set yj = 0, otherwise yj = 1.425C - Sereja and Two SequencesIn thgis problem we will use dynamic programming: dpi, j — minimal pozition of deleted element in second array, such that we have made first operation j times and have deleted not more then i elements from first array. Lets decided how to calculate transfers. Standing in pozition dpi, j we can change nothing and go to pozition dpi + 1, j, by other words make transfer dpi + 1, j:  = min(dpi + 1, j, dpi, j). What happens when we make first operation with fixed prefix(by i-th element) in first array? We should find element in second array with number greater dpi, j and value equal to ai, lets its pozition is t, so we need to make transfer dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). How to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. 425D - Sereja and SquaresLets line x = k contain not more then points. Then for each pair of points on this line (lets it be (k, y1) and (k, y2)) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points (k - |y2 - y1|, y1) and (k - |y2 - y1|, y2), or pair (k + |y2 - y1|, y1) and (k + |y2 - y1|, y2). Lets delete all watched points, and reverse points about line x = y. Then each line x = k will contain not more then points. Will solve problem in the same way. Now we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number k. Lets mark in some array u for all points with x-coordinate equal to k uy = k. Now to check is our pair with y-coordinates (y1, y2) on line we can simply check following condition: uy1 = uy2 = k.425E - Sereja and SetsFirst, lets look at F(S). First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don't intersected with last taken to the optimal set, we get our current to the set.Our solution will be based on this greedy. Solution of the problem is next dynamic:1). number of position of second coordinte of interval2). number of intervals in good set3). second coordinate of last taken interval to the optimal set How should we make transfers? Lets note that when we know dpi, count, last we can change last by i, or not change at all. Lets look what happens in every case. In first case last is changed by i, so we should take to optimal set atleast one of the inervals: [last + 1, i], [last + 2, i], ..., [i, i], number of such intervals i - last, number of ways to get at least one of them is 2i - last - 1. All other intervals: [1, i], [2, i], ..., [last, i] we could get as we wish, so we have 2last ways. So total number of transfers from dpi, count, last to dpi + 1, count + 1, i is (2i - last - 1)·(2last). If we count number of transfers from dpi, count, last to dpi + 1, count, last, we can simply use number 2last(as described early). Also we shouldn't forget about trivial case dpi, 0, 0. So now we have quite easy solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 426 和字母"
          },
          "content_length": 5266
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000, 1000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n    } else if (type == \"max\") {\n        // Generate array that is already maximized\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000 - i % 200; // Ensure within bounds\n    } else if (type == \"min\") {\n        // Generate array that is already minimized\n        for (int i = 0; i < n; ++i)\n            a[i] = -1000 + i % 200; // Ensure within bounds\n    } else if (type == \"negative\") {\n        // All negative numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, -1);\n    } else if (type == \"positive\") {\n        // All positive numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else if (type == \"alternating\") {\n        // Alternating positive and negative numbers\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, 1000);\n            else\n                a[i] = rnd.next(-1000, -1);\n        }\n    } else if (type == \"constant\") {\n        // All elements are the same\n        int value = rnd.next(-1000, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = value;\n    } else if (type == \"special\") {\n        // Create an array that can be significantly improved with at most k swaps\n        // For example, place large numbers apart from each other, and small numbers in between\n        int large_value = 1000;\n        int small_value = -1000;\n        a[0] = large_value;\n        a[n - 1] = large_value;\n        for (int i = 1; i < n - 1; ++i)\n            a[i] = small_value;\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the array\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n    } else if (type == \"max\") {\n        // Generate array that is already maximized\n        for (int i = 0; i < n; ++i)\n            a[i] = 1000 - i % 200; // Ensure within bounds\n    } else if (type == \"min\") {\n        // Generate array that is already minimized\n        for (int i = 0; i < n; ++i)\n            a[i] = -1000 + i % 200; // Ensure within bounds\n    } else if (type == \"negative\") {\n        // All negative numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, -1);\n    } else if (type == \"positive\") {\n        // All positive numbers\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else if (type == \"alternating\") {\n        // Alternating positive and negative numbers\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = rnd.next(1, 1000);\n            else\n                a[i] = rnd.next(-1000, -1);\n        }\n    } else if (type == \"constant\") {\n        // All elements are the same\n        int value = rnd.next(-1000, 1000);\n        for (int i = 0; i < n; ++i)\n            a[i] = value;\n    } else if (type == \"special\") {\n        // Create an array that can be significantly improved with at most k swaps\n        // For example, place large numbers apart from each other, and small numbers in between\n        int large_value = 1000;\n        int small_value = -1000;\n        a[0] = large_value;\n        a[n - 1] = large_value;\n        for (int i = 1; i < n - 1; ++i)\n            a[i] = small_value;\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-1000, 1000);\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the array\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i + 1 == n) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type positive\n./gen -n 1 -k 1 -type negative\n./gen -n 1 -k 1 -type alternating\n./gen -n 1 -k 1 -type constant\n\n./gen -n 5 -k 1 -type random\n./gen -n 5 -k 5 -type random\n./gen -n 5 -k 10 -type random\n\n./gen -n 200 -k 1 -type random\n./gen -n 200 -k 5 -type random\n./gen -n 200 -k 10 -type random\n\n./gen -n 200 -k 10 -type max\n./gen -n 200 -k 10 -type min\n./gen -n 200 -k 5 -type alternating\n./gen -n 200 -k 5 -type negative\n./gen -n 200 -k 5 -type positive\n\n./gen -n 200 -k 10 -type special\n\n./gen -n 199 -k 9 -type random\n./gen -n 2 -k 2 -type special\n\n./gen -n 100 -k 3 -type random\n./gen -n 100 -k 4 -type max\n./gen -n 100 -k 5 -type min\n\n./gen -n 50 -k 5 -type positive\n./gen -n 50 -k 5 -type negative\n\n./gen -n 100 -k 1 -type max\n./gen -n 100 -k 1 -type min\n./gen -n 100 -k 1 -type special\n\n./gen -n 200 -k 10 -type constant\n./gen -n 200 -k 10 -type special\n./gen -n 200 -k 10 -type negative\n./gen -n 200 -k 10 -type alternating\n\n./gen -n 100 -k 1 -type random\n./gen -n 100 -k 10 -type random\n\n./gen -n 50 -k 2 -type random\n./gen -n 75 -k 7 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:12.031021",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "426/D",
      "title": "D. Sereja and Table",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integers n, m and k (1 ≤ n, m ≤ 100; 1 ≤ k ≤ 10). Next n lines describe the table a: the i-th of them contains m integers ai1, ai2, ..., aim (0 ≤ ai, j ≤ 1) — the values in the cells of the i-th row.",
      "output_spec": "OutputPrint -1, if it is impossible to meet the requirement. Otherwise, print the minimum number of cells which should be changed.",
      "sample_tests": "ExamplesInputCopy5 5 21 1 1 1 11 1 1 1 11 1 0 1 11 1 1 1 11 1 1 1 1OutputCopy1InputCopy3 4 11 0 0 00 1 1 11 1 1 0OutputCopy-1InputCopy3 4 11 0 0 10 1 1 01 0 0 1OutputCopy0",
      "description": "D. Sereja and Table\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m and k (1 ≤ n, m ≤ 100; 1 ≤ k ≤ 10). Next n lines describe the table a: the i-th of them contains m integers ai1, ai2, ..., aim (0 ≤ ai, j ≤ 1) — the values in the cells of the i-th row.\n\nOutputPrint -1, if it is impossible to meet the requirement. Otherwise, print the minimum number of cells which should be changed.\n\nInputCopy5 5 21 1 1 1 11 1 1 1 11 1 0 1 11 1 1 1 11 1 1 1 1OutputCopy1InputCopy3 4 11 0 0 00 1 1 11 1 1 0OutputCopy-1InputCopy3 4 11 0 0 10 1 1 01 0 0 1OutputCopy0\n\nInputCopy5 5 21 1 1 1 11 1 1 1 11 1 0 1 11 1 1 1 11 1 1 1 1\n\nOutputCopy1\n\nInputCopy3 4 11 0 0 00 1 1 11 1 1 0\n\nOutputCopy-1\n\nInputCopy3 4 11 0 0 10 1 1 01 0 0 1\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Sereja and MugsLets count the sum of all elements Sum and value of the maximal element M. If Sum - M ≤ S then answer is yes, otherwise — no.426B - Sereja and MirroringLets solve problem from another side. We will try to cut of matix as many times as we can. Cut means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Sereja and SwapsLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3·log(n)). Is there some ideas how to solve this problem in time O(n) or O(n·log(n)) ? 425B - Sereja and Table Note, that if we have two arrays x[1..n], 0 ≤ xi ≤ 1 and y[1..m], 0 ≤ yi ≤ 1, then described matrix can be showed as next one: ai, j = xi xor yj.If n ≤ k, then we can backtrack array x and using greedy find best y. Otherwise there will be atleast one i, such that we will not change any cell in row number i. So we can simply bruteforce some row and use it like x. Then we use greedy and find y. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn't possible to have atleast one mistake in each row. Greedy means next algorithm: for every element of y we will look, will it be better to choose it like 0 or 1. To find better choise, we will count number of different bits in x and current(lets it be j) column. If number of different if lower then count of same cells we will set yj = 0, otherwise yj = 1.425C - Sereja and Two SequencesIn thgis problem we will use dynamic programming: dpi, j — minimal pozition of deleted element in second array, such that we have made first operation j times and have deleted not more then i elements from first array. Lets decided how to calculate transfers. Standing in pozition dpi, j we can change nothing and go to pozition dpi + 1, j, by other words make transfer dpi + 1, j:  = min(dpi + 1, j, dpi, j). What happens when we make first operation with fixed prefix(by i-th element) in first array? We should find element in second array with number greater dpi, j and value equal to ai, lets its pozition is t, so we need to make transfer dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). How to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. 425D - Sereja and SquaresLets line x = k contain not more then points. Then for each pair of points on this line (lets it be (k, y1) and (k, y2)) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points (k - |y2 - y1|, y1) and (k - |y2 - y1|, y2), or pair (k + |y2 - y1|, y1) and (k + |y2 - y1|, y2). Lets delete all watched points, and reverse points about line x = y. Then each line x = k will contain not more then points. Will solve problem in the same way. Now we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number k. Lets mark in some array u for all points with x-coordinate equal to k uy = k. Now to check is our pair with y-coordinates (y1, y2) on line we can simply check following condition: uy1 = uy2 = k.425E - Sereja and SetsFirst, lets look at F(S). First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don't intersected with last taken to the optimal set, we get our current to the set.Our solution will be based on this greedy. Solution of the problem is next dynamic:1). number of position of second coordinte of interval2). number of intervals in good set3). second coordinate of last taken interval to the optimal set How should we make transfers? Lets note that when we know dpi, count, last we can change last by i, or not change at all. Lets look what happens in every case. In first case last is changed by i, so we should take to optimal set atleast one of the inervals: [last + 1, i], [last + 2, i], ..., [i, i], number of such intervals i - last, number of ways to get at least one of them is 2i - last - 1. All other intervals: [1, i], [2, i], ..., [last, i] we could get as we wish, so we have 2last ways. So total number of transfers from dpi, count, last to dpi + 1, count + 1, i is (2i - last - 1)·(2last). If we count number of transfers from dpi, count, last to dpi + 1, count, last, we can simply use number 2last(as described early). Also we shouldn't forget about trivial case dpi, 0, 0. So now we have quite easy solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 426 和字母"
          },
          "content_length": 5266
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 10, \"k\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random grid\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(0, 1);\n            }\n        }\n    } else if (type == \"valid\") {\n        // Generate valid grid\n        // Decide number of horizontal and vertical cuts\n        int num_h_cuts = rnd.next(1, n);\n        int num_v_cuts = rnd.next(1, m);\n\n        vector<int> h_positions;\n        if (num_h_cuts > 1) {\n            h_positions = rnd.distinct(num_h_cuts - 1, 1, n - 1);\n            sort(h_positions.begin(), h_positions.end());\n        }\n        vector<int> v_positions;\n        if (num_v_cuts > 1) {\n            v_positions = rnd.distinct(num_v_cuts - 1, 1, m - 1);\n            sort(v_positions.begin(), v_positions.end());\n        }\n\n        // Build row ranges\n        vector<pair<int, int>> row_ranges;\n        int last = 0;\n        for (int cut : h_positions) {\n            row_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        row_ranges.emplace_back(last, n - 1);\n\n        // Build column ranges\n        vector<pair<int, int>> col_ranges;\n        last = 0;\n        for (int cut : v_positions) {\n            col_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        col_ranges.emplace_back(last, m - 1);\n\n        // Assign values to rectangles in checkerboard pattern\n        for (size_t i = 0; i < row_ranges.size(); ++i) {\n            for (size_t j = 0; j < col_ranges.size(); ++j) {\n                int val = (i + j) % 2;\n                for (int x = row_ranges[i].first; x <= row_ranges[i].second; ++x) {\n                    for (int y = col_ranges[j].first; y <= col_ranges[j].second; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n    } else if (type == \"invalid\") {\n        // Start with a valid grid\n        // Then flip some cells to make it invalid\n        // Generate valid grid\n        int num_h_cuts = rnd.next(1, n);\n        int num_v_cuts = rnd.next(1, m);\n\n        vector<int> h_positions;\n        if (num_h_cuts > 1) {\n            h_positions = rnd.distinct(num_h_cuts - 1, 1, n - 1);\n            sort(h_positions.begin(), h_positions.end());\n        }\n        vector<int> v_positions;\n        if (num_v_cuts > 1) {\n            v_positions = rnd.distinct(num_v_cuts - 1, 1, m - 1);\n            sort(v_positions.begin(), v_positions.end());\n        }\n\n        // Build row ranges\n        vector<pair<int, int>> row_ranges;\n        int last = 0;\n        for (int cut : h_positions) {\n            row_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        row_ranges.emplace_back(last, n - 1);\n\n        // Build column ranges\n        vector<pair<int, int>> col_ranges;\n        last = 0;\n        for (int cut : v_positions) {\n            col_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        col_ranges.emplace_back(last, m - 1);\n\n        // Assign values to rectangles in checkerboard pattern\n        for (size_t i = 0; i < row_ranges.size(); ++i) {\n            for (size_t j = 0; j < col_ranges.size(); ++j) {\n                int val = (i + j) % 2;\n                for (int x = row_ranges[i].first; x <= row_ranges[i].second; ++x) {\n                    for (int y = col_ranges[j].first; y <= col_ranges[j].second; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n\n        // Flip some cells to make it invalid\n        int num_flips = rnd.next(1, k);\n        for (int i = 0; i < num_flips; ++i) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            grid[x][y] ^= 1;\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a grid that cannot be fixed within k changes\n        // For simplicity, create an 'L' shaped connected component that needs at least k+1 changes\n\n        // Fill grid with 1s\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n\n        // Create an 'L' shaped 0s connected component\n        int len = k + 1;\n        len = min(len, min(n, m));\n\n        for (int i = 0; i < len; ++i) {\n            grid[0][i] = 0; // First row\n            grid[i][0] = 0; // First column\n        }\n\n    } else if (type == \"min_changes\") {\n        // Generate a valid grid, then flip k cells\n        // Generate valid grid\n        int num_h_cuts = rnd.next(1, n);\n        int num_v_cuts = rnd.next(1, m);\n\n        vector<int> h_positions;\n        if (num_h_cuts > 1) {\n            h_positions = rnd.distinct(num_h_cuts - 1, 1, n - 1);\n            sort(h_positions.begin(), h_positions.end());\n        }\n        vector<int> v_positions;\n        if (num_v_cuts > 1) {\n            v_positions = rnd.distinct(num_v_cuts - 1, 1, m - 1);\n            sort(v_positions.begin(), v_positions.end());\n        }\n\n        // Build row ranges\n        vector<pair<int, int>> row_ranges;\n        int last = 0;\n        for (int cut : h_positions) {\n            row_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        row_ranges.emplace_back(last, n - 1);\n\n        // Build column ranges\n        vector<pair<int, int>> col_ranges;\n        last = 0;\n        for (int cut : v_positions) {\n            col_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        col_ranges.emplace_back(last, m - 1);\n\n        // Assign values to rectangles in checkerboard pattern\n        for (size_t i = 0; i < row_ranges.size(); ++i) {\n            for (size_t j = 0; j < col_ranges.size(); ++j) {\n                int val = (i + j) % 2;\n                for (int x = row_ranges[i].first; x <= row_ranges[i].second; ++x) {\n                    for (int y = col_ranges[j].first; y <= col_ranges[j].second; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n\n        // Flip k cells to make it invalid\n        for (int i = 0; i < k; ++i) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            grid[x][y] ^= 1;\n        }\n\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Generate random grid\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(0, 1);\n            }\n        }\n    } else if (type == \"valid\") {\n        // Generate valid grid\n        // Decide number of horizontal and vertical cuts\n        int num_h_cuts = rnd.next(1, n);\n        int num_v_cuts = rnd.next(1, m);\n\n        vector<int> h_positions;\n        if (num_h_cuts > 1) {\n            h_positions = rnd.distinct(num_h_cuts - 1, 1, n - 1);\n            sort(h_positions.begin(), h_positions.end());\n        }\n        vector<int> v_positions;\n        if (num_v_cuts > 1) {\n            v_positions = rnd.distinct(num_v_cuts - 1, 1, m - 1);\n            sort(v_positions.begin(), v_positions.end());\n        }\n\n        // Build row ranges\n        vector<pair<int, int>> row_ranges;\n        int last = 0;\n        for (int cut : h_positions) {\n            row_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        row_ranges.emplace_back(last, n - 1);\n\n        // Build column ranges\n        vector<pair<int, int>> col_ranges;\n        last = 0;\n        for (int cut : v_positions) {\n            col_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        col_ranges.emplace_back(last, m - 1);\n\n        // Assign values to rectangles in checkerboard pattern\n        for (size_t i = 0; i < row_ranges.size(); ++i) {\n            for (size_t j = 0; j < col_ranges.size(); ++j) {\n                int val = (i + j) % 2;\n                for (int x = row_ranges[i].first; x <= row_ranges[i].second; ++x) {\n                    for (int y = col_ranges[j].first; y <= col_ranges[j].second; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n    } else if (type == \"invalid\") {\n        // Start with a valid grid\n        // Then flip some cells to make it invalid\n        // Generate valid grid\n        int num_h_cuts = rnd.next(1, n);\n        int num_v_cuts = rnd.next(1, m);\n\n        vector<int> h_positions;\n        if (num_h_cuts > 1) {\n            h_positions = rnd.distinct(num_h_cuts - 1, 1, n - 1);\n            sort(h_positions.begin(), h_positions.end());\n        }\n        vector<int> v_positions;\n        if (num_v_cuts > 1) {\n            v_positions = rnd.distinct(num_v_cuts - 1, 1, m - 1);\n            sort(v_positions.begin(), v_positions.end());\n        }\n\n        // Build row ranges\n        vector<pair<int, int>> row_ranges;\n        int last = 0;\n        for (int cut : h_positions) {\n            row_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        row_ranges.emplace_back(last, n - 1);\n\n        // Build column ranges\n        vector<pair<int, int>> col_ranges;\n        last = 0;\n        for (int cut : v_positions) {\n            col_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        col_ranges.emplace_back(last, m - 1);\n\n        // Assign values to rectangles in checkerboard pattern\n        for (size_t i = 0; i < row_ranges.size(); ++i) {\n            for (size_t j = 0; j < col_ranges.size(); ++j) {\n                int val = (i + j) % 2;\n                for (int x = row_ranges[i].first; x <= row_ranges[i].second; ++x) {\n                    for (int y = col_ranges[j].first; y <= col_ranges[j].second; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n\n        // Flip some cells to make it invalid\n        int num_flips = rnd.next(1, k);\n        for (int i = 0; i < num_flips; ++i) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            grid[x][y] ^= 1;\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a grid that cannot be fixed within k changes\n        // For simplicity, create an 'L' shaped connected component that needs at least k+1 changes\n\n        // Fill grid with 1s\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n\n        // Create an 'L' shaped 0s connected component\n        int len = k + 1;\n        len = min(len, min(n, m));\n\n        for (int i = 0; i < len; ++i) {\n            grid[0][i] = 0; // First row\n            grid[i][0] = 0; // First column\n        }\n\n    } else if (type == \"min_changes\") {\n        // Generate a valid grid, then flip k cells\n        // Generate valid grid\n        int num_h_cuts = rnd.next(1, n);\n        int num_v_cuts = rnd.next(1, m);\n\n        vector<int> h_positions;\n        if (num_h_cuts > 1) {\n            h_positions = rnd.distinct(num_h_cuts - 1, 1, n - 1);\n            sort(h_positions.begin(), h_positions.end());\n        }\n        vector<int> v_positions;\n        if (num_v_cuts > 1) {\n            v_positions = rnd.distinct(num_v_cuts - 1, 1, m - 1);\n            sort(v_positions.begin(), v_positions.end());\n        }\n\n        // Build row ranges\n        vector<pair<int, int>> row_ranges;\n        int last = 0;\n        for (int cut : h_positions) {\n            row_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        row_ranges.emplace_back(last, n - 1);\n\n        // Build column ranges\n        vector<pair<int, int>> col_ranges;\n        last = 0;\n        for (int cut : v_positions) {\n            col_ranges.emplace_back(last, cut - 1);\n            last = cut;\n        }\n        col_ranges.emplace_back(last, m - 1);\n\n        // Assign values to rectangles in checkerboard pattern\n        for (size_t i = 0; i < row_ranges.size(); ++i) {\n            for (size_t j = 0; j < col_ranges.size(); ++j) {\n                int val = (i + j) % 2;\n                for (int x = row_ranges[i].first; x <= row_ranges[i].second; ++x) {\n                    for (int y = col_ranges[j].first; y <= col_ranges[j].second; ++y) {\n                        grid[x][y] = val;\n                    }\n                }\n            }\n        }\n\n        // Flip k cells to make it invalid\n        for (int i = 0; i < k; ++i) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            grid[x][y] ^= 1;\n        }\n\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -type random\n./gen -n 1 -m 1 -k 1 -type valid\n./gen -n 1 -m 1 -k 1 -type invalid\n\n./gen -n 2 -m 2 -k 1 -type random\n./gen -n 2 -m 2 -k 1 -type valid\n./gen -n 2 -m 2 -k 1 -type invalid\n\n./gen -n 10 -m 10 -k 5 -type random\n./gen -n 10 -m 10 -k 5 -type valid\n./gen -n 10 -m 10 -k 5 -type invalid\n./gen -n 10 -m 10 -k 5 -type impossible\n./gen -n 10 -m 10 -k 5 -type min_changes\n\n./gen -n 50 -m 50 -k 10 -type random\n./gen -n 50 -m 50 -k 10 -type valid\n./gen -n 50 -m 50 -k 10 -type invalid\n\n./gen -n 100 -m 100 -k 10 -type random\n./gen -n 100 -m 100 -k 10 -type valid\n./gen -n 100 -m 100 -k 10 -type invalid\n./gen -n 100 -m 100 -k 10 -type impossible\n./gen -n 100 -m 100 -k 10 -type min_changes\n\n./gen -n 99 -m 95 -k 10 -type random\n./gen -n 99 -m 95 -k 5 -type valid\n./gen -n 99 -m 95 -k 1 -type invalid\n\n./gen -n 100 -m 1 -k 10 -type random\n./gen -n 1 -m 100 -k 10 -type random\n\n./gen -n 100 -m 100 -k 1 -type random\n./gen -n 100 -m 100 -k 10 -type random\n\n./gen -n 100 -m 100 -k 1 -type impossible\n./gen -n 100 -m 100 -k 10 -type impossible\n\n./gen -n 100 -m 100 -k 1 -type min_changes\n./gen -n 100 -m 100 -k 10 -type min_changes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:13.969064",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "426/E",
      "title": "E. Sereja and Two Sequences",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains integers n, m, s, e (1 ≤ n, m ≤ 105; 1 ≤ s ≤ 3·105; 103 ≤ e ≤ 104). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 105). The third line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 105).",
      "output_spec": "OutputPrint a single integer — maximum number of money in dollars that Sereja can get.",
      "sample_tests": "ExamplesInputCopy5 5 100000 10001 2 3 4 53 2 4 5 1OutputCopy3InputCopy3 4 3006 10001 2 31 2 4 3OutputCopy2",
      "description": "E. Sereja and Two Sequences\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integers n, m, s, e (1 ≤ n, m ≤ 105; 1 ≤ s ≤ 3·105; 103 ≤ e ≤ 104). The second line contains n integers a1, a2, ..., an (1 ≤ ai ≤ 105). The third line contains m integers b1, b2, ..., bm (1 ≤ bi ≤ 105).\n\nOutputPrint a single integer — maximum number of money in dollars that Sereja can get.\n\nInputCopy5 5 100000 10001 2 3 4 53 2 4 5 1OutputCopy3InputCopy3 4 3006 10001 2 31 2 4 3OutputCopy2\n\nInputCopy5 5 100000 10001 2 3 4 53 2 4 5 1\n\nOutputCopy3\n\nInputCopy3 4 3006 10001 2 31 2 4 3\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces",
          "content": "426A - Sereja and MugsLets count the sum of all elements Sum and value of the maximal element M. If Sum - M ≤ S then answer is yes, otherwise — no.426B - Sereja and MirroringLets solve problem from another side. We will try to cut of matix as many times as we can. Cut means operation, reversed to operation described in statement. To check, can we cut matrix we need to check following conditions:1). n mod 2 = 02). ai, j = an - i + 1, j for all 1 ≤ i ≤ n, 1 ≤ j ≤ m.425A - Sereja and SwapsLets backtrack interval on which will contain maximal sum. To improve our sum we can swap not more then k minimal elements from the interval to k maximal elements that don't belong to interval. As n isn't big we can do it in any way. Author solution sort all elemets from interval in increasing order and all elements that don't belong to interval by descreasing order. We will swap elements one by one while we haven't done k swaps and we have some unswaped elements in first set and we have some unswaped elemets in second set and swap is optimal(we will optimize the answer after this swap). Author solution works in time O(n3·log(n)). Is there some ideas how to solve this problem in time O(n) or O(n·log(n)) ? 425B - Sereja and Table Note, that if we have two arrays x[1..n], 0 ≤ xi ≤ 1 and y[1..m], 0 ≤ yi ≤ 1, then described matrix can be showed as next one: ai, j = xi xor yj.If n ≤ k, then we can backtrack array x and using greedy find best y. Otherwise there will be atleast one i, such that we will not change any cell in row number i. So we can simply bruteforce some row and use it like x. Then we use greedy and find y. From all possible rows we choose most optimal. Such row will be as number of mistakes is lower then number of rows, so it isn't possible to have atleast one mistake in each row. Greedy means next algorithm: for every element of y we will look, will it be better to choose it like 0 or 1. To find better choise, we will count number of different bits in x and current(lets it be j) column. If number of different if lower then count of same cells we will set yj = 0, otherwise yj = 1.425C - Sereja and Two SequencesIn thgis problem we will use dynamic programming: dpi, j — minimal pozition of deleted element in second array, such that we have made first operation j times and have deleted not more then i elements from first array. Lets decided how to calculate transfers. Standing in pozition dpi, j we can change nothing and go to pozition dpi + 1, j, by other words make transfer dpi + 1, j:  = min(dpi + 1, j, dpi, j). What happens when we make first operation with fixed prefix(by i-th element) in first array? We should find element in second array with number greater dpi, j and value equal to ai, lets its pozition is t, so we need to make transfer dpi + 1, j + 1:  = min(dpi + 1, j + 1, t). How to find required element quickly: lets just do vector of pozition in second array for all different elements that contains in second array. Then we can simply use binary search. 425D - Sereja and SquaresLets line x = k contain not more then points. Then for each pair of points on this line (lets it be (k, y1) and (k, y2)) check: is there squere that contain them as vertexes. So we should check: is there(in input) pair of points (k - |y2 - y1|, y1) and (k - |y2 - y1|, y2), or pair (k + |y2 - y1|, y1) and (k + |y2 - y1|, y2). Lets delete all watched points, and reverse points about line x = y. Then each line x = k will contain not more then points. Will solve problem in the same way. Now we should learn: how to check is some pair of points(on one vertical line) in input. Lets write all of this pairs in vectors. Each vector(for every line) will contain pairs that we should check on it. Suppose, that we check it for line number k. Lets mark in some array u for all points with x-coordinate equal to k uy = k. Now to check is our pair with y-coordinates (y1, y2) on line we can simply check following condition: uy1 = uy2 = k.425E - Sereja and SetsFirst, lets look at F(S). First, we sort all intervals by second coordinte and then go by them in sorted order. And if current interval don't intersected with last taken to the optimal set, we get our current to the set.Our solution will be based on this greedy. Solution of the problem is next dynamic:1). number of position of second coordinte of interval2). number of intervals in good set3). second coordinate of last taken interval to the optimal set How should we make transfers? Lets note that when we know dpi, count, last we can change last by i, or not change at all. Lets look what happens in every case. In first case last is changed by i, so we should take to optimal set atleast one of the inervals: [last + 1, i], [last + 2, i], ..., [i, i], number of such intervals i - last, number of ways to get at least one of them is 2i - last - 1. All other intervals: [1, i], [2, i], ..., [last, i] we could get as we wish, so we have 2last ways. So total number of transfers from dpi, count, last to dpi + 1, count + 1, i is (2i - last - 1)·(2last). If we count number of transfers from dpi, count, last to dpi + 1, count, last, we can simply use number 2last(as described early). Also we shouldn't forget about trivial case dpi, 0, 0. So now we have quite easy solution.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/11998",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 426 和字母"
          },
          "content_length": 5266
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 1",
          "code": "31 ms < 93 ms",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 2",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 3",
          "code": "TEST #2\n3 4 3006 1000\n1 2 3\n1 2 4 3\n\nans = 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 4",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 5",
          "code": "TEST #4\n4 3 100000 1290\n75575 42837 79021 96022\n42837 79021 96022\n\nans = 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 6",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #243 tutorial - Codeforces - Code 7",
          "code": "while(_in < in && _ot && k--){\n                int a = x[_in++],b=y[_ot--];\n                res+=(a > b)?a:b;\n            }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/11998",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, 300000, \"s\");\n    inf.readSpace();\n    int e = inf.readInt(1000, 10000, \"e\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readInts(m, 1, 100000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, 300000, \"s\");\n    inf.readSpace();\n    int e = inf.readInt(1000, 10000, \"e\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readInts(m, 1, 100000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int s = inf.readInt(1, 300000, \"s\");\n    inf.readSpace();\n    int e = inf.readInt(1000, 10000, \"e\");\n    inf.readEoln();\n\n    inf.readInts(n, 1, 100000, \"a_i\");\n    inf.readEoln();\n\n    inf.readInts(m, 1, 100000, \"b_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n\n    int s = opt<int>(\"s\", 1); // default s = 1\n    int e = opt<int>(\"e\", 1000); // default e = 1000\n    string type = opt<string>(\"type\", \"random\"); // default type = \"random\"\n\n    // Constraints according to the problem\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 100000);\n    ensure(1 <= s && s <= 300000);\n    ensure(1000 <= e && e <= 10000);\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"max_matches\") {\n        // We want to maximize the number of possible Move 1's\n        int k = min(n, m);\n\n        // Generate sequences where the elements are equal at each position\n        for (int i = 0; i < k; ++i) {\n            // Assign same value to a[i] and b[i]\n            a[i] = b[i] = rnd.next(1, 100000);\n        }\n\n        // Fill the rest with random numbers\n        for (int i = k; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = k; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"no_matches\") {\n        // Generate sequences where there are no matches in any prefixes\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n        // Ensure that there is no possible match between any prefixes\n        // One way is to ensure that a_i != b_j for any i,j\n        set<int> vals;\n        for (int i = 0; i < n; ++i) {\n            vals.insert(a[i]);\n        }\n        for (int i = 0; i < m; ++i) {\n            int val;\n            do {\n                val = rnd.next(1, 100000);\n            } while (vals.count(val));\n            b[i] = val;\n        }\n    } else if (type == \"random\") {\n        // Generate completely random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"single_match\") {\n        // Make only one possible match at some point\n        // First fill random elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(2, 100000);\n        }\n        // Set a[k], b[l] to 1, where k and l are random positions\n        int k = rnd.next(0, n - 1);\n        int l = rnd.next(0, m - 1);\n        a[k] = b[l] = 1;\n    } else if (type == \"long_prefix_match\") {\n        // Force a match only if we take long prefixes\n        int match_value = rnd.next(1, 100000);\n        // Fill a with random values except the last\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        a[n - 1] = match_value;\n        // Similarly for b\n        for (int i = 0; i < m - 1; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n        b[m - 1] = match_value;\n    } else if (type == \"max_s\") {\n        // Use maximum s\n        s = 300000;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"min_s\") {\n        // Use minimum s\n        s = 1;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"min_e\") {\n        // Use minimum e\n        e = 1000;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"max_e\") {\n        // Use maximum e\n        e = 10000;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"large_elements\") {\n        // Use maximum possible a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 100000;\n        }\n    } else if (type == \"small_elements\") {\n        // Use minimum possible a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    } else {\n        // Default to random sequences if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, s, e);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n\n    int s = opt<int>(\"s\", 1); // default s = 1\n    int e = opt<int>(\"e\", 1000); // default e = 1000\n    string type = opt<string>(\"type\", \"random\"); // default type = \"random\"\n\n    // Constraints according to the problem\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 100000);\n    ensure(1 <= s && s <= 300000);\n    ensure(1000 <= e && e <= 10000);\n\n    vector<int> a(n);\n    vector<int> b(m);\n\n    if (type == \"max_matches\") {\n        // We want to maximize the number of possible Move 1's\n        int k = min(n, m);\n\n        // Generate sequences where the elements are equal at each position\n        for (int i = 0; i < k; ++i) {\n            // Assign same value to a[i] and b[i]\n            a[i] = b[i] = rnd.next(1, 100000);\n        }\n\n        // Fill the rest with random numbers\n        for (int i = k; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = k; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n\n    } else if (type == \"no_matches\") {\n        // Generate sequences where there are no matches in any prefixes\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n        // Ensure that there is no possible match between any prefixes\n        // One way is to ensure that a_i != b_j for any i,j\n        set<int> vals;\n        for (int i = 0; i < n; ++i) {\n            vals.insert(a[i]);\n        }\n        for (int i = 0; i < m; ++i) {\n            int val;\n            do {\n                val = rnd.next(1, 100000);\n            } while (vals.count(val));\n            b[i] = val;\n        }\n    } else if (type == \"random\") {\n        // Generate completely random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"single_match\") {\n        // Make only one possible match at some point\n        // First fill random elements\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(2, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(2, 100000);\n        }\n        // Set a[k], b[l] to 1, where k and l are random positions\n        int k = rnd.next(0, n - 1);\n        int l = rnd.next(0, m - 1);\n        a[k] = b[l] = 1;\n    } else if (type == \"long_prefix_match\") {\n        // Force a match only if we take long prefixes\n        int match_value = rnd.next(1, 100000);\n        // Fill a with random values except the last\n        for (int i = 0; i < n - 1; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        a[n - 1] = match_value;\n        // Similarly for b\n        for (int i = 0; i < m - 1; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n        b[m - 1] = match_value;\n    } else if (type == \"max_s\") {\n        // Use maximum s\n        s = 300000;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"min_s\") {\n        // Use minimum s\n        s = 1;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"min_e\") {\n        // Use minimum e\n        e = 1000;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"max_e\") {\n        // Use maximum e\n        e = 10000;\n        // Generate random sequences\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    } else if (type == \"large_elements\") {\n        // Use maximum possible a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 100000;\n        }\n    } else if (type == \"small_elements\") {\n        // Use minimum possible a_i and b_i\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = 1;\n        }\n    } else {\n        // Default to random sequences if type is unrecognized\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 100000);\n        }\n        for (int i = 0; i < m; ++i) {\n            b[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d %d\\n\", n, m, s, e);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -s 1 -e 1000 -type max_matches\n./gen -n 1 -m 1 -s 1000 -e 10000 -type no_matches\n./gen -n 10 -m 10 -s 10000 -e 5000 -type random\n./gen -n 100 -m 100 -s 100000 -e 1000 -type random\n./gen -n 1000 -m 1000 -s 200000 -e 5000 -type single_match\n./gen -n 50000 -m 50000 -s 300000 -e 10000 -type long_prefix_match\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type max_matches\n./gen -n 100000 -m 100000 -s 300000 -e 1000 -type no_matches\n./gen -n 100000 -m 100000 -s 300000 -e 1000 -type random\n./gen -n 100000 -m 100000 -s 1 -e 10000 -type min_s\n./gen -n 100000 -m 100000 -s 300000 -e 1000 -type max_s\n./gen -n 100000 -m 50000 -s 300000 -e 1000 -type random\n./gen -n 50000 -m 100000 -s 250000 -e 5000 -type large_elements\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type small_elements\n./gen -n 100000 -m 100000 -s 300000 -e 1000 -type min_e\n./gen -n 100000 -m 100000 -s 300000 -e 10000 -type max_e\n./gen -n 100000 -m 100000 -s 200000 -e 5000 -type random\n./gen -n 100000 -m 100000 -s 100000 -e 5000 -type random\n./gen -n 100000 -m 99999 -s 300000 -e 10000 -type random\n./gen -n 2 -m 2 -s 300000 -e 10000 -type max_matches\n./gen -n 2 -m 100000 -s 300000 -e 10000 -type long_prefix_match\n./gen -n 100000 -m 2 -s 300000 -e 10000 -type long_prefix_match\n./gen -n 100000 -m 100000 -s 300000 -e 5000 -type single_match\n./gen -n 100000 -m 100000 -s 300000 -e 5000 -type no_matches\n./gen -n 100000 -m 100000 -s 300000 -e 5000 -type random\n./gen -n 50 -m 50 -s 50 -e 1000 -type max_matches\n./gen -n 50 -m 50 -s 50 -e 1000 -type no_matches\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:15.988003",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "427/A",
      "title": "A. Police Recruits",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain an integer n (1 ≤ n ≤ 105), the number of events. The next line will contain n space-separated integers.If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.",
      "output_spec": "OutputPrint a single integer, the number of crimes which will go untreated.",
      "sample_tests": "ExamplesInputCopy3-1 -1 1OutputCopy2InputCopy81 -1 1 -1 -1 1 1 1OutputCopy1InputCopy11-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1OutputCopy8",
      "description": "A. Police Recruits\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input will contain an integer n (1 ≤ n ≤ 105), the number of events. The next line will contain n space-separated integers.If the integer is -1 then it means a crime has occurred. Otherwise, the integer will be positive, the number of officers recruited together at that time. No more than 10 officers will be recruited at a time.\n\nOutputPrint a single integer, the number of crimes which will go untreated.\n\nInputCopy3-1 -1 1OutputCopy2InputCopy81 -1 1 -1 -1 1 1 1OutputCopy1InputCopy11-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1OutputCopy8\n\nInputCopy3-1 -1 1\n\nOutputCopy2\n\nInputCopy81 -1 1 -1 -1 1 1 1\n\nOutputCopy1\n\nInputCopy11-1 -1 2 -1 -1 -1 -1 -1 -1 -1 -1\n\nOutputCopy8\n\nNoteLets consider the second example:  Firstly one person is hired.  Then crime appears, the last hired person will investigate this crime.  One more person is hired.  One more crime appears, the last hired person will investigate this crime.  Crime appears. There is no free policeman at the time, so this crime will go untreated.  One more person is hired.  One more person is hired.  One more person is hired. The answer is one, as one crime (on step 5) will go untreated.",
      "solutions": [
        {
          "title": "Codeforces Round #244 (Div. 2) - Codeforces",
          "content": "Good day everyone.Codeforces round #244 for division 2 participants will start at May 2, Friday, 19:30 MSK. As you all know, participants from division 1 can also take part from out of the competition.The round was prepared by me (Bidhan), student of University of Dhaka, Bangladesh. This is my first codeforces round. I have tried to prepare interesting and solvable problems for division 2 participants. Special effort was given to make the problem statements as clear as possible. Hoping that everything will go right and everyone will enjoy the round.Special thanks to msh_shiplu, lecturer of University of Dhaka, for his contribution to the contest by finding time to set one of the problems, writing alternates, reviewing problem statements and giving expert advice on dataset generation in spite of his hectic schedule.Also, a BIG thanks to nice guy Gerald, for helping throughout the preparation process.I wish all the participants good luck :)Update0 : Score distribution is 500-1000-1500-2000-2500.Update1 : A short editorial of the contest is here. The post will be enlarged to detailed editorial later.The Russian translation of this post is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12023",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1159
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces",
          "content": "The round statistics are nicely put by DmitriyH.427A - Police Recruits ( Author : Bidhan )Maintain a variable, sum. Initially sum=0, it keeps the number of currently free police officers. With every recruitment operation, add the number of officers recruited at that time to sum. When a crime occurs, if sum > 0 then decrease the number of free officers by one, otherwise no officers are free so the crime will go untreated.Model solution : 6546268427B - Prison Transfer ( Author : Bidhan )The severity of crimes form an integer sequence. Find all the contiguous sequences without any integer greater than t. If the length of any sequence is L, then we can choose c prisoners from them in L - c + 1 ways.Model solution : 6546272427C - Checkposts ( Author : Bidhan )Find the strongly connected components of the graph. From each component we need to choose a node with the lowest cost. If there are more than one nodes with lowest cost, then there are more than one way to choose node from this component.Model solution : 6546275427D - Match & Catch ( Author : msh_shiplu )O(n2) dynamic programming solution : Calculate the longest common prefix ( LCP ) for each index of s1 with each index of s2. Then, calculate LCP for each index of s1 with all the other indexes of it's own ( s1 ). Do the same for s2. Now from precalculated values, you can easily check the length of the shortest unique substring starting from any of the indexes of s1 or s2. Suppose i is an index of s1 and j is an index of s2. Find the LCP for i and j. Now, the minimum of the length of LCP, length of shortest unique substring starting from i, length of shortest unique substring starting from j is the answer for i,j. Now we need to find the minimum answer from all possible i,j pair. This problem can also be solved in by suffix array and in O(n) using suffix automaton.Model solution : 6546277427E - Police Patrol ( Author : Bidhan )Trying to place the police station on existing criminal locations is the best strategy. Calculate the cost from the leftmost criminal location, then sweep over the next locations. By doing some adjustments on the cost of the previous location will yield the cost of the current location.Model solution : 6546283",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12082",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 427\\s*A"
          },
          "content_length": 2221
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<string> events = inf.readTokens(n, \"-1|[1-9]|10\", \"events\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<string> events = inf.readTokens(n, \"-1|[1-9]|10\", \"events\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<string> events = inf.readTokens(n, \"-1|[1-9]|10\", \"events\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> events(n);\n\n    if (type == \"all_crimes\") {\n        for (int i = 0; i < n; ++i)\n            events[i] = -1;\n    } else if (type == \"all_recruits\") {\n        for (int i = 0; i < n; ++i)\n            events[i] = rnd.next(1, 10);\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                events[i] = -1;\n            else\n                events[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                events[i] = -1;\n            } else {\n                events[i] = rnd.next(1, 10);\n            }\n        }\n    } else if (type == \"initial_crimes\") {\n        int crimes = n / 2;\n        for (int i = 0; i < crimes; ++i)\n            events[i] = -1;\n        for (int i = crimes; i < n; ++i)\n            events[i] = rnd.next(1, 10);\n    } else if (type == \"initial_recruits\") {\n        int recruits = n / 2;\n        for (int i = 0; i < recruits; ++i)\n            events[i] = rnd.next(1, 10);\n        for (int i = recruits; i < n; ++i)\n            events[i] = -1;\n    } else if (type == \"initial_crimes_then_recruits\") {\n        for (int i = 0; i < n / 2; ++i)\n            events[i] = -1;\n        for (int i = n / 2; i < n; ++i)\n            events[i] = rnd.next(1, 10);\n    } else if (type == \"initial_recruits_then_crimes\") {\n        for (int i = 0; i < n / 2; ++i)\n            events[i] = rnd.next(1, 10);\n        for (int i = n / 2; i < n; ++i)\n            events[i] = -1;\n    } else if (type == \"max_crimes_before_hire\") {\n        int crimes = n - 1;\n        for (int i = 0; i < crimes; ++i)\n            events[i] = -1;\n        events[crimes] = rnd.next(1, 10); // Hire\n    } else if (type == \"max_recruits\") {\n        for (int i = 0; i < n; ++i)\n            events[i] = 10;\n    } else if (type == \"chunky\") {\n        int i = 0;\n        while (i < n) {\n            int chunk_size = rnd.next(1, 10);\n            int event_type = rnd.next(0, 1); // 0 for crimes, 1 for hires\n            int limit = min(n, i + chunk_size);\n            if (event_type == 0) {\n                for (; i < limit; ++i)\n                    events[i] = -1;\n            } else {\n                for (; i < limit; ++i)\n                    events[i] = rnd.next(1, 10);\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                events[i] = -1;\n            } else {\n                events[i] = rnd.next(1, 10);\n            }\n        }\n    }\n\n    // Output the events\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", events[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> events(n);\n\n    if (type == \"all_crimes\") {\n        for (int i = 0; i < n; ++i)\n            events[i] = -1;\n    } else if (type == \"all_recruits\") {\n        for (int i = 0; i < n; ++i)\n            events[i] = rnd.next(1, 10);\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                events[i] = -1;\n            else\n                events[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                events[i] = -1;\n            } else {\n                events[i] = rnd.next(1, 10);\n            }\n        }\n    } else if (type == \"initial_crimes\") {\n        int crimes = n / 2;\n        for (int i = 0; i < crimes; ++i)\n            events[i] = -1;\n        for (int i = crimes; i < n; ++i)\n            events[i] = rnd.next(1, 10);\n    } else if (type == \"initial_recruits\") {\n        int recruits = n / 2;\n        for (int i = 0; i < recruits; ++i)\n            events[i] = rnd.next(1, 10);\n        for (int i = recruits; i < n; ++i)\n            events[i] = -1;\n    } else if (type == \"initial_crimes_then_recruits\") {\n        for (int i = 0; i < n / 2; ++i)\n            events[i] = -1;\n        for (int i = n / 2; i < n; ++i)\n            events[i] = rnd.next(1, 10);\n    } else if (type == \"initial_recruits_then_crimes\") {\n        for (int i = 0; i < n / 2; ++i)\n            events[i] = rnd.next(1, 10);\n        for (int i = n / 2; i < n; ++i)\n            events[i] = -1;\n    } else if (type == \"max_crimes_before_hire\") {\n        int crimes = n - 1;\n        for (int i = 0; i < crimes; ++i)\n            events[i] = -1;\n        events[crimes] = rnd.next(1, 10); // Hire\n    } else if (type == \"max_recruits\") {\n        for (int i = 0; i < n; ++i)\n            events[i] = 10;\n    } else if (type == \"chunky\") {\n        int i = 0;\n        while (i < n) {\n            int chunk_size = rnd.next(1, 10);\n            int event_type = rnd.next(0, 1); // 0 for crimes, 1 for hires\n            int limit = min(n, i + chunk_size);\n            if (event_type == 0) {\n                for (; i < limit; ++i)\n                    events[i] = -1;\n            } else {\n                for (; i < limit; ++i)\n                    events[i] = rnd.next(1, 10);\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0, 1) == 0) {\n                events[i] = -1;\n            } else {\n                events[i] = rnd.next(1, 10);\n            }\n        }\n    }\n\n    // Output the events\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", events[i]);\n        if (i != n - 1)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_crimes\n./gen -n 1 -type all_recruits\n./gen -n 2 -type alternate\n./gen -n 2 -type random\n./gen -n 2 -type initial_crimes_then_recruits\n./gen -n 2 -type initial_recruits_then_crimes\n./gen -n 10 -type all_crimes\n./gen -n 10 -type all_recruits\n./gen -n 10 -type alternate\n./gen -n 10 -type random\n./gen -n 10 -type initial_crimes\n./gen -n 10 -type initial_recruits\n./gen -n 10 -type initial_crimes_then_recruits\n./gen -n 10 -type initial_recruits_then_crimes\n./gen -n 100 -type random\n./gen -n 100 -type chunky\n./gen -n 1000 -type random\n./gen -n 1000 -type chunky\n./gen -n 1000 -type alternate\n./gen -n 1000 -type initial_crimes\n./gen -n 1000 -type initial_recruits\n./gen -n 1000 -type max_crimes_before_hire\n./gen -n 1000 -type max_recruits\n./gen -n 99999 -type random\n./gen -n 100000 -type all_crimes\n./gen -n 100000 -type all_recruits\n./gen -n 100000 -type alternate\n./gen -n 100000 -type random\n./gen -n 100000 -type initial_crimes\n./gen -n 100000 -type initial_recruits\n./gen -n 100000 -type initial_crimes_then_recruits\n./gen -n 100000 -type initial_recruits_then_crimes\n./gen -n 100000 -type max_crimes_before_hire\n./gen -n 100000 -type max_recruits\n./gen -n 100000 -type chunky\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:17.759406",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "427/B",
      "title": "B. Prison Transfer",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input will contain three space separated integers n (1 ≤ n ≤ 2·105), t (0 ≤ t ≤ 109) and c (1 ≤ c ≤ n). The next line will contain n space separated integers, the ith integer is the severity ith prisoner's crime. The value of crime severities will be non-negative and will not exceed 109.",
      "output_spec": "OutputPrint a single integer — the number of ways you can choose the c prisoners.",
      "sample_tests": "ExamplesInputCopy4 3 32 3 1 1OutputCopy2InputCopy1 1 12OutputCopy0InputCopy11 4 22 2 0 7 3 2 2 4 9 1 4OutputCopy6",
      "description": "B. Prison Transfer\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input will contain three space separated integers n (1 ≤ n ≤ 2·105), t (0 ≤ t ≤ 109) and c (1 ≤ c ≤ n). The next line will contain n space separated integers, the ith integer is the severity ith prisoner's crime. The value of crime severities will be non-negative and will not exceed 109.\n\nOutputPrint a single integer — the number of ways you can choose the c prisoners.\n\nInputCopy4 3 32 3 1 1OutputCopy2InputCopy1 1 12OutputCopy0InputCopy11 4 22 2 0 7 3 2 2 4 9 1 4OutputCopy6\n\nInputCopy4 3 32 3 1 1\n\nOutputCopy2\n\nInputCopy1 1 12\n\nOutputCopy0\n\nInputCopy11 4 22 2 0 7 3 2 2 4 9 1 4\n\nOutputCopy6",
      "solutions": [
        {
          "title": "Codeforces Round #244 (Div. 2) - Codeforces",
          "content": "Good day everyone.Codeforces round #244 for division 2 participants will start at May 2, Friday, 19:30 MSK. As you all know, participants from division 1 can also take part from out of the competition.The round was prepared by me (Bidhan), student of University of Dhaka, Bangladesh. This is my first codeforces round. I have tried to prepare interesting and solvable problems for division 2 participants. Special effort was given to make the problem statements as clear as possible. Hoping that everything will go right and everyone will enjoy the round.Special thanks to msh_shiplu, lecturer of University of Dhaka, for his contribution to the contest by finding time to set one of the problems, writing alternates, reviewing problem statements and giving expert advice on dataset generation in spite of his hectic schedule.Also, a BIG thanks to nice guy Gerald, for helping throughout the preparation process.I wish all the participants good luck :)Update0 : Score distribution is 500-1000-1500-2000-2500.Update1 : A short editorial of the contest is here. The post will be enlarged to detailed editorial later.The Russian translation of this post is here.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12023",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1159
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces",
          "content": "The round statistics are nicely put by DmitriyH.427A - Police Recruits ( Author : Bidhan )Maintain a variable, sum. Initially sum=0, it keeps the number of currently free police officers. With every recruitment operation, add the number of officers recruited at that time to sum. When a crime occurs, if sum > 0 then decrease the number of free officers by one, otherwise no officers are free so the crime will go untreated.Model solution : 6546268427B - Prison Transfer ( Author : Bidhan )The severity of crimes form an integer sequence. Find all the contiguous sequences without any integer greater than t. If the length of any sequence is L, then we can choose c prisoners from them in L - c + 1 ways.Model solution : 6546272427C - Checkposts ( Author : Bidhan )Find the strongly connected components of the graph. From each component we need to choose a node with the lowest cost. If there are more than one nodes with lowest cost, then there are more than one way to choose node from this component.Model solution : 6546275427D - Match & Catch ( Author : msh_shiplu )O(n2) dynamic programming solution : Calculate the longest common prefix ( LCP ) for each index of s1 with each index of s2. Then, calculate LCP for each index of s1 with all the other indexes of it's own ( s1 ). Do the same for s2. Now from precalculated values, you can easily check the length of the shortest unique substring starting from any of the indexes of s1 or s2. Suppose i is an index of s1 and j is an index of s2. Find the LCP for i and j. Now, the minimum of the length of LCP, length of shortest unique substring starting from i, length of shortest unique substring starting from j is the answer for i,j. Now we need to find the minimum answer from all possible i,j pair. This problem can also be solved in by suffix array and in O(n) using suffix automaton.Model solution : 6546277427E - Police Patrol ( Author : Bidhan )Trying to place the police station on existing criminal locations is the best strategy. Calculate the cost from the leftmost criminal location, then sweep over the next locations. By doing some adjustments on the cost of the previous location will yield the cost of the current location.Model solution : 6546283",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12082",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 427\\s*B"
          },
          "content_length": 2221
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(0, 1000000000, \"t\");\n    inf.readSpace();\n    int c = inf.readInt(1, n, \"c\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, 1000000000, \"crime severities\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(0, 1000000000, \"t\");\n    inf.readSpace();\n    int c = inf.readInt(1, n, \"c\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, 1000000000, \"crime severities\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int t = inf.readInt(0, 1000000000, \"t\");\n    inf.readSpace();\n    int c = inf.readInt(1, n, \"c\");\n    inf.readEoln();\n\n    inf.readInts(n, 0, 1000000000, \"crime severities\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gen_s_greater_than_t(int t) {\n    if (t < int(1e9)) {\n        return rnd.next(t + 1, int(1e9));\n    } else {\n        // Cannot generate s_i > t when t is maximum\n        // Return t (maximum allowed severity)\n        return t;\n    }\n}\n\nint gen_s_less_than_or_equal_t(int t) {\n    return rnd.next(0, t);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"all_good\") {\n        // All prisoners have severity ≤ t\n        for (int i = 0; i < n; ++i) {\n            s[i] = gen_s_less_than_or_equal_t(t);\n        }\n    } else if (type == \"all_bad\") {\n        // All prisoners have severity > t (if possible)\n        for (int i = 0; i < n; ++i) {\n            s[i] = gen_s_greater_than_t(t);\n        }\n    } else if (type == \"alternating\") {\n        // Severities alternate between ≤ t and > t\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n    } else if (type == \"single_long_good\") {\n        // One long segment of 'good' prisoners (severity ≤ t)\n        int len = rnd.next(c, n);\n        int start = rnd.next(0, n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i >= start && i < start + len) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n    } else if (type == \"single_long_bad\") {\n        // One long segment of 'bad' prisoners (severity > t)\n        int len = rnd.next(c, n);\n        int start = rnd.next(0, n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i >= start && i < start + len) {\n                s[i] = gen_s_greater_than_t(t);\n            } else {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            }\n        }\n    } else if (type == \"random_with_long_good\") {\n        // Random severities but ensure there's a long 'good' segment\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0,1)) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n        int len = rnd.next(c, n);\n        int start = rnd.next(0, n - len);\n        for (int i = start; i < start + len; ++i) {\n            s[i] = gen_s_less_than_or_equal_t(t);\n        }\n    } else {\n        // Default random assignment\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0,1)) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, t, c);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint gen_s_greater_than_t(int t) {\n    if (t < int(1e9)) {\n        return rnd.next(t + 1, int(1e9));\n    } else {\n        // Cannot generate s_i > t when t is maximum\n        // Return t (maximum allowed severity)\n        return t;\n    }\n}\n\nint gen_s_less_than_or_equal_t(int t) {\n    return rnd.next(0, t);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n    int c = opt<int>(\"c\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> s(n);\n\n    if (type == \"all_good\") {\n        // All prisoners have severity ≤ t\n        for (int i = 0; i < n; ++i) {\n            s[i] = gen_s_less_than_or_equal_t(t);\n        }\n    } else if (type == \"all_bad\") {\n        // All prisoners have severity > t (if possible)\n        for (int i = 0; i < n; ++i) {\n            s[i] = gen_s_greater_than_t(t);\n        }\n    } else if (type == \"alternating\") {\n        // Severities alternate between ≤ t and > t\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n    } else if (type == \"single_long_good\") {\n        // One long segment of 'good' prisoners (severity ≤ t)\n        int len = rnd.next(c, n);\n        int start = rnd.next(0, n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i >= start && i < start + len) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n    } else if (type == \"single_long_bad\") {\n        // One long segment of 'bad' prisoners (severity > t)\n        int len = rnd.next(c, n);\n        int start = rnd.next(0, n - len);\n        for (int i = 0; i < n; ++i) {\n            if (i >= start && i < start + len) {\n                s[i] = gen_s_greater_than_t(t);\n            } else {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            }\n        }\n    } else if (type == \"random_with_long_good\") {\n        // Random severities but ensure there's a long 'good' segment\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0,1)) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n        int len = rnd.next(c, n);\n        int start = rnd.next(0, n - len);\n        for (int i = start; i < start + len; ++i) {\n            s[i] = gen_s_less_than_or_equal_t(t);\n        }\n    } else {\n        // Default random assignment\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(0,1)) {\n                s[i] = gen_s_less_than_or_equal_t(t);\n            } else {\n                s[i] = gen_s_greater_than_t(t);\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, t, c);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", s[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -t 0 -c 1 -type all_good\n./gen -n 1 -t 0 -c 1 -type all_bad\n./gen -n 1 -t 1000000000 -c 1 -type all_good\n./gen -n 1 -t 1000000000 -c 1 -type all_bad\n\n./gen -n 10 -t 5 -c 1 -type random\n./gen -n 10 -t 5 -c 10 -type random\n./gen -n 10 -t 5 -c 5 -type alternating\n./gen -n 10 -t 5 -c 5 -type single_long_good\n\n./gen -n 100 -t 0 -c 1 -type all_good\n./gen -n 100 -t 0 -c 1 -type all_bad\n./gen -n 100 -t 1000000000 -c 1 -type all_good\n./gen -n 100 -t 1000000000 -c 100 -type all_good\n./gen -n 100 -t 1000000000 -c 100 -type random\n\n./gen -n 1000 -t 500000000 -c 1 -type random\n./gen -n 1000 -t 500000000 -c 1000 -type single_long_good\n./gen -n 1000 -t 500000000 -c 500 -type single_long_bad\n\n./gen -n 10000 -t 1000000000 -c 5000 -type random\n./gen -n 10000 -t 0 -c 1 -type random\n\n./gen -n 100000 -t 100 -c 50000 -type random_with_long_good\n./gen -n 100000 -t 0 -c 1 -type alternating\n\n./gen -n 200000 -t 1000000000 -c 100000 -type all_good\n./gen -n 200000 -t 1000000000 -c 200000 -type all_good\n./gen -n 200000 -t 1000000000 -c 200000 -type random\n./gen -n 200000 -t 0 -c 1 -type all_bad\n./gen -n 200000 -t 1000000000 -c 1 -type random_with_long_good\n./gen -n 200000 -t 999999999 -c 1 -type random\n./gen -n 200000 -t 999999999 -c 100000 -type random_with_long_good\n./gen -n 200000 -t 999999999 -c 200000 -type single_long_bad\n\n./gen -n 198765 -t 500000000 -c 98765 -type random\n./gen -n 200000 -t 123456789 -c 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:19.922060",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "427/C",
      "title": "C. Checkposts",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line, you will be given an integer n, number of junctions (1 ≤ n ≤ 105). In the next line, n space-separated integers will be given. The ith integer is the cost of building checkpost at the ith junction (costs will be non-negative and will not exceed 109).The next line will contain an integer m (0 ≤ m ≤ 3·105). And each of the next m lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; u ≠ v). A pair ui, vi means, that there is a one-way road which goes from ui to vi. There will not be more than one road between two nodes in the same direction.",
      "output_spec": "OutputPrint two integers separated by spaces. The first one is the minimum possible money needed to ensure the security of all the junctions. And the second one is the number of ways you can ensure the security modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy31 2 331 22 33 2OutputCopy3 1InputCopy52 8 0 6 061 41 32 43 44 55 1OutputCopy8 2InputCopy101 3 2 2 1 3 1 4 10 10121 22 33 13 44 55 65 76 47 38 99 1010 9OutputCopy15 6InputCopy27 9121 22 1OutputCopy7 1",
      "description": "C. Checkposts\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputIn the first line, you will be given an integer n, number of junctions (1 ≤ n ≤ 105). In the next line, n space-separated integers will be given. The ith integer is the cost of building checkpost at the ith junction (costs will be non-negative and will not exceed 109).The next line will contain an integer m (0 ≤ m ≤ 3·105). And each of the next m lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; u ≠ v). A pair ui, vi means, that there is a one-way road which goes from ui to vi. There will not be more than one road between two nodes in the same direction.\n\nOutputPrint two integers separated by spaces. The first one is the minimum possible money needed to ensure the security of all the junctions. And the second one is the number of ways you can ensure the security modulo 1000000007 (109 + 7).\n\nInputCopy31 2 331 22 33 2OutputCopy3 1InputCopy52 8 0 6 061 41 32 43 44 55 1OutputCopy8 2InputCopy101 3 2 2 1 3 1 4 10 10121 22 33 13 44 55 65 76 47 38 99 1010 9OutputCopy15 6InputCopy27 9121 22 1OutputCopy7 1\n\nInputCopy31 2 331 22 33 2\n\nOutputCopy3 1\n\nInputCopy52 8 0 6 061 41 32 43 44 55 1\n\nOutputCopy8 2\n\nInputCopy101 3 2 2 1 3 1 4 10 10121 22 33 13 44 55 65 76 47 38 99 1010 9\n\nOutputCopy15 6\n\nInputCopy27 9121 22 1\n\nOutputCopy7 1",
      "solutions": [
        {
          "title": "Codeforces Round #244 (Div. 2) - Codeforces",
          "content": "Good day everyone.Codeforces round #244 for division 2 participants will start at May 2, Friday, 19:30 MSK. As you all know, participants from division 1 can also take part from out of the competition.The round was prepared by me (Bidhan), student of University of Dhaka, Bangladesh. This is my first codeforces round. I have tried to prepare interesting and solvable problems for division 2 participants. Special effort was given to make the problem statements as clear as possible. Hoping that everything will go right and everyone will enjoy the round.Special thanks to msh_shiplu, lecturer of University of Dhaka, for his contribution to the contest by finding time to set one of the problems, writing alternates, reviewing problem statements and giving expert advice on dataset generation in spite of his hectic schedule.Also, a BIG thanks to nice guy Gerald, for helping throughout the preparation process.I wish all the participants good luck :)Update0 : Score distribution is 500-1000-1500-2000-2500.Update1 : A short editorial of the contest is here. The post will be enlarged to detailed editorial later.The Russian translation of this post is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12023",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1159
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces",
          "content": "The round statistics are nicely put by DmitriyH.427A - Police Recruits ( Author : Bidhan )Maintain a variable, sum. Initially sum=0, it keeps the number of currently free police officers. With every recruitment operation, add the number of officers recruited at that time to sum. When a crime occurs, if sum > 0 then decrease the number of free officers by one, otherwise no officers are free so the crime will go untreated.Model solution : 6546268427B - Prison Transfer ( Author : Bidhan )The severity of crimes form an integer sequence. Find all the contiguous sequences without any integer greater than t. If the length of any sequence is L, then we can choose c prisoners from them in L - c + 1 ways.Model solution : 6546272427C - Checkposts ( Author : Bidhan )Find the strongly connected components of the graph. From each component we need to choose a node with the lowest cost. If there are more than one nodes with lowest cost, then there are more than one way to choose node from this component.Model solution : 6546275427D - Match & Catch ( Author : msh_shiplu )O(n2) dynamic programming solution : Calculate the longest common prefix ( LCP ) for each index of s1 with each index of s2. Then, calculate LCP for each index of s1 with all the other indexes of it's own ( s1 ). Do the same for s2. Now from precalculated values, you can easily check the length of the shortest unique substring starting from any of the indexes of s1 or s2. Suppose i is an index of s1 and j is an index of s2. Find the LCP for i and j. Now, the minimum of the length of LCP, length of shortest unique substring starting from i, length of shortest unique substring starting from j is the answer for i,j. Now we need to find the minimum answer from all possible i,j pair. This problem can also be solved in by suffix array and in O(n) using suffix automaton.Model solution : 6546277427E - Police Patrol ( Author : Bidhan )Trying to place the police station on existing criminal locations is the best strategy. Calculate the cost from the leftmost criminal location, then sweep over the next locations. By doing some adjustments on the cost of the previous location will yield the cost of the current location.Model solution : 6546283",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12082",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 427\\s*C"
          },
          "content_length": 2221
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c\");\n    inf.readEoln();\n    \n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    \n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        \n        ensuref(u != v, \"Self-loops are not allowed: u == v == %d\", u);\n        pair<int, int> edge = {u, v};\n        ensuref(edges.count(edge) == 0, \"Duplicate edge (%d, %d) found\", u, v);\n        edges.insert(edge);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c\");\n    inf.readEoln();\n    \n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    \n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        \n        ensuref(u != v, \"Self-loops are not allowed: u == v == %d\", u);\n        pair<int, int> edge = {u, v};\n        ensuref(edges.count(edge) == 0, \"Duplicate edge (%d, %d) found\", u, v);\n        edges.insert(edge);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 0, 1000000000, \"c\");\n    inf.readEoln();\n    \n    int m = inf.readInt(0, 300000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    \n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        \n        ensuref(u != v, \"Self-loops are not allowed: u == v == %d\", u);\n        pair<int, int> edge = {u, v};\n        ensuref(edges.count(edge) == 0, \"Duplicate edge (%d, %d) found\", u, v);\n        edges.insert(edge);\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Generator for the problem.\n * Generates graphs of various types to test different scenarios.\n * Parameters:\n * - n: number of junctions (nodes)\n * - m: number of one-way roads (edges). Optional, if not provided, calculated based on type.\n * - min_c: minimum cost to build checkpost at a junction (inclusive)\n * - max_c: maximum cost to build checkpost at a junction (inclusive)\n * - type: type of graph. Possible values: \"random\", \"chain\", \"cycle\", \"sccs\"\n * - sccs: number of strongly connected components (only used when type is \"sccs\")\n */\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    int min_c = opt<int>(\"min_c\", 0);\n    int max_c = opt<int>(\"max_c\", 1000000000); // 1e9\n    string type = opt<string>(\"type\", \"random\");\n    int sccs = opt<int>(\"sccs\", 1);\n    \n    // Generate c_i (costs)\n    vector<int> c(n);\n    for(int i = 0; i < n; ++i)\n        c[i] = rnd.next(min_c, max_c);\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    \n    // Output c_i\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], \" \\n\"[i == n-1]);\n    \n    // Generate edges based on type\n    vector<pair<int,int>> edges;\n    \n    if(type == \"chain\") {\n        // Chain from 1 to n\n        for(int i = 1; i < n; ++i)\n            edges.push_back({i, i+1});\n        if(m != -1 && m > (int)edges.size()) {\n            fprintf(stderr, \"Requested m is larger than number of edges in chain.\\n\");\n            return 1;\n        }\n    } else if(type == \"cycle\") {\n        // Cycle from 1 to n, back to 1\n        for(int i = 1; i < n; ++i)\n            edges.push_back({i, i+1});\n        edges.push_back({n, 1});\n        if(m != -1 && m > (int)edges.size()) {\n            fprintf(stderr, \"Requested m is larger than number of edges in cycle.\\n\");\n            return 1;\n        }\n    } else if(type == \"random\") {\n        // Random edges\n        if(m == -1)\n            m = rnd.next(0, min(3 * n, (int)(1LL * n * (n - 1))));\n        m = min(m, (int)(1LL * n * (n - 1))); // Max possible edges without self-loops\n        set<pair<int,int>> edge_set;\n        while((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue; // No self-loops\n            pair<int,int> edge = {u, v};\n            if(edge_set.count(edge)) continue; // Avoid duplicate edges\n            edge_set.insert(edge);\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if(type == \"sccs\") {\n        // Generate sccs components\n        if(sccs > n) sccs = n; // Cannot have more SCCs than nodes\n        vector<int> sizes(sccs, n / sccs);\n        for(int i = 0; i < n % sccs; ++i)\n            sizes[i]++;\n        int idx = 0;\n        vector<int> nodes(n);\n        iota(nodes.begin(), nodes.end(), 1);\n        shuffle(nodes.begin(), nodes.end());\n        for(int s = 0; s < sccs; ++s) {\n            int sz = sizes[s];\n            vector<int> scc_nodes(nodes.begin() + idx, nodes.begin() + idx + sz);\n            idx += sz;\n            int scc_sz = scc_nodes.size();\n            // Connect nodes in a cycle to form a SCC\n            for(int i = 0; i < scc_sz; ++i) {\n                int u = scc_nodes[i];\n                int v = scc_nodes[(i + 1) % scc_sz];\n                edges.push_back({u, v});\n            }\n        }\n        if(m != -1 && m > (int)edges.size()) {\n            // Add additional random edges within SCCs\n            int extra_edges = m - edges.size();\n            set<pair<int,int>> edge_set(edges.begin(), edges.end());\n            while(extra_edges > 0) {\n                int s = rnd.next(0, sccs - 1);\n                int sz = sizes[s];\n                int start_idx = accumulate(sizes.begin(), sizes.begin() + s, 0);\n                int u = nodes[rnd.next(start_idx, start_idx + sz - 1)];\n                int v = nodes[rnd.next(start_idx, start_idx + sz - 1)];\n                if(u == v) continue;\n                pair<int,int> edge = {u, v};\n                if(edge_set.count(edge)) continue;\n                edge_set.insert(edge);\n                edges.push_back(edge);\n                extra_edges--;\n            }\n        } else if(m != -1 && m < (int)edges.size()) {\n            fprintf(stderr, \"Requested m is smaller than minimum required edges for sccs.\\n\");\n            return 1;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n    \n    // Shuffle edges to randomize the order\n    shuffle(edges.begin(), edges.end());\n    \n    // Output m and the edges\n    printf(\"%d\\n\", (int)edges.size());\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n * Generator for the problem.\n * Generates graphs of various types to test different scenarios.\n * Parameters:\n * - n: number of junctions (nodes)\n * - m: number of one-way roads (edges). Optional, if not provided, calculated based on type.\n * - min_c: minimum cost to build checkpost at a junction (inclusive)\n * - max_c: maximum cost to build checkpost at a junction (inclusive)\n * - type: type of graph. Possible values: \"random\", \"chain\", \"cycle\", \"sccs\"\n * - sccs: number of strongly connected components (only used when type is \"sccs\")\n */\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    int min_c = opt<int>(\"min_c\", 0);\n    int max_c = opt<int>(\"max_c\", 1000000000); // 1e9\n    string type = opt<string>(\"type\", \"random\");\n    int sccs = opt<int>(\"sccs\", 1);\n    \n    // Generate c_i (costs)\n    vector<int> c(n);\n    for(int i = 0; i < n; ++i)\n        c[i] = rnd.next(min_c, max_c);\n    \n    // Output n\n    printf(\"%d\\n\", n);\n    \n    // Output c_i\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], \" \\n\"[i == n-1]);\n    \n    // Generate edges based on type\n    vector<pair<int,int>> edges;\n    \n    if(type == \"chain\") {\n        // Chain from 1 to n\n        for(int i = 1; i < n; ++i)\n            edges.push_back({i, i+1});\n        if(m != -1 && m > (int)edges.size()) {\n            fprintf(stderr, \"Requested m is larger than number of edges in chain.\\n\");\n            return 1;\n        }\n    } else if(type == \"cycle\") {\n        // Cycle from 1 to n, back to 1\n        for(int i = 1; i < n; ++i)\n            edges.push_back({i, i+1});\n        edges.push_back({n, 1});\n        if(m != -1 && m > (int)edges.size()) {\n            fprintf(stderr, \"Requested m is larger than number of edges in cycle.\\n\");\n            return 1;\n        }\n    } else if(type == \"random\") {\n        // Random edges\n        if(m == -1)\n            m = rnd.next(0, min(3 * n, (int)(1LL * n * (n - 1))));\n        m = min(m, (int)(1LL * n * (n - 1))); // Max possible edges without self-loops\n        set<pair<int,int>> edge_set;\n        while((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if(u == v) continue; // No self-loops\n            pair<int,int> edge = {u, v};\n            if(edge_set.count(edge)) continue; // Avoid duplicate edges\n            edge_set.insert(edge);\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if(type == \"sccs\") {\n        // Generate sccs components\n        if(sccs > n) sccs = n; // Cannot have more SCCs than nodes\n        vector<int> sizes(sccs, n / sccs);\n        for(int i = 0; i < n % sccs; ++i)\n            sizes[i]++;\n        int idx = 0;\n        vector<int> nodes(n);\n        iota(nodes.begin(), nodes.end(), 1);\n        shuffle(nodes.begin(), nodes.end());\n        for(int s = 0; s < sccs; ++s) {\n            int sz = sizes[s];\n            vector<int> scc_nodes(nodes.begin() + idx, nodes.begin() + idx + sz);\n            idx += sz;\n            int scc_sz = scc_nodes.size();\n            // Connect nodes in a cycle to form a SCC\n            for(int i = 0; i < scc_sz; ++i) {\n                int u = scc_nodes[i];\n                int v = scc_nodes[(i + 1) % scc_sz];\n                edges.push_back({u, v});\n            }\n        }\n        if(m != -1 && m > (int)edges.size()) {\n            // Add additional random edges within SCCs\n            int extra_edges = m - edges.size();\n            set<pair<int,int>> edge_set(edges.begin(), edges.end());\n            while(extra_edges > 0) {\n                int s = rnd.next(0, sccs - 1);\n                int sz = sizes[s];\n                int start_idx = accumulate(sizes.begin(), sizes.begin() + s, 0);\n                int u = nodes[rnd.next(start_idx, start_idx + sz - 1)];\n                int v = nodes[rnd.next(start_idx, start_idx + sz - 1)];\n                if(u == v) continue;\n                pair<int,int> edge = {u, v};\n                if(edge_set.count(edge)) continue;\n                edge_set.insert(edge);\n                edges.push_back(edge);\n                extra_edges--;\n            }\n        } else if(m != -1 && m < (int)edges.size()) {\n            fprintf(stderr, \"Requested m is smaller than minimum required edges for sccs.\\n\");\n            return 1;\n        }\n    } else {\n        // Unknown type\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n    \n    // Shuffle edges to randomize the order\n    shuffle(edges.begin(), edges.end());\n    \n    // Output m and the edges\n    printf(\"%d\\n\", (int)edges.size());\n    for(auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type chain\n./gen -n 1 -type chain -min_c 0 -max_c 0\n\n./gen -n 5 -type chain -min_c 0 -max_c 10\n./gen -n 5 -type cycle -min_c 0 -max_c 10\n./gen -n 5 -type random -m 10 -min_c 0 -max_c 10\n\n./gen -n 10 -type sccs -sccs 1 -min_c 0 -max_c 100\n./gen -n 100 -type sccs -sccs 100 -min_c 0 -max_c 1000\n\n./gen -n 1000 -type sccs -sccs 10 -min_c 1 -max_c 1000\n./gen -n 1000 -type sccs -sccs 100 -min_c 0 -max_c 0\n\n./gen -n 10000 -type chain -min_c 0 -max_c 1000000000\n./gen -n 10000 -type cycle -min_c 0 -max_c 1000000000\n\n./gen -n 100000 -type cycle -min_c 1000000000 -max_c 1000000000\n./gen -n 100000 -type random -m 300000 -min_c 0 -max_c 1000000000\n./gen -n 100000 -type random -m 300000 -min_c 0 -max_c 0\n./gen -n 100000 -type random -m 0 -min_c 1 -max_c 1\n./gen -n 100000 -type random -m 300000 -min_c 0 -max_c 10\n\n./gen -n 100000 -type sccs -sccs 1\n./gen -n 100000 -type sccs -sccs 2\n./gen -n 100000 -type sccs -sccs 1000\n./gen -n 100000 -type sccs -sccs 100000\n\n./gen -n 99999 -type sccs -sccs 33333 -min_c 0 -max_c 0\n./gen -n 100000 -type sccs -sccs 1 -min_c 1 -max_c 1\n./gen -n 100000 -type random -m 300000 -min_c 0 -max_c 100\n./gen -n 100000 -type sccs -sccs 50 -m 300000\n\n./gen -n 99999 -type chain -min_c 0 -max_c 0\n./gen -n 100000 -type chain -min_c 0 -max_c 1\n./gen -n 100000 -type chain -min_c 1000000000 -max_c 1000000000\n./gen -n 100000 -type random -m 1 -min_c 0 -max_c 0\n./gen -n 100000 -type random -m 100000 -min_c 0 -max_c 1000000000\n./gen -n 100000 -type sccs -sccs 100000 -min_c 0 -max_c 1000000000\n./gen -n 100000 -type sccs -sccs 100000 -min_c 0 -max_c 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:22.212423",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "427/D",
      "title": "Problem 427/D",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 5000, \"Length of s1 is %d, which is out of bounds\", (int)s1.length());\n    for (int i = 0; i < (int)s1.length(); ++i) {\n        ensuref('a' <= s1[i] && s1[i] <= 'z', \"s1 contains invalid character '%c' at position %d\", s1[i], i + 1);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 5000, \"Length of s2 is %d, which is out of bounds\", (int)s2.length());\n    for (int i = 0; i < (int)s2.length(); ++i) {\n        ensuref('a' <= s2[i] && s2[i] <= 'z', \"s2 contains invalid character '%c' at position %d\", s2[i], i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 5000, \"Length of s1 is %d, which is out of bounds\", (int)s1.length());\n    for (int i = 0; i < (int)s1.length(); ++i) {\n        ensuref('a' <= s1[i] && s1[i] <= 'z', \"s1 contains invalid character '%c' at position %d\", s1[i], i + 1);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 5000, \"Length of s2 is %d, which is out of bounds\", (int)s2.length());\n    for (int i = 0; i < (int)s2.length(); ++i) {\n        ensuref('a' <= s2[i] && s2[i] <= 'z', \"s2 contains invalid character '%c' at position %d\", s2[i], i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 5000, \"Length of s1 is %d, which is out of bounds\", (int)s1.length());\n    for (int i = 0; i < (int)s1.length(); ++i) {\n        ensuref('a' <= s1[i] && s1[i] <= 'z', \"s1 contains invalid character '%c' at position %d\", s1[i], i + 1);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 5000, \"Length of s2 is %d, which is out of bounds\", (int)s2.length());\n    for (int i = 0; i < (int)s2.length(); ++i) {\n        ensuref('a' <= s2[i] && s2[i] <= 'z', \"s2 contains invalid character '%c' at position %d\", s2[i], i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring gen_random_string(int length) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        char c = rnd.next('a', 'z');\n        s += c;\n    }\n    return s;\n}\n\nstring gen_random_string(int length, char from, char to) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        char c = rnd.next(from, to);\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n1 = opt<int>(\"n1\");\n    int n2 = opt<int>(\"n2\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s1, s2;\n\n    if (type == \"random\") {\n        s1 = gen_random_string(n1);\n        s2 = gen_random_string(n2);\n\n    } else if (type == \"same\") {\n        s1 = gen_random_string(n1);\n        s2 = s1;\n\n    } else if (type == \"different\") {\n        s1 = gen_random_string(n1, 'a', 'm');\n        s2 = gen_random_string(n2, 'n', 'z');\n\n    } else if (type == \"no_solution\") {\n        // Generate strings where any common substring occurs more than once\n        s1 = string(n1, 'a');\n        s2 = string(n2, 'a');\n\n    } else if (type == \"minimal_unique\") {\n        // Generate strings where the minimal unique common substring is length 1\n        s1 = gen_random_string(n1, 'a', 'm');\n        s2 = gen_random_string(n2, 'n', 'z');\n        char common_char = 'z';\n        int pos1 = rnd.next(0, n1 - 1);\n        int pos2 = rnd.next(0, n2 - 1);\n        s1[pos1] = common_char;\n        s2[pos2] = common_char;\n\n    } else if (type == \"maximal_unique\") {\n        // Generate strings where the minimal unique common substring is of maximal length\n        s1 = gen_random_string(n1);\n        int k = min(n1, n2);\n        s2 = s1.substr(0, k);\n        for (int i = k; i < n2; ++i) {\n            s2 += rnd.next('a', 'z');\n        }\n\n    } else if (type == \"repeating\") {\n        // Generate strings with repeating patterns\n        string pattern = gen_random_string(rnd.next(1, 10));\n        while ((int)pattern.size() < (int)(min(n1, n2))) {\n            pattern += pattern;\n        }\n        s1 = s2 = \"\";\n        while ((int)s1.size() < n1) s1 += pattern;\n        s1 = s1.substr(0, n1);\n        while ((int)s2.size() < n2) s2 += pattern;\n        s2 = s2.substr(0, n2);\n\n    } else if (type == \"edge_case\") {\n        // Unique substring at the beginning or end\n        s1 = string(n1 - 1, 'a') + 'b';\n        s2 = 'b' + string(n2 - 1, 'a');\n\n    } else {\n        // Default to random if type is unknown\n        s1 = gen_random_string(n1);\n        s2 = gen_random_string(n2);\n    }\n\n    // Output s1 and s2\n    printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring gen_random_string(int length) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        char c = rnd.next('a', 'z');\n        s += c;\n    }\n    return s;\n}\n\nstring gen_random_string(int length, char from, char to) {\n    string s;\n    for (int i = 0; i < length; ++i) {\n        char c = rnd.next(from, to);\n        s += c;\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n1 = opt<int>(\"n1\");\n    int n2 = opt<int>(\"n2\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    string s1, s2;\n\n    if (type == \"random\") {\n        s1 = gen_random_string(n1);\n        s2 = gen_random_string(n2);\n\n    } else if (type == \"same\") {\n        s1 = gen_random_string(n1);\n        s2 = s1;\n\n    } else if (type == \"different\") {\n        s1 = gen_random_string(n1, 'a', 'm');\n        s2 = gen_random_string(n2, 'n', 'z');\n\n    } else if (type == \"no_solution\") {\n        // Generate strings where any common substring occurs more than once\n        s1 = string(n1, 'a');\n        s2 = string(n2, 'a');\n\n    } else if (type == \"minimal_unique\") {\n        // Generate strings where the minimal unique common substring is length 1\n        s1 = gen_random_string(n1, 'a', 'm');\n        s2 = gen_random_string(n2, 'n', 'z');\n        char common_char = 'z';\n        int pos1 = rnd.next(0, n1 - 1);\n        int pos2 = rnd.next(0, n2 - 1);\n        s1[pos1] = common_char;\n        s2[pos2] = common_char;\n\n    } else if (type == \"maximal_unique\") {\n        // Generate strings where the minimal unique common substring is of maximal length\n        s1 = gen_random_string(n1);\n        int k = min(n1, n2);\n        s2 = s1.substr(0, k);\n        for (int i = k; i < n2; ++i) {\n            s2 += rnd.next('a', 'z');\n        }\n\n    } else if (type == \"repeating\") {\n        // Generate strings with repeating patterns\n        string pattern = gen_random_string(rnd.next(1, 10));\n        while ((int)pattern.size() < (int)(min(n1, n2))) {\n            pattern += pattern;\n        }\n        s1 = s2 = \"\";\n        while ((int)s1.size() < n1) s1 += pattern;\n        s1 = s1.substr(0, n1);\n        while ((int)s2.size() < n2) s2 += pattern;\n        s2 = s2.substr(0, n2);\n\n    } else if (type == \"edge_case\") {\n        // Unique substring at the beginning or end\n        s1 = string(n1 - 1, 'a') + 'b';\n        s2 = 'b' + string(n2 - 1, 'a');\n\n    } else {\n        // Default to random if type is unknown\n        s1 = gen_random_string(n1);\n        s2 = gen_random_string(n2);\n    }\n\n    // Output s1 and s2\n    printf(\"%s\\n%s\\n\", s1.c_str(), s2.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n1 1 -n2 1 -type random\n./gen -n1 10 -n2 10 -type random\n./gen -n1 1000 -n2 1000 -type random\n./gen -n1 5000 -n2 5000 -type random\n\n./gen -n1 1 -n2 1 -type same\n./gen -n1 10 -n2 10 -type same\n./gen -n1 1000 -n2 1000 -type same\n./gen -n1 5000 -n2 5000 -type same\n\n./gen -n1 1 -n2 1 -type different\n./gen -n1 10 -n2 10 -type different\n./gen -n1 1000 -n2 1000 -type different\n./gen -n1 5000 -n2 5000 -type different\n\n./gen -n1 1 -n2 1 -type no_solution\n./gen -n1 10 -n2 15 -type no_solution\n./gen -n1 1000 -n2 1000 -type no_solution\n./gen -n1 5000 -n2 5000 -type no_solution\n\n./gen -n1 1 -n2 1 -type minimal_unique\n./gen -n1 10 -n2 10 -type minimal_unique\n./gen -n1 1000 -n2 1000 -type minimal_unique\n./gen -n1 5000 -n2 5000 -type minimal_unique\n\n./gen -n1 1 -n2 1 -type maximal_unique\n./gen -n1 10 -n2 15 -type maximal_unique\n./gen -n1 1000 -n2 1000 -type maximal_unique\n./gen -n1 5000 -n2 5000 -type maximal_unique\n\n./gen -n1 1 -n2 1 -type repeating\n./gen -n1 10 -n2 10 -type repeating\n./gen -n1 1000 -n2 1000 -type repeating\n./gen -n1 5000 -n2 5000 -type repeating\n\n./gen -n1 1 -n2 1 -type edge_case\n./gen -n1 10 -n2 10 -type edge_case\n./gen -n1 1000 -n2 1000 -type edge_case\n./gen -n1 5000 -n2 5000 -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:24.182448",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "427/E",
      "title": "E. Police Patrol",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input will have two integers n (1 ≤ n ≤ 106) and m (1 ≤ m ≤ 106) separated by spaces. The next line will contain n integers separated by spaces. The ith integer is the position of the ith criminal on the x-axis. Absolute value of positions will not exceed 109. If a criminal has position x, he/she is located in the point (x, 0) of the plane. The positions of the criminals will be given in non-decreasing order. Note, that there can be more than one criminal standing at some point of the plane.Note: since the size of the input/output could be very large, don't use slow input/output techniques in your language. For example, do not use input/output streams (cin, cout) in C++.",
      "output_spec": "OutputPrint a single integer, that means the minimum possible distance you need to cover to catch all the criminals.",
      "sample_tests": "ExamplesInputCopy3 61 2 3OutputCopy4InputCopy5 5-7 -6 -3 -1 1OutputCopy16InputCopy1 3690OutputCopy0InputCopy11 2-375 -108 1336 1453 1598 1892 2804 3732 4291 4588 4822OutputCopy18716",
      "description": "E. Police Patrol\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input will have two integers n (1 ≤ n ≤ 106) and m (1 ≤ m ≤ 106) separated by spaces. The next line will contain n integers separated by spaces. The ith integer is the position of the ith criminal on the x-axis. Absolute value of positions will not exceed 109. If a criminal has position x, he/she is located in the point (x, 0) of the plane. The positions of the criminals will be given in non-decreasing order. Note, that there can be more than one criminal standing at some point of the plane.Note: since the size of the input/output could be very large, don't use slow input/output techniques in your language. For example, do not use input/output streams (cin, cout) in C++.\n\nOutputPrint a single integer, that means the minimum possible distance you need to cover to catch all the criminals.\n\nInputCopy3 61 2 3OutputCopy4InputCopy5 5-7 -6 -3 -1 1OutputCopy16InputCopy1 3690OutputCopy0InputCopy11 2-375 -108 1336 1453 1598 1892 2804 3732 4291 4588 4822OutputCopy18716\n\nInputCopy3 61 2 3\n\nOutputCopy4\n\nInputCopy5 5-7 -6 -3 -1 1\n\nOutputCopy16\n\nInputCopy1 3690\n\nOutputCopy0\n\nInputCopy11 2-375 -108 1336 1453 1598 1892 2804 3732 4291 4588 4822\n\nOutputCopy18716",
      "solutions": [
        {
          "title": "Codeforces Round #244 (Div. 2) - Codeforces",
          "content": "Good day everyone.Codeforces round #244 for division 2 participants will start at May 2, Friday, 19:30 MSK. As you all know, participants from division 1 can also take part from out of the competition.The round was prepared by me (Bidhan), student of University of Dhaka, Bangladesh. This is my first codeforces round. I have tried to prepare interesting and solvable problems for division 2 participants. Special effort was given to make the problem statements as clear as possible. Hoping that everything will go right and everyone will enjoy the round.Special thanks to msh_shiplu, lecturer of University of Dhaka, for his contribution to the contest by finding time to set one of the problems, writing alternates, reviewing problem statements and giving expert advice on dataset generation in spite of his hectic schedule.Also, a BIG thanks to nice guy Gerald, for helping throughout the preparation process.I wish all the participants good luck :)Update0 : Score distribution is 500-1000-1500-2000-2500.Update1 : A short editorial of the contest is here. The post will be enlarged to detailed editorial later.The Russian translation of this post is here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12023",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1159
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces",
          "content": "The round statistics are nicely put by DmitriyH.427A - Police Recruits ( Author : Bidhan )Maintain a variable, sum. Initially sum=0, it keeps the number of currently free police officers. With every recruitment operation, add the number of officers recruited at that time to sum. When a crime occurs, if sum > 0 then decrease the number of free officers by one, otherwise no officers are free so the crime will go untreated.Model solution : 6546268427B - Prison Transfer ( Author : Bidhan )The severity of crimes form an integer sequence. Find all the contiguous sequences without any integer greater than t. If the length of any sequence is L, then we can choose c prisoners from them in L - c + 1 ways.Model solution : 6546272427C - Checkposts ( Author : Bidhan )Find the strongly connected components of the graph. From each component we need to choose a node with the lowest cost. If there are more than one nodes with lowest cost, then there are more than one way to choose node from this component.Model solution : 6546275427D - Match & Catch ( Author : msh_shiplu )O(n2) dynamic programming solution : Calculate the longest common prefix ( LCP ) for each index of s1 with each index of s2. Then, calculate LCP for each index of s1 with all the other indexes of it's own ( s1 ). Do the same for s2. Now from precalculated values, you can easily check the length of the shortest unique substring starting from any of the indexes of s1 or s2. Suppose i is an index of s1 and j is an index of s2. Find the LCP for i and j. Now, the minimum of the length of LCP, length of shortest unique substring starting from i, length of shortest unique substring starting from j is the answer for i,j. Now we need to find the minimum answer from all possible i,j pair. This problem can also be solved in by suffix array and in O(n) using suffix automaton.Model solution : 6546277427E - Police Patrol ( Author : Bidhan )Trying to place the police station on existing criminal locations is the best strategy. Calculate the cost from the leftmost criminal location, then sweep over the next locations. By doing some adjustments on the cost of the previous location will yield the cost of the current location.Model solution : 6546283",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12082",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 427\\s*E"
          },
          "content_length": 2221
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #244 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "answer := 0\nL := 0\nfor v in values do\n  if v > t do:\n    if L >= c do:\n      answer := answer + L - c + 1\n    end\n    L := 0\n  else do:\n    L := L + 1\n  end\nend\n\n// Test for last L\nif L >= c do:\n  answer := answer + L - c + 1\nend",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12082",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> positions = inf.readInts(n, -1000000000, 1000000000, \"positions\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; i++) {\n        ensuref(positions[i] <= positions[i + 1],\n                \"positions are not in non-decreasing order at positions[%d] = %d and positions[%d] = %d\",\n                i, positions[i], i + 1, positions[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> positions = inf.readInts(n, -1000000000, 1000000000, \"positions\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; i++) {\n        ensuref(positions[i] <= positions[i + 1],\n                \"positions are not in non-decreasing order at positions[%d] = %d and positions[%d] = %d\",\n                i, positions[i], i + 1, positions[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000, \"m\");\n    inf.readEoln();\n\n    vector<int> positions = inf.readInts(n, -1000000000, 1000000000, \"positions\");\n    inf.readEoln();\n\n    for (int i = 0; i + 1 < n; i++) {\n        ensuref(positions[i] <= positions[i + 1],\n                \"positions are not in non-decreasing order at positions[%d] = %d and positions[%d] = %d\",\n                i, positions[i], i + 1, positions[i + 1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_N = 1;\nconst int MAX_N = 1e6;\nconst int MIN_M = 1;\nconst int MAX_M = 1e6;\nconst int MIN_X = -1e9;\nconst int MAX_X = 1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default to -1\n    string type = opt<string>(\"type\", \"random\");\n\n    // If m is not provided, set it to a random value between MIN_M and MAX_M\n    if (m == -1) {\n        m = rnd.next(MIN_M, MAX_M);\n    }\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(MIN_X, MAX_X);\n        }\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = 0;\n        }\n    } else if (type == \"same_point\") {\n        int p = rnd.next(MIN_X, MAX_X);\n        for (int i = 0; i < n; ++i) {\n            x[i] = p;\n        }\n    } else if (type == \"one_side_neg\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(MIN_X, -1);\n        }\n    } else if (type == \"one_side_pos\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(1, MAX_X);\n        }\n    } else if (type == \"max_range\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = (i % 2 == 0) ? MIN_X : MAX_X;\n        }\n    } else if (type == \"clustered\") {\n        int center = rnd.next(MIN_X + 1000, MAX_X - 1000);\n        int range = rnd.next(0, 10);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(center - range, center + range);\n        }\n    } else if (type == \"sparse\") {\n        set<int> positions;\n        positions.insert(MIN_X);\n        positions.insert(MAX_X);\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(MIN_X, MAX_X));\n        }\n        int idx = 0;\n        for (int pos : positions) {\n            x[idx++] = pos;\n        }\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                x[i] = rnd.next(MIN_X, -1);\n            } else {\n                x[i] = rnd.next(1, MAX_X);\n            }\n        }\n    }\n\n    // Ensure positions are within allowed range\n    for (int i = 0; i < n; ++i) {\n        x[i] = max(min(x[i], MAX_X), MIN_X);\n    }\n\n    // Ensure positions are in non-decreasing order\n    sort(x.begin(), x.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output positions x_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MIN_N = 1;\nconst int MAX_N = 1e6;\nconst int MIN_M = 1;\nconst int MAX_M = 1e6;\nconst int MIN_X = -1e9;\nconst int MAX_X = 1e9;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default to -1\n    string type = opt<string>(\"type\", \"random\");\n\n    // If m is not provided, set it to a random value between MIN_M and MAX_M\n    if (m == -1) {\n        m = rnd.next(MIN_M, MAX_M);\n    }\n\n    vector<int> x(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(MIN_X, MAX_X);\n        }\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = 0;\n        }\n    } else if (type == \"same_point\") {\n        int p = rnd.next(MIN_X, MAX_X);\n        for (int i = 0; i < n; ++i) {\n            x[i] = p;\n        }\n    } else if (type == \"one_side_neg\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(MIN_X, -1);\n        }\n    } else if (type == \"one_side_pos\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(1, MAX_X);\n        }\n    } else if (type == \"max_range\") {\n        for (int i = 0; i < n; ++i) {\n            x[i] = (i % 2 == 0) ? MIN_X : MAX_X;\n        }\n    } else if (type == \"clustered\") {\n        int center = rnd.next(MIN_X + 1000, MAX_X - 1000);\n        int range = rnd.next(0, 10);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(center - range, center + range);\n        }\n    } else if (type == \"sparse\") {\n        set<int> positions;\n        positions.insert(MIN_X);\n        positions.insert(MAX_X);\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(MIN_X, MAX_X));\n        }\n        int idx = 0;\n        for (int pos : positions) {\n            x[idx++] = pos;\n        }\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                x[i] = rnd.next(MIN_X, -1);\n            } else {\n                x[i] = rnd.next(1, MAX_X);\n            }\n        }\n    }\n\n    // Ensure positions are within allowed range\n    for (int i = 0; i < n; ++i) {\n        x[i] = max(min(x[i], MAX_X), MIN_X);\n    }\n\n    // Ensure positions are in non-decreasing order\n    sort(x.begin(), x.end());\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output positions x_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", x[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type all_zero\n./gen -n 1 -m 1 -type same_point\n./gen -n 1 -m 1 -type random\n\n./gen -n 10 -m 1 -type one_side_neg\n./gen -n 10 -m 10 -type one_side_pos\n\n./gen -n 100 -m 50 -type clustered\n./gen -n 100 -m 100 -type sparse\n\n./gen -n 1000 -m 1 -type max_range\n./gen -n 1000 -m 1000 -type alternate\n\n./gen -n 10000 -m 1 -type random\n./gen -n 10000 -m 10000 -type random\n\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 1000000 -m 1 -type random\n./gen -n 1000000 -m 1000000 -type random\n\n./gen -n 10 -m 1 -type all_zero\n./gen -n 1000000 -m 1 -type all_zero\n\n./gen -n 10 -m 1 -type same_point\n./gen -n 1000000 -m 1 -type same_point\n\n./gen -n 1000000 -m 1 -type one_side_neg\n./gen -n 1000000 -m 1 -type one_side_pos\n\n./gen -n 1000000 -m 1 -type max_range\n\n./gen -n 1000000 -m 1 -type clustered\n./gen -n 1000000 -m 1 -type sparse\n./gen -n 1000000 -m 1 -type alternate\n\n./gen -n 1000000 -m 1000000 -type random\n./gen -n 1000000 -m 1000000 -type max_range\n\n./gen -n 1000000 -m 1 -type clustered\n./gen -n 1000000 -m 1 -type alternate\n\n# m is set randomly\n./gen -n 1000000 -type random\n./gen -n 1000000 -type one_side_neg\n./gen -n 1000000 -type one_side_pos\n\n# m = 1\n./gen -n 1000000 -m 1 -type random\n\n# m = n\n./gen -n 1000000 -m 1000000 -type all_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:26.017835",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "429/A",
      "title": "A. Xor-tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105). Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) meaning there is an edge between nodes ui and vi. The next line contains n integer numbers, the i-th of them corresponds to initi (initi is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goali (goali is either 0 or 1).",
      "output_spec": "OutputIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer xi, representing that you pick a node xi.",
      "sample_tests": "ExamplesInputCopy102 13 14 25 16 27 58 69 810 51 0 1 1 0 1 0 1 0 11 0 1 0 0 1 1 1 0 1OutputCopy247",
      "description": "A. Xor-tree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105). Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) meaning there is an edge between nodes ui and vi. The next line contains n integer numbers, the i-th of them corresponds to initi (initi is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goali (goali is either 0 or 1).\n\nOutputIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer xi, representing that you pick a node xi.\n\nInputCopy102 13 14 25 16 27 58 69 810 51 0 1 1 0 1 0 1 0 11 0 1 0 0 1 1 1 0 1OutputCopy247\n\nInputCopy102 13 14 25 16 27 58 69 810 51 0 1 1 0 1 0 1 0 11 0 1 0 0 1 1 1 0 1\n\nOutputCopy247",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 429\\s*A"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        return parent[u] == u ? u : parent[u] = find(parent[u]);\n    };\n\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v)\n            return false; // cycle detected\n        parent[u] = v;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge cannot connect node to itself: u_i = v_i = %d\", u);\n\n        bool ok = unite(u, v);\n        ensuref(ok, \"Graph contains a cycle at edge %d: %d %d\", i + 1, u, v);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    vector<int> init = inf.readInts(n, 0, 1, \"initial_values\");\n    inf.readEoln();\n\n    vector<int> goal = inf.readInts(n, 0, 1, \"goal_values\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        return parent[u] == u ? u : parent[u] = find(parent[u]);\n    };\n\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v)\n            return false; // cycle detected\n        parent[u] = v;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge cannot connect node to itself: u_i = v_i = %d\", u);\n\n        bool ok = unite(u, v);\n        ensuref(ok, \"Graph contains a cycle at edge %d: %d %d\", i + 1, u, v);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    vector<int> init = inf.readInts(n, 0, 1, \"initial_values\");\n    inf.readEoln();\n\n    vector<int> goal = inf.readInts(n, 0, 1, \"goal_values\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        return parent[u] == u ? u : parent[u] = find(parent[u]);\n    };\n\n    auto unite = [&](int u, int v) {\n        u = find(u);\n        v = find(v);\n        if (u == v)\n            return false; // cycle detected\n        parent[u] = v;\n        return true;\n    };\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge cannot connect node to itself: u_i = v_i = %d\", u);\n\n        bool ok = unite(u, v);\n        ensuref(ok, \"Graph contains a cycle at edge %d: %d %d\", i + 1, u, v);\n    }\n\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected\");\n    }\n\n    vector<int> init = inf.readInts(n, 0, 1, \"initial_values\");\n    inf.readEoln();\n\n    vector<int> goal = inf.readInts(n, 0, 1, \"goal_values\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 1e5 + 5;\n\nvector<int> adj[MAXN];\nint init[MAXN], goal[MAXN];\nint n;\nset<int> picks;\n\n// Function to read the tree structure and initial and goal values\nvoid readInput() {\n    n = inf.readInt(1, 100000, \"n\");\n    // Reading tree edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        int v = inf.readInt(1, n, \"v\");\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    // Reading initial values\n    for (int i = 1; i <= n; ++i) {\n        init[i] = inf.readInt(0, 1, \"init_i\");\n    }\n    // Reading goal values\n    for (int i = 1; i <= n; ++i) {\n        goal[i] = inf.readInt(0, 1, \"goal_i\");\n    }\n}\n\n// Recursive function to perform DFS traversal and simulate flips\nvoid dfs(int node, int parent, int depth, int flipEven, int flipOdd) {\n    // Check if the node is picked by the participant\n    if (picks.count(node)) {\n        if (depth % 2 == 0) {\n            flipEven ^= 1;\n        } else {\n            flipOdd ^= 1;\n        }\n    }\n    // Compute the value of the node after flips\n    int val = init[node];\n    if (depth % 2 == 0) {\n        val ^= flipEven;\n    } else {\n        val ^= flipOdd;\n    }\n    // Check if the value matches the goal value\n    if (val != goal[node]) {\n        quitf(_wa, \"Value at node %d does not match goal after flips\", node);\n    }\n    // Continue DFS traversal\n    for (int neighbor : adj[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, depth + 1, flipEven, flipOdd);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    readInput();\n\n    int ans_cnt = ans.readInt(0, n, \"ans_cnt\");\n    vector<int> ans_picks;\n    for (int i = 0; i < ans_cnt; ++i) {\n        int x = ans.readInt(1, n, \"ans_pick_i\");\n        ans_picks.push_back(x);\n    }\n\n    int cnt = ouf.readInt(0, n, \"cnt\");\n    if (cnt > ans_cnt) {\n        quitf(_wa, \"Number of operations %d is greater than minimal %d\", cnt, ans_cnt);\n    }\n\n    for (int i = 0; i < cnt; ++i) {\n        int x = ouf.readInt(1, n, \"pick_i\");\n        picks.insert(x);\n    }\n\n    dfs(1, 0, 0, 0, 0);\n\n    quitf(_ok, \"Correct answer with %d operations\", cnt);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_chain_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i - 1, i);\n    }\n}\n\nvoid generate_star_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(1, i);\n    }\n}\n\nvoid generate_balanced_tree(int n, vector<pair<int, int>>& edges) {\n    vector<int> nodes;\n    nodes.push_back(1);\n    int current = 2;\n    while (current <= n) {\n        vector<int> next_level;\n        for (int u : nodes) {\n            if (current > n)\n                break;\n            edges.emplace_back(u, current);\n            next_level.push_back(current);\n            ++current;\n            if (current > n)\n                break;\n            edges.emplace_back(u, current);\n            next_level.push_back(current);\n            ++current;\n        }\n        nodes = next_level;\n    }\n}\n\nvoid generate_random_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        int u = rnd.next(1, i - 1);\n        edges.emplace_back(u, i);\n    }\n    shuffle(edges.begin(), edges.end());\n}\n\nvector<int> generate_values(int n, const string& value_type) {\n    vector<int> values(n + 1);\n    if (value_type == \"zeros\") {\n        fill(values.begin() + 1, values.end(), 0);\n    } else if (value_type == \"ones\") {\n        fill(values.begin() + 1, values.end(), 1);\n    } else if (value_type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            values[i] = rnd.next(0, 1);\n        }\n    } else if (value_type == \"same\") {\n        int val = rnd.next(0, 1);\n        fill(values.begin() + 1, values.end(), val);\n    } else if (value_type == \"opposite\") {\n        int val = rnd.next(0, 1);\n        for (int i = 1; i <= n; ++i) {\n            values[i] = val;\n            val = 1 - val; // Flip between 0 and 1\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            values[i] = rnd.next(0, 1);\n        }\n    }\n    return values;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<std::string>(\"tree_type\", \"random\");\n    string initial_type = opt<std::string>(\"initial_type\", \"random\");\n    string goal_type = opt<std::string>(\"goal_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        generate_chain_tree(n, edges);\n    } else if (tree_type == \"star\") {\n        generate_star_tree(n, edges);\n    } else if (tree_type == \"balanced\") {\n        generate_balanced_tree(n, edges);\n    } else if (tree_type == \"random\") {\n        generate_random_tree(n, edges);\n    } else {\n        // Default to random tree\n        generate_random_tree(n, edges);\n    }\n\n    vector<int> init_values = generate_values(n, initial_type);\n    vector<int> goal_values = generate_values(n, goal_type);\n\n    // Output the number of nodes\n    printf(\"%d\\n\", n);\n\n    // Output the edges\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    // Output the initial values\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", init_values[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output the goal values\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", goal_values[i], i == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid generate_chain_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(i - 1, i);\n    }\n}\n\nvoid generate_star_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        edges.emplace_back(1, i);\n    }\n}\n\nvoid generate_balanced_tree(int n, vector<pair<int, int>>& edges) {\n    vector<int> nodes;\n    nodes.push_back(1);\n    int current = 2;\n    while (current <= n) {\n        vector<int> next_level;\n        for (int u : nodes) {\n            if (current > n)\n                break;\n            edges.emplace_back(u, current);\n            next_level.push_back(current);\n            ++current;\n            if (current > n)\n                break;\n            edges.emplace_back(u, current);\n            next_level.push_back(current);\n            ++current;\n        }\n        nodes = next_level;\n    }\n}\n\nvoid generate_random_tree(int n, vector<pair<int, int>>& edges) {\n    for (int i = 2; i <= n; ++i) {\n        int u = rnd.next(1, i - 1);\n        edges.emplace_back(u, i);\n    }\n    shuffle(edges.begin(), edges.end());\n}\n\nvector<int> generate_values(int n, const string& value_type) {\n    vector<int> values(n + 1);\n    if (value_type == \"zeros\") {\n        fill(values.begin() + 1, values.end(), 0);\n    } else if (value_type == \"ones\") {\n        fill(values.begin() + 1, values.end(), 1);\n    } else if (value_type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            values[i] = rnd.next(0, 1);\n        }\n    } else if (value_type == \"same\") {\n        int val = rnd.next(0, 1);\n        fill(values.begin() + 1, values.end(), val);\n    } else if (value_type == \"opposite\") {\n        int val = rnd.next(0, 1);\n        for (int i = 1; i <= n; ++i) {\n            values[i] = val;\n            val = 1 - val; // Flip between 0 and 1\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            values[i] = rnd.next(0, 1);\n        }\n    }\n    return values;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<std::string>(\"tree_type\", \"random\");\n    string initial_type = opt<std::string>(\"initial_type\", \"random\");\n    string goal_type = opt<std::string>(\"goal_type\", \"random\");\n\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        generate_chain_tree(n, edges);\n    } else if (tree_type == \"star\") {\n        generate_star_tree(n, edges);\n    } else if (tree_type == \"balanced\") {\n        generate_balanced_tree(n, edges);\n    } else if (tree_type == \"random\") {\n        generate_random_tree(n, edges);\n    } else {\n        // Default to random tree\n        generate_random_tree(n, edges);\n    }\n\n    vector<int> init_values = generate_values(n, initial_type);\n    vector<int> goal_values = generate_values(n, goal_type);\n\n    // Output the number of nodes\n    printf(\"%d\\n\", n);\n\n    // Output the edges\n    for (const auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    // Output the initial values\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", init_values[i], i == n ? '\\n' : ' ');\n    }\n\n    // Output the goal values\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", goal_values[i], i == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree_type chain -initial_type zeros -goal_type zeros\n./gen -n 1 -tree_type chain -initial_type zeros -goal_type ones\n\n./gen -n 2 -tree_type chain -initial_type zeros -goal_type ones\n./gen -n 2 -tree_type star -initial_type ones -goal_type zeros\n\n./gen -n 3 -tree_type balanced -initial_type zeros -goal_type ones\n./gen -n 3 -tree_type random -initial_type random -goal_type random\n\n./gen -n 10 -tree_type chain -initial_type zeros -goal_type ones\n./gen -n 10 -tree_type star -initial_type ones -goal_type zeros\n./gen -n 10 -tree_type balanced -initial_type random -goal_type random\n./gen -n 10 -tree_type random -initial_type same -goal_type opposite\n\n./gen -n 50 -tree_type chain -initial_type zeros -goal_type zeros\n./gen -n 50 -tree_type chain -initial_type zeros -goal_type ones\n./gen -n 50 -tree_type chain -initial_type ones -goal_type zeros\n./gen -n 50 -tree_type chain -initial_type random -goal_type random\n\n./gen -n 100 -tree_type star -initial_type zeros -goal_type ones\n./gen -n 100 -tree_type star -initial_type ones -goal_type zeros\n./gen -n 100 -tree_type star -initial_type random -goal_type random\n\n./gen -n 1000 -tree_type balanced -initial_type zeros -goal_type ones\n./gen -n 1000 -tree_type balanced -initial_type ones -goal_type zeros\n./gen -n 1000 -tree_type balanced -initial_type random -goal_type random\n\n./gen -n 10000 -tree_type random -initial_type zeros -goal_type ones\n./gen -n 10000 -tree_type random -initial_type ones -goal_type zeros\n./gen -n 10000 -tree_type random -initial_type random -goal_type random\n\n./gen -n 100000 -tree_type chain -initial_type zeros -goal_type ones\n./gen -n 100000 -tree_type chain -initial_type ones -goal_type zeros\n./gen -n 100000 -tree_type star -initial_type zeros -goal_type ones\n./gen -n 100000 -tree_type star -initial_type ones -goal_type zeros\n./gen -n 100000 -tree_type balanced -initial_type zeros -goal_type zeros\n./gen -n 100000 -tree_type balanced -initial_type same -goal_type opposite\n./gen -n 100000 -tree_type random -initial_type zeros -goal_type zeros\n./gen -n 100000 -tree_type random -initial_type random -goal_type random\n./gen -n 100000 -tree_type random -initial_type zeros -goal_type random\n./gen -n 100000 -tree_type random -initial_type random -goal_type zeros\n./gen -n 100000 -tree_type random -initial_type same -goal_type opposite\n./gen -n 99999 -tree_type random -initial_type random -goal_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:28.400619",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "429/B",
      "title": "B. Working out",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (3 ≤ n, m ≤ 1000). Each of the next n lines contains m integers: j-th number from i-th line denotes element a[i][j] (0 ≤ a[i][j] ≤ 105).",
      "output_spec": "OutputThe output contains a single number — the maximum total gain possible.",
      "sample_tests": "ExamplesInputCopy3 3100 100 100100 1 100100 100 100OutputCopy800",
      "description": "B. Working out\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (3 ≤ n, m ≤ 1000). Each of the next n lines contains m integers: j-th number from i-th line denotes element a[i][j] (0 ≤ a[i][j] ≤ 105).\n\nOutputThe output contains a single number — the maximum total gain possible.\n\nInputCopy3 3100 100 100100 1 100100 100 100OutputCopy800\n\nInputCopy3 3100 100 100100 1 100100 100 100\n\nOutputCopy800\n\nNoteIahub will choose exercises a[1][1] → a[1][2] → a[2][2] → a[3][2] → a[3][3]. Iahubina will choose exercises a[3][1] → a[2][1] → a[2][2] → a[2][3] → a[1][3].",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 429\\s*B"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 100000, \"a[i]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 100000, \"a[i]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 100000, \"a[i]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"zero\") {\n        // All zeros\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 0);\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n    } else if (type == \"max\") {\n        // All 100000\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 100000);\n    } else if (type == \"random\") {\n        // Random values between 0 and 100000\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 100000);\n    } else if (type == \"checkerboard\") {\n        // Alternating 0 and 100000\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = ((i + j) % 2 == 0) ? 0 : 100000;\n    } else if (type == \"path\") {\n        // Maximum values along both paths, zeros elsewhere\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 0);\n        // For Iahub's path from (1,1) to (n,m)\n        int x = 0, y = 0;\n        while (x < n && y < m) {\n            a[x][y] = 100000;\n            if (x + 1 < n && y + 1 < m) {\n                if (rnd.next(2))\n                    ++x;\n                else\n                    ++y;\n            } else if (x + 1 < n) {\n                ++x;\n            } else {\n                ++y;\n            }\n        }\n        // For Iahubina's path from (n,1) to (1,m)\n        x = n - 1;\n        y = 0;\n        while (x >= 0 && y < m) {\n            a[x][y] = 100000;\n            if (x - 1 >= 0 && y + 1 < m) {\n                if (rnd.next(2))\n                    --x;\n                else\n                    ++y;\n            } else if (x - 1 >= 0) {\n                --x;\n            } else {\n                ++y;\n            }\n        }\n    } else if (type == \"anti-path\") {\n        // Zeros along the paths, maximum elsewhere\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 100000);\n        // For Iahub's path from (1,1) to (n,m)\n        int x = 0, y = 0;\n        while (x < n && y < m) {\n            a[x][y] = 0;\n            if (x + 1 < n && y + 1 < m) {\n                if (rnd.next(2))\n                    ++x;\n                else\n                    ++y;\n            } else if (x + 1 < n) {\n                ++x;\n            } else {\n                ++y;\n            }\n        }\n        // For Iahubina's path from (n,1) to (1,m)\n        x = n - 1;\n        y = 0;\n        while (x >= 0 && y < m) {\n            a[x][y] = 0;\n            if (x - 1 >= 0 && y + 1 < m) {\n                if (rnd.next(2))\n                    --x;\n                else\n                    ++y;\n            } else if (x - 1 >= 0) {\n                --x;\n            } else {\n                ++y;\n            }\n        }\n    } else if (type == \"meet-early\") {\n        // Maximum values, with high gain before an early meet point\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n\n        // Set meet point early, at (1,1) if possible\n        int meet_x = min(1, n - 1);\n        int meet_y = min(1, m - 1);\n        a[meet_x][meet_y] = 0; // Meet cell, neither gains from it\n\n        // High gains before the meet point\n        for(int i = 0; i <= meet_x; ++i)\n            for(int j = 0; j <= meet_y; ++j)\n                a[i][j] = 100000;\n    } else if (type == \"meet-late\") {\n        // Maximum values, with high gain after a late meet point\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n\n        // Set meet point late, at (n-2, m-2) if possible\n        int meet_x = max(n - 2, 0);\n        int meet_y = max(m - 2, 0);\n        a[meet_x][meet_y] = 0; // Meet cell, neither gains from it\n\n        // High gains after the meet point\n        for(int i = meet_x; i < n; ++i)\n            for(int j = meet_y; j < m; ++j)\n                a[i][j] = 100000;\n    } else if (type == \"special1\") {\n        // High gain at meet cell, others are low\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n\n        // Set meet cell somewhere in the middle\n        int meet_x = n / 2;\n        int meet_y = m / 2;\n        a[meet_x][meet_y] = 100000; // High gain at meet cell\n    } else if (type == \"special2\") {\n        // All high gains except at the meet cell\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 100000);\n\n        // Set meet cell somewhere in the middle\n        int meet_x = n / 2;\n        int meet_y = m / 2;\n        a[meet_x][meet_y] = 0; // Zero gain at meet cell\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 100000);\n    }\n\n    // Output the matrix\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<int>> a(n, vector<int>(m));\n\n    if (type == \"zero\") {\n        // All zeros\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 0);\n    } else if (type == \"ones\") {\n        // All ones\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n    } else if (type == \"max\") {\n        // All 100000\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 100000);\n    } else if (type == \"random\") {\n        // Random values between 0 and 100000\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 100000);\n    } else if (type == \"checkerboard\") {\n        // Alternating 0 and 100000\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = ((i + j) % 2 == 0) ? 0 : 100000;\n    } else if (type == \"path\") {\n        // Maximum values along both paths, zeros elsewhere\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 0);\n        // For Iahub's path from (1,1) to (n,m)\n        int x = 0, y = 0;\n        while (x < n && y < m) {\n            a[x][y] = 100000;\n            if (x + 1 < n && y + 1 < m) {\n                if (rnd.next(2))\n                    ++x;\n                else\n                    ++y;\n            } else if (x + 1 < n) {\n                ++x;\n            } else {\n                ++y;\n            }\n        }\n        // For Iahubina's path from (n,1) to (1,m)\n        x = n - 1;\n        y = 0;\n        while (x >= 0 && y < m) {\n            a[x][y] = 100000;\n            if (x - 1 >= 0 && y + 1 < m) {\n                if (rnd.next(2))\n                    --x;\n                else\n                    ++y;\n            } else if (x - 1 >= 0) {\n                --x;\n            } else {\n                ++y;\n            }\n        }\n    } else if (type == \"anti-path\") {\n        // Zeros along the paths, maximum elsewhere\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 100000);\n        // For Iahub's path from (1,1) to (n,m)\n        int x = 0, y = 0;\n        while (x < n && y < m) {\n            a[x][y] = 0;\n            if (x + 1 < n && y + 1 < m) {\n                if (rnd.next(2))\n                    ++x;\n                else\n                    ++y;\n            } else if (x + 1 < n) {\n                ++x;\n            } else {\n                ++y;\n            }\n        }\n        // For Iahubina's path from (n,1) to (1,m)\n        x = n - 1;\n        y = 0;\n        while (x >= 0 && y < m) {\n            a[x][y] = 0;\n            if (x - 1 >= 0 && y + 1 < m) {\n                if (rnd.next(2))\n                    --x;\n                else\n                    ++y;\n            } else if (x - 1 >= 0) {\n                --x;\n            } else {\n                ++y;\n            }\n        }\n    } else if (type == \"meet-early\") {\n        // Maximum values, with high gain before an early meet point\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n\n        // Set meet point early, at (1,1) if possible\n        int meet_x = min(1, n - 1);\n        int meet_y = min(1, m - 1);\n        a[meet_x][meet_y] = 0; // Meet cell, neither gains from it\n\n        // High gains before the meet point\n        for(int i = 0; i <= meet_x; ++i)\n            for(int j = 0; j <= meet_y; ++j)\n                a[i][j] = 100000;\n    } else if (type == \"meet-late\") {\n        // Maximum values, with high gain after a late meet point\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n\n        // Set meet point late, at (n-2, m-2) if possible\n        int meet_x = max(n - 2, 0);\n        int meet_y = max(m - 2, 0);\n        a[meet_x][meet_y] = 0; // Meet cell, neither gains from it\n\n        // High gains after the meet point\n        for(int i = meet_x; i < n; ++i)\n            for(int j = meet_y; j < m; ++j)\n                a[i][j] = 100000;\n    } else if (type == \"special1\") {\n        // High gain at meet cell, others are low\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 1);\n\n        // Set meet cell somewhere in the middle\n        int meet_x = n / 2;\n        int meet_y = m / 2;\n        a[meet_x][meet_y] = 100000; // High gain at meet cell\n    } else if (type == \"special2\") {\n        // All high gains except at the meet cell\n        for(int i = 0; i < n; ++i)\n            fill(a[i].begin(), a[i].end(), 100000);\n\n        // Set meet cell somewhere in the middle\n        int meet_x = n / 2;\n        int meet_y = m / 2;\n        a[meet_x][meet_y] = 0; // Zero gain at meet cell\n    } else {\n        // Default to random\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, 100000);\n    }\n\n    // Output the matrix\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < m; ++j) {\n            printf(\"%d\", a[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -type zero\n./gen -n 3 -m 3 -type ones\n./gen -n 3 -m 3 -type max\n./gen -n 3 -m 3 -type random\n./gen -n 3 -m 3 -type checkerboard\n./gen -n 3 -m 3 -type path\n./gen -n 3 -m 3 -type anti-path\n./gen -n 3 -m 3 -type meet-early\n./gen -n 3 -m 3 -type meet-late\n./gen -n 3 -m 3 -type special1\n./gen -n 3 -m 3 -type special2\n\n./gen -n 1000 -m 1000 -type zero\n./gen -n 1000 -m 1000 -type ones\n./gen -n 1000 -m 1000 -type max\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type checkerboard\n./gen -n 1000 -m 1000 -type path\n./gen -n 1000 -m 1000 -type anti-path\n./gen -n 1000 -m 1000 -type meet-early\n./gen -n 1000 -m 1000 -type meet-late\n./gen -n 1000 -m 1000 -type special1\n./gen -n 1000 -m 1000 -type special2\n\n./gen -n 3 -m 1000 -type random\n./gen -n 1000 -m 3 -type random\n\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 500 -type checkerboard\n\n./gen -n 999 -m 1000 -type anti-path\n./gen -n 1000 -m 999 -type anti-path\n\n./gen -n 1000 -m 1000 -type meet-early\n./gen -n 1000 -m 1000 -type meet-late\n\n./gen -n 1000 -m 1000 -type special1\n./gen -n 1000 -m 1000 -type special2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:31.130260",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "429/C",
      "title": "C. Guess the Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 24). Next line contains n positive integers: the i-th number represents ci (1 ≤ ci ≤ n).",
      "output_spec": "OutputOutput on the first line \"YES\" (without quotes) if there exist at least one tree following Iahub's restrictions, otherwise output \"NO\" (without quotes).",
      "sample_tests": "ExamplesInputCopy41 1 1 4OutputCopyYESInputCopy51 1 5 2 1OutputCopyNO",
      "description": "C. Guess the Tree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 24). Next line contains n positive integers: the i-th number represents ci (1 ≤ ci ≤ n).\n\nOutputOutput on the first line \"YES\" (without quotes) if there exist at least one tree following Iahub's restrictions, otherwise output \"NO\" (without quotes).\n\nInputCopy41 1 1 4OutputCopyYESInputCopy51 1 5 2 1OutputCopyNO\n\nInputCopy41 1 1 4\n\nOutputCopyYES\n\nInputCopy51 1 5 2 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 429\\s*C"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, n, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, n, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, n, \"c_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 24;\n\nstruct Node {\n    int id;\n    vector<Node*> children;\n};\n\nint getSubtreeSize(Node* node, vector<int>& c) {\n    int sz = 1;\n    for (Node* child : node->children) {\n        sz += getSubtreeSize(child, c);\n    }\n    c[node->id] = sz;\n    return sz;\n}\n\nvoid generateValidTree(int n, vector<int>& c) {\n    // Build a tree where each internal node has at least two children\n    // Start with a root node\n    vector<Node*> nodes(n);\n    for (int i = 0; i < n; ++i) {\n        nodes[i] = new Node();\n        nodes[i]->id = i;\n    }\n    vector<Node*> leafNodes;\n    leafNodes.push_back(nodes[0]); // Root node\n\n    int usedNodes = 1;\n\n    while (usedNodes < n) {\n        // Choose a leaf node to expand\n        int idx = rnd.next(leafNodes.size());\n        Node* leaf = leafNodes[idx];\n        leafNodes.erase(leafNodes.begin() + idx);\n        // Decide how many children to add (at least 2)\n        int remainingNodes = n - usedNodes;\n        int minChildren = 2;\n        int maxChildren = remainingNodes >= 2 ? remainingNodes : 0;\n        if (maxChildren == 0) {\n            // No more nodes can be added\n            break;\n        }\n        int numChildren = min(remainingNodes, minChildren + rnd.next(remainingNodes - minChildren +1));\n        if (numChildren < 2) numChildren = 2; // Ensure at least 2 children\n\n        for (int i = 0; i < numChildren && usedNodes < n; ++i) {\n            Node* child = nodes[usedNodes++];\n            leaf->children.push_back(child);\n            leafNodes.push_back(child);\n        }\n    }\n    // Compute ci\n    c.resize(n);\n    getSubtreeSize(nodes[0], c);\n    // Clean up nodes\n    for (int i = 0; i < n; ++i) {\n        delete nodes[i];\n    }\n}\n\nvoid generateInvalidCi(int n, vector<int>& c) {\n    // Generate random ci's that are invalid\n    c.resize(n);\n    for (int i = 0; i < n; ++i) {\n        c[i] = rnd.next(1, n);\n    }\n    // Introduce inconsistency\n    int idx = rnd.next(n);\n    c[idx] = n; // Set one ci to n\n    if (n >= 2) {\n        c[(idx+1)%n] = n; // Set another ci to n\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (n < 1 || n > MAXN) {\n        cerr << \"Error: n must be between 1 and \" << MAXN << endl;\n        return 1;\n    }\n\n    vector<int> c;\n    if (type == \"valid\") {\n        generateValidTree(n, c);\n    } else if (type == \"invalid\") {\n        generateInvalidCi(n, c);\n    } else {\n        cerr << \"Error: type must be 'valid' or 'invalid'\" << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 24;\n\nstruct Node {\n    int id;\n    vector<Node*> children;\n};\n\nint getSubtreeSize(Node* node, vector<int>& c) {\n    int sz = 1;\n    for (Node* child : node->children) {\n        sz += getSubtreeSize(child, c);\n    }\n    c[node->id] = sz;\n    return sz;\n}\n\nvoid generateValidTree(int n, vector<int>& c) {\n    // Build a tree where each internal node has at least two children\n    // Start with a root node\n    vector<Node*> nodes(n);\n    for (int i = 0; i < n; ++i) {\n        nodes[i] = new Node();\n        nodes[i]->id = i;\n    }\n    vector<Node*> leafNodes;\n    leafNodes.push_back(nodes[0]); // Root node\n\n    int usedNodes = 1;\n\n    while (usedNodes < n) {\n        // Choose a leaf node to expand\n        int idx = rnd.next(leafNodes.size());\n        Node* leaf = leafNodes[idx];\n        leafNodes.erase(leafNodes.begin() + idx);\n        // Decide how many children to add (at least 2)\n        int remainingNodes = n - usedNodes;\n        int minChildren = 2;\n        int maxChildren = remainingNodes >= 2 ? remainingNodes : 0;\n        if (maxChildren == 0) {\n            // No more nodes can be added\n            break;\n        }\n        int numChildren = min(remainingNodes, minChildren + rnd.next(remainingNodes - minChildren +1));\n        if (numChildren < 2) numChildren = 2; // Ensure at least 2 children\n\n        for (int i = 0; i < numChildren && usedNodes < n; ++i) {\n            Node* child = nodes[usedNodes++];\n            leaf->children.push_back(child);\n            leafNodes.push_back(child);\n        }\n    }\n    // Compute ci\n    c.resize(n);\n    getSubtreeSize(nodes[0], c);\n    // Clean up nodes\n    for (int i = 0; i < n; ++i) {\n        delete nodes[i];\n    }\n}\n\nvoid generateInvalidCi(int n, vector<int>& c) {\n    // Generate random ci's that are invalid\n    c.resize(n);\n    for (int i = 0; i < n; ++i) {\n        c[i] = rnd.next(1, n);\n    }\n    // Introduce inconsistency\n    int idx = rnd.next(n);\n    c[idx] = n; // Set one ci to n\n    if (n >= 2) {\n        c[(idx+1)%n] = n; // Set another ci to n\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"valid\");\n\n    if (n < 1 || n > MAXN) {\n        cerr << \"Error: n must be between 1 and \" << MAXN << endl;\n        return 1;\n    }\n\n    vector<int> c;\n    if (type == \"valid\") {\n        generateValidTree(n, c);\n    } else if (type == \"invalid\") {\n        generateInvalidCi(n, c);\n    } else {\n        cerr << \"Error: type must be 'valid' or 'invalid'\" << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type valid\n\n./gen -n 2 -type valid\n./gen -n 2 -type invalid\n\n./gen -n 3 -type valid\n./gen -n 3 -type invalid\n\n./gen -n 4 -type valid\n./gen -n 4 -type invalid\n\n./gen -n 5 -type valid\n./gen -n 5 -type invalid\n\n./gen -n 6 -type valid\n./gen -n 6 -type invalid\n\n./gen -n 7 -type valid\n./gen -n 7 -type invalid\n\n./gen -n 8 -type valid\n./gen -n 8 -type invalid\n\n./gen -n 9 -type valid\n./gen -n 9 -type invalid\n\n./gen -n 10 -type valid\n./gen -n 10 -type invalid\n\n./gen -n 12 -type valid\n./gen -n 12 -type invalid\n\n./gen -n 15 -type valid\n./gen -n 15 -type invalid\n\n./gen -n 18 -type valid\n./gen -n 18 -type invalid\n\n./gen -n 20 -type valid\n./gen -n 20 -type invalid\n\n./gen -n 24 -type valid\n./gen -n 24 -type invalid\n\n./gen -n 24 -type valid\n./gen -n 24 -type valid\n./gen -n 24 -type invalid\n./gen -n 24 -type invalid\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:33.071138",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "429/D",
      "title": "D. Tricky Function",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (2 ≤ n ≤ 100000). Next line contains n integers a[1], a[2], ..., a[n] ( - 104 ≤ a[i] ≤ 104).",
      "output_spec": "OutputOutput a single integer — the value of mini ≠ j  f(i, j).",
      "sample_tests": "ExamplesInputCopy41 0 0 -1OutputCopy1InputCopy21 -1OutputCopy2",
      "description": "D. Tricky Function\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains a single integer n (2 ≤ n ≤ 100000). Next line contains n integers a[1], a[2], ..., a[n] ( - 104 ≤ a[i] ≤ 104).\n\nOutputOutput a single integer — the value of mini ≠ j  f(i, j).\n\nInputCopy41 0 0 -1OutputCopy1InputCopy21 -1OutputCopy2\n\nInputCopy41 0 0 -1\n\nOutputCopy1\n\nInputCopy21 -1\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 429\\s*D"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, -10000, 10000, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_A = 10000;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        /* All elements are zero */\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"all_max\") {\n        /* All elements are MAX_A */\n        for (int i = 0; i < n; ++i)\n            a[i] = MAX_A;\n    } else if (type == \"all_min\") {\n        /* All elements are -MAX_A */\n        for (int i = 0; i < n; ++i)\n            a[i] = -MAX_A;\n    } else if (type == \"alternating\") {\n        /* Alternating MAX_A and -MAX_A */\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? MAX_A : -MAX_A;\n    } else if (type == \"one_zero\") {\n        /* All random elements, except one zero */\n        int zero_pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n            if (i == zero_pos)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(-MAX_A, MAX_A);\n    } else if (type == \"large_zero_sum\") {\n        /* Create sequences where some ranges sum to zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-MAX_A / 2, MAX_A / 2);\n        }\n        /* Adjust elements to make certain ranges sum to zero */\n        int m = n / 10; // Number of zero-sum ranges\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(0, n - 2);\n            int r = rnd.next(l + 1, n - 1);\n            long long sum = 0;\n            for (int k = l + 1; k <= r; ++k)\n                sum += a[k];\n            if (sum != 0) {\n                int idx = rnd.next(0, 1) ? l : r;\n                a[idx] = -sum;\n                if (a[idx] > MAX_A) a[idx] = MAX_A;\n                if (a[idx] < -MAX_A) a[idx] = -MAX_A;\n            }\n        }\n    } else if (type == \"random\") {\n        /* Random elements in range [-MAX_A, MAX_A] */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-MAX_A, MAX_A);\n    } else if (type == \"small_random\") {\n        /* Random elements in range [-10, 10] */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10, 10);\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-MAX_A, MAX_A);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a[1..n]\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_A = 10000;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"all_zero\") {\n        /* All elements are zero */\n        for (int i = 0; i < n; ++i)\n            a[i] = 0;\n    } else if (type == \"all_max\") {\n        /* All elements are MAX_A */\n        for (int i = 0; i < n; ++i)\n            a[i] = MAX_A;\n    } else if (type == \"all_min\") {\n        /* All elements are -MAX_A */\n        for (int i = 0; i < n; ++i)\n            a[i] = -MAX_A;\n    } else if (type == \"alternating\") {\n        /* Alternating MAX_A and -MAX_A */\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? MAX_A : -MAX_A;\n    } else if (type == \"one_zero\") {\n        /* All random elements, except one zero */\n        int zero_pos = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i)\n            if (i == zero_pos)\n                a[i] = 0;\n            else\n                a[i] = rnd.next(-MAX_A, MAX_A);\n    } else if (type == \"large_zero_sum\") {\n        /* Create sequences where some ranges sum to zero */\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-MAX_A / 2, MAX_A / 2);\n        }\n        /* Adjust elements to make certain ranges sum to zero */\n        int m = n / 10; // Number of zero-sum ranges\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(0, n - 2);\n            int r = rnd.next(l + 1, n - 1);\n            long long sum = 0;\n            for (int k = l + 1; k <= r; ++k)\n                sum += a[k];\n            if (sum != 0) {\n                int idx = rnd.next(0, 1) ? l : r;\n                a[idx] = -sum;\n                if (a[idx] > MAX_A) a[idx] = MAX_A;\n                if (a[idx] < -MAX_A) a[idx] = -MAX_A;\n            }\n        }\n    } else if (type == \"random\") {\n        /* Random elements in range [-MAX_A, MAX_A] */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-MAX_A, MAX_A);\n    } else if (type == \"small_random\") {\n        /* Random elements in range [-10, 10] */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-10, 10);\n    } else {\n        /* Default to random */\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(-MAX_A, MAX_A);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output array a[1..n]\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n test cases\n./gen -n 2 -type all_zero\n./gen -n 2 -type all_max\n./gen -n 2 -type all_min\n./gen -n 2 -type random\n./gen -n 2 -type one_zero\n./gen -n 2 -type alternating\n./gen -n 2 -type large_zero_sum\n\n./gen -n 3 -type random\n./gen -n 3 -type large_zero_sum\n\n# Medium n test cases\n./gen -n 100 -type random\n./gen -n 100 -type alternating\n./gen -n 100 -type all_zero\n./gen -n 100 -type one_zero\n./gen -n 100 -type large_zero_sum\n\n# Large n test cases\n./gen -n 100000 -type all_zero\n./gen -n 100000 -type all_max\n./gen -n 100000 -type all_min\n./gen -n 100000 -type random\n./gen -n 100000 -type small_random\n./gen -n 100000 -type alternating\n./gen -n 100000 -type one_zero\n./gen -n 100000 -type large_zero_sum\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:35.435529",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "429/E",
      "title": "E. Points and Segments",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains integer n (1 ≤ n ≤ 105) — the number of segments. The i-th of the next n lines contains two integers li and ri (0 ≤ li ≤ ri ≤ 109) — the borders of the i-th segment.It's guaranteed that all the segments are distinct.",
      "output_spec": "OutputIf there is no good drawing for a given test, output a single integer -1. Otherwise output n integers; each integer must be 0 or 1. The i-th number denotes the color of the i-th segment (0 is red and 1 is blue).If there are multiple good drawings you can output any of them.",
      "sample_tests": "ExamplesInputCopy20 22 3OutputCopy0 1InputCopy61 51 33 52 1011 1112 12OutputCopy0 1 0 1 0 0",
      "description": "E. Points and Segments\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains integer n (1 ≤ n ≤ 105) — the number of segments. The i-th of the next n lines contains two integers li and ri (0 ≤ li ≤ ri ≤ 109) — the borders of the i-th segment.It's guaranteed that all the segments are distinct.\n\nOutputIf there is no good drawing for a given test, output a single integer -1. Otherwise output n integers; each integer must be 0 or 1. The i-th number denotes the color of the i-th segment (0 is red and 1 is blue).If there are multiple good drawings you can output any of them.\n\nInputCopy20 22 3OutputCopy0 1InputCopy61 51 33 52 1011 1112 12OutputCopy0 1 0 1 0 0\n\nInputCopy20 22 3\n\nOutputCopy0 1\n\nInputCopy61 51 33 52 1011 1112 12\n\nOutputCopy0 1 0 1 0 0",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 429\\s*E"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int> > segments;\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n        pair<int, int> seg = make_pair(li, ri);\n        ensuref(segments.insert(seg).second, \"Segments must be distinct: segment [%d, %d] is duplicated\", li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int> > segments;\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n        pair<int, int> seg = make_pair(li, ri);\n        ensuref(segments.insert(seg).second, \"Segments must be distinct: segment [%d, %d] is duplicated\", li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    set<pair<int, int> > segments;\n\n    for (int i = 0; i < n; ++i) {\n        int li = inf.readInt(0, 1000000000, \"li\");\n        inf.readSpace();\n        int ri = inf.readInt(li, 1000000000, \"ri\");\n        inf.readEoln();\n        pair<int, int> seg = make_pair(li, ri);\n        ensuref(segments.insert(seg).second, \"Segments must be distinct: segment [%d, %d] is duplicated\", li, ri);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    vector<ll> li(n), ri(n);\n    set<pair<ll, ll>> segments_set; // to ensure segments are distinct\n\n    for (int i = 0; i < n; ++i) {\n        li[i] = inf.readLong();\n        ri[i] = inf.readLong();\n        if (segments_set.count({li[i], ri[i]}) > 0) {\n            quitf(_fail, \"Segments are not distinct in the input.\");\n        }\n        segments_set.insert({li[i], ri[i]});\n    }\n\n    // Read contestant's output\n    vector<int> c(n);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) {\n            // No need to check for spaces or newlines explicitly\n            // readInt takes care of skipping whitespaces\n        }\n        c[i] = ouf.readInt(0, 1, format(\"c[%d]\", i + 1).c_str());\n    }\n\n    // Build counts of red and blue segments over the x-axis\n    map<ll, int> counts; // Map from position x to delta in (r_x - b_x)\n    for (int i = 0; i < n; ++i) {\n        if (c[i] == 0) {\n            // Red segment\n            counts[li[i]] += 1;\n            counts[ri[i] + 1] -= 1;\n        } else if (c[i] == 1) {\n            // Blue segment\n            counts[li[i]] += -1;\n            counts[ri[i] + 1] += 1;\n        } else {\n            ouf.quitf(_wa, \"Invalid color %d at index %d. Colors must be 0 or 1.\", c[i], i + 1);\n        }\n    }\n\n    // Process the counts\n    ll prev_x = -1; // Start from -1 to include all possible x\n    int count = 0;  // Current value of (r_x - b_x)\n\n    for (auto it = counts.begin(); it != counts.end(); ++it) {\n        ll x = it->first;\n        if (prev_x != -1 && prev_x < x) {\n            // For interval [prev_x, x - 1], count remains constant\n            if (abs(count) > 1) {\n                ouf.quitf(_wa, \"Condition |r_x - b_x| <= 1 violated in interval [%lld, %lld].\", prev_x, x - 1);\n            }\n        }\n        count += it->second;\n        if (abs(count) > 1) {\n            // Check at position x\n            ouf.quitf(_wa, \"Condition |r_x - b_x| <= 1 violated at position x = %lld.\", x);\n        }\n        prev_x = x;\n    }\n\n    // After the last position, counts remain constant\n    if (abs(count) > 1) {\n        ouf.quitf(_wa, \"Condition |r_x - b_x| <= 1 violated after position x = %lld.\", prev_x);\n    }\n\n    // If we reach here, the output is correct\n    ouf.quitf(_ok, \"Correct coloring.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<ll, ll>> segments_set; // To store segments and ensure they are distinct\n    vector<pair<ll, ll>> segments;\n\n    if (type == \"random\") {\n        while ((int)segments_set.size() < n) {\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = rnd.next(li, 1000000000LL);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    } else if (type == \"full_overlap\") {\n        ll x = rnd.next(0LL, 1000000000LL);\n        while ((int)segments_set.size() < n) {\n            ll left = rnd.next(0LL, x);\n            ll right = rnd.next(x, 1000000000LL);\n            if (segments_set.insert({left, right}).second) {\n                segments.push_back({left, right});\n            }\n        }\n    } else if (type == \"single_point\") {\n        set<ll> points;\n        while ((int)points.size() < n) {\n            ll x = rnd.next(0LL, 1000000000LL);\n            if (points.insert(x).second) {\n                segments.push_back({x, x});\n            }\n        }\n    } else if (type == \"non_overlapping\") {\n        ll current_li = 0LL;\n        ll step = (1000000000LL) / n;\n        while ((int)segments_set.size() < n) {\n            ll li = current_li;\n            ll max_ri = li + step - 1;\n            if (max_ri > 1000000000LL) max_ri = 1000000000LL;\n            ll ri = rnd.next(li, max_ri);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n                current_li = ri + 1;\n                if (current_li > 1000000000LL) break;\n            } else {\n                current_li++;\n            }\n        }\n    } else if (type == \"touching\") {\n        ll start = rnd.next(0LL, 1000000000LL - n);\n        ll current = start;\n        for (int i = 0; i < n; ++i) {\n            ll li = current;\n            ll ri = li + rnd.next(0LL, 1000LL); // small length\n            if (ri > 1000000000LL) ri = 1000000000LL;\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n                current = ri; // next segment starts where this one ends\n                if (current > 1000000000LL) break;\n            } else {\n                current++;\n            }\n        }\n        while ((int)segments.size() < n) {\n            // we might need to generate more segments\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = li + rnd.next(0LL, 1000LL);\n            if (ri > 1000000000LL) ri = 1000000000LL;\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    } else if (type == \"nested\") {\n        ll min_li = 0LL;\n        ll max_ri = 1000000000LL;\n        for (int i = 0; i < n; ++i) {\n            if (segments_set.insert({min_li, max_ri}).second) {\n                segments.push_back({min_li, max_ri});\n                // Adjust min_li and max_ri\n                if (i < n - 1) {\n                    ll delta_li = rnd.next(0LL, (max_ri - min_li) / (n - i));\n                    min_li += delta_li;\n                    ll delta_ri = rnd.next(0LL, (max_ri - min_li) / (n - i));\n                    max_ri -= delta_ri;\n                    if (min_li > max_ri) break;\n                }\n            } else {\n                min_li++;\n            }\n        }\n        while ((int)segments.size() < n) {\n            // generate random segments\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = rnd.next(li, 1000000000LL);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        while ((int)segments_set.size() < n) {\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = rnd.next(li, 1000000000LL);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    }\n\n    // Shuffle the segments\n    shuffle(segments.begin(), segments.end());\n\n    printf(\"%d\\n\", n);\n    for (const auto& s : segments) {\n        printf(\"%lld %lld\\n\", s.first, s.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    set<pair<ll, ll>> segments_set; // To store segments and ensure they are distinct\n    vector<pair<ll, ll>> segments;\n\n    if (type == \"random\") {\n        while ((int)segments_set.size() < n) {\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = rnd.next(li, 1000000000LL);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    } else if (type == \"full_overlap\") {\n        ll x = rnd.next(0LL, 1000000000LL);\n        while ((int)segments_set.size() < n) {\n            ll left = rnd.next(0LL, x);\n            ll right = rnd.next(x, 1000000000LL);\n            if (segments_set.insert({left, right}).second) {\n                segments.push_back({left, right});\n            }\n        }\n    } else if (type == \"single_point\") {\n        set<ll> points;\n        while ((int)points.size() < n) {\n            ll x = rnd.next(0LL, 1000000000LL);\n            if (points.insert(x).second) {\n                segments.push_back({x, x});\n            }\n        }\n    } else if (type == \"non_overlapping\") {\n        ll current_li = 0LL;\n        ll step = (1000000000LL) / n;\n        while ((int)segments_set.size() < n) {\n            ll li = current_li;\n            ll max_ri = li + step - 1;\n            if (max_ri > 1000000000LL) max_ri = 1000000000LL;\n            ll ri = rnd.next(li, max_ri);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n                current_li = ri + 1;\n                if (current_li > 1000000000LL) break;\n            } else {\n                current_li++;\n            }\n        }\n    } else if (type == \"touching\") {\n        ll start = rnd.next(0LL, 1000000000LL - n);\n        ll current = start;\n        for (int i = 0; i < n; ++i) {\n            ll li = current;\n            ll ri = li + rnd.next(0LL, 1000LL); // small length\n            if (ri > 1000000000LL) ri = 1000000000LL;\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n                current = ri; // next segment starts where this one ends\n                if (current > 1000000000LL) break;\n            } else {\n                current++;\n            }\n        }\n        while ((int)segments.size() < n) {\n            // we might need to generate more segments\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = li + rnd.next(0LL, 1000LL);\n            if (ri > 1000000000LL) ri = 1000000000LL;\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    } else if (type == \"nested\") {\n        ll min_li = 0LL;\n        ll max_ri = 1000000000LL;\n        for (int i = 0; i < n; ++i) {\n            if (segments_set.insert({min_li, max_ri}).second) {\n                segments.push_back({min_li, max_ri});\n                // Adjust min_li and max_ri\n                if (i < n - 1) {\n                    ll delta_li = rnd.next(0LL, (max_ri - min_li) / (n - i));\n                    min_li += delta_li;\n                    ll delta_ri = rnd.next(0LL, (max_ri - min_li) / (n - i));\n                    max_ri -= delta_ri;\n                    if (min_li > max_ri) break;\n                }\n            } else {\n                min_li++;\n            }\n        }\n        while ((int)segments.size() < n) {\n            // generate random segments\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = rnd.next(li, 1000000000LL);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    } else {\n        // Default to random if type is unrecognized\n        while ((int)segments_set.size() < n) {\n            ll li = rnd.next(0LL, 1000000000LL);\n            ll ri = rnd.next(li, 1000000000LL);\n            if (segments_set.insert({li, ri}).second) {\n                segments.push_back({li, ri});\n            }\n        }\n    }\n\n    // Shuffle the segments\n    shuffle(segments.begin(), segments.end());\n\n    printf(\"%d\\n\", n);\n    for (const auto& s : segments) {\n        printf(\"%lld %lld\\n\", s.first, s.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 1 -type random\n./gen -n 1 -type full_overlap\n./gen -n 1 -type single_point\n\n./gen -n 2 -type nested\n./gen -n 2 -type touching\n\n# Medium n\n./gen -n 10 -type random\n./gen -n 10 -type full_overlap\n./gen -n 10 -type single_point\n./gen -n 10 -type non_overlapping\n\n./gen -n 1000 -type random\n./gen -n 1000 -type full_overlap\n./gen -n 1000 -type single_point\n./gen -n 1000 -type non_overlapping\n./gen -n 1000 -type nested\n./gen -n 1000 -type touching\n\n# Larger n\n./gen -n 10000 -type random\n./gen -n 10000 -type full_overlap\n./gen -n 10000 -type single_point\n./gen -n 10000 -type non_overlapping\n./gen -n 10000 -type nested\n./gen -n 10000 -type touching\n\n./gen -n 50000 -type random\n./gen -n 50000 -type full_overlap\n./gen -n 50000 -type single_point\n./gen -n 50000 -type non_overlapping\n./gen -n 50000 -type nested\n./gen -n 50000 -type touching\n\n# Max n\n./gen -n 100000 -type random\n./gen -n 100000 -type full_overlap\n./gen -n 100000 -type single_point\n./gen -n 100000 -type non_overlapping\n./gen -n 100000 -type nested\n./gen -n 100000 -type touching\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:37.294995",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "43/A",
      "title": "A. Football",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100) — the number of lines in the description. Then follow n lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.",
      "output_spec": "OutputPrint the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.",
      "sample_tests": "ExamplesInputCopy1ABCOutputCopyABCInputCopy5AABAABAAAOutputCopyA",
      "description": "A. Football\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100) — the number of lines in the description. Then follow n lines — for each goal the names of the teams that scored it. The names are non-empty lines consisting of uppercase Latin letters whose lengths do not exceed 10 symbols. It is guaranteed that the match did not end in a tie and the description contains no more than two different teams.\n\nOutputPrint the name of the winning team. We remind you that in football the team that scores more goals is considered the winner.\n\nInputCopy1ABCOutputCopyABCInputCopy5AABAABAAAOutputCopyA\n\nInputCopy1ABC\n\nOutputCopyABC\n\nInputCopy5AABAABAAA\n\nOutputCopyA",
      "solutions": [
        {
          "title": "Codeforces Beta Round #42 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good eveningYesterday evening the Saratov university delegation returned from St. Petersburg, from the ACM-ICPC NEERC 2010/11 World Programming Championship semi-finals. If you haven't seen the final standings: 4 Saratov teams received diplomas, and we (Saratov SU 2) advanced to the finals. Saratov SU 1 was also among those, who advanced, that's pretty cool for their first time, but didn't advance because of the limitation \"only one team from one university\".Also we have prepared a Div. 2 round. Thanks for prompt assistance to Edvard Davtyan, Gerald Agapov and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: MiminoUnfortunately, the discrepancy between author’s solution and statement of problem E was detected. We bring our apologies to all the participants. All solutions that have not been Accepted previously were rejudged. Thanks to member xcr for detection of the issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/900",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 915
        },
        {
          "title": "Разбор задач A, B, C, D CodeForces Beta Round #42 - Codeforces",
          "content": "А. Футбол.Эту задачу можно решить, не расходуя лишнюю память, а заведя лишь две строки для хранения названий первой и (возможно) второй команд и две целочисленные переменные для хранения количества голов, забитых первой и второй командами. Считываем название первой команды, запоминаем в первой строке и идем циклом до n - 1. На каждом шаге если считанная строка совпадает с уже имеющейся (первой строкой - она всегда есть, так как мы ее заранее (до цикла) считали), то увеличиваем счет этой команды, иначе запоминаем название второй команды и увеличиваем ее счет. В конце делаем целочисленное сравнение и выводим одну из строк.Заметим, что даже если вторая строка останется неинициализированной, ничего плохого не произойдет, так как мы к ней никогда не общаемся, кроме случая, когда победила вторая команда (значит, у нее ненулевое количество голов и строку мы все-таки инициализировали).B. Письмо.Известно, что символы из таблицы ASCII, к которым относятся все (строчные и заглавные) латинские буквы и пробел, имеют коды от 0 до 127. Значит, достаточно завести два массива на 128 символов (можно узнать требуемую память точнее, но char занимает 1 (или 2 байта в Java), поэтому это непринципиально), инициализированных нулями, и заполнить каждый из них следующим образом: идем циклом по строке, получаем код текущего символа строки, элемент массива с таким индексом (кодом символа) увеличиваем на единицу. Таким образом получим два массива - один для первой строки и один для второй. Чтобы составить вторую строку, нужно, чтобы выполнялось условие b[i] <= a[i] для всех i от 0 до 127, кроме (char)i == ' '. Пробелы вырезать ненужно, поэтому для них неравенство может не выполняться.С. Счастливые билеты.Признак делимости на три говорит нам, что натуральное число делится на три тогда и только тогда, когда сумма его цифр делится на 3. Для каждого кусочка билетика мы можем посчитать остатки от деления этого числа на 3 - 0, 1 или 2. Обозначим количество билетов первого типа - a, второго типа -  b, третьего - с. Счастливые билетики можно составить двумя способами: либо соединить кусочки с остатками от деления 0 и 0, либо - 1 и 2. Тогда сумма чисел на получившемся билетике будет 3, что и требуется. Ответом будет число a / 2 + min(b, c). Оставшиеся a % 2 + max(a, b) - min(a, b) билетиков придется выкинуть, так как для них нет соответствующей пары.D. ПутешествиеСперва заметим, что в оптимальном решении может быть не более одного телепорта. Таблицу n * m можно обойти несколькими способами, перемещаясь только по соседним клеткам - например, змейкой или спиралью. Далее, из последней клетки, в которую мы пришли при обходе таблицы, можно телепортироваться в первую.В этой задаче нужно было рассмотреть 4 случая:1. n * m = 2 - тогда ответ легко выписать вручную2. n = 1, m > 2; n > 2, m = 1 - идем по полоске до конца, а из последней клетки ((1, m) или (n, 1)) телепортируемся в первую3. оба n и m нечетные (ни одно из чисел не равно 1) - тогда нужна одна телепортация: обходим доску одним из предложенных способов: змейкой (вверх-вниз или вправо-влево) или по спирали - а из последней клетки телепортируемся4. хотя бы одно из чисел четное, а другое не равно единице - тогда идем вдоль четной стороны до края таблицы, а оставшуюся часть обходим змейкой + делаем один завершающий ход.Для пояснения пункта 4, рассмотрим пример.Пусть n - четное, m - нечетное (не равное 1). Тогда идем вдоль края таблицы из клетки (1, 1) в клетку (n, 1). Дальше возвращаемся в клетку (1, 2) следующим образом: если текущая строка i четная - идем вправо от 2 до m, иначе идем влево от m до 2. Заметим, что последней строкой, которую мы так пройдем, будет первая (по номеру), то есть мы действительно закончим в клетке (1, 2). Осталось сделать только заключительный ход в (1, 1).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/902",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3763
        },
        {
          "title": "CodeForces Beta Round #42 :: Разбор задач - Codeforces",
          "content": "Задача A. ФутболКлассическая задача A второго дивизиона. Можно было решить без хранения в памяти всех N строк входного файла. Хотя тесты проходило и любое решение, которое только можно себе представить.Решение без сохранения всех N строк в памяти: считывать все строки, при встрече незнакомой строки присваивать ей идентификатор. Для каждого идентификатора завести счетчик, который будет отражать, сколько раз строка встретилось во входном файле. Из двух строк выбрать ту, у которой значение счетчика больше.Задача B. ПисьмоСамое простое решение - это для каждой буквы (другие символы просто игнорировать) в обеих строках посчитать число ее вхождений. Если какая-то буква входит во вторую строку большее число раз, чем входит в первую, ответ \"NO\", иначе ответ \"YES\". Очевидная асимптотика решения O(L), где L - ограничение на длину строки во входном файле.Задача С. Счастливые билетыВсем известно условие делимости числа на 3: \"Число кратно трем, тогда и только тогда, когда сумма цифр этого числа делится без остатка на 3\". Соответственно, чтобы при склеивании двух чисел получить число кратное трем, необходим чтобы сумма цифр первого числа плюс сумма цифр второго числа было кратно трем.Стоит отметить, что оперировать в условиях этой задачи можно только с остатками от деления на 3. Несложно понять, что есть смысл соединять числа, которые дают в остатке от деления на 3 двойку с теми, кто дает в остатке единицу. Числа, которые нацело делятся на 3 можно объединять только с числами, которые так же делятся нацело на 3. Если посчитать количество чисел на кусках билетов с остатком от деления на 3 равным 0, 1, 2 (обозначим их как R0, R1, R2 соответственно), то ответом будет min(R1, R2) + [R0 / 2]. Здесь [] - операция округления в меньшую сторону.Задача D. ПутешествиеЗадача не требует знания каких-то алгоритмов, математики или даже банальной логики. От Вас требуется найти все частные случаи и не забыть рассмотреть каждый из них.Теста \"1 1\" быть не могло (ограничения такие).Для тестов \"1 2\" и \"2 1\" ответом служит последовательность из трех клеток (1 1, оставшаяся клетка, 1 1). Телепортов не требуется.Для тестов \"1 M\" и \"N 1\" (2 < N, M) ответом служит последовательность 1 1 -> 1 2 -> ... -> 1 M (ну и аналогично для перевернутого случая) и снова 1 1 в конце. Требуется один телепорт (1 M -> 1 1).Далее логика простая. Если хотя бы одна из сторон - четная, то пройти можно следующим алгоритмом:Рассмотрим случай, когда количество строк нечетно. При нечетном количестве столбцов можно действовать так же, поменяв строки и столбцы местами.Из клетки 1 1 шагнем в 1 2 и далее пойдем змейкой по прямоугольнику Rect(1, 2, N, M). То есть во время обхода змейкой не посещаем первую строку. Такой обход закончится в клетке с координатами 2 M. После чего можно шагнуть на 1 M и спокойно прийти по первой строке в 1 1.Для случая, когда N и M четные, можно воспользоваться тем же алгоритмом. Очевидно, что телепортов строить во всех этих случая не потребуется.Для случая, когда N и M нечетные всегда потребуется один телепорт. Если действовать по той же стратегии, то в конце обхода змейкой можно попасть только в клетку с координатами N M, откуда необходимо телепортироваться в клетку 1 M и пройтись по первой строке до клетки 1 1.Задача E. ГонкаЗадача не требует знания каких-то сложных формул из физики. Сразу открою занавесу и выпишу все формулы, которые потребуются при решении.X0 = 0Xn + 1 = Xn + Vn (Tn+1 - Tn), где Xi - координата, Ti - момент времениНесложно понять, что решение с асимптотикой O(SN2) получит заслуженный Time Limit. Решение с асимптотикой O(KN3) вполне сойдет. Впрочем, скорее всего существует решение с гораздо более хорошей трудоемкостью.Далее будет рассказано решение за O(KN3), которое имеет множество других достоинств.Будем рассматривать всю гонку, как набор некоторых событий упорядоченных во времени. События - изменение скорости какого-либо участника в какой-либо момент времени. Для каждого участника несложно (еще при чтении) получить все события, которые с ним связаны. Каждое из них обладает двумя параметрами: время, когда была сменена скорость и сама величина скорости. Все события можно объединить и упорядочить хронологически (в порядке неубывания времени, когда происходит событие).Теперь нет смысла идти по всем моментам времени (от 0 до S). Есть смысл рассматривать только моменты времени, в которые происходит хотя бы одно событие. Всего смен скоростей будет O(NK). Для дальнейшего решения можно сделать несколько утверждений:Между двумя соседними моментами времени (в которые происходят события) скорости автомобилей остаются постоянными. Соответственно, автомобиль i обгонит на участке между этими двумя моментами времени автомобиль j если Vi > Vj (иначе обгон точно не возможен). А далее требуется соблюдение одного из двух условий:Координата автомобиля i в первый момент времени меньше, чем у автомобиля j, а во второй момент времени координата автомобила i уже больше координаты автомобиля j.Координата автомобиля i в первый момент времени такая же, как у автомобиля j, а во второй момент координата автомобиля i больше координаты автомобиля j. При этом на предыдущем этапе координата автомобиля i была меньше (то есть он сравнялся с автомобилем j на прошлом интервале времени).На каждом временном интервале можно за O(N2) проверять для каждой пары (i, j) обгоняет ли автомобиль i автомобиль j.Каждое из вышеописанных условий можно проверить в целых числах (32 бита вполне хватает). Ответ так же не потребует 64-битовой переменной.Стоит отметить, что решение не использует значение S, которое дается во входном файле.  Дописав один IF можно получить решение, которое будет правильно обрабатывать даже случаи, когда автомобили некоторое время ехали бок о бок.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5709
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    map<string, int> goal_count;\n    for (int i = 0; i < n; ++i) {\n        string team = inf.readLine(\"[A-Z]{1,10}\", \"team name\");\n        goal_count[team]++;\n    }\n\n    inf.readEof();\n\n    ensuref(goal_count.size() <= 2, \"There are more than two different teams.\");\n\n    if (goal_count.size() == 2) {\n        auto it = goal_count.begin();\n        int score1 = it->second;\n        ++it;\n        int score2 = it->second;\n        ensuref(score1 != score2, \"The match ended in a tie.\");\n    }\n    // If there is only one team, no tie is possible.\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    map<string, int> goal_count;\n    for (int i = 0; i < n; ++i) {\n        string team = inf.readLine(\"[A-Z]{1,10}\", \"team name\");\n        goal_count[team]++;\n    }\n\n    inf.readEof();\n\n    ensuref(goal_count.size() <= 2, \"There are more than two different teams.\");\n\n    if (goal_count.size() == 2) {\n        auto it = goal_count.begin();\n        int score1 = it->second;\n        ++it;\n        int score2 = it->second;\n        ensuref(score1 != score2, \"The match ended in a tie.\");\n    }\n    // If there is only one team, no tie is possible.\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    map<string, int> goal_count;\n    for (int i = 0; i < n; ++i) {\n        string team = inf.readLine(\"[A-Z]{1,10}\", \"team name\");\n        goal_count[team]++;\n    }\n\n    inf.readEof();\n\n    ensuref(goal_count.size() <= 2, \"There are more than two different teams.\");\n\n    if (goal_count.size() == 2) {\n        auto it = goal_count.begin();\n        int score1 = it->second;\n        ++it;\n        int score2 = it->second;\n        ensuref(score1 != score2, \"The match ended in a tie.\");\n    }\n    // If there is only one team, no tie is possible.\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> teams;\n\n    if (type == \"one_team\") {\n        // Only one team scores all the goals\n        string team_name = \"\";\n        int len = rnd.next(1, 10);\n        for (int i = 0; i < len; ++i) {\n            team_name += (char)('A' + rnd.next(26));\n        }\n        teams.push_back(team_name);\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", teams[0].c_str());\n        }\n\n    } else if (type == \"minimal_win\") {\n        // Two teams, one wins by one goal\n        string team1 = \"\", team2 = \"\";\n        do {\n            int len1 = rnd.next(1, 10);\n            int len2 = rnd.next(1, 10);\n            team1 = \"\";\n            team2 = \"\";\n            for (int i = 0; i < len1; ++i) {\n                team1 += (char)('A' + rnd.next(26));\n            }\n            for (int i = 0; i < len2; ++i) {\n                team2 += (char)('A' + rnd.next(26));\n            }\n        } while (team1 == team2);\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = n / 2 + 1;\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else if (type == \"maximal_win\") {\n        // Two teams, one scores all the goals\n        string team1 = \"\", team2 = \"\";\n        do {\n            int len1 = rnd.next(1, 10);\n            int len2 = rnd.next(1, 10);\n            team1 = \"\";\n            team2 = \"\";\n            for (int i = 0; i < len1; ++i) {\n                team1 += (char)('A' + rnd.next(26));\n            }\n            for (int i = 0; i < len2; ++i) {\n                team2 += (char)('A' + rnd.next(26));\n            }\n        } while (team1 == team2);\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        // All goals scored by team1\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", team1.c_str());\n        }\n\n    } else if (type == \"similar_names\") {\n        // Team names differ by one character\n        int len = rnd.next(1, 10);\n        string base_name = \"\";\n        for (int i = 0; i < len; ++i) {\n            base_name += (char)('A' + rnd.next(26));\n        }\n\n        string team1 = base_name;\n        string team2 = base_name;\n        int pos = rnd.next(0, len - 1);\n        char new_char;\n        do {\n            new_char = (char)('A' + rnd.next(26));\n        } while (new_char == base_name[pos]);\n        team2[pos] = new_char;\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = rnd.next(n / 2 + 1, n);\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else if (type == \"max_length_names\") {\n        // Team names with maximum length (10 characters)\n        string team1 = \"\", team2 = \"\";\n        for (int i = 0; i < 10; ++i) {\n            team1 += (char)('A' + rnd.next(26));\n            team2 += (char)('A' + rnd.next(26));\n        }\n        if (team1 == team2) {\n            team2[0] = (char)((team2[0] - 'A' + 1) % 26 + 'A');\n        }\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = rnd.next(n / 2 + 1, n);\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else if (type == \"min_length_names\") {\n        // Team names with minimum length (1 character)\n        char ch1 = 'A' + rnd.next(26);\n        char ch2 = 'A' + rnd.next(26);\n        while (ch1 == ch2) {\n            ch2 = 'A' + rnd.next(26);\n        }\n\n        string team1 = string(1, ch1);\n        string team2 = string(1, ch2);\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = rnd.next(n / 2 + 1, n);\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else {\n        // Random test case\n        int num_teams = rnd.next(1, 2);\n\n        if (num_teams == 1) {\n            // Only one team\n            string team_name = \"\";\n            int len = rnd.next(1, 10);\n            for (int i = 0; i < len; ++i) {\n                team_name += (char)('A' + rnd.next(26));\n            }\n            teams.push_back(team_name);\n\n            printf(\"%d\\n\", n);\n            for (int i = 0; i < n; ++i) {\n                printf(\"%s\\n\", teams[0].c_str());\n            }\n\n        } else {\n            // Two teams\n            string team1 = \"\", team2 = \"\";\n            do {\n                int len1 = rnd.next(1, 10);\n                int len2 = rnd.next(1, 10);\n                team1 = \"\";\n                team2 = \"\";\n                for (int i = 0; i < len1; ++i) {\n                    team1 += (char)('A' + rnd.next(26));\n                }\n                for (int i = 0; i < len2; ++i) {\n                    team2 += (char)('A' + rnd.next(26));\n                }\n            } while (team1 == team2);\n\n            teams.push_back(team1);\n            teams.push_back(team2);\n\n            int goals_team1 = rnd.next(n / 2 + 1, n);\n            int goals_team2 = n - goals_team1;\n\n            vector<string> goals;\n            for (int i = 0; i < goals_team1; ++i) {\n                goals.push_back(team1);\n            }\n            for (int i = 0; i < goals_team2; ++i) {\n                goals.push_back(team2);\n            }\n\n            shuffle(goals.begin(), goals.end());\n\n            // Output\n            printf(\"%d\\n\", n);\n            for (auto& goal : goals) {\n                printf(\"%s\\n\", goal.c_str());\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> teams;\n\n    if (type == \"one_team\") {\n        // Only one team scores all the goals\n        string team_name = \"\";\n        int len = rnd.next(1, 10);\n        for (int i = 0; i < len; ++i) {\n            team_name += (char)('A' + rnd.next(26));\n        }\n        teams.push_back(team_name);\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", teams[0].c_str());\n        }\n\n    } else if (type == \"minimal_win\") {\n        // Two teams, one wins by one goal\n        string team1 = \"\", team2 = \"\";\n        do {\n            int len1 = rnd.next(1, 10);\n            int len2 = rnd.next(1, 10);\n            team1 = \"\";\n            team2 = \"\";\n            for (int i = 0; i < len1; ++i) {\n                team1 += (char)('A' + rnd.next(26));\n            }\n            for (int i = 0; i < len2; ++i) {\n                team2 += (char)('A' + rnd.next(26));\n            }\n        } while (team1 == team2);\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = n / 2 + 1;\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else if (type == \"maximal_win\") {\n        // Two teams, one scores all the goals\n        string team1 = \"\", team2 = \"\";\n        do {\n            int len1 = rnd.next(1, 10);\n            int len2 = rnd.next(1, 10);\n            team1 = \"\";\n            team2 = \"\";\n            for (int i = 0; i < len1; ++i) {\n                team1 += (char)('A' + rnd.next(26));\n            }\n            for (int i = 0; i < len2; ++i) {\n                team2 += (char)('A' + rnd.next(26));\n            }\n        } while (team1 == team2);\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        // All goals scored by team1\n        printf(\"%d\\n\", n);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", team1.c_str());\n        }\n\n    } else if (type == \"similar_names\") {\n        // Team names differ by one character\n        int len = rnd.next(1, 10);\n        string base_name = \"\";\n        for (int i = 0; i < len; ++i) {\n            base_name += (char)('A' + rnd.next(26));\n        }\n\n        string team1 = base_name;\n        string team2 = base_name;\n        int pos = rnd.next(0, len - 1);\n        char new_char;\n        do {\n            new_char = (char)('A' + rnd.next(26));\n        } while (new_char == base_name[pos]);\n        team2[pos] = new_char;\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = rnd.next(n / 2 + 1, n);\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else if (type == \"max_length_names\") {\n        // Team names with maximum length (10 characters)\n        string team1 = \"\", team2 = \"\";\n        for (int i = 0; i < 10; ++i) {\n            team1 += (char)('A' + rnd.next(26));\n            team2 += (char)('A' + rnd.next(26));\n        }\n        if (team1 == team2) {\n            team2[0] = (char)((team2[0] - 'A' + 1) % 26 + 'A');\n        }\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = rnd.next(n / 2 + 1, n);\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else if (type == \"min_length_names\") {\n        // Team names with minimum length (1 character)\n        char ch1 = 'A' + rnd.next(26);\n        char ch2 = 'A' + rnd.next(26);\n        while (ch1 == ch2) {\n            ch2 = 'A' + rnd.next(26);\n        }\n\n        string team1 = string(1, ch1);\n        string team2 = string(1, ch2);\n\n        teams.push_back(team1);\n        teams.push_back(team2);\n\n        int goals_team1 = rnd.next(n / 2 + 1, n);\n        int goals_team2 = n - goals_team1;\n\n        vector<string> goals;\n        for (int i = 0; i < goals_team1; ++i) {\n            goals.push_back(team1);\n        }\n        for (int i = 0; i < goals_team2; ++i) {\n            goals.push_back(team2);\n        }\n\n        shuffle(goals.begin(), goals.end());\n\n        // Output\n        printf(\"%d\\n\", n);\n        for (auto& goal : goals) {\n            printf(\"%s\\n\", goal.c_str());\n        }\n\n    } else {\n        // Random test case\n        int num_teams = rnd.next(1, 2);\n\n        if (num_teams == 1) {\n            // Only one team\n            string team_name = \"\";\n            int len = rnd.next(1, 10);\n            for (int i = 0; i < len; ++i) {\n                team_name += (char)('A' + rnd.next(26));\n            }\n            teams.push_back(team_name);\n\n            printf(\"%d\\n\", n);\n            for (int i = 0; i < n; ++i) {\n                printf(\"%s\\n\", teams[0].c_str());\n            }\n\n        } else {\n            // Two teams\n            string team1 = \"\", team2 = \"\";\n            do {\n                int len1 = rnd.next(1, 10);\n                int len2 = rnd.next(1, 10);\n                team1 = \"\";\n                team2 = \"\";\n                for (int i = 0; i < len1; ++i) {\n                    team1 += (char)('A' + rnd.next(26));\n                }\n                for (int i = 0; i < len2; ++i) {\n                    team2 += (char)('A' + rnd.next(26));\n                }\n            } while (team1 == team2);\n\n            teams.push_back(team1);\n            teams.push_back(team2);\n\n            int goals_team1 = rnd.next(n / 2 + 1, n);\n            int goals_team2 = n - goals_team1;\n\n            vector<string> goals;\n            for (int i = 0; i < goals_team1; ++i) {\n                goals.push_back(team1);\n            }\n            for (int i = 0; i < goals_team2; ++i) {\n                goals.push_back(team2);\n            }\n\n            shuffle(goals.begin(), goals.end());\n\n            // Output\n            printf(\"%d\\n\", n);\n            for (auto& goal : goals) {\n                printf(\"%s\\n\", goal.c_str());\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type one_team\n./gen -n 1 -type minimal_win\n./gen -n 1 -type maximal_win\n./gen -n 1 -type similar_names\n./gen -n 1 -type max_length_names\n./gen -n 1 -type min_length_names\n./gen -n 1 -type random\n\n./gen -n 2 -type one_team\n./gen -n 2 -type minimal_win\n./gen -n 2 -type maximal_win\n./gen -n 2 -type similar_names\n./gen -n 2 -type max_length_names\n./gen -n 2 -type min_length_names\n./gen -n 2 -type random\n\n./gen -n 50 -type one_team\n./gen -n 50 -type minimal_win\n./gen -n 50 -type maximal_win\n./gen -n 50 -type similar_names\n./gen -n 50 -type max_length_names\n./gen -n 50 -type min_length_names\n./gen -n 50 -type random\n\n./gen -n 99 -type one_team\n./gen -n 99 -type minimal_win\n./gen -n 99 -type maximal_win\n./gen -n 99 -type similar_names\n./gen -n 99 -type max_length_names\n./gen -n 99 -type min_length_names\n./gen -n 99 -type random\n\n./gen -n 100 -type one_team\n./gen -n 100 -type minimal_win\n./gen -n 100 -type maximal_win\n./gen -n 100 -type similar_names\n./gen -n 100 -type max_length_names\n./gen -n 100 -type min_length_names\n./gen -n 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:38.969703",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "43/B",
      "title": "B. Letter",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a newspaper heading s1. The second line contains the letter text s2. s1 и s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.",
      "output_spec": "OutputIf Vasya can write the given anonymous letter, print YES, otherwise print NO",
      "sample_tests": "ExamplesInputCopyInstead of dogging Your footsteps it disappears but you dont notice anythingwhere is your dogOutputCopyNOInputCopyInstead of dogging Your footsteps it disappears but you dont notice anythingYour dog is upstearsOutputCopyYESInputCopyInstead of dogging your footsteps it disappears but you dont notice anythingYour dog is upstearsOutputCopyNOInputCopyabcdefg hijkk j i h g f e d c b aOutputCopyYES",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a newspaper heading s1. The second line contains the letter text s2. s1 и s2 are non-empty lines consisting of spaces, uppercase and lowercase Latin letters, whose lengths do not exceed 200 symbols. The uppercase and lowercase letters should be differentiated. Vasya does not cut spaces out of the heading.\n\nOutputIf Vasya can write the given anonymous letter, print YES, otherwise print NO\n\nInputCopyInstead of dogging Your footsteps it disappears but you dont notice anythingwhere is your dogOutputCopyNOInputCopyInstead of dogging Your footsteps it disappears but you dont notice anythingYour dog is upstearsOutputCopyYESInputCopyInstead of dogging your footsteps it disappears but you dont notice anythingYour dog is upstearsOutputCopyNOInputCopyabcdefg hijkk j i h g f e d c b aOutputCopyYES\n\nInputCopyInstead of dogging Your footsteps it disappears but you dont notice anythingwhere is your dog\n\nOutputCopyNO\n\nInputCopyInstead of dogging Your footsteps it disappears but you dont notice anythingYour dog is upstears\n\nOutputCopyYES\n\nInputCopyInstead of dogging your footsteps it disappears but you dont notice anythingYour dog is upstears\n\nOutputCopyNO\n\nInputCopyabcdefg hijkk j i h g f e d c b a\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Beta Round #42 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good eveningYesterday evening the Saratov university delegation returned from St. Petersburg, from the ACM-ICPC NEERC 2010/11 World Programming Championship semi-finals. If you haven't seen the final standings: 4 Saratov teams received diplomas, and we (Saratov SU 2) advanced to the finals. Saratov SU 1 was also among those, who advanced, that's pretty cool for their first time, but didn't advance because of the limitation \"only one team from one university\".Also we have prepared a Div. 2 round. Thanks for prompt assistance to Edvard Davtyan, Gerald Agapov and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: MiminoUnfortunately, the discrepancy between author’s solution and statement of problem E was detected. We bring our apologies to all the participants. All solutions that have not been Accepted previously were rejudged. Thanks to member xcr for detection of the issue.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/900",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 915
        },
        {
          "title": "Разбор задач A, B, C, D CodeForces Beta Round #42 - Codeforces",
          "content": "А. Футбол.Эту задачу можно решить, не расходуя лишнюю память, а заведя лишь две строки для хранения названий первой и (возможно) второй команд и две целочисленные переменные для хранения количества голов, забитых первой и второй командами. Считываем название первой команды, запоминаем в первой строке и идем циклом до n - 1. На каждом шаге если считанная строка совпадает с уже имеющейся (первой строкой - она всегда есть, так как мы ее заранее (до цикла) считали), то увеличиваем счет этой команды, иначе запоминаем название второй команды и увеличиваем ее счет. В конце делаем целочисленное сравнение и выводим одну из строк.Заметим, что даже если вторая строка останется неинициализированной, ничего плохого не произойдет, так как мы к ней никогда не общаемся, кроме случая, когда победила вторая команда (значит, у нее ненулевое количество голов и строку мы все-таки инициализировали).B. Письмо.Известно, что символы из таблицы ASCII, к которым относятся все (строчные и заглавные) латинские буквы и пробел, имеют коды от 0 до 127. Значит, достаточно завести два массива на 128 символов (можно узнать требуемую память точнее, но char занимает 1 (или 2 байта в Java), поэтому это непринципиально), инициализированных нулями, и заполнить каждый из них следующим образом: идем циклом по строке, получаем код текущего символа строки, элемент массива с таким индексом (кодом символа) увеличиваем на единицу. Таким образом получим два массива - один для первой строки и один для второй. Чтобы составить вторую строку, нужно, чтобы выполнялось условие b[i] <= a[i] для всех i от 0 до 127, кроме (char)i == ' '. Пробелы вырезать ненужно, поэтому для них неравенство может не выполняться.С. Счастливые билеты.Признак делимости на три говорит нам, что натуральное число делится на три тогда и только тогда, когда сумма его цифр делится на 3. Для каждого кусочка билетика мы можем посчитать остатки от деления этого числа на 3 - 0, 1 или 2. Обозначим количество билетов первого типа - a, второго типа -  b, третьего - с. Счастливые билетики можно составить двумя способами: либо соединить кусочки с остатками от деления 0 и 0, либо - 1 и 2. Тогда сумма чисел на получившемся билетике будет 3, что и требуется. Ответом будет число a / 2 + min(b, c). Оставшиеся a % 2 + max(a, b) - min(a, b) билетиков придется выкинуть, так как для них нет соответствующей пары.D. ПутешествиеСперва заметим, что в оптимальном решении может быть не более одного телепорта. Таблицу n * m можно обойти несколькими способами, перемещаясь только по соседним клеткам - например, змейкой или спиралью. Далее, из последней клетки, в которую мы пришли при обходе таблицы, можно телепортироваться в первую.В этой задаче нужно было рассмотреть 4 случая:1. n * m = 2 - тогда ответ легко выписать вручную2. n = 1, m > 2; n > 2, m = 1 - идем по полоске до конца, а из последней клетки ((1, m) или (n, 1)) телепортируемся в первую3. оба n и m нечетные (ни одно из чисел не равно 1) - тогда нужна одна телепортация: обходим доску одним из предложенных способов: змейкой (вверх-вниз или вправо-влево) или по спирали - а из последней клетки телепортируемся4. хотя бы одно из чисел четное, а другое не равно единице - тогда идем вдоль четной стороны до края таблицы, а оставшуюся часть обходим змейкой + делаем один завершающий ход.Для пояснения пункта 4, рассмотрим пример.Пусть n - четное, m - нечетное (не равное 1). Тогда идем вдоль края таблицы из клетки (1, 1) в клетку (n, 1). Дальше возвращаемся в клетку (1, 2) следующим образом: если текущая строка i четная - идем вправо от 2 до m, иначе идем влево от m до 2. Заметим, что последней строкой, которую мы так пройдем, будет первая (по номеру), то есть мы действительно закончим в клетке (1, 2). Осталось сделать только заключительный ход в (1, 1).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/902",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3763
        },
        {
          "title": "CodeForces Beta Round #42 :: Разбор задач - Codeforces",
          "content": "Задача A. ФутболКлассическая задача A второго дивизиона. Можно было решить без хранения в памяти всех N строк входного файла. Хотя тесты проходило и любое решение, которое только можно себе представить.Решение без сохранения всех N строк в памяти: считывать все строки, при встрече незнакомой строки присваивать ей идентификатор. Для каждого идентификатора завести счетчик, который будет отражать, сколько раз строка встретилось во входном файле. Из двух строк выбрать ту, у которой значение счетчика больше.Задача B. ПисьмоСамое простое решение - это для каждой буквы (другие символы просто игнорировать) в обеих строках посчитать число ее вхождений. Если какая-то буква входит во вторую строку большее число раз, чем входит в первую, ответ \"NO\", иначе ответ \"YES\". Очевидная асимптотика решения O(L), где L - ограничение на длину строки во входном файле.Задача С. Счастливые билетыВсем известно условие делимости числа на 3: \"Число кратно трем, тогда и только тогда, когда сумма цифр этого числа делится без остатка на 3\". Соответственно, чтобы при склеивании двух чисел получить число кратное трем, необходим чтобы сумма цифр первого числа плюс сумма цифр второго числа было кратно трем.Стоит отметить, что оперировать в условиях этой задачи можно только с остатками от деления на 3. Несложно понять, что есть смысл соединять числа, которые дают в остатке от деления на 3 двойку с теми, кто дает в остатке единицу. Числа, которые нацело делятся на 3 можно объединять только с числами, которые так же делятся нацело на 3. Если посчитать количество чисел на кусках билетов с остатком от деления на 3 равным 0, 1, 2 (обозначим их как R0, R1, R2 соответственно), то ответом будет min(R1, R2) + [R0 / 2]. Здесь [] - операция округления в меньшую сторону.Задача D. ПутешествиеЗадача не требует знания каких-то алгоритмов, математики или даже банальной логики. От Вас требуется найти все частные случаи и не забыть рассмотреть каждый из них.Теста \"1 1\" быть не могло (ограничения такие).Для тестов \"1 2\" и \"2 1\" ответом служит последовательность из трех клеток (1 1, оставшаяся клетка, 1 1). Телепортов не требуется.Для тестов \"1 M\" и \"N 1\" (2 < N, M) ответом служит последовательность 1 1 -> 1 2 -> ... -> 1 M (ну и аналогично для перевернутого случая) и снова 1 1 в конце. Требуется один телепорт (1 M -> 1 1).Далее логика простая. Если хотя бы одна из сторон - четная, то пройти можно следующим алгоритмом:Рассмотрим случай, когда количество строк нечетно. При нечетном количестве столбцов можно действовать так же, поменяв строки и столбцы местами.Из клетки 1 1 шагнем в 1 2 и далее пойдем змейкой по прямоугольнику Rect(1, 2, N, M). То есть во время обхода змейкой не посещаем первую строку. Такой обход закончится в клетке с координатами 2 M. После чего можно шагнуть на 1 M и спокойно прийти по первой строке в 1 1.Для случая, когда N и M четные, можно воспользоваться тем же алгоритмом. Очевидно, что телепортов строить во всех этих случая не потребуется.Для случая, когда N и M нечетные всегда потребуется один телепорт. Если действовать по той же стратегии, то в конце обхода змейкой можно попасть только в клетку с координатами N M, откуда необходимо телепортироваться в клетку 1 M и пройтись по первой строке до клетки 1 1.Задача E. ГонкаЗадача не требует знания каких-то сложных формул из физики. Сразу открою занавесу и выпишу все формулы, которые потребуются при решении.X0 = 0Xn + 1 = Xn + Vn (Tn+1 - Tn), где Xi - координата, Ti - момент времениНесложно понять, что решение с асимптотикой O(SN2) получит заслуженный Time Limit. Решение с асимптотикой O(KN3) вполне сойдет. Впрочем, скорее всего существует решение с гораздо более хорошей трудоемкостью.Далее будет рассказано решение за O(KN3), которое имеет множество других достоинств.Будем рассматривать всю гонку, как набор некоторых событий упорядоченных во времени. События - изменение скорости какого-либо участника в какой-либо момент времени. Для каждого участника несложно (еще при чтении) получить все события, которые с ним связаны. Каждое из них обладает двумя параметрами: время, когда была сменена скорость и сама величина скорости. Все события можно объединить и упорядочить хронологически (в порядке неубывания времени, когда происходит событие).Теперь нет смысла идти по всем моментам времени (от 0 до S). Есть смысл рассматривать только моменты времени, в которые происходит хотя бы одно событие. Всего смен скоростей будет O(NK). Для дальнейшего решения можно сделать несколько утверждений:Между двумя соседними моментами времени (в которые происходят события) скорости автомобилей остаются постоянными. Соответственно, автомобиль i обгонит на участке между этими двумя моментами времени автомобиль j если Vi > Vj (иначе обгон точно не возможен). А далее требуется соблюдение одного из двух условий:Координата автомобиля i в первый момент времени меньше, чем у автомобиля j, а во второй момент времени координата автомобила i уже больше координаты автомобиля j.Координата автомобиля i в первый момент времени такая же, как у автомобиля j, а во второй момент координата автомобиля i больше координаты автомобиля j. При этом на предыдущем этапе координата автомобиля i была меньше (то есть он сравнялся с автомобилем j на прошлом интервале времени).На каждом временном интервале можно за O(N2) проверять для каждой пары (i, j) обгоняет ли автомобиль i автомобиль j.Каждое из вышеописанных условий можно проверить в целых числах (32 бита вполне хватает). Ответ так же не потребует 64-битовой переменной.Стоит отметить, что решение не использует значение S, которое дается во входном файле.  Дописав один IF можно получить решение, которое будет правильно обрабатывать даже случаи, когда автомобили некоторое время ехали бок о бок.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5709
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 200, \"Length of s1 must be between 1 and 200, but it is %zu\", s1.length());\n    for (char c : s1) {\n        ensuref(c == ' ' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'), \"Invalid character '%c' in s1\", c);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 200, \"Length of s2 must be between 1 and 200, but it is %zu\", s2.length());\n    for (char c : s2) {\n        ensuref(c == ' ' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'), \"Invalid character '%c' in s2\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 200, \"Length of s1 must be between 1 and 200, but it is %zu\", s1.length());\n    for (char c : s1) {\n        ensuref(c == ' ' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'), \"Invalid character '%c' in s1\", c);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 200, \"Length of s2 must be between 1 and 200, but it is %zu\", s2.length());\n    for (char c : s2) {\n        ensuref(c == ' ' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'), \"Invalid character '%c' in s2\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s1 = inf.readLine();\n    ensuref(1 <= s1.length() && s1.length() <= 200, \"Length of s1 must be between 1 and 200, but it is %zu\", s1.length());\n    for (char c : s1) {\n        ensuref(c == ' ' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'), \"Invalid character '%c' in s1\", c);\n    }\n\n    string s2 = inf.readLine();\n    ensuref(1 <= s2.length() && s2.length() <= 200, \"Length of s2 must be between 1 and 200, but it is %zu\", s2.length());\n    for (char c : s2) {\n        ensuref(c == ' ' || ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'), \"Invalid character '%c' in s2\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n1 = opt<int>(\"n1\");\n    int n2 = opt<int>(\"n2\");\n    string type = opt<string>(\"type\", \"good\");\n\n    string s1 = \"\";\n    string s2 = \"\";\n\n    if (type == \"good\") {\n        /* Generate s1 and s2 such that s2 can be formed from s1 */\n        vector<char> letters;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters.push_back(c);\n        }\n\n        s1 = \"\";\n        for (char c : letters) s1 += c;\n\n        shuffle(letters.begin(), letters.end());\n        if (n2 > n1) n2 = n1;\n        s2 = \"\";\n        for (int i = 0; i < n2; ++i) {\n            s2 += letters[i];\n        }\n    } else if (type == \"bad_extra\") {\n        /* Generate s2 with letters not in s1 */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        set<char> s1_letters(letters_s1.begin(), letters_s1.end());\n        char extra_letter;\n        do {\n            extra_letter = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n        } while (s1_letters.count(extra_letter));\n\n        vector<char> letters_s2 = letters_s1;\n        letters_s2.push_back(extra_letter);\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"bad_repeat\") {\n        /* Generate s2 with repeated letters more than in s1 */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        map<char,int> freq_s1;\n        for (char c : letters_s1) freq_s1[c]++;\n\n        char repeat_char = letters_s1[rnd.next(letters_s1.size())];\n        vector<char> letters_s2 = letters_s1;\n        letters_s2.push_back(repeat_char); // Add one more occurrence\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"case_sensitive\") {\n        /* Generate s1 and s2 with same letters but different cases */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next('a','z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2;\n        for (int i = 0; i < n2; ++i) {\n            char c = rnd.next('A','Z');\n            letters_s2.push_back(c);\n        }\n        s2 = \"\";\n        for (char c : letters_s2) s2 += c;\n    } else if (type == \"spaces_in_s2\") {\n        /* Generate s2 with spaces */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next('a','z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2 = letters_s1;\n        int num_spaces = rnd.next(1, n2 / 5 + 1);\n        for (int i = 0; i < num_spaces; ++i) {\n            letters_s2.push_back(' ');\n        }\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"long_spaces\") {\n        /* Generate s1 with spaces only and s2 with letters */\n        if (n1 < 1) n1 = 1;\n        s1 = \"\";\n        for (int i = 0; i < n1; ++i) {\n            s1 += ' ';\n        }\n        s2 = \"\";\n        s2 += rnd.next('a','z');\n    } else if (type == \"spaces_in_s1\") {\n        /* Generate s1 with spaces */\n        vector<char> letters_s1;\n        int num_spaces = rnd.next(1, n1 / 5 + 1);\n        for (int i = 0; i < n1 - num_spaces; ++i) {\n            letters_s1.push_back(rnd.next('a','z'));\n        }\n        for (int i = 0; i < num_spaces; ++i) {\n            letters_s1.push_back(' ');\n        }\n        shuffle(letters_s1.begin(), letters_s1.end());\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2;\n        for (char c : letters_s1) {\n            if (c != ' ') letters_s2.push_back(c);\n        }\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"max_length\") {\n        /* Generate s1 and s2 of maximum allowed length */\n        n1 = 200;\n        n2 = 200;\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2 = letters_s1;\n        shuffle(letters_s2.begin(), letters_s2.end());\n        s2 = \"\";\n        for (int i = 0; i < n2; ++i) {\n            s2 += letters_s2[i];\n        }\n    } else {\n        /* Generate random s1 and s2 */\n        vector<char> letters_s1;\n        vector<char> letters_s2;\n        for (int i = 0; i < n1; ++i) {\n            letters_s1.push_back(rnd.next('a','z'));\n        }\n        for (int i = 0; i < n2; ++i) {\n            letters_s2.push_back(rnd.next('a','z'));\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n        s2 = \"\";\n        for (char c : letters_s2) s2 += c;\n    }\n\n    /* Output s1 and s2 */\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n1 = opt<int>(\"n1\");\n    int n2 = opt<int>(\"n2\");\n    string type = opt<string>(\"type\", \"good\");\n\n    string s1 = \"\";\n    string s2 = \"\";\n\n    if (type == \"good\") {\n        /* Generate s1 and s2 such that s2 can be formed from s1 */\n        vector<char> letters;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters.push_back(c);\n        }\n\n        s1 = \"\";\n        for (char c : letters) s1 += c;\n\n        shuffle(letters.begin(), letters.end());\n        if (n2 > n1) n2 = n1;\n        s2 = \"\";\n        for (int i = 0; i < n2; ++i) {\n            s2 += letters[i];\n        }\n    } else if (type == \"bad_extra\") {\n        /* Generate s2 with letters not in s1 */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        set<char> s1_letters(letters_s1.begin(), letters_s1.end());\n        char extra_letter;\n        do {\n            extra_letter = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n        } while (s1_letters.count(extra_letter));\n\n        vector<char> letters_s2 = letters_s1;\n        letters_s2.push_back(extra_letter);\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"bad_repeat\") {\n        /* Generate s2 with repeated letters more than in s1 */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        map<char,int> freq_s1;\n        for (char c : letters_s1) freq_s1[c]++;\n\n        char repeat_char = letters_s1[rnd.next(letters_s1.size())];\n        vector<char> letters_s2 = letters_s1;\n        letters_s2.push_back(repeat_char); // Add one more occurrence\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"case_sensitive\") {\n        /* Generate s1 and s2 with same letters but different cases */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next('a','z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2;\n        for (int i = 0; i < n2; ++i) {\n            char c = rnd.next('A','Z');\n            letters_s2.push_back(c);\n        }\n        s2 = \"\";\n        for (char c : letters_s2) s2 += c;\n    } else if (type == \"spaces_in_s2\") {\n        /* Generate s2 with spaces */\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next('a','z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2 = letters_s1;\n        int num_spaces = rnd.next(1, n2 / 5 + 1);\n        for (int i = 0; i < num_spaces; ++i) {\n            letters_s2.push_back(' ');\n        }\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"long_spaces\") {\n        /* Generate s1 with spaces only and s2 with letters */\n        if (n1 < 1) n1 = 1;\n        s1 = \"\";\n        for (int i = 0; i < n1; ++i) {\n            s1 += ' ';\n        }\n        s2 = \"\";\n        s2 += rnd.next('a','z');\n    } else if (type == \"spaces_in_s1\") {\n        /* Generate s1 with spaces */\n        vector<char> letters_s1;\n        int num_spaces = rnd.next(1, n1 / 5 + 1);\n        for (int i = 0; i < n1 - num_spaces; ++i) {\n            letters_s1.push_back(rnd.next('a','z'));\n        }\n        for (int i = 0; i < num_spaces; ++i) {\n            letters_s1.push_back(' ');\n        }\n        shuffle(letters_s1.begin(), letters_s1.end());\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2;\n        for (char c : letters_s1) {\n            if (c != ' ') letters_s2.push_back(c);\n        }\n        shuffle(letters_s2.begin(), letters_s2.end());\n\n        s2 = \"\";\n        for (int i = 0; i < n2 && i < (int)letters_s2.size(); ++i) {\n            s2 += letters_s2[i];\n        }\n    } else if (type == \"max_length\") {\n        /* Generate s1 and s2 of maximum allowed length */\n        n1 = 200;\n        n2 = 200;\n        vector<char> letters_s1;\n        for (int i = 0; i < n1; ++i) {\n            char c = rnd.next(2) ? rnd.next('a','z') : rnd.next('A','Z');\n            letters_s1.push_back(c);\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n\n        vector<char> letters_s2 = letters_s1;\n        shuffle(letters_s2.begin(), letters_s2.end());\n        s2 = \"\";\n        for (int i = 0; i < n2; ++i) {\n            s2 += letters_s2[i];\n        }\n    } else {\n        /* Generate random s1 and s2 */\n        vector<char> letters_s1;\n        vector<char> letters_s2;\n        for (int i = 0; i < n1; ++i) {\n            letters_s1.push_back(rnd.next('a','z'));\n        }\n        for (int i = 0; i < n2; ++i) {\n            letters_s2.push_back(rnd.next('a','z'));\n        }\n        s1 = \"\";\n        for (char c : letters_s1) s1 += c;\n        s2 = \"\";\n        for (char c : letters_s2) s2 += c;\n    }\n\n    /* Output s1 and s2 */\n    printf(\"%s\\n\", s1.c_str());\n    printf(\"%s\\n\", s2.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n1 100 -n2 100 -type good\n./gen -n1 100 -n2 110 -type bad_repeat\n./gen -n1 100 -n2 100 -type bad_extra\n./gen -n1 100 -n2 100 -type case_sensitive\n./gen -n1 100 -n2 100 -type spaces_in_s2\n./gen -n1 150 -n2 120 -type spaces_in_s1\n./gen -n1 200 -n2 200 -type max_length\n./gen -n1 1 -n2 1 -type good\n./gen -n1 1 -n2 2 -type bad_repeat\n./gen -n1 100 -n2 50 -type good\n./gen -n1 50 -n2 100 -type bad_extra\n./gen -n1 30 -n2 30 -type case_sensitive\n./gen -n1 50 -n2 50 -type long_spaces\n./gen -n1 100 -n2 80 -type good\n./gen -n1 100 -n2 90 -type bad_repeat\n./gen -n1 100 -n2 110 -type bad_extra\n./gen -n1 100 -n2 50 -type spaces_in_s2\n./gen -n1 150 -n2 120 -type spaces_in_s1\n./gen -n1 200 -n2 200 -type max_length\n./gen -n1 200 -n2 200 -type case_sensitive\n./gen -n1 200 -n2 200 -type bad_repeat\n./gen -n1 200 -n2 200 -type bad_extra\n./gen -n1 200 -n2 200 -type spaces_in_s2\n./gen -n1 200 -n2 200 -type spaces_in_s1\n./gen -n1 200 -n2 200 -type long_spaces\n./gen -n1 200 -n2 199 -type good\n./gen -n1 199 -n2 200 -type bad_extra\n./gen -n1 1 -n2 1 -type spaces_in_s1\n./gen -n1 1 -n2 1 -type spaces_in_s2\n./gen -n1 1 -n2 1 -type case_sensitive\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:41.081024",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "43/C",
      "title": "C. Lucky Tickets",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 104) — the number of pieces. The second line contains n space-separated numbers ai (1 ≤ ai ≤ 108) — the numbers on the pieces. Vasya can only glue the pieces in pairs. Even if the number of a piece is already lucky, Vasya should glue the piece with some other one for it to count as lucky. Vasya does not have to use all the pieces. The numbers on the pieces an on the resulting tickets may coincide.",
      "output_spec": "OutputPrint the single number — the maximum number of lucky tickets that will be able to be restored. Don't forget that every lucky ticket is made of exactly two pieces glued together.",
      "sample_tests": "ExamplesInputCopy3123 123 99OutputCopy1InputCopy61 1 1 23 10 3OutputCopy1",
      "description": "C. Lucky Tickets\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 104) — the number of pieces. The second line contains n space-separated numbers ai (1 ≤ ai ≤ 108) — the numbers on the pieces. Vasya can only glue the pieces in pairs. Even if the number of a piece is already lucky, Vasya should glue the piece with some other one for it to count as lucky. Vasya does not have to use all the pieces. The numbers on the pieces an on the resulting tickets may coincide.\n\nOutputPrint the single number — the maximum number of lucky tickets that will be able to be restored. Don't forget that every lucky ticket is made of exactly two pieces glued together.\n\nInputCopy3123 123 99OutputCopy1InputCopy61 1 1 23 10 3OutputCopy1\n\nInputCopy3123 123 99\n\nOutputCopy1\n\nInputCopy61 1 1 23 10 3\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #42 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good eveningYesterday evening the Saratov university delegation returned from St. Petersburg, from the ACM-ICPC NEERC 2010/11 World Programming Championship semi-finals. If you haven't seen the final standings: 4 Saratov teams received diplomas, and we (Saratov SU 2) advanced to the finals. Saratov SU 1 was also among those, who advanced, that's pretty cool for their first time, but didn't advance because of the limitation \"only one team from one university\".Also we have prepared a Div. 2 round. Thanks for prompt assistance to Edvard Davtyan, Gerald Agapov and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: MiminoUnfortunately, the discrepancy between author’s solution and statement of problem E was detected. We bring our apologies to all the participants. All solutions that have not been Accepted previously were rejudged. Thanks to member xcr for detection of the issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/900",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 915
        },
        {
          "title": "Разбор задач A, B, C, D CodeForces Beta Round #42 - Codeforces",
          "content": "А. Футбол.Эту задачу можно решить, не расходуя лишнюю память, а заведя лишь две строки для хранения названий первой и (возможно) второй команд и две целочисленные переменные для хранения количества голов, забитых первой и второй командами. Считываем название первой команды, запоминаем в первой строке и идем циклом до n - 1. На каждом шаге если считанная строка совпадает с уже имеющейся (первой строкой - она всегда есть, так как мы ее заранее (до цикла) считали), то увеличиваем счет этой команды, иначе запоминаем название второй команды и увеличиваем ее счет. В конце делаем целочисленное сравнение и выводим одну из строк.Заметим, что даже если вторая строка останется неинициализированной, ничего плохого не произойдет, так как мы к ней никогда не общаемся, кроме случая, когда победила вторая команда (значит, у нее ненулевое количество голов и строку мы все-таки инициализировали).B. Письмо.Известно, что символы из таблицы ASCII, к которым относятся все (строчные и заглавные) латинские буквы и пробел, имеют коды от 0 до 127. Значит, достаточно завести два массива на 128 символов (можно узнать требуемую память точнее, но char занимает 1 (или 2 байта в Java), поэтому это непринципиально), инициализированных нулями, и заполнить каждый из них следующим образом: идем циклом по строке, получаем код текущего символа строки, элемент массива с таким индексом (кодом символа) увеличиваем на единицу. Таким образом получим два массива - один для первой строки и один для второй. Чтобы составить вторую строку, нужно, чтобы выполнялось условие b[i] <= a[i] для всех i от 0 до 127, кроме (char)i == ' '. Пробелы вырезать ненужно, поэтому для них неравенство может не выполняться.С. Счастливые билеты.Признак делимости на три говорит нам, что натуральное число делится на три тогда и только тогда, когда сумма его цифр делится на 3. Для каждого кусочка билетика мы можем посчитать остатки от деления этого числа на 3 - 0, 1 или 2. Обозначим количество билетов первого типа - a, второго типа -  b, третьего - с. Счастливые билетики можно составить двумя способами: либо соединить кусочки с остатками от деления 0 и 0, либо - 1 и 2. Тогда сумма чисел на получившемся билетике будет 3, что и требуется. Ответом будет число a / 2 + min(b, c). Оставшиеся a % 2 + max(a, b) - min(a, b) билетиков придется выкинуть, так как для них нет соответствующей пары.D. ПутешествиеСперва заметим, что в оптимальном решении может быть не более одного телепорта. Таблицу n * m можно обойти несколькими способами, перемещаясь только по соседним клеткам - например, змейкой или спиралью. Далее, из последней клетки, в которую мы пришли при обходе таблицы, можно телепортироваться в первую.В этой задаче нужно было рассмотреть 4 случая:1. n * m = 2 - тогда ответ легко выписать вручную2. n = 1, m > 2; n > 2, m = 1 - идем по полоске до конца, а из последней клетки ((1, m) или (n, 1)) телепортируемся в первую3. оба n и m нечетные (ни одно из чисел не равно 1) - тогда нужна одна телепортация: обходим доску одним из предложенных способов: змейкой (вверх-вниз или вправо-влево) или по спирали - а из последней клетки телепортируемся4. хотя бы одно из чисел четное, а другое не равно единице - тогда идем вдоль четной стороны до края таблицы, а оставшуюся часть обходим змейкой + делаем один завершающий ход.Для пояснения пункта 4, рассмотрим пример.Пусть n - четное, m - нечетное (не равное 1). Тогда идем вдоль края таблицы из клетки (1, 1) в клетку (n, 1). Дальше возвращаемся в клетку (1, 2) следующим образом: если текущая строка i четная - идем вправо от 2 до m, иначе идем влево от m до 2. Заметим, что последней строкой, которую мы так пройдем, будет первая (по номеру), то есть мы действительно закончим в клетке (1, 2). Осталось сделать только заключительный ход в (1, 1).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/902",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3763
        },
        {
          "title": "CodeForces Beta Round #42 :: Разбор задач - Codeforces",
          "content": "Задача A. ФутболКлассическая задача A второго дивизиона. Можно было решить без хранения в памяти всех N строк входного файла. Хотя тесты проходило и любое решение, которое только можно себе представить.Решение без сохранения всех N строк в памяти: считывать все строки, при встрече незнакомой строки присваивать ей идентификатор. Для каждого идентификатора завести счетчик, который будет отражать, сколько раз строка встретилось во входном файле. Из двух строк выбрать ту, у которой значение счетчика больше.Задача B. ПисьмоСамое простое решение - это для каждой буквы (другие символы просто игнорировать) в обеих строках посчитать число ее вхождений. Если какая-то буква входит во вторую строку большее число раз, чем входит в первую, ответ \"NO\", иначе ответ \"YES\". Очевидная асимптотика решения O(L), где L - ограничение на длину строки во входном файле.Задача С. Счастливые билетыВсем известно условие делимости числа на 3: \"Число кратно трем, тогда и только тогда, когда сумма цифр этого числа делится без остатка на 3\". Соответственно, чтобы при склеивании двух чисел получить число кратное трем, необходим чтобы сумма цифр первого числа плюс сумма цифр второго числа было кратно трем.Стоит отметить, что оперировать в условиях этой задачи можно только с остатками от деления на 3. Несложно понять, что есть смысл соединять числа, которые дают в остатке от деления на 3 двойку с теми, кто дает в остатке единицу. Числа, которые нацело делятся на 3 можно объединять только с числами, которые так же делятся нацело на 3. Если посчитать количество чисел на кусках билетов с остатком от деления на 3 равным 0, 1, 2 (обозначим их как R0, R1, R2 соответственно), то ответом будет min(R1, R2) + [R0 / 2]. Здесь [] - операция округления в меньшую сторону.Задача D. ПутешествиеЗадача не требует знания каких-то алгоритмов, математики или даже банальной логики. От Вас требуется найти все частные случаи и не забыть рассмотреть каждый из них.Теста \"1 1\" быть не могло (ограничения такие).Для тестов \"1 2\" и \"2 1\" ответом служит последовательность из трех клеток (1 1, оставшаяся клетка, 1 1). Телепортов не требуется.Для тестов \"1 M\" и \"N 1\" (2 < N, M) ответом служит последовательность 1 1 -> 1 2 -> ... -> 1 M (ну и аналогично для перевернутого случая) и снова 1 1 в конце. Требуется один телепорт (1 M -> 1 1).Далее логика простая. Если хотя бы одна из сторон - четная, то пройти можно следующим алгоритмом:Рассмотрим случай, когда количество строк нечетно. При нечетном количестве столбцов можно действовать так же, поменяв строки и столбцы местами.Из клетки 1 1 шагнем в 1 2 и далее пойдем змейкой по прямоугольнику Rect(1, 2, N, M). То есть во время обхода змейкой не посещаем первую строку. Такой обход закончится в клетке с координатами 2 M. После чего можно шагнуть на 1 M и спокойно прийти по первой строке в 1 1.Для случая, когда N и M четные, можно воспользоваться тем же алгоритмом. Очевидно, что телепортов строить во всех этих случая не потребуется.Для случая, когда N и M нечетные всегда потребуется один телепорт. Если действовать по той же стратегии, то в конце обхода змейкой можно попасть только в клетку с координатами N M, откуда необходимо телепортироваться в клетку 1 M и пройтись по первой строке до клетки 1 1.Задача E. ГонкаЗадача не требует знания каких-то сложных формул из физики. Сразу открою занавесу и выпишу все формулы, которые потребуются при решении.X0 = 0Xn + 1 = Xn + Vn (Tn+1 - Tn), где Xi - координата, Ti - момент времениНесложно понять, что решение с асимптотикой O(SN2) получит заслуженный Time Limit. Решение с асимптотикой O(KN3) вполне сойдет. Впрочем, скорее всего существует решение с гораздо более хорошей трудоемкостью.Далее будет рассказано решение за O(KN3), которое имеет множество других достоинств.Будем рассматривать всю гонку, как набор некоторых событий упорядоченных во времени. События - изменение скорости какого-либо участника в какой-либо момент времени. Для каждого участника несложно (еще при чтении) получить все события, которые с ним связаны. Каждое из них обладает двумя параметрами: время, когда была сменена скорость и сама величина скорости. Все события можно объединить и упорядочить хронологически (в порядке неубывания времени, когда происходит событие).Теперь нет смысла идти по всем моментам времени (от 0 до S). Есть смысл рассматривать только моменты времени, в которые происходит хотя бы одно событие. Всего смен скоростей будет O(NK). Для дальнейшего решения можно сделать несколько утверждений:Между двумя соседними моментами времени (в которые происходят события) скорости автомобилей остаются постоянными. Соответственно, автомобиль i обгонит на участке между этими двумя моментами времени автомобиль j если Vi > Vj (иначе обгон точно не возможен). А далее требуется соблюдение одного из двух условий:Координата автомобиля i в первый момент времени меньше, чем у автомобиля j, а во второй момент времени координата автомобила i уже больше координаты автомобиля j.Координата автомобиля i в первый момент времени такая же, как у автомобиля j, а во второй момент координата автомобиля i больше координаты автомобиля j. При этом на предыдущем этапе координата автомобиля i была меньше (то есть он сравнялся с автомобилем j на прошлом интервале времени).На каждом временном интервале можно за O(N2) проверять для каждой пары (i, j) обгоняет ли автомобиль i автомобиль j.Каждое из вышеописанных условий можно проверить в целых числах (32 бита вполне хватает). Ответ так же не потребует 64-битовой переменной.Стоит отметить, что решение не использует значение S, которое дается во входном файле.  Дописав один IF можно получить решение, которое будет правильно обрабатывать даже случаи, когда автомобили некоторое время ехали бок о бок.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5709
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 100000000, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 100000000);\n\n    vector<int> a;\n\n    if (type == \"c0\") {\n        // All ai mod 3 == 0\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n    } else if (type == \"c1\") {\n        // All ai mod 3 == 1\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n    } else if (type == \"c2\") {\n        // All ai mod 3 == 2\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 2;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 2;\n            a.push_back(ai);\n        }\n    } else if (type == \"equal\") {\n        // cnt[0] == cnt[1] == cnt[2]\n        int c0 = n / 3;\n        int c1 = n / 3;\n        int c2 = n - c0 - c1;\n        for (int i = 0; i < c0; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c1; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c2; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 2;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 2;\n            a.push_back(ai);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_pairs\") {\n        // Maximize number of lucky tickets\n        // cnt[0] even, cnt[1] == cnt[2]\n        int c0 = (n / 2) / 2 * 2; // Even number less than n/2\n        int rem = n - c0;\n        int c1 = rem / 2;\n        int c2 = rem - c1;\n        for (int i = 0; i < c0; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c1; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c2; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 2;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 2;\n            a.push_back(ai);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"min_pairs\") {\n        // Minimize number of lucky tickets\n        // cnt[0] odd, cnt[1] and cnt[2] unequal\n        int c0 = n / 2;\n        if (c0 % 2 == 0) c0++; // Make c0 odd\n        int rem = n - c0;\n        int c1 = rem;\n        int c2 = 0;\n        for (int i = 0; i < c0; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c1; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n        // No c2 elements\n        shuffle(a.begin(), a.end());\n    } else if (type == \"random\") {\n        // Generate random ai from 1 to max_ai\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, max_ai);\n            a.push_back(ai);\n        }\n    } else {\n        cerr << \"Invalid type parameter\" << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 100000000);\n\n    vector<int> a;\n\n    if (type == \"c0\") {\n        // All ai mod 3 == 0\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n    } else if (type == \"c1\") {\n        // All ai mod 3 == 1\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n    } else if (type == \"c2\") {\n        // All ai mod 3 == 2\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 2;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 2;\n            a.push_back(ai);\n        }\n    } else if (type == \"equal\") {\n        // cnt[0] == cnt[1] == cnt[2]\n        int c0 = n / 3;\n        int c1 = n / 3;\n        int c2 = n - c0 - c1;\n        for (int i = 0; i < c0; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c1; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c2; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 2;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 2;\n            a.push_back(ai);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"max_pairs\") {\n        // Maximize number of lucky tickets\n        // cnt[0] even, cnt[1] == cnt[2]\n        int c0 = (n / 2) / 2 * 2; // Even number less than n/2\n        int rem = n - c0;\n        int c1 = rem / 2;\n        int c2 = rem - c1;\n        for (int i = 0; i < c0; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c1; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c2; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 2;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 2;\n            a.push_back(ai);\n        }\n        shuffle(a.begin(), a.end());\n    } else if (type == \"min_pairs\") {\n        // Minimize number of lucky tickets\n        // cnt[0] odd, cnt[1] and cnt[2] unequal\n        int c0 = n / 2;\n        if (c0 % 2 == 0) c0++; // Make c0 odd\n        int rem = n - c0;\n        int c1 = rem;\n        int c2 = 0;\n        for (int i = 0; i < c0; ++i) {\n            int ai = rnd.next(1, max_ai / 3) * 3;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 3;\n            a.push_back(ai);\n        }\n        for (int i = 0; i < c1; ++i) {\n            int ai = rnd.next(0, max_ai / 3) * 3 + 1;\n            if (ai > max_ai) ai -= 3;\n            if (ai < 1) ai = 1;\n            a.push_back(ai);\n        }\n        // No c2 elements\n        shuffle(a.begin(), a.end());\n    } else if (type == \"random\") {\n        // Generate random ai from 1 to max_ai\n        for (int i = 0; i < n; ++i) {\n            int ai = rnd.next(1, max_ai);\n            a.push_back(ai);\n        }\n    } else {\n        cerr << \"Invalid type parameter\" << endl;\n        return 1;\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type equal\n./gen -n 3 -type c0\n./gen -n 3 -type max_pairs\n\n./gen -n 5 -type c0\n./gen -n 5 -type c1\n./gen -n 5 -type c2\n./gen -n 5 -type equal\n\n./gen -n 10 -type random\n./gen -n 10 -type max_pairs\n./gen -n 10 -type min_pairs\n\n./gen -n 100 -type c0\n./gen -n 100 -type c1\n./gen -n 100 -type c2\n./gen -n 100 -type equal\n./gen -n 100 -type random\n./gen -n 100 -type max_pairs\n./gen -n 100 -type min_pairs\n\n./gen -n 1000 -type c0\n./gen -n 1000 -type c1\n./gen -n 1000 -type c2\n./gen -n 1000 -type equal\n./gen -n 1000 -type random\n./gen -n 1000 -type max_pairs\n./gen -n 1000 -type min_pairs\n\n./gen -n 5000 -type c2 -max_ai 100000000\n\n./gen -n 9999 -type min_pairs\n./gen -n 10000 -type random\n./gen -n 10000 -type random -max_ai 1\n./gen -n 10000 -type c1 -max_ai 2\n./gen -n 10000 -type c0\n\n./gen -n 10000 -type c1\n./gen -n 10000 -type c2\n./gen -n 10000 -type equal\n./gen -n 10000 -type max_pairs\n./gen -n 10000 -type min_pairs\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:43.025792",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "43/D",
      "title": "D. Journey",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 100, 2 ≤  n · m) — the field size. The upper left square has coordinates (1, 1), and the lower right square has coordinates of (n, m).",
      "output_spec": "OutputOn the first line output integer k — the minimum number of teleporters. Then output k lines each containing 4 integers x1 y1 x2 y2 (1 ≤ x1, x2 ≤ n, 1 ≤ y1, y2 ≤ m) — the coordinates of the square where the teleporter is installed (x1, y1), and the coordinates of the square where the teleporter leads (x2, y2).Then print nm + 1 lines containing 2 numbers each — the coordinates of the squares in the order in which they are visited by the king. The travel path must start and end at (1, 1). The king can move to side-neighboring squares and to the squares where a teleporter leads. Besides, he also should visit the capital exactly two times and he should visit other squares exactly one time.",
      "sample_tests": "ExamplesInputCopy2 2OutputCopy01 11 22 22 11 1InputCopy3 3OutputCopy13 3 1 11 11 21 32 32 22 13 13 23 31 1",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers n and m (1 ≤ n, m ≤ 100, 2 ≤  n · m) — the field size. The upper left square has coordinates (1, 1), and the lower right square has coordinates of (n, m).\n\nOutputOn the first line output integer k — the minimum number of teleporters. Then output k lines each containing 4 integers x1 y1 x2 y2 (1 ≤ x1, x2 ≤ n, 1 ≤ y1, y2 ≤ m) — the coordinates of the square where the teleporter is installed (x1, y1), and the coordinates of the square where the teleporter leads (x2, y2).Then print nm + 1 lines containing 2 numbers each — the coordinates of the squares in the order in which they are visited by the king. The travel path must start and end at (1, 1). The king can move to side-neighboring squares and to the squares where a teleporter leads. Besides, he also should visit the capital exactly two times and he should visit other squares exactly one time.\n\nInputCopy2 2OutputCopy01 11 22 22 11 1InputCopy3 3OutputCopy13 3 1 11 11 21 32 32 22 13 13 23 31 1\n\nInputCopy2 2\n\nOutputCopy01 11 22 22 11 1\n\nInputCopy3 3\n\nOutputCopy13 3 1 11 11 21 32 32 22 13 13 23 31 1",
      "solutions": [
        {
          "title": "Codeforces Beta Round #42 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good eveningYesterday evening the Saratov university delegation returned from St. Petersburg, from the ACM-ICPC NEERC 2010/11 World Programming Championship semi-finals. If you haven't seen the final standings: 4 Saratov teams received diplomas, and we (Saratov SU 2) advanced to the finals. Saratov SU 1 was also among those, who advanced, that's pretty cool for their first time, but didn't advance because of the limitation \"only one team from one university\".Also we have prepared a Div. 2 round. Thanks for prompt assistance to Edvard Davtyan, Gerald Agapov and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: MiminoUnfortunately, the discrepancy between author’s solution and statement of problem E was detected. We bring our apologies to all the participants. All solutions that have not been Accepted previously were rejudged. Thanks to member xcr for detection of the issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/900",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 915
        },
        {
          "title": "Разбор задач A, B, C, D CodeForces Beta Round #42 - Codeforces",
          "content": "А. Футбол.Эту задачу можно решить, не расходуя лишнюю память, а заведя лишь две строки для хранения названий первой и (возможно) второй команд и две целочисленные переменные для хранения количества голов, забитых первой и второй командами. Считываем название первой команды, запоминаем в первой строке и идем циклом до n - 1. На каждом шаге если считанная строка совпадает с уже имеющейся (первой строкой - она всегда есть, так как мы ее заранее (до цикла) считали), то увеличиваем счет этой команды, иначе запоминаем название второй команды и увеличиваем ее счет. В конце делаем целочисленное сравнение и выводим одну из строк.Заметим, что даже если вторая строка останется неинициализированной, ничего плохого не произойдет, так как мы к ней никогда не общаемся, кроме случая, когда победила вторая команда (значит, у нее ненулевое количество голов и строку мы все-таки инициализировали).B. Письмо.Известно, что символы из таблицы ASCII, к которым относятся все (строчные и заглавные) латинские буквы и пробел, имеют коды от 0 до 127. Значит, достаточно завести два массива на 128 символов (можно узнать требуемую память точнее, но char занимает 1 (или 2 байта в Java), поэтому это непринципиально), инициализированных нулями, и заполнить каждый из них следующим образом: идем циклом по строке, получаем код текущего символа строки, элемент массива с таким индексом (кодом символа) увеличиваем на единицу. Таким образом получим два массива - один для первой строки и один для второй. Чтобы составить вторую строку, нужно, чтобы выполнялось условие b[i] <= a[i] для всех i от 0 до 127, кроме (char)i == ' '. Пробелы вырезать ненужно, поэтому для них неравенство может не выполняться.С. Счастливые билеты.Признак делимости на три говорит нам, что натуральное число делится на три тогда и только тогда, когда сумма его цифр делится на 3. Для каждого кусочка билетика мы можем посчитать остатки от деления этого числа на 3 - 0, 1 или 2. Обозначим количество билетов первого типа - a, второго типа -  b, третьего - с. Счастливые билетики можно составить двумя способами: либо соединить кусочки с остатками от деления 0 и 0, либо - 1 и 2. Тогда сумма чисел на получившемся билетике будет 3, что и требуется. Ответом будет число a / 2 + min(b, c). Оставшиеся a % 2 + max(a, b) - min(a, b) билетиков придется выкинуть, так как для них нет соответствующей пары.D. ПутешествиеСперва заметим, что в оптимальном решении может быть не более одного телепорта. Таблицу n * m можно обойти несколькими способами, перемещаясь только по соседним клеткам - например, змейкой или спиралью. Далее, из последней клетки, в которую мы пришли при обходе таблицы, можно телепортироваться в первую.В этой задаче нужно было рассмотреть 4 случая:1. n * m = 2 - тогда ответ легко выписать вручную2. n = 1, m > 2; n > 2, m = 1 - идем по полоске до конца, а из последней клетки ((1, m) или (n, 1)) телепортируемся в первую3. оба n и m нечетные (ни одно из чисел не равно 1) - тогда нужна одна телепортация: обходим доску одним из предложенных способов: змейкой (вверх-вниз или вправо-влево) или по спирали - а из последней клетки телепортируемся4. хотя бы одно из чисел четное, а другое не равно единице - тогда идем вдоль четной стороны до края таблицы, а оставшуюся часть обходим змейкой + делаем один завершающий ход.Для пояснения пункта 4, рассмотрим пример.Пусть n - четное, m - нечетное (не равное 1). Тогда идем вдоль края таблицы из клетки (1, 1) в клетку (n, 1). Дальше возвращаемся в клетку (1, 2) следующим образом: если текущая строка i четная - идем вправо от 2 до m, иначе идем влево от m до 2. Заметим, что последней строкой, которую мы так пройдем, будет первая (по номеру), то есть мы действительно закончим в клетке (1, 2). Осталось сделать только заключительный ход в (1, 1).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/902",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3763
        },
        {
          "title": "CodeForces Beta Round #42 :: Разбор задач - Codeforces",
          "content": "Задача A. ФутболКлассическая задача A второго дивизиона. Можно было решить без хранения в памяти всех N строк входного файла. Хотя тесты проходило и любое решение, которое только можно себе представить.Решение без сохранения всех N строк в памяти: считывать все строки, при встрече незнакомой строки присваивать ей идентификатор. Для каждого идентификатора завести счетчик, который будет отражать, сколько раз строка встретилось во входном файле. Из двух строк выбрать ту, у которой значение счетчика больше.Задача B. ПисьмоСамое простое решение - это для каждой буквы (другие символы просто игнорировать) в обеих строках посчитать число ее вхождений. Если какая-то буква входит во вторую строку большее число раз, чем входит в первую, ответ \"NO\", иначе ответ \"YES\". Очевидная асимптотика решения O(L), где L - ограничение на длину строки во входном файле.Задача С. Счастливые билетыВсем известно условие делимости числа на 3: \"Число кратно трем, тогда и только тогда, когда сумма цифр этого числа делится без остатка на 3\". Соответственно, чтобы при склеивании двух чисел получить число кратное трем, необходим чтобы сумма цифр первого числа плюс сумма цифр второго числа было кратно трем.Стоит отметить, что оперировать в условиях этой задачи можно только с остатками от деления на 3. Несложно понять, что есть смысл соединять числа, которые дают в остатке от деления на 3 двойку с теми, кто дает в остатке единицу. Числа, которые нацело делятся на 3 можно объединять только с числами, которые так же делятся нацело на 3. Если посчитать количество чисел на кусках билетов с остатком от деления на 3 равным 0, 1, 2 (обозначим их как R0, R1, R2 соответственно), то ответом будет min(R1, R2) + [R0 / 2]. Здесь [] - операция округления в меньшую сторону.Задача D. ПутешествиеЗадача не требует знания каких-то алгоритмов, математики или даже банальной логики. От Вас требуется найти все частные случаи и не забыть рассмотреть каждый из них.Теста \"1 1\" быть не могло (ограничения такие).Для тестов \"1 2\" и \"2 1\" ответом служит последовательность из трех клеток (1 1, оставшаяся клетка, 1 1). Телепортов не требуется.Для тестов \"1 M\" и \"N 1\" (2 < N, M) ответом служит последовательность 1 1 -> 1 2 -> ... -> 1 M (ну и аналогично для перевернутого случая) и снова 1 1 в конце. Требуется один телепорт (1 M -> 1 1).Далее логика простая. Если хотя бы одна из сторон - четная, то пройти можно следующим алгоритмом:Рассмотрим случай, когда количество строк нечетно. При нечетном количестве столбцов можно действовать так же, поменяв строки и столбцы местами.Из клетки 1 1 шагнем в 1 2 и далее пойдем змейкой по прямоугольнику Rect(1, 2, N, M). То есть во время обхода змейкой не посещаем первую строку. Такой обход закончится в клетке с координатами 2 M. После чего можно шагнуть на 1 M и спокойно прийти по первой строке в 1 1.Для случая, когда N и M четные, можно воспользоваться тем же алгоритмом. Очевидно, что телепортов строить во всех этих случая не потребуется.Для случая, когда N и M нечетные всегда потребуется один телепорт. Если действовать по той же стратегии, то в конце обхода змейкой можно попасть только в клетку с координатами N M, откуда необходимо телепортироваться в клетку 1 M и пройтись по первой строке до клетки 1 1.Задача E. ГонкаЗадача не требует знания каких-то сложных формул из физики. Сразу открою занавесу и выпишу все формулы, которые потребуются при решении.X0 = 0Xn + 1 = Xn + Vn (Tn+1 - Tn), где Xi - координата, Ti - момент времениНесложно понять, что решение с асимптотикой O(SN2) получит заслуженный Time Limit. Решение с асимптотикой O(KN3) вполне сойдет. Впрочем, скорее всего существует решение с гораздо более хорошей трудоемкостью.Далее будет рассказано решение за O(KN3), которое имеет множество других достоинств.Будем рассматривать всю гонку, как набор некоторых событий упорядоченных во времени. События - изменение скорости какого-либо участника в какой-либо момент времени. Для каждого участника несложно (еще при чтении) получить все события, которые с ним связаны. Каждое из них обладает двумя параметрами: время, когда была сменена скорость и сама величина скорости. Все события можно объединить и упорядочить хронологически (в порядке неубывания времени, когда происходит событие).Теперь нет смысла идти по всем моментам времени (от 0 до S). Есть смысл рассматривать только моменты времени, в которые происходит хотя бы одно событие. Всего смен скоростей будет O(NK). Для дальнейшего решения можно сделать несколько утверждений:Между двумя соседними моментами времени (в которые происходят события) скорости автомобилей остаются постоянными. Соответственно, автомобиль i обгонит на участке между этими двумя моментами времени автомобиль j если Vi > Vj (иначе обгон точно не возможен). А далее требуется соблюдение одного из двух условий:Координата автомобиля i в первый момент времени меньше, чем у автомобиля j, а во второй момент времени координата автомобила i уже больше координаты автомобиля j.Координата автомобиля i в первый момент времени такая же, как у автомобиля j, а во второй момент координата автомобиля i больше координаты автомобиля j. При этом на предыдущем этапе координата автомобиля i была меньше (то есть он сравнялся с автомобилем j на прошлом интервале времени).На каждом временном интервале можно за O(N2) проверять для каждой пары (i, j) обгоняет ли автомобиль i автомобиль j.Каждое из вышеописанных условий можно проверить в целых числах (32 бита вполне хватает). Ответ так же не потребует 64-битовой переменной.Стоит отметить, что решение не использует значение S, которое дается во входном файле.  Дописав один IF можно получить решение, которое будет правильно обрабатывать даже случаи, когда автомобили некоторое время ехали бок о бок.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5709
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    ensuref(n * m >= 2, \"n * m must be at least 2, but n = %d, m = %d, n * m = %d\", n, m, n * m);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    ensuref(n * m >= 2, \"n * m must be at least 2, but n = %d, m = %d, n * m = %d\", n, m, n * m);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    ensuref(n * m >= 2, \"n * m must be at least 2, but n = %d, m = %d, n * m = %d\", n, m, n * m);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read n and m from the input file\n    int n = inf.readInt(1, 100, \"n\");\n    int m = inf.readInt(1, 100, \"m\");\n\n    // Read jury's minimal number of teleporters from ans\n    int k_j = ans.readInt(0, n * m, \"k_j\");\n\n    // Read participant's number of teleporters\n    int k_p = ouf.readInt(0, n * m, \"k_p\");\n\n    // Compare participant's k with jury's k\n    if (k_p > k_j)\n        quitf(_wa, \"Participant's number of teleporters k = %d exceeds minimal k = %d\", k_p, k_j);\n\n    // Read participant's teleporters\n    map<pair<int, int>, pair<int, int>> teleporters;\n    for (int i = 0; i < k_p; ++i) {\n        int x1 = ouf.readInt(1, n, format(\"teleporter x1 [%d]\", i+1).c_str());\n        int y1 = ouf.readInt(1, m, format(\"teleporter y1 [%d]\", i+1).c_str());\n        int x2 = ouf.readInt(1, n, format(\"teleporter x2 [%d]\", i+1).c_str());\n        int y2 = ouf.readInt(1, m, format(\"teleporter y2 [%d]\", i+1).c_str());\n        pair<int, int> from = make_pair(x1, y1);\n        pair<int, int> to = make_pair(x2, y2);\n        if (teleporters.count(from) > 0)\n            quitf(_wa, \"Multiple teleporters installed on square (%d, %d)\", x1, y1);\n        teleporters[from] = to;\n    }\n\n    // Read participant's path\n    int path_length = n * m + 1;\n    vector<pair<int, int>> path;\n    for (int i = 0; i < path_length; ++i) {\n        int x = ouf.readInt(1, n, format(\"path x [%d]\", i+1).c_str());\n        int y = ouf.readInt(1, m, format(\"path y [%d]\", i+1).c_str());\n        path.push_back(make_pair(x, y));\n    }\n\n    // Verify the path\n    if (path[0] != make_pair(1, 1))\n        quitf(_wa, \"Path does not start at (1,1)\");\n\n    if (path.back() != make_pair(1, 1))\n        quitf(_wa, \"Path does not end at (1,1)\");\n\n    map<pair<int, int>, int> visit_count;\n    for (int i = 0; i < path_length; ++i) {\n        pair<int, int> sq = path[i];\n        visit_count[sq]++;\n    }\n\n    // Check visits to (1,1)\n    if (visit_count[make_pair(1,1)] != 2)\n        quitf(_wa, \"Square (1,1) is visited %d times (expected 2 times: start and end)\", visit_count[make_pair(1,1)]);\n\n    // Check other squares\n    for (int x = 1; x <= n; ++x)\n        for (int y = 1; y <= m; ++y)\n            if (x != 1 || y != 1) {\n                if (visit_count[make_pair(x, y)] != 1)\n                    quitf(_wa, \"Square (%d, %d) is visited %d times (expected 1 time)\", x, y, visit_count[make_pair(x, y)]);\n            }\n\n    // Check the movement validity\n    for (int i = 0; i < path_length -1; ++i) {\n        pair<int, int> curr = path[i];\n        pair<int, int> next = path[i+1];\n        // Check if next is a side neighbor\n        int dx = abs(curr.first - next.first);\n        int dy = abs(curr.second - next.second);\n        if ((dx == 1 && dy == 0) || (dx == 0 && dy ==1)) {\n            continue; // valid move\n        }\n        // Check if there is a teleporter from curr to next\n        if (teleporters.count(curr) && teleporters[curr] == next) {\n            continue; // valid teleporter move\n        }\n        // Invalid move\n        quitf(_wa, \"Invalid move from (%d, %d) to (%d, %d)\", curr.first, curr.second, next.first, next.second);\n    }\n\n    // If all checks pass\n    quitf(_ok, \"Correct, participant's k = %d\", k_p);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = 0, m = 0;\n\n    if (type == \"min\") {\n        // Minimum size grid where n * m >= 2\n        n = 1;\n        m = 2;\n    }\n    else if (type == \"max\") {\n        // Maximum size grid\n        n = 100;\n        m = 100;\n    }\n    else if (type == \"n1\") {\n        // n = 1, m varies\n        n = 1;\n        m = rnd.next(2, 100);\n    }\n    else if (type == \"m1\") {\n        // m = 1, n varies\n        n = rnd.next(2, 100);\n        m = 1;\n    }\n    else if (type == \"small_even\") {\n        // Small grid with even n and m\n        n = rnd.next(1, 10) * 2;\n        m = rnd.next(1, 10) * 2;\n    }\n    else if (type == \"small_odd\") {\n        // Small grid with odd n and m\n        n = rnd.next(1, 10) * 2 - 1;\n        m = rnd.next(1, 10) * 2 - 1;\n    }\n    else if (type == \"large_even\") {\n        // Large grid with even n and m\n        n = rnd.next(25, 50) * 2;\n        m = rnd.next(25, 50) * 2;\n    }\n    else if (type == \"large_odd\") {\n        // Large grid with odd n and m\n        n = rnd.next(25, 50) * 2 - 1;\n        m = rnd.next(25, 50) * 2 - 1;\n    }\n    else if (type == \"n_m_equal_even\") {\n        // n and m are equal even numbers\n        n = m = rnd.next(1, 50) * 2;\n    }\n    else if (type == \"n_m_equal_odd\") {\n        // n and m are equal odd numbers\n        n = m = rnd.next(1, 50) * 2 - 1;\n    }\n    else if (type == \"random\") {\n        // Random n and m within constraints\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n        if (n * m < 2) {\n            if (n < 100)\n                n++;\n            else\n                m++;\n        }\n    }\n    else if (type == \"specified\") {\n        // Specify n and m via command line arguments\n        n = opt<int>(\"n\");\n        m = opt<int>(\"m\");\n    }\n    else {\n        // Default to random if type is unrecognized\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n        if (n * m < 2) {\n            if (n < 100)\n                n++;\n            else\n                m++;\n        }\n    }\n\n    // Ensure that constraints are met\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n    ensure(n * m >= 2);\n\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    int n = 0, m = 0;\n\n    if (type == \"min\") {\n        // Minimum size grid where n * m >= 2\n        n = 1;\n        m = 2;\n    }\n    else if (type == \"max\") {\n        // Maximum size grid\n        n = 100;\n        m = 100;\n    }\n    else if (type == \"n1\") {\n        // n = 1, m varies\n        n = 1;\n        m = rnd.next(2, 100);\n    }\n    else if (type == \"m1\") {\n        // m = 1, n varies\n        n = rnd.next(2, 100);\n        m = 1;\n    }\n    else if (type == \"small_even\") {\n        // Small grid with even n and m\n        n = rnd.next(1, 10) * 2;\n        m = rnd.next(1, 10) * 2;\n    }\n    else if (type == \"small_odd\") {\n        // Small grid with odd n and m\n        n = rnd.next(1, 10) * 2 - 1;\n        m = rnd.next(1, 10) * 2 - 1;\n    }\n    else if (type == \"large_even\") {\n        // Large grid with even n and m\n        n = rnd.next(25, 50) * 2;\n        m = rnd.next(25, 50) * 2;\n    }\n    else if (type == \"large_odd\") {\n        // Large grid with odd n and m\n        n = rnd.next(25, 50) * 2 - 1;\n        m = rnd.next(25, 50) * 2 - 1;\n    }\n    else if (type == \"n_m_equal_even\") {\n        // n and m are equal even numbers\n        n = m = rnd.next(1, 50) * 2;\n    }\n    else if (type == \"n_m_equal_odd\") {\n        // n and m are equal odd numbers\n        n = m = rnd.next(1, 50) * 2 - 1;\n    }\n    else if (type == \"random\") {\n        // Random n and m within constraints\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n        if (n * m < 2) {\n            if (n < 100)\n                n++;\n            else\n                m++;\n        }\n    }\n    else if (type == \"specified\") {\n        // Specify n and m via command line arguments\n        n = opt<int>(\"n\");\n        m = opt<int>(\"m\");\n    }\n    else {\n        // Default to random if type is unrecognized\n        n = rnd.next(1, 100);\n        m = rnd.next(1, 100);\n        if (n * m < 2) {\n            if (n < 100)\n                n++;\n            else\n                m++;\n        }\n    }\n\n    // Ensure that constraints are met\n    ensure(1 <= n && n <= 100);\n    ensure(1 <= m && m <= 100);\n    ensure(n * m >= 2);\n\n    printf(\"%d %d\\n\", n, m);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min                  # n=1, m=2\n./gen -type max                  # n=100, m=100\n\n./gen -type n1                   # n=1, m random between 2-100\n./gen -type m1                   # n random between 2-100, m=1\n\n./gen -type small_even           # Small grids with even n and m\n./gen -type small_odd            # Small grids with odd n and m\n\n./gen -type large_even           # Large grids with even n and m\n./gen -type large_odd            # Large grids with odd n and m\n\n./gen -type n_m_equal_even       # n = m, both even\n./gen -type n_m_equal_odd        # n = m, both odd\n\n./gen -type random               # Random grids\n./gen -type random\n./gen -type random\n\n./gen -type small_even\n./gen -type small_odd\n./gen -type large_even\n./gen -type large_odd\n\n./gen -type specified -n 1 -m 2     # n=1, m=2\n./gen -type specified -n 2 -m 1     # n=2, m=1\n./gen -type specified -n 1 -m 50    # n=1, m=50\n./gen -type specified -n 50 -m 1    # n=50, m=1\n\n./gen -type specified -n 99 -m 99   # Large grid with n and m both close to maximum\n./gen -type specified -n 100 -m 1   # n is maximum, m is minimum\n./gen -type specified -n 1 -m 100   # n is minimum, m is maximum\n\n./gen -type specified -n 51 -m 51   # Medium grid with equal n and m\n\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type n1\n./gen -type m1\n./gen -type n_m_equal_odd\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:45.848867",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "43/E",
      "title": "E. Race",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and s (2 ≤ n ≤ 100, 1 ≤ s ≤ 106) — the number of cars and the length of the track in kilometers. Then follow n lines — the description of the system of segments for each car. Every description starts with integer k (1 ≤ k ≤ 100) — the number of segments in the system. Then k space-separated pairs of integers are written. Each pair is the speed and time of the segment. These integers are positive and don't exceed 1000. It is guaranteed, that the sum of lengths of all segments (in kilometers) for each car equals to s; and all the leads happen instantly.",
      "output_spec": "OutputPrint the single number — the number of times some car managed to take the lead over another car during the race.",
      "sample_tests": "ExamplesInputCopy2 332 5 1 2 141 3 11OutputCopy1InputCopy2 332 1 3 10 31 11 3OutputCopy0InputCopy5 332 1 3 3 101 11 32 5 3 3 62 3 1 10 32 6 3 3 5OutputCopy2",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and s (2 ≤ n ≤ 100, 1 ≤ s ≤ 106) — the number of cars and the length of the track in kilometers. Then follow n lines — the description of the system of segments for each car. Every description starts with integer k (1 ≤ k ≤ 100) — the number of segments in the system. Then k space-separated pairs of integers are written. Each pair is the speed and time of the segment. These integers are positive and don't exceed 1000. It is guaranteed, that the sum of lengths of all segments (in kilometers) for each car equals to s; and all the leads happen instantly.\n\nOutputPrint the single number — the number of times some car managed to take the lead over another car during the race.\n\nInputCopy2 332 5 1 2 141 3 11OutputCopy1InputCopy2 332 1 3 10 31 11 3OutputCopy0InputCopy5 332 1 3 3 101 11 32 5 3 3 62 3 1 10 32 6 3 3 5OutputCopy2\n\nInputCopy2 332 5 1 2 141 3 11\n\nOutputCopy1\n\nInputCopy2 332 1 3 10 31 11 3\n\nOutputCopy0\n\nInputCopy5 332 1 3 3 101 11 32 5 3 3 62 3 1 10 32 6 3 3 5\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #42 (Div. 2, Codeforces format) - Codeforces",
          "content": "Good eveningYesterday evening the Saratov university delegation returned from St. Petersburg, from the ACM-ICPC NEERC 2010/11 World Programming Championship semi-finals. If you haven't seen the final standings: 4 Saratov teams received diplomas, and we (Saratov SU 2) advanced to the finals. Saratov SU 1 was also among those, who advanced, that's pretty cool for their first time, but didn't advance because of the limitation \"only one team from one university\".Also we have prepared a Div. 2 round. Thanks for prompt assistance to Edvard Davtyan, Gerald Agapov and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: MiminoUnfortunately, the discrepancy between author’s solution and statement of problem E was detected. We bring our apologies to all the participants. All solutions that have not been Accepted previously were rejudged. Thanks to member xcr for detection of the issue.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/900",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 915
        },
        {
          "title": "Разбор задач A, B, C, D CodeForces Beta Round #42 - Codeforces",
          "content": "А. Футбол.Эту задачу можно решить, не расходуя лишнюю память, а заведя лишь две строки для хранения названий первой и (возможно) второй команд и две целочисленные переменные для хранения количества голов, забитых первой и второй командами. Считываем название первой команды, запоминаем в первой строке и идем циклом до n - 1. На каждом шаге если считанная строка совпадает с уже имеющейся (первой строкой - она всегда есть, так как мы ее заранее (до цикла) считали), то увеличиваем счет этой команды, иначе запоминаем название второй команды и увеличиваем ее счет. В конце делаем целочисленное сравнение и выводим одну из строк.Заметим, что даже если вторая строка останется неинициализированной, ничего плохого не произойдет, так как мы к ней никогда не общаемся, кроме случая, когда победила вторая команда (значит, у нее ненулевое количество голов и строку мы все-таки инициализировали).B. Письмо.Известно, что символы из таблицы ASCII, к которым относятся все (строчные и заглавные) латинские буквы и пробел, имеют коды от 0 до 127. Значит, достаточно завести два массива на 128 символов (можно узнать требуемую память точнее, но char занимает 1 (или 2 байта в Java), поэтому это непринципиально), инициализированных нулями, и заполнить каждый из них следующим образом: идем циклом по строке, получаем код текущего символа строки, элемент массива с таким индексом (кодом символа) увеличиваем на единицу. Таким образом получим два массива - один для первой строки и один для второй. Чтобы составить вторую строку, нужно, чтобы выполнялось условие b[i] <= a[i] для всех i от 0 до 127, кроме (char)i == ' '. Пробелы вырезать ненужно, поэтому для них неравенство может не выполняться.С. Счастливые билеты.Признак делимости на три говорит нам, что натуральное число делится на три тогда и только тогда, когда сумма его цифр делится на 3. Для каждого кусочка билетика мы можем посчитать остатки от деления этого числа на 3 - 0, 1 или 2. Обозначим количество билетов первого типа - a, второго типа -  b, третьего - с. Счастливые билетики можно составить двумя способами: либо соединить кусочки с остатками от деления 0 и 0, либо - 1 и 2. Тогда сумма чисел на получившемся билетике будет 3, что и требуется. Ответом будет число a / 2 + min(b, c). Оставшиеся a % 2 + max(a, b) - min(a, b) билетиков придется выкинуть, так как для них нет соответствующей пары.D. ПутешествиеСперва заметим, что в оптимальном решении может быть не более одного телепорта. Таблицу n * m можно обойти несколькими способами, перемещаясь только по соседним клеткам - например, змейкой или спиралью. Далее, из последней клетки, в которую мы пришли при обходе таблицы, можно телепортироваться в первую.В этой задаче нужно было рассмотреть 4 случая:1. n * m = 2 - тогда ответ легко выписать вручную2. n = 1, m > 2; n > 2, m = 1 - идем по полоске до конца, а из последней клетки ((1, m) или (n, 1)) телепортируемся в первую3. оба n и m нечетные (ни одно из чисел не равно 1) - тогда нужна одна телепортация: обходим доску одним из предложенных способов: змейкой (вверх-вниз или вправо-влево) или по спирали - а из последней клетки телепортируемся4. хотя бы одно из чисел четное, а другое не равно единице - тогда идем вдоль четной стороны до края таблицы, а оставшуюся часть обходим змейкой + делаем один завершающий ход.Для пояснения пункта 4, рассмотрим пример.Пусть n - четное, m - нечетное (не равное 1). Тогда идем вдоль края таблицы из клетки (1, 1) в клетку (n, 1). Дальше возвращаемся в клетку (1, 2) следующим образом: если текущая строка i четная - идем вправо от 2 до m, иначе идем влево от m до 2. Заметим, что последней строкой, которую мы так пройдем, будет первая (по номеру), то есть мы действительно закончим в клетке (1, 2). Осталось сделать только заключительный ход в (1, 1).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/902",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3763
        },
        {
          "title": "CodeForces Beta Round #42 :: Разбор задач - Codeforces",
          "content": "Задача A. ФутболКлассическая задача A второго дивизиона. Можно было решить без хранения в памяти всех N строк входного файла. Хотя тесты проходило и любое решение, которое только можно себе представить.Решение без сохранения всех N строк в памяти: считывать все строки, при встрече незнакомой строки присваивать ей идентификатор. Для каждого идентификатора завести счетчик, который будет отражать, сколько раз строка встретилось во входном файле. Из двух строк выбрать ту, у которой значение счетчика больше.Задача B. ПисьмоСамое простое решение - это для каждой буквы (другие символы просто игнорировать) в обеих строках посчитать число ее вхождений. Если какая-то буква входит во вторую строку большее число раз, чем входит в первую, ответ \"NO\", иначе ответ \"YES\". Очевидная асимптотика решения O(L), где L - ограничение на длину строки во входном файле.Задача С. Счастливые билетыВсем известно условие делимости числа на 3: \"Число кратно трем, тогда и только тогда, когда сумма цифр этого числа делится без остатка на 3\". Соответственно, чтобы при склеивании двух чисел получить число кратное трем, необходим чтобы сумма цифр первого числа плюс сумма цифр второго числа было кратно трем.Стоит отметить, что оперировать в условиях этой задачи можно только с остатками от деления на 3. Несложно понять, что есть смысл соединять числа, которые дают в остатке от деления на 3 двойку с теми, кто дает в остатке единицу. Числа, которые нацело делятся на 3 можно объединять только с числами, которые так же делятся нацело на 3. Если посчитать количество чисел на кусках билетов с остатком от деления на 3 равным 0, 1, 2 (обозначим их как R0, R1, R2 соответственно), то ответом будет min(R1, R2) + [R0 / 2]. Здесь [] - операция округления в меньшую сторону.Задача D. ПутешествиеЗадача не требует знания каких-то алгоритмов, математики или даже банальной логики. От Вас требуется найти все частные случаи и не забыть рассмотреть каждый из них.Теста \"1 1\" быть не могло (ограничения такие).Для тестов \"1 2\" и \"2 1\" ответом служит последовательность из трех клеток (1 1, оставшаяся клетка, 1 1). Телепортов не требуется.Для тестов \"1 M\" и \"N 1\" (2 < N, M) ответом служит последовательность 1 1 -> 1 2 -> ... -> 1 M (ну и аналогично для перевернутого случая) и снова 1 1 в конце. Требуется один телепорт (1 M -> 1 1).Далее логика простая. Если хотя бы одна из сторон - четная, то пройти можно следующим алгоритмом:Рассмотрим случай, когда количество строк нечетно. При нечетном количестве столбцов можно действовать так же, поменяв строки и столбцы местами.Из клетки 1 1 шагнем в 1 2 и далее пойдем змейкой по прямоугольнику Rect(1, 2, N, M). То есть во время обхода змейкой не посещаем первую строку. Такой обход закончится в клетке с координатами 2 M. После чего можно шагнуть на 1 M и спокойно прийти по первой строке в 1 1.Для случая, когда N и M четные, можно воспользоваться тем же алгоритмом. Очевидно, что телепортов строить во всех этих случая не потребуется.Для случая, когда N и M нечетные всегда потребуется один телепорт. Если действовать по той же стратегии, то в конце обхода змейкой можно попасть только в клетку с координатами N M, откуда необходимо телепортироваться в клетку 1 M и пройтись по первой строке до клетки 1 1.Задача E. ГонкаЗадача не требует знания каких-то сложных формул из физики. Сразу открою занавесу и выпишу все формулы, которые потребуются при решении.X0 = 0Xn + 1 = Xn + Vn (Tn+1 - Tn), где Xi - координата, Ti - момент времениНесложно понять, что решение с асимптотикой O(SN2) получит заслуженный Time Limit. Решение с асимптотикой O(KN3) вполне сойдет. Впрочем, скорее всего существует решение с гораздо более хорошей трудоемкостью.Далее будет рассказано решение за O(KN3), которое имеет множество других достоинств.Будем рассматривать всю гонку, как набор некоторых событий упорядоченных во времени. События - изменение скорости какого-либо участника в какой-либо момент времени. Для каждого участника несложно (еще при чтении) получить все события, которые с ним связаны. Каждое из них обладает двумя параметрами: время, когда была сменена скорость и сама величина скорости. Все события можно объединить и упорядочить хронологически (в порядке неубывания времени, когда происходит событие).Теперь нет смысла идти по всем моментам времени (от 0 до S). Есть смысл рассматривать только моменты времени, в которые происходит хотя бы одно событие. Всего смен скоростей будет O(NK). Для дальнейшего решения можно сделать несколько утверждений:Между двумя соседними моментами времени (в которые происходят события) скорости автомобилей остаются постоянными. Соответственно, автомобиль i обгонит на участке между этими двумя моментами времени автомобиль j если Vi > Vj (иначе обгон точно не возможен). А далее требуется соблюдение одного из двух условий:Координата автомобиля i в первый момент времени меньше, чем у автомобиля j, а во второй момент времени координата автомобила i уже больше координаты автомобиля j.Координата автомобиля i в первый момент времени такая же, как у автомобиля j, а во второй момент координата автомобиля i больше координаты автомобиля j. При этом на предыдущем этапе координата автомобиля i была меньше (то есть он сравнялся с автомобилем j на прошлом интервале времени).На каждом временном интервале можно за O(N2) проверять для каждой пары (i, j) обгоняет ли автомобиль i автомобиль j.Каждое из вышеописанных условий можно проверить в целых числах (32 бита вполне хватает). Ответ так же не потребует 64-битовой переменной.Стоит отметить, что решение не использует значение S, которое дается во входном файле.  Дописав один IF можно получить решение, которое будет правильно обрабатывать даже случаи, когда автомобили некоторое время ехали бок о бок.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/905",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 5709
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int k = inf.readInt(1, 100, \"k\");\n        long long sum = 0;\n\n        for (int j = 0; j < k; ++j) {\n            inf.readSpace();\n            int v = inf.readInt(1, 1000, \"v\");\n            inf.readSpace();\n            int t = inf.readInt(1, 1000, \"t\");\n\n            sum += (long long)v * t;\n        }\n\n        inf.readEoln();\n\n        ensuref(sum == s, \"Sum of v_i_j * t_i_j for car %d is %lld, expected %d\", i+1, sum, s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int k = inf.readInt(1, 100, \"k\");\n        long long sum = 0;\n\n        for (int j = 0; j < k; ++j) {\n            inf.readSpace();\n            int v = inf.readInt(1, 1000, \"v\");\n            inf.readSpace();\n            int t = inf.readInt(1, 1000, \"t\");\n\n            sum += (long long)v * t;\n        }\n\n        inf.readEoln();\n\n        ensuref(sum == s, \"Sum of v_i_j * t_i_j for car %d is %lld, expected %d\", i+1, sum, s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100, \"n\");\n    inf.readSpace();\n    int s = inf.readInt(1, 1000000, \"s\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int k = inf.readInt(1, 100, \"k\");\n        long long sum = 0;\n\n        for (int j = 0; j < k; ++j) {\n            inf.readSpace();\n            int v = inf.readInt(1, 1000, \"v\");\n            inf.readSpace();\n            int t = inf.readInt(1, 1000, \"t\");\n\n            sum += (long long)v * t;\n        }\n\n        inf.readEoln();\n\n        ensuref(sum == s, \"Sum of v_i_j * t_i_j for car %d is %lld, expected %d\", i+1, sum, s);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool generate_car(int s, int &k, vector<int>& vi, vector<int>& ti) {\n    k = rnd.next(1, 100);\n    vi.resize(k);\n    ti.resize(k);\n    long long D = 0;\n\n    for (int attempts = 0; attempts < 100; attempts++) {\n        D = 0;\n        for (int j = 0; j < k - 1; j++) {\n            vi[j] = rnd.next(1, 1000);\n            ti[j] = rnd.next(1, 1000);\n            D += (long long)vi[j] * ti[j];\n            if (D > s) {\n                // Adjust ti[j] to fit within s\n                D -= (long long)vi[j] * ti[j];\n                ti[j] = (s - D) / vi[j];\n                if (ti[j] < 1) ti[j] = 1;\n                D += (long long)vi[j] * ti[j];\n                k = j + 1;\n                break;\n            }\n        }\n        long long R = s - D;\n        if (R <= 0) {\n            k = max(k - 1, 1);\n            continue;\n        }\n        bool success = false;\n        for (int t_last = 1; t_last <= min((long long)1000, R); t_last++) {\n            if (R % t_last == 0) {\n                int v_last = R / t_last;\n                if (v_last >= 1 && v_last <= 1000) {\n                    ti[k-1] = t_last;\n                    vi[k-1] = v_last;\n                    success = true;\n                    break;\n                }\n            }\n        }\n        if (success) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid generate_random(int n, int s) {\n    printf(\"%d %d\\n\", n, s);\n    for (int i = 0; i < n; i++) {\n        int k;\n        vector<int> vi, ti;\n        if (!generate_car(s, k, vi, ti)) {\n            // Retry if failed to generate a valid car\n            i--;\n            continue;\n        }\n        printf(\"%d\", k);\n        for (int j = 0; j < k; j++) {\n            printf(\" %d %d\", vi[j], ti[j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid generate_same_speed(int n, int s, int v) {\n    printf(\"%d %d\\n\", n, s);\n    int t = s / v;\n    if (t * v != s) t++; // make sure total distance is at least s\n    if (t > 1000) t = 1000; // t should not exceed 1000\n    for (int i = 0; i < n; i++) {\n        int k = 1;\n        printf(\"%d %d %d\\n\", k, v, t);\n    }\n}\n\nvoid generate_alternating_speed(int n, int s) {\n    printf(\"%d %d\\n\", n, s);\n    for (int i = 0; i < n; i++) {\n        int k = 2;\n        int v1 = rnd.next(1, 1000);\n        int v2 = rnd.next(1, 1000);\n        int total_vt = v1 + v2;\n        int t = s / total_vt;\n        if (t == 0) t = 1;\n        long long d1 = (long long)v1 * t;\n        long long d2 = (long long)v2 * t;\n        long long remain = s - d1 - d2;\n        if (remain > 0) {\n            d2 += remain;\n            t = d2 / v2;\n            if (v2 * t != d2) t++;\n        }\n        if (t > 1000) t = 1000;\n        printf(\"%d %d %d %d %d\\n\", k, v1, t, v2, t);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\", 1000);\n    string type = opt<string>(\"type\", \"random\"); // default type \"random\"\n\n    if (type == \"random\") {\n        generate_random(n, s);\n    } else if (type == \"same_speed\") {\n        int v = opt<int>(\"v\", 10);\n        generate_same_speed(n, s, v);\n    } else if (type == \"alternating_speed\") {\n        generate_alternating_speed(n, s);\n    } else {\n        // default to random\n        generate_random(n, s);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool generate_car(int s, int &k, vector<int>& vi, vector<int>& ti) {\n    k = rnd.next(1, 100);\n    vi.resize(k);\n    ti.resize(k);\n    long long D = 0;\n\n    for (int attempts = 0; attempts < 100; attempts++) {\n        D = 0;\n        for (int j = 0; j < k - 1; j++) {\n            vi[j] = rnd.next(1, 1000);\n            ti[j] = rnd.next(1, 1000);\n            D += (long long)vi[j] * ti[j];\n            if (D > s) {\n                // Adjust ti[j] to fit within s\n                D -= (long long)vi[j] * ti[j];\n                ti[j] = (s - D) / vi[j];\n                if (ti[j] < 1) ti[j] = 1;\n                D += (long long)vi[j] * ti[j];\n                k = j + 1;\n                break;\n            }\n        }\n        long long R = s - D;\n        if (R <= 0) {\n            k = max(k - 1, 1);\n            continue;\n        }\n        bool success = false;\n        for (int t_last = 1; t_last <= min((long long)1000, R); t_last++) {\n            if (R % t_last == 0) {\n                int v_last = R / t_last;\n                if (v_last >= 1 && v_last <= 1000) {\n                    ti[k-1] = t_last;\n                    vi[k-1] = v_last;\n                    success = true;\n                    break;\n                }\n            }\n        }\n        if (success) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid generate_random(int n, int s) {\n    printf(\"%d %d\\n\", n, s);\n    for (int i = 0; i < n; i++) {\n        int k;\n        vector<int> vi, ti;\n        if (!generate_car(s, k, vi, ti)) {\n            // Retry if failed to generate a valid car\n            i--;\n            continue;\n        }\n        printf(\"%d\", k);\n        for (int j = 0; j < k; j++) {\n            printf(\" %d %d\", vi[j], ti[j]);\n        }\n        printf(\"\\n\");\n    }\n}\n\nvoid generate_same_speed(int n, int s, int v) {\n    printf(\"%d %d\\n\", n, s);\n    int t = s / v;\n    if (t * v != s) t++; // make sure total distance is at least s\n    if (t > 1000) t = 1000; // t should not exceed 1000\n    for (int i = 0; i < n; i++) {\n        int k = 1;\n        printf(\"%d %d %d\\n\", k, v, t);\n    }\n}\n\nvoid generate_alternating_speed(int n, int s) {\n    printf(\"%d %d\\n\", n, s);\n    for (int i = 0; i < n; i++) {\n        int k = 2;\n        int v1 = rnd.next(1, 1000);\n        int v2 = rnd.next(1, 1000);\n        int total_vt = v1 + v2;\n        int t = s / total_vt;\n        if (t == 0) t = 1;\n        long long d1 = (long long)v1 * t;\n        long long d2 = (long long)v2 * t;\n        long long remain = s - d1 - d2;\n        if (remain > 0) {\n            d2 += remain;\n            t = d2 / v2;\n            if (v2 * t != d2) t++;\n        }\n        if (t > 1000) t = 1000;\n        printf(\"%d %d %d %d %d\\n\", k, v1, t, v2, t);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int s = opt<int>(\"s\", 1000);\n    string type = opt<string>(\"type\", \"random\"); // default type \"random\"\n\n    if (type == \"random\") {\n        generate_random(n, s);\n    } else if (type == \"same_speed\") {\n        int v = opt<int>(\"v\", 10);\n        generate_same_speed(n, s, v);\n    } else if (type == \"alternating_speed\") {\n        generate_alternating_speed(n, s);\n    } else {\n        // default to random\n        generate_random(n, s);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -s 33 -type random\n./gen -n 2 -s 33 -type same_speed -v 11\n./gen -n 2 -s 33 -type alternating_speed\n\n./gen -n 5 -s 1000 -type random\n./gen -n 5 -s 1000 -type same_speed -v 100\n./gen -n 5 -s 1000 -type alternating_speed\n\n./gen -n 100 -s 1000000 -type random\n./gen -n 100 -s 1000000 -type same_speed -v 1000\n./gen -n 100 -s 1000000 -type alternating_speed\n\n./gen -n 50 -s 1000000 -type random\n./gen -n 50 -s 1000000 -type same_speed -v 500\n./gen -n 50 -s 1000000 -type alternating_speed\n\n./gen -n 3 -s 3000 -type same_speed -v 1\n./gen -n 3 -s 3000 -type same_speed -v 1000\n./gen -n 3 -s 3000 -type random\n\n./gen -n 2 -s 1 -type random\n./gen -n 2 -s 1 -type same_speed -v 1\n./gen -n 2 -s 1 -type alternating_speed\n\n./gen -n 100 -s 1 -type random\n./gen -n 100 -s 1 -type same_speed -v 1\n./gen -n 100 -s 1 -type alternating_speed\n\n./gen -n 100 -s 1000000 -type random\n./gen -n 100 -s 1000000 -type same_speed -v 1000\n./gen -n 100 -s 1000000 -type alternating_speed\n\n./gen -n 2 -s 1000000 -type random\n./gen -n 2 -s 1000000 -type same_speed -v 1000\n./gen -n 2 -s 1000000 -type alternating_speed\n\n./gen -n 100 -s 1000 -type random\n./gen -n 100 -s 1000 -type same_speed -v 10\n./gen -n 100 -s 1000 -type alternating_speed\n\n./gen -n 2 -s 10000 -type random\n./gen -n 2 -s 10000 -type same_speed -v 1000\n./gen -n 2 -s 10000 -type alternating_speed\n\n./gen -n 100 -s 10000 -type random\n./gen -n 100 -s 10000 -type same_speed -v 100\n./gen -n 100 -s 10000 -type alternating_speed\n\n./gen -n 60 -s 999999 -type random\n./gen -n 60 -s 999999 -type same_speed -v 999\n./gen -n 60 -s 999999 -type alternating_speed\n\n./gen -n 99 -s 876543 -type random\n./gen -n 99 -s 876543 -type same_speed -v 999\n./gen -n 99 -s 876543 -type alternating_speed\n\n./gen -n 100 -s 333333 -type random\n./gen -n 100 -s 333333 -type same_speed -v 333\n./gen -n 100 -s 333333 -type alternating_speed\n\n./gen -n 2 -s 1000 -type same_speed -v 1\n./gen -n 2 -s 1000 -type same_speed -v 1000\n./gen -n 2 -s 1000 -type alternating_speed\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:48.306509",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "430/A",
      "title": "A. Points and Segments (easy)",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers: n (1 ≤ n ≤ 100) and m (1 ≤ m ≤ 100). The next line contains n space-separated integers x1, x2, ..., xn (0 ≤ xi ≤ 100) — the coordinates of the points. The following m lines contain the descriptions of the m segments. Each line contains two integers li and ri (0 ≤ li ≤ ri ≤ 100) — the borders of the i-th segment.It's guaranteed that all the points are distinct.",
      "output_spec": "OutputIf there is no good drawing for a given test, output a single integer -1. Otherwise output n integers, each integer must be 0 or 1. The i-th number denotes the color of the i-th point (0 is red, and 1 is blue).If there are multiple good drawings you can output any of them.",
      "sample_tests": "ExamplesInputCopy3 33 7 141 56 1011 15OutputCopy0 0 0InputCopy3 41 2 31 22 35 62 2OutputCopy1 0 1",
      "description": "A. Points and Segments (easy)\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers: n (1 ≤ n ≤ 100) and m (1 ≤ m ≤ 100). The next line contains n space-separated integers x1, x2, ..., xn (0 ≤ xi ≤ 100) — the coordinates of the points. The following m lines contain the descriptions of the m segments. Each line contains two integers li and ri (0 ≤ li ≤ ri ≤ 100) — the borders of the i-th segment.It's guaranteed that all the points are distinct.\n\nOutputIf there is no good drawing for a given test, output a single integer -1. Otherwise output n integers, each integer must be 0 or 1. The i-th number denotes the color of the i-th point (0 is red, and 1 is blue).If there are multiple good drawings you can output any of them.\n\nInputCopy3 33 7 141 56 1011 15OutputCopy0 0 0InputCopy3 41 2 31 22 35 62 2OutputCopy1 0 1\n\nInputCopy3 33 7 141 56 1011 15\n\nOutputCopy0 0 0\n\nInputCopy3 41 2 31 22 35 62 2\n\nOutputCopy1 0 1",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 430\\s*A"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> xs = inf.readInts(n, 0, 100, \"x_i\");\n    inf.readEoln();\n\n    set<int> x_set(xs.begin(), xs.end());\n    ensuref(x_set.size() == n, \"All x_i should be distinct\");\n\n    for (int i = 0; i < m; i++) {\n        int l = inf.readInt(0, 100, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(0, 100, \"r_i\");\n        ensuref(l <= r, \"Segment %d has l_i (%d) > r_i (%d)\", i + 1, l, r);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> xs = inf.readInts(n, 0, 100, \"x_i\");\n    inf.readEoln();\n\n    set<int> x_set(xs.begin(), xs.end());\n    ensuref(x_set.size() == n, \"All x_i should be distinct\");\n\n    for (int i = 0; i < m; i++) {\n        int l = inf.readInt(0, 100, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(0, 100, \"r_i\");\n        ensuref(l <= r, \"Segment %d has l_i (%d) > r_i (%d)\", i + 1, l, r);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> xs = inf.readInts(n, 0, 100, \"x_i\");\n    inf.readEoln();\n\n    set<int> x_set(xs.begin(), xs.end());\n    ensuref(x_set.size() == n, \"All x_i should be distinct\");\n\n    for (int i = 0; i < m; i++) {\n        int l = inf.readInt(0, 100, \"l_i\");\n        inf.readSpace();\n        int r = inf.readInt(0, 100, \"r_i\");\n        ensuref(l <= r, \"Segment %d has l_i (%d) > r_i (%d)\", i + 1, l, r);\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> points;\n    vector<pair<int,int>> segments;\n\n    if (type == \"random\") {\n        // Generate n distinct points between 0 and 100\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Generate m random segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 100);\n            int r = rnd.next(0, 100);\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        // For example, create two segments that conflict over the same point\n        n = 1;\n        m = 2;\n        int x = rnd.next(0, 100);\n        points.push_back(x);\n        segments.push_back(make_pair(x, x));\n        segments.push_back(make_pair(x, x));\n\n    } else if (type == \"full_range_segments\") {\n        // Generate segments that cover the entire range 0 to 100\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // All segments cover the full range\n        for(int i = 0; i < m; ++i) {\n            segments.push_back(make_pair(0, 100));\n        }\n\n    } else if (type == \"single_point_segments\") {\n        // Generate segments that each cover a single point\n        n = m = min(n, m);\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        for(int i = 0; i < m; ++i) {\n            int x = points[i];\n            segments.push_back(make_pair(x, x));\n        }\n\n    } else if (type == \"overlapping_segments\") {\n        // Generate overlapping segments\n\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0);\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Create overlapping segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 50);\n            int r = rnd.next(50, 100);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else if (type == \"non_overlapping_segments\") {\n        // Generate non-overlapping segments\n        // Divide the range into m parts\n        m = min(m, n); // Can't have more segments than points here\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0);\n\n        shuffle(xs.begin(), xs.end());\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        vector<int> dividers;\n        for(int i = 0; i <= m; ++i) {\n            dividers.push_back(i * 100 / m);\n        }\n\n        for(int i = 0; i < m; ++i) {\n            int l = dividers[i];\n            int r = dividers[i+1]-1;\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else if (type == \"max\") {\n        // Max n and m\n        n = 100;\n        m = 100;\n\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0);\n\n        shuffle(xs.begin(), xs.end());\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Generate random segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 100);\n            int r = rnd.next(0, 100);\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else {\n        // Default to random\n        // Generate n distinct points between 0 and 100\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Generate m random segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 100);\n            int r = rnd.next(0, 100);\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", points[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", segments[i].first, segments[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> points;\n    vector<pair<int,int>> segments;\n\n    if (type == \"random\") {\n        // Generate n distinct points between 0 and 100\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Generate m random segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 100);\n            int r = rnd.next(0, 100);\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate an impossible case\n        // For example, create two segments that conflict over the same point\n        n = 1;\n        m = 2;\n        int x = rnd.next(0, 100);\n        points.push_back(x);\n        segments.push_back(make_pair(x, x));\n        segments.push_back(make_pair(x, x));\n\n    } else if (type == \"full_range_segments\") {\n        // Generate segments that cover the entire range 0 to 100\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // All segments cover the full range\n        for(int i = 0; i < m; ++i) {\n            segments.push_back(make_pair(0, 100));\n        }\n\n    } else if (type == \"single_point_segments\") {\n        // Generate segments that each cover a single point\n        n = m = min(n, m);\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        for(int i = 0; i < m; ++i) {\n            int x = points[i];\n            segments.push_back(make_pair(x, x));\n        }\n\n    } else if (type == \"overlapping_segments\") {\n        // Generate overlapping segments\n\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0);\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Create overlapping segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 50);\n            int r = rnd.next(50, 100);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else if (type == \"non_overlapping_segments\") {\n        // Generate non-overlapping segments\n        // Divide the range into m parts\n        m = min(m, n); // Can't have more segments than points here\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0);\n\n        shuffle(xs.begin(), xs.end());\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        vector<int> dividers;\n        for(int i = 0; i <= m; ++i) {\n            dividers.push_back(i * 100 / m);\n        }\n\n        for(int i = 0; i < m; ++i) {\n            int l = dividers[i];\n            int r = dividers[i+1]-1;\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else if (type == \"max\") {\n        // Max n and m\n        n = 100;\n        m = 100;\n\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0);\n\n        shuffle(xs.begin(), xs.end());\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Generate random segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 100);\n            int r = rnd.next(0, 100);\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    } else {\n        // Default to random\n        // Generate n distinct points between 0 and 100\n        vector<int> xs(101);\n        iota(xs.begin(), xs.end(), 0); // xs contains numbers from 0 to 100\n\n        shuffle(xs.begin(), xs.end());\n\n        points.assign(xs.begin(), xs.begin() + n);\n\n        sort(points.begin(), points.end());\n\n        // Generate m random segments\n        for(int i = 0; i < m; ++i) {\n            int l = rnd.next(0, 100);\n            int r = rnd.next(0, 100);\n            if (l > r) swap(l, r);\n            segments.push_back(make_pair(l, r));\n        }\n\n    }\n\n    // Output the data\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d\", points[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for(int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", segments[i].first, segments[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -type impossible\n\n./gen -n 5 -m 5 -type random\n\n./gen -n 100 -m 100 -type random\n\n./gen -n 50 -m 50 -type full_range_segments\n\n./gen -n 50 -m 50 -type overlapping_segments\n\n./gen -n 50 -m 50 -type non_overlapping_segments\n\n./gen -n 10 -m 10 -type single_point_segments\n\n./gen -n 100 -m 100 -type max\n\n./gen -n 1 -m 1 -type random\n\n./gen -n 2 -m 1 -type impossible\n\n./gen -n 4 -m 4 -type impossible\n\n./gen -n 100 -m 100 -type impossible\n\n./gen -n 3 -m 5 -type overlapping_segments\n\n./gen -n 20 -m 20 -type overlapping_segments\n\n./gen -n 80 -m 80 -type overlapping_segments\n\n./gen -n 100 -m 100 -type non_overlapping_segments\n\n./gen -n 70 -m 100 -type random\n\n./gen -n 50 -m 70 -type random\n\n./gen -n 99 -m 99 -type single_point_segments\n\n./gen -n 30 -m 80 -type full_range_segments\n\n./gen -n 100 -m 5 -type full_range_segments\n\n./gen -n 5 -m 100 -type full_range_segments\n\n./gen -n 100 -m 100 -type full_range_segments\n\n./gen -n 2 -m 2 -type impossible\n\n./gen -n 5 -m 5 -type impossible\n\n./gen -n 10 -m 10 -type impossible\n\n./gen -n 1 -m 1 -type impossible\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:50.813540",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "430/B",
      "title": "B. Balls Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers: n (1 ≤ n ≤ 100), k (1 ≤ k ≤ 100) and x (1 ≤ x ≤ k). The next line contains n space-separated integers c1, c2, ..., cn (1 ≤ ci ≤ k). Number ci means that the i-th ball in the row has color ci.It is guaranteed that the initial row of balls will never contain three or more contiguous balls of the same color.",
      "output_spec": "OutputPrint a single integer — the maximum number of balls Iahub can destroy.",
      "sample_tests": "ExamplesInputCopy6 2 21 1 2 2 1 1OutputCopy6InputCopy1 1 11OutputCopy0",
      "description": "B. Balls Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains three integers: n (1 ≤ n ≤ 100), k (1 ≤ k ≤ 100) and x (1 ≤ x ≤ k). The next line contains n space-separated integers c1, c2, ..., cn (1 ≤ ci ≤ k). Number ci means that the i-th ball in the row has color ci.It is guaranteed that the initial row of balls will never contain three or more contiguous balls of the same color.\n\nOutputPrint a single integer — the maximum number of balls Iahub can destroy.\n\nInputCopy6 2 21 1 2 2 1 1OutputCopy6InputCopy1 1 11OutputCopy0\n\nInputCopy6 2 21 1 2 2 1 1\n\nOutputCopy6\n\nInputCopy1 1 11\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 430\\s*B"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(1, k, \"x\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, k, \"c\");\n    inf.readEoln();\n\n    // Check that the initial row of balls does NOT contain three or more contiguous balls of the same color\n    for (int i = 0; i <= n - 3; i++) {\n        ensuref(!(c[i] == c[i+1] && c[i+1] == c[i+2]), \n            \"The initial row contains three or more contiguous balls of the same color at positions %d, %d, %d\", \n            i+1, i+2, i+3);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(1, k, \"x\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, k, \"c\");\n    inf.readEoln();\n\n    // Check that the initial row of balls does NOT contain three or more contiguous balls of the same color\n    for (int i = 0; i <= n - 3; i++) {\n        ensuref(!(c[i] == c[i+1] && c[i+1] == c[i+2]), \n            \"The initial row contains three or more contiguous balls of the same color at positions %d, %d, %d\", \n            i+1, i+2, i+3);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(1, k, \"x\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, k, \"c\");\n    inf.readEoln();\n\n    // Check that the initial row of balls does NOT contain three or more contiguous balls of the same color\n    for (int i = 0; i <= n - 3; i++) {\n        ensuref(!(c[i] == c[i+1] && c[i+1] == c[i+2]), \n            \"The initial row contains three or more contiguous balls of the same color at positions %d, %d, %d\", \n            i+1, i+2, i+3);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n    int k = opt<int>(\"k\", 1);\n    int x = opt<int>(\"x\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> c;\n\n    if (type == \"sample1\") {\n        /* Sample Input 1 */\n        n = 6;\n        k = 2;\n        x = 2;\n        c = {1, 1, 2, 2, 1, 1};\n    } else if (type == \"sample2\") {\n        /* Sample Input 2 */\n        n = 1;\n        k = 1;\n        x = 1;\n        c = {1};\n    } else if (type == \"random\") {\n        /* Generate a random sequence */\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int color = rnd.next(1, k);\n            if (i >= 2 && color == c[i-1] && c[i-1] == c[i-2]) {\n                /* Avoid three same colors in a row */\n                do {\n                    color = rnd.next(1, k);\n                } while (color == c[i-1]);\n            }\n            c[i] = color;\n        }\n    } else if (type == \"max_destruction\") {\n        /* Generate a sequence where maximum balls can be destroyed */\n        c.resize(n);\n        /* Alternate pairs of x and another color */\n        int other_color = x % k + 1; // Ensure other_color is different from x\n        for (int i = 0; i < n; ) {\n            c[i++] = x;\n            if (i < n) c[i++] = x;\n            if (i < n) c[i++] = other_color;\n            if (i < n) c[i++] = other_color;\n        }\n        /* Adjust to avoid three same colors in a row */\n        for (int i = 2; i < n; ++i) {\n            if (c[i] == c[i-1] && c[i-1] == c[i-2]) {\n                c[i] = c[i] % k + 1;\n            }\n        }\n    } else if (type == \"no_destruction\") {\n        /* Generate a sequence where no balls can be destroyed */\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            c[i] = (i % k) + 1;\n            /* Ensure no three same colors in a row */\n            if (i >= 2 && c[i] == c[i-1] && c[i-1] == c[i-2]) {\n                c[i] = c[i] % k + 1;\n            }\n        }\n    } else if (type == \"single_chain_reaction\") {\n        /* Generate a sequence causing a single chain reaction */\n        c.resize(n);\n        c[0] = x;\n        c[1 % n] = x;\n        for (int i = 2; i < n; ++i) {\n            c[i] = rnd.next(1, k);\n            /* Avoid three same colors in a row */\n            if (i >= 2 && c[i] == c[i-1] && c[i-1] == c[i-2]) {\n                c[i] = c[i] % k + 1;\n            }\n        }\n    } else {\n        /* Default to random if type is unrecognized */\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int color = rnd.next(1, k);\n            if (i >= 2 && color == c[i-1] && c[i-1] == c[i-2]) {\n                do {\n                    color = rnd.next(1, k);\n                } while (color == c[i-1]);\n            }\n            c[i] = color;\n        }\n    }\n\n    /* Ensure the sequence does not contain three or more same-colored balls consecutively */\n    for (int i = 2; i < n; ++i) {\n        if (c[i] == c[i-1] && c[i-1] == c[i-2]) {\n            c[i] = c[i] % k + 1;\n        }\n    }\n\n    /* Output n, k, x */\n    printf(\"%d %d %d\\n\", n, k, x);\n\n    /* Output the sequence */\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], i + 1 == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1);\n    int k = opt<int>(\"k\", 1);\n    int x = opt<int>(\"x\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> c;\n\n    if (type == \"sample1\") {\n        /* Sample Input 1 */\n        n = 6;\n        k = 2;\n        x = 2;\n        c = {1, 1, 2, 2, 1, 1};\n    } else if (type == \"sample2\") {\n        /* Sample Input 2 */\n        n = 1;\n        k = 1;\n        x = 1;\n        c = {1};\n    } else if (type == \"random\") {\n        /* Generate a random sequence */\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int color = rnd.next(1, k);\n            if (i >= 2 && color == c[i-1] && c[i-1] == c[i-2]) {\n                /* Avoid three same colors in a row */\n                do {\n                    color = rnd.next(1, k);\n                } while (color == c[i-1]);\n            }\n            c[i] = color;\n        }\n    } else if (type == \"max_destruction\") {\n        /* Generate a sequence where maximum balls can be destroyed */\n        c.resize(n);\n        /* Alternate pairs of x and another color */\n        int other_color = x % k + 1; // Ensure other_color is different from x\n        for (int i = 0; i < n; ) {\n            c[i++] = x;\n            if (i < n) c[i++] = x;\n            if (i < n) c[i++] = other_color;\n            if (i < n) c[i++] = other_color;\n        }\n        /* Adjust to avoid three same colors in a row */\n        for (int i = 2; i < n; ++i) {\n            if (c[i] == c[i-1] && c[i-1] == c[i-2]) {\n                c[i] = c[i] % k + 1;\n            }\n        }\n    } else if (type == \"no_destruction\") {\n        /* Generate a sequence where no balls can be destroyed */\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            c[i] = (i % k) + 1;\n            /* Ensure no three same colors in a row */\n            if (i >= 2 && c[i] == c[i-1] && c[i-1] == c[i-2]) {\n                c[i] = c[i] % k + 1;\n            }\n        }\n    } else if (type == \"single_chain_reaction\") {\n        /* Generate a sequence causing a single chain reaction */\n        c.resize(n);\n        c[0] = x;\n        c[1 % n] = x;\n        for (int i = 2; i < n; ++i) {\n            c[i] = rnd.next(1, k);\n            /* Avoid three same colors in a row */\n            if (i >= 2 && c[i] == c[i-1] && c[i-1] == c[i-2]) {\n                c[i] = c[i] % k + 1;\n            }\n        }\n    } else {\n        /* Default to random if type is unrecognized */\n        c.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int color = rnd.next(1, k);\n            if (i >= 2 && color == c[i-1] && c[i-1] == c[i-2]) {\n                do {\n                    color = rnd.next(1, k);\n                } while (color == c[i-1]);\n            }\n            c[i] = color;\n        }\n    }\n\n    /* Ensure the sequence does not contain three or more same-colored balls consecutively */\n    for (int i = 2; i < n; ++i) {\n        if (c[i] == c[i-1] && c[i-1] == c[i-2]) {\n            c[i] = c[i] % k + 1;\n        }\n    }\n\n    /* Output n, k, x */\n    printf(\"%d %d %d\\n\", n, k, x);\n\n    /* Output the sequence */\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], i + 1 == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type sample1\n./gen -type sample2\n\n./gen -n 1 -k 1 -x 1 -type random\n./gen -n 2 -k 2 -x 1 -type random\n./gen -n 5 -k 2 -x 1 -type random\n./gen -n 5 -k 2 -x 2 -type random\n./gen -n 10 -k 5 -x 3 -type random\n./gen -n 20 -k 5 -x 2 -type max_destruction\n./gen -n 30 -k 3 -x 1 -type max_destruction\n./gen -n 50 -k 10 -x 5 -type max_destruction\n./gen -n 70 -k 10 -x 5 -type random\n./gen -n 80 -k 5 -x 3 -type single_chain_reaction\n./gen -n 90 -k 4 -x 2 -type single_chain_reaction\n./gen -n 100 -k 100 -x 50 -type random\n./gen -n 99 -k 2 -x 1 -type no_destruction\n./gen -n 100 -k 5 -x 2 -type no_destruction\n./gen -n 100 -k 5 -x 2 -type random\n./gen -n 100 -k 100 -x 1 -type random\n./gen -n 1 -k 1 -x 1 -type no_destruction\n./gen -n 1 -k 1 -x 1 -type max_destruction\n./gen -n 2 -k 2 -x 1 -type single_chain_reaction\n./gen -n 50 -k 2 -x 1 -type max_destruction\n./gen -n 100 -k 2 -x 1 -type max_destruction\n./gen -n 99 -k 50 -x 25 -type random\n./gen -n 100 -k 25 -x 10 -type single_chain_reaction\n./gen -n 10 -k 10 -x 1 -type no_destruction\n./gen -n 75 -k 50 -x 25 -type random\n./gen -n 100 -k 100 -x 1 -type single_chain_reaction\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:52.761356",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "430/C",
      "title": "C. Xor-tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105). Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) meaning there is an edge between nodes ui and vi. The next line contains n integer numbers, the i-th of them corresponds to initi (initi is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goali (goali is either 0 or 1).",
      "output_spec": "OutputIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer xi, representing that you pick a node xi.",
      "sample_tests": "ExamplesInputCopy102 13 14 25 16 27 58 69 810 51 0 1 1 0 1 0 1 0 11 0 1 0 0 1 1 1 0 1OutputCopy247",
      "description": "C. Xor-tree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105). Each of the next n - 1 lines contains two integers ui and vi (1 ≤ ui, vi ≤ n; ui ≠ vi) meaning there is an edge between nodes ui and vi. The next line contains n integer numbers, the i-th of them corresponds to initi (initi is either 0 or 1). The following line also contains n integer numbers, the i-th number corresponds to goali (goali is either 0 or 1).\n\nOutputIn the first line output an integer number cnt, representing the minimal number of operations you perform. Each of the next cnt lines should contain an integer xi, representing that you pick a node xi.\n\nInputCopy102 13 14 25 16 27 58 69 810 51 0 1 1 0 1 0 1 0 11 0 1 0 0 1 1 1 0 1OutputCopy247\n\nInputCopy102 13 14 25 16 27 58 69 810 51 0 1 1 0 1 0 1 0 11 0 1 0 0 1 1 1 0 1\n\nOutputCopy247",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 430 和字母"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000);  // 1 ≤ n ≤ 1e5\n    inf.readEoln();\n    \n    // Build adjacency list for the tree\n    vector<vector<int>> adj(n + 1);  // 1-based indexing\n    set<pair<int, int>> edges;  // To check for duplicate edges\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n);\n        inf.readSpace();\n        int v = inf.readInt(1, n);\n        inf.readEoln();\n        ensuref(u != v, \"u and v must be different, but u=%d and v=%d\", u, v);\n\n        // Check for duplicate edges\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n\n        // Build adjacency list to check connectedness and acyclicity\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Read initial values init_i (0 or 1)\n    vector<int> init(n + 1);  // 1-based indexing\n    init[1] = inf.readInt(0, 1);\n    for (int i = 2; i <= n; ++i) {\n        inf.readSpace();\n        init[i] = inf.readInt(0, 1);\n    }\n    inf.readEoln();\n\n    // Read goal values goal_i (0 or 1)\n    vector<int> goal(n + 1);  // 1-based indexing\n    goal[1] = inf.readInt(0, 1);\n    for (int i = 2; i <= n; ++i) {\n        inf.readSpace();\n        goal[i] = inf.readInt(0, 1);\n    }\n    inf.readEoln();\n    \n    inf.readEof();\n\n    // Check that the graph is connected and acyclic (i.e., it's a tree)\n\n    // Use DFS to verify that all nodes are reachable from the root\n    vector<bool> visited(n + 1, false);\n    int count = 0;\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        ++count;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n    ensuref(count == n, \"The graph is not connected\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000);  // 1 ≤ n ≤ 1e5\n    inf.readEoln();\n    \n    // Build adjacency list for the tree\n    vector<vector<int>> adj(n + 1);  // 1-based indexing\n    set<pair<int, int>> edges;  // To check for duplicate edges\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n);\n        inf.readSpace();\n        int v = inf.readInt(1, n);\n        inf.readEoln();\n        ensuref(u != v, \"u and v must be different, but u=%d and v=%d\", u, v);\n\n        // Check for duplicate edges\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n\n        // Build adjacency list to check connectedness and acyclicity\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Read initial values init_i (0 or 1)\n    vector<int> init(n + 1);  // 1-based indexing\n    init[1] = inf.readInt(0, 1);\n    for (int i = 2; i <= n; ++i) {\n        inf.readSpace();\n        init[i] = inf.readInt(0, 1);\n    }\n    inf.readEoln();\n\n    // Read goal values goal_i (0 or 1)\n    vector<int> goal(n + 1);  // 1-based indexing\n    goal[1] = inf.readInt(0, 1);\n    for (int i = 2; i <= n; ++i) {\n        inf.readSpace();\n        goal[i] = inf.readInt(0, 1);\n    }\n    inf.readEoln();\n    \n    inf.readEof();\n\n    // Check that the graph is connected and acyclic (i.e., it's a tree)\n\n    // Use DFS to verify that all nodes are reachable from the root\n    vector<bool> visited(n + 1, false);\n    int count = 0;\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        ++count;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n    ensuref(count == n, \"The graph is not connected\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000);  // 1 ≤ n ≤ 1e5\n    inf.readEoln();\n    \n    // Build adjacency list for the tree\n    vector<vector<int>> adj(n + 1);  // 1-based indexing\n    set<pair<int, int>> edges;  // To check for duplicate edges\n\n    for (int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n);\n        inf.readSpace();\n        int v = inf.readInt(1, n);\n        inf.readEoln();\n        ensuref(u != v, \"u and v must be different, but u=%d and v=%d\", u, v);\n\n        // Check for duplicate edges\n        pair<int, int> edge = make_pair(min(u, v), max(u, v));\n        ensuref(edges.count(edge) == 0, \"Duplicate edge between %d and %d\", u, v);\n        edges.insert(edge);\n\n        // Build adjacency list to check connectedness and acyclicity\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Read initial values init_i (0 or 1)\n    vector<int> init(n + 1);  // 1-based indexing\n    init[1] = inf.readInt(0, 1);\n    for (int i = 2; i <= n; ++i) {\n        inf.readSpace();\n        init[i] = inf.readInt(0, 1);\n    }\n    inf.readEoln();\n\n    // Read goal values goal_i (0 or 1)\n    vector<int> goal(n + 1);  // 1-based indexing\n    goal[1] = inf.readInt(0, 1);\n    for (int i = 2; i <= n; ++i) {\n        inf.readSpace();\n        goal[i] = inf.readInt(0, 1);\n    }\n    inf.readEoln();\n    \n    inf.readEof();\n\n    // Check that the graph is connected and acyclic (i.e., it's a tree)\n\n    // Use DFS to verify that all nodes are reachable from the root\n    vector<bool> visited(n + 1, false);\n    int count = 0;\n\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        ++count;\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                dfs(v);\n            }\n        }\n    };\n\n    dfs(1);\n    ensuref(count == n, \"The graph is not connected\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> tree;\nvector<int> init, goal;\n\n// Function to simulate the participant's operations\nvoid simulate(const unordered_set<int>& picks, vector<int>& values) {\n    function<void(int, int, int, int, int)> dfs = [&](int u, int parent, int depth, int flip_even, int flip_odd) {\n\n        if (picks.count(u)) {\n            if (depth % 2 == 0) {\n                flip_even ^= 1;\n            } else {\n                flip_odd ^= 1;\n            }\n        }\n\n        if (depth % 2 == 0) {\n            values[u] ^= flip_even;\n        } else {\n            values[u] ^= flip_odd;\n        }\n\n        for (int v : tree[u]) {\n            if (v != parent) {\n                dfs(v, u, depth + 1, flip_even, flip_odd);\n            }\n        }\n    };\n\n    dfs(1, 0, 0, 0, 0);\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    tree.resize(n + 1);\n    for (int i = 0; i < n - 1; i++) {\n        int u = inf.readInt(1, n);\n        int v = inf.readInt(1, n);\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n    }\n\n    init.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        init[i] = inf.readInt(0, 1, format(\"init[%d]\", i).c_str());\n    }\n\n    goal.resize(n + 1);\n    for (int i = 1; i <= n; i++) {\n        goal[i] = inf.readInt(0, 1, format(\"goal[%d]\", i).c_str());\n    }\n\n    // Read jury's minimal cnt\n    int jury_cnt = ans.readInt(0, n, \"jury cnt\");\n\n    // Read participant's cnt\n    int participant_cnt = ouf.readInt(0, n, \"participant cnt\");\n\n    if (participant_cnt > jury_cnt) {\n        quitf(_wa, \"Participant's cnt (%d) is greater than minimal cnt (%d)\", participant_cnt, jury_cnt);\n    } else if (participant_cnt < jury_cnt) {\n        quitf(_fail, \"Participant's cnt (%d) is less than minimal cnt (%d)\", participant_cnt, jury_cnt);\n    }\n\n    // Read participant's picks\n    unordered_set<int> picks_set;\n    for (int i = 0; i < participant_cnt; i++) {\n        int x = ouf.readInt(1, n, format(\"xi[%d]\", i + 1).c_str());\n        picks_set.insert(x);\n    }\n\n    // Simulate participant's operations\n    vector<int> values = init; // Copy initial values\n    simulate(picks_set, values);\n\n    // Check if values match goal\n    bool correct = true;\n    for (int i = 1; i <= n; i++) {\n        if (values[i] != goal[i]) {\n            correct = false;\n            break;\n        }\n    }\n\n    if (!correct) {\n        quitf(_wa, \"After participant's operations, goal not reached\");\n    } else {\n        quitf(_ok, \"Correct answer with minimal cnt = %d\", participant_cnt);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string init_type = opt<string>(\"init_type\", \"random\");\n    string goal_type = opt<string>(\"goal_type\", \"random\");\n\n    // Generate tree edges\n    vector<pair<int,int>> edges;\n\n    if (tree_type == \"chain\") {\n        // Nodes connected like a line\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i-1, i});\n    } else if (tree_type == \"star\") {\n        // All nodes connected to root\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (tree_type == \"binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i/2, i});\n    } else if (tree_type == \"bamboo\") {\n        // Skewed tree (all left or right children)\n        int cur = 1;\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({cur, i});\n            cur = i; \n        }\n    } else if (tree_type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({rnd.next(1, i-1), i});\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({rnd.next(1, i-1), i});\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate initial values\n    vector<int> init(n+1);\n    if (init_type == \"all_zero\") {\n        for(int i = 1; i <= n; ++i)\n            init[i] = 0;\n    } else if (init_type == \"all_one\") {\n        for(int i = 1; i <= n; ++i)\n            init[i] = 1;\n    } else if (init_type == \"random\") {\n        for(int i = 1; i <= n; ++i)\n            init[i] = rnd.next(0,1);\n    } else if (init_type == \"alternate\") {\n        // Alternate between 0 and 1\n        for(int i = 1; i <= n; ++i)\n            init[i] = i % 2;\n    } else {\n        // Default to random\n        for(int i = 1; i <= n; ++i)\n            init[i] = rnd.next(0,1);\n    }\n\n    // Generate goal values\n    vector<int> goal(n+1);\n    if (goal_type == \"all_zero\") {\n        for(int i = 1; i <= n; ++i)\n            goal[i] = 0;\n    } else if (goal_type == \"all_one\") {\n        for(int i = 1; i <= n; ++i)\n            goal[i] = 1;\n    } else if (goal_type == \"random\") {\n        for(int i = 1; i <= n; ++i)\n            goal[i] = rnd.next(0,1);\n    } else if (goal_type == \"alternate\") {\n        // Alternate between 0 and 1\n        for(int i = 1; i <= n; ++i)\n            goal[i] = (i+1) % 2;\n    } else {\n        // Default to random\n        for(int i = 1; i <= n; ++i)\n            goal[i] = rnd.next(0,1);\n    }\n\n    // Output number of nodes\n    printf(\"%d\\n\", n);\n    // Output edges\n    for(auto &edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    // Output initial values\n    for(int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", init[i], i == n ? '\\n' : ' ');\n    }\n    // Output goal values\n    for(int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", goal[i], i == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string init_type = opt<string>(\"init_type\", \"random\");\n    string goal_type = opt<string>(\"goal_type\", \"random\");\n\n    // Generate tree edges\n    vector<pair<int,int>> edges;\n\n    if (tree_type == \"chain\") {\n        // Nodes connected like a line\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i-1, i});\n    } else if (tree_type == \"star\") {\n        // All nodes connected to root\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({1, i});\n    } else if (tree_type == \"binary\") {\n        // Complete binary tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({i/2, i});\n    } else if (tree_type == \"bamboo\") {\n        // Skewed tree (all left or right children)\n        int cur = 1;\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({cur, i});\n            cur = i; \n        }\n    } else if (tree_type == \"random\") {\n        // Random tree\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({rnd.next(1, i-1), i});\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Default to random\n        for (int i = 2; i <= n; ++i)\n            edges.push_back({rnd.next(1, i-1), i});\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Generate initial values\n    vector<int> init(n+1);\n    if (init_type == \"all_zero\") {\n        for(int i = 1; i <= n; ++i)\n            init[i] = 0;\n    } else if (init_type == \"all_one\") {\n        for(int i = 1; i <= n; ++i)\n            init[i] = 1;\n    } else if (init_type == \"random\") {\n        for(int i = 1; i <= n; ++i)\n            init[i] = rnd.next(0,1);\n    } else if (init_type == \"alternate\") {\n        // Alternate between 0 and 1\n        for(int i = 1; i <= n; ++i)\n            init[i] = i % 2;\n    } else {\n        // Default to random\n        for(int i = 1; i <= n; ++i)\n            init[i] = rnd.next(0,1);\n    }\n\n    // Generate goal values\n    vector<int> goal(n+1);\n    if (goal_type == \"all_zero\") {\n        for(int i = 1; i <= n; ++i)\n            goal[i] = 0;\n    } else if (goal_type == \"all_one\") {\n        for(int i = 1; i <= n; ++i)\n            goal[i] = 1;\n    } else if (goal_type == \"random\") {\n        for(int i = 1; i <= n; ++i)\n            goal[i] = rnd.next(0,1);\n    } else if (goal_type == \"alternate\") {\n        // Alternate between 0 and 1\n        for(int i = 1; i <= n; ++i)\n            goal[i] = (i+1) % 2;\n    } else {\n        // Default to random\n        for(int i = 1; i <= n; ++i)\n            goal[i] = rnd.next(0,1);\n    }\n\n    // Output number of nodes\n    printf(\"%d\\n\", n);\n    // Output edges\n    for(auto &edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n    // Output initial values\n    for(int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", init[i], i == n ? '\\n' : ' ');\n    }\n    // Output goal values\n    for(int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", goal[i], i == n ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree_type chain -init_type all_zero -goal_type all_zero\n./gen -n 1 -tree_type chain -init_type all_zero -goal_type all_one\n./gen -n 1 -tree_type chain -init_type all_one -goal_type all_zero\n\n./gen -n 2 -tree_type chain -init_type all_zero -goal_type all_one\n\n./gen -n 10 -tree_type chain -init_type random -goal_type random\n./gen -n 10 -tree_type star -init_type random -goal_type random\n./gen -n 10 -tree_type binary -init_type all_zero -goal_type all_zero\n./gen -n 10 -tree_type binary -init_type all_zero -goal_type all_one\n./gen -n 10 -tree_type binary -init_type all_one -goal_type all_one\n\n./gen -n 100 -tree_type chain -init_type random -goal_type random\n./gen -n 100 -tree_type star -init_type random -goal_type random\n./gen -n 100 -tree_type binary -init_type random -goal_type random\n\n./gen -n 1000 -tree_type random -init_type random -goal_type random\n./gen -n 5000 -tree_type random -init_type random -goal_type random\n\n./gen -n 100000 -tree_type chain -init_type all_zero -goal_type all_one\n./gen -n 100000 -tree_type chain -init_type all_zero -goal_type all_zero\n\n./gen -n 100000 -tree_type bamboo -init_type random -goal_type random\n./gen -n 100000 -tree_type star -init_type random -goal_type random\n./gen -n 100000 -tree_type random -init_type random -goal_type random\n\n./gen -n 100000 -tree_type binary -init_type alternate -goal_type alternate\n\n./gen -n 50000 -tree_type random -init_type all_one -goal_type all_zero\n./gen -n 50000 -tree_type random -init_type all_zero -goal_type all_one\n\n./gen -n 100000 -tree_type chain -init_type alternate -goal_type alternate\n./gen -n 100000 -tree_type chain -init_type random -goal_type random\n./gen -n 100000 -tree_type chain -init_type all_one -goal_type all_one\n\n./gen -n 99999 -tree_type random -init_type random -goal_type random\n\n./gen -n 100000 -tree_type binary -init_type all_zero -goal_type alternate\n./gen -n 100000 -tree_type binary -init_type alternate -goal_type all_zero\n\n./gen -n 100000 -tree_type binary -init_type alternate -goal_type all_one\n\n./gen -n 100000 -tree_type binary -init_type random -goal_type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:55.239846",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "430/D",
      "title": "D. Working out",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n and m (3 ≤ n, m ≤ 1000). Each of the next n lines contains m integers: j-th number from i-th line denotes element a[i][j] (0 ≤ a[i][j] ≤ 105).",
      "output_spec": "OutputThe output contains a single number — the maximum total gain possible.",
      "sample_tests": "ExamplesInputCopy3 3100 100 100100 1 100100 100 100OutputCopy800",
      "description": "D. Working out\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains two integers n and m (3 ≤ n, m ≤ 1000). Each of the next n lines contains m integers: j-th number from i-th line denotes element a[i][j] (0 ≤ a[i][j] ≤ 105).\n\nOutputThe output contains a single number — the maximum total gain possible.\n\nInputCopy3 3100 100 100100 1 100100 100 100OutputCopy800\n\nInputCopy3 3100 100 100100 1 100100 100 100\n\nOutputCopy800\n\nNoteIahub will choose exercises a[1][1] → a[1][2] → a[2][2] → a[3][2] → a[3][3]. Iahubina will choose exercises a[3][1] → a[2][1] → a[2][2] → a[2][3] → a[1][3].",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 430 和字母"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 100000, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 100000, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(3, 1000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 100000, \"a_i_j\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_A = 100000; // 1e5\n\n    vector<vector<int>> a(n, vector<int>(m, 0));\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = rnd.next(0, MAX_A);\n            }\n        }\n    } else if (type == \"zeros\") {\n        // All zeros; already initialized\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = MAX_A;\n            }\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = 1;\n            }\n        }\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n && i < m; i++) {\n            a[i][i] = MAX_A;\n        }\n    } else if (type == \"pyramidal\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int dist_i = abs(i - n/2);\n                int dist_j = abs(j - m/2);\n                int max_dist = max(n, m) / 2;\n                a[i][j] = max(0, MAX_A - (dist_i + dist_j) * (MAX_A / max_dist));\n            }\n        }\n    } else if (type == \"forced_meet_corner\") {\n        for (int i = 0; i < n; i++) {\n            a[i][m - 1] = MAX_A;\n        }\n        for (int j = 0; j < m; j++) {\n            a[0][j] = MAX_A;\n        }\n        a[0][m - 1] = 0; // Meeting point\n    } else if (type == \"forced_meet_center\") {\n        int ci = n / 2;\n        int cj = m / 2;\n        for (int i = 0; i < n; i++) {\n            a[i][cj] = MAX_A;\n        }\n        for (int j = 0; j < m; j++) {\n            a[ci][j] = MAX_A;\n        }\n        a[ci][cj] = 0; // Meeting point\n    } else if (type == \"long_paths\") {\n        for (int i = 0; i < n; i++) {\n            a[i][0] = MAX_A;\n        }\n        for (int j = 0; j < m; j++) {\n            a[n-1][j] = MAX_A;\n        }\n        a[n-1][0] = 0; // Starting point for Iahubina\n    } else if (type == \"max_single_cell\") {\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        a[x][y] = MAX_A;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = rnd.next(0, MAX_A);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (j > 0) printf(\" \");\n            printf(\"%d\", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n);\n    string type = opt<string>(\"type\", \"random\");\n\n    const int MAX_A = 100000; // 1e5\n\n    vector<vector<int>> a(n, vector<int>(m, 0));\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = rnd.next(0, MAX_A);\n            }\n        }\n    } else if (type == \"zeros\") {\n        // All zeros; already initialized\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = MAX_A;\n            }\n        }\n    } else if (type == \"ones\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = 1;\n            }\n        }\n    } else if (type == \"diagonal\") {\n        for (int i = 0; i < n && i < m; i++) {\n            a[i][i] = MAX_A;\n        }\n    } else if (type == \"pyramidal\") {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int dist_i = abs(i - n/2);\n                int dist_j = abs(j - m/2);\n                int max_dist = max(n, m) / 2;\n                a[i][j] = max(0, MAX_A - (dist_i + dist_j) * (MAX_A / max_dist));\n            }\n        }\n    } else if (type == \"forced_meet_corner\") {\n        for (int i = 0; i < n; i++) {\n            a[i][m - 1] = MAX_A;\n        }\n        for (int j = 0; j < m; j++) {\n            a[0][j] = MAX_A;\n        }\n        a[0][m - 1] = 0; // Meeting point\n    } else if (type == \"forced_meet_center\") {\n        int ci = n / 2;\n        int cj = m / 2;\n        for (int i = 0; i < n; i++) {\n            a[i][cj] = MAX_A;\n        }\n        for (int j = 0; j < m; j++) {\n            a[ci][j] = MAX_A;\n        }\n        a[ci][cj] = 0; // Meeting point\n    } else if (type == \"long_paths\") {\n        for (int i = 0; i < n; i++) {\n            a[i][0] = MAX_A;\n        }\n        for (int j = 0; j < m; j++) {\n            a[n-1][j] = MAX_A;\n        }\n        a[n-1][0] = 0; // Starting point for Iahubina\n    } else if (type == \"max_single_cell\") {\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        a[x][y] = MAX_A;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = rnd.next(0, MAX_A);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (j > 0) printf(\" \");\n            printf(\"%d\", a[i][j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random grid\n./gen -n 3 -m 3 -type random\n\n# Small zeros grid\n./gen -n 3 -m 3 -type zeros\n\n# Small max grid\n./gen -n 3 -m 3 -type max\n\n# Small ones grid\n./gen -n 3 -m 3 -type ones\n\n# Medium random grid\n./gen -n 10 -m 10 -type random\n\n# Medium max grid\n./gen -n 10 -m 10 -type max\n\n# Medium zeros grid\n./gen -n 10 -m 10 -type zeros\n\n# Large random grid\n./gen -n 1000 -m 1000 -type random\n\n# Large max grid\n./gen -n 1000 -m 1000 -type max\n\n# Large zeros grid\n./gen -n 1000 -m 1000 -type zeros\n\n# Diagonal grid small\n./gen -n 10 -m 10 -type diagonal\n\n# Diagonal grid large\n./gen -n 1000 -m 1000 -type diagonal\n\n# Pyramidal grid medium\n./gen -n 500 -m 500 -type pyramidal\n\n# Forced meet at corner small\n./gen -n 10 -m 10 -type forced_meet_corner\n\n# Forced meet at corner large\n./gen -n 1000 -m 1000 -type forced_meet_corner\n\n# Forced meet at center small\n./gen -n 10 -m 10 -type forced_meet_center\n\n# Forced meet at center large\n./gen -n 1000 -m 1000 -type forced_meet_center\n\n# Long paths small\n./gen -n 10 -m 10 -type long_paths\n\n# Long paths large\n./gen -n 1000 -m 1000 -type long_paths\n\n# Max single cell small\n./gen -n 10 -m 10 -type max_single_cell\n\n# Max single cell large\n./gen -n 1000 -m 1000 -type max_single_cell\n\n# Random grid with n != m\n./gen -n 1000 -m 500 -type random\n\n# Random grid with minimal n and maximal m\n./gen -n 3 -m 1000 -type random\n\n# Random grid with maximal n and minimal m\n./gen -n 1000 -m 3 -type random\n\n# Grid full of ones medium size\n./gen -n 500 -m 500 -type ones\n\n# Grid full of max values medium size\n./gen -n 500 -m 500 -type max\n\n# Grid full of zeros large size\n./gen -n 1000 -m 1000 -type zeros\n\n# Edge case where n = m = 3\n./gen -n 3 -m 3 -type random\n\n# Edge case with minimal grid size and max single cell\n./gen -n 3 -m 3 -type max_single_cell\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:58.006248",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "430/E",
      "title": "E. Guess the Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains integer n (1 ≤ n ≤ 24). Next line contains n positive integers: the i-th number represents ci (1 ≤ ci ≤ n).",
      "output_spec": "OutputOutput on the first line \"YES\" (without quotes) if there exist at least one tree following Iahub's restrictions, otherwise output \"NO\" (without quotes).",
      "sample_tests": "ExamplesInputCopy41 1 1 4OutputCopyYESInputCopy51 1 5 2 1OutputCopyNO",
      "description": "E. Guess the Tree\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of the input contains integer n (1 ≤ n ≤ 24). Next line contains n positive integers: the i-th number represents ci (1 ≤ ci ≤ n).\n\nOutputOutput on the first line \"YES\" (without quotes) if there exist at least one tree following Iahub's restrictions, otherwise output \"NO\" (without quotes).\n\nInputCopy41 1 1 4OutputCopyYESInputCopy51 1 5 2 1OutputCopyNO\n\nInputCopy41 1 1 4\n\nOutputCopyYES\n\nInputCopy51 1 5 2 1\n\nOutputCopyNO",
      "solutions": [
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 - Codeforces",
          "content": "Hello everyone! We invite you to participate in Codeforces Round #245, scheduled for Sunday, 11th May at 7:30 MSK. This is the fourth round I write for Codeforces. After the last round your upvotes helped me get into the Contributors Top 10. Thanks for all your good remarks; I'll try and do my best in order for this round to be at least as good as the previous one. This round is prepared by my friend Ioan Petcu (author of D1 E) and I (all problems, except D1 E). We've chosen the problems to be as diverse as possible — no two problems will share the same programming technique. As the problems are varied, we hope you'll find at least one problem of your taste. The main character is Iahub, currently the number one ranked contestant in the Romanian selection camps for IOI. After reading the problem statements, you'll see what the life of a very good Romanian competitive programmer is like (just kidding, it's just my evil imagination).This round wouldn't have been possible without the people that helped me test it: Gerald Agapov (Gerald), Damian Straszak (DamianS), Dan Alexandru (DanAlex) and Vlad Badelita (vladb). As always, we’d like to thank Mike Mirzayanov for creating the Polygon system and Codeforces plaftorm and to Delinur for translating the problems in Russian. We wish high ratings to everyone and, above all, have fun!UPD Score DistributionDivision 1: 500 1000 1500 2000 2000Division 2: 500 1000 1500 2000 2500I apologize for all technical issues during the round, from the ambiguous problem statements to very easy problem D1 D. In my trial to invent a nice task, I didn't see that straight forward solution for it and I have no excuse for this. UPD WinnersDivision 1: SergeyRogulenko scott_wu vepifanov YuukaKazami ballon Division 2: clavichord93 krmunn481 Dgleich PopovkinAndrey roben_76 UPD EditorialUPD Statistics",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12254",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1844
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces",
          "content": "430A - Точки и отрезки (легкая версия)The problem asks you to output “-1” if there is no solution. A natural question is now: “when there is no solution”? Try to come up with a test like this! After some analysis, you’ll see anyhow we draw the points and the lines, there will always be a solution. By manually solving small cases, you might already have found the pattern. But for now, let’s assume anyhow we draw points and lines, there will always be a solution. Let’s have a fixed set of points. Then, anyhow we draw a line, there should still be a solution. So, we need to find a coloring of points, such as for every line, |number of red points which belong to it – number of blue points which belong to it| <= 1.Suppose anytime you color a point with red you assign it +1 value. Also, anytime you color it with blue you assign it -1 value. Then, for a segment, the drawing is good if S = sum of values assigned to points that belong to segment is between -1 and 1 (in other words |S| <= 1). Let’s sort points increasing by abscissa. It’s useful because now, for a segment, there will be a contiguous range of points that belong to that segment. For example, suppose my current segment is [3, 7] and the initial set of points was {4, 1, 5, 2, 8, 7}. Initially, points that belong to the segment would be first, third and sixth. Let’s sort the points by abscissa. It looks like {1, 2, 4, 5, 7, 8}. You can see now there is a contiguous range of points that belongs to [3, 7] segment: more exactly third, fourth and fifth.We reduced problem to: given an array, assign it either +1 or -1 values such as, for each subarray (contiguous range), the sum S of subarray’s elements follows the condition |S| <= 1. Before reading on, try to come up with an example by yourself.My solution uses the pattern: +1 -1 +1 -1 +1 -1 ... Each subarray of it will have sum of its elements either -1, 0 or 1. How to proof it? When dealing with sums of subarrays, a good idea is to use partial sums. Denote sum[i] = x[1] + x[2] + ... + x[i]. Then, sum of a subarray [x, y] is sum[y] – sum[x – 1]. Partial sums for the pattern looks like: 1 0 1 0 1 0 .... Hence, there are 4 possible cases:1/ sum[x – 1] = 0 and sum[y] = 0. sum[y] – sum[x – 1] = 02/ sum[x – 1] = 1 and sum[y] = 1. sum[y] – sum[x – 1] = 0 3/ sum[x – 1] = 0 and sum[y] = 1. sum[y] – sum[x – 1] = 14/ sum[x – 1] = 1 and sum[y] = 0. sum[y] – sum[x – 1] = -1Hence, each subarray sum is either -1, 0 or 1. So, general algorithm looks like: sort points by abscissa, assign them red, blue, red, blue, ... and then sort them back by original order and print the colors.430B - Игра с шарамиThis is an implementation problem. There is not so much to explain. Perhaps the trick at implementation problems is to divide code into smaller subproblems, easy to code and then put them together. I don’t know if this is the universally truth, but this is how I approach them. Here, there are two main parts: the part when you insert a ball between 2 balls and the part when you see how many balls are destroyed after the move. We can keep an array a[] with initial configuration of balls, then for each insertion create an array b[] with current configuration after the insertion. If my ball is inserted after position pos, b is something like this: b = a[1....pos] + {my_ball} + a[pos+1....n].For now we have array b[] and we need to know how many balls will disappear. The problem statement gives us an important clue: no 3 balls will initially have the same color. This means, any time, at most one contiguous range of balls of same color will exist with length at least 3. If it exists, we have to remove it. Then, we have to repeat this process. So algorithm is something like bubble sort: while b[] array has changed last step, continue algorithm, otherwise exit it. Now, search an i for which b[i] = b[i + 1] = b[i + 2]. Then, take the maximum j > i for which b[k] = b[i], with i < k <= j. You have to remove from b[] the subarray [i...j] and add j – i + 1 to the destroyed balls. You’ll need to return this sum – 1, because the ball you added wasn’t there at beginning. Pay attention on case when you can’t destroy anything, you need to output 0 instead of -1. There are O(n) positions where you can insert the new ball, for each of them there are maximal O(n) steps when balls are deleted and deleting balls takes maximal O(n) time, so overall complexity is O(n ^ 3). Note: in my solution, I don’t actually do deletion. If I have to delete a range [i, j] I create a new array c[] = b[1...i – 1] + b[j+1....n] and then copy c[] into b[] array. This guarantees O(n) time for deletion.429A - Дерево XORThere is something to learn from “propagating tree” problem, used in round #225. It’s how the special operation works. I’ll copy paste the explanation from there (with some modification, corresponding to the problem):Let’s define level of a node the number of edges in the path from root to the node. Root (node 1) is at level 0, sons of root are at level 1, sons of sons of root are at level 2 and so on. Now suppose you want to do a special operation to a node x. What nodes from subtree of x will be flipped? Obviously, x will be first, being located at level L. Sons of x, located at level L + 1 will not be flipped. Sons of sons, located at level L + 2, will be flipped again. So, nodes from subtree of x located at levels L, L + 2, L + 4, ... will be flipped, and nodes located at levels L + 1, L + 3, L + 5 won’t be flipped. Let’s take those values of L modulo 2. All nodes having remainder L modulo 2 will be flipped, and nodes having reminder (L + 1) modulo 2 will not. In other words, for a fixed x, at a level L, let y a node from subtree of x, at level L2. If L and L2 have same parity, y will be flipped, otherwise it won’t. We’ll use this fact later. For now, let’s think what should be our first operation. Let’s consider some nodes {x1, x2, ..., xk} with property that x1 is son of x2, x2 is son of x3, ... xk-1 is son of xk and parity of levels of these nodes is the same. Suppose by now we fixed {x1, x2, ..., xk-1} (their current value is equal to their goal value), but xk is still not fixed. After some time, we’ll have to fix xk. Now, by doing this, all nodes {x1, x2, ..., xk-1} will get flipped and hence unfixed. We’ve done some useless operations, so our used strategy is not the one that gives minimal number of operations.What we learn from this example? Suppose I want to currently fix a node X. There is no point to fix it now, unless all ancestors Y of X with property level(Y) = level(X) (mod 2) are fixed. But what if an ancestor Y of X is not fixed yet and level(Y) != level(X) (mod 2)? Can I fix node X now? The answer is yes, as future operations done on Y won’t affect X. But, by same logic, I can firstly fix Y and then fix X, because again operations done on Y won’t affect X. We get a nice property: there is no point to make an operation on a node X unless all ancestors of X are fixed. How can we use this property? What should be the first operation? We know that node 1 is the root, hence it always won’t have any ancestor. All other nodes might have sometimes not fixed ancestors, but we know for sure, for beginning, node 1 won’t have any unfixed ancestor (because it won’t have any). So, for beginning we can start with node 1. More, suppose node 1 is unfixed. The only way to fix it is to make an operation on it. Since it’s unfixed and this is the only way to fix it, you’ll be obligated to do this operation. This means, in an optimal sequence of operations, you’ll be obligated to do this operation, too. So, if node 1 was unfixed, we did an operation on it. If it was already fixed, we’re done with it. What are next nodes we know for sure that will have all ancestors fixed? Sons of 1, because they have only one ancestor (node 1), which we know it’s fixed. We can only fix them by doing operations of them (doing operations on node 1 / sons of them won’t affect them). Since eventually they have to be fixed and only way to be fixed is to do an operation on them, in an optimal sequence of operations, we’ll have to make operations on them. Let’s move on. What are next nodes that we know for sure all ancestors of them will be fixed? Sons of sons of 1. We can fix them by doing an operation of them, or by doing an operation on 1. But doing an operation on 1 isn’t helpful, because even if it fixes this node, it unfixes 1. Then, you’ll have to do one more operation on 1, which will unfix current node, so we do two useless operations. It turns out, the only way to fix them is to do an operation on them.Generally, suppose all ancestors of node x are fixed. We get the current value of node x after the operations done on ancestors of x. If the current value is not the expected one, we’ll have to do an operation on node x (this is the only way to fix the node x). Now, after node x is fixed, we can process sons of it. This strategy guarantees minimal number of operations, because we do an operation only when we’re forced to do it.This leads immediately to an O(N ^ 2) algorithm, by every time we need to do an operation to update it to nodes from its subtree. How to get O(N)? Suppose we are at node x and want to know its current value after operations done for its ancestors. Obviously, it is defined by initial value. If we know number of operations done so far by even levels for its ancestors, number of operations done so far by odd levels and current level, we can determine the current value. Suppose these values are (initial_value, odd_times, even_times, level). We observe that 2 operations cancel each other, so we can take this number modulo 2. If level mod 2 = 0, then only even_times will matter, and current_value = (initial_value + even_times) % 2. Otherwise, current_value = (initial_value + odd_times) % 2. We can send (even_times, odd_times and level) as DFS parameters, so current_value can be calculated in O(1), and overall complexity is O(N). 429B - ТренировкаThe particularity of this problem which makes it different by other problem of this kind is that paths need to cross exactly one cell and Iahub can go only right and down, Iahubina can go only right and up. Let's try to come up with a solution based on these facts. A good start is to analyze configurations possible for meeting cell. Iahub can come either from right or down and Iahubina can come either from right or up. However, if both Iahub and Iahubina come from right, they must have met in other cell as well before (the cell in the left of the meet one). Similarly, if one comes from up and other one from down, their paths will cross either on upper cell, lower cell or right cell.Only 2 possible cases are: Iahub comes from right, Iahubina comes from up or Iahub comes from down, Iahubina comes from right. By drawing some skatches on paper, you'll see next cell visited after meeting one will have the same direction for both of them. More, they will never meet again. So Iahub comes from right, goes to right, Iahubina comes from up, goes to up or Iahub comes from down, goes to down and Iahubina comes from right, goes to right.In the drawing, Iahub's possible visited cells are blue, Iahubina's possible visited cells are red and meeting cell is purple. Denote (X, Y) meeting cell. For first case, Iahub comes from (1, 1) to (X, Y — 1) by going down or right. Next, he goes from (X, Y + 1) to (N, M) by going down or right. Iahubina goes from (M, 1) to (X + 1, Y) by going up or right and then from (X — 1, Y) to (1, M) by going with same directions. In second case, Iahub goes from (1, 1) to (X — 1, Y) and then from (X + 1, Y) to (N, M) and Iahubina goes from (M, 1) to (X, Y — 1) and then from (X, Y + 1) to (1, M).We can precalculate for dynamic programming matrixes and we're done. dp1[i][j] = maximal cost of a path going from (1, 1) to (i, j) only down and right.dp2[i][j] = maximal cost of a path from (i, j) to (1, m) going only up and right.dp3[i][j] = maximal cost of a path from (m, 1) to (i, j) going only up and right.dp4[i][j] = maximal cost of a path from (i, j) to (n, m) going only down or right.And here is my full implementation of recurrences (C++ only): for (int i = 1; i <= n; ++i)\n for (int j = 1; j <= m; ++j)\n dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n for (int i = 1; i <= n; ++i)\n dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = 1; j <= m; ++j)\n dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n for (int j = m; j >= 1; --j)\n dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);Also, pay attention that meeting points can be cells (i, j) with 1 < i < n and 1 < j < m. (why?)429C - Угадай деревоThe constrain n <= 24 immediately suggest us an exponential solution. 24 numbers seems to be not too big, but also not too small. What if we can reduce it by half? We can do this, by analyzing problem’s restriction more carefully.The problem states that each internal node has at least two sons. After drawing some trees likes these, one may notice there are a lot of leafs in them. For a tree with this property, number of leafs is at least (n + 1) / 2. We’ll proof this affirmation by mathematical induction. For n = 1, affirmation is true. Now, suppose our tree has n nodes, and the root of it has sons {s1, s2, ..., sk}. Let’s assume subtree of s1 has n1 nodes, subtree of s2 has n2 nodes, ..., subtree of sk has nk nodes. By induction we get that s1 has at least (n1 + 1) / 2 leafs, ..., sk has at least (nk + 1) / 2 leafs. Summing up, we get that our tree has at least (n1 + n2 + ... + nk + k) / 2 leafs. But n1 + n2 + ... + nk = n – 1. So it has at least (n + k – 1) / 2 leafs. But, by hypothesis k >= 2, so our tree has at least (n + 1) / 2 leafs. For n = 24, there will be at least 13 leafs, so at most 11 internal nodes. It looks much better now for an exponential solution! Before presenting it, we need one more observation. Suppose we sorted c[] array decreasing. Now, the father of node i can be only one of nodes {1, 2, ..., i – 1}. Nodes {i + 1, i + 2, ..., n} will have at most as much nodes as node i, so they can’t be father of i. By doing this observation we can start algorithm: start with node 1 and assign its sons. Then, move to node 2. If it does not have a father, we won’t have one, so current configuration is good. If he has a father (in this case node 1), then tree is connected so far. So we can assign children of node 2. Generally, if a node i does not have a father when it’s processed, it won’t have in future either. If it has, the tree is connected so far, so we add children of i.Let’s introduce the following dynamic programming. Let dp[node][mask][leafs] = is it possible to create a tree if all nodes {1, 2, ..., node} have already a father, exactly leafs nodes don’t have one and internal nodes corresponding to 1 in bitmask mask also don’t have one? If you never heart about “bitmask” word, this problem is not good for you to start with. I recommend you problem E from round #191, where I explained more how bitmasks work. Back on the problem. If node has 1 in its bit from the mask, then we know for sure the tree can’t be built. Otherwise, let’s assign sons for node. We take all submasks of mask (number obtained by changing some bits from 1 to 0) and make sum of degrees for corresponding nodes. Denote this number as S. These are the internal nodes. How about the leafs? We need to have available L = c[node] – S – 1 leafs. If L is <= than leafs, we can use them. If L < 0, obviously we can’t build the tree. Will remain obviously leafs – L leafs. The new mask will be mask ^ submask. Also, we need to iterate to node + 1. If dp[node+1][mask ^ submask][leafs – L]. One more condition that needs to be considered: node needs to have at least 2 sons. This means L + cnt > 1 (where cnt are number of internal nodes used). When do we stop the dp? When c[nod] = 1. If mask = 0 and leafs = 0, then we can build the tree. Otherwise, we can’t. Let’s analyze the complexity. There are O(2 ^ (n / 2)) masks, each of them has O(n) leafs, for each O(n) node. This gives O(2 ^ (n / 2) * n ^ 2) states. Apparently, iterating over all submasks gives O(2 ^ (n / 2)) time for each submask, so overall complexity should be O(4 ^ (n / 2) * n ^ 2). But this complexity is over rated. Taking all submasks for all masks takes O(3 ^ (n / 2)) time, instead of O(4 ^ (n / 2)) time. Why? Consider numbers written in base 3: for a mask and a submask we can assign 3 ternary digits to each bit:0 if bit does not appear in mask1 if bit appears in mask but not in submask2 if bit appears in mask and in submaskObviously, there are O(3 ^ (n / 2)) numbers like this and the two problems are equivalent, so this step takes O(3 ^ (n / 2)) and overall complexity is O(3 ^ (n / 2) * n ^ 2). 429D - Хитрая функцияLet’s define S[i] = a[1] + a[2] + ... + a[i]. Then, f(i, j) = (i – j) ^ 2 + (S[i] – S[j]) ^ 2. Trying to minimize this function seems complicated, so we need to manipulate the formula more. We know from the maths that if f(i, j) is minimized, then also f’(i, j) = sqrt ( (i – j) ^ 2 + (S[i] – S[j]) ^ 2) is also minimized. Does this function look familiar to you? Suppose you get two points in 2D plane: one having coordinates (i, S[i]) and the other one having coordinates (j, S[j]). One can see that f’(i, j) is exactly euclidean distance of those points. So, if f’(i, j) is a distance between two points in plane, when is achieved minimal f’(i, j)? For the closest two points in plane (the points which are located at minimal distance). So, having set of points (i, S[i]), we need to compute closest two points from this plane. There is a classical algorithm that does this in O(n * logn). 429E - Точки и отрезкиThe problem asks you to check the property for an infinity of points. Obviously, we can’t do that. However, we can observe that some contiguous ranges on OX axis have the same rx and bx values. Like a sweep line algorithm, a possible change may appear only when a new segment begins or when an old one ends. So let’s consider set of points formed by all li reunited with set of points formed by all ri. Sort the values increasing. Suppose the set looks like {x1, x2, ..., xk}. Then ranges [0, x1) [x1, x2) ... [xk-1, xk) [xk, infinity) are the only ones that need to be considered. If we can take an arbitrary point from each range and the property is respected for all points, then the drawing is good. We need to color segments. But each segment is a reunion of ranges like the ones from above. When you color a segment, all ranges from it will be colored too. So, after coloring the segments, for each range, |number of times range was colored with blue – number of times range was colored with red| <= 1.It’s time to think creative. We can see ranges as vertexes of a graph and segments as edges. For example, if a segment is formed by ranges {Xi, Xi+1, ..., Xj-1, Xj} we add an undirected edge from i to j + 1. We need to color the edges. We divide the graph into connected components and apply same logic for each component. Next, by graph I’ll refer to a connected graph.Let’s assume that our graph has all degrees even. Then, it admits an eulerian cycle. Suppose {x1, x2, ..., xk} is the list of nodes from the cycle, such as x1-x2 x2-x3 ... xk-x1 are the edges of it, in this order. We apply a rule: if xi < xi+1, we color edge between xi and xi+1 in red. Otherwise, we color it in blue. What happens for a node? Whenever a “red” edge crosses it (for example edge 1-5 crosses node 4) a “blue” edge will always exist to cross it again (for example edge 6-2 crosses node 4). This is because of property of euler cycle: suppose we started from a node x and gone in “left”. We need to return to it, but the only way to do it is an edge which goes to “right”. So, when degrees of graph are all even, for every point on OX axis, difference between rx and bx will be always 0.Let’s solve the general case now. Some nodes have odd degree. But there will always be an even number of nodes with odd degrees. Why? Suppose the property is respected for some edges added so far and now we add a new one. There are two cases: 1/ the edge connects two nodes with odd degree. in this case, the number of nodes with odd degrees decreases by 2, but its parity does not change.2/ the edge connects one node with odd degree and one node with even degree. Now, degree of “old” odd one becomes even and degree of “old” even one becomes odd. So number of nodes with odd degrees does not change.So suppose the nodes with odd degrees are X1 X2 ... Xk (k is even). Assume X1 < X2 < ... < Xk. If we add one more edge to each of these nodes, an euler cycle would be possible. However, we can’t “add” edges, because edges are segments from the input. But we can imagine them. Of course, this we’ll create an imbalance between red and blue edges, but let’s see how big it is. What if we add a fictive edge between X1 to X2, between X3 to X4, ..., between X(k – 1) to Xk? In this way, all those nodes will have even degree. So for each Xi (i odd) we add a dummy vertex Yi and some dummy edges from Xi to Yi and from Yi to Xi+1. Now let’s see the effect: if the fictive edges existed, the balance would be 0. But they do not exist, so one of rx or bx will decrease. So now |rx – bx| <= 1, good enough for problem’s restrictions.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12265",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 430 和字母"
          },
          "content_length": 21404
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 1",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 2",
          "code": "5 1\n3 1 2\n2 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 3",
          "code": "currentPoint.y - bestAnswer < y < currentPoint.y + bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 - Codeforces - Code 4",
          "code": "x < currentPoint.x - bestAnswer",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12254",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 1",
          "code": "for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= m; ++j)\n        dp1[i][j] = a[i][j] + max(dp1[i - 1][j], dp1[i][j - 1]);\nfor (int j = m; j >= 1; --j)\n    for (int i = 1; i <= n; ++i)\n        dp2[i][j] = a[i][j] + max(dp2[i - 1][j], dp2[i][j + 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = 1; j <= m; ++j)\n        dp3[i][j] = a[i][j] + max(dp3[i + 1][j], dp3[i][j - 1]);\nfor (int i = n; i >= 1; --i)\n    for (int j = m; j >= 1; --j)\n        dp4[i][j] = a[i][j] + max(dp4[i][j + 1], dp4[i + 1][j]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 2",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 3",
          "code": "12\n12 7 4 3 3 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 4",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 5",
          "code": "struct point\n{\n\tll x, y;\n}p[maxn];\n\nint cmpx(const point &a, const point &b)\n{\n\treturn a.x < b.x || (a.x == b.x && a.y < b.y);\n}\n\nint cmpy(const point &a, const point &b)\n{\n\treturn a.y < b.y || (a.y == b.y && a.y < b.y);\n}\n\nll Dist(point a, point b)\n{\n\treturn pow(a.x - b.x, 2) + pow(a.y - b.y, 2);\n}\n\nint n;\nll t;\nint main()\n{\n\tru(n);\n\tll s = 0;\n\tRP(i, 1, n)\n\t{\n\t\tru(t);\n\t\ts += t;\n\t\tp[i].x = i;\n\t\tp[i].y = s;\n\t}\n\t\n\tll ans = LINF;\n\tsort(p + 1, p + n + 1, cmpx);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tsort(p + 1, p + n + 1, cmpy);\n\tRP(i, 2, n) upmin(ans, Dist(p[i], p[i - 1]));\n\tcout << ans;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 6",
          "code": "0 1 1 2 0 3 3 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #245 — Editorial - Codeforces - Code 7",
          "code": "0 1 5 2 4 3 7 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12265",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n    vector<int> ci = inf.readInts(n, 1, n, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n    vector<int> ci = inf.readInts(n, 1, n, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 24, \"n\");\n    inf.readEoln();\n    vector<int> ci = inf.readInts(n, 1, n, \"ci\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    vector<int> c(n);\n\n    if (type == \"ones\") {\n        /* All counts ci = 1 */\n        for(int i = 0; i < n; ++i) \n            c[i] = 1;\n    } else if (type == \"max\") {\n        /* One node with ci = n, others with ci = 1 */\n        c[0] = n;\n        for(int i = 1; i < n; ++i)\n            c[i] = 1;\n        shuffle(c.begin(), c.end());\n    } else if (type == \"increasing\") {\n        /* Counts ci in increasing order from 1 to n (capped at n) */\n        int val = 1;\n        for(int i = 0; i < n; ++i)\n            c[i] = min(val++, n);\n    } else if (type == \"decreasing\") {\n        /* Counts ci in decreasing order from n to 1 */\n        int val = n;\n        for(int i = 0; i < n; ++i)\n            c[i] = val--;\n    } else if (type == \"random\") {\n        /* Random counts ci between 1 and n */\n        for(int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, n);\n    } else if (type == \"invalid\") {\n        /* Counts ci that likely make the tree invalid */\n        /* For example, set all counts to n */\n        for(int i = 0; i < n; ++i)\n            c[i] = n;\n    } else if (type == \"random_invalid\") {\n        /* Random counts ci likely to make the tree invalid */\n        for(int i = 0; i < n; ++i)\n            c[i] = rnd.next(n/2 + 1, n);\n    } else {\n        /* Default to random counts */\n        for(int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, n);\n    }\n\n    /* Output counts ci */\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], (i==n-1)?'\\n':' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    vector<int> c(n);\n\n    if (type == \"ones\") {\n        /* All counts ci = 1 */\n        for(int i = 0; i < n; ++i) \n            c[i] = 1;\n    } else if (type == \"max\") {\n        /* One node with ci = n, others with ci = 1 */\n        c[0] = n;\n        for(int i = 1; i < n; ++i)\n            c[i] = 1;\n        shuffle(c.begin(), c.end());\n    } else if (type == \"increasing\") {\n        /* Counts ci in increasing order from 1 to n (capped at n) */\n        int val = 1;\n        for(int i = 0; i < n; ++i)\n            c[i] = min(val++, n);\n    } else if (type == \"decreasing\") {\n        /* Counts ci in decreasing order from n to 1 */\n        int val = n;\n        for(int i = 0; i < n; ++i)\n            c[i] = val--;\n    } else if (type == \"random\") {\n        /* Random counts ci between 1 and n */\n        for(int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, n);\n    } else if (type == \"invalid\") {\n        /* Counts ci that likely make the tree invalid */\n        /* For example, set all counts to n */\n        for(int i = 0; i < n; ++i)\n            c[i] = n;\n    } else if (type == \"random_invalid\") {\n        /* Random counts ci likely to make the tree invalid */\n        for(int i = 0; i < n; ++i)\n            c[i] = rnd.next(n/2 + 1, n);\n    } else {\n        /* Default to random counts */\n        for(int i = 0; i < n; ++i)\n            c[i] = rnd.next(1, n);\n    }\n\n    /* Output counts ci */\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", c[i], (i==n-1)?'\\n':' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type ones\n./gen -n 1 -type max\n./gen -n 1 -type random\n\n./gen -n 2 -type ones\n./gen -n 2 -type max\n./gen -n 2 -type increasing\n./gen -n 2 -type decreasing\n./gen -n 2 -type random\n./gen -n 2 -type invalid\n\n./gen -n 5 -type ones\n./gen -n 5 -type max\n./gen -n 5 -type increasing\n./gen -n 5 -type decreasing\n./gen -n 5 -type random\n./gen -n 5 -type invalid\n./gen -n 5 -type random_invalid\n\n./gen -n 10 -type ones\n./gen -n 10 -type max\n./gen -n 10 -type increasing\n./gen -n 10 -type decreasing\n./gen -n 10 -type random\n./gen -n 10 -type invalid\n./gen -n 10 -type random_invalid\n\n./gen -n 20 -type ones\n./gen -n 20 -type max\n./gen -n 20 -type increasing\n./gen -n 20 -type decreasing\n./gen -n 20 -type random\n./gen -n 20 -type invalid\n./gen -n 20 -type random_invalid\n\n./gen -n 24 -type ones\n./gen -n 24 -type max\n./gen -n 24 -type increasing\n./gen -n 24 -type decreasing\n./gen -n 24 -type random\n./gen -n 24 -type invalid\n./gen -n 24 -type random_invalid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:26:59.930802",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "431/A",
      "title": "A. Black Square",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four space-separated integers a1, a2, a3, a4 (0 ≤ a1, a2, a3, a4 ≤ 104).The second line contains string s (1 ≤ |s| ≤ 105), where the і-th character of the string equals \"1\", if on the i-th second of the game the square appears on the first strip, \"2\", if it appears on the second strip, \"3\", if it appears on the third strip, \"4\", if it appears on the fourth strip.",
      "output_spec": "OutputPrint a single integer — the total number of calories that Jury wastes.",
      "sample_tests": "ExamplesInputCopy1 2 3 4123214OutputCopy13InputCopy1 5 3 211221OutputCopy13",
      "description": "A. Black Square\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four space-separated integers a1, a2, a3, a4 (0 ≤ a1, a2, a3, a4 ≤ 104).The second line contains string s (1 ≤ |s| ≤ 105), where the і-th character of the string equals \"1\", if on the i-th second of the game the square appears on the first strip, \"2\", if it appears on the second strip, \"3\", if it appears on the third strip, \"4\", if it appears on the fourth strip.\n\nOutputPrint a single integer — the total number of calories that Jury wastes.\n\nInputCopy1 2 3 4123214OutputCopy13InputCopy1 5 3 211221OutputCopy13\n\nInputCopy1 2 3 4123214\n\nOutputCopy13\n\nInputCopy1 5 3 211221\n\nOutputCopy13",
      "solutions": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "Hi everybody!Codeforces round #247 for Div. 2 participants will take place on May 21 at 19:30 MSK. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me(Antoniuk) and Kirill Schetinin(KaiZeR). This is the first round prepared by us and we hope that you will enjoy the round.We want to thank Gerald and Delinur for helping to prepare the round and MikeMirzayanov for Codeforces and Polygon. UPD: Score distribution will be the next — 500-1500-1500-2000-2500.UPD2: The contest is over, we hope you enjoy it)UPD3: Editorial.UPD4: Statistics.Congratulations to winners!1) hzjsxxy 2) azariamuh 3) tonkosi 4) inutard 5) c.u.c.u.m.b.e.rGl & hf)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 689
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "431A - Black SquareTo solve this problem, you must only do the process described in statement. for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...Complexity: O(N) Solution: 6676675431B - Shower LineIn this problem, according to the small limits, we can brute all permutations and choose the best answer of all. The easeast way to do this — use standart C++ function next_permutation, or simply write 5 for. For each permutation we can simulate the process, which was described in a statement, or notice that first with second student, and second with the third will communicate one time, and third with fourth student, and fourth with fifth — will communicate two times. Another pairs of students will never communicate to each other during they stay in queue.Complexity: O(n!) Solution: 6676695431C - k-TreeThis problem can be solved by dinamic programming. Let's Dp[n][is] — number of ways with length equals to n in k-tree, where if is = 1 — there is exists edge with length at least d, is = 0 — lengths of all edges less then d. Initial state Dp[0][0] = 1. Transition — iterate all edges which can be first on the way in k-tree, then problem transform to the same, but with less length of the way (because subtree of vertex son is the k-tree).Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0] Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])See solution for more details.Complexity: O(nk) Notice that this solution can be easy midify to O(N) complexity, only precalc partial sums. But it is not neccesary to solve this problem in such way. Solution: 6676700431D - Random TaskWe will search n by binary search. Such function is monotone, because the amount of numbers with exactly k 1-bits on a segment n + 2 ... 2·(n + 1) more or equal than amount of such numbers on segment n + 1 ... 2·n. Last statement is correct, because of n + 1 and 2·(n + 1) have equals number of 1-bits. To find the amount of numbers on segment L...R, which have exactly k 1-bits, it is sufficient to can calculate this number for segment 1...L, then the answer will be F(1...R) - F(1..L - 1). Let's understand how we can calculate F(1...X). Iterate number of bit will be the first(from biggest to smallest) which is different in X and numbers, which amount we want to calculate. Let the first difference will be in i-th bit(it's possible, if in X this bit equals to 1, because we consider all numbers do not exceed X). Then other smallest bits we can choose in any way, but only amount of 1-bits must equals to k. We can do this in Cik - cnt ways, where cnt — the number of 1-bits in X, bigger then i, and Cnk — binomailany factor. Finally, you should not forget about X (if it, of course, has k one bits). long long F( X )\n Ans = 0 , cnt = 0;\n for i = Max_Bit...0\n if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n if (Bit_Counts(X) == K) Ans ++; \n return Ans;Асимптотика: O(log2(Ans)) Решение: 6676713431E - Chemistry ExperimentFirst of all let's understand the statement. We have n tubes. At the beginning of each of them there are a few amount of mercury is poured. We want be able to perform two types of queries: Make the amount of mercury in p- th tube equals to x. Given the number v — the amount of water that must be optimally pour these tubes. What does it mean optimally? That mean we pour water in some of the tubes in the way, when maximum volume of liquid for all tubes, where we poured water, will be as small, as possible. Well, actually now turn to the solution. Use binary search to find an answer, in particular, will sort out the amount of mercury in a tubes(let it equals to d), such that in the tubes with smaller volume of the liquid can be poured all v liters of water and the maximum liquid level does not exceed d. Let the number of tubes, with the amount of mercury less than d is equal t.Now the problem is reduced to learning how to count the total amount of water that we can to pour into each of t least tubes, such that the level of the liquid in each of them is equal d.Let a[i] — the total amount of mercury in the tubes which exactly have i liters mercury and b[i] — number of tubes which the volume of mercury is equal i. Then t = b[0] + ... + b[d - 1] and v1 = t * d - (a[0] + a[1] + ... + a[d - 1]) — the total maximum amount of the water which can be poured. If v1 < v, then obviously this space is not enough for pour all the water, otherwise quite enough and so the answer will be no more than d. When we found the smallest d, we can say that the answer is equal d — (v1 — v) / t. To quickly find for a[0] + a[1] + ... + a[d - 1] and b[0] + ... + b[d - 1], and perform queries of the first type, you can use the Fenwick tree. Асимптотика: O(qlog2(n)) Решение: 6676668",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12369",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 431\\s*A"
          },
          "content_length": 4776
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "scanf(\"%d %d %d %d\\n\",a+1,a+2,a+3,a+4);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "i < 64 ? X >> i : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 5",
          "code": "Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 6",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 7",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 8",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 9",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 10",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 12",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 13",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 14",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 15",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 16",
          "code": "#define N 100005",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 17",
          "code": "0 <= n <= 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 18",
          "code": "Dp[n][0] + Dp[n][1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 19",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 20",
          "code": "Dp[0][1] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 21",
          "code": "Dp[n][0] = Dp[n-1][0] + Dp[n-2][0] + ... + Dp[n-DL][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 22",
          "code": "DL = min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 23",
          "code": "Dp[n][1] = Dp[n-1][1] + Dp[n-2][1] + ... + Dp[n-K][1] +",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 24",
          "code": "+ Dp[n-d][0] + Dp[n-(d+1)][0] + ... + Dp[n-K][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 25",
          "code": "K = min(k,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 26",
          "code": "1 <= m <= min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 27",
          "code": "1 <= m <= d-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> a = inf.readInts(4, 0, 10000, \"a_i\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[1-4]{1,100000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> a = inf.readInts(4, 0, 10000, \"a_i\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[1-4]{1,100000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> a = inf.readInts(4, 0, 10000, \"a_i\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[1-4]{1,100000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <cstdio>\n\n/*\n * FINAL ultra-minimal generator for the \"Black Square\" problem.\n *\n * 1) Clamps n to [1..100000].\n * 2) Prints (a1, a2, a3, a4) via printf (no C++ I/O).\n * 3) Prints each character of the string via fputc (no arrays or buffers).\n * 4) Ends with a newline, then flushes stdout.\n *\n * If a segmentation fault still occurs at large n (e.g., 30000) with zeros cost \n * and random sDist, it is very likely an environment issue (e.g., memory limits).\n */\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Clamp n to [1..100000].\n    int n = opt<int>(\"n\", 10);\n    if (n < 1) n = 1;\n    if (n > 100000) n = 100000;\n\n    // Parse distribution arguments\n    std::string aDist = opt<std::string>(\"aDist\", \"random\");\n    std::string sDist = opt<std::string>(\"sDist\", \"random\");\n\n    // Generate a1..a4\n    int a1, a2, a3, a4;\n    if (aDist == \"zeros\") {\n        a1 = a2 = a3 = a4 = 0;\n    }\n    else if (aDist == \"max\") {\n        a1 = a2 = a3 = a4 = 10000;\n    }\n    else if (aDist == \"mixedSmall\") {\n        a1 = 0;\n        a2 = 5;\n        a3 = 10;\n        a4 = 999;\n    }\n    else if (aDist == \"mixedLarge\") {\n        a1 = 10000;\n        a2 = 5000;\n        a3 = 9999;\n        a4 = 1234;\n    }\n    else {\n        // random in [0..10000]\n        a1 = rnd.next(0, 10000);\n        a2 = rnd.next(0, 10000);\n        a3 = rnd.next(0, 10000);\n        a4 = rnd.next(0, 10000);\n    }\n\n    // Print the four costs\n    printf(\"%d %d %d %d\\n\", a1, a2, a3, a4);\n\n    // Output n characters for the game string\n    if (sDist == \"all1\") {\n        for (int i = 0; i < n; i++) fputc('1', stdout);\n    }\n    else if (sDist == \"all2\") {\n        for (int i = 0; i < n; i++) fputc('2', stdout);\n    }\n    else if (sDist == \"all3\") {\n        for (int i = 0; i < n; i++) fputc('3', stdout);\n    }\n    else if (sDist == \"all4\") {\n        for (int i = 0; i < n; i++) fputc('4', stdout);\n    }\n    else if (sDist == \"pattern\") {\n        // repeat \"1234\"\n        static const char PAT[] = \"1234\";\n        for (int i = 0; i < n; i++) {\n            fputc(PAT[i % 4], stdout);\n        }\n    }\n    else if (sDist == \"mix12\") {\n        for (int i = 0; i < n; i++) {\n            int c = 1 + rnd.next(0,1); // 1 or 2\n            fputc(char('0' + c), stdout);\n        }\n    }\n    else if (sDist == \"mix34\") {\n        for (int i = 0; i < n; i++) {\n            int c = 3 + rnd.next(0,1); // 3 or 4\n            fputc(char('0' + c), stdout);\n        }\n    }\n    else if (sDist == \"incremental\") {\n        for (int i = 0; i < n; i++) {\n            fputc(char('1' + (i % 4)), stdout);\n        }\n    }\n    else {\n        // default or \"random\": digit in [1..4]\n        for (int i = 0; i < n; i++) {\n            int d = rnd.next(1,4);\n            fputc(char('0' + d), stdout);\n        }\n    }\n\n    // End with newline and flush\n    fputc('\\n', stdout);\n    fflush(stdout);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <cstdio>\n\n/*\n * FINAL ultra-minimal generator for the \"Black Square\" problem.\n *\n * 1) Clamps n to [1..100000].\n * 2) Prints (a1, a2, a3, a4) via printf (no C++ I/O).\n * 3) Prints each character of the string via fputc (no arrays or buffers).\n * 4) Ends with a newline, then flushes stdout.\n *\n * If a segmentation fault still occurs at large n (e.g., 30000) with zeros cost \n * and random sDist, it is very likely an environment issue (e.g., memory limits).\n */\n\nint main(int argc, char* argv[])\n{\n    registerGen(argc, argv, 1);\n\n    // Clamp n to [1..100000].\n    int n = opt<int>(\"n\", 10);\n    if (n < 1) n = 1;\n    if (n > 100000) n = 100000;\n\n    // Parse distribution arguments\n    std::string aDist = opt<std::string>(\"aDist\", \"random\");\n    std::string sDist = opt<std::string>(\"sDist\", \"random\");\n\n    // Generate a1..a4\n    int a1, a2, a3, a4;\n    if (aDist == \"zeros\") {\n        a1 = a2 = a3 = a4 = 0;\n    }\n    else if (aDist == \"max\") {\n        a1 = a2 = a3 = a4 = 10000;\n    }\n    else if (aDist == \"mixedSmall\") {\n        a1 = 0;\n        a2 = 5;\n        a3 = 10;\n        a4 = 999;\n    }\n    else if (aDist == \"mixedLarge\") {\n        a1 = 10000;\n        a2 = 5000;\n        a3 = 9999;\n        a4 = 1234;\n    }\n    else {\n        // random in [0..10000]\n        a1 = rnd.next(0, 10000);\n        a2 = rnd.next(0, 10000);\n        a3 = rnd.next(0, 10000);\n        a4 = rnd.next(0, 10000);\n    }\n\n    // Print the four costs\n    printf(\"%d %d %d %d\\n\", a1, a2, a3, a4);\n\n    // Output n characters for the game string\n    if (sDist == \"all1\") {\n        for (int i = 0; i < n; i++) fputc('1', stdout);\n    }\n    else if (sDist == \"all2\") {\n        for (int i = 0; i < n; i++) fputc('2', stdout);\n    }\n    else if (sDist == \"all3\") {\n        for (int i = 0; i < n; i++) fputc('3', stdout);\n    }\n    else if (sDist == \"all4\") {\n        for (int i = 0; i < n; i++) fputc('4', stdout);\n    }\n    else if (sDist == \"pattern\") {\n        // repeat \"1234\"\n        static const char PAT[] = \"1234\";\n        for (int i = 0; i < n; i++) {\n            fputc(PAT[i % 4], stdout);\n        }\n    }\n    else if (sDist == \"mix12\") {\n        for (int i = 0; i < n; i++) {\n            int c = 1 + rnd.next(0,1); // 1 or 2\n            fputc(char('0' + c), stdout);\n        }\n    }\n    else if (sDist == \"mix34\") {\n        for (int i = 0; i < n; i++) {\n            int c = 3 + rnd.next(0,1); // 3 or 4\n            fputc(char('0' + c), stdout);\n        }\n    }\n    else if (sDist == \"incremental\") {\n        for (int i = 0; i < n; i++) {\n            fputc(char('1' + (i % 4)), stdout);\n        }\n    }\n    else {\n        // default or \"random\": digit in [1..4]\n        for (int i = 0; i < n; i++) {\n            int d = rnd.next(1,4);\n            fputc(char('0' + d), stdout);\n        }\n    }\n\n    // End with newline and flush\n    fputc('\\n', stdout);\n    fflush(stdout);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1) n=1, zeros cost, all1\n./gen -n 1 -aDist zeros -sDist all1\n\n# 2) n=5, zeros cost, all4\n./gen -n 5 -aDist zeros -sDist all4\n\n# 3) n=5, max cost, random\n./gen -n 5 -aDist max -sDist random\n\n# 4) n=10, random cost, all1\n./gen -n 10 -aDist random -sDist all1\n\n# 5) n=10, random cost, pattern\n./gen -n 10 -aDist random -sDist pattern\n\n# 6) n=12, mixedSmall cost, random\n./gen -n 12 -aDist mixedSmall -sDist random\n\n# 7) n=12, mixedLarge cost, random\n./gen -n 12 -aDist mixedLarge -sDist random\n\n# 8) n=15, zeros cost, mix12\n./gen -n 15 -aDist zeros -sDist mix12\n\n# 9) n=15, zeros cost, mix34\n./gen -n 15 -aDist zeros -sDist mix34\n\n# 10) n=50, random cost, incremental\n./gen -n 50 -aDist random -sDist incremental\n\n# 11) n=100, mixedSmall cost, all2\n./gen -n 100 -aDist mixedSmall -sDist all2\n\n# 12) n=200, mixedLarge cost, all3\n./gen -n 200 -aDist mixedLarge -sDist all3\n\n# 13) n=500, max cost, pattern\n./gen -n 500 -aDist max -sDist pattern\n\n# 14) n=1000, zeros cost, random\n./gen -n 1000 -aDist zeros -sDist random\n\n# 15) n=2000, random cost, mix12\n./gen -n 2000 -aDist random -sDist mix12\n\n# 16) n=9999, mixedSmall cost, mix34\n./gen -n 9999 -aDist mixedSmall -sDist mix34\n\n# 17) n=15000, mixedLarge cost, incremental\n./gen -n 15000 -aDist mixedLarge -sDist incremental\n\n# 18) n=30000, zeros cost, random\n./gen -n 30000 -aDist zeros -sDist random\n\n# 19) n=50000, random cost, random\n./gen -n 50000 -aDist random -sDist random\n\n# 20) n=100000, max cost, random\n./gen -n 100000 -aDist max -sDist random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:01.875670",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "431/B",
      "title": "B. Очередь в душ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВходные данные состоят из пяти строк, в каждой строке записано пять целых чисел разделенных пробелом: j-е число в i-й строке обозначает gij (0 ≤ gij ≤ 105). Гарантируется, что gii = 0 для всех i.Считайте, что студенты пронумерованы от 1 до 5.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимально возможную суммарную радость студентов.",
      "sample_tests": "ПримерыВходные данныеСкопировать0 0 0 0 90 0 0 0 00 0 0 0 00 0 0 0 07 0 0 0 0Выходные данныеСкопировать32Входные данныеСкопировать0 43 21 18 23 0 21 11 655 2 0 1 454 62 12 0 9987 64 81 33 0Выходные данныеСкопировать620",
      "description": "B. Очередь в душ\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВходные данные состоят из пяти строк, в каждой строке записано пять целых чисел разделенных пробелом: j-е число в i-й строке обозначает gij (0 ≤ gij ≤ 105). Гарантируется, что gii = 0 для всех i.Считайте, что студенты пронумерованы от 1 до 5.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимально возможную суммарную радость студентов.\n\nВыходные данные\n\nВходные данныеСкопировать0 0 0 0 90 0 0 0 00 0 0 0 00 0 0 0 07 0 0 0 0Выходные данныеСкопировать32Входные данныеСкопировать0 43 21 18 23 0 21 11 655 2 0 1 454 62 12 0 9987 64 81 33 0Выходные данныеСкопировать620\n\nВходные данныеСкопировать0 0 0 0 90 0 0 0 00 0 0 0 00 0 0 0 07 0 0 0 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать32\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать0 43 21 18 23 0 21 11 655 2 0 1 454 62 12 0 9987 64 81 33 0\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать620\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере оптимальное расположение очереди 23154. В таком случае суммарная радость равна:(g23 + g32 + g15 + g51) + (g13 + g31 + g54 + g45) + (g15 + g51) + (g54 + g45) = 32.",
      "solutions": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "Всем привет!Совсем скоро, 21 мая в 19:30 MSK, состоится очередной раунд Codeforces #247 для участников Div. 2. Как всегда, участники Div. 1 могут поучаствовать вне конкурса. Подготовкой задач занимались Кирилл Щетинин(KaiZeR) и Вася Антонюк(Antoniuk). Это наш первый раунд на Codeforces и мы надеемся, что задачи вам понравятся. Выражаем свою благодарность Gerald и Delinur за помощь в подготовке раунда и MikeMirzayanov за Codeforces и Polygon. UPD: Распределение баллов по задачам будет таким — 500-1500-1500-2000-2500.UPD2: Соревнование завершилось, спасибо за участие)UPD3: Разбор задач.UPD4: Статистика.Поздравляем победителей!1) hzjsxxy 2) azariamuh 3) tonkosi 4) inutard 5) c.u.c.u.m.b.e.rВсем удачи и высокого рейтинга)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 727
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "431A - Черный квадратВ этой задаче нужно было просто сделать то, что написано в условии. for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...Асимптотика: O(N) Решение: 6676675431B - Очередь в душВ этой задаче, в следствии маленьких ограничений, можно перебрать все перестановки и среди всех перестановок выбрать ту, в которой ответ получается наибольший.Легче всего это было сделать использую стандартную процедуру (для С++) next_permutation либо же просто написал 5 циклов. Для каждой перестановки можно было как промоделировать процесс описанный в условии, так и заметить что первый студент со вторым и второй с третьим будут общаться 1 раз(за все время которое они будут стоять в очереди), а третий с четвертым и четвертый с пятым 2 раза. Остальные пары студентов между собой общаться не будут.Асимптотика: O(n!) Решение: 6676695431C - k-деревоЭта задача может быть решена методом динамического программирования. Пусть Dp[n][is] — количество путей длины n в к-дереве, в котором если is = 1 — есть ребро веса не меньше d, is = 0 — веса всех ребер меньше d. Начальное значение Dp[0][0] = 1. Переход — перебрать ребро из корня которым начинается путь, тогда задача сведется к аналогичной но уже для меньшей длины пути (поскольку поддерево сына вершины абсолютно такое-же к-дерево).Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0] Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])Смотрите решение для уточнения деталей.Асимптотика: O(nk) Заметим что это решение, подсчитав частичные суммы, можно очевидным образом модифицировать до O(n), но этого в задаче не требовалось. Решение: 6676700431D - Случайное заданиеБудем искать n бинарным поиском. Такая функция будет монотонна,поскольку количество чисел с ровно k единичными битами на отрезке n + 2 ... 2·(n + 1) не меньше чем количество таких чисел на отрезке n + 1 ... 2·n. Справедливость предыдущего утверждения следует из того, что n + 1 и 2·(n + 1) имеют одинаковое количество единичных бит. Для нахождения количества чисел на заданном отрезке L...R у которых ровно k единичных бит, нам достаточно научиться считать это количество для отрезков вида 1...L, тогда ответом будет F(1...R) - F(1..L - 1). Поймем как считать F(1...X). Переберем в каком бите(начиная от старших к младшим) число будет отличаться от X. Пусть первое отличие в i-ом бите(только если в X — этот бит единичный, потому что число не может превышать X).Тогда все остальные младшие биты мы можем выбрать как угодно, при условии что общее количество единичных бит будет равно k. Это можно сделать Cik - cnt способами, где cnt — количество единичных бит в числе X с номерами большими i, а Cnk — биномиальный коэффициент. Так же нужно не забыть про само число X (если в нем, конечно, ровно K единичных бит). long long F( X )\n Ans = 0 , cnt = 0;\n for i = Max_Bit...0\n if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n if (Bit_Counts(X) == K) Ans ++; \n return Ans;Асимптотика: O(log2(Ans)) Решение: 6676713431E - Химический экспериментРазберемся сначала в условии. У нас есть n колб. В начале в каждой из них налито определенное количество ртути. Надо уметь выполнять два вида действий: Сделать количество ртути в p-й колбе равным x. Дано число v — это количество воды, которую надо оптимально разлить по этим колбам. Что значит оптимально? Надо в некоторые колбы долить воду так, чтобы среди всех колб, куда мы налили хоть какое-то количество воды, максимальный объем жидкости(вода + ртуть) был как можно меньше. Ну собственно теперь перейдем к решению. Используем бинарный поиск для нахождения ответа, в частности, будем перебирать количество ртути в колбе( пусть оно равно d), такой что в меньшие по объему колбы можно разлить все v литров воды, так, чтобы максимальный уровень жидкости не превысил d. Пусть количество колб объемом ртути, меньшим чем d равно t. Теперь задача свелась к тому, чтобы научиться считать суммарный объем воды который нужно долить в каждую из t наименьших колб, чтобы уровень жидкости в каждой из них стал равен d.Пусть a[i] — суммарный объем ртути в колбах в которых ровно i литров ртути и b[i] — количество колб в которых объем ртути равен i. Тогда t = b[0] + ... + b[d - 1] и v1 = t * d - (a[0] + a[1] + ... + a[d - 1]) — суммарный максимальный объем воды который можно долить. Если v1 < v, то очевидно этого места мало чтобы разлить всю воду, иначе вполне достаточно и значит ответ уже будет не больше d. После того как мы нашли такое наименьшее d, мы можем утверждать что ответ равен d — (v1 — v)/t.Чтобы быстро искать a[0] + a[1] + ... + a[d - 1] и b[0] + ... + b[d - 1], а также выполнять запросы первого типа можно использовать дерево Фенвика.Асимптотика: O(qlog2(n)) Решение: 6676668",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12369",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 431\\s*B"
          },
          "content_length": 4723
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "scanf(\"%d %d %d %d\\n\",a+1,a+2,a+3,a+4);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "i < 64 ? X >> i : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 5",
          "code": "Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 6",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 7",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 8",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 9",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 10",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 12",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 13",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 14",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 15",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 16",
          "code": "#define N 100005",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 17",
          "code": "Dp[n][0] = Dp[n-1][0] + Dp[n-2][0] + ... + Dp[n-DL][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 18",
          "code": "DL = min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 19",
          "code": "Dp[n][1] = Dp[n-1][1] + Dp[n-2][1] + ... + Dp[n-DL][1] +",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 20",
          "code": "+ (Dp[n-d][0] + Dp[n-d][1]) + (Dp[n-(d+1)][0] + Dp[n-(d+1)][1]) + ... + (Dp[n-K][0] + Dp[n-K][1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 21",
          "code": "K = min(k,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 22",
          "code": "Dp[n][1] = Dp[n-1][1] + Dp[n-2][1] + ... + Dp[n-K][1] +",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 23",
          "code": "+ Dp[n-d][0] + Dp[n-(d+1)][0] + ... + Dp[n-K][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 24",
          "code": "0 <= n <= 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 25",
          "code": "Dp[n][0] + Dp[n][1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 26",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 27",
          "code": "Dp[0][1] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 28",
          "code": "Dp[n][0] = Dp[n-1][0] + Dp[n-2][0] + ... + Dp[n-DL][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 29",
          "code": "DL = min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 30",
          "code": "Dp[n][1] = Dp[n-1][1] + Dp[n-2][1] + ... + Dp[n-K][1] +",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 31",
          "code": "+ Dp[n-d][0] + Dp[n-(d+1)][0] + ... + Dp[n-K][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 32",
          "code": "K = min(k,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 33",
          "code": "1 <= m <= min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #247 (Div. 2) - Codeforces - Code 34",
          "code": "1 <= m <= d-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    for (int i = 1; i <= 5; i++) {\n        vector<int> g = inf.readInts(5, 0, 100000);\n        inf.readEoln();\n        for (int j = 0; j < 5; j++) {\n            if (i == j + 1) {\n                ensuref(g[j] == 0, \"g[%d][%d] should be 0\", i, j + 1);\n            }\n        }\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    for (int i = 1; i <= 5; i++) {\n        vector<int> g = inf.readInts(5, 0, 100000);\n        inf.readEoln();\n        for (int j = 0; j < 5; j++) {\n            if (i == j + 1) {\n                ensuref(g[j] == 0, \"g[%d][%d] should be 0\", i, j + 1);\n            }\n        }\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    for (int i = 1; i <= 5; i++) {\n        vector<int> g = inf.readInts(5, 0, 100000);\n        inf.readEoln();\n        for (int j = 0; j < 5; j++) {\n            if (i == j + 1) {\n                ensuref(g[j] == 0, \"g[%d][%d] should be 0\", i, j + 1);\n            }\n        }\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 100000);\n\n    // Generate the 5x5 matrix of gij\n    vector<vector<int>> g(5, vector<int>(5, 0));\n\n    if (type == \"zeros\") {\n        // All gij = 0\n        // Matrix is already initialized with zeros\n    } else if (type == \"ones\") {\n        // All gij = 1\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = 1;\n    } else if (type == \"max\") {\n        // All gij = max_value\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = max_value;\n    } else if (type == \"one_pair\") {\n        // Only gij between students 0 and 1 are non-zero\n        int value = max_value;\n        g[0][1] = value;\n        g[1][0] = value;\n    } else if (type == \"single_high\") {\n        // Only one gij is maximum, others are zero\n        int i = rnd.next(5);\n        int j = rnd.next(5);\n        while(i == j) {\n            j = rnd.next(5);\n        }\n        g[i][j] = max_value;\n    } else if (type == \"some_high\") {\n        // Some gij are high, others are low\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = rnd.next(0, max_value / 2);\n        // Now set some g[i][j] to max_value\n        int num_high = rnd.next(1, 5);  // Random number of high values\n        for(int k = 0; k < num_high; ++k) {\n            int i = rnd.next(5);\n            int j = rnd.next(5);\n            while(i == j) {\n                j = rnd.next(5);\n            }\n            g[i][j] = max_value;\n        }\n    } else if (type == \"all_same\") {\n        // All gij = value\n        int value = rnd.next(0, max_value);\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = value;\n    } else if (type == \"random\") {\n        // Random gij between 0 and max_value\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = rnd.next(0, max_value);\n    } else if (type == \"pattern1\") {\n        // g[i][j] = abs(i - j) * (max_value / 4)\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = abs(i - j) * (max_value / 4);\n    } else if (type == \"pattern2\") {\n        // Alternating high and low values\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = ((i + j) % 2 == 0) ? rnd.next(0, max_value / 10) : rnd.next(9 * max_value / 10, max_value);\n    } else if (type == \"pattern3\") {\n        // Only i < j entries have random values, others are zero\n        for(int i = 0; i < 5; ++i)\n            for(int j = i + 1; j < 5; ++j)\n                g[i][j] = rnd.next(0, max_value);\n    } else {\n        // Default to random\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = rnd.next(0, max_value);\n    }\n\n    // Now output the matrix\n    for(int i = 0; i < 5; ++i) {\n        for(int j = 0; j < 5; ++j) {\n            printf(\"%d\", g[i][j]);\n            if (j != 4)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_value = opt<int>(\"max_value\", 100000);\n\n    // Generate the 5x5 matrix of gij\n    vector<vector<int>> g(5, vector<int>(5, 0));\n\n    if (type == \"zeros\") {\n        // All gij = 0\n        // Matrix is already initialized with zeros\n    } else if (type == \"ones\") {\n        // All gij = 1\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = 1;\n    } else if (type == \"max\") {\n        // All gij = max_value\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = max_value;\n    } else if (type == \"one_pair\") {\n        // Only gij between students 0 and 1 are non-zero\n        int value = max_value;\n        g[0][1] = value;\n        g[1][0] = value;\n    } else if (type == \"single_high\") {\n        // Only one gij is maximum, others are zero\n        int i = rnd.next(5);\n        int j = rnd.next(5);\n        while(i == j) {\n            j = rnd.next(5);\n        }\n        g[i][j] = max_value;\n    } else if (type == \"some_high\") {\n        // Some gij are high, others are low\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = rnd.next(0, max_value / 2);\n        // Now set some g[i][j] to max_value\n        int num_high = rnd.next(1, 5);  // Random number of high values\n        for(int k = 0; k < num_high; ++k) {\n            int i = rnd.next(5);\n            int j = rnd.next(5);\n            while(i == j) {\n                j = rnd.next(5);\n            }\n            g[i][j] = max_value;\n        }\n    } else if (type == \"all_same\") {\n        // All gij = value\n        int value = rnd.next(0, max_value);\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = value;\n    } else if (type == \"random\") {\n        // Random gij between 0 and max_value\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = rnd.next(0, max_value);\n    } else if (type == \"pattern1\") {\n        // g[i][j] = abs(i - j) * (max_value / 4)\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = abs(i - j) * (max_value / 4);\n    } else if (type == \"pattern2\") {\n        // Alternating high and low values\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = ((i + j) % 2 == 0) ? rnd.next(0, max_value / 10) : rnd.next(9 * max_value / 10, max_value);\n    } else if (type == \"pattern3\") {\n        // Only i < j entries have random values, others are zero\n        for(int i = 0; i < 5; ++i)\n            for(int j = i + 1; j < 5; ++j)\n                g[i][j] = rnd.next(0, max_value);\n    } else {\n        // Default to random\n        for(int i = 0; i < 5; ++i)\n            for(int j = 0; j < 5; ++j)\n                if (i != j)\n                    g[i][j] = rnd.next(0, max_value);\n    }\n\n    // Now output the matrix\n    for(int i = 0; i < 5; ++i) {\n        for(int j = 0; j < 5; ++j) {\n            printf(\"%d\", g[i][j]);\n            if (j != 4)\n                printf(\" \");\n            else\n                printf(\"\\n\");\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zeros\n./gen -type ones -max_value 1\n./gen -type max\n\n./gen -type one_pair\n./gen -type single_high\n./gen -type single_high\n./gen -type single_high\n\n./gen -type some_high\n./gen -type some_high\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random -max_value 1\n./gen -type random -max_value 100\n./gen -type random -max_value 1000\n./gen -type random -max_value 5000\n./gen -type random -max_value 10000\n./gen -type random -max_value 50000\n./gen -type random -max_value 99999\n\n./gen -type all_same\n./gen -type all_same -max_value 1\n./gen -type all_same -max_value 50000\n\n./gen -type pattern1\n./gen -type pattern2\n./gen -type pattern3\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:03.586443",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "431/C",
      "title": "C. k-Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains three space-separated integers: n, k and d (1 ≤ n, k ≤ 100; 1 ≤ d ≤ k).",
      "output_spec": "OutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).",
      "sample_tests": "ExamplesInputCopy3 3 2OutputCopy3InputCopy3 3 3OutputCopy1InputCopy4 3 2OutputCopy6InputCopy4 5 2OutputCopy7",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputA single line contains three space-separated integers: n, k and d (1 ≤ n, k ≤ 100; 1 ≤ d ≤ k).\n\nOutputPrint a single integer — the answer to the problem modulo 1000000007 (109 + 7).\n\nInputCopy3 3 2OutputCopy3InputCopy3 3 3OutputCopy1InputCopy4 3 2OutputCopy6InputCopy4 5 2OutputCopy7\n\nInputCopy3 3 2\n\nOutputCopy3\n\nInputCopy3 3 3\n\nOutputCopy1\n\nInputCopy4 3 2\n\nOutputCopy6\n\nInputCopy4 5 2\n\nOutputCopy7",
      "solutions": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "Hi everybody!Codeforces round #247 for Div. 2 participants will take place on May 21 at 19:30 MSK. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me(Antoniuk) and Kirill Schetinin(KaiZeR). This is the first round prepared by us and we hope that you will enjoy the round.We want to thank Gerald and Delinur for helping to prepare the round and MikeMirzayanov for Codeforces and Polygon. UPD: Score distribution will be the next — 500-1500-1500-2000-2500.UPD2: The contest is over, we hope you enjoy it)UPD3: Editorial.UPD4: Statistics.Congratulations to winners!1) hzjsxxy 2) azariamuh 3) tonkosi 4) inutard 5) c.u.c.u.m.b.e.rGl & hf)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 689
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "431A - Black SquareTo solve this problem, you must only do the process described in statement. for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...Complexity: O(N) Solution: 6676675431B - Shower LineIn this problem, according to the small limits, we can brute all permutations and choose the best answer of all. The easeast way to do this — use standart C++ function next_permutation, or simply write 5 for. For each permutation we can simulate the process, which was described in a statement, or notice that first with second student, and second with the third will communicate one time, and third with fourth student, and fourth with fifth — will communicate two times. Another pairs of students will never communicate to each other during they stay in queue.Complexity: O(n!) Solution: 6676695431C - k-TreeThis problem can be solved by dinamic programming. Let's Dp[n][is] — number of ways with length equals to n in k-tree, where if is = 1 — there is exists edge with length at least d, is = 0 — lengths of all edges less then d. Initial state Dp[0][0] = 1. Transition — iterate all edges which can be first on the way in k-tree, then problem transform to the same, but with less length of the way (because subtree of vertex son is the k-tree).Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0] Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])See solution for more details.Complexity: O(nk) Notice that this solution can be easy midify to O(N) complexity, only precalc partial sums. But it is not neccesary to solve this problem in such way. Solution: 6676700431D - Random TaskWe will search n by binary search. Such function is monotone, because the amount of numbers with exactly k 1-bits on a segment n + 2 ... 2·(n + 1) more or equal than amount of such numbers on segment n + 1 ... 2·n. Last statement is correct, because of n + 1 and 2·(n + 1) have equals number of 1-bits. To find the amount of numbers on segment L...R, which have exactly k 1-bits, it is sufficient to can calculate this number for segment 1...L, then the answer will be F(1...R) - F(1..L - 1). Let's understand how we can calculate F(1...X). Iterate number of bit will be the first(from biggest to smallest) which is different in X and numbers, which amount we want to calculate. Let the first difference will be in i-th bit(it's possible, if in X this bit equals to 1, because we consider all numbers do not exceed X). Then other smallest bits we can choose in any way, but only amount of 1-bits must equals to k. We can do this in Cik - cnt ways, where cnt — the number of 1-bits in X, bigger then i, and Cnk — binomailany factor. Finally, you should not forget about X (if it, of course, has k one bits). long long F( X )\n Ans = 0 , cnt = 0;\n for i = Max_Bit...0\n if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n if (Bit_Counts(X) == K) Ans ++; \n return Ans;Асимптотика: O(log2(Ans)) Решение: 6676713431E - Chemistry ExperimentFirst of all let's understand the statement. We have n tubes. At the beginning of each of them there are a few amount of mercury is poured. We want be able to perform two types of queries: Make the amount of mercury in p- th tube equals to x. Given the number v — the amount of water that must be optimally pour these tubes. What does it mean optimally? That mean we pour water in some of the tubes in the way, when maximum volume of liquid for all tubes, where we poured water, will be as small, as possible. Well, actually now turn to the solution. Use binary search to find an answer, in particular, will sort out the amount of mercury in a tubes(let it equals to d), such that in the tubes with smaller volume of the liquid can be poured all v liters of water and the maximum liquid level does not exceed d. Let the number of tubes, with the amount of mercury less than d is equal t.Now the problem is reduced to learning how to count the total amount of water that we can to pour into each of t least tubes, such that the level of the liquid in each of them is equal d.Let a[i] — the total amount of mercury in the tubes which exactly have i liters mercury and b[i] — number of tubes which the volume of mercury is equal i. Then t = b[0] + ... + b[d - 1] and v1 = t * d - (a[0] + a[1] + ... + a[d - 1]) — the total maximum amount of the water which can be poured. If v1 < v, then obviously this space is not enough for pour all the water, otherwise quite enough and so the answer will be no more than d. When we found the smallest d, we can say that the answer is equal d — (v1 — v) / t. To quickly find for a[0] + a[1] + ... + a[d - 1] and b[0] + ... + b[d - 1], and perform queries of the first type, you can use the Fenwick tree. Асимптотика: O(qlog2(n)) Решение: 6676668",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12369",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 431\\s*C"
          },
          "content_length": 4776
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "scanf(\"%d %d %d %d\\n\",a+1,a+2,a+3,a+4);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "i < 64 ? X >> i : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 5",
          "code": "Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 6",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 7",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 8",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 9",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 10",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 12",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 13",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 14",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 15",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 16",
          "code": "#define N 100005",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 17",
          "code": "0 <= n <= 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 18",
          "code": "Dp[n][0] + Dp[n][1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 19",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 20",
          "code": "Dp[0][1] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 21",
          "code": "Dp[n][0] = Dp[n-1][0] + Dp[n-2][0] + ... + Dp[n-DL][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 22",
          "code": "DL = min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 23",
          "code": "Dp[n][1] = Dp[n-1][1] + Dp[n-2][1] + ... + Dp[n-K][1] +",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 24",
          "code": "+ Dp[n-d][0] + Dp[n-(d+1)][0] + ... + Dp[n-K][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 25",
          "code": "K = min(k,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 26",
          "code": "1 <= m <= min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 27",
          "code": "1 <= m <= d-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(1, k, \"d\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(1, k, \"d\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100, \"k\");\n    inf.readSpace();\n    int d = inf.readInt(1, k, \"d\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/*\nThis generator outputs test cases for the problem.\n\nIt accepts parameters:\n- n: the total weight of the paths (1 ≤ n ≤ 100)\n- k: the number of children for each node in the k-tree (1 ≤ k ≤ 100)\n- d: the minimum edge weight that should appear in the path (1 ≤ d ≤ k)\n- type: optional, to specify predefined types of test cases\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    int d = opt<int>(\"d\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") n = 1;\n    else if (type == \"max_n\") n = 100;\n    else if (n == -1) n = rnd.next(1, 100);\n\n    if (type == \"k_equals_1\") k = 1;\n    else if (type == \"max_k\") k = 100;\n    else if (k == -1) k = rnd.next(1, 100);\n\n    if (type == \"d_equals_1\") d = 1;\n    else if (type == \"d_equals_k\") d = k;\n    else if (d == -1) d = rnd.next(1, k);\n\n    // Ensure d <= k\n    if (d > k) d = k;\n\n    // Ensure that constraints are satisfied\n    if (!(1 <= n && n <= 100)) {\n        fprintf(stderr, \"n out of bounds\\n\");\n        return 1;\n    }\n    if (!(1 <= k && k <= 100)) {\n        fprintf(stderr, \"k out of bounds\\n\");\n        return 1;\n    }\n    if (!(1 <= d && d <= k)) {\n        fprintf(stderr, \"d out of bounds\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", n, k, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n/*\nThis generator outputs test cases for the problem.\n\nIt accepts parameters:\n- n: the total weight of the paths (1 ≤ n ≤ 100)\n- k: the number of children for each node in the k-tree (1 ≤ k ≤ 100)\n- d: the minimum edge weight that should appear in the path (1 ≤ d ≤ k)\n- type: optional, to specify predefined types of test cases\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    int d = opt<int>(\"d\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") n = 1;\n    else if (type == \"max_n\") n = 100;\n    else if (n == -1) n = rnd.next(1, 100);\n\n    if (type == \"k_equals_1\") k = 1;\n    else if (type == \"max_k\") k = 100;\n    else if (k == -1) k = rnd.next(1, 100);\n\n    if (type == \"d_equals_1\") d = 1;\n    else if (type == \"d_equals_k\") d = k;\n    else if (d == -1) d = rnd.next(1, k);\n\n    // Ensure d <= k\n    if (d > k) d = k;\n\n    // Ensure that constraints are satisfied\n    if (!(1 <= n && n <= 100)) {\n        fprintf(stderr, \"n out of bounds\\n\");\n        return 1;\n    }\n    if (!(1 <= k && k <= 100)) {\n        fprintf(stderr, \"k out of bounds\\n\");\n        return 1;\n    }\n    if (!(1 <= d && d <= k)) {\n        fprintf(stderr, \"d out of bounds\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d %d\\n\", n, k, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Test case 1: minimum n, k, d\n./gen -n 1 -k 1 -d 1\n\n# Test case 2: maximum n, k, d\n./gen -n 100 -k 100 -d 100\n\n# Test case 3: minimum n, maximum k, minimum d\n./gen -type min_n -k 100 -d 1\n\n# Test case 4: maximum n, minimum k, minimum d\n./gen -n 100 -type k_equals_1 -d 1\n\n# Test case 5: random n, k = 100, d = 1\n./gen -k 100 -d 1\n\n# Test case 6: random n, k = 1, d = 1\n./gen -k 1 -d 1\n\n# Test case 7: random n, random k, d = 1\n./gen -d 1\n\n# Test case 8: random n, k = 100, d = k\n./gen -k 100 -type d_equals_k\n\n# Test case 9: n = 100, k = 100, d = 1\n./gen -n 100 -k 100 -d 1\n\n# Test case 10: n = 100, k = 1, d = 1\n./gen -n 100 -k 1 -d 1\n\n# Test case 11: n = 50, k = 100, d = 50\n./gen -n 50 -k 100 -d 50\n\n# Test case 12: n = 25, k = 50, d = 25\n./gen -n 25 -k 50 -d 25\n\n# Test case 13: random n, random k, random d\n./gen\n\n# Test case 14: n = 1, random k, random d\n./gen -n 1\n\n# Test case 15: n = 100, random k, random d\n./gen -n 100\n\n# Test case 16: random n, k = 1, random d\n./gen -k 1\n\n# Test case 17: random n, k = 100, random d\n./gen -k 100\n\n# Test case 18: random n, random k, d = 1\n./gen -d 1\n\n# Test case 19: random n, random k, d = k\n./gen -type d_equals_k\n\n# Test case 20: n = 100, k = 50, d = 25\n./gen -n 100 -k 50 -d 25\n\n# Test case 21: n = 75, k = 75, d = 50\n./gen -n 75 -k 75 -d 50\n\n# Test case 22: n = random, k = random, d = random\n./gen\n\n# Test case 23: n = 99, k = 99, d = 99\n./gen -n 99 -k 99 -d 99\n\n# Test case 24: n = 1, k = 100, d = 100\n./gen -n 1 -k 100 -d 100\n\n# Test case 25: n = 2, k = 2, d = 2\n./gen -n 2 -k 2 -d 2\n\n# Test case 26: n = 100, k = 100, d = 50\n./gen -n 100 -k 100 -d 50\n\n# Test case 27: n = 100, k = 50, d = 1\n./gen -n 100 -k 50 -d 1\n\n# Test case 28: n = 1, k = 50, d = 50\n./gen -n 1 -k 50 -d 50\n\n# Test case 29: n = 100, k = 1, d = 1\n./gen -n 100 -k 1 -d 1\n\n# Test case 30: n = 100, k = 100, d = 1\n./gen -n 100 -k 100 -d 1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:06.166365",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "431/D",
      "title": "D. Random Task",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space-separated integers, m and k (0 ≤ m ≤ 1018; 1 ≤ k ≤ 64).",
      "output_spec": "OutputPrint the required number n (1 ≤ n ≤ 1018). If there are multiple answers, print any of them.",
      "sample_tests": "ExamplesInputCopy1 1OutputCopy1InputCopy3 2OutputCopy5",
      "description": "D. Random Task\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space-separated integers, m and k (0 ≤ m ≤ 1018; 1 ≤ k ≤ 64).\n\nOutputPrint the required number n (1 ≤ n ≤ 1018). If there are multiple answers, print any of them.\n\nInputCopy1 1OutputCopy1InputCopy3 2OutputCopy5\n\nInputCopy1 1\n\nOutputCopy1\n\nInputCopy3 2\n\nOutputCopy5",
      "solutions": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "Hi everybody!Codeforces round #247 for Div. 2 participants will take place on May 21 at 19:30 MSK. Traditionally, Div. 1 participants can take part out of the competition.Problems have been prepared by me(Antoniuk) and Kirill Schetinin(KaiZeR). This is the first round prepared by us and we hope that you will enjoy the round.We want to thank Gerald and Delinur for helping to prepare the round and MikeMirzayanov for Codeforces and Polygon. UPD: Score distribution will be the next — 500-1500-1500-2000-2500.UPD2: The contest is over, we hope you enjoy it)UPD3: Editorial.UPD4: Statistics.Congratulations to winners!1) hzjsxxy 2) azariamuh 3) tonkosi 4) inutard 5) c.u.c.u.m.b.e.rGl & hf)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12353",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 689
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces",
          "content": "431A - Black SquareTo solve this problem, you must only do the process described in statement. for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...Complexity: O(N) Solution: 6676675431B - Shower LineIn this problem, according to the small limits, we can brute all permutations and choose the best answer of all. The easeast way to do this — use standart C++ function next_permutation, or simply write 5 for. For each permutation we can simulate the process, which was described in a statement, or notice that first with second student, and second with the third will communicate one time, and third with fourth student, and fourth with fifth — will communicate two times. Another pairs of students will never communicate to each other during they stay in queue.Complexity: O(n!) Solution: 6676695431C - k-TreeThis problem can be solved by dinamic programming. Let's Dp[n][is] — number of ways with length equals to n in k-tree, where if is = 1 — there is exists edge with length at least d, is = 0 — lengths of all edges less then d. Initial state Dp[0][0] = 1. Transition — iterate all edges which can be first on the way in k-tree, then problem transform to the same, but with less length of the way (because subtree of vertex son is the k-tree).Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0] Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])See solution for more details.Complexity: O(nk) Notice that this solution can be easy midify to O(N) complexity, only precalc partial sums. But it is not neccesary to solve this problem in such way. Solution: 6676700431D - Random TaskWe will search n by binary search. Such function is monotone, because the amount of numbers with exactly k 1-bits on a segment n + 2 ... 2·(n + 1) more or equal than amount of such numbers on segment n + 1 ... 2·n. Last statement is correct, because of n + 1 and 2·(n + 1) have equals number of 1-bits. To find the amount of numbers on segment L...R, which have exactly k 1-bits, it is sufficient to can calculate this number for segment 1...L, then the answer will be F(1...R) - F(1..L - 1). Let's understand how we can calculate F(1...X). Iterate number of bit will be the first(from biggest to smallest) which is different in X and numbers, which amount we want to calculate. Let the first difference will be in i-th bit(it's possible, if in X this bit equals to 1, because we consider all numbers do not exceed X). Then other smallest bits we can choose in any way, but only amount of 1-bits must equals to k. We can do this in Cik - cnt ways, where cnt — the number of 1-bits in X, bigger then i, and Cnk — binomailany factor. Finally, you should not forget about X (if it, of course, has k one bits). long long F( X )\n Ans = 0 , cnt = 0;\n for i = Max_Bit...0\n if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n if (Bit_Counts(X) == K) Ans ++; \n return Ans;Асимптотика: O(log2(Ans)) Решение: 6676713431E - Chemistry ExperimentFirst of all let's understand the statement. We have n tubes. At the beginning of each of them there are a few amount of mercury is poured. We want be able to perform two types of queries: Make the amount of mercury in p- th tube equals to x. Given the number v — the amount of water that must be optimally pour these tubes. What does it mean optimally? That mean we pour water in some of the tubes in the way, when maximum volume of liquid for all tubes, where we poured water, will be as small, as possible. Well, actually now turn to the solution. Use binary search to find an answer, in particular, will sort out the amount of mercury in a tubes(let it equals to d), such that in the tubes with smaller volume of the liquid can be poured all v liters of water and the maximum liquid level does not exceed d. Let the number of tubes, with the amount of mercury less than d is equal t.Now the problem is reduced to learning how to count the total amount of water that we can to pour into each of t least tubes, such that the level of the liquid in each of them is equal d.Let a[i] — the total amount of mercury in the tubes which exactly have i liters mercury and b[i] — number of tubes which the volume of mercury is equal i. Then t = b[0] + ... + b[d - 1] and v1 = t * d - (a[0] + a[1] + ... + a[d - 1]) — the total maximum amount of the water which can be poured. If v1 < v, then obviously this space is not enough for pour all the water, otherwise quite enough and so the answer will be no more than d. When we found the smallest d, we can say that the answer is equal d — (v1 — v) / t. To quickly find for a[0] + a[1] + ... + a[d - 1] and b[0] + ... + b[d - 1], and perform queries of the first type, you can use the Fenwick tree. Асимптотика: O(qlog2(n)) Решение: 6676668",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12369",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 431\\s*D"
          },
          "content_length": 4776
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "REP(i,strlen(s)){\n     kq+=a[s[i]-'0'];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "scanf(\"%d %d %d %d\\n\",a+1,a+2,a+3,a+4);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "i < 64 ? X >> i : 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12353",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 1",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 2",
          "code": "for i = 1 .. s.size()\n if (s[i] = '1') ans += a[1];\n else ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 3",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 4",
          "code": "Dp[n][0] = Dp[n-1][0] + ... + Dp[n-min(d-1,n)][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 5",
          "code": "Dp[n][1] = Dp[n-1][1] + ... + Dp[n-min(d-1,n)][1] + (Dp[n-d][0] + Dp[n-d][1]) + ... + (Dp[n-min(n,k)][0] + Dp[n-min(n,k)][1])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 6",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 7",
          "code": "long long F( X )\n   Ans = 0 , cnt = 0;\n   for i = Max_Bit...0\n      if (bit(X,i) == 1) Ans += C[i][K - cnt] , cnt ++;\n   if (Bit_Counts(X) == K) Ans ++;   \n   return Ans;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 8",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 9",
          "code": "for(int i=1; i<=n; i++)\n        for(int j=i-1; j>= i-k && j>=0; j--)\n            dp[i]+=dp[j];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 10",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 11",
          "code": "for(int i=1; i<=n; i++)\n    {\n        for(int j=i-1; j>= i-d+1 && j>=0; j--)\n            dpp[i]+=dpp[j];\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 12",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 13",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (c+i <= n)\n    {\n       if (i >= d)\n         foo(c+i,n,k,d,true);\n       else\n         foo(c+i,n,k,d,take);\n    }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 14",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 15",
          "code": "for (int i = 1; i <= k; i++)\n{\n    if (i <= n)\n    {\n       if (i >= d)\n         foo(i,n,k,d,true);\n       else\n         foo(i,n,k,d,false);\n    }\n    else\n       break;\n}\ncout<<ans<<endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 16",
          "code": "#define N 100005",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 17",
          "code": "0 <= n <= 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 18",
          "code": "Dp[n][0] + Dp[n][1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 19",
          "code": "Dp[0][0] = 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 20",
          "code": "Dp[0][1] = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 21",
          "code": "Dp[n][0] = Dp[n-1][0] + Dp[n-2][0] + ... + Dp[n-DL][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 22",
          "code": "DL = min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 23",
          "code": "Dp[n][1] = Dp[n-1][1] + Dp[n-2][1] + ... + Dp[n-K][1] +",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 24",
          "code": "+ Dp[n-d][0] + Dp[n-(d+1)][0] + ... + Dp[n-K][0]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 25",
          "code": "K = min(k,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 26",
          "code": "1 <= m <= min(d-1,n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        },
        {
          "title": "Editorial Codeforces Round #247 (Div. 2) - Codeforces - Code 27",
          "code": "1 <= m <= d-1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12369",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long m = inf.readLong(0LL, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 64, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long m = inf.readLong(0LL, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 64, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long m = inf.readLong(0LL, 1000000000000000000LL, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 64, \"k\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// We'll consider up to 61 bits, since n <= 1e18 => 2n < 2^61.\nstatic const int MAXB = 61;\nstatic long long C[MAXB + 1][MAXB + 1];\n\n// Precompute binomial coefficients for up to 60 bits, clamping sums above 1e18.\nvoid buildComb() {\n    for (int i = 0; i <= MAXB; i++) {\n        C[i][0] = 1;\n        for (int j = 1; j <= i; j++) {\n            __int128 s = ( (__int128)C[i-1][j-1] + C[i-1][j] );\n            if (s > 1000000000000000000LL) {\n                s = 1000000000000000001LL; // clamp\n            }\n            C[i][j] = (long long)s;\n        }\n    }\n}\n\n// Counts how many integers in [0..x] have exactly k bits set, in at most 61 steps.\nlong long countPopcount(long long x, int k) {\n    if (x < 0 || k < 0) return 0;\n    long long res = 0;\n    int used = 0; // how many bits set so far\n    \n    for (int b = MAXB - 1; b >= 0; b--) {\n        if ((x >> b) & 1LL) {\n            int remain = b;\n            int need = k - used;\n            if (need >= 0 && need <= remain) {\n                res += C[remain][need];\n                if (res > 1000000000000000000LL) {\n                    // clamp above 1e18\n                    res = 1000000000000000001LL;\n                }\n            }\n            used++;\n            if (used > k) break;\n        }\n    }\n    if (used == k) res++;\n    return res;\n}\n\nvoid checkAnswer(InStream &stream, long long m, int k, const char* label) {\n    long long n = stream.readLong(1LL, 1000000000000000000LL, label);\n    if ((__int128)n * 2 > LLONG_MAX) {\n        stream.quitf(_wa, \"2*n exceeds 64-bit range\");\n    }\n    long long twoN = (n << 1);\n\n    long long cnt2N = countPopcount(twoN, k);\n    long long cntN  = countPopcount(n, k);\n    long long found = cnt2N - cntN;\n    if (found != m) {\n        stream.quitf(_wa,\n            \"Expected %lld numbers in [n+1..2n] with %d bits set; got %lld\",\n            m, k, found);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    buildComb();\n\n    long long m = inf.readLong(0LL, 1000000000000000000LL, \"m\");\n    int k = inf.readInt(1, 64, \"k\");\n\n    checkAnswer(ans, m, k, \"jury's answer\");\n    checkAnswer(ouf, m, k, \"participant's answer\");\n\n    quitf(_ok, \"Correct answer\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long m;\n    int k;\n\n    if (type == \"minimal\") {\n        m = 0;\n        k = 1;\n    } else if (type == \"maximal\") {\n        m = 1000000000000000000LL; // 1e18\n        k = 64;\n    } else if (type == \"random_small\") {\n        m = rnd.next(0LL, 1000000LL);\n        k = rnd.next(1, 64);\n    } else if (type == \"random_large\") {\n        m = rnd.next(1000000000000LL, 1000000000000000000LL);\n        k = rnd.next(1, 64);\n    } else if (type == \"k_equals_one\") {\n        m = rnd.next(0LL, 1000000000000000000LL);\n        k = 1;\n    } else if (type == \"k_equals_max\") {\n        m = rnd.next(0LL, 1000000000000000000LL);\n        k = 64;\n    } else if (type == \"m_equals_zero\") {\n        m = 0;\n        k = rnd.next(1, 64);\n    } else if (type == \"m_equals_max\") {\n        m = 1000000000000000000LL;\n        k = rnd.next(1, 64);\n    } else if (type == \"large_m_small_k\") {\n        m = rnd.next(500000000000000000LL, 1000000000000000000LL);\n        k = rnd.next(1, 5);\n    } else if (type == \"small_m_large_k\") {\n        m = rnd.next(0LL, 1000000LL);\n        k = rnd.next(60, 64);\n    } else {\n        // Default random\n        m = rnd.next(0LL, 1000000000000000000LL);\n        k = rnd.next(1, 64);\n    }\n\n    printf(\"%lld %d\\n\", m, k);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n\n    long long m;\n    int k;\n\n    if (type == \"minimal\") {\n        m = 0;\n        k = 1;\n    } else if (type == \"maximal\") {\n        m = 1000000000000000000LL; // 1e18\n        k = 64;\n    } else if (type == \"random_small\") {\n        m = rnd.next(0LL, 1000000LL);\n        k = rnd.next(1, 64);\n    } else if (type == \"random_large\") {\n        m = rnd.next(1000000000000LL, 1000000000000000000LL);\n        k = rnd.next(1, 64);\n    } else if (type == \"k_equals_one\") {\n        m = rnd.next(0LL, 1000000000000000000LL);\n        k = 1;\n    } else if (type == \"k_equals_max\") {\n        m = rnd.next(0LL, 1000000000000000000LL);\n        k = 64;\n    } else if (type == \"m_equals_zero\") {\n        m = 0;\n        k = rnd.next(1, 64);\n    } else if (type == \"m_equals_max\") {\n        m = 1000000000000000000LL;\n        k = rnd.next(1, 64);\n    } else if (type == \"large_m_small_k\") {\n        m = rnd.next(500000000000000000LL, 1000000000000000000LL);\n        k = rnd.next(1, 5);\n    } else if (type == \"small_m_large_k\") {\n        m = rnd.next(0LL, 1000000LL);\n        k = rnd.next(60, 64);\n    } else {\n        // Default random\n        m = rnd.next(0LL, 1000000000000000000LL);\n        k = rnd.next(1, 64);\n    }\n\n    printf(\"%lld %d\\n\", m, k);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal and maximal test cases\n./gen -type minimal\n./gen -type maximal\n\n# Random small values\n./gen -type random_small\n./gen -type random_small\n./gen -type random_small\n\n# Random large values\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n# k equals one\n./gen -type k_equals_one\n./gen -type k_equals_one\n./gen -type k_equals_one\n\n# k equals maximal value\n./gen -type k_equals_max\n./gen -type k_equals_max\n./gen -type k_equals_max\n\n# m equals zero\n./gen -type m_equals_zero\n./gen -type m_equals_zero\n./gen -type m_equals_zero\n\n# m equals maximal value\n./gen -type m_equals_max\n./gen -type m_equals_max\n./gen -type m_equals_max\n\n# Large m, small k\n./gen -type large_m_small_k\n./gen -type large_m_small_k\n./gen -type large_m_small_k\n\n# Small m, large k\n./gen -type small_m_large_k\n./gen -type small_m_large_k\n./gen -type small_m_large_k\n\n# Default random test cases\n./gen\n./gen\n./gen\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:08.227333",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "431/E",
      "title": "Problem 431/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 0, 1000000000, \"h\");\n    inf.readEoln();\n\n    int cntAction2 = 0;\n\n    for (int i = 0; i < q; ++i) {\n        int actionType = inf.readInt(1, 2, \"actionType\");\n        inf.readSpace();\n        if (actionType == 1) {\n            int pi = inf.readInt(1, n, \"pi\");\n            inf.readSpace();\n            int xi = inf.readInt(0, 1000000000, \"xi\");\n            inf.readEoln();\n        } else { // actionType == 2\n            long long vi = inf.readLong(1LL, 1000000000000000LL, \"vi\");\n            inf.readEoln();\n            cntAction2 += 1;\n        }\n    }\n\n    ensuref(cntAction2 >= 1, \"There must be at least one action of the second type\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 0, 1000000000, \"h\");\n    inf.readEoln();\n\n    int cntAction2 = 0;\n\n    for (int i = 0; i < q; ++i) {\n        int actionType = inf.readInt(1, 2, \"actionType\");\n        inf.readSpace();\n        if (actionType == 1) {\n            int pi = inf.readInt(1, n, \"pi\");\n            inf.readSpace();\n            int xi = inf.readInt(0, 1000000000, \"xi\");\n            inf.readEoln();\n        } else { // actionType == 2\n            long long vi = inf.readLong(1LL, 1000000000000000LL, \"vi\");\n            inf.readEoln();\n            cntAction2 += 1;\n        }\n    }\n\n    ensuref(cntAction2 >= 1, \"There must be at least one action of the second type\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 0, 1000000000, \"h\");\n    inf.readEoln();\n\n    int cntAction2 = 0;\n\n    for (int i = 0; i < q; ++i) {\n        int actionType = inf.readInt(1, 2, \"actionType\");\n        inf.readSpace();\n        if (actionType == 1) {\n            int pi = inf.readInt(1, n, \"pi\");\n            inf.readSpace();\n            int xi = inf.readInt(0, 1000000000, \"xi\");\n            inf.readEoln();\n        } else { // actionType == 2\n            long long vi = inf.readLong(1LL, 1000000000000000LL, \"vi\");\n            inf.readEoln();\n            cntAction2 += 1;\n        }\n    }\n\n    ensuref(cntAction2 >= 1, \"There must be at least one action of the second type\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxHi = opt<int>(\"maxHi\", 1000000000); // Default maxHi is 1e9\n    long long maxVi = opt<long long>(\"maxVi\", 1000000000000000LL); // Default maxVi is 1e15\n    int hiValue = opt<int>(\"hiValue\", maxHi / 2); // Default hiValue for samehi type\n    int numType2 = opt<int>(\"numType2\", -1); // Number of type 2 actions (-1 means random)\n    string actionOrder = opt<string>(\"actionOrder\", \"random\"); // \"alternate\", \"grouped\", \"random\"\n\n    // Ensure n and q are within constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= q && q <= 100000);\n\n    // Generate initial hi based on the specified type\n    vector<int> hi(n);\n\n    if (type == \"zeros\") {\n        // All hi are zeros\n        fill(hi.begin(), hi.end(), 0);\n    } else if (type == \"maxhi\") {\n        // All hi are maxHi\n        fill(hi.begin(), hi.end(), maxHi);\n    } else if (type == \"samehi\") {\n        // All hi are hiValue\n        fill(hi.begin(), hi.end(), hiValue);\n    } else if (type == \"ascendhi\") {\n        // hi in ascending order\n        for(int i = 0; i < n; ++i)\n            hi[i] = (i * (maxHi / max(1, n - 1))) % (maxHi + 1);\n    } else if (type == \"descendhi\") {\n        // hi in descending order\n        for(int i = 0; i < n; ++i)\n            hi[i] = (maxHi - i * (maxHi / max(1, n - 1))) % (maxHi + 1);\n    } else if (type == \"random\") {\n        // hi are random between 0 and maxHi\n        for(int i = 0; i < n; ++i)\n            hi[i] = rnd.next(0, maxHi);\n    } else {\n        // Default to random hi\n        for(int i = 0; i < n; ++i)\n            hi[i] = rnd.next(0, maxHi);\n    }\n\n    // Determine the number of actions of type 2 (must be at least 1)\n    if (numType2 == -1) {\n        numType2 = rnd.next(1, q);\n    }\n    numType2 = max(1, min(numType2, q));\n    int numType1 = q - numType2;\n\n    vector<int> action_types(q);\n\n    // Generate action types based on the specified action order\n    if (actionOrder == \"alternate\") {\n        int idx = 0;\n        while (numType1 > 0 || numType2 > 0) {\n            if (numType2 > 0) {\n                action_types[idx++] = 2;\n                numType2--;\n            }\n            if (numType1 > 0) {\n                action_types[idx++] = 1;\n                numType1--;\n            }\n        }\n    } else if (actionOrder == \"grouped\") {\n        for (int i = 0; i < numType1; ++i) action_types[i] = 1;\n        for (int i = numType1; i < q; ++i) action_types[i] = 2;\n    } else {\n        // Random action order\n        for (int i = 0; i < numType1; ++i) action_types[i] = 1;\n        for (int i = numType1; i < q; ++i) action_types[i] = 2;\n        shuffle(action_types.begin(), action_types.end());\n    }\n\n    // Generate the actions with appropriate parameters\n    vector<pair<int, vector<long long>>> actions; // pair<action_type, parameters>\n\n    for (int i = 0; i < q; ++i) {\n        int at = action_types[i];\n        if (at == 1) {\n            // Action type 1: \"1 pi xi\"\n            int pi = rnd.next(1, n);\n            int xi = rnd.next(0, maxHi);\n            actions.push_back(make_pair(1, vector<long long>{pi, xi}));\n        } else {\n            // Action type 2: \"2 vi\"\n            long long vi = rnd.next(1LL, maxVi);\n            actions.push_back(make_pair(2, vector<long long>{vi}));\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output initial hi\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", hi[i], i + 1 == n ? '\\n' : ' ');\n\n    // Output the actions\n    for (const auto& action : actions) {\n        int at = action.first;\n        const auto& params = action.second;\n        if (at == 1) {\n            int pi = params[0];\n            int xi = params[1];\n            printf(\"1 %d %d\\n\", pi, xi);\n\n            // Update hi[pi - 1] to xi\n            hi[pi - 1] = xi;\n        } else {\n            long long vi = params[0];\n            printf(\"2 %lld\\n\", vi);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxHi = opt<int>(\"maxHi\", 1000000000); // Default maxHi is 1e9\n    long long maxVi = opt<long long>(\"maxVi\", 1000000000000000LL); // Default maxVi is 1e15\n    int hiValue = opt<int>(\"hiValue\", maxHi / 2); // Default hiValue for samehi type\n    int numType2 = opt<int>(\"numType2\", -1); // Number of type 2 actions (-1 means random)\n    string actionOrder = opt<string>(\"actionOrder\", \"random\"); // \"alternate\", \"grouped\", \"random\"\n\n    // Ensure n and q are within constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= q && q <= 100000);\n\n    // Generate initial hi based on the specified type\n    vector<int> hi(n);\n\n    if (type == \"zeros\") {\n        // All hi are zeros\n        fill(hi.begin(), hi.end(), 0);\n    } else if (type == \"maxhi\") {\n        // All hi are maxHi\n        fill(hi.begin(), hi.end(), maxHi);\n    } else if (type == \"samehi\") {\n        // All hi are hiValue\n        fill(hi.begin(), hi.end(), hiValue);\n    } else if (type == \"ascendhi\") {\n        // hi in ascending order\n        for(int i = 0; i < n; ++i)\n            hi[i] = (i * (maxHi / max(1, n - 1))) % (maxHi + 1);\n    } else if (type == \"descendhi\") {\n        // hi in descending order\n        for(int i = 0; i < n; ++i)\n            hi[i] = (maxHi - i * (maxHi / max(1, n - 1))) % (maxHi + 1);\n    } else if (type == \"random\") {\n        // hi are random between 0 and maxHi\n        for(int i = 0; i < n; ++i)\n            hi[i] = rnd.next(0, maxHi);\n    } else {\n        // Default to random hi\n        for(int i = 0; i < n; ++i)\n            hi[i] = rnd.next(0, maxHi);\n    }\n\n    // Determine the number of actions of type 2 (must be at least 1)\n    if (numType2 == -1) {\n        numType2 = rnd.next(1, q);\n    }\n    numType2 = max(1, min(numType2, q));\n    int numType1 = q - numType2;\n\n    vector<int> action_types(q);\n\n    // Generate action types based on the specified action order\n    if (actionOrder == \"alternate\") {\n        int idx = 0;\n        while (numType1 > 0 || numType2 > 0) {\n            if (numType2 > 0) {\n                action_types[idx++] = 2;\n                numType2--;\n            }\n            if (numType1 > 0) {\n                action_types[idx++] = 1;\n                numType1--;\n            }\n        }\n    } else if (actionOrder == \"grouped\") {\n        for (int i = 0; i < numType1; ++i) action_types[i] = 1;\n        for (int i = numType1; i < q; ++i) action_types[i] = 2;\n    } else {\n        // Random action order\n        for (int i = 0; i < numType1; ++i) action_types[i] = 1;\n        for (int i = numType1; i < q; ++i) action_types[i] = 2;\n        shuffle(action_types.begin(), action_types.end());\n    }\n\n    // Generate the actions with appropriate parameters\n    vector<pair<int, vector<long long>>> actions; // pair<action_type, parameters>\n\n    for (int i = 0; i < q; ++i) {\n        int at = action_types[i];\n        if (at == 1) {\n            // Action type 1: \"1 pi xi\"\n            int pi = rnd.next(1, n);\n            int xi = rnd.next(0, maxHi);\n            actions.push_back(make_pair(1, vector<long long>{pi, xi}));\n        } else {\n            // Action type 2: \"2 vi\"\n            long long vi = rnd.next(1LL, maxVi);\n            actions.push_back(make_pair(2, vector<long long>{vi}));\n        }\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Output initial hi\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", hi[i], i + 1 == n ? '\\n' : ' ');\n\n    // Output the actions\n    for (const auto& action : actions) {\n        int at = action.first;\n        const auto& params = action.second;\n        if (at == 1) {\n            int pi = params[0];\n            int xi = params[1];\n            printf(\"1 %d %d\\n\", pi, xi);\n\n            // Update hi[pi - 1] to xi\n            hi[pi - 1] = xi;\n        } else {\n            long long vi = params[0];\n            printf(\"2 %lld\\n\", vi);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -q 1 -type zeros -actionOrder grouped\n./gen -n 2 -q 2 -type samehi -hiValue 5 -actionOrder alternate\n./gen -n 10 -q 10 -type random\n./gen -n 100 -q 100 -type ascendhi -actionOrder random\n./gen -n 100 -q 100 -type descendhi -actionOrder random\n./gen -n 1000 -q 1000 -type zeros -maxVi 1000000000000000\n./gen -n 1000 -q 1000 -type maxhi -maxVi 1000000000000000\n./gen -n 1000 -q 1000 -type samehi -hiValue 0\n./gen -n 1000 -q 1000 -type samehi -hiValue 1000000000\n./gen -n 1000 -q 1000 -type random -actionOrder alternate\n./gen -n 1000 -q 1000 -type random -actionOrder grouped\n./gen -n 1000 -q 1000 -type random -actionOrder random\n./gen -n 100000 -q 100000 -type zeros -numType2 1\n./gen -n 100000 -q 100000 -type zeros -numType2 100000\n./gen -n 100000 -q 100000 -type zeros -numType2 50000\n./gen -n 100000 -q 100000 -type random -actionOrder random\n./gen -n 2 -q 100000 -type random -actionOrder random\n./gen -n 100000 -q 2 -type random\n./gen -n 1 -q 100000 -type random\n./gen -n 100000 -q 100000 -type ascendhi -actionOrder random\n./gen -n 100000 -q 100000 -type descendhi -actionOrder random\n./gen -n 100000 -q 100000 -type maxhi -actionOrder grouped\n./gen -n 100000 -q 100000 -type samehi -hiValue 500000000\n./gen -n 100000 -q 100000 -type random -maxHi 0\n./gen -n 100000 -q 100000 -type random -maxHi 1000000000\n./gen -n 100000 -q 100000 -type zeros -maxVi 1\n./gen -n 100000 -q 100000 -type zeros -maxVi 1000000000000000\n./gen -n 100000 -q 100000 -type random -numType2 1000\n./gen -n 100000 -q 100000 -type random -numType2 99999\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:10.610877",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "432/A",
      "title": "A. Choosing Teams",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and k (1 ≤ n ≤ 2000; 1 ≤ k ≤ 5). The next line contains n integers: y1, y2, ..., yn (0 ≤ yi ≤ 5), where yi shows the number of times the i-th person participated in the ACM ICPC world championship.",
      "output_spec": "OutputPrint a single number — the answer to the problem.",
      "sample_tests": "ExamplesInputCopy5 20 4 5 1 0OutputCopy1InputCopy6 40 1 2 3 4 5OutputCopy0InputCopy6 50 0 0 0 0 0OutputCopy2",
      "description": "A. Choosing Teams\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and k (1 ≤ n ≤ 2000; 1 ≤ k ≤ 5). The next line contains n integers: y1, y2, ..., yn (0 ≤ yi ≤ 5), where yi shows the number of times the i-th person participated in the ACM ICPC world championship.\n\nOutputPrint a single number — the answer to the problem.\n\nInputCopy5 20 4 5 1 0OutputCopy1InputCopy6 40 1 2 3 4 5OutputCopy0InputCopy6 50 0 0 0 0 0OutputCopy2\n\nInputCopy5 20 4 5 1 0\n\nOutputCopy1\n\nInputCopy6 40 1 2 3 4 5\n\nOutputCopy0\n\nInputCopy6 50 0 0 0 0 0\n\nOutputCopy2\n\nNoteIn the first sample only one team could be made: the first, the fourth and the fifth participants.In the second sample no teams could be created.In the third sample two teams could be created. Any partition into two teams fits.",
      "solutions": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "Good day, codeforces)Welcome to regular Codeforces round #246 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Is not the first and definitely not the last time when we tried our best for you. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.UPD2: The contest is over, we hope you enjoy it)UPD3: the editorial is hereCongratulations to winners!:1) PopovkinAndrey2) FTD20093) Gulan14no4) Kozakai_Aya5) Mikael We wish all participants good luck and enjoyment of solving problems)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12298",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 785
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces",
          "content": "432A - Choosing TeamsIn this problem you should count number of students who can participate in ACM, divide it by 3 and round down. It could be done like this: int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n if (5 - a[i] >= k)\n cnt++;\n\nint ans = cnt / 3;432B - Football KitCount for every team number of games in home kit. For team i it equals to sum of n - 1 games at home and some away games with such teams which home kit color equals away kit color of team i. To count number of such away games you could calc array cnt[j] — number of teams with home color kit j. The solution could be implemented in this wasy: for(int i = 0; i < n; i++)\n cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n ans_home[i] = n - 1;\n ans_home[i] += cnt[ y[i] ];\n\n ans_away[i] = 2 * (n - 1) - ans_home[i];\n}432C - Prime SwapsThe solution can be described by pseudo-code: Consider elements of permutation from 1 to n While current element i is not sutiated on position i Let the position of element i equals pos Find maximum prime integer p which is less or equal than $pos — i + 1 Swap element in positions pos and pos - p + 1 It could be proved that such algorithm makes less than 4n swaps (for example, by implementing the algorithm)This algorithm should be implemented optimally. You should maintain positions of elements of permutation. Swap function in author's solution: void doSwap(int i, int j){\n int x = a[i], y = a[j];\n a[j] = x, pos[x] = j;\n a[i] = y, pos[y] = i;\n result.push_back(make_pair(i, j));\n}432D - Prefixes and SuffixesThe problem could be solved using different algorithms with z and prefix functions. Let's describe the solution with prefix function p of string s.Calc prefix function and create a tree where vertices — integers from 0 to |s|, edges — from p[i] to i for every i. The root of the tree is 0. For every vertex v calc the number of values p[i] = v — that is cnt[v]. Then for every v calc the sum all values cnt[u] for every u in to subtree of v. The general answer to the problem is:Find all lenghts of the prefixes which matches the suffixes — these values are |s|, p[|s|], p[p[|s|]], p[p[p[|s|]]]... For every such length L the answer to the problem is sum[L] + 1.432E - Square TilingThis is popular test 6 :) 13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABBThe problem could be solved in a standard way — try to fill the table from the first cell to the last and try to put the miminum letter.Consider the first row. Obviously it begins from some letters A (to be exact min(n, m) letters A). When we put some letters A in the first row, we should put several letters A in some next rows to make a square. The next letter could be only B.Describe the solution in general. Assume that we have already considered some rows. Consider row i. Some cells in this row could be already painted. Consider unpainted cells from left to the right. For every such cell consider its color from A to Z. Two cases should be considered: Put in this cell the minimum possible letter (neighbours have no such letter) If the previous cell in this row was not painted at the beginning of considering row i, now it is already painted. We should try to merge the current cell with the square of the previous cell. Choose the best case from these cases. Try to get the answer on test n = 13 m = 5 to understand the algorithm better.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12310",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 432\\s*A"
          },
          "content_length": 3352
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "The answer should only consist of A,B and C. If your anwser has letter D or others your solution is 100% wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "for every i from 1 to n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "O(5 n log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "z[N - len] == len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n    if (5 - a[i] >= k)\n        cnt++;\n\nint ans = cnt / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int i = 0; i < n; i++)\n    cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n    ans_home[i] = n - 1;\n    ans_home[i] += cnt[ y[i] ];\n\n    ans_away[i] = 2 * (n - 1) - ans_home[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "void doSwap(int i, int j){\n    int x = a[i], y = a[j];\n    a[j] = x, pos[x] = j;\n    a[i] = y, pos[y] = i;\n    result.push_back(make_pair(i, j));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    vector<int> y = inf.readInts(n, 0, 5, \"y\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    vector<int> y = inf.readInts(n, 0, 5, \"y\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 5, \"k\");\n    inf.readEoln();\n\n    vector<int> y = inf.readInts(n, 0, 5, \"y\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") {\n        n = 1;\n    } else if (type == \"max_n\") {\n        n = 2000;\n    }\n\n    if (n == -1 || k == -1) {\n        fprintf(stderr, \"n and k must be specified\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<int> y(n);\n\n    if (type == \"min_n\") {\n        y[0] = rnd.next(0, 5);\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; i++)\n            y[i] = 0;\n    } else if (type == \"all_five\") {\n        for (int i = 0; i < n; i++)\n            y[i] = 5;\n    } else if (type == \"max_teams\") {\n        int max_yi = 5 - k;\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, max_yi);\n    } else if (type == \"no_team\") {\n        int min_yi = 5 - k + 1;\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(min_yi, 5);\n    } else if (type == \"boundary\") {\n        int accept_yi = 5 - k;\n        int reject_yi = 5 - k + 1;\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, 1) ? accept_yi : reject_yi;\n    } else if (type == \"half_and_half\") {\n        int max_yi = 5 - k;\n        int min_yi = 5 - k + 1;\n        for (int i = 0; i < n / 2; i++)\n            y[i] = rnd.next(0, max_yi);\n        for (int i = n / 2; i < n; i++)\n            y[i] = rnd.next(min_yi, 5);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, 5);\n    } else if (type == \"max_n\") {\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, 5);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    shuffle(y.begin(), y.end());\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", y[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int k = opt<int>(\"k\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"min_n\") {\n        n = 1;\n    } else if (type == \"max_n\") {\n        n = 2000;\n    }\n\n    if (n == -1 || k == -1) {\n        fprintf(stderr, \"n and k must be specified\\n\");\n        return 1;\n    }\n\n    printf(\"%d %d\\n\", n, k);\n\n    vector<int> y(n);\n\n    if (type == \"min_n\") {\n        y[0] = rnd.next(0, 5);\n    } else if (type == \"all_zero\") {\n        for (int i = 0; i < n; i++)\n            y[i] = 0;\n    } else if (type == \"all_five\") {\n        for (int i = 0; i < n; i++)\n            y[i] = 5;\n    } else if (type == \"max_teams\") {\n        int max_yi = 5 - k;\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, max_yi);\n    } else if (type == \"no_team\") {\n        int min_yi = 5 - k + 1;\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(min_yi, 5);\n    } else if (type == \"boundary\") {\n        int accept_yi = 5 - k;\n        int reject_yi = 5 - k + 1;\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, 1) ? accept_yi : reject_yi;\n    } else if (type == \"half_and_half\") {\n        int max_yi = 5 - k;\n        int min_yi = 5 - k + 1;\n        for (int i = 0; i < n / 2; i++)\n            y[i] = rnd.next(0, max_yi);\n        for (int i = n / 2; i < n; i++)\n            y[i] = rnd.next(min_yi, 5);\n    } else if (type == \"random\") {\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, 5);\n    } else if (type == \"max_n\") {\n        for (int i = 0; i < n; i++)\n            y[i] = rnd.next(0, 5);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    shuffle(y.begin(), y.end());\n\n    for (int i = 0; i < n; i++)\n        printf(\"%d%c\", y[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 2 -type all_zero\n./gen -n 5 -k 2 -type all_five\n./gen -n 5 -k 2 -type random\n./gen -n 5 -k 2 -type max_teams\n./gen -n 5 -k 2 -type no_team\n./gen -n 5 -k 2 -type boundary\n./gen -n 5 -k 2 -type half_and_half\n\n./gen -n 6 -k 4 -type all_zero\n./gen -n 6 -k 4 -type all_five\n./gen -n 6 -k 4 -type random\n./gen -n 6 -k 4 -type max_teams\n./gen -n 6 -k 4 -type no_team\n./gen -n 6 -k 4 -type boundary\n./gen -n 6 -k 4 -type half_and_half\n\n./gen -n 6 -k 5 -type all_zero\n./gen -n 6 -k 5 -type all_five\n./gen -n 6 -k 5 -type random\n./gen -n 6 -k 5 -type max_teams\n./gen -n 6 -k 5 -type no_team\n./gen -n 6 -k 5 -type boundary\n./gen -n 6 -k 5 -type half_and_half\n\n./gen -n 1 -k 1 -type min_n\n./gen -n 2000 -k 1 -type max_n\n\n./gen -n 2000 -k 1 -type random\n./gen -n 2000 -k 5 -type random\n./gen -n 2000 -k 3 -type max_teams\n./gen -n 2000 -k 3 -type no_team\n./gen -n 2000 -k 3 -type boundary\n./gen -n 2000 -k 3 -type half_and_half\n\n./gen -n 2000 -k 5 -type all_zero\n./gen -n 2000 -k 1 -type all_zero\n./gen -n 2000 -k 5 -type all_five\n\n./gen -n 1999 -k 3 -type random\n./gen -n 1999 -k 3 -type max_teams\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:12.613203",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "432/B",
      "title": "B. Football Kit",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of teams. Next n lines contain the description of the teams. The i-th line contains two space-separated numbers xi, yi (1 ≤ xi, yi ≤ 105; xi ≠ yi) — the color numbers for the home and away kits of the i-th team.",
      "output_spec": "OutputFor each team, print on a single line two space-separated integers — the number of games this team is going to play in home and away kits, correspondingly. Print the answers for the teams in the order they appeared in the input.",
      "sample_tests": "ExamplesInputCopy21 22 1OutputCopy2 02 0InputCopy31 22 11 3OutputCopy3 14 02 2",
      "description": "B. Football Kit\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer n (2 ≤ n ≤ 105) — the number of teams. Next n lines contain the description of the teams. The i-th line contains two space-separated numbers xi, yi (1 ≤ xi, yi ≤ 105; xi ≠ yi) — the color numbers for the home and away kits of the i-th team.\n\nOutputFor each team, print on a single line two space-separated integers — the number of games this team is going to play in home and away kits, correspondingly. Print the answers for the teams in the order they appeared in the input.\n\nInputCopy21 22 1OutputCopy2 02 0InputCopy31 22 11 3OutputCopy3 14 02 2\n\nInputCopy21 22 1\n\nOutputCopy2 02 0\n\nInputCopy31 22 11 3\n\nOutputCopy3 14 02 2",
      "solutions": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "Good day, codeforces)Welcome to regular Codeforces round #246 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Is not the first and definitely not the last time when we tried our best for you. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.UPD2: The contest is over, we hope you enjoy it)UPD3: the editorial is hereCongratulations to winners!:1) PopovkinAndrey2) FTD20093) Gulan14no4) Kozakai_Aya5) Mikael We wish all participants good luck and enjoyment of solving problems)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12298",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 785
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces",
          "content": "432A - Choosing TeamsIn this problem you should count number of students who can participate in ACM, divide it by 3 and round down. It could be done like this: int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n if (5 - a[i] >= k)\n cnt++;\n\nint ans = cnt / 3;432B - Football KitCount for every team number of games in home kit. For team i it equals to sum of n - 1 games at home and some away games with such teams which home kit color equals away kit color of team i. To count number of such away games you could calc array cnt[j] — number of teams with home color kit j. The solution could be implemented in this wasy: for(int i = 0; i < n; i++)\n cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n ans_home[i] = n - 1;\n ans_home[i] += cnt[ y[i] ];\n\n ans_away[i] = 2 * (n - 1) - ans_home[i];\n}432C - Prime SwapsThe solution can be described by pseudo-code: Consider elements of permutation from 1 to n While current element i is not sutiated on position i Let the position of element i equals pos Find maximum prime integer p which is less or equal than $pos — i + 1 Swap element in positions pos and pos - p + 1 It could be proved that such algorithm makes less than 4n swaps (for example, by implementing the algorithm)This algorithm should be implemented optimally. You should maintain positions of elements of permutation. Swap function in author's solution: void doSwap(int i, int j){\n int x = a[i], y = a[j];\n a[j] = x, pos[x] = j;\n a[i] = y, pos[y] = i;\n result.push_back(make_pair(i, j));\n}432D - Prefixes and SuffixesThe problem could be solved using different algorithms with z and prefix functions. Let's describe the solution with prefix function p of string s.Calc prefix function and create a tree where vertices — integers from 0 to |s|, edges — from p[i] to i for every i. The root of the tree is 0. For every vertex v calc the number of values p[i] = v — that is cnt[v]. Then for every v calc the sum all values cnt[u] for every u in to subtree of v. The general answer to the problem is:Find all lenghts of the prefixes which matches the suffixes — these values are |s|, p[|s|], p[p[|s|]], p[p[p[|s|]]]... For every such length L the answer to the problem is sum[L] + 1.432E - Square TilingThis is popular test 6 :) 13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABBThe problem could be solved in a standard way — try to fill the table from the first cell to the last and try to put the miminum letter.Consider the first row. Obviously it begins from some letters A (to be exact min(n, m) letters A). When we put some letters A in the first row, we should put several letters A in some next rows to make a square. The next letter could be only B.Describe the solution in general. Assume that we have already considered some rows. Consider row i. Some cells in this row could be already painted. Consider unpainted cells from left to the right. For every such cell consider its color from A to Z. Two cases should be considered: Put in this cell the minimum possible letter (neighbours have no such letter) If the previous cell in this row was not painted at the beginning of considering row i, now it is already painted. We should try to merge the current cell with the square of the previous cell. Choose the best case from these cases. Try to get the answer on test n = 13 m = 5 to understand the algorithm better.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12310",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 432\\s*B"
          },
          "content_length": 3352
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "The answer should only consist of A,B and C. If your anwser has letter D or others your solution is 100% wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "for every i from 1 to n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "O(5 n log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "z[N - len] == len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n    if (5 - a[i] >= k)\n        cnt++;\n\nint ans = cnt / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int i = 0; i < n; i++)\n    cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n    ans_home[i] = n - 1;\n    ans_home[i] += cnt[ y[i] ];\n\n    ans_away[i] = 2 * (n - 1) - ans_home[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "void doSwap(int i, int j){\n    int x = a[i], y = a[j];\n    a[j] = x, pos[x] = j;\n    a[i] = y, pos[y] = i;\n    result.push_back(make_pair(i, j));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 100000, \"yi\");\n        ensuref(xi != yi, \"xi and yi should not be equal at line %d, xi=%d, yi=%d\", i+2, xi, yi);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 100000, \"yi\");\n        ensuref(xi != yi, \"xi and yi should not be equal at line %d, xi=%d, yi=%d\", i+2, xi, yi);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        int xi = inf.readInt(1, 100000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, 100000, \"yi\");\n        ensuref(xi != yi, \"xi and yi should not be equal at line %d, xi=%d, yi=%d\", i+2, xi, yi);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    vector<pair<int, int>> teams(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(1, 100000);\n            int yi = rnd.next(1, 100000 - 1);\n            if (yi >= xi) yi++;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"same_home\") {\n        int xi = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            int yi = rnd.next(1, 100000 - 1);\n            if (yi >= xi) yi++;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"same_away\") {\n        int yi = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(1, 100000 - 1);\n            if (xi >= yi) xi++;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"cycle\") {\n        int shift = n / 2;\n        for (int i = 0; i < n; ++i) {\n            int xi = i + 1;\n            int yi = (i + shift) % n + 1;\n            if (xi == yi) yi = (yi % n) + 1;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"max_color\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = 100000;\n            int yi = 99999;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"min_color\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = 1;\n            int yi = 2;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"unique\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = (i % 100000) + 1;\n            int yi = (xi + n / 2) % 100000 + 1;\n            if (xi == yi) yi = (yi % 100000) + 1;\n            teams[i] = make_pair(xi, yi);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", teams[i].first, teams[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    vector<pair<int, int>> teams(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(1, 100000);\n            int yi = rnd.next(1, 100000 - 1);\n            if (yi >= xi) yi++;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"same_home\") {\n        int xi = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            int yi = rnd.next(1, 100000 - 1);\n            if (yi >= xi) yi++;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"same_away\") {\n        int yi = rnd.next(1, 100000);\n        for (int i = 0; i < n; ++i) {\n            int xi = rnd.next(1, 100000 - 1);\n            if (xi >= yi) xi++;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"cycle\") {\n        int shift = n / 2;\n        for (int i = 0; i < n; ++i) {\n            int xi = i + 1;\n            int yi = (i + shift) % n + 1;\n            if (xi == yi) yi = (yi % n) + 1;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"max_color\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = 100000;\n            int yi = 99999;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"min_color\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = 1;\n            int yi = 2;\n            teams[i] = make_pair(xi, yi);\n        }\n    } else if (type == \"unique\") {\n        for (int i = 0; i < n; ++i) {\n            int xi = (i % 100000) + 1;\n            int yi = (xi + n / 2) % 100000 + 1;\n            if (xi == yi) yi = (yi % 100000) + 1;\n            teams[i] = make_pair(xi, yi);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", teams[i].first, teams[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type same_home\n./gen -n 2 -type same_away\n./gen -n 2 -type cycle\n./gen -n 2 -type max_color\n./gen -n 2 -type min_color\n./gen -n 2 -type unique\n\n./gen -n 10 -type random\n./gen -n 10 -type same_home\n./gen -n 10 -type same_away\n./gen -n 10 -type cycle\n./gen -n 10 -type unique\n\n./gen -n 1000 -type random\n./gen -n 1000 -type same_home\n./gen -n 1000 -type same_away\n./gen -n 1000 -type cycle\n./gen -n 1000 -type unique\n\n./gen -n 50000 -type random\n./gen -n 50000 -type same_home\n./gen -n 50000 -type same_away\n\n./gen -n 99999 -type random\n./gen -n 99999 -type cycle\n./gen -n 99999 -type unique\n\n./gen -n 100000 -type random\n./gen -n 100000 -type same_home\n./gen -n 100000 -type same_away\n./gen -n 100000 -type cycle\n./gen -n 100000 -type unique\n./gen -n 100000 -type max_color\n./gen -n 100000 -type min_color\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:14.791404",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "432/C",
      "title": "C. Prime Swaps",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105). The next line contains n distinct integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ n).",
      "output_spec": "OutputIn the first line, print integer k (0 ≤ k ≤ 5n) — the number of used operations. Next, print the operations. Each operation must be printed as \"i j\" (1 ≤ i < j ≤ n; (j - i + 1) is a prime).If there are multiple answers, you can print any of them.",
      "sample_tests": "ExamplesInputCopy33 2 1OutputCopy11 3InputCopy21 2OutputCopy0InputCopy44 2 3 1OutputCopy32 41 22 4",
      "description": "C. Prime Swaps\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105). The next line contains n distinct integers a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ n).\n\nOutputIn the first line, print integer k (0 ≤ k ≤ 5n) — the number of used operations. Next, print the operations. Each operation must be printed as \"i j\" (1 ≤ i < j ≤ n; (j - i + 1) is a prime).If there are multiple answers, you can print any of them.\n\nInputCopy33 2 1OutputCopy11 3InputCopy21 2OutputCopy0InputCopy44 2 3 1OutputCopy32 41 22 4\n\nInputCopy33 2 1\n\nOutputCopy11 3\n\nInputCopy21 2\n\nOutputCopy0\n\nInputCopy44 2 3 1\n\nOutputCopy32 41 22 4",
      "solutions": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "Good day, codeforces)Welcome to regular Codeforces round #246 for Div.2 participants. As always Div.1 participants can take part out of the competition.The problems were prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). Is not the first and definitely not the last time when we tried our best for you. Traditionally thanks to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.UPD2: The contest is over, we hope you enjoy it)UPD3: the editorial is hereCongratulations to winners!:1) PopovkinAndrey2) FTD20093) Gulan14no4) Kozakai_Aya5) Mikael We wish all participants good luck and enjoyment of solving problems)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12298",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 785
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces",
          "content": "432A - Choosing TeamsIn this problem you should count number of students who can participate in ACM, divide it by 3 and round down. It could be done like this: int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n if (5 - a[i] >= k)\n cnt++;\n\nint ans = cnt / 3;432B - Football KitCount for every team number of games in home kit. For team i it equals to sum of n - 1 games at home and some away games with such teams which home kit color equals away kit color of team i. To count number of such away games you could calc array cnt[j] — number of teams with home color kit j. The solution could be implemented in this wasy: for(int i = 0; i < n; i++)\n cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n ans_home[i] = n - 1;\n ans_home[i] += cnt[ y[i] ];\n\n ans_away[i] = 2 * (n - 1) - ans_home[i];\n}432C - Prime SwapsThe solution can be described by pseudo-code: Consider elements of permutation from 1 to n While current element i is not sutiated on position i Let the position of element i equals pos Find maximum prime integer p which is less or equal than $pos — i + 1 Swap element in positions pos and pos - p + 1 It could be proved that such algorithm makes less than 4n swaps (for example, by implementing the algorithm)This algorithm should be implemented optimally. You should maintain positions of elements of permutation. Swap function in author's solution: void doSwap(int i, int j){\n int x = a[i], y = a[j];\n a[j] = x, pos[x] = j;\n a[i] = y, pos[y] = i;\n result.push_back(make_pair(i, j));\n}432D - Prefixes and SuffixesThe problem could be solved using different algorithms with z and prefix functions. Let's describe the solution with prefix function p of string s.Calc prefix function and create a tree where vertices — integers from 0 to |s|, edges — from p[i] to i for every i. The root of the tree is 0. For every vertex v calc the number of values p[i] = v — that is cnt[v]. Then for every v calc the sum all values cnt[u] for every u in to subtree of v. The general answer to the problem is:Find all lenghts of the prefixes which matches the suffixes — these values are |s|, p[|s|], p[p[|s|]], p[p[p[|s|]]]... For every such length L the answer to the problem is sum[L] + 1.432E - Square TilingThis is popular test 6 :) 13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABBThe problem could be solved in a standard way — try to fill the table from the first cell to the last and try to put the miminum letter.Consider the first row. Obviously it begins from some letters A (to be exact min(n, m) letters A). When we put some letters A in the first row, we should put several letters A in some next rows to make a square. The next letter could be only B.Describe the solution in general. Assume that we have already considered some rows. Consider row i. Some cells in this row could be already painted. Consider unpainted cells from left to the right. For every such cell consider its color from A to Z. Two cases should be considered: Put in this cell the minimum possible letter (neighbours have no such letter) If the previous cell in this row was not painted at the beginning of considering row i, now it is already painted. We should try to merge the current cell with the square of the previous cell. Choose the best case from these cases. Try to get the answer on test n = 13 m = 5 to understand the algorithm better.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12310",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 432\\s*C"
          },
          "content_length": 3352
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "The answer should only consist of A,B and C. If your anwser has letter D or others your solution is 100% wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "for every i from 1 to n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "O(5 n log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "z[N - len] == len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n    if (5 - a[i] >= k)\n        cnt++;\n\nint ans = cnt / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "for(int i = 0; i < n; i++)\n    cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n    ans_home[i] = n - 1;\n    ans_home[i] += cnt[ y[i] ];\n\n    ans_away[i] = 2 * (n - 1) - ans_home[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "void doSwap(int i, int j){\n    int x = a[i], y = a[j];\n    a[j] = x, pos[x] = j;\n    a[i] = y, pos[y] = i;\n    result.push_back(make_pair(i, j));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    vector<bool> vis(n+1, false);\n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!vis[ai], \"Numbers in a[] must be distinct, but number %d occurs more than once\", ai);\n        vis[ai] = true;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    vector<bool> vis(n+1, false);\n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!vis[ai], \"Numbers in a[] must be distinct, but number %d occurs more than once\", ai);\n        vis[ai] = true;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]){\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a_i\");\n    inf.readEoln();\n\n    vector<bool> vis(n+1, false);\n\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!vis[ai], \"Numbers in a[] must be distinct, but number %d occurs more than once\", ai);\n        vis[ai] = true;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int x) {\n    if (x <= 1) return false;\n    if (x == 2) return true;\n    if (x % 2 == 0) return false;\n    for (int i = 3; i * i <= x; i += 2) {\n        if (x % i == 0) return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    int k = ouf.readInt(0, 5 * n, \"k\");\n    vector<pair<int, int>> ops;\n    for (int op = 1; op <= k; ++op) {\n        vector<int> ij = ouf.readInts(2, 1, n, format(\"operation %d\", op).c_str());\n        int i = ij[0];\n        int j = ij[1];\n        if (i >= j) {\n            quitf(_wa, \"Invalid swap in operation %d: i (%d) must be less than j (%d)\", op, i, j);\n        }\n        int len = j - i + 1;\n        if (!isPrime(len)) {\n            quitf(_wa, \"Invalid swap in operation %d: length (%d) is not prime\", op, len);\n        }\n        // Adjust to zero-based indexing\n        ops.emplace_back(i -1, j -1);\n    }\n    // Perform the swaps\n    for (auto [i, j] : ops) {\n        swap(a[i], a[j]);\n    }\n    // Check if array is sorted in increasing order\n    for (int idx = 0; idx < n -1; ++idx) {\n        if (a[idx] > a[idx + 1]) {\n            quitf(_wa, \"Array is not sorted after performing the operations\");\n        }\n    }\n    // All good\n    quitf(_ok, \"Array is sorted in increasing order after %d operations\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n + 1); // Using 1-based indexing\n\n    if (type == \"sorted\") {\n        /* Array is already sorted */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n    } else if (type == \"reversed\") {\n        /* Array is sorted in reverse order */\n        for (int i = 1; i <= n; ++i)\n            a[i] = n - i + 1;\n    } else if (type == \"random\") {\n        /* Random permutation of 1 to n */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        shuffle(a.begin() + 1, a.end());\n    } else if (type == \"single_swap\") {\n        /* Array with two elements swapped */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        if (n >= 2) {\n            int i = rnd.next(1, n - 1);\n            int j = rnd.next(i + 1, n);\n            swap(a[i], a[j]);\n        }\n    } else if (type == \"almost_sorted\") {\n        /* Array is almost sorted, with several elements swapped */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        int num_swaps = max(1, n / 10); // Swap 10% of elements\n        for (int k = 0; k < num_swaps; ++k) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(1, n);\n            while (i == j) j = rnd.next(1, n);\n            swap(a[i], a[j]);\n        }\n    } else if (type == \"anti_prime_gap\") {\n        /* Construct an array that may require swaps of large prime gaps */\n        if (n % 2 != 0) {\n            fprintf(stderr, \"Error: n must be even for type anti_prime_gap\\n\");\n            exit(1);\n        }\n        int mid = n / 2;\n        for (int i = 1; i <= mid; ++i)\n            a[i] = mid + i;\n        for (int i = mid + 1; i <= n; ++i)\n            a[i] = i - mid;\n    } else {\n        /* Default to random */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        shuffle(a.begin() + 1, a.end());\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the array */\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n + 1); // Using 1-based indexing\n\n    if (type == \"sorted\") {\n        /* Array is already sorted */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n    } else if (type == \"reversed\") {\n        /* Array is sorted in reverse order */\n        for (int i = 1; i <= n; ++i)\n            a[i] = n - i + 1;\n    } else if (type == \"random\") {\n        /* Random permutation of 1 to n */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        shuffle(a.begin() + 1, a.end());\n    } else if (type == \"single_swap\") {\n        /* Array with two elements swapped */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        if (n >= 2) {\n            int i = rnd.next(1, n - 1);\n            int j = rnd.next(i + 1, n);\n            swap(a[i], a[j]);\n        }\n    } else if (type == \"almost_sorted\") {\n        /* Array is almost sorted, with several elements swapped */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        int num_swaps = max(1, n / 10); // Swap 10% of elements\n        for (int k = 0; k < num_swaps; ++k) {\n            int i = rnd.next(1, n);\n            int j = rnd.next(1, n);\n            while (i == j) j = rnd.next(1, n);\n            swap(a[i], a[j]);\n        }\n    } else if (type == \"anti_prime_gap\") {\n        /* Construct an array that may require swaps of large prime gaps */\n        if (n % 2 != 0) {\n            fprintf(stderr, \"Error: n must be even for type anti_prime_gap\\n\");\n            exit(1);\n        }\n        int mid = n / 2;\n        for (int i = 1; i <= mid; ++i)\n            a[i] = mid + i;\n        for (int i = mid + 1; i <= n; ++i)\n            a[i] = i - mid;\n    } else {\n        /* Default to random */\n        for (int i = 1; i <= n; ++i)\n            a[i] = i;\n        shuffle(a.begin() + 1, a.end());\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the array */\n    for (int i = 1; i <= n; ++i)\n        printf(\"%d%c\", a[i], i == n ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, test edge cases\n./gen -n 1 -type sorted\n./gen -n 1 -type reversed\n./gen -n 1 -type random\n\n./gen -n 2 -type sorted\n./gen -n 2 -type reversed\n./gen -n 2 -type single_swap\n\n./gen -n 3 -type sorted\n./gen -n 3 -type reversed\n./gen -n 3 -type random\n\n./gen -n 10 -type sorted\n./gen -n 10 -type reversed\n./gen -n 10 -type random\n./gen -n 10 -type single_swap\n\n# Medium n\n./gen -n 100 -type sorted\n./gen -n 100 -type reversed\n./gen -n 100 -type random\n./gen -n 100 -type single_swap\n./gen -n 100 -type almost_sorted\n\n# Larger n\n./gen -n 1000 -type sorted\n./gen -n 1000 -type reversed\n./gen -n 1000 -type random\n./gen -n 1000 -type single_swap\n./gen -n 1000 -type almost_sorted\n\n# Large n\n./gen -n 99999 -type sorted\n./gen -n 99999 -type reversed\n./gen -n 99999 -type random\n./gen -n 99999 -type single_swap\n./gen -n 99999 -type almost_sorted\n\n# Maximum n\n./gen -n 100000 -type sorted\n./gen -n 100000 -type reversed\n./gen -n 100000 -type random\n./gen -n 100000 -type single_swap\n./gen -n 100000 -type almost_sorted\n\n# Special case: anti_prime_gap (n must be even)\n./gen -n 100000 -type anti_prime_gap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:16.421927",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "432/D",
      "title": "D. Префиксы и суффиксы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке записана последовательность символов s1s2...s|s| (1 ≤ |s| ≤ 105) — строка s. Строка состоит только из больших букв латинского алфавита.",
      "output_spec": "Выходные данныеВ первой строке выведите целое число k (0 ≤ k ≤ |s|) — количество префиксов, которые совпадают с суффиксом строки s. Далее выведите k строк, в каждой строке выведите два целых числа li ci. Числа li ci обозначают, что префикс длины li совпадает с суффиксом длины li и встречается в строке s в качестве подстроки ci раз. Пары li ci выводите в порядке возрастания li.",
      "sample_tests": "ПримерыВходные данныеСкопироватьABACABAВыходные данныеСкопировать31 43 27 1Входные данныеСкопироватьAAAВыходные данныеСкопировать31 32 23 1",
      "description": "D. Префиксы и суффиксы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ единственной строке записана последовательность символов s1s2...s|s| (1 ≤ |s| ≤ 105) — строка s. Строка состоит только из больших букв латинского алфавита.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число k (0 ≤ k ≤ |s|) — количество префиксов, которые совпадают с суффиксом строки s. Далее выведите k строк, в каждой строке выведите два целых числа li ci. Числа li ci обозначают, что префикс длины li совпадает с суффиксом длины li и встречается в строке s в качестве подстроки ci раз. Пары li ci выводите в порядке возрастания li.\n\nВыходные данные\n\nВходные данныеСкопироватьABACABAВыходные данныеСкопировать31 43 27 1Входные данныеСкопироватьAAAВыходные данныеСкопировать31 32 23 1\n\nВходные данныеСкопироватьABACABA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 43 27 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопироватьAAA\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 32 23 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, codeforces)Приглашаем вас на очередной раунд Codeforces #246 для участников Div. 2. Как всегда, участники Div. 1 могут поучаствовать в этом соревновании вне конкурса.Задачи для вас готовили авторы Павел Холкин (HolkinPV) и Геральд Агапов (Gerald). Уже не первый и, определенно, не последний раз мы стараемся для вас. Традиционно мы говорим слова благодарности Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод условий задач.UPD: Распределение баллов по задачам будет стандартным — 500-1000-1500-2000-2500.Желаем всем участникам удачи и удовольствия от решения задач)UPD2: Соревнование завершилось, надеемся оно вам понравилось)UPD3: А вот и ссылка на разбор задачПоздравляем победителей!:1) PopovkinAndrey2) FTD20093) Gulan14no4) Kozakai_Aya5) Mikael",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12298",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 846
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "432A - Выбор командВ этой задаче нужно было посчитать количество студентов, которые еще могут участвовать в ACM ICPC, поделить его на три и округлить вниз. Это можно сделать так: int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n if (5 - a[i] >= k)\n cnt++;\n\nint ans = cnt / 3;432B - Футбольная формаПосчитаем для каждой команды количество матчей в домашней форме. Для команды i это количество равно сумме числа всех домашних n - 1 игр и гостевых игр с такими команды, у которых цвет домашней формы совпадает с цветом гостевой формы команды i. Чтобы посчитать количество таких гостевых игр, можно заранее предпосчитать количество команд с определенным цветом домашней формы. Итоговое решение будет выглядеть примерно так: for(int i = 0; i < n; i++)\n cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n ans_home[i] = n - 1;\n ans_home[i] += cnt[ y[i] ];\n\n ans_away[i] = 2 * (n - 1) - ans_home[i];\n}432C - Простые обменыРешение этой задачи можно описать следующим псевдо-кодом: Перебираем элементы перестановки от 1 до n Пока текущий элемент i не находится на позиции i Пусть текущая позиция элемента i равна pos Найти наибольшее простое меньшее либо равное pos - i + 1, обозначим его p Поменять местами элементы в позициях pos и pos - p + 1 Можно доказать, что данный алгоритм всегда будет совершать не более 4n обменов. Проще всего это сделать, если написать код, который находит максимальное количество итераций цикла <ПОКА> для всех возможных pos - i.Кроме всего прочего данный алгоритм нужно было реализовать оптимально. А именно поддерживать позиции элементов перестановки. В авторском решении была следующая функция: void doSwap(int i, int j){\n int x = a[i], y = a[j];\n a[j] = x, pos[x] = j;\n a[i] = y, pos[y] = i;\n result.push_back(make_pair(i, j));\n}432D - Префиксы и суффиксыСуществует много решений этой задачи. Мы опишем решение, которое использует префикс функцию. Построим префикс функцию p строки s. Далее построим дерево, вершины которого — числа от 0 до |s|, а ребра идут из p[i] в i для каждого i. Корень дерева — это вершина 0. Далее для каждого v посчитаем сколько значений p[i] = v, обозначим его за cnt[v]. А затем для каждого v посчитаем сумму sum[v] всех cnt[u], где вершина u находится в поддереве вершины v.Ответ на задачу считается считается следующим образом:Найдем все длины префиксов, которые совпадают с суффиксами — это значения |s|, p[|s|], p[p[|s|]], p[p[p[|s|]]]... Для каждой такой длины L количество вхождений соответствующего префикса в строку это sum[L] + 1.432E - Замощение квадратамиРазбор по задаче Е будет чуть позже, а пока всем понравившийся тест номер 6 :) 13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABBБудем решать задачу стандартным методом — то есть будем заполнять таблицу от более значащих клеток к менее значащим. В каждую клетку будем стараться ставить букву как можно меньше. Рассмотрим самую первую строку, понятно, что оптимальная раскраска этой строки начинается с нескольких букв A. На самом деле букв A в начале этой строки должно быть min(n, m). Поставив нужные буквы A в эту строку, мы должны поставить буквы A и в другие строки, чтобы образовать квадрат. Следующая буква (после закраски первого квадрата из A) в первой строке может быть только B.Попробуем построить более общий алгоритм решения задачи. Предположим, что мы уже рассмотрели несколько строк, и теперь рассматриваем строку i. Вполне вероятно, что в нашей таблице в строке i некоторые клетки уже закрашены. Будем итерироваться по незакрашенным клеткам в порядке слева направо. Для каждой клетки будет перебирать ее цвет от A до Z. Нужно рассмотреть два случая: Поставить в текущую клетку наименьшую букву, такую, что в соседних клетках нет такой буквы. Если предыдущая клетка в строке была свободна на момент начала покраски i-й строки, то мы ее уже покрасили в какой-то цвет. Нужно попробовать объединить текущую клетку с квадратом, в котором находится предыдущая клетка. Из двух описанных вариантов нужно выбрать тот, в котором цвет клетки получается меньше. Чтобы лучше понять, как должен работать алгоритм разберите его работу на примере n = 13 m = 5",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12310",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 432\\s*D"
          },
          "content_length": 4096
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "The answer should only consist of A,B and C. If your anwser has letter D or others your solution is 100% wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "while (!z.empty() && !z[0]) z.erase(z.begin());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "while (!z.empty() && !z[0]) z.erase(z.begin());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "3 6\nAAABAA\nAAACAA\nAAABCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "3 6\nAAABAA\nAAACAA\nAAABCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "10 6\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nBBBBCB\nBBBBAA\nBBBBAA\nBBBBCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 9",
          "code": "10 6\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nBBBBCB\nBBBBAA\nBBBBAA\nBBBBCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 10",
          "code": "for every i from 1 to n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 11",
          "code": "O(5 n log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 13",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 14",
          "code": "z[N - len] == len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n    if (5 - a[i] >= k)\n        cnt++;\n\nint ans = cnt / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = 0; i < n; i++)\n    cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n    ans_home[i] = n - 1;\n    ans_home[i] += cnt[ y[i] ];\n\n    ans_away[i] = 2 * (n - 1) - ans_home[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "void doSwap(int i, int j){\n    int x = a[i], y = a[j];\n    a[j] = x, pos[x] = j;\n    a[i] = y, pos[y] = i;\n    result.push_back(make_pair(i, j));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "4\n1 3\n3 4\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "4\n1 3\n3 4\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "wrong answer In the end array should be sorted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "wrong answer In the end array should be sorted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 9",
          "code": "432A - Выбор команд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 10",
          "code": "432A - Выбор команд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a,b[1111],b1,c=0,d;\n    cin>>a>>b1;\n    int q=a;\n    for(int i=1;i<=a;i++)\n    {\n        cin>>b[i];\n        d=b[i]+b1;\n        if(d<=5)c++;\n    }\n    cout<<c/3;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a,b[1111],b1,c=0,d;\n    cin>>a>>b1;\n    int q=a;\n    for(int i=1;i<=a;i++)\n    {\n        cin>>b[i];\n        d=b[i]+b1;\n        if(d<=5)c++;\n    }\n    cout<<c/3;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]+\", \"s\");\n    ensuref(1 <= s.length() && s.length() <= 100000, \"Length of s must be between 1 and 100000, but s.length()=%d\", (int)s.length());\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]+\", \"s\");\n    ensuref(1 <= s.length() && s.length() <= 100000, \"Length of s must be between 1 and 100000, but s.length()=%d\", (int)s.length());\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[A-Z]+\", \"s\");\n    ensuref(1 <= s.length() && s.length() <= 100000, \"Length of s must be between 1 and 100000, but s.length()=%d\", (int)s.length());\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate random uppercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"same_char\") {\n        // All the same character\n        char c = 'A' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        string half;\n        for (int i = 0; i < n / 2; ++i) {\n            char c = 'A' + rnd.next(26);\n            half += c;\n        }\n        s = half;\n        if (n % 2 == 1) {\n            char c = 'A' + rnd.next(26);\n            s += c;\n        }\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (type == \"repeating_pattern\") {\n        // Generate a string by repeating a random pattern\n        int pattern_length = opt<int>(\"pattern_length\", 1);\n        ensure(pattern_length >= 1 && pattern_length <= n);\n        string pattern;\n        for (int i = 0; i < pattern_length; ++i) {\n            char c = 'A' + rnd.next(26);\n            pattern += c;\n        }\n        while ((int)s.size() < n) {\n            s += pattern;\n        }\n        s = s.substr(0, n);\n    } else if (type == \"prefix_suffix_overlap\") {\n        // Generate a string where prefixes and suffixes overlap significantly\n        int t_length = opt<int>(\"t_length\", n / 2);\n        ensure(t_length >= 1 && t_length <= n / 2);\n        string t;\n        for (int i = 0; i < t_length; ++i) {\n            char c = 'A' + rnd.next(26);\n            t += c;\n        }\n        int middle_length = n - 2 * t_length;\n        ensure(middle_length >= 0);\n        string middle;\n        for (int i = 0; i < middle_length; ++i) {\n            char c = 'A' + rnd.next(26);\n            middle += c;\n        }\n        s = t + middle + t;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            s += c;\n        }\n    }\n    ensure((int)s.size() == n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate random uppercase letters\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"same_char\") {\n        // All the same character\n        char c = 'A' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"palindrome\") {\n        // Generate a palindrome\n        string half;\n        for (int i = 0; i < n / 2; ++i) {\n            char c = 'A' + rnd.next(26);\n            half += c;\n        }\n        s = half;\n        if (n % 2 == 1) {\n            char c = 'A' + rnd.next(26);\n            s += c;\n        }\n        reverse(half.begin(), half.end());\n        s += half;\n    } else if (type == \"repeating_pattern\") {\n        // Generate a string by repeating a random pattern\n        int pattern_length = opt<int>(\"pattern_length\", 1);\n        ensure(pattern_length >= 1 && pattern_length <= n);\n        string pattern;\n        for (int i = 0; i < pattern_length; ++i) {\n            char c = 'A' + rnd.next(26);\n            pattern += c;\n        }\n        while ((int)s.size() < n) {\n            s += pattern;\n        }\n        s = s.substr(0, n);\n    } else if (type == \"prefix_suffix_overlap\") {\n        // Generate a string where prefixes and suffixes overlap significantly\n        int t_length = opt<int>(\"t_length\", n / 2);\n        ensure(t_length >= 1 && t_length <= n / 2);\n        string t;\n        for (int i = 0; i < t_length; ++i) {\n            char c = 'A' + rnd.next(26);\n            t += c;\n        }\n        int middle_length = n - 2 * t_length;\n        ensure(middle_length >= 0);\n        string middle;\n        for (int i = 0; i < middle_length; ++i) {\n            char c = 'A' + rnd.next(26);\n            middle += c;\n        }\n        s = t + middle + t;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'A' + rnd.next(26);\n            s += c;\n        }\n    }\n    ensure((int)s.size() == n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type palindrome\n./gen -n 3 -type same_char\n\n./gen -n 10 -type random\n./gen -n 10 -type palindrome\n./gen -n 10 -type repeating_pattern -pattern_length 2\n./gen -n 10 -type repeating_pattern -pattern_length 3\n./gen -n 10 -type prefix_suffix_overlap -t_length 3\n\n./gen -n 100 -type random\n./gen -n 100 -type same_char\n./gen -n 100 -type palindrome\n./gen -n 100 -type repeating_pattern -pattern_length 5\n./gen -n 100 -type prefix_suffix_overlap -t_length 50\n\n./gen -n 1000 -type random\n./gen -n 1000 -type palindrome\n./gen -n 1000 -type repeating_pattern -pattern_length 10\n./gen -n 1000 -type prefix_suffix_overlap -t_length 500\n\n./gen -n 10000 -type random\n./gen -n 10000 -type same_char\n./gen -n 10000 -type palindrome\n\n./gen -n 100000 -type random\n./gen -n 100000 -type palindrome\n./gen -n 100000 -type repeating_pattern -pattern_length 1000\n./gen -n 100000 -type prefix_suffix_overlap -t_length 50000\n\n./gen -n 99999 -type repeating_pattern -pattern_length 33333\n\n./gen -n 80000 -type same_char\n\n./gen -n 50000 -type repeating_pattern -pattern_length 1\n./gen -n 50000 -type repeating_pattern -pattern_length 2\n./gen -n 50000 -type repeating_pattern -pattern_length 25000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:18.449918",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "432/E",
      "title": "E. Замощение квадратами",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 100).",
      "output_spec": "Выходные данныеВыведите лексикографически минимальную раскраску таблицы, удовлетворяющую описанным условиям. Одна раскраска (обозначим ее X) считается лексикографически меньше другой (обозначим ее Y), если:  будем рассматривать клетки таблицы в порядке слева направо, сверху вниз (сначала самая первая клетка в первой строке, затем вторая клетка в первой строке и так далее);  найдем первую клетку в таком порядке, цвет которой в двух раскрасках отличается;  буква, обозначающая цвет этой клетки в X, идет раньше в алфавите, чем буква, обозначающая цвет этой клетки в Y.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 3Выходные данныеСкопироватьABAВходные данныеСкопировать2 2Выходные данныеСкопироватьAAAAВходные данныеСкопировать3 4Выходные данныеСкопироватьAAABAAACAAAB",
      "description": "E. Замощение квадратами\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n, m ≤ 100).\n\nВходные данные\n\nВыходные данныеВыведите лексикографически минимальную раскраску таблицы, удовлетворяющую описанным условиям. Одна раскраска (обозначим ее X) считается лексикографически меньше другой (обозначим ее Y), если:  будем рассматривать клетки таблицы в порядке слева направо, сверху вниз (сначала самая первая клетка в первой строке, затем вторая клетка в первой строке и так далее);  найдем первую клетку в таком порядке, цвет которой в двух раскрасках отличается;  буква, обозначающая цвет этой клетки в X, идет раньше в алфавите, чем буква, обозначающая цвет этой клетки в Y.\n\nВыходные данные\n\nВходные данныеСкопировать1 3Выходные данныеСкопироватьABAВходные данныеСкопировать2 2Выходные данныеСкопироватьAAAAВходные данныеСкопировать3 4Выходные данныеСкопироватьAAABAAACAAAB\n\nВходные данныеСкопировать1 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьABA\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAAAA\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьAAABAAACAAAB\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "Доброго времени суток, codeforces)Приглашаем вас на очередной раунд Codeforces #246 для участников Div. 2. Как всегда, участники Div. 1 могут поучаствовать в этом соревновании вне конкурса.Задачи для вас готовили авторы Павел Холкин (HolkinPV) и Геральд Агапов (Gerald). Уже не первый и, определенно, не последний раз мы стараемся для вас. Традиционно мы говорим слова благодарности Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод условий задач.UPD: Распределение баллов по задачам будет стандартным — 500-1000-1500-2000-2500.Желаем всем участникам удачи и удовольствия от решения задач)UPD2: Соревнование завершилось, надеемся оно вам понравилось)UPD3: А вот и ссылка на разбор задачПоздравляем победителей!:1) PopovkinAndrey2) FTD20093) Gulan14no4) Kozakai_Aya5) Mikael",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12298",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 846
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces",
          "content": "432A - Выбор командВ этой задаче нужно было посчитать количество студентов, которые еще могут участвовать в ACM ICPC, поделить его на три и округлить вниз. Это можно сделать так: int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n if (5 - a[i] >= k)\n cnt++;\n\nint ans = cnt / 3;432B - Футбольная формаПосчитаем для каждой команды количество матчей в домашней форме. Для команды i это количество равно сумме числа всех домашних n - 1 игр и гостевых игр с такими команды, у которых цвет домашней формы совпадает с цветом гостевой формы команды i. Чтобы посчитать количество таких гостевых игр, можно заранее предпосчитать количество команд с определенным цветом домашней формы. Итоговое решение будет выглядеть примерно так: for(int i = 0; i < n; i++)\n cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n ans_home[i] = n - 1;\n ans_home[i] += cnt[ y[i] ];\n\n ans_away[i] = 2 * (n - 1) - ans_home[i];\n}432C - Простые обменыРешение этой задачи можно описать следующим псевдо-кодом: Перебираем элементы перестановки от 1 до n Пока текущий элемент i не находится на позиции i Пусть текущая позиция элемента i равна pos Найти наибольшее простое меньшее либо равное pos - i + 1, обозначим его p Поменять местами элементы в позициях pos и pos - p + 1 Можно доказать, что данный алгоритм всегда будет совершать не более 4n обменов. Проще всего это сделать, если написать код, который находит максимальное количество итераций цикла <ПОКА> для всех возможных pos - i.Кроме всего прочего данный алгоритм нужно было реализовать оптимально. А именно поддерживать позиции элементов перестановки. В авторском решении была следующая функция: void doSwap(int i, int j){\n int x = a[i], y = a[j];\n a[j] = x, pos[x] = j;\n a[i] = y, pos[y] = i;\n result.push_back(make_pair(i, j));\n}432D - Префиксы и суффиксыСуществует много решений этой задачи. Мы опишем решение, которое использует префикс функцию. Построим префикс функцию p строки s. Далее построим дерево, вершины которого — числа от 0 до |s|, а ребра идут из p[i] в i для каждого i. Корень дерева — это вершина 0. Далее для каждого v посчитаем сколько значений p[i] = v, обозначим его за cnt[v]. А затем для каждого v посчитаем сумму sum[v] всех cnt[u], где вершина u находится в поддереве вершины v.Ответ на задачу считается считается следующим образом:Найдем все длины префиксов, которые совпадают с суффиксами — это значения |s|, p[|s|], p[p[|s|]], p[p[p[|s|]]]... Для каждой такой длины L количество вхождений соответствующего префикса в строку это sum[L] + 1.432E - Замощение квадратамиРазбор по задаче Е будет чуть позже, а пока всем понравившийся тест номер 6 :) 13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABBБудем решать задачу стандартным методом — то есть будем заполнять таблицу от более значащих клеток к менее значащим. В каждую клетку будем стараться ставить букву как можно меньше. Рассмотрим самую первую строку, понятно, что оптимальная раскраска этой строки начинается с нескольких букв A. На самом деле букв A в начале этой строки должно быть min(n, m). Поставив нужные буквы A в эту строку, мы должны поставить буквы A и в другие строки, чтобы образовать квадрат. Следующая буква (после закраски первого квадрата из A) в первой строке может быть только B.Попробуем построить более общий алгоритм решения задачи. Предположим, что мы уже рассмотрели несколько строк, и теперь рассматриваем строку i. Вполне вероятно, что в нашей таблице в строке i некоторые клетки уже закрашены. Будем итерироваться по незакрашенным клеткам в порядке слева направо. Для каждой клетки будет перебирать ее цвет от A до Z. Нужно рассмотреть два случая: Поставить в текущую клетку наименьшую букву, такую, что в соседних клетках нет такой буквы. Если предыдущая клетка в строке была свободна на момент начала покраски i-й строки, то мы ее уже покрасили в какой-то цвет. Нужно попробовать объединить текущую клетку с квадратом, в котором находится предыдущая клетка. Из двух описанных вариантов нужно выбрать тот, в котором цвет клетки получается меньше. Чтобы лучше понять, как должен работать алгоритм разберите его работу на примере n = 13 m = 5",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12310",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 432\\s*E"
          },
          "content_length": 4096
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "puts(\"Good luck to everybody here that's gonna enter the cf contest.\");\nputs(\"I hope you'll all upgrade to International. Grandmaster.\");",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "The answer should only consist of A,B and C. If your anwser has letter D or others your solution is 100% wrong.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "while (!z.empty() && !z[0]) z.erase(z.begin());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "while (!z.empty() && !z[0]) z.erase(z.begin());",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "3 6\nAAABAA\nAAACAA\nAAABCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "3 6\nAAABAA\nAAACAA\nAAABCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "10 6\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nBBBBCB\nBBBBAA\nBBBBAA\nBBBBCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 9",
          "code": "10 6\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nBBBBCB\nBBBBAA\nBBBBAA\nBBBBCB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 10",
          "code": "for every i from 1 to n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 11",
          "code": "O(5 n log(n))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 12",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 13",
          "code": "for(int i = N; i; -- i)\n{\n    Nr[i] ++;\n    Nr[Prefix[i]] += Nr[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #246 (Div. 2) - Codeforces - Code 14",
          "code": "z[N - len] == len",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12298",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 1",
          "code": "int cnt = 0;\n\nfor(int i = 0; i < n; i++)\n    if (5 - a[i] >= k)\n        cnt++;\n\nint ans = cnt / 3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 2",
          "code": "for(int i = 0; i < n; i++)\n    cnt[ x[i] ]++;\n\nfor(int i = 0; i < n; i++)\n{\n    ans_home[i] = n - 1;\n    ans_home[i] += cnt[ y[i] ];\n\n    ans_away[i] = 2 * (n - 1) - ans_home[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 3",
          "code": "void doSwap(int i, int j){\n    int x = a[i], y = a[j];\n    a[j] = x, pos[x] = j;\n    a[i] = y, pos[y] = i;\n    result.push_back(make_pair(i, j));\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 4",
          "code": "13 5\n\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nBBBBB\nAAACA\nAAABB\nAAABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 5",
          "code": "4\n1 3\n3 4\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 6",
          "code": "4\n1 3\n3 4\n2 3\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 7",
          "code": "wrong answer In the end array should be sorted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 8",
          "code": "wrong answer In the end array should be sorted",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 9",
          "code": "432A - Выбор команд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 10",
          "code": "432A - Выбор команд",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 11",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a,b[1111],b1,c=0,d;\n    cin>>a>>b1;\n    int q=a;\n    for(int i=1;i<=a;i++)\n    {\n        cin>>b[i];\n        d=b[i]+b1;\n        if(d<=5)c++;\n    }\n    cout<<c/3;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #246 (Div. 2) - Codeforces - Code 12",
          "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    int a,b[1111],b1,c=0,d;\n    cin>>a>>b1;\n    int q=a;\n    for(int i=1;i<=a;i++)\n    {\n        cin>>b[i];\n        d=b[i]+b1;\n        if(d<=5)c++;\n    }\n    cout<<c/3;\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12310",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        n = 100;\n        m = 100;\n    } else if (type == \"min\") {\n        n = 1;\n        m = 1;\n    } else if (type == \"n1\") {\n        n = 1;\n        if (m == -1) m = rnd.next(1, 100);\n    } else if (type == \"m1\") {\n        m = 1;\n        if (n == -1) n = rnd.next(1, 100);\n    } else if (type == \"square\") {\n        if (n == -1) n = rnd.next(1, 100);\n        m = n;\n    } else if (type == \"rectangle\") {\n        if (n == -1) n = rnd.next(2, 100);\n        if (m == -1) {\n            int max_m = n - 1;\n            m = rnd.next(1, max_m);\n        }\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(1, 100);\n    } else if (type == \"odd\") {\n        if (n == -1) n = rnd.next(1, 100) | 1; // make n odd\n        else n = n | 1;\n        if (m == -1) m = rnd.next(1, 100) | 1; // make m odd\n        else m = m | 1;\n    } else if (type == \"even\") {\n        if (n == -1) n = rnd.next(1, 100) & ~1; // make n even\n        else n = n & ~1;\n        if (n == 0) n = 2;\n        if (m == -1) m = rnd.next(1, 100) & ~1; // make m even\n        else m = m & ~1;\n        if (m == 0) m = 2;\n    } else if (type == \"prime\") {\n        // List of primes up to 100\n        vector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\n        if (n == -1) n = primes[rnd.next(0, (int)primes.size()-1)];\n        if (m == -1) m = primes[rnd.next(0, (int)primes.size()-1)];\n    } else if (type == \"powerof2\") {\n        vector<int> powers = {1,2,4,8,16,32,64};\n        if (n == -1) n = powers[rnd.next(0, (int)powers.size()-1)];\n        if (m == -1) m = powers[rnd.next(0, (int)powers.size()-1)];\n    } else {\n        // Use provided n and m\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(1, 100);\n    }\n\n    // Ensure n and m within bounds\n    n = max(1, min(n, 100));\n    m = max(1, min(m, 100));\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        n = 100;\n        m = 100;\n    } else if (type == \"min\") {\n        n = 1;\n        m = 1;\n    } else if (type == \"n1\") {\n        n = 1;\n        if (m == -1) m = rnd.next(1, 100);\n    } else if (type == \"m1\") {\n        m = 1;\n        if (n == -1) n = rnd.next(1, 100);\n    } else if (type == \"square\") {\n        if (n == -1) n = rnd.next(1, 100);\n        m = n;\n    } else if (type == \"rectangle\") {\n        if (n == -1) n = rnd.next(2, 100);\n        if (m == -1) {\n            int max_m = n - 1;\n            m = rnd.next(1, max_m);\n        }\n    } else if (type == \"random\") {\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(1, 100);\n    } else if (type == \"odd\") {\n        if (n == -1) n = rnd.next(1, 100) | 1; // make n odd\n        else n = n | 1;\n        if (m == -1) m = rnd.next(1, 100) | 1; // make m odd\n        else m = m | 1;\n    } else if (type == \"even\") {\n        if (n == -1) n = rnd.next(1, 100) & ~1; // make n even\n        else n = n & ~1;\n        if (n == 0) n = 2;\n        if (m == -1) m = rnd.next(1, 100) & ~1; // make m even\n        else m = m & ~1;\n        if (m == 0) m = 2;\n    } else if (type == \"prime\") {\n        // List of primes up to 100\n        vector<int> primes = {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};\n        if (n == -1) n = primes[rnd.next(0, (int)primes.size()-1)];\n        if (m == -1) m = primes[rnd.next(0, (int)primes.size()-1)];\n    } else if (type == \"powerof2\") {\n        vector<int> powers = {1,2,4,8,16,32,64};\n        if (n == -1) n = powers[rnd.next(0, (int)powers.size()-1)];\n        if (m == -1) m = powers[rnd.next(0, (int)powers.size()-1)];\n    } else {\n        // Use provided n and m\n        if (n == -1) n = rnd.next(1, 100);\n        if (m == -1) m = rnd.next(1, 100);\n    }\n\n    // Ensure n and m within bounds\n    n = max(1, min(n, 100));\n    m = max(1, min(m, 100));\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n\n./gen -type max\n\n./gen -type n1\n\n./gen -type m1\n\n./gen -type square\n\n./gen -type square\n\n./gen -type rectangle\n\n./gen -type rectangle\n\n./gen -type odd\n\n./gen -type even\n\n./gen -type prime\n\n./gen -type prime\n\n./gen -type powerof2\n\n./gen -type powerof2\n\n./gen -n 1 -m 1\n\n./gen -n 2 -m 2\n\n./gen -n 99 -m 99\n\n./gen -n 100 -m 100\n\n./gen -n 1 -m 100\n\n./gen -n 100 -m 1\n\n./gen -n 50 -m 50\n\n./gen -n 3 -m 4\n\n./gen -n 1 -m 3\n\n./gen -n 2 -m 2\n\n./gen -n 2 -m 3\n\n./gen -n 3 -m 2\n\n./gen -n 100 -m 100 -type odd\n\n./gen -n 100 -m 100 -type even\n\n./gen -n 97 -m 97 -type prime\n\n./gen -n 64 -m 64 -type powerof2\n\n./gen -n 99 -m 100\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:20.380215",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "433/A",
      "title": "A. Kitahara Haruki's Gift",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 100) — the number of apples. The second line contains n integers w1, w2, ..., wn (wi = 100 or wi = 200), where wi is the weight of the i-th apple.",
      "output_spec": "OutputIn a single line print \"YES\" (without the quotes) if it is possible to divide all the apples between his friends. Otherwise print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy3100 200 100OutputCopyYESInputCopy4100 100 100 200OutputCopyNO",
      "description": "A. Kitahara Haruki's Gift\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 100) — the number of apples. The second line contains n integers w1, w2, ..., wn (wi = 100 or wi = 200), where wi is the weight of the i-th apple.\n\nOutputIn a single line print \"YES\" (without the quotes) if it is possible to divide all the apples between his friends. Otherwise print \"NO\" (without the quotes).\n\nInputCopy3100 200 100OutputCopyYESInputCopy4100 100 100 200OutputCopyNO\n\nInputCopy3100 200 100\n\nOutputCopyYES\n\nInputCopy4100 100 100 200\n\nOutputCopyNO\n\nNoteIn the first test sample Kitahara Haruki can give the first and the last apple to Ogiso Setsuna and the middle apple to Touma Kazusa.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 100, 200);\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(w[i] == 100 || w[i] == 200, \"Each wi must be 100 or 200, but wi[%d] = %d\", i+1, w[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 100, 200);\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(w[i] == 100 || w[i] == 200, \"Each wi must be 100 or 200, but wi[%d] = %d\", i+1, w[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    vector<int> w = inf.readInts(n, 100, 200);\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(w[i] == 100 || w[i] == 200, \"Each wi must be 100 or 200, but wi[%d] = %d\", i+1, w[i]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // n is between 1 and 100 inclusive\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> wi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(2) ? 100 : 200;\n        }\n    } else if (type == \"only100\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n    } else if (type == \"only200\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 200;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = (i % 2 == 0) ? 100 : 200;\n        }\n    } else if (type == \"yes\") {\n        // Generate a test case where the answer is YES.\n        int num100 = n / 2;\n        int num200 = n - num100;\n\n        // Adjust to make total weight even\n        int total_weight = 100 * num100 + 200 * num200;\n        if ((total_weight / 100) % 2 != 0) {\n            if (num100 > 0) {\n                num100--;\n            } else if (num200 > 0) {\n                num200--;\n            }\n            n = num100 + num200;\n            wi.resize(n);\n        }\n\n        for (int i = 0; i < num100; ++i) {\n            wi[i] = 100;\n        }\n        for (int i = num100; i < n; ++i) {\n            wi[i] = 200;\n        }\n\n    } else if (type == \"no\") {\n        // Generate a test case where the answer is NO.\n        if (n < 3) {\n            n = 3;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n\n        // Ensure total weight cannot be split into two equal sums\n        if (((100 * n) / 100) % 2 == 0) {\n            wi[0] = 200;\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a test case where total weight is even but cannot be partitioned\n        if (n < 3) {\n            n = 3;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n    } else if (type == \"sum_odd\") {\n        // Generate a test case where total weight divided by 100 is odd\n        if (n % 2 == 0) {\n            n += 1;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n    } else if (type == \"edge\") {\n        // Edge cases with n = 1 or n = 100\n        if (n != 1 && n != 100) {\n            n = 100;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(2) ? 100 : 200;\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n and weights\n    n = wi.size();\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%s\", wi[i], (i + 1 == n) ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // n is between 1 and 100 inclusive\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> wi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(2) ? 100 : 200;\n        }\n    } else if (type == \"only100\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n    } else if (type == \"only200\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 200;\n        }\n    } else if (type == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            wi[i] = (i % 2 == 0) ? 100 : 200;\n        }\n    } else if (type == \"yes\") {\n        // Generate a test case where the answer is YES.\n        int num100 = n / 2;\n        int num200 = n - num100;\n\n        // Adjust to make total weight even\n        int total_weight = 100 * num100 + 200 * num200;\n        if ((total_weight / 100) % 2 != 0) {\n            if (num100 > 0) {\n                num100--;\n            } else if (num200 > 0) {\n                num200--;\n            }\n            n = num100 + num200;\n            wi.resize(n);\n        }\n\n        for (int i = 0; i < num100; ++i) {\n            wi[i] = 100;\n        }\n        for (int i = num100; i < n; ++i) {\n            wi[i] = 200;\n        }\n\n    } else if (type == \"no\") {\n        // Generate a test case where the answer is NO.\n        if (n < 3) {\n            n = 3;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n\n        // Ensure total weight cannot be split into two equal sums\n        if (((100 * n) / 100) % 2 == 0) {\n            wi[0] = 200;\n        }\n\n    } else if (type == \"impossible\") {\n        // Generate a test case where total weight is even but cannot be partitioned\n        if (n < 3) {\n            n = 3;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n    } else if (type == \"sum_odd\") {\n        // Generate a test case where total weight divided by 100 is odd\n        if (n % 2 == 0) {\n            n += 1;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 100;\n        }\n    } else if (type == \"edge\") {\n        // Edge cases with n = 1 or n = 100\n        if (n != 1 && n != 100) {\n            n = 100;\n            wi.resize(n);\n        }\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(2) ? 100 : 200;\n        }\n    } else {\n        // Unknown type\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n and weights\n    n = wi.size();\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%s\", wi[i], (i + 1 == n) ? \"\\n\" : \" \");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type yes\n./gen -n 1 -type no\n./gen -n 1 -type random\n\n./gen -n 2 -type yes\n./gen -n 2 -type no\n./gen -n 2 -type random\n\n./gen -n 3 -type yes\n./gen -n 3 -type no\n./gen -n 3 -type impossible\n\n./gen -n 4 -type yes\n./gen -n 4 -type no\n./gen -n 4 -type random\n\n./gen -n 10 -type yes\n./gen -n 10 -type no\n./gen -n 10 -type only100\n./gen -n 10 -type only200\n./gen -n 10 -type alternating\n\n./gen -n 20 -type random\n./gen -n 20 -type yes\n./gen -n 20 -type no\n\n./gen -n 50 -type only100\n./gen -n 50 -type only200\n./gen -n 50 -type alternating\n\n./gen -n 60 -type yes\n./gen -n 60 -type no\n\n./gen -n 70 -type random\n./gen -n 70 -type edge\n\n./gen -n 98 -type sum_odd\n\n./gen -n 99 -type impossible\n./gen -n 99 -type no\n\n./gen -n 100 -type random\n./gen -n 100 -type yes\n./gen -n 100 -type no\n./gen -n 100 -type only100\n./gen -n 100 -type only200\n./gen -n 100 -type alternating\n./gen -n 100 -type edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:23.029724",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "433/B",
      "title": "B. Kuriyama Mirai's Stones",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 105). The second line contains n integers: v1, v2, ..., vn (1 ≤ vi ≤ 109) — costs of the stones. The third line contains an integer m (1 ≤ m ≤ 105) — the number of Kuriyama Mirai's questions. Then follow m lines, each line contains three integers type, l and r (1 ≤ l ≤ r ≤ n; 1 ≤ type ≤ 2), describing a question. If type equal to 1, then you should output the answer for the first question, else you should output the answer for the second one.",
      "output_spec": "OutputPrint m lines. Each line must contain an integer — the answer to Kuriyama Mirai's question. Print the answers to the questions in the order of input.",
      "sample_tests": "ExamplesInputCopy66 4 2 7 2 732 3 61 3 41 1 6OutputCopy24928InputCopy45 5 2 3101 2 42 1 41 1 12 1 42 1 21 1 11 3 31 1 31 4 41 2 2OutputCopy10155155521235",
      "description": "B. Kuriyama Mirai's Stones\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 105). The second line contains n integers: v1, v2, ..., vn (1 ≤ vi ≤ 109) — costs of the stones. The third line contains an integer m (1 ≤ m ≤ 105) — the number of Kuriyama Mirai's questions. Then follow m lines, each line contains three integers type, l and r (1 ≤ l ≤ r ≤ n; 1 ≤ type ≤ 2), describing a question. If type equal to 1, then you should output the answer for the first question, else you should output the answer for the second one.\n\nOutputPrint m lines. Each line must contain an integer — the answer to Kuriyama Mirai's question. Print the answers to the questions in the order of input.\n\nInputCopy66 4 2 7 2 732 3 61 3 41 1 6OutputCopy24928InputCopy45 5 2 3101 2 42 1 41 1 12 1 42 1 21 1 11 3 31 1 31 4 41 2 2OutputCopy10155155521235\n\nInputCopy66 4 2 7 2 732 3 61 3 41 1 6\n\nOutputCopy24928\n\nInputCopy45 5 2 3101 2 42 1 41 1 12 1 42 1 21 1 11 3 31 1 31 4 41 2 2\n\nOutputCopy10155155521235\n\nNotePlease note that the answers to the questions may overflow 32-bit integer type.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, 1, 1000000000, \"v_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, 1, 1000000000, \"v_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, 1, 1000000000, \"v_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++) {\n        int type = inf.readInt(1, 2, \"type\");\n        inf.readSpace();\n        int l = inf.readInt(1, n, \"l\");\n        inf.readSpace();\n        int r = inf.readInt(l, n, \"r\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long min_vi = opt<long long>(\"min_vi\", 1); // default min_vi = 1\n    long long max_vi = opt<long long>(\"max_vi\", 1000000000); // default max_vi = 1e9\n    string vi_type = opt<string>(\"vi_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate vi according to vi_type\n    vector<long long> vi(n);\n\n    if (vi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(min_vi, max_vi);\n        }\n    } else if (vi_type == \"equal\") {\n        long long val = min_vi;\n        for (int i = 0; i < n; ++i) {\n            vi[i] = val;\n        }\n    } else if (vi_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = min_vi + ((max_vi - min_vi) * i) / max(1, n - 1);\n        }\n    } else if (vi_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = max_vi - ((max_vi - min_vi) * i) / max(1, n - 1);\n        }\n    } else if (vi_type == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10);\n        }\n    } else if (vi_type == \"large\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1000000000 - 10, 1000000000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(min_vi, max_vi);\n        }\n    }\n\n    // Generate m queries according to query_type\n    vector<tuple<int, int, int>> queries(m);\n\n    if (query_type == \"type1\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(1, l, r);\n        }\n    } else if (query_type == \"type2\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(2, l, r);\n        }\n    } else if (query_type == \"full\") {\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"single\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"edge\") {\n        for (int i = 0; i < m; ++i) {\n            int l, r;\n            int chance = rnd.next(1, 3);\n            if (chance == 1) {\n                l = 1;\n                r = rnd.next(1, n);\n            } else if (chance == 2) {\n                l = rnd.next(1, n);\n                r = n;\n            } else {\n                l = 1;\n                r = n;\n            }\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"small\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n - 10);\n            int r = rnd.next(l, min(n, l + 10));\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"mixed\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output vi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", vi[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int type, l, r;\n        tie(type, l, r) = queries[i];\n        printf(\"%d %d %d\\n\", type, l, r);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    long long min_vi = opt<long long>(\"min_vi\", 1); // default min_vi = 1\n    long long max_vi = opt<long long>(\"max_vi\", 1000000000); // default max_vi = 1e9\n    string vi_type = opt<string>(\"vi_type\", \"random\");\n    string query_type = opt<string>(\"query_type\", \"random\");\n\n    // Generate vi according to vi_type\n    vector<long long> vi(n);\n\n    if (vi_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(min_vi, max_vi);\n        }\n    } else if (vi_type == \"equal\") {\n        long long val = min_vi;\n        for (int i = 0; i < n; ++i) {\n            vi[i] = val;\n        }\n    } else if (vi_type == \"increasing\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = min_vi + ((max_vi - min_vi) * i) / max(1, n - 1);\n        }\n    } else if (vi_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = max_vi - ((max_vi - min_vi) * i) / max(1, n - 1);\n        }\n    } else if (vi_type == \"small\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1, 10);\n        }\n    } else if (vi_type == \"large\") {\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(1000000000 - 10, 1000000000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            vi[i] = rnd.next(min_vi, max_vi);\n        }\n    }\n\n    // Generate m queries according to query_type\n    vector<tuple<int, int, int>> queries(m);\n\n    if (query_type == \"type1\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(1, l, r);\n        }\n    } else if (query_type == \"type2\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            queries[i] = make_tuple(2, l, r);\n        }\n    } else if (query_type == \"full\") {\n        for (int i = 0; i < m; ++i) {\n            int l = 1;\n            int r = n;\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"single\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = l;\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"edge\") {\n        for (int i = 0; i < m; ++i) {\n            int l, r;\n            int chance = rnd.next(1, 3);\n            if (chance == 1) {\n                l = 1;\n                r = rnd.next(1, n);\n            } else if (chance == 2) {\n                l = rnd.next(1, n);\n                r = n;\n            } else {\n                l = 1;\n                r = n;\n            }\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"small\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n - 10);\n            int r = rnd.next(l, min(n, l + 10));\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else if (query_type == \"mixed\") {\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i) {\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            int type = rnd.next(1, 2);\n            queries[i] = make_tuple(type, l, r);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output vi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld\", vi[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output queries\n    for (int i = 0; i < m; ++i) {\n        int type, l, r;\n        tie(type, l, r) = queries[i];\n        printf(\"%d %d %d\\n\", type, l, r);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -vi_type equal -query_type single\n\n./gen -n 2 -m 1 -vi_type increasing -query_type single\n\n./gen -n 3 -m 2 -vi_type decreasing -query_type type1\n\n./gen -n 10 -m 5 -vi_type small -query_type type1\n\n./gen -n 10 -m 5 -vi_type small -query_type type2\n\n./gen -n 10 -m 5 -vi_type random -min_vi 1 -max_vi 10 -query_type mixed\n\n./gen -n 100 -m 50 -vi_type equal -min_vi 1000000000 -query_type full\n\n./gen -n 1000 -m 1000 -vi_type random -query_type mixed\n\n./gen -n 1000 -m 1000 -vi_type small -query_type small\n\n./gen -n 1000 -m 1000 -vi_type large -query_type single\n\n./gen -n 10000 -m 10000 -vi_type increasing -query_type edge\n\n./gen -n 10000 -m 10000 -vi_type decreasing -query_type edge\n\n./gen -n 10000 -m 10000 -vi_type equal -min_vi 1000000000 -query_type full\n\n./gen -n 20000 -m 50000 -vi_type random -query_type mixed\n\n./gen -n 50000 -m 50000 -vi_type small -query_type small\n\n./gen -n 70000 -m 100000 -vi_type large -query_type single\n\n./gen -n 100000 -m 100000 -vi_type random -min_vi 1 -max_vi 1000000000 -query_type mixed\n\n./gen -n 100000 -m 100000 -vi_type increasing -query_type full\n\n./gen -n 100000 -m 100000 -vi_type decreasing -query_type full\n\n./gen -n 100000 -m 100000 -vi_type equal -min_vi 1000000000 -query_type edge\n\n./gen -n 100000 -m 100000 -vi_type small -query_type small\n\n./gen -n 100000 -m 100000 -vi_type random -min_vi 1 -max_vi 1000000000 -query_type mixed\n\n./gen -n 100000 -m 100000 -vi_type random -min_vi 1000000000 -max_vi 1000000000 -query_type mixed\n\n./gen -n 100000 -m 100000 -vi_type large -query_type single\n\n./gen -n 100000 -m 100000 -vi_type small -query_type type1\n\n./gen -n 100000 -m 100000 -vi_type small -query_type type2\n\n./gen -n 100000 -m 100000 -vi_type random -query_type type1\n\n./gen -n 100000 -m 100000 -vi_type random -query_type type2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:25.632352",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "433/C",
      "title": "C. Ryouko's Memory Note",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and m (1 ≤ n, m ≤ 105).The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).",
      "output_spec": "OutputPrint a single integer — the minimum number of pages Ryouko needs to turn.",
      "sample_tests": "ExamplesInputCopy4 61 2 3 4 3 2OutputCopy3InputCopy10 59 4 3 8 8OutputCopy6",
      "description": "C. Ryouko's Memory Note\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers n and m (1 ≤ n, m ≤ 105).The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).\n\nOutputPrint a single integer — the minimum number of pages Ryouko needs to turn.\n\nInputCopy4 61 2 3 4 3 2OutputCopy3InputCopy10 59 4 3 8 8OutputCopy6\n\nInputCopy4 61 2 3 4 3 2\n\nOutputCopy3\n\nInputCopy10 59 4 3 8 8\n\nOutputCopy6\n\nNoteIn the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.In the second sample, optimal solution is achieved by merging page 9 to 4.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(m, 1, n, \"a_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n\n    if (type == \"random\") {\n        for(int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, n);\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = val;\n    } else if (type == \"alternating\") {\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1) val2 = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (type == \"increasing\") {\n        if (n >= m) {\n            for(int i = 0; i < m; ++i)\n                a[i] = i + 1;\n        } else {\n            for(int i = 0; i < m; ++i)\n                a[i] = (i % n) + 1;\n        }\n    } else if (type == \"decreasing\") {\n        if (n >= m) {\n            for(int i = 0; i < m; ++i)\n                a[i] = n - i;\n        } else {\n            for(int i = 0; i < m; ++i)\n                a[i] = n - (i % n);\n        }\n    } else if (type == \"single_change\") {\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1) val2 = rnd.next(1, n);\n        int num_changes = opt<int>(\"changes\", 1);\n        for(int i = 0; i < m; ++i)\n            a[i] = val1;\n        for(int i = 0; i < num_changes; ++i) {\n            int pos = rnd.next(0, m - 1);\n            a[pos] = val2;\n        }\n    } else if (type == \"max_turns\") {\n        for(int i = 0; i < m; ++i)\n            a[i] = (i % 2 == 0) ? 1 : n;\n    } else if (type == \"same_except_one\") {\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1) val2 = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = val1;\n        int pos = rnd.next(0, m - 1);\n        a[pos] = val2;\n    } else if (type == \"worst_merge\") {\n        // Create a scenario where the optimal merge is non-obvious\n        // Let's distribute the readings equally among k different pages\n        int k = opt<int>(\"k\", 10);\n        vector<int> pages;\n        for(int i = 0; i < k; ++i)\n            pages.push_back(rnd.next(1, n));\n        for(int i = 0; i < m; ++i)\n            a[i] = pages[i % k];\n    } else {\n        // Default random if type is unrecognized\n        for(int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, n);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < m; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == m - 1]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n\n    if (type == \"random\") {\n        for(int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, n);\n    } else if (type == \"all_same\") {\n        int val = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = val;\n    } else if (type == \"alternating\") {\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1) val2 = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = (i % 2 == 0) ? val1 : val2;\n    } else if (type == \"increasing\") {\n        if (n >= m) {\n            for(int i = 0; i < m; ++i)\n                a[i] = i + 1;\n        } else {\n            for(int i = 0; i < m; ++i)\n                a[i] = (i % n) + 1;\n        }\n    } else if (type == \"decreasing\") {\n        if (n >= m) {\n            for(int i = 0; i < m; ++i)\n                a[i] = n - i;\n        } else {\n            for(int i = 0; i < m; ++i)\n                a[i] = n - (i % n);\n        }\n    } else if (type == \"single_change\") {\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1) val2 = rnd.next(1, n);\n        int num_changes = opt<int>(\"changes\", 1);\n        for(int i = 0; i < m; ++i)\n            a[i] = val1;\n        for(int i = 0; i < num_changes; ++i) {\n            int pos = rnd.next(0, m - 1);\n            a[pos] = val2;\n        }\n    } else if (type == \"max_turns\") {\n        for(int i = 0; i < m; ++i)\n            a[i] = (i % 2 == 0) ? 1 : n;\n    } else if (type == \"same_except_one\") {\n        int val1 = rnd.next(1, n);\n        int val2 = rnd.next(1, n);\n        while (val2 == val1) val2 = rnd.next(1, n);\n        for(int i = 0; i < m; ++i)\n            a[i] = val1;\n        int pos = rnd.next(0, m - 1);\n        a[pos] = val2;\n    } else if (type == \"worst_merge\") {\n        // Create a scenario where the optimal merge is non-obvious\n        // Let's distribute the readings equally among k different pages\n        int k = opt<int>(\"k\", 10);\n        vector<int> pages;\n        for(int i = 0; i < k; ++i)\n            pages.push_back(rnd.next(1, n));\n        for(int i = 0; i < m; ++i)\n            a[i] = pages[i % k];\n    } else {\n        // Default random if type is unrecognized\n        for(int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, n);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < m; ++i)\n        printf(\"%d%c\", a[i], \" \\n\"[i == m - 1]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small input, all pages are the same\n./gen -n 1 -m 1 -type all_same\n\n# Small random input\n./gen -n 5 -m 5 -type random\n\n# Maximum input size with all pages the same\n./gen -n 100000 -m 100000 -type all_same\n\n# Maximum input size with random pages\n./gen -n 100000 -m 100000 -type random\n\n# Maximum input size with alternating pages\n./gen -n 100000 -m 100000 -type alternating\n\n# Maximum input size with increasing pages\n./gen -n 100000 -m 100000 -type increasing\n\n# Maximum input size with decreasing pages\n./gen -n 100000 -m 100000 -type decreasing\n\n# Single change in the readings, small number of changes\n./gen -n 100000 -m 100000 -type single_change -changes 10\n\n# Single change in the readings, large number of changes\n./gen -n 100000 -m 100000 -type single_change -changes 1000\n\n# Maximum page turns by alternating between first and last page\n./gen -n 100000 -m 100000 -type max_turns\n\n# Small number of pages, maximum readings, alternating pages\n./gen -n 2 -m 100000 -type alternating\n\n# Random pages with maximum input size\n./gen -n 100000 -m 100000 -type random\n\n# Single change in readings, only one change\n./gen -n 100000 -m 100000 -type single_change -changes 1\n\n# Single change in readings, changes in almost all positions\n./gen -n 100000 -m 100000 -type single_change -changes 99999\n\n# Edge case with only one reading\n./gen -n 100000 -m 1 -type random\n\n# Edge case with only one reading, all pages are the same\n./gen -n 100000 -m 1 -type all_same\n\n# Maximum input size, maximizing page turns with two pages\n./gen -n 2 -m 100000 -type max_turns\n\n# Medium-sized input with increasing pages\n./gen -n 1000 -m 1000 -type increasing\n\n# Medium-sized input with decreasing pages\n./gen -n 1000 -m 1000 -type decreasing\n\n# Medium-sized input with half of the readings changed\n./gen -n 1000 -m 1000 -type single_change -changes 500\n\n# Large number of readings with small number of pages\n./gen -n 10 -m 100000 -type random\n\n# Readings are the same except for one position\n./gen -n 100000 -m 100000 -type same_except_one\n\n# Test case designed where optimal merge is non-obvious\n./gen -n 100000 -m 100000 -type worst_merge -k 10\n\n# Another 'worst_merge' with different k value\n./gen -n 100000 -m 100000 -type worst_merge -k 50\n\n# All readings are randomly selected among a small subset of pages\n./gen -n 100000 -m 100000 -type worst_merge -k 5\n\n# Edge case where n = m = 1e5 and pages are maximum\n./gen -n 100000 -m 100000 -type max_turns\n\n# Random readings with small n\n./gen -n 5 -m 100000 -type random\n\n# Readings are between two pages with maximum distance apart\n./gen -n 100000 -m 100000 -type alternating\n\n# Edge case with m = 1\n./gen -n 100000 -m 1 -type random\n\n# Edge case with n = 1\n./gen -n 1 -m 100000 -type all_same\n\n# Edge case with n and m minimum\n./gen -n 1 -m 1 -type all_same\n\n# Default type (random) with maximum input size\n./gen -n 100000 -m 100000\n\n# Large input with readings that have a random walk pattern\n./gen -n 100000 -m 100000 -type random_walk\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:27.761534",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "433/D",
      "title": "D. Nanami's Digital Board",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three space-separated integers n, m and q (1 ≤ n, m, q ≤ 1000) — the height and width of the digital board, and the number of operations.Then follow n lines, each line containing m space-separated integers. The j-th integer of the i-th line is ai, j — the initial state of pixel (i, j).  If ai, j = 0, pixel (i, j) is initially dark.  If ai, j = 1, pixel (i, j) is initially light. Then follow q lines, each line containing three space-separated integers op, x, and y (1 ≤ op ≤ 2; 1 ≤ x ≤ n; 1 ≤ y ≤ m), describing an operation.  If op = 1, the pixel at (x, y) changes its state (from light to dark or from dark to light).  If op = 2, Nanami queries the biggest light block with pixel (x, y) on its side.",
      "output_spec": "OutputFor each query, print a single line containing one integer — the answer to Nanami's query.",
      "sample_tests": "ExamplesInputCopy3 4 50 1 1 01 0 0 10 1 1 02 2 22 1 21 2 21 2 32 2 2OutputCopy026InputCopy3 3 41 1 11 1 11 1 12 2 21 2 22 1 12 2 1OutputCopy633",
      "description": "D. Nanami's Digital Board\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three space-separated integers n, m and q (1 ≤ n, m, q ≤ 1000) — the height and width of the digital board, and the number of operations.Then follow n lines, each line containing m space-separated integers. The j-th integer of the i-th line is ai, j — the initial state of pixel (i, j).  If ai, j = 0, pixel (i, j) is initially dark.  If ai, j = 1, pixel (i, j) is initially light. Then follow q lines, each line containing three space-separated integers op, x, and y (1 ≤ op ≤ 2; 1 ≤ x ≤ n; 1 ≤ y ≤ m), describing an operation.  If op = 1, the pixel at (x, y) changes its state (from light to dark or from dark to light).  If op = 2, Nanami queries the biggest light block with pixel (x, y) on its side.\n\nOutputFor each query, print a single line containing one integer — the answer to Nanami's query.\n\nInputCopy3 4 50 1 1 01 0 0 10 1 1 02 2 22 1 21 2 21 2 32 2 2OutputCopy026InputCopy3 3 41 1 11 1 11 1 12 2 21 2 22 1 12 2 1OutputCopy633\n\nInputCopy3 4 50 1 1 01 0 0 10 1 1 02 2 22 1 21 2 21 2 32 2 2\n\nOutputCopy026\n\nInputCopy3 3 41 1 11 1 11 1 12 2 21 2 22 1 12 2 1\n\nOutputCopy633\n\nNoteConsider the first sample.The first query specifies pixel (2, 2), which is dark itself, so there are no valid light blocks, thus the answer is 0.The second query specifies pixel (1, 2). The biggest light block is the block with (1, 2) as its upper-left vertex and (1, 3) as its lower-right vertex.The last query specifies pixel (2, 2), which became light in the third operation. The biggest light block is the block with (1, 2) as its upper-left vertex and (3, 3) as its lower-right vertex.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1, \"ai_j\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1, \"ai_j\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readSpace();\n    int q = inf.readInt(1, 1000, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        vector<int> row = inf.readInts(m, 0, 1, \"ai_j\");\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; i++) {\n        int op = inf.readInt(1, 2, \"op\");\n        inf.readSpace();\n        int x = inf.readInt(1, n, \"x\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string ops = opt<string>(\"ops\", \"random\");\n\n    // Generate initial grid based on 'initial' parameter\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (initial == \"all_light\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n    } else if (initial == \"all_dark\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n    } else if (initial == \"checkerboard\") {\n        // Alternate between 0 and 1 in the grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i + j) % 2;\n    } else if (initial == \"vertical_stripes\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = j % 2;\n    } else if (initial == \"horizontal_stripes\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; ++j < m; ++j)\n                grid[i][j] = i % 2;\n    } else if (initial == \"single_light\") {\n        // All dark except one light pixel\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n        grid[x][y] = 1;\n    } else if (initial == \"single_dark\") {\n        // All light except one dark pixel\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n        grid[x][y] = 0;\n    } else { // default or \"random\"\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(0, 1);\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output initial grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    // Generate q operations based on 'ops' parameter\n    vector<tuple<int, int, int>> operations;\n\n    if (ops == \"only_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(2, x, y);\n        }\n    } else if (ops == \"only_updates\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(1, x, y);\n        }\n    } else if (ops == \"alternating\") {\n        for (int i = 0; i < q; ++i) {\n            int op = (i % 2) + 1;\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(op, x, y);\n        }\n    } else if (ops == \"update_then_query\") {\n        for (int i = 0; i < q; ++i) {\n            if (i < q / 2) {\n                // First half updates\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                operations.emplace_back(1, x, y);\n            } else {\n                // Second half queries\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                operations.emplace_back(2, x, y);\n            }\n        }\n    } else if (ops == \"corner_queries\") {\n        // Generate queries on corner pixels\n        vector<pair<int, int>> corners = {{1, 1}, {1, m}, {n, 1}, {n, m}};\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(0, 3);\n            int x = corners[idx].first;\n            int y = corners[idx].second;\n            operations.emplace_back(2, x, y);\n        }\n    } else { // default or \"random\"\n        for (int i = 0; i < q; ++i) {\n            int op = rnd.next(1, 2);\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(op, x, y);\n        }\n    }\n\n    // Output operations\n    for (auto& op : operations) {\n        int o, x, y;\n        tie(o, x, y) = op;\n        printf(\"%d %d %d\\n\", o, x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string initial = opt<string>(\"initial\", \"random\");\n    string ops = opt<string>(\"ops\", \"random\");\n\n    // Generate initial grid based on 'initial' parameter\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (initial == \"all_light\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n    } else if (initial == \"all_dark\") {\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n    } else if (initial == \"checkerboard\") {\n        // Alternate between 0 and 1 in the grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (i + j) % 2;\n    } else if (initial == \"vertical_stripes\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = j % 2;\n    } else if (initial == \"horizontal_stripes\") {\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; ++j < m; ++j)\n                grid[i][j] = i % 2;\n    } else if (initial == \"single_light\") {\n        // All dark except one light pixel\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 0);\n        grid[x][y] = 1;\n    } else if (initial == \"single_dark\") {\n        // All light except one dark pixel\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        for (int i = 0; i < n; ++i)\n            fill(grid[i].begin(), grid[i].end(), 1);\n        grid[x][y] = 0;\n    } else { // default or \"random\"\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = rnd.next(0, 1);\n    }\n\n    // Output n, m, q\n    printf(\"%d %d %d\\n\", n, m, q);\n\n    // Output initial grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d\", grid[i][j]);\n            if (j + 1 < m) printf(\" \");\n        }\n        printf(\"\\n\");\n    }\n\n    // Generate q operations based on 'ops' parameter\n    vector<tuple<int, int, int>> operations;\n\n    if (ops == \"only_queries\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(2, x, y);\n        }\n    } else if (ops == \"only_updates\") {\n        for (int i = 0; i < q; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(1, x, y);\n        }\n    } else if (ops == \"alternating\") {\n        for (int i = 0; i < q; ++i) {\n            int op = (i % 2) + 1;\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(op, x, y);\n        }\n    } else if (ops == \"update_then_query\") {\n        for (int i = 0; i < q; ++i) {\n            if (i < q / 2) {\n                // First half updates\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                operations.emplace_back(1, x, y);\n            } else {\n                // Second half queries\n                int x = rnd.next(1, n);\n                int y = rnd.next(1, m);\n                operations.emplace_back(2, x, y);\n            }\n        }\n    } else if (ops == \"corner_queries\") {\n        // Generate queries on corner pixels\n        vector<pair<int, int>> corners = {{1, 1}, {1, m}, {n, 1}, {n, m}};\n        for (int i = 0; i < q; ++i) {\n            int idx = rnd.next(0, 3);\n            int x = corners[idx].first;\n            int y = corners[idx].second;\n            operations.emplace_back(2, x, y);\n        }\n    } else { // default or \"random\"\n        for (int i = 0; i < q; ++i) {\n            int op = rnd.next(1, 2);\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            operations.emplace_back(op, x, y);\n        }\n    }\n\n    // Output operations\n    for (auto& op : operations) {\n        int o, x, y;\n        tie(o, x, y) = op;\n        printf(\"%d %d %d\\n\", o, x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -q 10 -initial all_light -ops only_queries\n./gen -n 5 -m 5 -q 10 -initial all_dark -ops only_queries\n./gen -n 5 -m 5 -q 10 -initial checkerboard -ops only_updates\n./gen -n 5 -m 5 -q 10 -initial single_light -ops alternating\n./gen -n 5 -m 5 -q 10 -initial single_dark -ops alternating\n./gen -n 5 -m 5 -q 10 -initial random -ops random\n\n./gen -n 100 -m 100 -q 50 -initial all_light -ops corner_queries\n./gen -n 100 -m 100 -q 50 -initial all_dark -ops corner_queries\n./gen -n 100 -m 100 -q 50 -initial vertical_stripes -ops alternating\n./gen -n 100 -m 100 -q 50 -initial horizontal_stripes -ops update_then_query\n./gen -n 100 -m 100 -q 50 -initial checkerboard -ops random\n\n./gen -n 500 -m 500 -q 500 -initial random -ops random\n./gen -n 500 -m 500 -q 500 -initial single_light -ops only_queries\n./gen -n 500 -m 500 -q 500 -initial single_dark -ops only_updates\n./gen -n 500 -m 500 -q 500 -initial all_light -ops alternating\n\n./gen -n 1000 -m 1000 -q 1000 -initial random -ops random\n./gen -n 1000 -m 1000 -q 1000 -initial all_dark -ops only_queries\n./gen -n 1000 -m 1000 -q 1000 -initial all_light -ops only_updates\n./gen -n 1000 -m 1000 -q 1000 -initial checkerboard -ops update_then_query\n./gen -n 1000 -m 1000 -q 1000 -initial vertical_stripes -ops alternating\n\n./gen -n 1000 -m 1000 -q 1000 -initial horizontal_stripes -ops corner_queries\n./gen -n 1000 -m 1000 -q 1000 -initial single_light -ops corner_queries\n./gen -n 1000 -m 1000 -q 1000 -initial single_dark -ops corner_queries\n\n./gen -n 10 -m 1 -q 20 -initial all_light -ops random\n./gen -n 1 -m 10 -q 20 -initial all_dark -ops random\n\n./gen -n 1 -m 1 -q 1 -initial random -ops random\n\n./gen -n 999 -m 1 -q 500 -initial random -ops random\n./gen -n 1 -m 999 -q 500 -initial random -ops random\n\n./gen -n 1000 -m 1000 -q 1000 -initial random -ops random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:29.768755",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "433/E",
      "title": "E. Tachibana Kanade's Tofu",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and k (1 ≤ n ≤ 200; 2 ≤ m ≤ 20; 1 ≤ k ≤ 500). Where n denotes the number of strings, m denotes the base used, and k denotes the limit of the value for Mapo Tofu.The second line represents the number l. The first integer in the line is len (1 ≤ len ≤ 200), describing the length (number of digits in base m) of l. Then follow len integers a1, a2, ..., alen (0 ≤ ai < m; a1 > 0) separated by spaces, representing the digits of l, with a1 being the highest digit and alen being the lowest digit.The third line represents the number r in the same format as l. It is guaranteed that 1 ≤ l ≤ r.Then follow n lines, each line describing a number string. The i-th line contains the i-th number string and vi — the value of the i-th string (1 ≤ vi ≤ 200). All number strings are described in almost the same format as l, the only difference is number strings may contain necessary leading zeros (see the first example). The sum of the lengths of all number strings does not exceed 200.",
      "output_spec": "OutputOutput the number of pieces of Mapo Tofu modulo 1000000007 (109 + 7). The answer should be a decimal integer.",
      "sample_tests": "ExamplesInputCopy2 10 11 13 1 0 01 1 11 0 1OutputCopy97InputCopy2 10 122 5 96 6 3 5 4 9 72 0 6 13 6 7 2 1OutputCopy635439InputCopy4 2 66 1 0 1 1 1 06 1 1 0 1 0 01 1 23 0 1 0 54 0 1 1 0 43 1 0 1 2OutputCopy2",
      "description": "E. Tachibana Kanade's Tofu\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and k (1 ≤ n ≤ 200; 2 ≤ m ≤ 20; 1 ≤ k ≤ 500). Where n denotes the number of strings, m denotes the base used, and k denotes the limit of the value for Mapo Tofu.The second line represents the number l. The first integer in the line is len (1 ≤ len ≤ 200), describing the length (number of digits in base m) of l. Then follow len integers a1, a2, ..., alen (0 ≤ ai < m; a1 > 0) separated by spaces, representing the digits of l, with a1 being the highest digit and alen being the lowest digit.The third line represents the number r in the same format as l. It is guaranteed that 1 ≤ l ≤ r.Then follow n lines, each line describing a number string. The i-th line contains the i-th number string and vi — the value of the i-th string (1 ≤ vi ≤ 200). All number strings are described in almost the same format as l, the only difference is number strings may contain necessary leading zeros (see the first example). The sum of the lengths of all number strings does not exceed 200.\n\nOutputOutput the number of pieces of Mapo Tofu modulo 1000000007 (109 + 7). The answer should be a decimal integer.\n\nInputCopy2 10 11 13 1 0 01 1 11 0 1OutputCopy97InputCopy2 10 122 5 96 6 3 5 4 9 72 0 6 13 6 7 2 1OutputCopy635439InputCopy4 2 66 1 0 1 1 1 06 1 1 0 1 0 01 1 23 0 1 0 54 0 1 1 0 43 1 0 1 2OutputCopy2\n\nInputCopy2 10 11 13 1 0 01 1 11 0 1\n\nOutputCopy97\n\nInputCopy2 10 122 5 96 6 3 5 4 9 72 0 6 13 6 7 2 1\n\nOutputCopy635439\n\nInputCopy4 2 66 1 0 1 1 1 06 1 1 0 1 0 01 1 23 0 1 0 54 0 1 1 0 43 1 0 1 2\n\nOutputCopy2\n\nNoteIn the first sample, 10, 11 and 100 are the only three decimal numbers in [1, 100] with a value greater than 1. Here the value of 1 is 1 but not 2, since numbers cannot contain leading zeros and thus cannot be written as \"01\".In the second sample, no numbers in the given interval have a value greater than 12.In the third sample, 110000 and 110001 are the only two binary numbers in the given interval with a value no greater than 6.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Compare two numbers represented as vectors of digits.\n// Returns -1 if a < b, 0 if a == b, 1 if a > b.\nint compare(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size())\n        return a.size() < b.size() ? -1 : 1;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500, \"k\");\n    inf.readEoln();\n\n    // Read l\n    int len_l = inf.readInt(1, 200, \"len_l\");\n    inf.readSpace();\n    vector<int> l_digits(len_l);\n    for (int i = 0; i < len_l; ++i) {\n        l_digits[i] = (i == 0) ? inf.readInt(1, m - 1, \"l_digits[0]\") : inf.readInt(0, m - 1, \"l_digits[\" + to_string(i) + \"]\");\n        if (i != len_l -1) inf.readSpace();\n    }\n    inf.readEoln();\n\n    // Read r\n    int len_r = inf.readInt(1, 200, \"len_r\");\n    inf.readSpace();\n    vector<int> r_digits(len_r);\n    for (int i = 0; i < len_r; ++i) {\n        r_digits[i] = (i == 0) ? inf.readInt(1, m - 1, \"r_digits[0]\") : inf.readInt(0, m - 1, \"r_digits[\" + to_string(i) + \"]\");\n        if (i != len_r -1) inf.readSpace();\n    }\n    inf.readEoln();\n\n    // Ensure l <= r\n    int comp = compare(l_digits, r_digits);\n    ensuref(comp <= 0, \"l must be less than or equal to r\");\n\n    // Read n number strings\n    int total_len = 0;\n    for (int i = 0; i < n; ++i) {\n        int len_s = inf.readInt(1, 200, \"len_s[\" + to_string(i+1) + \"]\");\n        total_len += len_s;\n        ensuref(total_len <= 200, \"Sum of lengths of number strings exceeds 200\");\n        inf.readSpace();\n        vector<int> s_digits(len_s);\n        for (int j = 0; j < len_s; ++j) {\n            s_digits[j] = inf.readInt(0, m -1, \"s_digits[\" + to_string(i+1) + \"][\" + to_string(j) + \"]\");\n            if (j != len_s -1) inf.readSpace();\n        }\n        inf.readSpace();\n        int vi = inf.readInt(1, 200, \"v[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Compare two numbers represented as vectors of digits.\n// Returns -1 if a < b, 0 if a == b, 1 if a > b.\nint compare(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size())\n        return a.size() < b.size() ? -1 : 1;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500, \"k\");\n    inf.readEoln();\n\n    // Read l\n    int len_l = inf.readInt(1, 200, \"len_l\");\n    inf.readSpace();\n    vector<int> l_digits(len_l);\n    for (int i = 0; i < len_l; ++i) {\n        l_digits[i] = (i == 0) ? inf.readInt(1, m - 1, \"l_digits[0]\") : inf.readInt(0, m - 1, \"l_digits[\" + to_string(i) + \"]\");\n        if (i != len_l -1) inf.readSpace();\n    }\n    inf.readEoln();\n\n    // Read r\n    int len_r = inf.readInt(1, 200, \"len_r\");\n    inf.readSpace();\n    vector<int> r_digits(len_r);\n    for (int i = 0; i < len_r; ++i) {\n        r_digits[i] = (i == 0) ? inf.readInt(1, m - 1, \"r_digits[0]\") : inf.readInt(0, m - 1, \"r_digits[\" + to_string(i) + \"]\");\n        if (i != len_r -1) inf.readSpace();\n    }\n    inf.readEoln();\n\n    // Ensure l <= r\n    int comp = compare(l_digits, r_digits);\n    ensuref(comp <= 0, \"l must be less than or equal to r\");\n\n    // Read n number strings\n    int total_len = 0;\n    for (int i = 0; i < n; ++i) {\n        int len_s = inf.readInt(1, 200, \"len_s[\" + to_string(i+1) + \"]\");\n        total_len += len_s;\n        ensuref(total_len <= 200, \"Sum of lengths of number strings exceeds 200\");\n        inf.readSpace();\n        vector<int> s_digits(len_s);\n        for (int j = 0; j < len_s; ++j) {\n            s_digits[j] = inf.readInt(0, m -1, \"s_digits[\" + to_string(i+1) + \"][\" + to_string(j) + \"]\");\n            if (j != len_s -1) inf.readSpace();\n        }\n        inf.readSpace();\n        int vi = inf.readInt(1, 200, \"v[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Compare two numbers represented as vectors of digits.\n// Returns -1 if a < b, 0 if a == b, 1 if a > b.\nint compare(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size())\n        return a.size() < b.size() ? -1 : 1;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return 0;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500, \"k\");\n    inf.readEoln();\n\n    // Read l\n    int len_l = inf.readInt(1, 200, \"len_l\");\n    inf.readSpace();\n    vector<int> l_digits(len_l);\n    for (int i = 0; i < len_l; ++i) {\n        l_digits[i] = (i == 0) ? inf.readInt(1, m - 1, \"l_digits[0]\") : inf.readInt(0, m - 1, \"l_digits[\" + to_string(i) + \"]\");\n        if (i != len_l -1) inf.readSpace();\n    }\n    inf.readEoln();\n\n    // Read r\n    int len_r = inf.readInt(1, 200, \"len_r\");\n    inf.readSpace();\n    vector<int> r_digits(len_r);\n    for (int i = 0; i < len_r; ++i) {\n        r_digits[i] = (i == 0) ? inf.readInt(1, m - 1, \"r_digits[0]\") : inf.readInt(0, m - 1, \"r_digits[\" + to_string(i) + \"]\");\n        if (i != len_r -1) inf.readSpace();\n    }\n    inf.readEoln();\n\n    // Ensure l <= r\n    int comp = compare(l_digits, r_digits);\n    ensuref(comp <= 0, \"l must be less than or equal to r\");\n\n    // Read n number strings\n    int total_len = 0;\n    for (int i = 0; i < n; ++i) {\n        int len_s = inf.readInt(1, 200, \"len_s[\" + to_string(i+1) + \"]\");\n        total_len += len_s;\n        ensuref(total_len <= 200, \"Sum of lengths of number strings exceeds 200\");\n        inf.readSpace();\n        vector<int> s_digits(len_s);\n        for (int j = 0; j < len_s; ++j) {\n            s_digits[j] = inf.readInt(0, m -1, \"s_digits[\" + to_string(i+1) + \"][\" + to_string(j) + \"]\");\n            if (j != len_s -1) inf.readSpace();\n        }\n        inf.readSpace();\n        int vi = inf.readInt(1, 200, \"v[\" + to_string(i+1) + \"]\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint compareNumbers(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size()) {\n        if (a.size() < b.size()) return -1;\n        else return 1;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            if (a[i] < b[i]) return -1;\n            else return 1;\n        }\n    }\n    return 0;\n}\n\nvector<int> generateNumber(int len, int m, bool leading_nonzero) {\n    vector<int> num(len);\n    if (leading_nonzero) {\n        num[0] = rnd.next(1, m - 1);\n    } else {\n        num[0] = rnd.next(0, m - 1);\n    }\n    for (int i = 1; i < len; ++i) {\n        num[i] = rnd.next(0, m - 1);\n    }\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 200));\n    int m = opt<int>(\"m\", rnd.next(2, 20));\n    int k = opt<int>(\"k\", rnd.next(1, 500));\n    string type = opt<string>(\"type\", \"random\");\n\n    int len_l, len_r;\n    vector<int> l, r;\n\n    if (type == \"small\") {\n        n = rnd.next(1, 5);\n        m = rnd.next(2, 5);\n        k = rnd.next(1, 10);\n\n        len_l = rnd.next(1, 3);\n        len_r = rnd.next(1, 3);\n        l = generateNumber(len_l, m, true);\n        r = generateNumber(len_r, m, true);\n        if (compareNumbers(l, r) > 0) {\n            swap(l, r);\n        }\n    } else if (type == \"leading_zeros\") {\n        n = rnd.next(1, 200);\n        m = rnd.next(2, 20);\n        k = rnd.next(1, 500);\n        len_l = rnd.next(1, 10);\n        len_r = len_l + rnd.next(0, 5);\n\n        l = generateNumber(len_l, m, true);\n        r = generateNumber(len_r, m, true);\n        if (compareNumbers(l, r) > 0) {\n            swap(l, r);\n        }\n    } else {\n        // Default random case\n        n = n;\n        m = m;\n        k = k;\n\n        len_l = rnd.next(1, 200);\n        len_r = len_l + rnd.next(0, 20);\n        l = generateNumber(len_l, m, true);\n        r = generateNumber(len_r, m, true);\n        if (compareNumbers(l, r) > 0) {\n            swap(l, r);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output l\n    printf(\"%d \", (int)l.size());\n    for (int i = 0; i < (int)l.size(); ++i) {\n        printf(\"%d\", l[i]);\n        if (i < (int)l.size() - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output r\n    printf(\"%d \", (int)r.size());\n    for (int i = 0; i < (int)r.size(); ++i) {\n        printf(\"%d\", r[i]);\n        if (i < (int)r.size() - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Generate lengths of number strings\n    int total_length = rnd.next(n, 200);\n    vector<int> positions;\n\n    for (int i = 0; i < n - 1; ++i) {\n        positions.push_back(rnd.next(1, total_length - 1));\n    }\n    positions.push_back(0);\n    positions.push_back(total_length);\n    sort(positions.begin(), positions.end());\n\n    vector<int> len(n);\n    for (int i = 0; i < n; ++i) {\n        len[i] = positions[i + 1] - positions[i];\n        if (len[i] == 0) len[i] = 1;  // ensure length at least 1\n    }\n\n    // Adjust total_length\n    total_length = 0;\n    for (int i = 0; i < n; ++i) total_length += len[i];\n    // Ensure total_length <= 200\n    if (total_length > 200) {\n        for (int i = 0; i < n && total_length > 200; ++i) {\n            if (len[i] > 1) {\n                len[i]--;\n                total_length--;\n            }\n        }\n    }\n\n    // Generate number strings and their vi\n    for (int i = 0; i < n; ++i) {\n        int str_len = len[i];\n        vector<int> num_str = generateNumber(str_len, m, false);  // leading zeros allowed\n        int vi = rnd.next(1, 200);\n\n        // Output number string and vi\n        printf(\"%d \", str_len);\n        for (int j = 0; j < str_len; ++j) {\n            printf(\"%d\", num_str[j]);\n            if (j < str_len - 1) printf(\" \");\n        }\n        printf(\" %d\\n\", vi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint compareNumbers(const vector<int>& a, const vector<int>& b) {\n    if (a.size() != b.size()) {\n        if (a.size() < b.size()) return -1;\n        else return 1;\n    }\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            if (a[i] < b[i]) return -1;\n            else return 1;\n        }\n    }\n    return 0;\n}\n\nvector<int> generateNumber(int len, int m, bool leading_nonzero) {\n    vector<int> num(len);\n    if (leading_nonzero) {\n        num[0] = rnd.next(1, m - 1);\n    } else {\n        num[0] = rnd.next(0, m - 1);\n    }\n    for (int i = 1; i < len; ++i) {\n        num[i] = rnd.next(0, m - 1);\n    }\n    return num;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", rnd.next(1, 200));\n    int m = opt<int>(\"m\", rnd.next(2, 20));\n    int k = opt<int>(\"k\", rnd.next(1, 500));\n    string type = opt<string>(\"type\", \"random\");\n\n    int len_l, len_r;\n    vector<int> l, r;\n\n    if (type == \"small\") {\n        n = rnd.next(1, 5);\n        m = rnd.next(2, 5);\n        k = rnd.next(1, 10);\n\n        len_l = rnd.next(1, 3);\n        len_r = rnd.next(1, 3);\n        l = generateNumber(len_l, m, true);\n        r = generateNumber(len_r, m, true);\n        if (compareNumbers(l, r) > 0) {\n            swap(l, r);\n        }\n    } else if (type == \"leading_zeros\") {\n        n = rnd.next(1, 200);\n        m = rnd.next(2, 20);\n        k = rnd.next(1, 500);\n        len_l = rnd.next(1, 10);\n        len_r = len_l + rnd.next(0, 5);\n\n        l = generateNumber(len_l, m, true);\n        r = generateNumber(len_r, m, true);\n        if (compareNumbers(l, r) > 0) {\n            swap(l, r);\n        }\n    } else {\n        // Default random case\n        n = n;\n        m = m;\n        k = k;\n\n        len_l = rnd.next(1, 200);\n        len_r = len_l + rnd.next(0, 20);\n        l = generateNumber(len_l, m, true);\n        r = generateNumber(len_r, m, true);\n        if (compareNumbers(l, r) > 0) {\n            swap(l, r);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output l\n    printf(\"%d \", (int)l.size());\n    for (int i = 0; i < (int)l.size(); ++i) {\n        printf(\"%d\", l[i]);\n        if (i < (int)l.size() - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Output r\n    printf(\"%d \", (int)r.size());\n    for (int i = 0; i < (int)r.size(); ++i) {\n        printf(\"%d\", r[i]);\n        if (i < (int)r.size() - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    // Generate lengths of number strings\n    int total_length = rnd.next(n, 200);\n    vector<int> positions;\n\n    for (int i = 0; i < n - 1; ++i) {\n        positions.push_back(rnd.next(1, total_length - 1));\n    }\n    positions.push_back(0);\n    positions.push_back(total_length);\n    sort(positions.begin(), positions.end());\n\n    vector<int> len(n);\n    for (int i = 0; i < n; ++i) {\n        len[i] = positions[i + 1] - positions[i];\n        if (len[i] == 0) len[i] = 1;  // ensure length at least 1\n    }\n\n    // Adjust total_length\n    total_length = 0;\n    for (int i = 0; i < n; ++i) total_length += len[i];\n    // Ensure total_length <= 200\n    if (total_length > 200) {\n        for (int i = 0; i < n && total_length > 200; ++i) {\n            if (len[i] > 1) {\n                len[i]--;\n                total_length--;\n            }\n        }\n    }\n\n    // Generate number strings and their vi\n    for (int i = 0; i < n; ++i) {\n        int str_len = len[i];\n        vector<int> num_str = generateNumber(str_len, m, false);  // leading zeros allowed\n        int vi = rnd.next(1, 200);\n\n        // Output number string and vi\n        printf(\"%d \", str_len);\n        for (int j = 0; j < str_len; ++j) {\n            printf(\"%d\", num_str[j]);\n            if (j < str_len - 1) printf(\" \");\n        }\n        printf(\" %d\\n\", vi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 2 -k 1 -type small\n./gen -n 5 -m 3 -k 5 -type small\n./gen -n 10 -m 5 -k 50 -type small\n./gen -n 2 -m 4 -k 100 -type small\n./gen -n 1 -m 6 -k 1 -type small\n\n./gen -n 50 -m 10 -k 200 -type leading_zeros\n./gen -n 100 -m 20 -k 500 -type leading_zeros\n./gen -n 150 -m 15 -k 300 -type leading_zeros\n./gen -n 200 -m 20 -k 500 -type leading_zeros\n./gen -n 200 -m 2 -k 500 -type leading_zeros\n\n./gen -n 1 -m 2 -k 1 -type random\n./gen -n 1 -m 3 -k 2 -type random\n./gen -n 10 -m 10 -k 100 -type random\n./gen -n 50 -m 7 -k 350 -type random\n./gen -n 75 -m 15 -k 375 -type random\n./gen -n 100 -m 20 -k 250 -type random\n./gen -n 125 -m 10 -k 125 -type random\n./gen -n 150 -m 5 -k 100 -type random\n./gen -n 200 -m 20 -k 500 -type random\n./gen -n 200 -m 3 -k 500 -type random\n./gen -n 200 -m 20 -k 500 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:32.197326",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "434/A",
      "title": "A. Ryouko's Memory Note",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integers n and m (1 ≤ n, m ≤ 105).The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).",
      "output_spec": "OutputPrint a single integer — the minimum number of pages Ryouko needs to turn.",
      "sample_tests": "ExamplesInputCopy4 61 2 3 4 3 2OutputCopy3InputCopy10 59 4 3 8 8OutputCopy6",
      "description": "A. Ryouko's Memory Note\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integers n and m (1 ≤ n, m ≤ 105).The next line contains m integers separated by spaces: a1, a2, ..., am (1 ≤ ai ≤ n).\n\nOutputPrint a single integer — the minimum number of pages Ryouko needs to turn.\n\nInputCopy4 61 2 3 4 3 2OutputCopy3InputCopy10 59 4 3 8 8OutputCopy6\n\nInputCopy4 61 2 3 4 3 2\n\nOutputCopy3\n\nInputCopy10 59 4 3 8 8\n\nOutputCopy6\n\nNoteIn the first sample, the optimal solution is to merge page 4 to 3, after merging sequence a becomes {1, 2, 3, 3, 3, 2}, so the number of pages Ryouko needs to turn is |1 - 2| + |2 - 3| + |3 - 3| + |3 - 3| + |3 - 2| = 3.In the second sample, optimal solution is achieved by merging page 9 to 4.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, n, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, n, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(m, 1, n, \"a\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else if (type == \"same\") {\n        int page = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = page;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % n) + 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = n - (i % n);\n        }\n    } else if (type == \"alternating\") {\n        int p1 = rnd.next(1, n);\n        int p2 = rnd.next(1, n);\n        while (p2 == p1) p2 = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? p1 : p2;\n        }\n    } else if (type == \"clusters\") {\n        int k = opt<int>(\"k\", 5); // Average cluster size\n        int page = rnd.next(1, n);\n        for (int i = 0; i < m; ) {\n            int cluster_size = rnd.next(1, k);\n            for (int j = 0; j < cluster_size && i < m; ++j, ++i) {\n                a[i] = page;\n            }\n            page = rnd.next(1, n);\n        }\n    } else if (type == \"worst_case\") {\n        // Construct a test case where merging helps greatly.\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, n);\n        while (y == x) y = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else if (type == \"max_distance\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : n;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << \"\\n\";\n    for (int i = 0; i < m; ++i) {\n        cout << a[i] << (i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(m);\n\n    if (type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = rnd.next(1, n);\n        }\n    } else if (type == \"same\") {\n        int page = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = page;\n        }\n    } else if (type == \"increasing\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % n) + 1;\n        }\n    } else if (type == \"decreasing\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = n - (i % n);\n        }\n    } else if (type == \"alternating\") {\n        int p1 = rnd.next(1, n);\n        int p2 = rnd.next(1, n);\n        while (p2 == p1) p2 = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? p1 : p2;\n        }\n    } else if (type == \"clusters\") {\n        int k = opt<int>(\"k\", 5); // Average cluster size\n        int page = rnd.next(1, n);\n        for (int i = 0; i < m; ) {\n            int cluster_size = rnd.next(1, k);\n            for (int j = 0; j < cluster_size && i < m; ++j, ++i) {\n                a[i] = page;\n            }\n            page = rnd.next(1, n);\n        }\n    } else if (type == \"worst_case\") {\n        // Construct a test case where merging helps greatly.\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, n);\n        while (y == x) y = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? x : y;\n        }\n    } else if (type == \"max_distance\") {\n        for (int i = 0; i < m; ++i) {\n            a[i] = (i % 2 == 0) ? 1 : n;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n and m\n    cout << n << \" \" << m << \"\\n\";\n    for (int i = 0; i < m; ++i) {\n        cout << a[i] << (i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type same\n./gen -n 1 -m 100000 -type same\n\n./gen -n 100000 -m 1 -type random\n./gen -n 100000 -m 1 -type same\n\n./gen -n 100000 -m 100000 -type same\n./gen -n 100000 -m 100000 -type random\n\n./gen -n 100000 -m 100000 -type increasing\n./gen -n 100000 -m 100000 -type decreasing\n\n./gen -n 100000 -m 100000 -type alternating\n\n./gen -n 100000 -m 100000 -type clusters -k 1\n./gen -n 100000 -m 100000 -type clusters -k 10\n./gen -n 100000 -m 100000 -type clusters -k 100\n./gen -n 100000 -m 100000 -type clusters -k 1000\n\n./gen -n 100000 -m 100000 -type worst_case\n./gen -n 100000 -m 100000 -type max_distance\n\n./gen -n 100 -m 100000 -type random\n\n./gen -n 2 -m 100000 -type alternating\n./gen -n 2 -m 100000 -type worst_case\n./gen -n 2 -m 100000 -type max_distance\n\n./gen -n 100000 -m 2 -type random\n./gen -n 100000 -m 2 -type same\n\n./gen -n 2 -m 2 -type random\n\n./gen -n 100000 -m 50000 -type clusters -k 500\n./gen -n 100000 -m 50000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:34.637926",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "434/B",
      "title": "B. Электронная таблица Нанами",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три целых числа через пробел — n, m и q (1 ≤ n, m, q ≤ 1000) — высота и ширина электронной таблицы и количество операций.Затем следует n строк, в каждой строке записано по m целых чисел через пробел: j-е целое число в i-й строке равняется ai, j — начальному состоянию пикселя (i, j).  Если ai, j = 0, то пиксель (i, j) изначально не светится.  Если ai, j = 1, то пиксель (i, j) изначально светится. Затем следуют q строк, в каждой строке записано по три целых числа через пробел op, x, и y (1 ≤ op ≤ 2; 1 ≤ x ≤ n; 1 ≤ y ≤ m), описывающих события в порядке их возникновения.  Если op = 1, то пиксель в (x, y) меняет состояние (если он светился, то теперь он перестает светиться, и наоборот).  Если op = 2, то Нанами спрашивает у вас площадь наибольшего светящегося подпрямоугольника с пикселем (x, y) на стороне.",
      "output_spec": "Выходные данныеДля каждого вопроса выведите единственную строку, содержащую целое число — ответ на вопрос Нанами.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 4 50 1 1 01 0 0 10 1 1 02 2 22 1 21 2 21 2 32 2 2Выходные данныеСкопировать026Входные данныеСкопировать3 3 41 1 11 1 11 1 12 2 21 2 22 1 12 2 1Выходные данныеСкопировать633",
      "description": "B. Электронная таблица Нанами\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано три целых числа через пробел — n, m и q (1 ≤ n, m, q ≤ 1000) — высота и ширина электронной таблицы и количество операций.Затем следует n строк, в каждой строке записано по m целых чисел через пробел: j-е целое число в i-й строке равняется ai, j — начальному состоянию пикселя (i, j).  Если ai, j = 0, то пиксель (i, j) изначально не светится.  Если ai, j = 1, то пиксель (i, j) изначально светится. Затем следуют q строк, в каждой строке записано по три целых числа через пробел op, x, и y (1 ≤ op ≤ 2; 1 ≤ x ≤ n; 1 ≤ y ≤ m), описывающих события в порядке их возникновения.  Если op = 1, то пиксель в (x, y) меняет состояние (если он светился, то теперь он перестает светиться, и наоборот).  Если op = 2, то Нанами спрашивает у вас площадь наибольшего светящегося подпрямоугольника с пикселем (x, y) на стороне.\n\nВходные данные\n\nВыходные данныеДля каждого вопроса выведите единственную строку, содержащую целое число — ответ на вопрос Нанами.\n\nВыходные данные\n\nВходные данныеСкопировать3 4 50 1 1 01 0 0 10 1 1 02 2 22 1 21 2 21 2 32 2 2Выходные данныеСкопировать026Входные данныеСкопировать3 3 41 1 11 1 11 1 12 2 21 2 22 1 12 2 1Выходные данныеСкопировать633\n\nВходные данныеСкопировать3 4 50 1 1 01 0 0 10 1 1 02 2 22 1 21 2 21 2 32 2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать026\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 3 41 1 11 1 11 1 12 2 21 2 22 1 12 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать633\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример.В первом вопросе подпрямоугольник должен содержать пиксель (2, 2) на стороне, но этот пиксель не светится, поэтому подходящих светящихся прямоугольников нет, и ответ равняется 0.В втором вопросе подпрямоугольник должен содержать пиксель (1, 2) на стороне. Самый большой такой подпрямоугольник — это подпрямоугольник с левым верхним углом в (1, 2) и правым нижним углом в (1, 3).В последнем вопросе подпрямоугольник должен содержать пиксель (2, 2) на стороне, который засветился после третьего события. Самый большой светящийся подпрямоугольник — это подпрямоугольник с верхним левым углом в (1, 2) и правым нижним углом в (3, 3).",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Всем привет!Приглашаем вас принять участие в Codeforces Round #248, который начнется в субботу 24-го мая в 11:00. Раунд будет проходить в обоих дивизионах. Обратите внимание на крайне нестандартное время проведения раунда.Задачи были подготовлены zhonghaoxi, wyx528 и мной. Это наш первый раунд Codeforces, надеемся, что он пройдет хорошо.Большое спасибо Gerald за помощь в подготовке раунда, а также спасибо colin и MSTyoda за тестирование раунда. Традиционно благодарим MikeMirzayanov за создание удобной платформы для проведения соревнований.В дивизионе 1, это будет 500-1000-1500-2000-3000, в дивизионе 2, это будет 500-1500-1500-2000-2500.Надеюсь вам понравятся задачи! Желаем вам удачи и удовольствия от решения задач~",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 724
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000); inf.readSpace();\n    int m = inf.readInt(1, 1000); inf.readSpace();\n    int q = inf.readInt(1, 1000); inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int op = inf.readInt(1, 2); inf.readSpace();\n        int x = inf.readInt(1, n); inf.readSpace();\n        int y = inf.readInt(1, m); inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000); inf.readSpace();\n    int m = inf.readInt(1, 1000); inf.readSpace();\n    int q = inf.readInt(1, 1000); inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int op = inf.readInt(1, 2); inf.readSpace();\n        int x = inf.readInt(1, n); inf.readSpace();\n        int y = inf.readInt(1, m); inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000); inf.readSpace();\n    int m = inf.readInt(1, 1000); inf.readSpace();\n    int q = inf.readInt(1, 1000); inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        vector<int> row = inf.readInts(m, 0, 1);\n        inf.readEoln();\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int op = inf.readInt(1, 2); inf.readSpace();\n        int x = inf.readInt(1, n); inf.readSpace();\n        int y = inf.readInt(1, m); inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    assert(1 <= n && n <= 1000);\n    assert(1 <= m && m <= 1000);\n    assert(1 <= q && q <= 1000);\n\n    // Initial grid\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Random initial grid\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2); // 0 or 1\n            }\n        }\n    } else if (type == \"all_light\") {\n        // All pixels are light\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n    } else if (type == \"all_dark\") {\n        // All pixels are dark\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), 0);\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = (i + j) % 2;\n            }\n        }\n    } else if (type == \"single_row\") {\n        // Ensure n == 1\n        ensure(n == 1);\n        // Random initial grid\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = rnd.next(2);\n        }\n    } else if (type == \"single_column\") {\n        // Ensure m == 1\n        ensure(m == 1);\n        // Random initial grid\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = rnd.next(2);\n        }\n    } else if (type == \"edge_cases\") {\n        // Construct a specific test case to check edge cases\n        // All light grid with a darkened row and column\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n        if (n > 1 && m > 1) {\n            int row = rnd.next(1, n);\n            int col = rnd.next(1, m);\n            // Darken a row\n            for (int j = 0; j < m; ++j) {\n                grid[row - 1][j] = 0;\n            }\n            // Darken a column\n            for (int i = 0; i < n; ++i) {\n                grid[i][col - 1] = 0;\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2); // 0 or 1\n            }\n        }\n    }\n\n    // Generate operations\n    vector<tuple<int,int,int>> ops(q);\n    for (int k = 0; k < q; ++k) {\n        int op = rnd.next(1,2);\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n        ops[k] = make_tuple(op, x, y);\n    }\n\n    // Output the data\n    printf(\"%d %d %d\\n\", n, m, q);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", grid[i][j], j == m-1 ? '\\n' : ' ');\n        }\n    }\n    for (int k = 0; k < q; ++k) {\n        int op, x, y;\n        tie(op, x, y) = ops[k];\n        printf(\"%d %d %d\\n\", op, x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Check constraints\n    assert(1 <= n && n <= 1000);\n    assert(1 <= m && m <= 1000);\n    assert(1 <= q && q <= 1000);\n\n    // Initial grid\n    vector<vector<int>> grid(n, vector<int>(m));\n\n    if (type == \"random\") {\n        // Random initial grid\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2); // 0 or 1\n            }\n        }\n    } else if (type == \"all_light\") {\n        // All pixels are light\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n    } else if (type == \"all_dark\") {\n        // All pixels are dark\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), 0);\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = (i + j) % 2;\n            }\n        }\n    } else if (type == \"single_row\") {\n        // Ensure n == 1\n        ensure(n == 1);\n        // Random initial grid\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = rnd.next(2);\n        }\n    } else if (type == \"single_column\") {\n        // Ensure m == 1\n        ensure(m == 1);\n        // Random initial grid\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = rnd.next(2);\n        }\n    } else if (type == \"edge_cases\") {\n        // Construct a specific test case to check edge cases\n        // All light grid with a darkened row and column\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), 1);\n        }\n        if (n > 1 && m > 1) {\n            int row = rnd.next(1, n);\n            int col = rnd.next(1, m);\n            // Darken a row\n            for (int j = 0; j < m; ++j) {\n                grid[row - 1][j] = 0;\n            }\n            // Darken a column\n            for (int i = 0; i < n; ++i) {\n                grid[i][col - 1] = 0;\n            }\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = rnd.next(2); // 0 or 1\n            }\n        }\n    }\n\n    // Generate operations\n    vector<tuple<int,int,int>> ops(q);\n    for (int k = 0; k < q; ++k) {\n        int op = rnd.next(1,2);\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, m);\n        ops[k] = make_tuple(op, x, y);\n    }\n\n    // Output the data\n    printf(\"%d %d %d\\n\", n, m, q);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", grid[i][j], j == m-1 ? '\\n' : ' ');\n        }\n    }\n    for (int k = 0; k < q; ++k) {\n        int op, x, y;\n        tie(op, x, y) = ops[k];\n        printf(\"%d %d %d\\n\", op, x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -m 5 -q 3 -type random\n./gen -n 5 -m 5 -q 3 -type all_light\n./gen -n 5 -m 5 -q 3 -type all_dark\n./gen -n 5 -m 5 -q 3 -type checkerboard\n./gen -n 1 -m 10 -q 5 -type single_row\n./gen -n 10 -m 1 -q 5 -type single_column\n./gen -n 10 -m 10 -q 10 -type random\n./gen -n 100 -m 100 -q 50 -type random\n./gen -n 1000 -m 1000 -q 1000 -type random\n./gen -n 1000 -m 1000 -q 1000 -type all_light\n./gen -n 1000 -m 1000 -q 1000 -type all_dark\n./gen -n 1000 -m 1000 -q 1000 -type checkerboard\n./gen -n 1000 -m 1000 -q 1000 -type edge_cases\n./gen -n 500 -m 500 -q 1000 -type edge_cases\n./gen -n 1 -m 1000 -q 500 -type single_row\n./gen -n 1000 -m 1 -q 500 -type single_column\n./gen -n 100 -m 100 -q 1000 -type random\n./gen -n 50 -m 50 -q 1000 -type random\n./gen -n 1000 -m 1000 -q 1000 -type edge_cases\n./gen -n 1000 -m 1000 -q 1000 -type random\n./gen -n 1000 -m 1000 -q 1000 -type edge_cases\n./gen -n 1000 -m 1000 -q 1000 -type random\n./gen -n 1 -m 1 -q 1 -type random\n./gen -n 1 -m 1 -q 1 -type all_light\n./gen -n 1000 -m 1000 -q 1 -type random\n./gen -n 1000 -m 1000 -q 1000 -type checkerboard\n./gen -n 999 -m 999 -q 999 -type edge_cases\n./gen -n 2 -m 2 -q 4 -type random\n./gen -n 2 -m 2 -q 4 -type all_light\n./gen -n 2 -m 2 -q 4 -type all_dark\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:37.055770",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "434/C",
      "title": "C. Тофу Тачибана Канаде",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано три целых числа n, m и k (1 ≤ n ≤ 200; 2 ≤ m ≤ 20; 1 ≤ k ≤ 500), где n обозначает количество выбранных строк, m обозначает основание системы счисления, k — предельное значение для Мапо Тофу.Во второй строке задана запись числа l. Сначала в строке записано целое число len (1 ≤ len ≤ 200), оно обозначает длину (количество цифр в m-ричной записи) числа l. Затем в строке записаны len разделенных пробелом целых чисел a1, a2, ..., alen (0 ≤ ai < m; a1 > 0), обозначающих цифры числа l в системе счисления m, цифра a1 наиболее значащая, цифра alen наименее значащая.В третьей строке записано число r в таком же формате, как и число l. Гарантируется, что выполняется неравенство 1 ≤ l ≤ r.В следующих n строках записаны выбранные для оценки строки из цифр. В i-й строке сначала записана i-ая строка из цифр в системе счисления по основанию m, а затем целое число vi — значение этой строки (1 ≤ vi ≤ 200). Все строки из цифр заданы почти в таком же формате, как и число l, единственное отличие состоит в том, что эти строки могут иметь лидирующие нули, которые важны для решения задачи (смотрите первый тестовый пример). Сумма длин строк из цифр не превышает 200.",
      "output_spec": "Выходные данныеВыведите количество кусочков Мапо Тофу по модулю 1000000007 (109 + 7). Ответ должен быть десятичным целым числом.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 10 11 13 1 0 01 1 11 0 1Выходные данныеСкопировать97Входные данныеСкопировать2 10 122 5 96 6 3 5 4 9 72 0 6 13 6 7 2 1Выходные данныеСкопировать635439Входные данныеСкопировать4 2 66 1 0 1 1 1 06 1 1 0 1 0 01 1 23 0 1 0 54 0 1 1 0 43 1 0 1 2Выходные данныеСкопировать2",
      "description": "C. Тофу Тачибана Канаде\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано три целых числа n, m и k (1 ≤ n ≤ 200; 2 ≤ m ≤ 20; 1 ≤ k ≤ 500), где n обозначает количество выбранных строк, m обозначает основание системы счисления, k — предельное значение для Мапо Тофу.Во второй строке задана запись числа l. Сначала в строке записано целое число len (1 ≤ len ≤ 200), оно обозначает длину (количество цифр в m-ричной записи) числа l. Затем в строке записаны len разделенных пробелом целых чисел a1, a2, ..., alen (0 ≤ ai < m; a1 > 0), обозначающих цифры числа l в системе счисления m, цифра a1 наиболее значащая, цифра alen наименее значащая.В третьей строке записано число r в таком же формате, как и число l. Гарантируется, что выполняется неравенство 1 ≤ l ≤ r.В следующих n строках записаны выбранные для оценки строки из цифр. В i-й строке сначала записана i-ая строка из цифр в системе счисления по основанию m, а затем целое число vi — значение этой строки (1 ≤ vi ≤ 200). Все строки из цифр заданы почти в таком же формате, как и число l, единственное отличие состоит в том, что эти строки могут иметь лидирующие нули, которые важны для решения задачи (смотрите первый тестовый пример). Сумма длин строк из цифр не превышает 200.\n\nВходные данные\n\nВыходные данныеВыведите количество кусочков Мапо Тофу по модулю 1000000007 (109 + 7). Ответ должен быть десятичным целым числом.\n\nВыходные данные\n\nВходные данныеСкопировать2 10 11 13 1 0 01 1 11 0 1Выходные данныеСкопировать97Входные данныеСкопировать2 10 122 5 96 6 3 5 4 9 72 0 6 13 6 7 2 1Выходные данныеСкопировать635439Входные данныеСкопировать4 2 66 1 0 1 1 1 06 1 1 0 1 0 01 1 23 0 1 0 54 0 1 1 0 43 1 0 1 2Выходные данныеСкопировать2\n\nВходные данныеСкопировать2 10 11 13 1 0 01 1 11 0 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать97\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 10 122 5 96 6 3 5 4 9 72 0 6 13 6 7 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать635439\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 2 66 1 0 1 1 1 06 1 1 0 1 0 01 1 23 0 1 0 54 0 1 1 0 43 1 0 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере 10, 11 и 100 — единственные три кусочка тофу в отрезке [1, 100] со значением больше 1. Обратите внимание, что значение кусочка тофу 1 равно 1, а не 2, так как идентификаторы не могут содержать ведущих нулей и следовательно, не могут записываться как «01».Во втором примере ни у одного кусочка на данном интервале нет значения больше 12.В третьем примере 110000 и 110001 — единственные два идентификатора на данном интервале со значением не больше 6.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Всем привет!Приглашаем вас принять участие в Codeforces Round #248, который начнется в субботу 24-го мая в 11:00. Раунд будет проходить в обоих дивизионах. Обратите внимание на крайне нестандартное время проведения раунда.Задачи были подготовлены zhonghaoxi, wyx528 и мной. Это наш первый раунд Codeforces, надеемся, что он пройдет хорошо.Большое спасибо Gerald за помощь в подготовке раунда, а также спасибо colin и MSTyoda за тестирование раунда. Традиционно благодарим MikeMirzayanov за создание удобной платформы для проведения соревнований.В дивизионе 1, это будет 500-1000-1500-2000-3000, в дивизионе 2, это будет 500-1500-1500-2000-2500.Надеюсь вам понравятся задачи! Желаем вам удачи и удовольствия от решения задач~",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 724
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500, \"k\");\n    inf.readEoln();\n\n    // Read l\n    int len_l = inf.readInt(1, 200, \"len_l\");\n    inf.readSpace();\n    vector<int> l_digits = inf.readInts(len_l, 0, m - 1, \"l_digits\");\n    ensuref(l_digits[0] > 0, \"The first digit of l must be greater than 0\");\n    inf.readEoln();\n\n    // Read r\n    int len_r = inf.readInt(1, 200, \"len_r\");\n    inf.readSpace();\n    vector<int> r_digits = inf.readInts(len_r, 0, m - 1, \"r_digits\");\n    ensuref(r_digits[0] > 0, \"The first digit of r must be greater than 0\");\n    inf.readEoln();\n\n    // Ensure 1 ≤ l ≤ r\n    auto compareDigits = [](const vector<int>& a, const vector<int>& b) {\n        if (a.size() != b.size())\n            return (a.size() < b.size()) ? -1 : 1;\n        for (int i = 0; i < (int)a.size(); i++) {\n            if (a[i] != b[i])\n                return (a[i] < b[i]) ? -1 : 1;\n        }\n        return 0;\n    };\n\n    int cmp = compareDigits(l_digits, r_digits);\n    ensuref(cmp <= 0, \"l must be less than or equal to r\");\n\n    // Read n number strings\n    int total_len = 0;\n    for (int i = 0; i < n; i++) {\n        int len_i = inf.readInt(1, 200, \"len_i\");\n        total_len += len_i;\n        ensuref(total_len <= 200, \"Sum of lengths of number strings must be ≤ 200\");\n\n        inf.readSpace();\n        vector<int> digits_i = inf.readInts(len_i, 0, m - 1, \"digits_i\");\n        inf.readSpace();\n        int v_i = inf.readInt(1, 200, \"v_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500, \"k\");\n    inf.readEoln();\n\n    // Read l\n    int len_l = inf.readInt(1, 200, \"len_l\");\n    inf.readSpace();\n    vector<int> l_digits = inf.readInts(len_l, 0, m - 1, \"l_digits\");\n    ensuref(l_digits[0] > 0, \"The first digit of l must be greater than 0\");\n    inf.readEoln();\n\n    // Read r\n    int len_r = inf.readInt(1, 200, \"len_r\");\n    inf.readSpace();\n    vector<int> r_digits = inf.readInts(len_r, 0, m - 1, \"r_digits\");\n    ensuref(r_digits[0] > 0, \"The first digit of r must be greater than 0\");\n    inf.readEoln();\n\n    // Ensure 1 ≤ l ≤ r\n    auto compareDigits = [](const vector<int>& a, const vector<int>& b) {\n        if (a.size() != b.size())\n            return (a.size() < b.size()) ? -1 : 1;\n        for (int i = 0; i < (int)a.size(); i++) {\n            if (a[i] != b[i])\n                return (a[i] < b[i]) ? -1 : 1;\n        }\n        return 0;\n    };\n\n    int cmp = compareDigits(l_digits, r_digits);\n    ensuref(cmp <= 0, \"l must be less than or equal to r\");\n\n    // Read n number strings\n    int total_len = 0;\n    for (int i = 0; i < n; i++) {\n        int len_i = inf.readInt(1, 200, \"len_i\");\n        total_len += len_i;\n        ensuref(total_len <= 200, \"Sum of lengths of number strings must be ≤ 200\");\n\n        inf.readSpace();\n        vector<int> digits_i = inf.readInts(len_i, 0, m - 1, \"digits_i\");\n        inf.readSpace();\n        int v_i = inf.readInt(1, 200, \"v_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 20, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 500, \"k\");\n    inf.readEoln();\n\n    // Read l\n    int len_l = inf.readInt(1, 200, \"len_l\");\n    inf.readSpace();\n    vector<int> l_digits = inf.readInts(len_l, 0, m - 1, \"l_digits\");\n    ensuref(l_digits[0] > 0, \"The first digit of l must be greater than 0\");\n    inf.readEoln();\n\n    // Read r\n    int len_r = inf.readInt(1, 200, \"len_r\");\n    inf.readSpace();\n    vector<int> r_digits = inf.readInts(len_r, 0, m - 1, \"r_digits\");\n    ensuref(r_digits[0] > 0, \"The first digit of r must be greater than 0\");\n    inf.readEoln();\n\n    // Ensure 1 ≤ l ≤ r\n    auto compareDigits = [](const vector<int>& a, const vector<int>& b) {\n        if (a.size() != b.size())\n            return (a.size() < b.size()) ? -1 : 1;\n        for (int i = 0; i < (int)a.size(); i++) {\n            if (a[i] != b[i])\n                return (a[i] < b[i]) ? -1 : 1;\n        }\n        return 0;\n    };\n\n    int cmp = compareDigits(l_digits, r_digits);\n    ensuref(cmp <= 0, \"l must be less than or equal to r\");\n\n    // Read n number strings\n    int total_len = 0;\n    for (int i = 0; i < n; i++) {\n        int len_i = inf.readInt(1, 200, \"len_i\");\n        total_len += len_i;\n        ensuref(total_len <= 200, \"Sum of lengths of number strings must be ≤ 200\");\n\n        inf.readSpace();\n        vector<int> digits_i = inf.readInts(len_i, 0, m - 1, \"digits_i\");\n        inf.readSpace();\n        int v_i = inf.readInt(1, 200, \"v_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a number in base m with specified length\nvector<int> generateNumber(int len, int m, bool leadingNonZero = true) {\n    vector<int> num(len);\n    if (leadingNonZero)\n        num[0] = rnd.next(1, m - 1);\n    else\n        num[0] = rnd.next(0, m - 1);\n    for (int i = 1; i < len; ++i) {\n        num[i] = rnd.next(0, m - 1);\n    }\n    return num;\n}\n\n// Function to output a number in the required format\nvoid outputNumber(const vector<int>& num) {\n    printf(\"%d\", (int)num.size());\n    for (int d : num) {\n        printf(\" %d\", d);\n    }\n    printf(\"\\n\");\n}\n\n// Function to output a number string with its associated value\nvoid outputNumberAndValue(const vector<int>& num, int vi) {\n    printf(\"%d\", (int)num.size());\n    for (int d : num) {\n        printf(\" %d\", d);\n    }\n    printf(\" %d\\n\", vi);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");          // Number of strings\n    int m = opt<int>(\"m\");          // Base\n    int k = opt<int>(\"k\");          // Value limit\n    string type = opt<string>(\"type\", \"random\");  // Type of test case\n\n    int len_l = opt<int>(\"len_l\", rnd.next(1, 200));  // Length of l\n    int len_r = opt<int>(\"len_r\", rnd.next(len_l, 200));  // Length of r\n\n    vector<int> l_num, r_num;\n\n    // Generate l and r based on the specified type\n    if (type == \"l_equals_r\") {\n        int len = opt<int>(\"len\", rnd.next(1, 200));\n        len_l = len_r = len;\n        l_num = generateNumber(len_l, m, true);\n        r_num = l_num;\n    } else if (type == \"max_range\") {\n        len_l = 1;\n        l_num = vector<int>(1, 1); // Minimal number\n        len_r = 200;\n        r_num = vector<int>(len_r, m - 1); // Maximal number\n    } else {\n        // Generate random l and r, ensure l ≤ r\n        l_num = generateNumber(len_l, m, true);\n        r_num = generateNumber(len_r, m, true);\n\n        // Comparator to ensure l ≤ r\n        auto cmpNumbers = [](const vector<int>& a, const vector<int>& b) {\n            if (a.size() != b.size()) {\n                return a.size() < b.size();\n            }\n            for (size_t i = 0; i < a.size(); ++i) {\n                if (a[i] != b[i])\n                    return a[i] < b[i];\n            }\n            return false; // Equal numbers\n        };\n\n        if (cmpNumbers(r_num, l_num)) {\n            swap(l_num, r_num);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output l\n    outputNumber(l_num);\n\n    // Output r\n    outputNumber(r_num);\n\n    // Generate n strings with associated values\n    // Ensure the sum of lengths does not exceed 200\n    int sum_len = 0;\n    int remaining_len = 200;\n    vector<pair< vector<int>, int> > strings;\n\n    for (int i = 0; i < n; ++i) {\n        int max_len = min(remaining_len - (n - i - 1), 200);\n        int len;\n        if (type == \"max_length_strings\") {\n            len = max_len;\n        } else if (type == \"min_length_strings\") {\n            len = 1;\n        } else {\n            len = rnd.next(1, max_len);\n        }\n        if (i == n -1) {\n            len = remaining_len;\n        }\n        remaining_len -= len;\n\n        bool leadingZeros = false;\n        if (type == \"leading_zeros_in_strings\") {\n            leadingZeros = true;\n        }\n\n        vector<int> str_num = generateNumber(len, m, !leadingZeros);\n\n        int vi;\n        if (type == \"max_vi\") {\n            vi = 200;\n        } else if (type == \"min_vi\") {\n            vi = 1;\n        } else {\n            vi = rnd.next(1, 200);\n        }\n\n        strings.emplace_back(str_num, vi);\n    }\n\n    // Output the strings and their associated values\n    for (const auto& p : strings) {\n        const vector<int>& str_num = p.first;\n        int vi = p.second;\n        outputNumberAndValue(str_num, vi);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a number in base m with specified length\nvector<int> generateNumber(int len, int m, bool leadingNonZero = true) {\n    vector<int> num(len);\n    if (leadingNonZero)\n        num[0] = rnd.next(1, m - 1);\n    else\n        num[0] = rnd.next(0, m - 1);\n    for (int i = 1; i < len; ++i) {\n        num[i] = rnd.next(0, m - 1);\n    }\n    return num;\n}\n\n// Function to output a number in the required format\nvoid outputNumber(const vector<int>& num) {\n    printf(\"%d\", (int)num.size());\n    for (int d : num) {\n        printf(\" %d\", d);\n    }\n    printf(\"\\n\");\n}\n\n// Function to output a number string with its associated value\nvoid outputNumberAndValue(const vector<int>& num, int vi) {\n    printf(\"%d\", (int)num.size());\n    for (int d : num) {\n        printf(\" %d\", d);\n    }\n    printf(\" %d\\n\", vi);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");          // Number of strings\n    int m = opt<int>(\"m\");          // Base\n    int k = opt<int>(\"k\");          // Value limit\n    string type = opt<string>(\"type\", \"random\");  // Type of test case\n\n    int len_l = opt<int>(\"len_l\", rnd.next(1, 200));  // Length of l\n    int len_r = opt<int>(\"len_r\", rnd.next(len_l, 200));  // Length of r\n\n    vector<int> l_num, r_num;\n\n    // Generate l and r based on the specified type\n    if (type == \"l_equals_r\") {\n        int len = opt<int>(\"len\", rnd.next(1, 200));\n        len_l = len_r = len;\n        l_num = generateNumber(len_l, m, true);\n        r_num = l_num;\n    } else if (type == \"max_range\") {\n        len_l = 1;\n        l_num = vector<int>(1, 1); // Minimal number\n        len_r = 200;\n        r_num = vector<int>(len_r, m - 1); // Maximal number\n    } else {\n        // Generate random l and r, ensure l ≤ r\n        l_num = generateNumber(len_l, m, true);\n        r_num = generateNumber(len_r, m, true);\n\n        // Comparator to ensure l ≤ r\n        auto cmpNumbers = [](const vector<int>& a, const vector<int>& b) {\n            if (a.size() != b.size()) {\n                return a.size() < b.size();\n            }\n            for (size_t i = 0; i < a.size(); ++i) {\n                if (a[i] != b[i])\n                    return a[i] < b[i];\n            }\n            return false; // Equal numbers\n        };\n\n        if (cmpNumbers(r_num, l_num)) {\n            swap(l_num, r_num);\n        }\n    }\n\n    // Output n, m, k\n    printf(\"%d %d %d\\n\", n, m, k);\n\n    // Output l\n    outputNumber(l_num);\n\n    // Output r\n    outputNumber(r_num);\n\n    // Generate n strings with associated values\n    // Ensure the sum of lengths does not exceed 200\n    int sum_len = 0;\n    int remaining_len = 200;\n    vector<pair< vector<int>, int> > strings;\n\n    for (int i = 0; i < n; ++i) {\n        int max_len = min(remaining_len - (n - i - 1), 200);\n        int len;\n        if (type == \"max_length_strings\") {\n            len = max_len;\n        } else if (type == \"min_length_strings\") {\n            len = 1;\n        } else {\n            len = rnd.next(1, max_len);\n        }\n        if (i == n -1) {\n            len = remaining_len;\n        }\n        remaining_len -= len;\n\n        bool leadingZeros = false;\n        if (type == \"leading_zeros_in_strings\") {\n            leadingZeros = true;\n        }\n\n        vector<int> str_num = generateNumber(len, m, !leadingZeros);\n\n        int vi;\n        if (type == \"max_vi\") {\n            vi = 200;\n        } else if (type == \"min_vi\") {\n            vi = 1;\n        } else {\n            vi = rnd.next(1, 200);\n        }\n\n        strings.emplace_back(str_num, vi);\n    }\n\n    // Output the strings and their associated values\n    for (const auto& p : strings) {\n        const vector<int>& str_num = p.first;\n        int vi = p.second;\n        outputNumberAndValue(str_num, vi);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 2 -k 1 -type random\n./gen -n 200 -m 20 -k 500 -type random\n./gen -n 100 -m 10 -k 250 -type random\n./gen -n 1 -m 2 -k 1 -type l_equals_r -len 1\n./gen -n 200 -m 20 -k 500 -type l_equals_r -len 200\n./gen -n 1 -m 2 -k 1 -type leading_zeros_in_strings\n./gen -n 200 -m 20 -k 500 -type leading_zeros_in_strings\n./gen -n 100 -m 10 -k 250 -type leading_zeros_in_strings\n./gen -n 1 -m 2 -k 1 -type max_range\n./gen -n 200 -m 20 -k 500 -type max_range\n./gen -n 200 -m 2 -k 500 -type max_range\n./gen -n 1 -m 2 -k 1 -type max_length_strings\n./gen -n 200 -m 20 -k 500 -type max_length_strings\n./gen -n 100 -m 10 -k 250 -type max_length_strings\n./gen -n 200 -m 2 -k 500 -type min_length_strings\n./gen -n 1 -m 20 -k 1 -type min_length_strings\n./gen -n 200 -m 5 -k 10 -type random\n./gen -n 50 -m 15 -k 100 -type random\n./gen -n 150 -m 7 -k 300 -type random\n./gen -n 20 -m 20 -k 500 -type random\n./gen -n 100 -m 2 -k 250 -type random\n./gen -n 200 -m 2 -k 500 -type leading_zeros_in_strings\n./gen -n 200 -m 2 -k 1 -type min_length_strings\n./gen -n 200 -m 20 -k 1 -type max_length_strings\n./gen -n 1 -m 2 -k 500 -type l_equals_r -len 1\n./gen -n 1 -m 20 -k 1 -type l_equals_r -len 200\n./gen -n 200 -m 10 -k 500 -type random\n./gen -n 200 -m 10 -k 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:39.240960",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "434/D",
      "title": "D. Nanami's Power Plant",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 50; 0 ≤ m ≤ 100) — the number of generators and the number of restrictions.Then follow n lines, each line contains three integers ai, bi, and ci (|ai| ≤ 10; |bi|, |ci| ≤ 1000) — the coefficients of the function fi(x). That is, fi(x) = aix2 + bix + ci.Then follow another n lines, each line contains two integers li and ri ( - 100 ≤ li ≤ ri ≤ 100).Then follow m lines, each line contains three integers ui, vi, and di (1 ≤ ui, vi ≤ n; ui ≠ vi; |di| ≤ 200), describing a restriction. The i-th restriction is xui ≤ xvi + di.",
      "output_spec": "OutputPrint a single line containing a single integer — the maximum output of all the generators. It is guaranteed that there exists at least one valid configuration.",
      "sample_tests": "ExamplesInputCopy3 30 1 00 1 10 1 20 31 2-100 1001 2 02 3 03 1 0OutputCopy9InputCopy5 81 -8 202 -4 0-1 10 -100 1 00 -1 11 91 40 103 117 92 1 31 2 32 3 33 2 33 4 34 3 34 5 35 4 3OutputCopy46",
      "description": "D. Nanami's Power Plant\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 50; 0 ≤ m ≤ 100) — the number of generators and the number of restrictions.Then follow n lines, each line contains three integers ai, bi, and ci (|ai| ≤ 10; |bi|, |ci| ≤ 1000) — the coefficients of the function fi(x). That is, fi(x) = aix2 + bix + ci.Then follow another n lines, each line contains two integers li and ri ( - 100 ≤ li ≤ ri ≤ 100).Then follow m lines, each line contains three integers ui, vi, and di (1 ≤ ui, vi ≤ n; ui ≠ vi; |di| ≤ 200), describing a restriction. The i-th restriction is xui ≤ xvi + di.\n\nOutputPrint a single line containing a single integer — the maximum output of all the generators. It is guaranteed that there exists at least one valid configuration.\n\nInputCopy3 30 1 00 1 10 1 20 31 2-100 1001 2 02 3 03 1 0OutputCopy9InputCopy5 81 -8 202 -4 0-1 10 -100 1 00 -1 11 91 40 103 117 92 1 31 2 32 3 33 2 33 4 34 3 34 5 35 4 3OutputCopy46\n\nInputCopy3 30 1 00 1 10 1 20 31 2-100 1001 2 02 3 03 1 0\n\nOutputCopy9\n\nInputCopy5 81 -8 202 -4 0-1 10 -100 1 00 -1 11 91 40 103 117 92 1 31 2 32 3 33 2 33 4 34 3 34 5 35 4 3\n\nOutputCopy46\n\nNoteIn the first sample, f1(x) = x, f2(x) = x + 1, and f3(x) = x + 2, so we are to maximize the sum of the generating levels. The restrictions are x1 ≤ x2, x2 ≤ x3, and x3 ≤ x1, which gives us x1 = x2 = x3. The optimal configuration is x1 = x2 = x3 = 2, which produces an output of 9.In the second sample, restrictions are equal to |xi - xi + 1| ≤ 3 for 1 ≤ i < n. One of the optimal configurations is x1 = 1, x2 = 4, x3 = 5, x4 = 8 and x5 = 7.",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int from, to;\n    int weight;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(-10, 10, \"a_i\");\n        inf.readSpace();\n        b[i] = inf.readInt(-1000, 1000, \"b_i\");\n        inf.readSpace();\n        c[i] = inf.readInt(-1000, 1000, \"c_i\");\n        inf.readEoln();\n    }\n\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        l[i] = inf.readInt(-100, 100, \"l_i\");\n        inf.readSpace();\n        r[i] = inf.readInt(-100, 100, \"r_i\");\n        inf.readEoln();\n        ensuref(l[i] <= r[i], \"l[%d]=%d should be <= r[%d]=%d\", i+1, l[i], i+1, r[i]);\n    }\n\n    vector<Edge> edges;\n\n    for (int i = 0; i < n; ++i) {\n        // xi ≤ ri => xi - s ≤ ri => edge s(0) -> xi(i+1) with weight ri\n        edges.push_back({0, i + 1, r[i]});\n\n        // xi ≥ li => s - xi ≤ -li => edge xi(i+1) -> s(0) with weight -li\n        edges.push_back({i + 1, 0, -l[i]});\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"v_i\");\n        ensuref(ui != vi, \"u_i (%d) should not equal v_i (%d)\", ui, vi);\n        inf.readSpace();\n        int di = inf.readInt(-200, 200, \"d_i\");\n        inf.readEoln();\n\n        // x_ui ≤ x_vi + di => x_ui - x_vi ≤ di\n        // Edge from v_i to u_i with weight di\n        edges.push_back({vi, ui, di});\n    }\n\n    int N = n + 1; // Nodes from 0 to n (0 is s)\n    vector<long long> dist(N, 0);\n\n    bool updated = false;\n    for (int iter = 0; iter < N; ++iter) {\n        updated = false;\n        for (const Edge& e : edges) {\n            int u = e.from;\n            int v = e.to;\n            int w = e.weight;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                updated = true;\n            }\n        }\n        if (!updated) break;\n    }\n    if (updated) {\n        // Negative cycle detected\n        ensuref(false, \"Constraints are inconsistent, negative cycle detected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int from, to;\n    int weight;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(-10, 10, \"a_i\");\n        inf.readSpace();\n        b[i] = inf.readInt(-1000, 1000, \"b_i\");\n        inf.readSpace();\n        c[i] = inf.readInt(-1000, 1000, \"c_i\");\n        inf.readEoln();\n    }\n\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        l[i] = inf.readInt(-100, 100, \"l_i\");\n        inf.readSpace();\n        r[i] = inf.readInt(-100, 100, \"r_i\");\n        inf.readEoln();\n        ensuref(l[i] <= r[i], \"l[%d]=%d should be <= r[%d]=%d\", i+1, l[i], i+1, r[i]);\n    }\n\n    vector<Edge> edges;\n\n    for (int i = 0; i < n; ++i) {\n        // xi ≤ ri => xi - s ≤ ri => edge s(0) -> xi(i+1) with weight ri\n        edges.push_back({0, i + 1, r[i]});\n\n        // xi ≥ li => s - xi ≤ -li => edge xi(i+1) -> s(0) with weight -li\n        edges.push_back({i + 1, 0, -l[i]});\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"v_i\");\n        ensuref(ui != vi, \"u_i (%d) should not equal v_i (%d)\", ui, vi);\n        inf.readSpace();\n        int di = inf.readInt(-200, 200, \"d_i\");\n        inf.readEoln();\n\n        // x_ui ≤ x_vi + di => x_ui - x_vi ≤ di\n        // Edge from v_i to u_i with weight di\n        edges.push_back({vi, ui, di});\n    }\n\n    int N = n + 1; // Nodes from 0 to n (0 is s)\n    vector<long long> dist(N, 0);\n\n    bool updated = false;\n    for (int iter = 0; iter < N; ++iter) {\n        updated = false;\n        for (const Edge& e : edges) {\n            int u = e.from;\n            int v = e.to;\n            int w = e.weight;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                updated = true;\n            }\n        }\n        if (!updated) break;\n    }\n    if (updated) {\n        // Negative cycle detected\n        ensuref(false, \"Constraints are inconsistent, negative cycle detected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int from, to;\n    int weight;\n};\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 50, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a(n), b(n), c(n);\n    for (int i = 0; i < n; ++i) {\n        a[i] = inf.readInt(-10, 10, \"a_i\");\n        inf.readSpace();\n        b[i] = inf.readInt(-1000, 1000, \"b_i\");\n        inf.readSpace();\n        c[i] = inf.readInt(-1000, 1000, \"c_i\");\n        inf.readEoln();\n    }\n\n    vector<int> l(n), r(n);\n    for (int i = 0; i < n; ++i) {\n        l[i] = inf.readInt(-100, 100, \"l_i\");\n        inf.readSpace();\n        r[i] = inf.readInt(-100, 100, \"r_i\");\n        inf.readEoln();\n        ensuref(l[i] <= r[i], \"l[%d]=%d should be <= r[%d]=%d\", i+1, l[i], i+1, r[i]);\n    }\n\n    vector<Edge> edges;\n\n    for (int i = 0; i < n; ++i) {\n        // xi ≤ ri => xi - s ≤ ri => edge s(0) -> xi(i+1) with weight ri\n        edges.push_back({0, i + 1, r[i]});\n\n        // xi ≥ li => s - xi ≤ -li => edge xi(i+1) -> s(0) with weight -li\n        edges.push_back({i + 1, 0, -l[i]});\n    }\n\n    for (int i = 0; i < m; ++i) {\n        int ui = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int vi = inf.readInt(1, n, \"v_i\");\n        ensuref(ui != vi, \"u_i (%d) should not equal v_i (%d)\", ui, vi);\n        inf.readSpace();\n        int di = inf.readInt(-200, 200, \"d_i\");\n        inf.readEoln();\n\n        // x_ui ≤ x_vi + di => x_ui - x_vi ≤ di\n        // Edge from v_i to u_i with weight di\n        edges.push_back({vi, ui, di});\n    }\n\n    int N = n + 1; // Nodes from 0 to n (0 is s)\n    vector<long long> dist(N, 0);\n\n    bool updated = false;\n    for (int iter = 0; iter < N; ++iter) {\n        updated = false;\n        for (const Edge& e : edges) {\n            int u = e.from;\n            int v = e.to;\n            int w = e.weight;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                updated = true;\n            }\n        }\n        if (!updated) break;\n    }\n    if (updated) {\n        // Negative cycle detected\n        ensuref(false, \"Constraints are inconsistent, negative cycle detected\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), c(n), l(n), r(n);\n    vector<tuple<int,int,int>> constraints;\n\n    // Generate coefficients a_i, b_i, c_i\n    // ai ∈ [-10, 10], bi ∈ [-1000, 1000], ci ∈ [-1000, 1000]\n    for (int i = 0; i < n; ++i) {\n        a[i] = rnd.next(-10, 10);\n        b[i] = rnd.next(-1000, 1000);\n        c[i] = rnd.next(-1000, 1000);\n    }\n\n    if (type == \"random\") {\n        // Generate l_i, r_i and x_i randomly\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n            x[i] = rnd.next(l[i], r[i]);\n        }\n\n        // Generate constraints based on x to ensure feasible solution\n        m = min(m, n * (n - 1)); // Maximum number of distinct pairs u != v\n        set<pair<int,int>> used_pairs;\n        constraints.clear();\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n\n            // Ensure x_u ≤ x_v + d\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            if (d > 200) d = 200;\n            if (d < -200) d = -200;\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"boundary\") {\n        // Set l_i = r_i\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = l[i];\n        }\n        // Generate x_i = l_i\n\n        // Constraints can be random since x_i are fixed\n        m = min(m, n * (n - 1));\n        set<pair<int,int>> used_pairs;\n        constraints.clear();\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = l[u - 1] - l[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"equal\") {\n        // Generate constraints that force xi to be equal\n        // xi ≤ xj + 0, xj ≤ xi + 0\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n        }\n\n        constraints.clear();\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            constraints.emplace_back(u, v, 0);\n            constraints.emplace_back(v, u, 0);\n        }\n        m = constraints.size();\n\n    } else if (type == \"negative\") {\n        // Include negative 'ai', 'bi', 'ci', 'li', 'ri', 'di'\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10, 10);\n            b[i] = rnd.next(-1000, 1000);\n            c[i] = rnd.next(-1000, 1000);\n            l[i] = rnd.next(-100, 0);\n            r[i] = rnd.next(l[i], 0);\n        }\n        // Generate x_i within [li, ri]\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(l[i], r[i]);\n        }\n\n        m = min(m, n * (n - 1));\n        constraints.clear();\n        set<pair<int,int>> used_pairs;\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            d = rnd.next(-200, 200); // Allow negative 'd'\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"cycle\") {\n        // Create constraints forming a cycle\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n        }\n\n        constraints.clear();\n        for (int i = 0; i < n; ++i) {\n            int u = i + 1;\n            int v = (i + 1) % n + 1;\n            constraints.emplace_back(u, v, rnd.next(-200, 200));\n        }\n        m = constraints.size();\n\n    } else if (type == \"zero_m\") {\n        m = 0;\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n        }\n        constraints.clear();\n\n    } else if (type == \"tight\") {\n        // Generate tight constraints that force xi to specific values\n        // For example, xi = li\n\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], l[i] + 10);\n            x[i] = l[i];\n        }\n        m = min(m, n * (n - 1));\n        set<pair<int,int>> used_pairs;\n        constraints.clear();\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = duv;\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"max\") {\n        // Set ai negative, bi such that maximum is at ri\n        for (int i = 0; i < n; ++i) {\n            a[i] = -rnd.next(1, 10); // Negative ai\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n            b[i] = -2 * a[i] * r[i];\n            if (b[i] < -1000) b[i] = -1000;\n            if (b[i] > 1000) b[i] = 1000;\n            c[i] = rnd.next(-1000, 1000);\n        }\n        // Constraints can be random as long as we ensure feasibility\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = r[i]; // Optimal at ri\n        // Generate constraints based on x\n        m = min(m, n * (n - 1));\n        constraints.clear();\n        set<pair<int,int>> used_pairs;\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            constraints.emplace_back(u, v, d);\n        }\n    } else if (type == \"min\") {\n        // Set ai positive, bi such that maximum is at li\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10); // Positive ai\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n            b[i] = -2 * a[i] * l[i];\n            if (b[i] < -1000) b[i] = -1000;\n            if (b[i] > 1000) b[i] = 1000;\n            c[i] = rnd.next(-1000, 1000);\n        }\n        // Constraints can be random as long as we ensure feasibility\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = l[i]; // Optimal at li\n        // Generate constraints based on x\n        m = min(m, n * (n - 1));\n        constraints.clear();\n        set<pair<int,int>> used_pairs;\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            constraints.emplace_back(u, v, d);\n        }\n    }\n\n    // Finally, print the data\n\n    printf(\"%d %d\\n\", n, m);\n\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d\\n\", l[i], r[i]);\n\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d %d\\n\", get<0>(constraints[i]), get<1>(constraints[i]), get<2>(constraints[i]));\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n), b(n), c(n), l(n), r(n);\n    vector<tuple<int,int,int>> constraints;\n\n    // Generate coefficients a_i, b_i, c_i\n    // ai ∈ [-10, 10], bi ∈ [-1000, 1000], ci ∈ [-1000, 1000]\n    for (int i = 0; i < n; ++i) {\n        a[i] = rnd.next(-10, 10);\n        b[i] = rnd.next(-1000, 1000);\n        c[i] = rnd.next(-1000, 1000);\n    }\n\n    if (type == \"random\") {\n        // Generate l_i, r_i and x_i randomly\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n            x[i] = rnd.next(l[i], r[i]);\n        }\n\n        // Generate constraints based on x to ensure feasible solution\n        m = min(m, n * (n - 1)); // Maximum number of distinct pairs u != v\n        set<pair<int,int>> used_pairs;\n        constraints.clear();\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n\n            // Ensure x_u ≤ x_v + d\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            if (d > 200) d = 200;\n            if (d < -200) d = -200;\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"boundary\") {\n        // Set l_i = r_i\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = l[i];\n        }\n        // Generate x_i = l_i\n\n        // Constraints can be random since x_i are fixed\n        m = min(m, n * (n - 1));\n        set<pair<int,int>> used_pairs;\n        constraints.clear();\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = l[u - 1] - l[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"equal\") {\n        // Generate constraints that force xi to be equal\n        // xi ≤ xj + 0, xj ≤ xi + 0\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n        }\n\n        constraints.clear();\n        for (int i = 1; i < n; ++i) {\n            int u = i;\n            int v = i + 1;\n            constraints.emplace_back(u, v, 0);\n            constraints.emplace_back(v, u, 0);\n        }\n        m = constraints.size();\n\n    } else if (type == \"negative\") {\n        // Include negative 'ai', 'bi', 'ci', 'li', 'ri', 'di'\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(-10, 10);\n            b[i] = rnd.next(-1000, 1000);\n            c[i] = rnd.next(-1000, 1000);\n            l[i] = rnd.next(-100, 0);\n            r[i] = rnd.next(l[i], 0);\n        }\n        // Generate x_i within [li, ri]\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i) {\n            x[i] = rnd.next(l[i], r[i]);\n        }\n\n        m = min(m, n * (n - 1));\n        constraints.clear();\n        set<pair<int,int>> used_pairs;\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            d = rnd.next(-200, 200); // Allow negative 'd'\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"cycle\") {\n        // Create constraints forming a cycle\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n        }\n\n        constraints.clear();\n        for (int i = 0; i < n; ++i) {\n            int u = i + 1;\n            int v = (i + 1) % n + 1;\n            constraints.emplace_back(u, v, rnd.next(-200, 200));\n        }\n        m = constraints.size();\n\n    } else if (type == \"zero_m\") {\n        m = 0;\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n        }\n        constraints.clear();\n\n    } else if (type == \"tight\") {\n        // Generate tight constraints that force xi to specific values\n        // For example, xi = li\n\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i) {\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], l[i] + 10);\n            x[i] = l[i];\n        }\n        m = min(m, n * (n - 1));\n        set<pair<int,int>> used_pairs;\n        constraints.clear();\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = duv;\n            constraints.emplace_back(u, v, d);\n        }\n\n    } else if (type == \"max\") {\n        // Set ai negative, bi such that maximum is at ri\n        for (int i = 0; i < n; ++i) {\n            a[i] = -rnd.next(1, 10); // Negative ai\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n            b[i] = -2 * a[i] * r[i];\n            if (b[i] < -1000) b[i] = -1000;\n            if (b[i] > 1000) b[i] = 1000;\n            c[i] = rnd.next(-1000, 1000);\n        }\n        // Constraints can be random as long as we ensure feasibility\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = r[i]; // Optimal at ri\n        // Generate constraints based on x\n        m = min(m, n * (n - 1));\n        constraints.clear();\n        set<pair<int,int>> used_pairs;\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            constraints.emplace_back(u, v, d);\n        }\n    } else if (type == \"min\") {\n        // Set ai positive, bi such that maximum is at li\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 10); // Positive ai\n            l[i] = rnd.next(-100, 100);\n            r[i] = rnd.next(l[i], 100);\n            b[i] = -2 * a[i] * l[i];\n            if (b[i] < -1000) b[i] = -1000;\n            if (b[i] > 1000) b[i] = 1000;\n            c[i] = rnd.next(-1000, 1000);\n        }\n        // Constraints can be random as long as we ensure feasibility\n        vector<int> x(n);\n        for (int i = 0; i < n; ++i)\n            x[i] = l[i]; // Optimal at li\n        // Generate constraints based on x\n        m = min(m, n * (n - 1));\n        constraints.clear();\n        set<pair<int,int>> used_pairs;\n        while ((int)constraints.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (used_pairs.count({u, v})) continue;\n            used_pairs.insert({u, v});\n            int duv = x[u - 1] - x[v - 1];\n            int d = rnd.next(duv, min(duv + 10, 200));\n            constraints.emplace_back(u, v, d);\n        }\n    }\n\n    // Finally, print the data\n\n    printf(\"%d %d\\n\", n, m);\n\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d %d\\n\", a[i], b[i], c[i]);\n\n    for (int i = 0; i < n; ++i)\n        printf(\"%d %d\\n\", l[i], r[i]);\n\n    for (int i = 0; i < m; ++i)\n        printf(\"%d %d %d\\n\", get<0>(constraints[i]), get<1>(constraints[i]), get<2>(constraints[i]));\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 0 -type zero_m\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 1 -type min\n./gen -n 2 -m 1 -type max\n./gen -n 2 -m 1 -type equal\n./gen -n 5 -m 0 -type zero_m\n./gen -n 5 -m 10 -type negative\n./gen -n 10 -m 20 -type random\n./gen -n 20 -m 50 -type random\n./gen -n 30 -m 60 -type cycle\n./gen -n 40 -m 80 -type boundary\n./gen -n 50 -m 0 -type zero_m\n./gen -n 50 -m 50 -type min\n./gen -n 50 -m 50 -type max\n./gen -n 50 -m 80 -type tight\n./gen -n 50 -m 90 -type equal\n./gen -n 50 -m 99 -type random\n./gen -n 50 -m 100 -type random\n./gen -n 50 -m 100 -type max\n./gen -n 50 -m 100 -type min\n./gen -n 50 -m 100 -type negative\n./gen -n 50 -m 100 -type boundary\n./gen -n 50 -m 100 -type equal\n./gen -n 50 -m 100 -type tight\n./gen -n 50 -m 100 -type cycle\n./gen -n 1 -m 0 -type boundary\n./gen -n 1 -m 0 -type negative\n./gen -n 50 -m 100 -type zero_m\n./gen -n 1 -m 0 -type random\n./gen -n 50 -m 100 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:41.976513",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "434/E",
      "title": "E. Furukawa Nagisa's Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains four integers n, y, k and x (1 ≤ n ≤ 105; 2 ≤ y ≤ 109; 1 ≤ k < y; 0 ≤ x < y) — n being the number of nodes on the tree. It is guaranteed that y is a prime number.The second line contains n integers, the i-th integer is vi (0 ≤ vi < y).Then follow n - 1 lines, each line contains two integers, denoting an edge of the tree. The nodes of the tree are numbered from 1 to n.",
      "output_spec": "OutputOutput a single integer — the number of triplets that are correct for Furukawa Nagisa's conclusion.",
      "sample_tests": "ExamplesInputCopy1 2 1 01OutputCopy1InputCopy3 5 2 14 3 11 22 3OutputCopy14InputCopy8 13 8 120 12 7 4 12 0 8 121 88 44 66 22 38 52 7OutputCopy341",
      "description": "E. Furukawa Nagisa's Tree\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains four integers n, y, k and x (1 ≤ n ≤ 105; 2 ≤ y ≤ 109; 1 ≤ k < y; 0 ≤ x < y) — n being the number of nodes on the tree. It is guaranteed that y is a prime number.The second line contains n integers, the i-th integer is vi (0 ≤ vi < y).Then follow n - 1 lines, each line contains two integers, denoting an edge of the tree. The nodes of the tree are numbered from 1 to n.\n\nOutputOutput a single integer — the number of triplets that are correct for Furukawa Nagisa's conclusion.\n\nInputCopy1 2 1 01OutputCopy1InputCopy3 5 2 14 3 11 22 3OutputCopy14InputCopy8 13 8 120 12 7 4 12 0 8 121 88 44 66 22 38 52 7OutputCopy341\n\nInputCopy1 2 1 01\n\nOutputCopy1\n\nInputCopy3 5 2 14 3 11 22 3\n\nOutputCopy14\n\nInputCopy8 13 8 120 12 7 4 12 0 8 121 88 44 66 22 38 52 7\n\nOutputCopy341",
      "solutions": [
        {
          "title": "Codeforces Round #248 - Codeforces",
          "content": "Hello everybody!We invite you to participate in Codeforces Round #248, which will take place at 11:00AM MSK on Saturday, May 24th. This round will be held in both divisions. Note that the starting time of this round is quite unusual.The problems were prepared by zhonghaoxi, wyx528 and me. This is our first Codeforces round and we hope it will be a good one.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to colin and MSTyoda, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000. In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Hope you enjoy the problems! Good luck and have fun~UPD: Contest has finished! Editorial for the round can be found here: EditorialUPD2: System test has finished! Congratulations to the following winners!Top 5 of Div. 1: YuukaKazami KADR RAVEman Seyaua ikatanic Top 5 of Div. 2: jason_yu Kann tomsyp keavil Kazakh_Alga YuukaKazami is the only contestant to solve problem D! Sadly no one solved problem E during the contest.UPD3: Statistics of the round by DmitriyH is here: Statistics",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12378",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1185
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces",
          "content": "If you have any questions or suggestions, or if you have a solution different to ours that you want to share with us, feel free to comment below :)Author solutions are added. Div. 2 A — Kitahara Haruki's GiftDenote G as the sum of the weight of the apples. If G / 100 is not an even number, then the answer is obviously \"NO\". Otherwise, we need to check if there is a way of choosing apples, so that the sum of the weight of the chosen apples is exactly .A simple O(n) approach would be to enumerate how many 200-gram apples do we choose, and check if we can fill the rest with 100-gram apples. We can also solve this problem using a classic knapsack DP.Solution: 6712942 Div. 2 B — Kuriyama Mirai's StonesSort sequence v to obtain sequence u. Sorting can be done in using quicksort. Now we are interested in the sum of a interval of a given sequence. This can be done by calculating the prefix sum of the sequence beforehand. That is, let . The sum of numbers in the interval [l, r] would then be svr - svl - 1. We can deal with sequence u likewise.Preprocessing takes O(n) time, and answering a query is only O(1). The total complexity would be .Solution: 6713020 Div. 2 C / Div. 1 A — Ryouko's Memory NoteSuppose we're merging page x to page y. Obviously page x should be an element of sequence a, otherwise merging would have no effect. Enumerate all possible values of x, and denote sequence b as the elements of a that are adjacent to an element with value x. If one element is adjacent to two elements with value x, it should appear twice in b. However, if one element itself is x, it should not appear in b.For example, suppose we have a = {2, 2, 4, 1, 2, 1, 2, 3, 1}, then sequence b for x = 2 would be b = {4, 1, 1, 1, 3}, where the 6-th element appears twice.Problem remains for finding a optimum value for y. Let m be the length of sequence b. When merging x to y, the change in answer would beWe only care about the left part, as the right part has nothing to do with y. We can change our problem to the following: Given n numbers on the number axis, find a number x so that the sum of the distance between x and the n given numbers is minimum. This is, however, a classic problem. We have the following conclusion: The number x in the problem should be the median of the n numbers. Proof: Consider the case where n is odd. Proof is similar for cases where n is even. We choose an arbitary number as x. Suppose there are l numbers on the left of x, and r numbers on the right of x. If x is the median, then l = r, so what we're going to prove is that optimal answer cannot be achieved when l ≠ r. Suppose l < r, consider what would happen to the answer if we add d(d > 0) to x (Here we assume that adding d to x does not affect the values of l and r). The distance between x and all the numbers on the right would decrease by d, while the distance between x and all numbers on the left would increase by d. So the answer would decrease by (r - l)d, which is a positive value, since l < r. So x would keep increasing until l = r, when optimal answer can be achieved. Thus x is the median of the n numbers. This brings us to our solution. Simply sort sequence b and find its median, then calculate the answer. The final answer would be the optimal one from all possible values of x. The complexity is , as the sum of the length of all b sequences does not exceed 2n.About the pretests: Pretests for this problem are deliberately made weak, in order to make hacking more fun. None of the pretests contains adjacent numbers with the same value.Solution: 6712939, 6713018 Div. 2 D / Div. 1 B — Nanami's Digital BoardConsider a similar problem: find the maximum light-block of the whole board. Constraints to this problem are the same as the original problem, but with no further operations.A brute-force idea would be to enumerate all four edges of the block, checking can be done with two-dimensional prefix sums, so the time complexity is O(n4). Obviously it would receive a TLE verdict.Why should we enumerate all four edges? Let's enumerate the lower- and upper-edge, and now our problem is only one-dimensional, which can be easily solved in O(n) time. Now our complexity is O(n3), still not fast enough.Let's try to enumerate the lower-edge only, and now what we have is an array up[], denoting the maximum \"height\" of each column. To be specific, suppose the lower-edge is row x, then up[i] is the maximum value such that (x, i), (x - 1, i), ..., (x - up[i] + 1, i) are all light. If we choose columns l and r as the left- and right-edge, then the area of the maximum light-block with these three sides fixed would beLet , what if we enumerate h, and find the leftmost l and the rightmost r? To be more specific, we enumerate a column p, and let the height of this column be the height of the block. Now we want to \"stretch\" the left and right sides of the block, so we're looking for the leftmost column l such that . Similarly look for the rightmost column r, then the maximum light block with its lower-edge and a point in the upper-edge fixed would be (r - l + 1)·up[p].This approach can be optimized with disjoint-set unions (abbr. DSU). Imagine that initially the up[] array is empty. Let's add the elements of up[] one by one, from the largest to the smallest. Maintain two DSUs, and denote them as L and R.When we add an element up[i], set the father of i as i + 1 in R, so that i will be \"skipped\" during the \"find\" operation of DSU. Similarly set the father of i as i - 1 in L. Simply find the root of i in L and R, and we would have l and r.Now this problem can be solved in quasi-quadratic time. We can actually further optimize it to quadratic time using monotonic queues, but we'll not talk about it here. Let's go back to the original problem.Suppose there are no modifications, operations only contain queries. Then we could simply maintain the up[] array of every row, and similarly maintain down[], left[] and right[] arrays. Use the approach described above to achieve quasi-linear time for the answering of a query.Now consider modifications. Modification of a single pixel only changes the values of O(n + m) positions of the arrays. So modifications can be handled in linear time.The total complexity for the algorithm is O(n2 + qn·α(n)), where α(n) is the inverse of the Ackermann function, which is often seen in the analysis of the time complexity of DSUs.Solution: 6712937, 6713016 Div. 2 E / Div. 1 C — Tachibana Kanade's TofuA straightforward brute-force idea would be to enumerate all numbers in the interval [l, r], and count how many of them have a value greater than k. This approach is way too slow, but nevertheless let's try optimizing it first.The enumeration part seems hard to optimize, so let's consider what is the fastest way of calculating the value of a string. This is a classic problem that can be solved using an Aho-Corasick automaton (abbr. ACA). Build an ACA with the given number strings, and simply \"walk\" in the automaton according to the string to be calculated.Consider a common method when dealing with digits — split the interval [l, r] into two, [1, r] minus [1, l - 1]. Then use DP to solve an interval, take [1, r] for instance. Consider filling in the numbers one by one, we need to record in the states of the DP the position in the string, and a flag denoting whether we're \"walking on the edge of the upper bound\", that is, whether the numbers we've filled are the prefix of the upper-bound r.How can we use the approach above in this problem? Can we combine this approach with our ACA? The answer is yes, further record in the states of the DP the ID of the node we're currently \"standing on\" in the ACA. Consider the transfer of this DP, enumerate which number we're going to fill in, and check using our flag if the current number will be greater than the upper-bound. Appending a number to the end of our string would result in a change of the ID of the node in our ACA, so \"walk\" along the transferring edge in the ACA.What about the limit of values? Simply record the current value in our DP state, during transfer, add the value stored in the ACA's node to the value stored in our state.The tricky bit is the leading zeros. Numbers can't have leading zeros, but number strings can. How can we distinguish leading zeros from zeros in the middle of the number? We keep another flag, denoting whether we're still dealing with leading zeros.So finally our state looks like f[len][node][val][upper_bound_flag][leading_zero_flag], where len, node, and val are current length of number, ID of current node in ACA, and current value of number respectively. Let N be the total length of all number string, and L be the length of r, the total complexity would be O(NLkm), since the number of states is O(NLk) and transfer takes O(m) time.Solution for the approach above: 6712934 Solution for a different approach: 6713013 Div. 1 D — Nanami's Power PlantWe can use a flow network to solve the problem.For each variable xi, create ri - li + 2 points, and denote them as node(i, li - 1) to node(i, ri). Edges are as follows: Link source to each node(i, li - 1) with capacity of infinity. Link each node(i, ri) to sink with capacity of infinity. Link each node(i, x - 1) to node(i, x) with capacity of MAX - fi(x). Here MAX is a number greater than every possible value of the variables. Let C be the value of the minimum cut of this network. If there are no further restrictions, it is obvious that MAX·n - C is the maximum profit.Now consider the restrictions. Suppose a restriction is xu ≤ xv + d, then for each node(u, x), link it to node(v, x - d) (if exists) with a capacity of infinity. If there exists a solution, MAX·n - C will be the optimal profit.We want to prove that the edges with infinite capacity can really restrict our choice of values for variables. Note that a valid solution is correspondent to a cut of the graph. It can be proved that if a restriction is not satisfied, there will be a augmenting path in the graph. You can verify this by drawing the graphs. And because we are looking for the minimum cut, in this case the maximum sum, there can be no valid solution with a greater sum.About the time limit: The time limit for this problem is 5 seconds, which is by far greater than this solution actually need. We set the time limit to 5 seconds because of possible worst-case complexity of the maximum flow algorithm, although in \"real-life\" cases that complexity is never achieved.About the solution: This solution takes advantage of the fact that there are few possible values for the variables. And also the fact that functions are all quadratic is no use here, so statements may be quite misleading. If you have any ideas on how to solve the problem with a larger range for variables, or a solution using the fact that functions are quadratic, please share it in the comments :)Solution: 6712933, 6713009 Div. 1 E — Furukawa Nagisa's TreeIn order not to mess things up, we use capital letters X, Y and K to denote the values in the original problem.First, we can build a directed graph with n2 edges. Let E(i, j) be the edge from node i to node j. If path (i, j) is good, the color of E(i, j) is 0, otherwise it is 1.We want to calculate the number of triplets (i, j, k) that satisfies (i, j), (j, k) and (i, k) are all good or all not good. It equals the number of directed triangles, the color of whose three edges are the same. (The triangle is like: )Calculating this is difficult, so let us calculate the number of directed triangles whose three edges are not all the same.Let in0[i] be the number of in-edges of node i whose color is 0. Similarly define in1[i], out0[i], out1[i]. LetWe can see that the answer is twice the number of triangles whose three edges are not all the same. So we can see the answer of the original problem is n3 - p / 2.It's certain that out0[i] + out1[i] = in0[i] + in1[i] = n, so we only need to calculate out0 and in0.Let us calculate out0 first. We can use the \"Divide and Conquer on trees\" algorithm to solve this in time. Choose a root i and get its subtree, we can get all the values of the paths from a node in the subtree to node i. We save the values and the lengths of the paths.For a path from node j with value v and length l, we want to find a node k which makes G(S(j, k)) ≡ X (mod Y). Let H(i, j) be the sequence of the value of nodes on (i, j) except node i, thenG(S(j, k)) = G(S(j, i)) + G(H(i, k))·Kl = v + G(H(i, k))·KlAs (v + G(H(i, k))·Kl) ≡ X (mod Y), so G(H(i, k)) = (X - v) / Kl. As Y is a prime number, we can get (x - v) / Kl easily. Let z = (x - v) / Kl, then the problem becomes that we need to calculate how many paths from node i to a node in the subtree except node i, whose value is z, this can be done by doing binary search on a sorted array. So we can get out0, and in0 likewise.With these two arrays we can calculate the answer. The total complexity is .Solution: 6707988, 6712931",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12397",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 12951
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #248 - Codeforces - Code 1",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 2",
          "code": "The hack uses generator\nhack.java:464: error: cannot find symbol\n        new Thread(null, new Java7QuicksortKiller(), \"\", 128*1024*1024).start();\n                             ^\n  symbol:   class Java7QuicksortKiller\n  location: class hack\n1 error",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 3",
          "code": "Java7QuicksortKiller",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 4",
          "code": "Tachibana Kanade's Tofu",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 - Codeforces - Code 5",
          "code": "Arrays.sort",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12378",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 1",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 2",
          "code": "inline int solve(int n, int x) {\n\tint maxh = h[x], ans = maxh, lft = x, rgt = x;\n\tfor(int lim = h[x];  lim > 0; --lim) {\n\t\twhile(lft >= 0 && h[lft] >= lim) --lft;\n\t\twhile(rgt < n && h[rgt] >= lim) ++rgt;\n\t\tans = max(ans, (rgt - lft - 1) * lim);\n\t}\n\treturn ans;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #248 Editorial - Codeforces - Code 3",
          "code": "freq100 % 2 == 1 ? \"NO\" : freq200 % 2 == 1 && freq100 == 0 ? \"NO\": \"YES\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12397",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if(n <= 1) return false;\n    if(n <= 3) return true;\n    if(n % 2 == 0) return false;\n    int sqrt_n = int(sqrt(n)) + 1;\n    for(int i = 3; i <= sqrt_n; i += 2) {\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nconst int MAXN = 100005;\nint parent[MAXN];\n\nint find(int x) {\n    if(parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int y = inf.readInt(2, 1000000000, \"y\");\n    ensuref(isPrime(y), \"y must be a prime number\");\n    inf.readSpace();\n    int k = inf.readInt(1, y - 1, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(0, y - 1, \"x\");\n    inf.readEoln();\n\n    vector<int> values = inf.readInts(n, 0, y - 1, \"v_i\");\n    inf.readEoln();\n\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n    int components = n;\n    set<pair<int, int>> edges;\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops are allowed (u_i != v_i) on edge %d\", i + 1);\n\n        int a = min(u, v), b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Duplicate edge between %d and %d\", a, b);\n        edges.insert({a, b});\n\n        int pu = find(u), pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle at edge %d\", i + 1);\n        parent[pu] = pv;\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if(n <= 1) return false;\n    if(n <= 3) return true;\n    if(n % 2 == 0) return false;\n    int sqrt_n = int(sqrt(n)) + 1;\n    for(int i = 3; i <= sqrt_n; i += 2) {\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nconst int MAXN = 100005;\nint parent[MAXN];\n\nint find(int x) {\n    if(parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int y = inf.readInt(2, 1000000000, \"y\");\n    ensuref(isPrime(y), \"y must be a prime number\");\n    inf.readSpace();\n    int k = inf.readInt(1, y - 1, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(0, y - 1, \"x\");\n    inf.readEoln();\n\n    vector<int> values = inf.readInts(n, 0, y - 1, \"v_i\");\n    inf.readEoln();\n\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n    int components = n;\n    set<pair<int, int>> edges;\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops are allowed (u_i != v_i) on edge %d\", i + 1);\n\n        int a = min(u, v), b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Duplicate edge between %d and %d\", a, b);\n        edges.insert({a, b});\n\n        int pu = find(u), pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle at edge %d\", i + 1);\n        parent[pu] = pv;\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPrime(int n) {\n    if(n <= 1) return false;\n    if(n <= 3) return true;\n    if(n % 2 == 0) return false;\n    int sqrt_n = int(sqrt(n)) + 1;\n    for(int i = 3; i <= sqrt_n; i += 2) {\n        if(n % i == 0) return false;\n    }\n    return true;\n}\n\nconst int MAXN = 100005;\nint parent[MAXN];\n\nint find(int x) {\n    if(parent[x] != x) parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int y = inf.readInt(2, 1000000000, \"y\");\n    ensuref(isPrime(y), \"y must be a prime number\");\n    inf.readSpace();\n    int k = inf.readInt(1, y - 1, \"k\");\n    inf.readSpace();\n    int x = inf.readInt(0, y - 1, \"x\");\n    inf.readEoln();\n\n    vector<int> values = inf.readInts(n, 0, y - 1, \"v_i\");\n    inf.readEoln();\n\n    for(int i = 1; i <= n; ++i) parent[i] = i;\n    int components = n;\n    set<pair<int, int>> edges;\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n        ensuref(u != v, \"No self-loops are allowed (u_i != v_i) on edge %d\", i + 1);\n\n        int a = min(u, v), b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Duplicate edge between %d and %d\", a, b);\n        edges.insert({a, b});\n\n        int pu = find(u), pv = find(v);\n        ensuref(pu != pv, \"Graph contains a cycle at edge %d\", i + 1);\n        parent[pu] = pv;\n        components--;\n    }\n\n    ensuref(components == 1, \"Graph is not connected\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\nlong long powmod(long long base, long long exponent, long long mod) {\n    long long result = 1 % mod;\n    base = base % mod;\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = mulmod(result, base, mod);\n        base = mulmod(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nbool isPrime(long long n) {\n    if (n < 2)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    long long d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    vector<long long> bases = {2, 3, 5, 7, 11, 13, 17};\n    for (long long a : bases) {\n        if (a >= n)\n            continue;\n        long long x = powmod(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = mulmod(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long y = opt<long long>(\"y\");\n    long long k = opt<long long>(\"k\");\n    long long x = opt<long long>(\"x\");\n    string vi_type = opt<string>(\"vi_type\", \"random\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n\n    // Validate parameters\n    if (n < 1 || n > 100000) {\n        cerr << \"Error: n must be between 1 and 1e5.\" << endl;\n        exit(1);\n    }\n    if (y < 2 || y > 1000000000) {\n        cerr << \"Error: y must be between 2 and 1e9.\" << endl;\n        exit(1);\n    }\n    if (!isPrime(y)) {\n        cerr << \"Error: y must be a prime number.\" << endl;\n        exit(1);\n    }\n    if (k < 1 || k >= y) {\n        cerr << \"Error: k must be between 1 and y-1.\" << endl;\n        exit(1);\n    }\n    if (x < 0 || x >= y) {\n        cerr << \"Error: x must be between 0 and y-1.\" << endl;\n        exit(1);\n    }\n\n    // Generate the vi's\n    vector<long long> vi(n + 1);\n    if (vi_type == \"random\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = rnd.next(0LL, y - 1);\n        }\n    } else if (vi_type == \"const_zero\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = 0;\n        }\n    } else if (vi_type == \"const_one\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = 1 % y;\n        }\n    } else if (vi_type == \"const_y1\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = y - 1;\n        }\n    } else if (vi_type == \"increasing\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = (i - 1) % y;\n        }\n    } else if (vi_type == \"decreasing\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = (y - (i - 1) % y) % y;\n        }\n    } else {\n        cerr << \"Error: Unknown vi_type '\" << vi_type << \"'.\" << endl;\n        exit(1);\n    }\n\n    // Generate the tree\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; i++) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    } else {\n        cerr << \"Error: Unknown tree_type '\" << tree_type << \"'.\" << endl;\n        exit(1);\n    }\n\n    // Shuffle the nodes\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; i++) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Remap vi and edges according to perm\n    vector<long long> vi_new(n + 1);\n    for (int i = 1; i <= n; i++) {\n        vi_new[perm[i]] = vi[i];\n    }\n    vi = vi_new;\n\n    for (auto& edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n        if (rnd.next(0, 1)) {\n            swap(edge.first, edge.second);\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the data\n    printf(\"%d %lld %lld %lld\\n\", n, y, k, x);\n    for (int i = 1; i <= n; i++) {\n        printf(\"%lld%c\", vi[i], (i == n ? '\\n' : ' '));\n    }\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long mulmod(long long a, long long b, long long mod) {\n    return (a % mod) * (b % mod) % mod;\n}\n\nlong long powmod(long long base, long long exponent, long long mod) {\n    long long result = 1 % mod;\n    base = base % mod;\n    while (exponent > 0) {\n        if (exponent & 1)\n            result = mulmod(result, base, mod);\n        base = mulmod(base, base, mod);\n        exponent >>= 1;\n    }\n    return result;\n}\n\nbool isPrime(long long n) {\n    if (n < 2)\n        return false;\n    if (n <= 3)\n        return true;\n    if (n % 2 == 0)\n        return false;\n    long long d = n - 1;\n    int s = 0;\n    while ((d & 1) == 0) {\n        d >>= 1;\n        s++;\n    }\n    vector<long long> bases = {2, 3, 5, 7, 11, 13, 17};\n    for (long long a : bases) {\n        if (a >= n)\n            continue;\n        long long x = powmod(a, d, n);\n        if (x == 1 || x == n - 1)\n            continue;\n        bool composite = true;\n        for (int r = 0; r < s - 1; r++) {\n            x = mulmod(x, x, n);\n            if (x == n - 1) {\n                composite = false;\n                break;\n            }\n        }\n        if (composite)\n            return false;\n    }\n    return true;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long y = opt<long long>(\"y\");\n    long long k = opt<long long>(\"k\");\n    long long x = opt<long long>(\"x\");\n    string vi_type = opt<string>(\"vi_type\", \"random\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n\n    // Validate parameters\n    if (n < 1 || n > 100000) {\n        cerr << \"Error: n must be between 1 and 1e5.\" << endl;\n        exit(1);\n    }\n    if (y < 2 || y > 1000000000) {\n        cerr << \"Error: y must be between 2 and 1e9.\" << endl;\n        exit(1);\n    }\n    if (!isPrime(y)) {\n        cerr << \"Error: y must be a prime number.\" << endl;\n        exit(1);\n    }\n    if (k < 1 || k >= y) {\n        cerr << \"Error: k must be between 1 and y-1.\" << endl;\n        exit(1);\n    }\n    if (x < 0 || x >= y) {\n        cerr << \"Error: x must be between 0 and y-1.\" << endl;\n        exit(1);\n    }\n\n    // Generate the vi's\n    vector<long long> vi(n + 1);\n    if (vi_type == \"random\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = rnd.next(0LL, y - 1);\n        }\n    } else if (vi_type == \"const_zero\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = 0;\n        }\n    } else if (vi_type == \"const_one\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = 1 % y;\n        }\n    } else if (vi_type == \"const_y1\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = y - 1;\n        }\n    } else if (vi_type == \"increasing\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = (i - 1) % y;\n        }\n    } else if (vi_type == \"decreasing\") {\n        for (int i = 1; i <= n; i++) {\n            vi[i] = (y - (i - 1) % y) % y;\n        }\n    } else {\n        cerr << \"Error: Unknown vi_type '\" << vi_type << \"'.\" << endl;\n        exit(1);\n    }\n\n    // Generate the tree\n    vector<pair<int, int>> edges;\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (tree_type == \"random\") {\n        for (int i = 2; i <= n; i++) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    } else {\n        cerr << \"Error: Unknown tree_type '\" << tree_type << \"'.\" << endl;\n        exit(1);\n    }\n\n    // Shuffle the nodes\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; i++) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Remap vi and edges according to perm\n    vector<long long> vi_new(n + 1);\n    for (int i = 1; i <= n; i++) {\n        vi_new[perm[i]] = vi[i];\n    }\n    vi = vi_new;\n\n    for (auto& edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n        if (rnd.next(0, 1)) {\n            swap(edge.first, edge.second);\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the data\n    printf(\"%d %lld %lld %lld\\n\", n, y, k, x);\n    for (int i = 1; i <= n; i++) {\n        printf(\"%lld%c\", vi[i], (i == n ? '\\n' : ' '));\n    }\n    for (auto& edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random vi, random tree\n./gen -n 1 -y 2 -k 1 -x 0 -vi_type random -tree_type random\n./gen -n 3 -y 5 -k 2 -x 1 -vi_type random -tree_type random\n\n# Small n, vi all zeros, chain tree\n./gen -n 5 -y 7 -k 3 -x 2 -vi_type const_zero -tree_type chain\n\n# Small n, vi increasing, star tree\n./gen -n 10 -y 11 -k 5 -x 7 -vi_type increasing -tree_type star\n\n# Medium n, random vi, balanced tree\n./gen -n 1000 -y 101 -k 50 -x 25 -vi_type random -tree_type balanced\n\n# Large n, random vi, random tree\n./gen -n 100000 -y 1000003 -k 500001 -x 123456 -vi_type random -tree_type random\n\n# Large n, vi all y-1, chain tree\n./gen -n 100000 -y 1000003 -k 2 -x 0 -vi_type const_y1 -tree_type chain\n\n# Large n, vi decreasing, star tree\n./gen -n 100000 -y 999999937 -k 1 -x 999999936 -vi_type decreasing -tree_type star\n\n# Large n, vi all ones, balanced tree\n./gen -n 100000 -y 10000019 -k 9999999 -x 9999999 -vi_type const_one -tree_type balanced\n\n# Small y, y=2\n./gen -n 1000 -y 2 -k 1 -x 0 -vi_type random -tree_type random\n\n# Small y, y=3\n./gen -n 1000 -y 3 -k 2 -x 1 -vi_type random -tree_type random\n\n# k=1\n./gen -n 50000 -y 1000003 -k 1 -x 123456 -vi_type random -tree_type random\n\n# k=y-1\n./gen -n 50000 -y 1000003 -k 1000002 -x 987654 -vi_type random -tree_type random\n\n# x=0\n./gen -n 100000 -y 1000003 -k 2 -x 0 -vi_type random -tree_type random\n\n# x=y-1\n./gen -n 100000 -y 999999937 -k 123456 -x 999999936 -vi_type random -tree_type random\n\n# vi all zeros\n./gen -n 100000 -y 1000003 -k 123456 -x 789012 -vi_type const_zero -tree_type random\n\n# vi all ones\n./gen -n 100000 -y 1000003 -k 555555 -x 666666 -vi_type const_one -tree_type random\n\n# vi all y-1\n./gen -n 100000 -y 1000003 -k 111111 -x 222222 -vi_type const_y1 -tree_type random\n\n# vi increasing\n./gen -n 100000 -y 1000003 -k 333333 -x 444444 -vi_type increasing -tree_type random\n\n# vi decreasing\n./gen -n 100000 -y 1000003 -k 777777 -x 888888 -vi_type decreasing -tree_type random\n\n# Tree types: chain, star, balanced, random\n\n# Chain\n./gen -n 100000 -y 10000019 -k 314159 -x 271828 -vi_type random -tree_type chain\n\n# Star\n./gen -n 100000 -y 10000019 -k 271828 -x 314159 -vi_type random -tree_type star\n\n# Balanced\n./gen -n 100000 -y 10000019 -k 161803 -x 141421 -vi_type random -tree_type balanced\n\n# Random\n./gen -n 100000 -y 10000019 -k 173205 -x 223606 -vi_type random -tree_type random\n\n# Edge case: n=1\n./gen -n 1 -y 2 -k 1 -x 0 -vi_type random -tree_type random\n\n# Edge case: y is largest prime less than 1e9\n./gen -n 100000 -y 999999937 -k 123456789 -x 987654321 -vi_type random -tree_type random\n\n# Edge case: y is small prime\n./gen -n 100000 -y 3 -k 2 -x 1 -vi_type random -tree_type random\n\n# Edge case: k=y-1\n./gen -n 100000 -y 1000003 -k 1000002 -x 0 -vi_type random -tree_type random\n\n# Edge case: x=0\n./gen -n 100000 -y 1000003 -k 2 -x 0 -vi_type random -tree_type random\n\n# Edge case: vi are all same\n./gen -n 100000 -y 1000003 -k 123456 -x 789012 -vi_type const_zero -tree_type random\n./gen -n 100000 -y 1000003 -k 123456 -x 789012 -vi_type const_one -tree_type random\n\n# Edge case: k=1 and vi are all zeros\n./gen -n 100000 -y 1000003 -k 1 -x 0 -vi_type const_zero -tree_type random\n\n# Edge case: k=1 and vi are random\n./gen -n 100000 -y 1000003 -k 1 -x 0 -vi_type random -tree_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:44.147040",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "435/A",
      "title": "A. Queue on Bus Stop",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 100). The next line contains n integers: a1, a2, ..., an (1 ≤ ai ≤ m).",
      "output_spec": "OutputPrint a single integer — the number of buses that is needed to transport all n groups to the dacha countryside.",
      "sample_tests": "ExamplesInputCopy4 32 3 2 1OutputCopy3InputCopy3 41 2 1OutputCopy1",
      "description": "A. Queue on Bus Stop\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 100). The next line contains n integers: a1, a2, ..., an (1 ≤ ai ≤ m).\n\nOutputPrint a single integer — the number of buses that is needed to transport all n groups to the dacha countryside.\n\nInputCopy4 32 3 2 1OutputCopy3InputCopy3 41 2 1OutputCopy1\n\nInputCopy4 32 3 2 1\n\nOutputCopy3\n\nInputCopy3 41 2 1\n\nOutputCopy1",
      "solutions": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces",
          "content": "Hi all)Tomorrow at usual time will be held regular Codeforces round #249 for Div.2 participants. Traditionally we invite Div.1 participants to take part out of the competition.The problems were again prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). As always, we express our gratitude to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.We wish all participants good luck, high rating and enjoyment of solving problems)UPD2: the contest is over, we hope you enjoy it)UPD3: link to editorial is already here)UPD4: Congratulations to winners!:1) JiangZemin_JiangHaha2) Rafbill3) Yukinoshita_Yukino4) kuangbin95) spartacus",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12450",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 795
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces",
          "content": "435A - Queue on Bus StopThe problem could be solved in one cycle by groups. The solution could be implemented in this way: int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n if (people + a[i] <= m)\n people += a[i];\n else\n {\n result++;\n people = a[i];\n }\n}\n\ncout << result << endl;435B - Pasha MaximizesThe problem could solved by greedy algorithm. We will try to pull maximum digits to the beginning. The algorithm could be described in this way:1) Consider every position in the number from the first, assume that the current position is i2) Find the nearest maximum digit from the next k digits of the number, assume that this digit is on position j3) If this maximum digit is greater than current digit on position i, then make series of swaps, push this digit to position i, also decrease k, that is do k = k - (j - i)435C - CardiogramThis problem is technical, you should implement what is written in the statement. First, you need to calc coordinates of all points of the polyline. Also create matrix for the answer. Coordinate y could become negative, so it is useful to double the sizes of the matrix and move the picture up to 1000. In the end you should print the answer without unnecessary empty rows.To paint the cardiogram you should consider every consecutive pair of points of the polyline and set characters in the answer matrix between them. If the polyline goes up then set slash, otherwise set backslash. To understand the solution better please paint the first test case on the paper, mark coordinates of the points and find what values to set in cycles in your program.435D - Special GridValues n and m are not so large, so the solution with complexity O(max(n, m)3) should pass. It means that you should consider all triangles and check all conditions in O(1).To make this check you should precalc arrays of partial sums on all diagonals, rows and columns. After that you could check, that there is no black nodes on the side using one sum-query.Some hints about this problem and the implementation: all correct triangles are isosceles right triangles; either all legs or hypotenuse of the triangle is parallel to the sides of the grid; if you know how to solve the problem for two types of the triangles, you can get the whole solution making 4 rotates of the matrix. 435E - Special GraphTo solve this problem you have to paint different correct colorings on the paper. After it you could observe that there are two types of them: vertical and horizontal.Vertical colorings looks like this:acbcbd...bdadac...acbcbd...bdadac...acbcbd...bdadac.........In other words, each vertical has only two colors, odd verticals have equal colors, even verticals have two others. The order of the colors on every vertical could be arbitrary.Horizontal colorings are the same, they are rotated by 90 degrees. Of course, there are both vertical and horizontal colorings, but it doesn't change the solution.So, you should consider every type of described colorings and check them. That is, you could choose what colors are on the verticals or what colors are on horizontals and check that obtained coloring matches the given matrix.The solution's complexity is O(n × m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 435\\s*A"
          },
          "content_length": 3188
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 1",
          "code": "#11111111b = #255d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 2",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 3",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 4",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 5",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 6",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 7",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 8",
          "code": "b+1 < a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 9",
          "code": "p+b+1 >= a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 10",
          "code": "l=min(p+b+1,a.length())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n    if (people + a[i] <= m)\n        people += a[i];\n    else\n    {\n        result++;\n        people = a[i];\n    }\n}\n\ncout << result << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "Y???????? > X????????",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "|D - I| > k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "|D - J| <= k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Z * 10^D + Y * 10^(I+K) + G2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, m);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, m);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, m);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, m);\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = m;\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % m) + 1;\n    } else if (type == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = m - (i % m);\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % 2 == 0) ? 1 : m;\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, m);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output ai[0..n-1]\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, m);\n    } else if (type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = m;\n    } else if (type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = 1;\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % m) + 1;\n    } else if (type == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = m - (i % m);\n    } else if (type == \"alternate\") {\n        for (int i = 0; i < n; ++i)\n            ai[i] = (i % 2 == 0) ? 1 : m;\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i)\n            ai[i] = rnd.next(1, m);\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output ai[0..n-1]\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type min\n./gen -n 1 -m 1 -type max\n./gen -n 1 -m 100 -type random\n./gen -n 1 -m 100 -type max\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 1 -type min\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type max\n./gen -n 100 -m 100 -type min\n./gen -n 10 -m 5 -type ascending\n./gen -n 10 -m 5 -type descending\n./gen -n 10 -m 5 -type alternate\n./gen -n 50 -m 20 -type random\n./gen -n 50 -m 2 -type random\n./gen -n 50 -m 3 -type random\n./gen -n 50 -m 50 -type random\n./gen -n 100 -m 1 -type min\n./gen -n 100 -m 1 -type random\n./gen -n 100 -m 100 -type descending\n./gen -n 100 -m 100 -type ascending\n./gen -n 100 -m 100 -type alternate\n./gen -n 99 -m 99 -type random\n./gen -n 99 -m 100 -type random\n./gen -n 100 -m 99 -type random\n./gen -n 1 -m 100 -type min\n./gen -n 100 -m 100 -type min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:46.429577",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "435/B",
      "title": "B. Pasha Maximizes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains two integers a and k (1 ≤ a ≤ 1018; 0 ≤ k ≤ 100).",
      "output_spec": "OutputPrint the maximum number that Pasha can get if he makes at most k swaps.",
      "sample_tests": "ExamplesInputCopy1990 1OutputCopy9190InputCopy300 0OutputCopy300InputCopy1034 2OutputCopy3104InputCopy9090000078001234 6OutputCopy9907000008001234",
      "description": "B. Pasha Maximizes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains two integers a and k (1 ≤ a ≤ 1018; 0 ≤ k ≤ 100).\n\nOutputPrint the maximum number that Pasha can get if he makes at most k swaps.\n\nInputCopy1990 1OutputCopy9190InputCopy300 0OutputCopy300InputCopy1034 2OutputCopy3104InputCopy9090000078001234 6OutputCopy9907000008001234\n\nInputCopy1990 1\n\nOutputCopy9190\n\nInputCopy300 0\n\nOutputCopy300\n\nInputCopy1034 2\n\nOutputCopy3104\n\nInputCopy9090000078001234 6\n\nOutputCopy9907000008001234",
      "solutions": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces",
          "content": "Hi all)Tomorrow at usual time will be held regular Codeforces round #249 for Div.2 participants. Traditionally we invite Div.1 participants to take part out of the competition.The problems were again prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). As always, we express our gratitude to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.We wish all participants good luck, high rating and enjoyment of solving problems)UPD2: the contest is over, we hope you enjoy it)UPD3: link to editorial is already here)UPD4: Congratulations to winners!:1) JiangZemin_JiangHaha2) Rafbill3) Yukinoshita_Yukino4) kuangbin95) spartacus",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12450",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 795
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces",
          "content": "435A - Queue on Bus StopThe problem could be solved in one cycle by groups. The solution could be implemented in this way: int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n if (people + a[i] <= m)\n people += a[i];\n else\n {\n result++;\n people = a[i];\n }\n}\n\ncout << result << endl;435B - Pasha MaximizesThe problem could solved by greedy algorithm. We will try to pull maximum digits to the beginning. The algorithm could be described in this way:1) Consider every position in the number from the first, assume that the current position is i2) Find the nearest maximum digit from the next k digits of the number, assume that this digit is on position j3) If this maximum digit is greater than current digit on position i, then make series of swaps, push this digit to position i, also decrease k, that is do k = k - (j - i)435C - CardiogramThis problem is technical, you should implement what is written in the statement. First, you need to calc coordinates of all points of the polyline. Also create matrix for the answer. Coordinate y could become negative, so it is useful to double the sizes of the matrix and move the picture up to 1000. In the end you should print the answer without unnecessary empty rows.To paint the cardiogram you should consider every consecutive pair of points of the polyline and set characters in the answer matrix between them. If the polyline goes up then set slash, otherwise set backslash. To understand the solution better please paint the first test case on the paper, mark coordinates of the points and find what values to set in cycles in your program.435D - Special GridValues n and m are not so large, so the solution with complexity O(max(n, m)3) should pass. It means that you should consider all triangles and check all conditions in O(1).To make this check you should precalc arrays of partial sums on all diagonals, rows and columns. After that you could check, that there is no black nodes on the side using one sum-query.Some hints about this problem and the implementation: all correct triangles are isosceles right triangles; either all legs or hypotenuse of the triangle is parallel to the sides of the grid; if you know how to solve the problem for two types of the triangles, you can get the whole solution making 4 rotates of the matrix. 435E - Special GraphTo solve this problem you have to paint different correct colorings on the paper. After it you could observe that there are two types of them: vertical and horizontal.Vertical colorings looks like this:acbcbd...bdadac...acbcbd...bdadac...acbcbd...bdadac.........In other words, each vertical has only two colors, odd verticals have equal colors, even verticals have two others. The order of the colors on every vertical could be arbitrary.Horizontal colorings are the same, they are rotated by 90 degrees. Of course, there are both vertical and horizontal colorings, but it doesn't change the solution.So, you should consider every type of described colorings and check them. That is, you could choose what colors are on the verticals or what colors are on horizontals and check that obtained coloring matches the given matrix.The solution's complexity is O(n × m).",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 435\\s*B"
          },
          "content_length": 3188
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 1",
          "code": "#11111111b = #255d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 2",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 3",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 4",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 5",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 6",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 7",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 8",
          "code": "b+1 < a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 9",
          "code": "p+b+1 >= a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 10",
          "code": "l=min(p+b+1,a.length())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n    if (people + a[i] <= m)\n        people += a[i];\n    else\n    {\n        result++;\n        people = a[i];\n    }\n}\n\ncout << result << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "Y???????? > X????????",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "|D - I| > k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "|D - J| <= k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Z * 10^D + Y * 10^(I+K) + G2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a_str = inf.readToken(\"[1-9][0-9]*\", \"a\"); // Read 'a' as a string without leading zeros\n    ensuref(a_str.size() <= 18, \"a (%s) is greater than 10^18\", a_str.c_str());\n    if (a_str.size() == 18) {\n        string max_a = \"1000000000000000000\";\n        ensuref(a_str <= max_a, \"a (%s) is greater than 10^18\", a_str.c_str());\n    }\n\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a_str = inf.readToken(\"[1-9][0-9]*\", \"a\"); // Read 'a' as a string without leading zeros\n    ensuref(a_str.size() <= 18, \"a (%s) is greater than 10^18\", a_str.c_str());\n    if (a_str.size() == 18) {\n        string max_a = \"1000000000000000000\";\n        ensuref(a_str <= max_a, \"a (%s) is greater than 10^18\", a_str.c_str());\n    }\n\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string a_str = inf.readToken(\"[1-9][0-9]*\", \"a\"); // Read 'a' as a string without leading zeros\n    ensuref(a_str.size() <= 18, \"a (%s) is greater than 10^18\", a_str.c_str());\n    if (a_str.size() == 18) {\n        string max_a = \"1000000000000000000\";\n        ensuref(a_str <= max_a, \"a (%s) is greater than 10^18\", a_str.c_str());\n    }\n\n    inf.readSpace();\n    int k = inf.readInt(0, 100, \"k\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", rnd.next(0, 100));\n    string type = opt<string>(\"type\", \"random\");\n    vector<char> digits;\n    if(type == \"random\"){\n        digits.push_back('1' + rnd.next(9));\n        for(int i = 1; i < n; ++i){\n            digits.push_back('0' + rnd.next(10));\n        }\n    } else if(type == \"ascending\"){\n        digits.push_back('1');\n        for(int i = 1; i < n; ++i){\n            int digit = ((digits[i - 1] - '0') + 1) % 10;\n            digits.push_back('0' + digit);\n        }\n    } else if(type == \"descending\"){\n        digits.push_back('9');\n        for(int i = 1; i < n; ++i){\n            int digit = ((digits[i - 1] - '0') - 1 + 10) % 10;\n            digits.push_back('0' + digit);\n        }\n    } else if(type == \"repeats\"){\n        char digit = '1' + rnd.next(9);\n        digits.assign(n, digit);\n    } else if(type == \"palindrome\"){\n        digits.resize(n);\n        digits[0] = '1' + rnd.next(9);\n        int half = n / 2;\n        for(int i = 1; i <= half; ++i){\n            digits[i] = '0' + rnd.next(10);\n        }\n        for(int i = 0; i <= n / 2; ++i){\n            digits[n - 1 - i] = digits[i];\n        }\n    } else if(type == \"zeros\"){\n        digits.resize(n);\n        digits[0] = '1' + rnd.next(9);\n        for(int i = 1; i < n; ++i){\n            if(rnd.next(2) == 0)\n                digits[i] = '0';\n            else\n                digits[i] = '1' + rnd.next(9);\n        }\n    } else {\n        digits.push_back('1' + rnd.next(9));\n        for(int i = 1; i < n; ++i){\n            digits.push_back('0' + rnd.next(10));\n        }\n    }\n    string a(digits.begin(), digits.end());\n    printf(\"%s %d\\n\", a.c_str(), k);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\", rnd.next(0, 100));\n    string type = opt<string>(\"type\", \"random\");\n    vector<char> digits;\n    if(type == \"random\"){\n        digits.push_back('1' + rnd.next(9));\n        for(int i = 1; i < n; ++i){\n            digits.push_back('0' + rnd.next(10));\n        }\n    } else if(type == \"ascending\"){\n        digits.push_back('1');\n        for(int i = 1; i < n; ++i){\n            int digit = ((digits[i - 1] - '0') + 1) % 10;\n            digits.push_back('0' + digit);\n        }\n    } else if(type == \"descending\"){\n        digits.push_back('9');\n        for(int i = 1; i < n; ++i){\n            int digit = ((digits[i - 1] - '0') - 1 + 10) % 10;\n            digits.push_back('0' + digit);\n        }\n    } else if(type == \"repeats\"){\n        char digit = '1' + rnd.next(9);\n        digits.assign(n, digit);\n    } else if(type == \"palindrome\"){\n        digits.resize(n);\n        digits[0] = '1' + rnd.next(9);\n        int half = n / 2;\n        for(int i = 1; i <= half; ++i){\n            digits[i] = '0' + rnd.next(10);\n        }\n        for(int i = 0; i <= n / 2; ++i){\n            digits[n - 1 - i] = digits[i];\n        }\n    } else if(type == \"zeros\"){\n        digits.resize(n);\n        digits[0] = '1' + rnd.next(9);\n        for(int i = 1; i < n; ++i){\n            if(rnd.next(2) == 0)\n                digits[i] = '0';\n            else\n                digits[i] = '1' + rnd.next(9);\n        }\n    } else {\n        digits.push_back('1' + rnd.next(9));\n        for(int i = 1; i < n; ++i){\n            digits.push_back('0' + rnd.next(10));\n        }\n    }\n    string a(digits.begin(), digits.end());\n    printf(\"%s %d\\n\", a.c_str(), k);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n./gen -n 1 -k 0 -type repeats\n./gen -n 1 -k 0 -type ascending\n./gen -n 1 -k 0 -type descending\n\n./gen -n 2 -k 0 -type random\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 1 -type ascending\n./gen -n 2 -k 1 -type descending\n\n./gen -n 5 -k 2 -type zeros\n./gen -n 5 -k 2 -type repeats\n./gen -n 5 -k 0 -type palindromic\n\n./gen -n 10 -k 10 -type random\n./gen -n 10 -k 5 -type ascending\n./gen -n 10 -k 7 -type descending\n./gen -n 10 -k 0 -type zeros\n\n./gen -n 15 -k 100 -type ascending\n./gen -n 15 -k 100 -type descending\n./gen -n 15 -k 50 -type random\n./gen -n 15 -k 0 -type random\n\n./gen -n 18 -k 100 -type random\n./gen -n 18 -k 100 -type ascending\n./gen -n 18 -k 100 -type descending\n\n./gen -n 18 -k 0 -type zeros\n./gen -n 18 -k 0 -type repeats\n./gen -n 18 -k 0 -type palindromic\n\n./gen -n 17 -k 1 -type random\n./gen -n 17 -k 100 -type random\n./gen -n 17 -k 50 -type zeros\n\n./gen -n 18 -k 100 -type zeros\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:48.699975",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "435/C",
      "title": "C. Cardiogram",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (2 ≤ n ≤ 1000). The next line contains the sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 1000). It is guaranteed that the sum of all ai doesn't exceed 1000.",
      "output_spec": "OutputPrint max |yi - yj| lines (where yk is the y coordinate of the k-th point of the polyline), in each line print  characters. Each character must equal either « / » (slash), « \\ » (backslash), « » (space). The printed image must be the image of the given polyline. Please study the test samples for better understanding of how to print a cardiogram.Note that in this problem the checker checks your answer taking spaces into consideration. Do not print any extra characters. Remember that the wrong answer to the first pretest doesn't give you a penalty.",
      "sample_tests": "ExamplesInputCopy53 1 2 5 1OutputCopy      / \\        / \\ /   \\      /       \\    /         \\            \\ / InputCopy31 5 1OutputCopy / \\       \\       \\       \\       \\ /",
      "description": "C. Cardiogram\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (2 ≤ n ≤ 1000). The next line contains the sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 1000). It is guaranteed that the sum of all ai doesn't exceed 1000.\n\nOutputPrint max |yi - yj| lines (where yk is the y coordinate of the k-th point of the polyline), in each line print  characters. Each character must equal either « / » (slash), « \\ » (backslash), « » (space). The printed image must be the image of the given polyline. Please study the test samples for better understanding of how to print a cardiogram.Note that in this problem the checker checks your answer taking spaces into consideration. Do not print any extra characters. Remember that the wrong answer to the first pretest doesn't give you a penalty.\n\nInputCopy53 1 2 5 1OutputCopy      / \\        / \\ /   \\      /       \\    /         \\            \\ / InputCopy31 5 1OutputCopy / \\       \\       \\       \\       \\ /\n\nInputCopy53 1 2 5 1\n\nOutputCopy      / \\        / \\ /   \\      /       \\    /         \\            \\ /\n\nInputCopy31 5 1\n\nOutputCopy / \\       \\       \\       \\       \\ /\n\nNoteDue to the technical reasons the answers for the samples cannot be copied from the statement. We've attached two text documents with the answers below.http://assets.codeforces.com/rounds/435/1.txthttp://assets.codeforces.com/rounds/435/2.txt",
      "solutions": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces",
          "content": "Hi all)Tomorrow at usual time will be held regular Codeforces round #249 for Div.2 participants. Traditionally we invite Div.1 participants to take part out of the competition.The problems were again prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). As always, we express our gratitude to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.We wish all participants good luck, high rating and enjoyment of solving problems)UPD2: the contest is over, we hope you enjoy it)UPD3: link to editorial is already here)UPD4: Congratulations to winners!:1) JiangZemin_JiangHaha2) Rafbill3) Yukinoshita_Yukino4) kuangbin95) spartacus",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12450",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 795
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces",
          "content": "435A - Queue on Bus StopThe problem could be solved in one cycle by groups. The solution could be implemented in this way: int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n if (people + a[i] <= m)\n people += a[i];\n else\n {\n result++;\n people = a[i];\n }\n}\n\ncout << result << endl;435B - Pasha MaximizesThe problem could solved by greedy algorithm. We will try to pull maximum digits to the beginning. The algorithm could be described in this way:1) Consider every position in the number from the first, assume that the current position is i2) Find the nearest maximum digit from the next k digits of the number, assume that this digit is on position j3) If this maximum digit is greater than current digit on position i, then make series of swaps, push this digit to position i, also decrease k, that is do k = k - (j - i)435C - CardiogramThis problem is technical, you should implement what is written in the statement. First, you need to calc coordinates of all points of the polyline. Also create matrix for the answer. Coordinate y could become negative, so it is useful to double the sizes of the matrix and move the picture up to 1000. In the end you should print the answer without unnecessary empty rows.To paint the cardiogram you should consider every consecutive pair of points of the polyline and set characters in the answer matrix between them. If the polyline goes up then set slash, otherwise set backslash. To understand the solution better please paint the first test case on the paper, mark coordinates of the points and find what values to set in cycles in your program.435D - Special GridValues n and m are not so large, so the solution with complexity O(max(n, m)3) should pass. It means that you should consider all triangles and check all conditions in O(1).To make this check you should precalc arrays of partial sums on all diagonals, rows and columns. After that you could check, that there is no black nodes on the side using one sum-query.Some hints about this problem and the implementation: all correct triangles are isosceles right triangles; either all legs or hypotenuse of the triangle is parallel to the sides of the grid; if you know how to solve the problem for two types of the triangles, you can get the whole solution making 4 rotates of the matrix. 435E - Special GraphTo solve this problem you have to paint different correct colorings on the paper. After it you could observe that there are two types of them: vertical and horizontal.Vertical colorings looks like this:acbcbd...bdadac...acbcbd...bdadac...acbcbd...bdadac.........In other words, each vertical has only two colors, odd verticals have equal colors, even verticals have two others. The order of the colors on every vertical could be arbitrary.Horizontal colorings are the same, they are rotated by 90 degrees. Of course, there are both vertical and horizontal colorings, but it doesn't change the solution.So, you should consider every type of described colorings and check them. That is, you could choose what colors are on the verticals or what colors are on horizontals and check that obtained coloring matches the given matrix.The solution's complexity is O(n × m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 435\\s*C"
          },
          "content_length": 3188
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 1",
          "code": "#11111111b = #255d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 2",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 3",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 4",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 5",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 6",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 7",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 8",
          "code": "b+1 < a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 9",
          "code": "p+b+1 >= a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 10",
          "code": "l=min(p+b+1,a.length())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n    if (people + a[i] <= m)\n        people += a[i];\n    else\n    {\n        result++;\n        people = a[i];\n    }\n}\n\ncout << result << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "Y???????? > X????????",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "|D - I| > k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "|D - J| <= k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Z * 10^D + Y * 10^(I+K) + G2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    int sum_ai = 0;\n    for (int ai : a) sum_ai += ai;\n    ensuref(sum_ai <= 1000, \"Sum of ai (%d) exceeds 1000\", sum_ai);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    int sum_ai = 0;\n    for (int ai : a) sum_ai += ai;\n    ensuref(sum_ai <= 1000, \"Sum of ai (%d) exceeds 1000\", sum_ai);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000, \"a_i\");\n    inf.readEoln();\n\n    int sum_ai = 0;\n    for (int ai : a) sum_ai += ai;\n    ensuref(sum_ai <= 1000, \"Sum of ai (%d) exceeds 1000\", sum_ai);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int sum = opt<int>(\"sum\", 1000);\n\n    sum = max(sum, n); // sum cannot be less than n\n    sum = min(sum, 1000); // sum cannot exceed 1000\n\n    // If n > sum, it's invalid\n    if (n > sum) {\n        fprintf(stderr, \"Invalid parameters: n (%d) > sum (%d)\\n\", n, sum);\n        return 1;\n    }\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Distribute sum into n integers ≥1\n        a.assign(n, 1);\n        int remaining = sum - n;\n        while (remaining > 0) {\n            int idx = rnd.next(0, n - 1);\n            if (a[idx] < 1000) {\n                a[idx]++;\n                remaining--;\n            }\n        }\n    } else if (type == \"constant\") {\n        // All ai are equal\n        int value = sum / n; // integer division\n        value = min(value, 1000);\n        a.assign(n, value);\n        int total = value * n;\n        int remaining = sum - total;\n        for (int i = 0; i < n && remaining > 0; i++) {\n            if (a[i] < 1000) {\n                a[i]++;\n                remaining--;\n            }\n        }\n    } else if (type == \"increasing\") {\n        // Generate ai in increasing order\n        a.assign(n, 1);\n        int remaining = sum - n;\n        for (int i = n - 1; i >= 0 && remaining > 0; i--) {\n            int add = min(remaining, 1000 - a[i]);\n            a[i] += add;\n            remaining -= add;\n        }\n        sort(a.begin(), a.end());\n    } else if (type == \"decreasing\") {\n        // Generate ai in decreasing order\n        a.assign(n, 1);\n        int remaining = sum - n;\n        for (int i = 0; i < n && remaining > 0; i++) {\n            int add = min(remaining, 1000 - a[i]);\n            a[i] += add;\n            remaining -= add;\n        }\n        sort(a.begin(), a.end(), greater<int>());\n    } else if (type == \"alternating\") {\n        // Alternate between large and small values\n        a.assign(n, 1);\n        int remaining = sum - n;\n        for (int i = 0; i < n && remaining > 0; i += 2) {\n            int add = min(remaining, 1000 - a[i]);\n            a[i] += add;\n            remaining -= add;\n        }\n    } else if (type == \"max\") {\n        // All ai as large as possible (up to 1000)\n        int value = min(1000, sum / n);\n        a.assign(n, value);\n        int total = value * n;\n        int remaining = sum - total;\n        for (int i = 0; i < n && remaining > 0; i++) {\n            if (a[i] < 1000) {\n                a[i]++;\n                remaining--;\n            }\n        }\n    } else if (type == \"min\") {\n        // All ai are 1\n        a.assign(n, 1);\n        if (sum > n) {\n            fprintf(stderr, \"Cannot have min type with sum > n\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Validate that all ai are within [1,1000]\n    for (int i = 0; i < n; i++) {\n        if (a[i] < 1 || a[i] > 1000) {\n            fprintf(stderr, \"Invalid ai[%d] = %d\\n\", i, a[i]);\n            return 1;\n        }\n    }\n\n    // Validate sum\n    int actual_sum = accumulate(a.begin(), a.end(), 0);\n    if (actual_sum > 1000 || actual_sum != sum) {\n        fprintf(stderr, \"Invalid sum: actual = %d, expected = %d\\n\", actual_sum, sum);\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1..an\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int sum = opt<int>(\"sum\", 1000);\n\n    sum = max(sum, n); // sum cannot be less than n\n    sum = min(sum, 1000); // sum cannot exceed 1000\n\n    // If n > sum, it's invalid\n    if (n > sum) {\n        fprintf(stderr, \"Invalid parameters: n (%d) > sum (%d)\\n\", n, sum);\n        return 1;\n    }\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Distribute sum into n integers ≥1\n        a.assign(n, 1);\n        int remaining = sum - n;\n        while (remaining > 0) {\n            int idx = rnd.next(0, n - 1);\n            if (a[idx] < 1000) {\n                a[idx]++;\n                remaining--;\n            }\n        }\n    } else if (type == \"constant\") {\n        // All ai are equal\n        int value = sum / n; // integer division\n        value = min(value, 1000);\n        a.assign(n, value);\n        int total = value * n;\n        int remaining = sum - total;\n        for (int i = 0; i < n && remaining > 0; i++) {\n            if (a[i] < 1000) {\n                a[i]++;\n                remaining--;\n            }\n        }\n    } else if (type == \"increasing\") {\n        // Generate ai in increasing order\n        a.assign(n, 1);\n        int remaining = sum - n;\n        for (int i = n - 1; i >= 0 && remaining > 0; i--) {\n            int add = min(remaining, 1000 - a[i]);\n            a[i] += add;\n            remaining -= add;\n        }\n        sort(a.begin(), a.end());\n    } else if (type == \"decreasing\") {\n        // Generate ai in decreasing order\n        a.assign(n, 1);\n        int remaining = sum - n;\n        for (int i = 0; i < n && remaining > 0; i++) {\n            int add = min(remaining, 1000 - a[i]);\n            a[i] += add;\n            remaining -= add;\n        }\n        sort(a.begin(), a.end(), greater<int>());\n    } else if (type == \"alternating\") {\n        // Alternate between large and small values\n        a.assign(n, 1);\n        int remaining = sum - n;\n        for (int i = 0; i < n && remaining > 0; i += 2) {\n            int add = min(remaining, 1000 - a[i]);\n            a[i] += add;\n            remaining -= add;\n        }\n    } else if (type == \"max\") {\n        // All ai as large as possible (up to 1000)\n        int value = min(1000, sum / n);\n        a.assign(n, value);\n        int total = value * n;\n        int remaining = sum - total;\n        for (int i = 0; i < n && remaining > 0; i++) {\n            if (a[i] < 1000) {\n                a[i]++;\n                remaining--;\n            }\n        }\n    } else if (type == \"min\") {\n        // All ai are 1\n        a.assign(n, 1);\n        if (sum > n) {\n            fprintf(stderr, \"Cannot have min type with sum > n\\n\");\n            return 1;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Validate that all ai are within [1,1000]\n    for (int i = 0; i < n; i++) {\n        if (a[i] < 1 || a[i] > 1000) {\n            fprintf(stderr, \"Invalid ai[%d] = %d\\n\", i, a[i]);\n            return 1;\n        }\n    }\n\n    // Validate sum\n    int actual_sum = accumulate(a.begin(), a.end(), 0);\n    if (actual_sum > 1000 || actual_sum != sum) {\n        fprintf(stderr, \"Invalid sum: actual = %d, expected = %d\\n\", actual_sum, sum);\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output a1..an\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -sum 2 -type min\n./gen -n 2 -sum 1000 -type max\n./gen -n 2 -sum 1000 -type constant\n./gen -n 2 -sum 3 -type increasing\n./gen -n 2 -sum 3 -type decreasing\n./gen -n 2 -sum 3 -type alternating\n./gen -n 10 -sum 1000 -type increasing\n./gen -n 10 -sum 1000 -type decreasing\n./gen -n 10 -sum 1000 -type random\n./gen -n 10 -sum 100 -type alternating\n./gen -n 100 -sum 1000 -type increasing\n./gen -n 100 -sum 1000 -type decreasing\n./gen -n 100 -sum 1000 -type random\n./gen -n 100 -sum 500 -type random\n./gen -n 500 -sum 1000 -type random\n./gen -n 500 -sum 1000 -type increasing\n./gen -n 500 -sum 1000 -type decreasing\n./gen -n 500 -sum 1000 -type alternating\n./gen -n 1000 -sum 1000 -type min\n./gen -n 1000 -sum 1000 -type random\n./gen -n 999 -sum 1000 -type random\n./gen -n 3 -sum 3 -type min\n./gen -n 3 -sum 1000 -type max\n./gen -n 50 -sum 1000 -type constant\n./gen -n 50 -sum 1000 -type random\n./gen -n 50 -sum 1000 -type increasing\n./gen -n 50 -sum 1000 -type decreasing\n./gen -n 5 -sum 15 -type constant\n./gen -n 5 -sum 15 -type increasing\n./gen -n 5 -sum 15 -type decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:50.801102",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "435/D",
      "title": "D. Special Grid",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (2 ≤ n, m ≤ 400). Each of the following n lines contain m characters (zeros and ones) — the description of the grid. If the j-th character in the i-th line equals zero, then the node on the i-th horizontal line and on the j-th vertical line is painted white. Otherwise, the node is painted black.The horizontal lines are numbered starting from one from top to bottom, the vertical lines are numbered starting from one from left to right.",
      "output_spec": "OutputPrint a single integer — the number of required triangles.",
      "sample_tests": "ExamplesInputCopy3 5100001001000001OutputCopy20InputCopy2 20000OutputCopy4InputCopy2 21111OutputCopy0",
      "description": "D. Special Grid\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (2 ≤ n, m ≤ 400). Each of the following n lines contain m characters (zeros and ones) — the description of the grid. If the j-th character in the i-th line equals zero, then the node on the i-th horizontal line and on the j-th vertical line is painted white. Otherwise, the node is painted black.The horizontal lines are numbered starting from one from top to bottom, the vertical lines are numbered starting from one from left to right.\n\nOutputPrint a single integer — the number of required triangles.\n\nInputCopy3 5100001001000001OutputCopy20InputCopy2 20000OutputCopy4InputCopy2 21111OutputCopy0\n\nInputCopy3 5100001001000001\n\nOutputCopy20\n\nInputCopy2 20000\n\nOutputCopy4\n\nInputCopy2 21111\n\nOutputCopy0\n\nNoteThe figure below shows red and blue triangles. They are the examples of the required triangles in the first sample. One of the invalid triangles is painted green. It is invalid because not all sides go along the grid lines.",
      "solutions": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces",
          "content": "Hi all)Tomorrow at usual time will be held regular Codeforces round #249 for Div.2 participants. Traditionally we invite Div.1 participants to take part out of the competition.The problems were again prepared by authors Pavel Kholkin (HolkinPV) and Gerald Agapov (Gerald). As always, we express our gratitude to Michael Mirzayanov (MikeMirzayanov) for perfect Codeforces and Polygon systems and Mary Belova (Delinur) for translating the problems.UPD: Score distribution will be standard — 500-1000-1500-2000-2500.We wish all participants good luck, high rating and enjoyment of solving problems)UPD2: the contest is over, we hope you enjoy it)UPD3: link to editorial is already here)UPD4: Congratulations to winners!:1) JiangZemin_JiangHaha2) Rafbill3) Yukinoshita_Yukino4) kuangbin95) spartacus",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12450",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 795
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces",
          "content": "435A - Queue on Bus StopThe problem could be solved in one cycle by groups. The solution could be implemented in this way: int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n if (people + a[i] <= m)\n people += a[i];\n else\n {\n result++;\n people = a[i];\n }\n}\n\ncout << result << endl;435B - Pasha MaximizesThe problem could solved by greedy algorithm. We will try to pull maximum digits to the beginning. The algorithm could be described in this way:1) Consider every position in the number from the first, assume that the current position is i2) Find the nearest maximum digit from the next k digits of the number, assume that this digit is on position j3) If this maximum digit is greater than current digit on position i, then make series of swaps, push this digit to position i, also decrease k, that is do k = k - (j - i)435C - CardiogramThis problem is technical, you should implement what is written in the statement. First, you need to calc coordinates of all points of the polyline. Also create matrix for the answer. Coordinate y could become negative, so it is useful to double the sizes of the matrix and move the picture up to 1000. In the end you should print the answer without unnecessary empty rows.To paint the cardiogram you should consider every consecutive pair of points of the polyline and set characters in the answer matrix between them. If the polyline goes up then set slash, otherwise set backslash. To understand the solution better please paint the first test case on the paper, mark coordinates of the points and find what values to set in cycles in your program.435D - Special GridValues n and m are not so large, so the solution with complexity O(max(n, m)3) should pass. It means that you should consider all triangles and check all conditions in O(1).To make this check you should precalc arrays of partial sums on all diagonals, rows and columns. After that you could check, that there is no black nodes on the side using one sum-query.Some hints about this problem and the implementation: all correct triangles are isosceles right triangles; either all legs or hypotenuse of the triangle is parallel to the sides of the grid; if you know how to solve the problem for two types of the triangles, you can get the whole solution making 4 rotates of the matrix. 435E - Special GraphTo solve this problem you have to paint different correct colorings on the paper. After it you could observe that there are two types of them: vertical and horizontal.Vertical colorings looks like this:acbcbd...bdadac...acbcbd...bdadac...acbcbd...bdadac.........In other words, each vertical has only two colors, odd verticals have equal colors, even verticals have two others. The order of the colors on every vertical could be arbitrary.Horizontal colorings are the same, they are rotated by 90 degrees. Of course, there are both vertical and horizontal colorings, but it doesn't change the solution.So, you should consider every type of described colorings and check them. That is, you could choose what colors are on the verticals or what colors are on horizontals and check that obtained coloring matches the given matrix.The solution's complexity is O(n × m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 435\\s*D"
          },
          "content_length": 3188
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 1",
          "code": "#11111111b = #255d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 2",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 3",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 4",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 5",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 6",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 7",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 8",
          "code": "b+1 < a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 9",
          "code": "p+b+1 >= a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 10",
          "code": "l=min(p+b+1,a.length())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n    if (people + a[i] <= m)\n        people += a[i];\n    else\n    {\n        result++;\n        people = a[i];\n    }\n}\n\ncout << result << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "Y???????? > X????????",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "|D - I| > k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "|D - J| <= k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "Z * 10^D + Y * 10^(I+K) + G2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 400, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 400, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 400, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 400, \"m\");\n    inf.readEoln();\n\n    string pattern = \"[01]{\" + to_string(m) + \"}\";\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, \"line \" + to_string(i+1));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    double density = opt<double>(\"density\", 0.5); // Probability of a node being black in random grids\n\n    vector<string> grid(n, string(m, '0'));\n\n    if (type == \"empty\") {\n        // All nodes are white ('0')\n        // Grid is already initialized with '0's\n    } else if (type == \"full\") {\n        // All nodes are black ('1')\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '1');\n        }\n    } else if (type == \"random\") {\n        // Random grid with black nodes with given density\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0.0, 1.0) < density) {\n                    grid[i][j] = '1';\n                }\n            }\n        }\n    } else if (type == \"border\") {\n        // Black nodes along the border\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = '1';\n            grid[i][m - 1] = '1';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '1';\n            grid[n - 1][j] = '1';\n        }\n    } else if (type == \"center\") {\n        // Black node at the center\n        int cx = n / 2;\n        int cy = m / 2;\n        grid[cx][cy] = '1';\n    } else if (type == \"cross\") {\n        // Black nodes form a cross pattern\n        for (int i = 0; i < n; ++i) {\n            grid[i][m / 2] = '1';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[n / 2][j] = '1';\n        }\n    } else if (type == \"diagonal\") {\n        // Black nodes along the main diagonal\n        for (int i = 0; i < min(n, m); ++i) {\n            grid[i][i] = '1';\n        }\n    } else if (type == \"antidiagonal\") {\n        // Black nodes along the anti-diagonal\n        for (int i = 0; i < min(n, m); ++i) {\n            grid[i][m - i - 1] = '1';\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = '1';\n                }\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    double density = opt<double>(\"density\", 0.5); // Probability of a node being black in random grids\n\n    vector<string> grid(n, string(m, '0'));\n\n    if (type == \"empty\") {\n        // All nodes are white ('0')\n        // Grid is already initialized with '0's\n    } else if (type == \"full\") {\n        // All nodes are black ('1')\n        for (int i = 0; i < n; ++i) {\n            fill(grid[i].begin(), grid[i].end(), '1');\n        }\n    } else if (type == \"random\") {\n        // Random grid with black nodes with given density\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0.0, 1.0) < density) {\n                    grid[i][j] = '1';\n                }\n            }\n        }\n    } else if (type == \"border\") {\n        // Black nodes along the border\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = '1';\n            grid[i][m - 1] = '1';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '1';\n            grid[n - 1][j] = '1';\n        }\n    } else if (type == \"center\") {\n        // Black node at the center\n        int cx = n / 2;\n        int cy = m / 2;\n        grid[cx][cy] = '1';\n    } else if (type == \"cross\") {\n        // Black nodes form a cross pattern\n        for (int i = 0; i < n; ++i) {\n            grid[i][m / 2] = '1';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[n / 2][j] = '1';\n        }\n    } else if (type == \"diagonal\") {\n        // Black nodes along the main diagonal\n        for (int i = 0; i < min(n, m); ++i) {\n            grid[i][i] = '1';\n        }\n    } else if (type == \"antidiagonal\") {\n        // Black nodes along the anti-diagonal\n        for (int i = 0; i < min(n, m); ++i) {\n            grid[i][m - i - 1] = '1';\n        }\n    } else if (type == \"checkerboard\") {\n        // Checkerboard pattern\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0) {\n                    grid[i][j] = '1';\n                }\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grids with different types\n./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type full\n./gen -n 2 -m 2 -type random -density 0.5\n./gen -n 2 -m 2 -type border\n./gen -n 2 -m 2 -type diagonal\n./gen -n 2 -m 2 -type checkerboard\n\n# Moderate grids with varying densities\n./gen -n 10 -m 10 -type random -density 0.1\n./gen -n 10 -m 10 -type random -density 0.9\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type cross\n\n# Large grids to test performance limits\n./gen -n 400 -m 400 -type random -density 0.5\n./gen -n 400 -m 400 -type empty\n./gen -n 400 -m 400 -type full\n./gen -n 400 -m 400 -type border\n./gen -n 400 -m 400 -type diagonal\n./gen -n 400 -m 400 -type antidiagonal\n./gen -n 400 -m 400 -type checkerboard\n\n# Grids with maximum size in one dimension\n./gen -n 400 -m 2 -type random -density 0.5\n./gen -n 2 -m 400 -type random -density 0.5\n\n# Grids with specific patterns\n./gen -n 250 -m 250 -type cross\n./gen -n 250 -m 250 -type center\n./gen -n 250 -m 250 -type random -density 0.0   # All white nodes\n./gen -n 250 -m 250 -type random -density 1.0   # All black nodes\n./gen -n 250 -m 250 -type random -density 0.3\n./gen -n 250 -m 250 -type random -density 0.7\n\n# Grids with varied dimensions\n./gen -n 50 -m 300 -type random -density 0.5\n./gen -n 300 -m 50 -type random -density 0.5\n\n# Small grids with edge cases\n./gen -n 2 -m 400 -type empty\n./gen -n 400 -m 2 -type empty\n./gen -n 2 -m 2 -type center\n./gen -n 3 -m 3 -type antidiagonal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:52.695751",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "435/E",
      "title": "E. Специальный граф",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (2 ≤ n, m ≤ 1000). В каждой из следующих n строк записано по m символов — заданный граф. Каждый символ — это один из символов: «0», «1», «2», «3», «4». Символ «0» обозначает, что цвет соответствующей вершины графа не задан, остальные символы обозначают, что вершина покрашена в заданный цвет.Считайте, что цвета пронумерованы от 1 до 4.",
      "output_spec": "Выходные данныеЕсли описанного способа не существует, в единственной строке выведите 0. Иначе выведите покрашенный граф размера n × m. Выводите граф в таком же формате, в котором он задан во входных данных.Если существует несколько правильных ответов, разрешается вывести любой.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 5101010002001000Выходные данныеСкопировать131314242431313Входные данныеСкопировать2 20000Выходные данныеСкопировать1234Входные данныеСкопировать2 21100Выходные данныеСкопировать0",
      "description": "E. Специальный граф\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (2 ≤ n, m ≤ 1000). В каждой из следующих n строк записано по m символов — заданный граф. Каждый символ — это один из символов: «0», «1», «2», «3», «4». Символ «0» обозначает, что цвет соответствующей вершины графа не задан, остальные символы обозначают, что вершина покрашена в заданный цвет.Считайте, что цвета пронумерованы от 1 до 4.\n\nВходные данные\n\nВыходные данныеЕсли описанного способа не существует, в единственной строке выведите 0. Иначе выведите покрашенный граф размера n × m. Выводите граф в таком же формате, в котором он задан во входных данных.Если существует несколько правильных ответов, разрешается вывести любой.\n\nВыходные данные\n\nВходные данныеСкопировать3 5101010002001000Выходные данныеСкопировать131314242431313Входные данныеСкопировать2 20000Выходные данныеСкопировать1234Входные данныеСкопировать2 21100Выходные данныеСкопировать0\n\nВходные данныеСкопировать3 5101010002001000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать131314242431313\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 20000\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1234\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 21100\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере ответ совпадает с картинкой из условия (1 — зеленый цвет, 2 — голубой, 3 — синий, 4 — розовый).На второй тестовый пример существует ровно 4! ответов, любой из них считается правильным.В третьем тестовом примере в изначальной раскраске две вершины одного цвета соединены ребром. Значит нельзя дополнить такую раскраску до корректной.",
      "solutions": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces",
          "content": "Всем привет)Уже завтра в привычное время состоится очередной раунд Codeforces #249 для участников Div. 2. Участников Div. 1 мы традиционно приглашаем поучаствовать в этом соревновании вне конкурса.Задачи для вас вновь готовили авторы Павел Холкин (HolkinPV) и Геральд Агапов (Gerald). Как всегда, мы выражаем свою благодарность Михаилу Мирзаянову (MikeMirzayanov) за прекрасные системы Codeforces и Polygon, а также Марии Беловой (Delinur) за перевод условий задач.UPD: Распределение баллов по задачам будет стандартным — 500-1000-1500-2000-2500.Желаем всем участникам удачи, высокого рейтинга и удовольствия от решения задач)UPD2: соревнование завершилось, надеемся оно вам понравилось)UPD3: ссылка на разбор уже здесь)UPD4: Поздравляем победителей!:1) JiangZemin_JiangHaha2) Rafbill3) Yukinoshita_Yukino4) kuangbin95) spartacus",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12450",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 829
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces",
          "content": "435A - Очередь на остановкеЭта задача решается за один проход по всем группам. Решение можно представить следующим кодом: int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n if (people + a[i] <= m)\n people += a[i];\n else\n {\n result++;\n people = a[i];\n }\n}\n\ncout << result << endl;435B - Паша максимизируетЭта задача решается жадно. Будем стараться максимальные цифры ставить как можно раньше. Алгоритм можно описать так:1) Рассмотрим каждую позицию по очереди, начиная с 1, пусть текущая позиция i2) Среди следующих k цифр числа найдем ближайшую максимальную, пусть она находится на позиции j3) Если эта цифра больше текущей цифры на позиции i, то сделаем серию обменов, поставим ее на позицию i, одновременно умешьшим величину k, то есть выполним k = k - (j - i)435C - КардиограммаЭта задача носила технический характер, нужно было реализовать описанное в условии. Для начала нужно было посчитать координаты всех точек ломанной. Также заведем матрицу для хранения ответа. Поскольку координата y могла становиться отрицательной, удобно было удвоить размеры матрицы и изначально сдвинуть картинку вверх на 1000. В конце нужно будет вывести ее без лишних пустых строк.Чтобы нарисовать саму кардиограмму, можно было рассмотреть каждую пару последовательных точек ломанной и отдельно расставить символы в матрице ответа. Если ломаная возрастает, нужно нарисовать прямой слеш, иначе обратный. Чтобы лучше разобраться как это сделать, можно аккуратно нарисовать первый тестовый пример на листочке, отметить координаты и понять как изменяются значения по координатам (какие границы получаются у циклов в программе).435D - Специальная сеткаТак как ограничения на n и m были не очень большие, должно было проходить решение за O(max(n, m)3), то есть перебор всех треугольников. А именно, нужно было перебрать все треугольники и проверить для каждого треугольника за O(1), что он удовлетворяет всем описанным условиям.Чтобы быстро выполнять проверку, нужно было для всех диагоналей, строк и столбцов сохранить массив частичных сумм. И далее, проверять запросом на сумму, лежит ли в данном отрезке на соответствующей линии хотя бы одна черная точка.Полезные соображения, помогающие значительно сократить реализацию описанного выше: все треугольники, которые нужно посчитать — равнобедренные прямоугольные треугольники; либо катеты треугольника параллельны сторонам сетки, либо гипотенуза параллельна одной из сторон сетки; если научиться решать задачу, считая, что нужно посчитать количество треугольников только двух видов, то решение для всех треугольников можно получить, посчитав ответы для 4-х поворотов матрицы. 435E - Специальный графДля того, чтобы решить последнюю задачу, нужно было порисовать различные раскраски на листочке бумаги. Далее путем исследований установить, что бывает два вида корректных раскрасок: вертикальные и горизонтальные.Вертикальные раскраски выглядят следующим образом:acbcbd...bdadac...acbcbd...bdadac...acbcbd...bdadac.........Другими словами, каждая вертикаль содержит только два цвета, вертикали одной четности содержат одинаковые цвета. При этом очередность цветов на каждой вертикали может быть совершенно произвольная.Горизонтальные раскраски выглядят аналогично, только повернуты на 90 градусов. Конечно, бывают раскраски, которые одновременно и горизонтальные и вертикальные, но для решения задачи, это не имеет никакого значения.Давайте научимся проверять, существует или нет, корректная вертикальная раскраска, удовлетворяющая шаблону заданному во входных данных. Это достаточно просто. Достаточно просто перебрать, какие цвета и на каких вертикалях находятся. А затем проверить, что такую раскраску действительно можно составить.Аналогично нужно проверить для горизонтальных раскрасок.Сложность решения O(n × m).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12479",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 435\\s*E"
          },
          "content_length": 3757
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 1",
          "code": "#11111111b = #255d",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 2",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 3",
          "code": "4 4\n0000\n0101\n0011\n0111",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 4",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 5",
          "code": "three 00, one 00, one 0 , one 000, one 0        \n      0        0      00       0       00        \n                                       0        \n\nand one 0000    \n        0 0    \n        00    \n        0    \n     \ntotal 8 triangles.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 6",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 7",
          "code": "if(b+1  > a.length())\n    l=a.length();\nelse l=p+b+1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 8",
          "code": "b+1 < a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 9",
          "code": "p+b+1 >= a.length()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #249 (Div. 2) - Codeforces - Code 10",
          "code": "l=min(p+b+1,a.length())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12450",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 1",
          "code": "int result = 1;\nint people = 0;\n\nfor(int i = 0; i < n; i++)\n{\n    if (people + a[i] <= m)\n        people += a[i];\n    else\n    {\n        result++;\n        people = a[i];\n    }\n}\n\ncout << result << endl;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 2",
          "code": "Y???????? > X????????",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 3",
          "code": "|D - I| > k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 4",
          "code": "|D - J| <= k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 5",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 6",
          "code": "Z * 10^D + Y * 10^(I+K) + G2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 7",
          "code": "X * 10^D + G1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 8",
          "code": "int a[1001], i, l, r;\n\na[0] = 0; // обязательно!\n\nfor (i = 1; i < 1001; ++i) a[i] = i; \n\nfor (i = 1; i < 1001; ++i) a[i] += a[i - 1]; // частичные суммы\n\ncin >> l >> r;\n\ncout << a[r] - a[l - 1]; // ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #249 (Div. 2) - Codeforces - Code 9",
          "code": "int a[1001], i, l, r;\n\na[0] = 0; // обязательно!\n\nfor (i = 1; i < 1001; ++i) a[i] = i; \n\nfor (i = 1; i < 1001; ++i) a[i] += a[i - 1]; // частичные суммы\n\ncin >> l >> r;\n\ncout << a[r] - a[l - 1]; // ans",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12479",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have length %d, but has length %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c >= '0' && c <= '4', \"Character at row %d, column %d is invalid\", i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have length %d, but has length %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c >= '0' && c <= '4', \"Character at row %d, column %d is invalid\", i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d should have length %d, but has length %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c >= '0' && c <= '4', \"Character at row %d, column %d is invalid\", i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nvector<string> inputGrid;\nvector<string> participantGrid;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input grid from inf\n    n = inf.readInt();\n    m = inf.readInt();\n    inputGrid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        inputGrid[i] = inf.readToken();\n        if (int(inputGrid[i].size()) != m)\n            quitf(_fail, \"Invalid input line length at line %d\", i + 1);\n    }\n\n    // Read judge's output from ans\n    bool judgeNoSolution = false;\n    string firstAnsLine = ans.readToken();\n    if (firstAnsLine == \"0\") {\n        judgeNoSolution = true;\n    } else {\n        // Read rest of the judge's output to prevent read errors\n        for (int k = 1; k < n; ++k) {\n            string dummyLine = ans.readToken();\n            if (int(dummyLine.size()) != m)\n                quitf(_fail, \"Invalid judge output line length at line %d\", k + 1);\n        }\n    }\n\n    // Read participant's output from ouf\n    string firstOutLine = ouf.readToken();\n    if (firstOutLine == \"0\") {\n        // Participant claims no solution\n        if (judgeNoSolution) {\n            quitf(_ok, \"Participant correctly found no solution\");\n        } else {\n            quitf(_wa, \"Participant claimed no solution, but solution exists\");\n        }\n    } else {\n        // Participant provided a coloring\n        participantGrid.resize(n);\n        participantGrid[0] = firstOutLine;\n        if (int(participantGrid[0].size()) != m)\n            quitf(_wa, \"Invalid output line length at line 1\");\n        for (int i = 1; i < n; ++i) {\n            participantGrid[i] = ouf.readToken();\n            if (int(participantGrid[i].size()) != m)\n                quitf(_wa, \"Invalid output line length at line %d\", i + 1);\n        }\n        // If judge claimed no solution, but participant provided a solution\n        if (judgeNoSolution) {\n            quitf(_fail, \"Participant found a solution, but judge didn't\");\n        }\n        // Proceed to validate participant's coloring\n        // Check that all characters are '1' to '4' and match the input where provided\n        for (int i = 0; i < n; ++i) {\n            if (int(participantGrid[i].size()) != m)\n                quitf(_wa, \"Incorrect line length at line %d\", i + 1);\n            for (int j = 0; j < m; ++j) {\n                char ch = participantGrid[i][j];\n                if (ch < '1' || ch > '4')\n                    quitf(_wa, \"Invalid color at position (%d,%d), found '%c', expected '1'-'4'\", i + 1, j + 1, ch);\n                if (inputGrid[i][j] != '0' && participantGrid[i][j] != inputGrid[i][j])\n                    quitf(_wa, \"Participant changed initial color at position (%d,%d)\", i + 1, j + 1);\n            }\n        }\n        // Check adjacency for coloring validity\n        int dx[] = {-1,-1,-1,0,0,1,1,1};\n        int dy[] = {-1,0,1,-1,1,-1,0,1};\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                char c1 = participantGrid[i][j];\n                for (int d = 0; d < 8; ++d) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < m) {\n                        char c2 = participantGrid[ni][nj];\n                        if (c1 == c2)\n                            quitf(_wa, \"Adjacent vertices (%d,%d) and (%d,%d) have the same color '%c'\", i + 1, j + 1, ni + 1, nj + 1, c1);\n                    }\n                }\n            }\n        }\n        // All checks passed, participant's coloring is valid\n        quitf(_ok, \"Correct coloring\");\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n);\n\n    if (type == \"empty\") {\n        // All cells are zeros\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n        }\n    }\n    else if (type == \"full\") {\n        // All cells are pre-colored, ensuring valid coloring\n        grid.assign(n, string(m, '0'));\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '0' + ((i % 2) * 2 + (j % 2) + 1); // Colors 1-4\n            }\n        }\n    }\n    else if (type == \"checkerboard\") {\n        // Valid checkerboard pattern with four colors\n        grid.assign(n, string(m, '0'));\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '0' + ((i % 2) * 2 + (j % 2) + 1); // Colors 1-4\n            }\n        }\n    }\n    else if (type == \"conflict\") {\n        // Create a grid where pre-colored cells are in conflict so that no solution exists\n        grid.assign(n, string(m, '0'));\n        if (n >= 2 && m >= 2) {\n            int x = n / 2;\n            int y = m / 2;\n            grid[x][y] = '1'; // Color 1\n\n            // Now color all neighbors with the same color\n            for (int dx = -1; dx <= 1; ++dx) {\n                int ni = x + dx;\n                if (ni < 0 || ni >= n) continue;\n                for (int dy = -1; dy <= 1; ++dy) {\n                    int nj = y + dy;\n                    if (nj < 0 || nj >= m) continue;\n                    if (dx == 0 && dy == 0) continue;\n                    grid[ni][nj] = '1'; // Same color as center\n                }\n            }\n        }\n    }\n    else if (type == \"diagconflict\") {\n        // Conflict in diagonally adjacent cells\n        grid.assign(n, string(m, '0'));\n        if (n >= 2 && m >= 2) {\n            grid[0][0] = '1'; // Color 1\n            grid[1][1] = '1'; // Diagonally adjacent with same color\n        }\n    }\n    else if (type == \"twocolors\") {\n        // Use two colors in a checkerboard pattern (invalid due to diagonals)\n        grid.assign(n, string(m, '0'));\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '0' + ((i + j) % 2 + 1); // Colors 1 and 2\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly pre-color some cells with random colors\n        grid.assign(n, string(m, '0'));\n        int num_precolored = rnd.next(0, n * m);\n        for (int k = 0; k < num_precolored; ++k) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            int color = rnd.next(1, 4);\n            grid[i][j] = '0' + color;\n        }\n    }\n    else {\n        // Default to empty grid\n        grid.assign(n, string(m, '0'));\n    }\n\n    // Now output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n);\n\n    if (type == \"empty\") {\n        // All cells are zeros\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n        }\n    }\n    else if (type == \"full\") {\n        // All cells are pre-colored, ensuring valid coloring\n        grid.assign(n, string(m, '0'));\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '0' + ((i % 2) * 2 + (j % 2) + 1); // Colors 1-4\n            }\n        }\n    }\n    else if (type == \"checkerboard\") {\n        // Valid checkerboard pattern with four colors\n        grid.assign(n, string(m, '0'));\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '0' + ((i % 2) * 2 + (j % 2) + 1); // Colors 1-4\n            }\n        }\n    }\n    else if (type == \"conflict\") {\n        // Create a grid where pre-colored cells are in conflict so that no solution exists\n        grid.assign(n, string(m, '0'));\n        if (n >= 2 && m >= 2) {\n            int x = n / 2;\n            int y = m / 2;\n            grid[x][y] = '1'; // Color 1\n\n            // Now color all neighbors with the same color\n            for (int dx = -1; dx <= 1; ++dx) {\n                int ni = x + dx;\n                if (ni < 0 || ni >= n) continue;\n                for (int dy = -1; dy <= 1; ++dy) {\n                    int nj = y + dy;\n                    if (nj < 0 || nj >= m) continue;\n                    if (dx == 0 && dy == 0) continue;\n                    grid[ni][nj] = '1'; // Same color as center\n                }\n            }\n        }\n    }\n    else if (type == \"diagconflict\") {\n        // Conflict in diagonally adjacent cells\n        grid.assign(n, string(m, '0'));\n        if (n >= 2 && m >= 2) {\n            grid[0][0] = '1'; // Color 1\n            grid[1][1] = '1'; // Diagonally adjacent with same color\n        }\n    }\n    else if (type == \"twocolors\") {\n        // Use two colors in a checkerboard pattern (invalid due to diagonals)\n        grid.assign(n, string(m, '0'));\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '0');\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = '0' + ((i + j) % 2 + 1); // Colors 1 and 2\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Randomly pre-color some cells with random colors\n        grid.assign(n, string(m, '0'));\n        int num_precolored = rnd.next(0, n * m);\n        for (int k = 0; k < num_precolored; ++k) {\n            int i = rnd.next(0, n - 1);\n            int j = rnd.next(0, m - 1);\n            int color = rnd.next(1, 4);\n            grid[i][j] = '0' + color;\n        }\n    }\n    else {\n        // Default to empty grid\n        grid.assign(n, string(m, '0'));\n    }\n\n    // Now output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output the grid\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type conflict\n./gen -n 2 -m 2 -type diagconflict\n./gen -n 2 -m 2 -type twocolors\n./gen -n 2 -m 2 -type checkerboard\n\n./gen -n 10 -m 10 -type empty\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type conflict\n./gen -n 10 -m 10 -type diagconflict\n./gen -n 10 -m 10 -type twocolors\n./gen -n 10 -m 10 -type checkerboard\n./gen -n 10 -m 10 -type full\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type checkerboard\n./gen -n 100 -m 100 -type conflict\n./gen -n 100 -m 100 -type diagconflict\n./gen -n 100 -m 100 -type full\n\n./gen -n 500 -m 500 -type random\n./gen -n 500 -m 500 -type checkerboard\n./gen -n 500 -m 500 -type conflict\n\n./gen -n 1000 -m 1000 -type empty\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type conflict\n./gen -n 1000 -m 1000 -type diagconflict\n./gen -n 1000 -m 1000 -type twocolors\n./gen -n 1000 -m 1000 -type checkerboard\n./gen -n 1000 -m 1000 -type full\n\n./gen -n 999 -m 1000 -type twocolors\n./gen -n 2 -m 1000 -type conflict\n./gen -n 1000 -m 2 -type diagconflict\n\n./gen -n 200 -m 300 -type random\n./gen -n 300 -m 200 -type random\n\n./gen -n 50 -m 50 -type random\n./gen -n 50 -m 50 -type full\n./gen -n 50 -m 50 -type checkerboard\n./gen -n 50 -m 50 -type conflict\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type diagconflict\n\n./gen -n 2 -m 3 -type random\n./gen -n 3 -m 2 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:54.342204",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "436/A",
      "title": "A. Feed with Candy",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and x (1 ≤ n, x ≤ 2000) — the number of sweets Evan has and the initial height of Om Nom's jump. Each of the following n lines contains three integers ti, hi, mi (0 ≤ ti ≤ 1; 1 ≤ hi, mi ≤ 2000) — the type, height and the mass of the i-th candy. If number ti equals 0, then the current candy is a caramel drop, otherwise it is a fruit drop.",
      "output_spec": "OutputPrint a single integer — the maximum number of candies Om Nom can eat.",
      "sample_tests": "ExamplesInputCopy5 30 2 41 3 10 8 30 20 101 5 5OutputCopy4",
      "description": "A. Feed with Candy\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and x (1 ≤ n, x ≤ 2000) — the number of sweets Evan has and the initial height of Om Nom's jump. Each of the following n lines contains three integers ti, hi, mi (0 ≤ ti ≤ 1; 1 ≤ hi, mi ≤ 2000) — the type, height and the mass of the i-th candy. If number ti equals 0, then the current candy is a caramel drop, otherwise it is a fruit drop.\n\nOutputPrint a single integer — the maximum number of candies Om Nom can eat.\n\nInputCopy5 30 2 41 3 10 8 30 20 101 5 5OutputCopy4\n\nInputCopy5 30 2 41 3 10 8 30 20 101 5 5\n\nOutputCopy4\n\nNoteOne of the possible ways to eat 4 candies is to eat them in the order: 1, 5, 3, 2. Let's assume the following scenario:  Initially, the height of Om Nom's jump equals 3. He can reach candies 1 and 2. Let's assume that he eats candy 1. As the mass of this candy equals 4, the height of his jump will rise to 3 + 4 = 7.  Now Om Nom can reach candies 2 and 5. Let's assume that he eats candy 5. Then the height of his jump will be 7 + 5 = 12.  At this moment, Om Nom can reach two candies, 2 and 3. He won't eat candy 2 as its type matches the type of the previously eaten candy. Om Nom eats candy 3, the height of his jump is 12 + 3 = 15.  Om Nom eats candy 2, the height of his jump is 15 + 1 = 16. He cannot reach candy 4.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces",
          "content": "A coder can apply his breathtaking coding skills not only in different search engines but also in the mobile game industry. It is an option in Russia. If you do not believe — check this out: ZeptoLab company that created the world famous Cut the Rope game offers you the opportunity to see this for yourself. And yes, we are in Moscow.It's not a secret that those who strive to achieve top coding skills — work hard, including work on his self-education. Here in ZeptoLab we aim to create the area that strongly encourages self-development. Specifically, we have recently purchased a company library with everything necessary to get new knowledge, an improvised reading room with sofas and armchairs. We also conduct developer's contest inside the company so that our ZeptoCoders could solve non-trivial problems and impress each other with zeroes and ones. The winners get glory, valuable gifts and name-encrusted weapon (it's a joke, it’s not weapon) We have recently opened our own algorithmic school here in ZebtoLab and the teacher is no other than the creator and the head of the whole wide Codeforces, Mike Mirzayanov! He is well-known among developers: Mike has trained a team that became the world champion in programming, so it's not hard to imagine the opportunities opened for ZeptoLab developers and the whole company. It's the first time that Mike teaches in such format, there are hardly any more examples of such corporate education systems in Russia and throughout the world. Algorithms play an important role for us as the requirements for developers are quite tough: ideally, the application should output 60 frames per second on the target gadget. All game logic calculations should be very quick and preferably, with simple and not amortized complexity. Besides, we can afford a fine pre-processing to transport some calculations to the stage at which resources for the game are prepared. Understanding this facts, alongside with many more is the key to the quick gameplay. That is why we support the algorithmist's movement.It's the first time when Zeptolab holds an algorithmic development contest based on Codeforces. Ingenious problems, fierce developer rivalry and cool prizes are waiting for you: 1st prize: Ipad Air, plush Om Nom, the championship T-shirt 2nd-3rd prize: Ipad Mini, plush Om Nom, the championship T-shirt 4-th-30-th prize: plush Om Nom, the championship T-shirt 31st-50th prize: the championship T-shirt And just for some suspense, we add another prize: We will randomly give the IPad Mini Retina to the person who makes it to the top 50 list of the contest champion. The IPad winner will be chosen like this: we sum up the times of all successful attempts of three top winners (in seconds starting from the start of the contest) and take a row with number s % 47 + 4, where s is the resulting sum. Being true coders. If the resulting line divides the place, then the priority goes to the earlier person to submit his last solved problem.Besides, the person who shows good results in the contest will have the opportunity to apply for a job in our company by a simplified scheme. If you'd be interested to try working in the ZeptoLab team, tick the corresponding square at the registration. You can find out more about what working with us is like at http://zeptoteam.ru/. What to apply to ZeptoLab? The championship will be conducted in a single round. The contest will go by the Codeforces rules. The round will be rated and both divisions can participate.The date and time of the contest is: June 13, 2014, 15:30PM — 18PM (UTC).The problem scores are: 1000-1000-1500-2500-2500-3000.The contest is over! Thanks for all the participants! We hope you like the problems and the contest! Our special congratulations to the winners: The 1st place — KAN (Nikolay Kalinin, Russia, Nizhniy Novgorod) — iPad Air The 2nd place — winger (Vladislav Isenbaev, USA, Facebook) — iPad Mini The 3rd place — tourist (Gennady Korotkevich, Russia, Saint Peterburg, ITMO) — iPad Mini All the participants on the places 1-30 will receive presents: plush Om Nom and the championship T-shirt. All the participants on the places 31-50 will receive championship T-shirt!Additional prize will be received to the the 21st place winner: package.zaic (Vadim Zaycev, Russia, Novosibirsk, NSU).",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/12605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4308
        },
        {
          "title": "Zepto Code Rush 2014 — solutions A-D - Codeforces",
          "content": "436A - Feed with CandyTutorial author: Fefer_IvanIn this problem types of eaten candies must alternate. It means that the type of first eaten candy dictated the types of all the following candies. There are only two possible types so we should consider each type as a type of first eaten candy separatelly and then pick the most optimal. So, what if Om Nom wants to eat a candy of type t and can jump up to h? It is obvious that best option is to eat a candy with maximal mass among all the candies he can eat at this time.436B - Om Nom and SpidersTutorial author: Fefer_IvanLet us number columns with integers from 0 from left to right and rows from 0 from top to bottom. In the cell (x, y) at the time t only four spiders can be at this cell: Spider, which is moving left and started at (x, y + t). Spider, which is moving right and started at (x, y - t). Spider, which is moving up and started at (x + t, y). Spider, which is moving down and started at (x - t, y). Let iterate through all possible starting positions of Om Nom. Consider that he starts at column y. At time 0 all spiders are on their initial positions and Om Nom is at (0, y). There is no spiders at row 0, so at time 0 Om Nom can not meet any spiders. When Om Nom is at cell (x, y), it means that x units of time passed after the start. So to calculate the number of spiders, that Om Nom meets it is enought to check only 4 cells stated above.436C - Dungeons and CandiesTutorial author: Fefer_IvanLet's consider a weighted undirected graph with k + 1 vertex. Label the vertices with numbers from 0 to k. Vertices from 1 to k correspond to levels. For each pair of levels i and j add an edge between vertices i and j with weight equal to the cost of transferring one level as a difference from the other level. For each level i add an edge from vertex 0 to vertex i with weight equal to n·m, i.e. cost of transmitting the whole level. Each way to transmit levels defined an spanning tree of this graph. So to solve the problem, we must find a minimal spanning tree of this graph.436D - Pudding MonstersTutorial author: Fefer_IvanThis problem can be solved using dynamic programming. Let's introduce some designations: sum(l, r) — number of special cells on the segment [l, r], zi — maximal number of covered special cells using only first i monsters, di — maximal number of covered special cells using only first i monsters and with i-th monster not moving.How to calculate di. Let's denote i-th monster position as r. Let's iterate through all special cells to the left of i-th monster. Let's denote current special cell position as l. Let's consider the situation when this cell is the leftmost special cell in the block of monsters with i-th monster in it. So we need r - l additional monsters to get to this cell from monster i. So the value of di can be updated with zi - (r - l) + sum(l, r).Now, after we computed new value of di, we need to update some values of zj. Let's denote i-th monster position as l. Let's iterate through all special cells to the right of i-th monster. Let's denote current special cell position as r. Let's consider the situation when this cell is the rightmost special cell in the block of monsters with i-th monster in it. So we need r - l additional monsters to get to this cell from monster i. So we can update the value zi + (r - l) with di + sum(l + 1, r). Also, zi should be updated with zi - 1.So the solution works in O(n·m) because for each of n monsters we iterate through all m special cells and for a fixed monster-cell pair all computing is done in O(1).There are some details about monsters, that are merged at the initial state, but they are pretty easy to figure out.436E - Cardboard BoxTutorial author: Gerald, NerevarIn this task you have to come with the proper greedy algorithms. Several algorithms will fit, let's describe one of them: From that point we will consider that the levels are sorted by increasing value of b. Let's look at some optimal solution (a set of completed levels). From levels that we completed for two stars, select the level k with the largest b[k]. It turns out that all levels that stand before k (remember, the levels are sorted) should be completed for at least one star. Otherwise, we could complete some of the previous levels instead of the level k. This won't increase the cost. Let's fix a prefix of the first L levels and solve the problem with the assumption that each of the selected levels should be completed. Additionally, we will assume that all levels that are completed for two stars are within this prefix (as was shown before, such prefix of L levels always exists for some optimal solution). As we will surely complete this L levels, we can imagine that we have initially completed all of the for just one star. So, we have w - L more stars to get. We can get these stars either by completing some of the levels that are outside our prefix for one star, or by completing some of the first L levels for two stars instead of one star. It's clear that we just have to choose w - L cheapest options, which correspond to w - L smallest numbers among the following: b[i] - a[i] for i ≤ L and a[i] for i > L. Computing the sum of these smallest values can be done with a data structure like Cartesian tree or BIT. The described solution has time completixy of O(n log n).436F - BannersTutorial author: Gerald, NerevarTask F was the hardest one in the problemset. To better understand the solution, let's look at the task from the geometrical point of view. Imagine that people are point in the Opc plane (value of p and q are points' coordinates). Then for each line horizontal c = i we have to find such vertical line p = j that maximizes some target function. The function is computed as follows: (number of points not below c = i, multiplied by w·i) plus (number of points below c = i and not to the left of p = j, multiplied by j).Let's move scanning line upwards (consider values c = 0, then c = 1, etc). For each value of p we will store the value d[p] — the value of the target function with the current value of c and this value of p. The problem is: if we have such array d[] for the value c, how to recompute it for the value c + 1?Let's look at all people that will be affected by the increase of c: these are the people with b[i] = c. With the current c they are still using free version, after the increase they won't. Each of these people makes the following effect to the array: d[1] +  = 1, d[2] +  = 2, ..., d[b[i]] +  = b[i]Now the task can be reduced to the problem related with data structures. There are two types of queries: add the increasing arithmetical progression to the prefix of the array and retrieve the maximum value of the array. One of the way to solve it is to use sqrt-decomposition.Let's divide all queries into groups of size sqrt(q). Let's denote the queries from the group as a sequence: p1, p2, ..., pk (k = sqrt(q)). For query pi we should perform assignments d[1] +  = 1, d[2] +  = 2, ..., d[pi] +  = pi. Imagine we already preformed all the queries. Each value of new array d[] can be represented as d[i] = oldD[i] + i·coef[i], where coef[i] is the number of pj (pj > i).One can notice that array coef contains at most sqrt(q) distinct values, additionally this array can be splitted into O(sqrt(q)) parts such that all elements from the same part will be the same. This is the key observation. We will divide array coef into parts. And for each part will maintain lower envelope of the lines y = d[i] + i·x. So, we will have O(sqrt(q)) lower envelopes. Each envelope will help us to get maximum value among the segment of array d[i](oldD[i] + i·coef[i]). As for each i from some segment factor coef[i] is containt we can just pick y-coordinate with x = coef[i] of corresponding lower envelope.Described solution has time complexity of O(MAXX·sqrt(MAXX)), where MAXX is the maximum value among a[i] and b[i]. With best regards, Ivan.",
          "author": "Fefer_Ivan",
          "url": "https://codeforces.com/blog/entry/12680",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 436\\s*A"
          },
          "content_length": 7939
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 1",
          "code": "You may edit your comment only for fixing grammar mistakes or small changes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 2",
          "code": "Do not change the main idea of your comment.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 3",
          "code": "All previous revisions are available for others. Are you sure you want to edit comment?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 4",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 5",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 6",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 7",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 8",
          "code": "if(par[r] = r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 9",
          "code": "if(par[r] == r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 10",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 11",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 12",
          "code": "What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 2000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int t_i = inf.readInt(0, 1, \"t_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 2000, \"h_i\");\n        inf.readSpace();\n        int m_i = inf.readInt(1, 2000, \"m_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 2000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int t_i = inf.readInt(0, 1, \"t_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 2000, \"h_i\");\n        inf.readSpace();\n        int m_i = inf.readInt(1, 2000, \"m_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(1, 2000, \"x\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int t_i = inf.readInt(0, 1, \"t_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 2000, \"h_i\");\n        inf.readSpace();\n        int m_i = inf.readInt(1, 2000, \"m_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    int n = opt<int>(\"n\", 1);\n    int x = opt<int>(\"x\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ti(n), hi(n), mi(n);\n\n    if (type == \"all_same_type\") {\n        // All candies are of the same type\n        int t = rnd.next(0, 1); // Random type 0 or 1\n        for (int i = 0; i < n; ++i) {\n            ti[i] = t;\n            hi[i] = rnd.next(1, 2000);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"alternating_types\") {\n        // Candies alternate types\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i % 2;\n            hi[i] = rnd.next(1, 2000);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"max_height_max_mass\") {\n        // Candies have maximum height and mass\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            hi[i] = 2000;\n            mi[i] = 2000;\n        }\n    } else if (type == \"min_height_min_mass\") {\n        // Candies have minimum height and mass\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            hi[i] = 1;\n            mi[i] = 1;\n        }\n    } else if (type == \"unreachable_initially\") {\n        // Candies are initially unreachable but become reachable after eating others\n        ti[0] = rnd.next(0, 1); // First candy type\n        hi[0] = rnd.next(1, x); // First candy is reachable\n        mi[0] = rnd.next(1, 2000);\n        for (int i = 1; i < n; ++i) {\n            ti[i] = (ti[i - 1] + 1) % 2; // Alternate types\n            hi[i] = hi[i - 1] + mi[i - 1] + rnd.next(1, 2000); // Ensure next candy is unreachable until previous is eaten\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"ascending_heights\") {\n        // Candies with ascending heights\n        for (int i = 0; i < n; ++i) {\n            hi[i] = rnd.next(1, 2000);\n        }\n        sort(hi.begin(), hi.end());\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"descending_heights\") {\n        // Candies with descending heights\n        for (int i = 0; i < n; ++i) {\n            hi[i] = rnd.next(1, 2000);\n        }\n        sort(hi.begin(), hi.end(), greater<int>());\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else {\n        // Random candies\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            hi[i] = rnd.next(1, 2000);\n            mi[i] = rnd.next(1, 2000);\n        }\n    }\n\n    // Output n and x\n    printf(\"%d %d\\n\", n, x);\n    // Output candies\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", ti[i], hi[i], mi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse command line arguments\n    int n = opt<int>(\"n\", 1);\n    int x = opt<int>(\"x\", 1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ti(n), hi(n), mi(n);\n\n    if (type == \"all_same_type\") {\n        // All candies are of the same type\n        int t = rnd.next(0, 1); // Random type 0 or 1\n        for (int i = 0; i < n; ++i) {\n            ti[i] = t;\n            hi[i] = rnd.next(1, 2000);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"alternating_types\") {\n        // Candies alternate types\n        for (int i = 0; i < n; ++i) {\n            ti[i] = i % 2;\n            hi[i] = rnd.next(1, 2000);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"max_height_max_mass\") {\n        // Candies have maximum height and mass\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            hi[i] = 2000;\n            mi[i] = 2000;\n        }\n    } else if (type == \"min_height_min_mass\") {\n        // Candies have minimum height and mass\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            hi[i] = 1;\n            mi[i] = 1;\n        }\n    } else if (type == \"unreachable_initially\") {\n        // Candies are initially unreachable but become reachable after eating others\n        ti[0] = rnd.next(0, 1); // First candy type\n        hi[0] = rnd.next(1, x); // First candy is reachable\n        mi[0] = rnd.next(1, 2000);\n        for (int i = 1; i < n; ++i) {\n            ti[i] = (ti[i - 1] + 1) % 2; // Alternate types\n            hi[i] = hi[i - 1] + mi[i - 1] + rnd.next(1, 2000); // Ensure next candy is unreachable until previous is eaten\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"ascending_heights\") {\n        // Candies with ascending heights\n        for (int i = 0; i < n; ++i) {\n            hi[i] = rnd.next(1, 2000);\n        }\n        sort(hi.begin(), hi.end());\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else if (type == \"descending_heights\") {\n        // Candies with descending heights\n        for (int i = 0; i < n; ++i) {\n            hi[i] = rnd.next(1, 2000);\n        }\n        sort(hi.begin(), hi.end(), greater<int>());\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            mi[i] = rnd.next(1, 2000);\n        }\n    } else {\n        // Random candies\n        for (int i = 0; i < n; ++i) {\n            ti[i] = rnd.next(0, 1);\n            hi[i] = rnd.next(1, 2000);\n            mi[i] = rnd.next(1, 2000);\n        }\n    }\n\n    // Output n and x\n    printf(\"%d %d\\n\", n, x);\n    // Output candies\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d %d\\n\", ti[i], hi[i], mi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2000 -x 2000 -type random\n./gen -n 2000 -x 500 -type random\n./gen -n 2000 -x 1 -type random\n\n./gen -n 2000 -x 2000 -type all_same_type\n./gen -n 2000 -x 2000 -type alternating_types\n\n./gen -n 2000 -x 1 -type min_height_min_mass\n./gen -n 2000 -x 2000 -type max_height_max_mass\n\n./gen -n 1 -x 100 -type random\n./gen -n 2 -x 100 -type random\n\n./gen -n 2000 -x 2000 -type ascending_heights\n./gen -n 2000 -x 2000 -type descending_heights\n./gen -n 2000 -x 2000 -type unreachable_initially\n\n./gen -n 2000 -x 2000 -type small_initial_x\n./gen -n 2000 -x 1 -type small_initial_x\n./gen -n 2000 -x 2000 -type max_initial_x\n\n./gen -n 100 -x 100 -type random\n./gen -n 500 -x 10 -type random\n./gen -n 1000 -x 1000 -type random\n./gen -n 2000 -x 1 -type random\n\n./gen -n 200 -x 20 -type alternating_types\n./gen -n 2000 -x 200 -type alternating_types\n./gen -n 2000 -x 2000 -type alternating_types\n./gen -n 2000 -x 1 -type alternating_types\n\n./gen -n 2000 -x 2000 -type all_same_type\n./gen -n 2000 -x 1 -type all_same_type\n\n./gen -n 2000 -x 2000 -type ascending_heights\n./gen -n 2000 -x 1 -type ascending_heights\n./gen -n 2000 -x 2000 -type descending_heights\n./gen -n 2000 -x 1 -type descending_heights\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:56.842549",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "436/B",
      "title": "B. Om Nom and Spiders",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (2 ≤ n, m ≤ 2000; 0 ≤ k ≤ m(n - 1)). Each of the next n lines contains m characters — the description of the park. The characters in the i-th line describe the i-th row of the park field. If the character in the line equals \".\", that means that the corresponding cell of the field is empty; otherwise, the character in the line will equal one of the four characters: \"L\" (meaning that this cell has a spider at time 0, moving left), \"R\" (a spider moving right), \"U\" (a spider moving up), \"D\" (a spider moving down). It is guaranteed that the first row doesn't contain any spiders. It is guaranteed that the description of the field contains no extra characters. It is guaranteed that at time 0 the field contains exactly k spiders.",
      "output_spec": "OutputPrint m integers: the j-th integer must show the number of spiders Om Nom will see if he starts his walk from the j-th cell of the first row. The cells in any row of the field are numbered from left to right.",
      "sample_tests": "ExamplesInputCopy3 3 4...R.LR.UOutputCopy0 2 2 InputCopy2 2 2..RLOutputCopy1 1 InputCopy2 2 2..LROutputCopy0 0 InputCopy3 4 8....RRLLUUUUOutputCopy1 3 3 1 InputCopy2 2 2..UUOutputCopy0 0",
      "description": "B. Om Nom and Spiders\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (2 ≤ n, m ≤ 2000; 0 ≤ k ≤ m(n - 1)). Each of the next n lines contains m characters — the description of the park. The characters in the i-th line describe the i-th row of the park field. If the character in the line equals \".\", that means that the corresponding cell of the field is empty; otherwise, the character in the line will equal one of the four characters: \"L\" (meaning that this cell has a spider at time 0, moving left), \"R\" (a spider moving right), \"U\" (a spider moving up), \"D\" (a spider moving down). It is guaranteed that the first row doesn't contain any spiders. It is guaranteed that the description of the field contains no extra characters. It is guaranteed that at time 0 the field contains exactly k spiders.\n\nOutputPrint m integers: the j-th integer must show the number of spiders Om Nom will see if he starts his walk from the j-th cell of the first row. The cells in any row of the field are numbered from left to right.\n\nInputCopy3 3 4...R.LR.UOutputCopy0 2 2 InputCopy2 2 2..RLOutputCopy1 1 InputCopy2 2 2..LROutputCopy0 0 InputCopy3 4 8....RRLLUUUUOutputCopy1 3 3 1 InputCopy2 2 2..UUOutputCopy0 0\n\nInputCopy3 3 4...R.LR.U\n\nOutputCopy0 2 2\n\nInputCopy2 2 2..RL\n\nOutputCopy1 1\n\nInputCopy2 2 2..LR\n\nOutputCopy0 0\n\nInputCopy3 4 8....RRLLUUUU\n\nOutputCopy1 3 3 1\n\nInputCopy2 2 2..UU\n\nOutputCopy0 0\n\nNoteConsider the first sample. The notes below show how the spider arrangement changes on the field over time:...        ...        ..U       ...R.L   ->   .*U   ->   L.R   ->  ...R.U        .R.        ..R       ...Character \"*\" represents a cell that contains two spiders at the same time.  If Om Nom starts from the first cell of the first row, he won't see any spiders.  If he starts from the second cell, he will see two spiders at time 1.  If he starts from the third cell, he will see two spiders: one at time 1, the other one at time 2.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces",
          "content": "A coder can apply his breathtaking coding skills not only in different search engines but also in the mobile game industry. It is an option in Russia. If you do not believe — check this out: ZeptoLab company that created the world famous Cut the Rope game offers you the opportunity to see this for yourself. And yes, we are in Moscow.It's not a secret that those who strive to achieve top coding skills — work hard, including work on his self-education. Here in ZeptoLab we aim to create the area that strongly encourages self-development. Specifically, we have recently purchased a company library with everything necessary to get new knowledge, an improvised reading room with sofas and armchairs. We also conduct developer's contest inside the company so that our ZeptoCoders could solve non-trivial problems and impress each other with zeroes and ones. The winners get glory, valuable gifts and name-encrusted weapon (it's a joke, it’s not weapon) We have recently opened our own algorithmic school here in ZebtoLab and the teacher is no other than the creator and the head of the whole wide Codeforces, Mike Mirzayanov! He is well-known among developers: Mike has trained a team that became the world champion in programming, so it's not hard to imagine the opportunities opened for ZeptoLab developers and the whole company. It's the first time that Mike teaches in such format, there are hardly any more examples of such corporate education systems in Russia and throughout the world. Algorithms play an important role for us as the requirements for developers are quite tough: ideally, the application should output 60 frames per second on the target gadget. All game logic calculations should be very quick and preferably, with simple and not amortized complexity. Besides, we can afford a fine pre-processing to transport some calculations to the stage at which resources for the game are prepared. Understanding this facts, alongside with many more is the key to the quick gameplay. That is why we support the algorithmist's movement.It's the first time when Zeptolab holds an algorithmic development contest based on Codeforces. Ingenious problems, fierce developer rivalry and cool prizes are waiting for you: 1st prize: Ipad Air, plush Om Nom, the championship T-shirt 2nd-3rd prize: Ipad Mini, plush Om Nom, the championship T-shirt 4-th-30-th prize: plush Om Nom, the championship T-shirt 31st-50th prize: the championship T-shirt And just for some suspense, we add another prize: We will randomly give the IPad Mini Retina to the person who makes it to the top 50 list of the contest champion. The IPad winner will be chosen like this: we sum up the times of all successful attempts of three top winners (in seconds starting from the start of the contest) and take a row with number s % 47 + 4, where s is the resulting sum. Being true coders. If the resulting line divides the place, then the priority goes to the earlier person to submit his last solved problem.Besides, the person who shows good results in the contest will have the opportunity to apply for a job in our company by a simplified scheme. If you'd be interested to try working in the ZeptoLab team, tick the corresponding square at the registration. You can find out more about what working with us is like at http://zeptoteam.ru/. What to apply to ZeptoLab? The championship will be conducted in a single round. The contest will go by the Codeforces rules. The round will be rated and both divisions can participate.The date and time of the contest is: June 13, 2014, 15:30PM — 18PM (UTC).The problem scores are: 1000-1000-1500-2500-2500-3000.The contest is over! Thanks for all the participants! We hope you like the problems and the contest! Our special congratulations to the winners: The 1st place — KAN (Nikolay Kalinin, Russia, Nizhniy Novgorod) — iPad Air The 2nd place — winger (Vladislav Isenbaev, USA, Facebook) — iPad Mini The 3rd place — tourist (Gennady Korotkevich, Russia, Saint Peterburg, ITMO) — iPad Mini All the participants on the places 1-30 will receive presents: plush Om Nom and the championship T-shirt. All the participants on the places 31-50 will receive championship T-shirt!Additional prize will be received to the the 21st place winner: package.zaic (Vadim Zaycev, Russia, Novosibirsk, NSU).",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/12605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 4308
        },
        {
          "title": "Zepto Code Rush 2014 — solutions A-D - Codeforces",
          "content": "436A - Feed with CandyTutorial author: Fefer_IvanIn this problem types of eaten candies must alternate. It means that the type of first eaten candy dictated the types of all the following candies. There are only two possible types so we should consider each type as a type of first eaten candy separatelly and then pick the most optimal. So, what if Om Nom wants to eat a candy of type t and can jump up to h? It is obvious that best option is to eat a candy with maximal mass among all the candies he can eat at this time.436B - Om Nom and SpidersTutorial author: Fefer_IvanLet us number columns with integers from 0 from left to right and rows from 0 from top to bottom. In the cell (x, y) at the time t only four spiders can be at this cell: Spider, which is moving left and started at (x, y + t). Spider, which is moving right and started at (x, y - t). Spider, which is moving up and started at (x + t, y). Spider, which is moving down and started at (x - t, y). Let iterate through all possible starting positions of Om Nom. Consider that he starts at column y. At time 0 all spiders are on their initial positions and Om Nom is at (0, y). There is no spiders at row 0, so at time 0 Om Nom can not meet any spiders. When Om Nom is at cell (x, y), it means that x units of time passed after the start. So to calculate the number of spiders, that Om Nom meets it is enought to check only 4 cells stated above.436C - Dungeons and CandiesTutorial author: Fefer_IvanLet's consider a weighted undirected graph with k + 1 vertex. Label the vertices with numbers from 0 to k. Vertices from 1 to k correspond to levels. For each pair of levels i and j add an edge between vertices i and j with weight equal to the cost of transferring one level as a difference from the other level. For each level i add an edge from vertex 0 to vertex i with weight equal to n·m, i.e. cost of transmitting the whole level. Each way to transmit levels defined an spanning tree of this graph. So to solve the problem, we must find a minimal spanning tree of this graph.436D - Pudding MonstersTutorial author: Fefer_IvanThis problem can be solved using dynamic programming. Let's introduce some designations: sum(l, r) — number of special cells on the segment [l, r], zi — maximal number of covered special cells using only first i monsters, di — maximal number of covered special cells using only first i monsters and with i-th monster not moving.How to calculate di. Let's denote i-th monster position as r. Let's iterate through all special cells to the left of i-th monster. Let's denote current special cell position as l. Let's consider the situation when this cell is the leftmost special cell in the block of monsters with i-th monster in it. So we need r - l additional monsters to get to this cell from monster i. So the value of di can be updated with zi - (r - l) + sum(l, r).Now, after we computed new value of di, we need to update some values of zj. Let's denote i-th monster position as l. Let's iterate through all special cells to the right of i-th monster. Let's denote current special cell position as r. Let's consider the situation when this cell is the rightmost special cell in the block of monsters with i-th monster in it. So we need r - l additional monsters to get to this cell from monster i. So we can update the value zi + (r - l) with di + sum(l + 1, r). Also, zi should be updated with zi - 1.So the solution works in O(n·m) because for each of n monsters we iterate through all m special cells and for a fixed monster-cell pair all computing is done in O(1).There are some details about monsters, that are merged at the initial state, but they are pretty easy to figure out.436E - Cardboard BoxTutorial author: Gerald, NerevarIn this task you have to come with the proper greedy algorithms. Several algorithms will fit, let's describe one of them: From that point we will consider that the levels are sorted by increasing value of b. Let's look at some optimal solution (a set of completed levels). From levels that we completed for two stars, select the level k with the largest b[k]. It turns out that all levels that stand before k (remember, the levels are sorted) should be completed for at least one star. Otherwise, we could complete some of the previous levels instead of the level k. This won't increase the cost. Let's fix a prefix of the first L levels and solve the problem with the assumption that each of the selected levels should be completed. Additionally, we will assume that all levels that are completed for two stars are within this prefix (as was shown before, such prefix of L levels always exists for some optimal solution). As we will surely complete this L levels, we can imagine that we have initially completed all of the for just one star. So, we have w - L more stars to get. We can get these stars either by completing some of the levels that are outside our prefix for one star, or by completing some of the first L levels for two stars instead of one star. It's clear that we just have to choose w - L cheapest options, which correspond to w - L smallest numbers among the following: b[i] - a[i] for i ≤ L and a[i] for i > L. Computing the sum of these smallest values can be done with a data structure like Cartesian tree or BIT. The described solution has time completixy of O(n log n).436F - BannersTutorial author: Gerald, NerevarTask F was the hardest one in the problemset. To better understand the solution, let's look at the task from the geometrical point of view. Imagine that people are point in the Opc plane (value of p and q are points' coordinates). Then for each line horizontal c = i we have to find such vertical line p = j that maximizes some target function. The function is computed as follows: (number of points not below c = i, multiplied by w·i) plus (number of points below c = i and not to the left of p = j, multiplied by j).Let's move scanning line upwards (consider values c = 0, then c = 1, etc). For each value of p we will store the value d[p] — the value of the target function with the current value of c and this value of p. The problem is: if we have such array d[] for the value c, how to recompute it for the value c + 1?Let's look at all people that will be affected by the increase of c: these are the people with b[i] = c. With the current c they are still using free version, after the increase they won't. Each of these people makes the following effect to the array: d[1] +  = 1, d[2] +  = 2, ..., d[b[i]] +  = b[i]Now the task can be reduced to the problem related with data structures. There are two types of queries: add the increasing arithmetical progression to the prefix of the array and retrieve the maximum value of the array. One of the way to solve it is to use sqrt-decomposition.Let's divide all queries into groups of size sqrt(q). Let's denote the queries from the group as a sequence: p1, p2, ..., pk (k = sqrt(q)). For query pi we should perform assignments d[1] +  = 1, d[2] +  = 2, ..., d[pi] +  = pi. Imagine we already preformed all the queries. Each value of new array d[] can be represented as d[i] = oldD[i] + i·coef[i], where coef[i] is the number of pj (pj > i).One can notice that array coef contains at most sqrt(q) distinct values, additionally this array can be splitted into O(sqrt(q)) parts such that all elements from the same part will be the same. This is the key observation. We will divide array coef into parts. And for each part will maintain lower envelope of the lines y = d[i] + i·x. So, we will have O(sqrt(q)) lower envelopes. Each envelope will help us to get maximum value among the segment of array d[i](oldD[i] + i·coef[i]). As for each i from some segment factor coef[i] is containt we can just pick y-coordinate with x = coef[i] of corresponding lower envelope.Described solution has time complexity of O(MAXX·sqrt(MAXX)), where MAXX is the maximum value among a[i] and b[i]. With best regards, Ivan.",
          "author": "Fefer_Ivan",
          "url": "https://codeforces.com/blog/entry/12680",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 436\\s*B"
          },
          "content_length": 7939
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 1",
          "code": "You may edit your comment only for fixing grammar mistakes or small changes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 2",
          "code": "Do not change the main idea of your comment.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 3",
          "code": "All previous revisions are available for others. Are you sure you want to edit comment?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 4",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 5",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 6",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 7",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 8",
          "code": "if(par[r] = r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 9",
          "code": "if(par[r] == r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 10",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 11",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 12",
          "code": "What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, m * (n - 1), \"k\");\n    inf.readEoln();\n\n    int total_spiders = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must contain exactly %d characters\", i + 1, m);\n\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '.' || c == 'L' || c == 'R' || c == 'U' || c == 'D',\n                    \"Invalid character '%c' in line %d column %d\", c, i + 1, j + 1);\n            if (i == 0) {\n                ensuref(c == '.', \"First row must not contain any spiders, but found '%c' in column %d\", c, j + 1);\n            }\n            if (c == 'L' || c == 'R' || c == 'U' || c == 'D') {\n                total_spiders++;\n            }\n        }\n    }\n\n    ensuref(total_spiders == k, \"Total number of spiders must be %d, but found %d\", k, total_spiders);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, m * (n - 1), \"k\");\n    inf.readEoln();\n\n    int total_spiders = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must contain exactly %d characters\", i + 1, m);\n\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '.' || c == 'L' || c == 'R' || c == 'U' || c == 'D',\n                    \"Invalid character '%c' in line %d column %d\", c, i + 1, j + 1);\n            if (i == 0) {\n                ensuref(c == '.', \"First row must not contain any spiders, but found '%c' in column %d\", c, j + 1);\n            }\n            if (c == 'L' || c == 'R' || c == 'U' || c == 'D') {\n                total_spiders++;\n            }\n        }\n    }\n\n    ensuref(total_spiders == k, \"Total number of spiders must be %d, but found %d\", k, total_spiders);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 2000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, m * (n - 1), \"k\");\n    inf.readEoln();\n\n    int total_spiders = 0;\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must contain exactly %d characters\", i + 1, m);\n\n        for (int j = 0; j < m; ++j) {\n            char c = s[j];\n            ensuref(c == '.' || c == 'L' || c == 'R' || c == 'U' || c == 'D',\n                    \"Invalid character '%c' in line %d column %d\", c, i + 1, j + 1);\n            if (i == 0) {\n                ensuref(c == '.', \"First row must not contain any spiders, but found '%c' in column %d\", c, j + 1);\n            }\n            if (c == 'L' || c == 'R' || c == 'U' || c == 'D') {\n                total_spiders++;\n            }\n        }\n    }\n\n    ensuref(total_spiders == k, \"Total number of spiders must be %d, but found %d\", k, total_spiders);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    int k = 0;\n    vector<string> grid(n, string(m, '.'));\n    \n    if (type == \"random\") {\n        string directions = \"LRUD\";\n        for (int i = 1; i < n; ++i) { // don't touch first row\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(2)) { // 50% chance to place a spider\n                    char dir = directions[rnd.next(4)];\n                    grid[i][j] = dir;\n                    ++k;\n                }\n            }\n        }\n    } else if (type == \"empty\") {\n        // Do nothing, grid is empty\n        k = 0;\n    } else if (type == \"full\") {\n        string directions = \"LRUD\";\n        for (int i = 1; i < n; ++i) { // don't touch first row\n            for (int j = 0; j < m; ++j) {\n                char dir = directions[rnd.next(4)];\n                grid[i][j] = dir;\n                ++k;\n            }\n        }\n    } else if (type == \"moving_up\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'U';\n                ++k;\n            }\n        }\n    } else if (type == \"moving_down\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'D';\n                ++k;\n            }\n        }\n    } else if (type == \"moving_left\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'L';\n                ++k;\n            }\n        }\n    } else if (type == \"moving_right\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'R';\n                ++k;\n            }\n        }\n    } else if (type == \"minimal\") {\n        // Minimal size test case\n        n = 2;\n        m = 2;\n        grid.assign(n, string(m, '.'));\n        // Place one spider in row 1 (second row)\n        grid[1][0] = 'D';\n        k = 1;\n    } else if (type == \"special1\") {\n        // Special test case where spiders meet Om Nom at different times\n        if (n < 4 || m < 4) {\n            n = max(n, 4);\n            m = max(m, 4);\n            grid.assign(n, string(m, '.'));\n        }\n        // Place spiders moving towards center\n        grid[1][m/2] = 'U'; // Spider moving up\n        grid[n-1][m/2] = 'D'; // Spider moving down\n        grid[n/2][1] = 'L'; // Spider moving left\n        grid[n/2][m-1] = 'R'; // Spider moving right\n        k = 4;\n    } else if (type == \"corner\") {\n        // Spiders move away from Om Nom, he never sees them\n        for (int i = 1; i < n; ++i) {\n            // Let's make spiders move down so Om Nom never meets them\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'D';\n                ++k;\n            }\n        }\n    }\n\n    // Output n m k\n    cout << n << \" \" << m << \" \" << k << \"\\n\";\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        cout << grid[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    int k = 0;\n    vector<string> grid(n, string(m, '.'));\n    \n    if (type == \"random\") {\n        string directions = \"LRUD\";\n        for (int i = 1; i < n; ++i) { // don't touch first row\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(2)) { // 50% chance to place a spider\n                    char dir = directions[rnd.next(4)];\n                    grid[i][j] = dir;\n                    ++k;\n                }\n            }\n        }\n    } else if (type == \"empty\") {\n        // Do nothing, grid is empty\n        k = 0;\n    } else if (type == \"full\") {\n        string directions = \"LRUD\";\n        for (int i = 1; i < n; ++i) { // don't touch first row\n            for (int j = 0; j < m; ++j) {\n                char dir = directions[rnd.next(4)];\n                grid[i][j] = dir;\n                ++k;\n            }\n        }\n    } else if (type == \"moving_up\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'U';\n                ++k;\n            }\n        }\n    } else if (type == \"moving_down\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'D';\n                ++k;\n            }\n        }\n    } else if (type == \"moving_left\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'L';\n                ++k;\n            }\n        }\n    } else if (type == \"moving_right\") {\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'R';\n                ++k;\n            }\n        }\n    } else if (type == \"minimal\") {\n        // Minimal size test case\n        n = 2;\n        m = 2;\n        grid.assign(n, string(m, '.'));\n        // Place one spider in row 1 (second row)\n        grid[1][0] = 'D';\n        k = 1;\n    } else if (type == \"special1\") {\n        // Special test case where spiders meet Om Nom at different times\n        if (n < 4 || m < 4) {\n            n = max(n, 4);\n            m = max(m, 4);\n            grid.assign(n, string(m, '.'));\n        }\n        // Place spiders moving towards center\n        grid[1][m/2] = 'U'; // Spider moving up\n        grid[n-1][m/2] = 'D'; // Spider moving down\n        grid[n/2][1] = 'L'; // Spider moving left\n        grid[n/2][m-1] = 'R'; // Spider moving right\n        k = 4;\n    } else if (type == \"corner\") {\n        // Spiders move away from Om Nom, he never sees them\n        for (int i = 1; i < n; ++i) {\n            // Let's make spiders move down so Om Nom never meets them\n            for (int j = 0; j < m; ++j) {\n                grid[i][j] = 'D';\n                ++k;\n            }\n        }\n    }\n\n    // Output n m k\n    cout << n << \" \" << m << \" \" << k << \"\\n\";\n    // Output grid\n    for (int i = 0; i < n; ++i) {\n        cout << grid[i] << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type minimal\n./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type full\n\n./gen -n 5 -m 5 -type random\n./gen -n 5 -m 5 -type moving_up\n./gen -n 5 -m 5 -type moving_down\n./gen -n 5 -m 5 -type moving_left\n./gen -n 5 -m 5 -type moving_right\n./gen -n 5 -m 5 -type corner\n./gen -n 5 -m 5 -type special1\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type full\n./gen -n 10 -m 10 -type empty\n./gen -n 10 -m 10 -type moving_up\n\n./gen -n 100 -m 100 -type random\n./gen -n 100 -m 100 -type moving_down\n./gen -n 100 -m 100 -type corner\n\n./gen -n 2000 -m 2000 -type random\n./gen -n 2000 -m 2000 -type full\n./gen -n 2000 -m 2000 -type empty\n\n./gen -n 2000 -m 2000 -type moving_up\n./gen -n 2000 -m 2000 -type moving_down\n./gen -n 2000 -m 2000 -type moving_left\n./gen -n 2000 -m 2000 -type moving_right\n\n./gen -n 2000 -m 2000 -type corner\n\n./gen -n 2000 -m 2000 -type special1\n\n./gen -n 2000 -m 2000 -type minimal\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 1000 -type full\n\n./gen -n 1000 -m 1000 -type moving_up\n\n./gen -n 1000 -m 1 -type moving_down\n\n./gen -n 2 -m 2000 -type moving_left\n\n./gen -n 2000 -m 2 -type moving_right\n\n./gen -n 500 -m 1000 -type random\n./gen -n 1000 -m 500 -type random\n\n./gen -n 2000 -m 2000 -type empty\n\n./gen -n 2 -m 2000 -type full\n./gen -n 2000 -m 2 -type full\n\n./gen -n 100 -m 2000 -type special1\n./gen -n 2000 -m 100 -type special1\n\n./gen -n 2000 -m 2000 -type corner\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:27:58.839166",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "436/C",
      "title": "C. Dungeons and Candies",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны четыре целых числа n, m, k, w (1 ≤ n, m ≤ 10; 1 ≤ k, w ≤ 1000). Далее следует описание k уровней. Каждый уровень описывается n строками, в каждой из которых записано m символов. Каждый символ — это либо буква латинского алфавита, либо точка («.»). Обратите внимание, что регистр букв имеет значение.",
      "output_spec": "Выходные данныеВ первой строке выведите искомое минимальное количество переданных байтов.Далее выведите k пар целых чисел x1, y1, x2, y2, ..., xk, yk, описывающих способ передачи уровней. Пара xi, yi обозначает, что уровень xi нужно передавать способом yi. Если yi равно 0, значит, уровень нужно передавать первым способом, иначе yi должно быть равно номеру ранее переданного уровня, разницу по сравнению с которым нужно передать, т. е. вы передадите уровень xi, передавая разницу между уровнями xi и yi. Пары выводите в порядке передачи уровней. Уровни пронумерованы от 1 до k в порядке их описания во входных данных.Если существует несколько оптимальных решений, разрешается вывести любое.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 3 3 2A.A...A.a..CX.Y...Выходные данныеСкопировать141 02 13 1Входные данныеСкопировать1 1 4 1A.B.Выходные данныеСкопировать31 02 04 23 0Входные данныеСкопировать1 3 5 2ABABBBBBABABABBВыходные данныеСкопировать111 03 12 34 25 1",
      "description": "C. Dungeons and Candies\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны четыре целых числа n, m, k, w (1 ≤ n, m ≤ 10; 1 ≤ k, w ≤ 1000). Далее следует описание k уровней. Каждый уровень описывается n строками, в каждой из которых записано m символов. Каждый символ — это либо буква латинского алфавита, либо точка («.»). Обратите внимание, что регистр букв имеет значение.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите искомое минимальное количество переданных байтов.Далее выведите k пар целых чисел x1, y1, x2, y2, ..., xk, yk, описывающих способ передачи уровней. Пара xi, yi обозначает, что уровень xi нужно передавать способом yi. Если yi равно 0, значит, уровень нужно передавать первым способом, иначе yi должно быть равно номеру ранее переданного уровня, разницу по сравнению с которым нужно передать, т. е. вы передадите уровень xi, передавая разницу между уровнями xi и yi. Пары выводите в порядке передачи уровней. Уровни пронумерованы от 1 до k в порядке их описания во входных данных.Если существует несколько оптимальных решений, разрешается вывести любое.\n\nВыходные данные\n\nВходные данныеСкопировать2 3 3 2A.A...A.a..CX.Y...Выходные данныеСкопировать141 02 13 1Входные данныеСкопировать1 1 4 1A.B.Выходные данныеСкопировать31 02 04 23 0Входные данныеСкопировать1 3 5 2ABABBBBBABABABBВыходные данныеСкопировать111 03 12 34 25 1\n\nВходные данныеСкопировать2 3 3 2A.A...A.a..CX.Y...\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать141 02 13 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1 4 1A.B.\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 02 04 23 0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 3 5 2ABABBBBBABABABB\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать111 03 12 34 25 1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces",
          "content": "Божественно кодить можно не только для разных поисковых систем, но и в индустрии видеоигр — и не где-нибудь, а прямо на родине. Если не верите, то компания ZeptoLab, создатель известной во всем мире игры Cut the Rope, дает вам возможность убедиться в этом лично. И да, мы находимся в Москве.Не секрет, что высот программирования достигают только те, кто много работает, в том числе — над собой и своим образованием. В ZeptoLab мы стараемся создать пространство, которое максимально к этому располагает. В частности, недавно у нас появилась корпоративная библиотека, где можно найти все необходимое для получения новых знаний, а также импровизированный читальный зал с диванами и креслами. Также мы устраиваем чемпионаты по разработке внутри компании, чтобы наши ЗептоПрограммисты могли в свое удовольствие порешать нетривиальные задачки и помериться с коллегами нулями и единицами. Победители получают славу, ценные подарки и именное оружие (шутим, не оружие). А с недавнего времени в Zeptolab открылась своя алгоритмическая школа, в которой преподает не кто иной, как создатель и руководитель всея Codeforces — Михаил Мирзаянов! Личность в девелоперских кругах немалоизвестная: Михаил уже тренировал команду, которая стала чемпионом мира по программированию, так что можно себе вообразить, какие горизонты развернулись перед разработчиками ZeptoLab и перед компанией в целом. В таком формате Михаил преподает впервые, в России и мире аналогов подобной системы корпоративного образования практически нет. Для нас алгоритмы играют существенную роль, ведь требования к разработке стоят довольно жесткие: приложение на таргет-устройстве в идеале должно выдавать 60 кадров в секунду, и все расчеты игровой логики надо производить очень быстро и предпочтительно с простой сложностью в противовес амортизированной. Кроме того, у нас есть возможность делать неслабый препроцессинг, перенося некоторые вычисления на этап подготовки ресурсов для игры. Понимание этих фактов, как и множества других — вот ключ к быстрой работе наших игр. По этой причине мы поддерживаем движение алгоритмистов.И впервые Зептолаб проводит конкурс по алгоритмической разработке, на базе Codeforces. Вас ждут нетривиальные задания, бескомпромиссная девелоперская борьба и крутые призы: Ну и чтобы добавить интриги: будет еще один приз: IPad Mini Retina мы вручим рандомно тому, кто попадет в ТОП-50 победителей конкурса и будет выбран вот так: мы просуммируем времена всех успешных попыток трех победителей (в секундах от начала контеста) и возьмем строчку с номером s % 47 + 4, где s — найденная сумма. Если вычисленная строка будет делить место, то приоритет будет у того, кто сдал последнюю из решенных задач раньше.И на сладенькое: у того, кто покажет неплохие результаты по конкурсу, будет возможность устроиться к нам по упрощенной схеме. Если тебе интересно попробовать себя в команде ZeptoLab — поставь соответствующую галочку при регистрации. О том, что такое работать у нас можно почитать тут: http://zeptoteam.ru/. Заинтересовались работой в ZeptoLab? Чемпионат будет проводиться в один раунд. Формат соревнования — по правилам Codeforces. Раунд будет рейтинговым и общим для обоих дивизионов.Дата и время проведения: 13 июня 2014, время: 19:30 — 22:00.Разбалловка задач: 1000-1000-1500-2500-2500-3000.Ура-ура! Соревнование завершено! Спасибо всем принявшим участие! Надеемся, что вам понравились задачи. Особые поздравления победителям соревнования: 1 место — KAN (Николай Калинин, Нижний Новгород) — iPad Air 2 место — winger (Владислав Исенбаев, США, Фейсбук) — iPad Mini 3 место — tourist (Геннадий Короткевич, Санкт-Петербург, ИТМО) — iPad Mini Все участники, занявшие места с 1-го по 30-е получат подарки: замечательного плюшего Ом Нома и сувенирную футболку, а участники с 31-го места по 50-е получат в подарок футболки чемпионата!Дополнительный приз достается участнику, занявшему 21-е место: package.zaic (Вадим Зайцев, Новосибирск, Новосибирский ГУ).",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/12605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3941
        },
        {
          "title": "Zepto Code Rush 2014 — решения - Codeforces",
          "content": "436A - Feed with CandyАвтор разбора: Fefer_IvanВ задача А типы съеденных конфет должны все время менятся. Так что первая съеденная конфета определяет тип всех последующих конфет. Возможных типа всего два, так что переберем тип первой съеденной конфеты. Пусть в какой-то момент времени Ом Ном должен съесть конфету типа t и может прыгать на высоту h. Очевидно, что наиболее выгодным решением будет съесть конфету с наибольшей массой среди всех конфет, которые Ом Ном может съесть на текущем этапе. Для решения задачи необходимо промоделировать процесс поедания конфет для начального h = x и t = [0, 1] и выбрать лучшее значение.436B - Om Nom and SpidersАвтор разбора: Fefer_IvanПронумеруем столбцы таблицы начиная с 0 слева направа, а строки начиная с 0 сверху вниз. Теперь заметим, что в момент времени t > 0 в клетке (x, y) могут находиться только 4 паука: Паук, который движется влево и в начале был в клетке (x, y + t). Паук, который движется вправо и в начале был в клетке (x, y - t). Паук, который движется вниз и в начале был в клетке (x - t, y). Паук, который движется вверх и в начале был в клетке (x + t, y). Давайте переберем столбец в котором Ом Ном начнет свой путь. Пусть это столбец y. В момент времени 0 все пауки стоят на своих исходных позициях, а Ом Ном стоит в клетке (0, y). Так как на нулевой строке нет пауков, то в момент времени 0 Ом Ном их точно не встречает. Когда Ом Ном находится в клетке (x, y), это значит, что с момента начала движения прошло x единиц времени. Следовательно, для того, чтобы вычислить сколько пауков Ом Ном встретим в этой клетке, необходимо проверить лишь 4 клетки, указанные выше, на наличие паука, движущегося в нужном направлении.436C - Dungeons and CandiesАвтор разбора: Fefer_IvanДавайте рассмотрим неориентированный взвешенный граф, в котором k + 1 вершина. Пронумеруем вершины целыми числами от 0 до k. Вершины c 1 по k будут соответствовать уровни. Для каждой пары уровней i и j добавим ребро из i в j стоимость которого равно стоимости передачи одного уровня как разность с другим. Так же для каждого уровня i добавим ребро между вершиной 0 и i стоимости n·m, т.е. стоимости передачи уровня целиком. Каждый способ передать все уровни соответсвует остовному дереву в указанном графе. Таким обзаром необходимо вывести минимальное остовное дерево в этом графе.436D - Pudding MonstersАвтор разбора: Fefer_IvanЗадача решается при помощи динамического программирования. Введем обозначения: sum(l, r) — количество особых клеток на отрезке с l по r, zi — максимальное количество особых клеток, которые можно покрыть, используя только первые i монстров при условии, что i-тый монстр либо остается на месте, либо отправляется влево, di--- максимальное количество особых клеток, которые можно покрыть, используя только первые i монстров при условии, что i-тый монстр остается на месте. Рассмотрим процесс вычисления di. Пусть i-тый монстр находится в клетке r. Переберем самую левую особую клетку, которая будет покрыта блоком монстров, в котором будет находиться i-й монстр. Пусть эта особая клетка находится в клетке l. Тогда нам требуется r - l дополнительных монстров отправить вправо для того, чтобы покрыть эту особую клетку. Тогда ответ будет равен zi - (r - l) + sum(l, r). Для вычисления di надо взять максимум по всем особым клеткам, левее i-того монстра.Теперь, после того, как мы вычислили очередное значение di, необходимо обновить некоторые значения zj. Пусть i-тый монстр находится в клетке l. Переберем самую правую особую клетку, которая будет покрыта блоком монстров, в котором будет находиться i-й монстр. Пусть эта особая клетка находится в клетке r. Тогда нам требуется r - l дополнительных монстров отправить влево для того, чтобы покрыть эту особую клетку. Тогда, zi + (r - l) можно обновить следующим значением di + sum(l + 1, r). Так же необходимо не забыть обновить значение zi значением zi - 1.Как можно видеть это решение имеет сложность O(n·m), так как для каждого из n монстров мы перебираем все m особых клеток, а все вычисления при фиксированной паре монстр-клетка проходят за O(1).При реализации могут возникнуть небольшие тонкости, связанные с монстрами, которые уже в начальном состоянии слиплись в один блок.436E - Cardboard BoxАвтор разбора: GeraldВ задаче E нужно было написать правильную жадность. Правильных жадностей существует несколько, вот одна из них: Посмотрим на некоторый оптимальный ответ (набор как-то пройденных уровней). Отсортируем все уровни по b[i]. Если рассмотреть последний взятый в ответ уровень, пройденный на 2 звезды, то окажется, что все находящиеся до него в таком порядке уровни пройдены хотя бы на одну звезду. Иначе, можно было бы заменить этот уровень на какой-то не пройденный и не увеличить ответ. Пользуясь вышесказанным, зафиксируем префикс L уровней в порядке сортировки по b[i]. Все уровни этого префикса мы должны хоть как-то пройти (либо на 1, либо на 2 звезды). Дополнительно, будет считать, что все уровни пройденные на 2 звезды должны содержаться только в этом префиксе (такой префикс должен существовать для некоторого оптимального ответа, как было показано ранее). Так как мы зафиксировали префикс длиной L уровней, которые мы точно хоть как-то пройдем, можно сказать, что нам осталось добрать w - L звезд. Как мы можем добирать эти звезды? Либо допроходить какие-то уровни из префикса L на 2 звезды, либо проходить уровни не из префикса L на одну (потому что уровни, которые мы проходим на 2 звезды должны содержаться только на зафиксированном префиксе). Понятно, что для того, чтобы получить оптимальный ответ нужно выбрать w - L самых дешевых звезд. Поэтому отсортируем n элементов: L чисел b[i] - a[i] (для всех i ≤ L), n - L чисел a[i] (для всех i > L). Выберем среди этих чисел w - L минимальных. Описанное нужно было реализовывать быстрее, чем за квадрат. Самая очевидная реализация использует декартово дерево, чуть менее очевидная использует дерево отрезков. Итоговая сложность решения: O(n log n).436F - BannersАвтор разбора: GeraldЗадача F была самой сложной задачей контеста. Чтобы лучше представить себе ее решение, можно перейти к геометрическому представлению задачи. Представим, что люди — это точки на плоскости Opc, тогда, то что требуется найти — для каждой прямой c = i, такую прямую p = j, что некоторая функция принимает максимальное значение. Под некоторой функцией понимается следующая: (количество точек не ниже прямой c = i умножить на w·i) плюс (количество точек ниже прямой c = i и не левее прямой p = j умножить на j).Будем двигать сканирующую прямую снизу вверх. Сначала рассматриваем c = 0, затем c = 1 и так далее. При этом для каждого p будем хранить величину d[p] — чему равен ответ на задачу при текущем c, если второй параметр будет равен p. Если у нас есть корректно посчитанный массив d[] и мы переходим от c к c + 1, как пересчитать этот массив для нового c?Посмотрим на всех людей, для которых хоть что-то поменяется, очевидно — это люди у которых b[i] = c. При текущем c они еще пользовались бесплатной версией, но после увеличения на 1, они перестанут ей пользоваться. Понятно, что каждый такой человек i модифицирует массив следующим образом: d[1] +  = 1, d[2] +  = 2, ..., d[b[i]] +  = b[i].Теперь можно переформулировать задачу в терминах структур данных. Есть два вида запросов: прибавить на префиксе возрастающую арифметическую прогрессию, узнать максимум среди всех элементов массива d. Один из способов решить такую задачу — корневая декомпозиция.Разобьем все запросы на группы по sqrt(q) штук, в каждой группе выделим отрезки, на которых к ячейке d[i] значение i прибавляется с одним и тем же коэффициентом. Для каждого такого отрезка построим нижнее огибающее множество прямых y = d[i] + i·x. Так как запросов в группе sqrt(q), то и отрезков будет O(sqrt(q)). Значит прибавление на префиксе и взятие максимума можно будет делать за O(sqrt(q)).Итоговая сложность решения: O(MAXX·sqrt(MAXX)), где MAXX — максимальное значение среди a[i] и b[i].",
          "author": "Fefer_Ivan",
          "url": "https://codeforces.com/blog/entry/12680",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 436\\s*C"
          },
          "content_length": 7921
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 1",
          "code": "You may edit your comment only for fixing grammar mistakes or small changes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 2",
          "code": "Do not change the main idea of your comment.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 3",
          "code": "All previous revisions are available for others. Are you sure you want to edit comment?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 4",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 5",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 6",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 7",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 8",
          "code": "if(par[r] = r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 9",
          "code": "if(par[r] == r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 10",
          "code": "3 1\n0 2 1\n0 3 1\n1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 11",
          "code": "3 1\n0 2 1\n0 3 1\n1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 12",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 13",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 14",
          "code": "What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readEoln();\n\n    for (int level = 1; level <= k; ++level) {\n        for (int line = 1; line <= n; ++line) {\n            string s = inf.readLine();\n            ensuref((int)s.length() == m, \"Line %d in level %d has length %d, expected %d\", line, level, (int)s.length(), m);\n            for (int i = 0; i < m; ++i) {\n                char c = s[i];\n                ensuref(c == '.' || ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'),\n                    \"Invalid character '%c' in level %d, line %d, position %d\", c, level, line, i + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readEoln();\n\n    for (int level = 1; level <= k; ++level) {\n        for (int line = 1; line <= n; ++line) {\n            string s = inf.readLine();\n            ensuref((int)s.length() == m, \"Line %d in level %d has length %d, expected %d\", line, level, (int)s.length(), m);\n            for (int i = 0; i < m; ++i) {\n                char c = s[i];\n                ensuref(c == '.' || ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'),\n                    \"Invalid character '%c' in level %d, line %d, position %d\", c, level, line, i + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000, \"k\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000, \"w\");\n    inf.readEoln();\n\n    for (int level = 1; level <= k; ++level) {\n        for (int line = 1; line <= n; ++line) {\n            string s = inf.readLine();\n            ensuref((int)s.length() == m, \"Line %d in level %d has length %d, expected %d\", line, level, (int)s.length(), m);\n            for (int i = 0; i < m; ++i) {\n                char c = s[i];\n                ensuref(c == '.' || ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'),\n                    \"Invalid character '%c' in level %d, line %d, position %d\", c, level, line, i + 1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 10;\nconst int MAXK = 1000;\n\nint n, m, k, w;\nvector<string> levels[MAXK];\nint total_levels;\nint level_size;\nint minimal_total_bytes;\n\nstruct Edge {\n    int u, v, weight;\n    bool operator<(const Edge& other) const {\n        return weight < other.weight;\n    }\n};\n\nint find_set(vector<int>& parent, int v) {\n    if (parent[v] == v)\n        return v;\n    return parent[v] = find_set(parent, parent[v]);\n}\n\nbool union_sets(vector<int>& parent, vector<int>& rank, int a, int b) {\n    a = find_set(parent, a);\n    b = find_set(parent, b);\n    if (a == b)\n        return false;\n    if (rank[a] < rank[b])\n        swap(a, b);\n    parent[b] = a;\n    if (rank[a] == rank[b])\n        rank[a]++;\n    return true;\n}\n\nint compute_diff(int idx1, int idx2) {\n    int diff = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (levels[idx1][i][j] != levels[idx2][i][j])\n                diff++;\n        }\n    }\n    return diff;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(); // Read n\n    m = inf.readInt(); // Read m\n    k = inf.readInt(); // Read k\n    w = inf.readInt(); // Read w\n\n    total_levels = k;\n    level_size = n * m;\n\n    // Read the levels\n    for (int lvl = 0; lvl < k; ++lvl) {\n        vector<string> level_data(n);\n        for (int i = 0; i < n; ++i) {\n            level_data[i] = inf.readToken();\n        }\n        levels[lvl] = level_data;\n    }\n\n    // Compute minimal total bytes using MST\n    vector<Edge> edges;\n    for (int i = 0; i < k; ++i) {\n        for (int j = i + 1; j < k; ++j) {\n            int diff = compute_diff(i, j);\n            int cost = diff * w;\n            if (cost < level_size) {\n                edges.push_back({i, j, cost});\n            } else {\n                edges.push_back({i, j, level_size});\n            }\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n\n    vector<int> parent(k), rank(k, 0);\n    for (int i = 0; i < k; ++i)\n        parent[i] = i;\n\n    int mst_total_cost = 0;\n    int components = k;\n    for (const Edge& e : edges) {\n        if (union_sets(parent, rank, e.u, e.v)) {\n            mst_total_cost += e.weight;\n            components--;\n            if (components == 1)\n                break;\n        }\n    }\n\n    // Add the cost of transmitting the first level\n    minimal_total_bytes = level_size + mst_total_cost;\n\n    // Read contestant's output\n    int cnt_total_bytes = ouf.readInt(1, INT_MAX, \"total_bytes\");\n\n    if (cnt_total_bytes > minimal_total_bytes) {\n        quitf(_wa, \"Total bytes is not minimal: participant has %d, minimal is %d\", cnt_total_bytes, minimal_total_bytes);\n    } else if (cnt_total_bytes < minimal_total_bytes) {\n        quitf(_fail, \"Participant's total bytes (%d) less than minimal total bytes (%d)\", cnt_total_bytes, minimal_total_bytes);\n    }\n\n    vector<bool> transferred(k, false);\n    vector<int> transfer_cost(k, -1);\n    vector<int> received_levels;\n    map<int, int> level_indices; // Maps level number to index in levels[]\n    for (int i = 0; i < k; ++i)\n        level_indices[i + 1] = i;\n\n    int cost_sum = 0;\n\n    for (int i = 0; i < k; ++i) {\n        int xi = ouf.readInt(1, k, format(\"x[%d]\", i + 1));\n        int yi = ouf.readInt(0, k, format(\"y[%d]\", i + 1));\n\n        int idx_xi = xi - 1;\n\n        if (transferred[idx_xi]) {\n            quitf(_wa, \"Level %d is transferred more than once\", xi);\n        }\n        transferred[idx_xi] = true;\n\n        if (yi == 0) {\n            // Transmit whole level\n            transfer_cost[idx_xi] = level_size;\n        } else {\n            int idx_yi = yi - 1;\n            if (!transferred[idx_yi]) {\n                quitf(_wa, \"Level %d is used for diff before it is transferred\", yi);\n            }\n            // Compute diff cost\n            int diff = compute_diff(idx_xi, idx_yi);\n            int diff_cost = diff * w;\n            if (diff_cost >= level_size) {\n                quitf(_wa, \"Cost of diff between levels %d and %d is not less than transmitting whole level\", xi, yi);\n            }\n            transfer_cost[idx_xi] = diff_cost;\n        }\n        cost_sum += transfer_cost[idx_xi];\n    }\n\n    if (cost_sum != cnt_total_bytes) {\n        quitf(_wa, \"Total cost mismatch: expected %d, got %d\", cnt_total_bytes, cost_sum);\n    }\n\n    quitf(_ok, \"Correct solution with minimal total bytes %d\", minimal_total_bytes);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar random_cell() {\n    int ch = rnd.next(0, 52); // 0 to 52 inclusive\n    if (ch == 0) {\n        return '.';\n    } else if (ch <= 26) {\n        return char('A' + ch - 1);\n    } else {\n        return char('a' + ch - 27);\n    }\n}\n\nvector<string> generate_random_level(int n, int m) {\n    vector<string> level(n);\n    for (int i = 0; i < n; ++i) {\n        level[i] = \"\";\n        for (int j = 0; j < m; ++j) {\n            level[i] += random_cell();\n        }\n    }\n    return level;\n}\n\nvoid change_one_cell(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    int x = rnd.next(0, n - 1);\n    int y = rnd.next(0, m - 1);\n\n    char new_cell;\n    do {\n        new_cell = random_cell();\n    } while (new_cell == level[x][y]);\n\n    level[x][y] = new_cell;\n}\n\nvoid change_case(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            char &c = level[i][j];\n            if (c >= 'a' && c <= 'z') {\n                c = 'A' + (c - 'a');\n            } else if (c >= 'A' && c <= 'Z') {\n                c = 'a' + (c - 'A');\n            }\n        }\n    }\n}\n\nvector<string> shift_level(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    int dx = rnd.next(1, n - 1);\n    int dy = rnd.next(1, m - 1);\n\n    vector<string> new_level(n, string(m, '.'));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int ni = (i + dx) % n;\n            int nj = (j + dy) % m;\n            new_level[ni][nj] = level[i][j];\n        }\n    }\n    return new_level;\n}\n\nvector<string> rotate_level(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    vector<string> new_level(m, string(n, '.'));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            new_level[j][n - 1 - i] = level[i][j];\n        }\n    }\n    return new_level;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int w = opt<int>(\"w\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<string>> levels(k);\n\n    if (type == \"identical\") {\n        vector<string> base_level = generate_random_level(n, m);\n        for (int i = 0; i < k; ++i) {\n            levels[i] = base_level;\n        }\n    } else if (type == \"differ_by_one\") {\n        levels[0] = generate_random_level(n, m);\n        for (int i = 1; i < k; ++i) {\n            levels[i] = levels[i - 1];\n            change_one_cell(levels[i]);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            levels[i] = generate_random_level(n, m);\n        }\n    } else if (type == \"random_case_sensitive\") {\n        vector<string> base_level = generate_random_level(n, m);\n        // make all letters lowercase\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                char &c = base_level[i][j];\n                if (c >= 'A' && c <= 'Z') {\n                    c = 'a' + (c - 'A');\n                }\n            }\n        }\n        levels[0] = base_level;\n        for (int i = 1; i < k; ++i) {\n            levels[i] = levels[i - 1];\n            // Change the case of some letters\n            int num_changes = rnd.next(1, n * m);\n            for (int t = 0; t < num_changes; ++t) {\n                int x = rnd.next(0, n - 1);\n                int y = rnd.next(0, m - 1);\n                char &c = levels[i][x][y];\n                if (c >= 'a' && c <= 'z') {\n                    c = 'A' + (c - 'a');\n                } else if (c >= 'A' && c <= 'Z') {\n                    c = 'a' + (c - 'A');\n                }\n            }\n        }\n    } else if (type == \"maximally_different\") {\n        for (int i = 0; i < k; ++i) {\n            levels[i] = generate_random_level(n, m);\n        }\n    } else if (type == \"shift_rotated_levels\") {\n        vector<string> base_level = generate_random_level(n, m);\n        for (int i = 0; i < k; ++i) {\n            int op = rnd.next(0, 1);\n            if (op == 0) {\n                // Shift\n                levels[i] = shift_level(base_level);\n            } else {\n                // Rotate\n                levels[i] = rotate_level(base_level);\n            }\n        }\n    } else {\n        // Type not recognized\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n, m, k, w\n    printf(\"%d %d %d %d\\n\", n, m, k, w);\n\n    // Output levels\n    for (int l = 0; l < k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", levels[l][i].c_str());\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nchar random_cell() {\n    int ch = rnd.next(0, 52); // 0 to 52 inclusive\n    if (ch == 0) {\n        return '.';\n    } else if (ch <= 26) {\n        return char('A' + ch - 1);\n    } else {\n        return char('a' + ch - 27);\n    }\n}\n\nvector<string> generate_random_level(int n, int m) {\n    vector<string> level(n);\n    for (int i = 0; i < n; ++i) {\n        level[i] = \"\";\n        for (int j = 0; j < m; ++j) {\n            level[i] += random_cell();\n        }\n    }\n    return level;\n}\n\nvoid change_one_cell(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    int x = rnd.next(0, n - 1);\n    int y = rnd.next(0, m - 1);\n\n    char new_cell;\n    do {\n        new_cell = random_cell();\n    } while (new_cell == level[x][y]);\n\n    level[x][y] = new_cell;\n}\n\nvoid change_case(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            char &c = level[i][j];\n            if (c >= 'a' && c <= 'z') {\n                c = 'A' + (c - 'a');\n            } else if (c >= 'A' && c <= 'Z') {\n                c = 'a' + (c - 'A');\n            }\n        }\n    }\n}\n\nvector<string> shift_level(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    int dx = rnd.next(1, n - 1);\n    int dy = rnd.next(1, m - 1);\n\n    vector<string> new_level(n, string(m, '.'));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            int ni = (i + dx) % n;\n            int nj = (j + dy) % m;\n            new_level[ni][nj] = level[i][j];\n        }\n    }\n    return new_level;\n}\n\nvector<string> rotate_level(vector<string> &level) {\n    int n = level.size();\n    int m = level[0].size();\n\n    vector<string> new_level(m, string(n, '.'));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            new_level[j][n - 1 - i] = level[i][j];\n        }\n    }\n    return new_level;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int w = opt<int>(\"w\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<vector<string>> levels(k);\n\n    if (type == \"identical\") {\n        vector<string> base_level = generate_random_level(n, m);\n        for (int i = 0; i < k; ++i) {\n            levels[i] = base_level;\n        }\n    } else if (type == \"differ_by_one\") {\n        levels[0] = generate_random_level(n, m);\n        for (int i = 1; i < k; ++i) {\n            levels[i] = levels[i - 1];\n            change_one_cell(levels[i]);\n        }\n    } else if (type == \"random\") {\n        for (int i = 0; i < k; ++i) {\n            levels[i] = generate_random_level(n, m);\n        }\n    } else if (type == \"random_case_sensitive\") {\n        vector<string> base_level = generate_random_level(n, m);\n        // make all letters lowercase\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                char &c = base_level[i][j];\n                if (c >= 'A' && c <= 'Z') {\n                    c = 'a' + (c - 'A');\n                }\n            }\n        }\n        levels[0] = base_level;\n        for (int i = 1; i < k; ++i) {\n            levels[i] = levels[i - 1];\n            // Change the case of some letters\n            int num_changes = rnd.next(1, n * m);\n            for (int t = 0; t < num_changes; ++t) {\n                int x = rnd.next(0, n - 1);\n                int y = rnd.next(0, m - 1);\n                char &c = levels[i][x][y];\n                if (c >= 'a' && c <= 'z') {\n                    c = 'A' + (c - 'a');\n                } else if (c >= 'A' && c <= 'Z') {\n                    c = 'a' + (c - 'A');\n                }\n            }\n        }\n    } else if (type == \"maximally_different\") {\n        for (int i = 0; i < k; ++i) {\n            levels[i] = generate_random_level(n, m);\n        }\n    } else if (type == \"shift_rotated_levels\") {\n        vector<string> base_level = generate_random_level(n, m);\n        for (int i = 0; i < k; ++i) {\n            int op = rnd.next(0, 1);\n            if (op == 0) {\n                // Shift\n                levels[i] = shift_level(base_level);\n            } else {\n                // Rotate\n                levels[i] = rotate_level(base_level);\n            }\n        }\n    } else {\n        // Type not recognized\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    // Output n, m, k, w\n    printf(\"%d %d %d %d\\n\", n, m, k, w);\n\n    // Output levels\n    for (int l = 0; l < k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            printf(\"%s\\n\", levels[l][i].c_str());\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -w 1 -type identical\n./gen -n 1 -m 1 -k 1000 -w 1000 -type identical\n./gen -n 2 -m 3 -k 5 -w 2 -type differ_by_one\n./gen -n 5 -m 5 -k 100 -w 500 -type differ_by_one\n./gen -n 10 -m 10 -k 1000 -w 1000 -type differ_by_one\n./gen -n 10 -m 10 -k 1000 -w 1000 -type random\n./gen -n 5 -m 7 -k 500 -w 100 -type random\n./gen -n 10 -m 10 -k 1000 -w 1000 -type maximally_different\n./gen -n 1 -m 10 -k 200 -w 50 -type maximally_different\n./gen -n 3 -m 3 -k 20 -w 10 -type shift_rotated_levels\n./gen -n 6 -m 6 -k 30 -w 15 -type shift_rotated_levels\n./gen -n 10 -m 10 -k 50 -w 1 -type random_case_sensitive\n./gen -n 2 -m 2 -k 10 -w 10 -type random_case_sensitive\n./gen -n 10 -m 10 -k 1000 -w 1000 -type random_case_sensitive\n./gen -n 1 -m 10 -k 10 -w 1 -type identical\n./gen -n 5 -m 5 -k 10 -w 1 -type identical\n./gen -n 10 -m 1 -k 100 -w 1000 -type differ_by_one\n./gen -n 4 -m 6 -k 500 -w 500 -type differ_by_one\n./gen -n 7 -m 7 -k 200 -w 300 -type random\n./gen -n 10 -m 10 -k 1000 -w 1000 -type random\n./gen -n 10 -m 10 -k 1000 -w 1 -type maximally_different\n./gen -n 2 -m 5 -k 100 -w 50 -type maximally_different\n./gen -n 5 -m 5 -k 200 -w 200 -type shift_rotated_levels\n./gen -n 3 -m 7 -k 50 -w 20 -type shift_rotated_levels\n./gen -n 1 -m 1 -k 500 -w 500 -type random_case_sensitive\n./gen -n 9 -m 9 -k 300 -w 300 -type random_case_sensitive\n./gen -n 10 -m 10 -k 1000 -w 1000 -type random_case_sensitive\n./gen -n 2 -m 2 -k 4 -w 1 -type identical\n./gen -n 3 -m 3 -k 3 -w 1 -type identical\n./gen -n 1 -m 10 -k 5 -w 2 -type differ_by_one\n./gen -n 10 -m 1 -k 5 -w 2 -type differ_by_one\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:00.994941",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "436/D",
      "title": "D. Pudding Monsters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и m (1 ≤ n ≤ 105; 1 ≤ m ≤ 2000) — количество монстров на полоске и количество особенных клеток.Во второй строке записаны n различных целых чисел — номера клеток с монстрами, в третьей строке записаны m различных целых чисел — номера особенных клеток. Гарантируется, что все номера клеток целые положительные числа не превышающие 2·105.",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальное количество особых клеток, которое можно занять монстрами.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 21 3 52 4Выходные данныеСкопировать2Входные данныеСкопировать4 21 3 4 62 5Выходные данныеСкопировать2Входные данныеСкопировать4 21 8 4 57 2Выходные данныеСкопировать1",
      "description": "D. Pudding Monsters\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и m (1 ≤ n ≤ 105; 1 ≤ m ≤ 2000) — количество монстров на полоске и количество особенных клеток.Во второй строке записаны n различных целых чисел — номера клеток с монстрами, в третьей строке записаны m различных целых чисел — номера особенных клеток. Гарантируется, что все номера клеток целые положительные числа не превышающие 2·105.\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальное количество особых клеток, которое можно занять монстрами.\n\nВыходные данные\n\nВходные данныеСкопировать3 21 3 52 4Выходные данныеСкопировать2Входные данныеСкопировать4 21 3 4 62 5Выходные данныеСкопировать2Входные данныеСкопировать4 21 8 4 57 2Выходные данныеСкопировать1\n\nВходные данныеСкопировать3 21 3 52 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 21 3 4 62 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 21 8 4 57 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces",
          "content": "Божественно кодить можно не только для разных поисковых систем, но и в индустрии видеоигр — и не где-нибудь, а прямо на родине. Если не верите, то компания ZeptoLab, создатель известной во всем мире игры Cut the Rope, дает вам возможность убедиться в этом лично. И да, мы находимся в Москве.Не секрет, что высот программирования достигают только те, кто много работает, в том числе — над собой и своим образованием. В ZeptoLab мы стараемся создать пространство, которое максимально к этому располагает. В частности, недавно у нас появилась корпоративная библиотека, где можно найти все необходимое для получения новых знаний, а также импровизированный читальный зал с диванами и креслами. Также мы устраиваем чемпионаты по разработке внутри компании, чтобы наши ЗептоПрограммисты могли в свое удовольствие порешать нетривиальные задачки и помериться с коллегами нулями и единицами. Победители получают славу, ценные подарки и именное оружие (шутим, не оружие). А с недавнего времени в Zeptolab открылась своя алгоритмическая школа, в которой преподает не кто иной, как создатель и руководитель всея Codeforces — Михаил Мирзаянов! Личность в девелоперских кругах немалоизвестная: Михаил уже тренировал команду, которая стала чемпионом мира по программированию, так что можно себе вообразить, какие горизонты развернулись перед разработчиками ZeptoLab и перед компанией в целом. В таком формате Михаил преподает впервые, в России и мире аналогов подобной системы корпоративного образования практически нет. Для нас алгоритмы играют существенную роль, ведь требования к разработке стоят довольно жесткие: приложение на таргет-устройстве в идеале должно выдавать 60 кадров в секунду, и все расчеты игровой логики надо производить очень быстро и предпочтительно с простой сложностью в противовес амортизированной. Кроме того, у нас есть возможность делать неслабый препроцессинг, перенося некоторые вычисления на этап подготовки ресурсов для игры. Понимание этих фактов, как и множества других — вот ключ к быстрой работе наших игр. По этой причине мы поддерживаем движение алгоритмистов.И впервые Зептолаб проводит конкурс по алгоритмической разработке, на базе Codeforces. Вас ждут нетривиальные задания, бескомпромиссная девелоперская борьба и крутые призы: Ну и чтобы добавить интриги: будет еще один приз: IPad Mini Retina мы вручим рандомно тому, кто попадет в ТОП-50 победителей конкурса и будет выбран вот так: мы просуммируем времена всех успешных попыток трех победителей (в секундах от начала контеста) и возьмем строчку с номером s % 47 + 4, где s — найденная сумма. Если вычисленная строка будет делить место, то приоритет будет у того, кто сдал последнюю из решенных задач раньше.И на сладенькое: у того, кто покажет неплохие результаты по конкурсу, будет возможность устроиться к нам по упрощенной схеме. Если тебе интересно попробовать себя в команде ZeptoLab — поставь соответствующую галочку при регистрации. О том, что такое работать у нас можно почитать тут: http://zeptoteam.ru/. Заинтересовались работой в ZeptoLab? Чемпионат будет проводиться в один раунд. Формат соревнования — по правилам Codeforces. Раунд будет рейтинговым и общим для обоих дивизионов.Дата и время проведения: 13 июня 2014, время: 19:30 — 22:00.Разбалловка задач: 1000-1000-1500-2500-2500-3000.Ура-ура! Соревнование завершено! Спасибо всем принявшим участие! Надеемся, что вам понравились задачи. Особые поздравления победителям соревнования: 1 место — KAN (Николай Калинин, Нижний Новгород) — iPad Air 2 место — winger (Владислав Исенбаев, США, Фейсбук) — iPad Mini 3 место — tourist (Геннадий Короткевич, Санкт-Петербург, ИТМО) — iPad Mini Все участники, занявшие места с 1-го по 30-е получат подарки: замечательного плюшего Ом Нома и сувенирную футболку, а участники с 31-го места по 50-е получат в подарок футболки чемпионата!Дополнительный приз достается участнику, занявшему 21-е место: package.zaic (Вадим Зайцев, Новосибирск, Новосибирский ГУ).",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/12605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3941
        },
        {
          "title": "Zepto Code Rush 2014 — решения - Codeforces",
          "content": "436A - Feed with CandyАвтор разбора: Fefer_IvanВ задача А типы съеденных конфет должны все время менятся. Так что первая съеденная конфета определяет тип всех последующих конфет. Возможных типа всего два, так что переберем тип первой съеденной конфеты. Пусть в какой-то момент времени Ом Ном должен съесть конфету типа t и может прыгать на высоту h. Очевидно, что наиболее выгодным решением будет съесть конфету с наибольшей массой среди всех конфет, которые Ом Ном может съесть на текущем этапе. Для решения задачи необходимо промоделировать процесс поедания конфет для начального h = x и t = [0, 1] и выбрать лучшее значение.436B - Om Nom and SpidersАвтор разбора: Fefer_IvanПронумеруем столбцы таблицы начиная с 0 слева направа, а строки начиная с 0 сверху вниз. Теперь заметим, что в момент времени t > 0 в клетке (x, y) могут находиться только 4 паука: Паук, который движется влево и в начале был в клетке (x, y + t). Паук, который движется вправо и в начале был в клетке (x, y - t). Паук, который движется вниз и в начале был в клетке (x - t, y). Паук, который движется вверх и в начале был в клетке (x + t, y). Давайте переберем столбец в котором Ом Ном начнет свой путь. Пусть это столбец y. В момент времени 0 все пауки стоят на своих исходных позициях, а Ом Ном стоит в клетке (0, y). Так как на нулевой строке нет пауков, то в момент времени 0 Ом Ном их точно не встречает. Когда Ом Ном находится в клетке (x, y), это значит, что с момента начала движения прошло x единиц времени. Следовательно, для того, чтобы вычислить сколько пауков Ом Ном встретим в этой клетке, необходимо проверить лишь 4 клетки, указанные выше, на наличие паука, движущегося в нужном направлении.436C - Dungeons and CandiesАвтор разбора: Fefer_IvanДавайте рассмотрим неориентированный взвешенный граф, в котором k + 1 вершина. Пронумеруем вершины целыми числами от 0 до k. Вершины c 1 по k будут соответствовать уровни. Для каждой пары уровней i и j добавим ребро из i в j стоимость которого равно стоимости передачи одного уровня как разность с другим. Так же для каждого уровня i добавим ребро между вершиной 0 и i стоимости n·m, т.е. стоимости передачи уровня целиком. Каждый способ передать все уровни соответсвует остовному дереву в указанном графе. Таким обзаром необходимо вывести минимальное остовное дерево в этом графе.436D - Pudding MonstersАвтор разбора: Fefer_IvanЗадача решается при помощи динамического программирования. Введем обозначения: sum(l, r) — количество особых клеток на отрезке с l по r, zi — максимальное количество особых клеток, которые можно покрыть, используя только первые i монстров при условии, что i-тый монстр либо остается на месте, либо отправляется влево, di--- максимальное количество особых клеток, которые можно покрыть, используя только первые i монстров при условии, что i-тый монстр остается на месте. Рассмотрим процесс вычисления di. Пусть i-тый монстр находится в клетке r. Переберем самую левую особую клетку, которая будет покрыта блоком монстров, в котором будет находиться i-й монстр. Пусть эта особая клетка находится в клетке l. Тогда нам требуется r - l дополнительных монстров отправить вправо для того, чтобы покрыть эту особую клетку. Тогда ответ будет равен zi - (r - l) + sum(l, r). Для вычисления di надо взять максимум по всем особым клеткам, левее i-того монстра.Теперь, после того, как мы вычислили очередное значение di, необходимо обновить некоторые значения zj. Пусть i-тый монстр находится в клетке l. Переберем самую правую особую клетку, которая будет покрыта блоком монстров, в котором будет находиться i-й монстр. Пусть эта особая клетка находится в клетке r. Тогда нам требуется r - l дополнительных монстров отправить влево для того, чтобы покрыть эту особую клетку. Тогда, zi + (r - l) можно обновить следующим значением di + sum(l + 1, r). Так же необходимо не забыть обновить значение zi значением zi - 1.Как можно видеть это решение имеет сложность O(n·m), так как для каждого из n монстров мы перебираем все m особых клеток, а все вычисления при фиксированной паре монстр-клетка проходят за O(1).При реализации могут возникнуть небольшие тонкости, связанные с монстрами, которые уже в начальном состоянии слиплись в один блок.436E - Cardboard BoxАвтор разбора: GeraldВ задаче E нужно было написать правильную жадность. Правильных жадностей существует несколько, вот одна из них: Посмотрим на некоторый оптимальный ответ (набор как-то пройденных уровней). Отсортируем все уровни по b[i]. Если рассмотреть последний взятый в ответ уровень, пройденный на 2 звезды, то окажется, что все находящиеся до него в таком порядке уровни пройдены хотя бы на одну звезду. Иначе, можно было бы заменить этот уровень на какой-то не пройденный и не увеличить ответ. Пользуясь вышесказанным, зафиксируем префикс L уровней в порядке сортировки по b[i]. Все уровни этого префикса мы должны хоть как-то пройти (либо на 1, либо на 2 звезды). Дополнительно, будет считать, что все уровни пройденные на 2 звезды должны содержаться только в этом префиксе (такой префикс должен существовать для некоторого оптимального ответа, как было показано ранее). Так как мы зафиксировали префикс длиной L уровней, которые мы точно хоть как-то пройдем, можно сказать, что нам осталось добрать w - L звезд. Как мы можем добирать эти звезды? Либо допроходить какие-то уровни из префикса L на 2 звезды, либо проходить уровни не из префикса L на одну (потому что уровни, которые мы проходим на 2 звезды должны содержаться только на зафиксированном префиксе). Понятно, что для того, чтобы получить оптимальный ответ нужно выбрать w - L самых дешевых звезд. Поэтому отсортируем n элементов: L чисел b[i] - a[i] (для всех i ≤ L), n - L чисел a[i] (для всех i > L). Выберем среди этих чисел w - L минимальных. Описанное нужно было реализовывать быстрее, чем за квадрат. Самая очевидная реализация использует декартово дерево, чуть менее очевидная использует дерево отрезков. Итоговая сложность решения: O(n log n).436F - BannersАвтор разбора: GeraldЗадача F была самой сложной задачей контеста. Чтобы лучше представить себе ее решение, можно перейти к геометрическому представлению задачи. Представим, что люди — это точки на плоскости Opc, тогда, то что требуется найти — для каждой прямой c = i, такую прямую p = j, что некоторая функция принимает максимальное значение. Под некоторой функцией понимается следующая: (количество точек не ниже прямой c = i умножить на w·i) плюс (количество точек ниже прямой c = i и не левее прямой p = j умножить на j).Будем двигать сканирующую прямую снизу вверх. Сначала рассматриваем c = 0, затем c = 1 и так далее. При этом для каждого p будем хранить величину d[p] — чему равен ответ на задачу при текущем c, если второй параметр будет равен p. Если у нас есть корректно посчитанный массив d[] и мы переходим от c к c + 1, как пересчитать этот массив для нового c?Посмотрим на всех людей, для которых хоть что-то поменяется, очевидно — это люди у которых b[i] = c. При текущем c они еще пользовались бесплатной версией, но после увеличения на 1, они перестанут ей пользоваться. Понятно, что каждый такой человек i модифицирует массив следующим образом: d[1] +  = 1, d[2] +  = 2, ..., d[b[i]] +  = b[i].Теперь можно переформулировать задачу в терминах структур данных. Есть два вида запросов: прибавить на префиксе возрастающую арифметическую прогрессию, узнать максимум среди всех элементов массива d. Один из способов решить такую задачу — корневая декомпозиция.Разобьем все запросы на группы по sqrt(q) штук, в каждой группе выделим отрезки, на которых к ячейке d[i] значение i прибавляется с одним и тем же коэффициентом. Для каждого такого отрезка построим нижнее огибающее множество прямых y = d[i] + i·x. Так как запросов в группе sqrt(q), то и отрезков будет O(sqrt(q)). Значит прибавление на префиксе и взятие максимума можно будет делать за O(sqrt(q)).Итоговая сложность решения: O(MAXX·sqrt(MAXX)), где MAXX — максимальное значение среди a[i] и b[i].",
          "author": "Fefer_Ivan",
          "url": "https://codeforces.com/blog/entry/12680",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 436\\s*D"
          },
          "content_length": 7921
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 1",
          "code": "You may edit your comment only for fixing grammar mistakes or small changes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 2",
          "code": "Do not change the main idea of your comment.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 3",
          "code": "All previous revisions are available for others. Are you sure you want to edit comment?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 4",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 5",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 6",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 7",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 8",
          "code": "if(par[r] = r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 9",
          "code": "if(par[r] == r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 10",
          "code": "3 1\n0 2 1\n0 3 1\n1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 11",
          "code": "3 1\n0 2 1\n0 3 1\n1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 12",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 13",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 14",
          "code": "What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    // Read n distinct integers for the monster cells\n    vector<int> monster_cells = inf.readInts(n, 1, 200000, \"monster_cells\");\n    inf.readEoln();\n\n    // Ensure monster cells are distinct\n    {\n        vector<int> tmp = monster_cells;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < n; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"Monster cells must be distinct\");\n        }\n    }\n\n    // Read m distinct integers for the special cells\n    vector<int> special_cells = inf.readInts(m, 1, 200000, \"special_cells\");\n    inf.readEoln();\n\n    // Ensure special cells are distinct\n    {\n        vector<int> tmp = special_cells;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < m; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"Special cells must be distinct\");\n        }\n    }\n\n    // End of file\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    // Read n distinct integers for the monster cells\n    vector<int> monster_cells = inf.readInts(n, 1, 200000, \"monster_cells\");\n    inf.readEoln();\n\n    // Ensure monster cells are distinct\n    {\n        vector<int> tmp = monster_cells;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < n; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"Monster cells must be distinct\");\n        }\n    }\n\n    // Read m distinct integers for the special cells\n    vector<int> special_cells = inf.readInts(m, 1, 200000, \"special_cells\");\n    inf.readEoln();\n\n    // Ensure special cells are distinct\n    {\n        vector<int> tmp = special_cells;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < m; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"Special cells must be distinct\");\n        }\n    }\n\n    // End of file\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and m\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    // Read n distinct integers for the monster cells\n    vector<int> monster_cells = inf.readInts(n, 1, 200000, \"monster_cells\");\n    inf.readEoln();\n\n    // Ensure monster cells are distinct\n    {\n        vector<int> tmp = monster_cells;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < n; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"Monster cells must be distinct\");\n        }\n    }\n\n    // Read m distinct integers for the special cells\n    vector<int> special_cells = inf.readInts(m, 1, 200000, \"special_cells\");\n    inf.readEoln();\n\n    // Ensure special cells are distinct\n    {\n        vector<int> tmp = special_cells;\n        sort(tmp.begin(), tmp.end());\n        for (int i = 1; i < m; i++) {\n            ensuref(tmp[i] != tmp[i - 1], \"Special cells must be distinct\");\n        }\n    }\n\n    // End of file\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m does not exceed 2000\n    m = min(m, 2000);\n    // Ensure n is at least 1\n    n = max(n, 1);\n    // Ensure m is at least 1\n    m = max(m, 1);\n\n    vector<int> monster_positions;\n    vector<int> special_positions;\n\n    if (type == \"min_values\") {\n        // n=1, m=1, positions = 1\n        monster_positions.push_back(1);\n        special_positions.push_back(1);\n    } else if (type == \"max_values\") {\n        // n=1e5, m=2000, positions = 2e5\n        n = 100000;\n        m = 2000;\n        monster_positions.resize(n);\n        for (int i = 0; i < n; ++i)\n            monster_positions[i] = 200000 - i; // Decreasing positions\n        special_positions.resize(m);\n        for (int i = 0; i < m; ++i)\n            special_positions[i] = 200000 - n - i; // Positions less than monsters'\n    } else if (type == \"all_special\") {\n        // All monster positions are special cells\n        n = min(n, m);\n        monster_positions.resize(n);\n        special_positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int pos = i + 1;\n            monster_positions[i] = pos;\n            special_positions[i] = pos;\n        }\n    } else if (type == \"no_special\") {\n        // No monster positions are special cells\n        monster_positions.resize(n);\n        special_positions.resize(m);\n        for (int i = 0; i < n; ++i) {\n            monster_positions[i] = i + 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            special_positions[i] = n + i + 1; // positions after monsters\n        }\n    } else if (type == \"random\") {\n        // Generate random positions\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    } else if (type == \"max_m\") {\n        // m is maximum\n        m = 2000;\n        monster_positions.resize(n);\n        special_positions.resize(m);\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    } else if (type == \"clustered\") {\n        // Monsters clustered in one area, special cells elsewhere\n        int base_pos = rnd.next(1, 10000);\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(base_pos + rnd.next(0, n * 2));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(100001, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    } else if (type == \"scattered\") {\n        // Monsters and special cells randomly scattered\n        set<int> positions;\n        while ((int)positions.size() < n + m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        auto it = positions.begin();\n        for (int i = 0; i < n; ++i, ++it) {\n            monster_positions.push_back(*it);\n        }\n        for (int i = 0; i < m; ++i, ++it) {\n            special_positions.push_back(*it);\n        }\n    } else if (type == \"overlap\") {\n        // Monsters and special cells share positions\n        n = min(n, m);\n        m = n;\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        special_positions = monster_positions;\n    } else if (type == \"max_monsters\") {\n        // n maximum, m small\n        n = 100000;\n        monster_positions.resize(n);\n        int base_pos = 100000;\n        for (int i = 0; i < n; ++i) {\n            monster_positions[i] = base_pos + i;\n        }\n        special_positions.resize(m);\n        for (int i = 0; i < m; ++i) {\n            special_positions[i] = base_pos + n + i;\n        }\n    } else if (type == \"max_monsters_overlap\") {\n        // n maximum, m small, overlapping positions\n        n = 100000;\n        m = min(m, 2000);\n        monster_positions.resize(n);\n        int base_pos = 100000;\n        for (int i = 0; i < n; ++i) {\n            monster_positions[i] = base_pos + i;\n        }\n        special_positions.resize(m);\n        for (int i = 0; i < m; ++i) {\n            special_positions[i] = base_pos + i;\n        }\n    } else {\n        // Default to random\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", monster_positions[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", special_positions[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure m does not exceed 2000\n    m = min(m, 2000);\n    // Ensure n is at least 1\n    n = max(n, 1);\n    // Ensure m is at least 1\n    m = max(m, 1);\n\n    vector<int> monster_positions;\n    vector<int> special_positions;\n\n    if (type == \"min_values\") {\n        // n=1, m=1, positions = 1\n        monster_positions.push_back(1);\n        special_positions.push_back(1);\n    } else if (type == \"max_values\") {\n        // n=1e5, m=2000, positions = 2e5\n        n = 100000;\n        m = 2000;\n        monster_positions.resize(n);\n        for (int i = 0; i < n; ++i)\n            monster_positions[i] = 200000 - i; // Decreasing positions\n        special_positions.resize(m);\n        for (int i = 0; i < m; ++i)\n            special_positions[i] = 200000 - n - i; // Positions less than monsters'\n    } else if (type == \"all_special\") {\n        // All monster positions are special cells\n        n = min(n, m);\n        monster_positions.resize(n);\n        special_positions.resize(n);\n        for (int i = 0; i < n; ++i) {\n            int pos = i + 1;\n            monster_positions[i] = pos;\n            special_positions[i] = pos;\n        }\n    } else if (type == \"no_special\") {\n        // No monster positions are special cells\n        monster_positions.resize(n);\n        special_positions.resize(m);\n        for (int i = 0; i < n; ++i) {\n            monster_positions[i] = i + 1;\n        }\n        for (int i = 0; i < m; ++i) {\n            special_positions[i] = n + i + 1; // positions after monsters\n        }\n    } else if (type == \"random\") {\n        // Generate random positions\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    } else if (type == \"max_m\") {\n        // m is maximum\n        m = 2000;\n        monster_positions.resize(n);\n        special_positions.resize(m);\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    } else if (type == \"clustered\") {\n        // Monsters clustered in one area, special cells elsewhere\n        int base_pos = rnd.next(1, 10000);\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(base_pos + rnd.next(0, n * 2));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(100001, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    } else if (type == \"scattered\") {\n        // Monsters and special cells randomly scattered\n        set<int> positions;\n        while ((int)positions.size() < n + m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        auto it = positions.begin();\n        for (int i = 0; i < n; ++i, ++it) {\n            monster_positions.push_back(*it);\n        }\n        for (int i = 0; i < m; ++i, ++it) {\n            special_positions.push_back(*it);\n        }\n    } else if (type == \"overlap\") {\n        // Monsters and special cells share positions\n        n = min(n, m);\n        m = n;\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        special_positions = monster_positions;\n    } else if (type == \"max_monsters\") {\n        // n maximum, m small\n        n = 100000;\n        monster_positions.resize(n);\n        int base_pos = 100000;\n        for (int i = 0; i < n; ++i) {\n            monster_positions[i] = base_pos + i;\n        }\n        special_positions.resize(m);\n        for (int i = 0; i < m; ++i) {\n            special_positions[i] = base_pos + n + i;\n        }\n    } else if (type == \"max_monsters_overlap\") {\n        // n maximum, m small, overlapping positions\n        n = 100000;\n        m = min(m, 2000);\n        monster_positions.resize(n);\n        int base_pos = 100000;\n        for (int i = 0; i < n; ++i) {\n            monster_positions[i] = base_pos + i;\n        }\n        special_positions.resize(m);\n        for (int i = 0; i < m; ++i) {\n            special_positions[i] = base_pos + i;\n        }\n    } else {\n        // Default to random\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        monster_positions.assign(positions.begin(), positions.end());\n        positions.clear();\n        while ((int)positions.size() < m) {\n            positions.insert(rnd.next(1, 200000));\n        }\n        special_positions.assign(positions.begin(), positions.end());\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", monster_positions[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", special_positions[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type min_values\n./gen -n 1 -m 1 -type all_special\n./gen -n 1 -m 1 -type no_special\n./gen -n 2 -m 1 -type overlap\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 5 -m 3 -type all_special\n./gen -n 5 -m 3 -type no_special\n./gen -n 10 -m 5 -type random\n./gen -n 10 -m 5 -type clustered\n./gen -n 10 -m 5 -type scattered\n./gen -n 50 -m 25 -type random\n./gen -n 50 -m 25 -type clustered\n./gen -n 50 -m 25 -type overlap\n./gen -n 100 -m 50 -type random\n./gen -n 100 -m 50 -type overlap\n./gen -n 500 -m 200 -type random\n./gen -n 500 -m 200 -type max_m\n./gen -n 1000 -m 200 -type clustered\n./gen -n 1000 -m 200 -type overlap\n./gen -n 2000 -m 500 -type random\n./gen -n 5000 -m 1000 -type max_m\n./gen -n 10000 -m 2000 -type random\n./gen -n 10000 -m 2000 -type overlap\n./gen -n 50000 -m 2000 -type random\n./gen -n 50000 -m 2000 -type max_monsters\n./gen -n 100000 -m 2000 -type max_monsters\n./gen -n 100000 -m 2000 -type max_monsters_overlap\n./gen -n 100000 -m 2000 -type max_values\n./gen -n 99999 -m 1999 -type overlap\n./gen -n 100000 -m 1 -type no_special\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:02.814470",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "436/E",
      "title": "E. Cardboard Box",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записаны два целых числа n и w (1 ≤ n ≤ 3·105; 1 ≤ w ≤ 2n) — количество уровней в первой коробке и количество звезд, которое требуется, чтобы открыть следующую коробку. В каждой из следующих n строк записаны два целых числа ai и bi (1 ≤ ai < bi ≤ 109) — характеристики i-го уровня.",
      "output_spec": "Выходные данныеВ первой строке выведите целое число t — минимальное время, которое требуется, чтобы открыть следующую коробку. В следующей строке выведите n цифр без пробелов — описание оптимального плана действий:   если i-й уровень нужно пройти на одну звезду, i-я цифра должна быть равна 1;  если i-й уровень нужно пройти на две звезды, i-я цифра должна быть равна 2;  если i-й уровень вовсе не нужно проходить, i-я цифра должна быть равна 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 31 21 2Выходные данныеСкопировать312Входные данныеСкопировать5 310 205 1010 206 925 30Выходные данныеСкопировать1401020",
      "description": "E. Cardboard Box\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записаны два целых числа n и w (1 ≤ n ≤ 3·105; 1 ≤ w ≤ 2n) — количество уровней в первой коробке и количество звезд, которое требуется, чтобы открыть следующую коробку. В каждой из следующих n строк записаны два целых числа ai и bi (1 ≤ ai < bi ≤ 109) — характеристики i-го уровня.\n\nВходные данные\n\nВыходные данныеВ первой строке выведите целое число t — минимальное время, которое требуется, чтобы открыть следующую коробку. В следующей строке выведите n цифр без пробелов — описание оптимального плана действий:   если i-й уровень нужно пройти на одну звезду, i-я цифра должна быть равна 1;  если i-й уровень нужно пройти на две звезды, i-я цифра должна быть равна 2;  если i-й уровень вовсе не нужно проходить, i-я цифра должна быть равна 0.\n\nВыходные данные\n\nВходные данныеСкопировать2 31 21 2Выходные данныеСкопировать312Входные данныеСкопировать5 310 205 1010 206 925 30Выходные данныеСкопировать1401020\n\nВходные данныеСкопировать2 31 21 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать312\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 310 205 1010 206 925 30\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1401020\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере ответ 21 также считается правильным.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces",
          "content": "Божественно кодить можно не только для разных поисковых систем, но и в индустрии видеоигр — и не где-нибудь, а прямо на родине. Если не верите, то компания ZeptoLab, создатель известной во всем мире игры Cut the Rope, дает вам возможность убедиться в этом лично. И да, мы находимся в Москве.Не секрет, что высот программирования достигают только те, кто много работает, в том числе — над собой и своим образованием. В ZeptoLab мы стараемся создать пространство, которое максимально к этому располагает. В частности, недавно у нас появилась корпоративная библиотека, где можно найти все необходимое для получения новых знаний, а также импровизированный читальный зал с диванами и креслами. Также мы устраиваем чемпионаты по разработке внутри компании, чтобы наши ЗептоПрограммисты могли в свое удовольствие порешать нетривиальные задачки и помериться с коллегами нулями и единицами. Победители получают славу, ценные подарки и именное оружие (шутим, не оружие). А с недавнего времени в Zeptolab открылась своя алгоритмическая школа, в которой преподает не кто иной, как создатель и руководитель всея Codeforces — Михаил Мирзаянов! Личность в девелоперских кругах немалоизвестная: Михаил уже тренировал команду, которая стала чемпионом мира по программированию, так что можно себе вообразить, какие горизонты развернулись перед разработчиками ZeptoLab и перед компанией в целом. В таком формате Михаил преподает впервые, в России и мире аналогов подобной системы корпоративного образования практически нет. Для нас алгоритмы играют существенную роль, ведь требования к разработке стоят довольно жесткие: приложение на таргет-устройстве в идеале должно выдавать 60 кадров в секунду, и все расчеты игровой логики надо производить очень быстро и предпочтительно с простой сложностью в противовес амортизированной. Кроме того, у нас есть возможность делать неслабый препроцессинг, перенося некоторые вычисления на этап подготовки ресурсов для игры. Понимание этих фактов, как и множества других — вот ключ к быстрой работе наших игр. По этой причине мы поддерживаем движение алгоритмистов.И впервые Зептолаб проводит конкурс по алгоритмической разработке, на базе Codeforces. Вас ждут нетривиальные задания, бескомпромиссная девелоперская борьба и крутые призы: Ну и чтобы добавить интриги: будет еще один приз: IPad Mini Retina мы вручим рандомно тому, кто попадет в ТОП-50 победителей конкурса и будет выбран вот так: мы просуммируем времена всех успешных попыток трех победителей (в секундах от начала контеста) и возьмем строчку с номером s % 47 + 4, где s — найденная сумма. Если вычисленная строка будет делить место, то приоритет будет у того, кто сдал последнюю из решенных задач раньше.И на сладенькое: у того, кто покажет неплохие результаты по конкурсу, будет возможность устроиться к нам по упрощенной схеме. Если тебе интересно попробовать себя в команде ZeptoLab — поставь соответствующую галочку при регистрации. О том, что такое работать у нас можно почитать тут: http://zeptoteam.ru/. Заинтересовались работой в ZeptoLab? Чемпионат будет проводиться в один раунд. Формат соревнования — по правилам Codeforces. Раунд будет рейтинговым и общим для обоих дивизионов.Дата и время проведения: 13 июня 2014, время: 19:30 — 22:00.Разбалловка задач: 1000-1000-1500-2500-2500-3000.Ура-ура! Соревнование завершено! Спасибо всем принявшим участие! Надеемся, что вам понравились задачи. Особые поздравления победителям соревнования: 1 место — KAN (Николай Калинин, Нижний Новгород) — iPad Air 2 место — winger (Владислав Исенбаев, США, Фейсбук) — iPad Mini 3 место — tourist (Геннадий Короткевич, Санкт-Петербург, ИТМО) — iPad Mini Все участники, занявшие места с 1-го по 30-е получат подарки: замечательного плюшего Ом Нома и сувенирную футболку, а участники с 31-го места по 50-е получат в подарок футболки чемпионата!Дополнительный приз достается участнику, занявшему 21-е место: package.zaic (Вадим Зайцев, Новосибирск, Новосибирский ГУ).",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/12605",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3941
        },
        {
          "title": "Zepto Code Rush 2014 — решения - Codeforces",
          "content": "436A - Feed with CandyАвтор разбора: Fefer_IvanВ задача А типы съеденных конфет должны все время менятся. Так что первая съеденная конфета определяет тип всех последующих конфет. Возможных типа всего два, так что переберем тип первой съеденной конфеты. Пусть в какой-то момент времени Ом Ном должен съесть конфету типа t и может прыгать на высоту h. Очевидно, что наиболее выгодным решением будет съесть конфету с наибольшей массой среди всех конфет, которые Ом Ном может съесть на текущем этапе. Для решения задачи необходимо промоделировать процесс поедания конфет для начального h = x и t = [0, 1] и выбрать лучшее значение.436B - Om Nom and SpidersАвтор разбора: Fefer_IvanПронумеруем столбцы таблицы начиная с 0 слева направа, а строки начиная с 0 сверху вниз. Теперь заметим, что в момент времени t > 0 в клетке (x, y) могут находиться только 4 паука: Паук, который движется влево и в начале был в клетке (x, y + t). Паук, который движется вправо и в начале был в клетке (x, y - t). Паук, который движется вниз и в начале был в клетке (x - t, y). Паук, который движется вверх и в начале был в клетке (x + t, y). Давайте переберем столбец в котором Ом Ном начнет свой путь. Пусть это столбец y. В момент времени 0 все пауки стоят на своих исходных позициях, а Ом Ном стоит в клетке (0, y). Так как на нулевой строке нет пауков, то в момент времени 0 Ом Ном их точно не встречает. Когда Ом Ном находится в клетке (x, y), это значит, что с момента начала движения прошло x единиц времени. Следовательно, для того, чтобы вычислить сколько пауков Ом Ном встретим в этой клетке, необходимо проверить лишь 4 клетки, указанные выше, на наличие паука, движущегося в нужном направлении.436C - Dungeons and CandiesАвтор разбора: Fefer_IvanДавайте рассмотрим неориентированный взвешенный граф, в котором k + 1 вершина. Пронумеруем вершины целыми числами от 0 до k. Вершины c 1 по k будут соответствовать уровни. Для каждой пары уровней i и j добавим ребро из i в j стоимость которого равно стоимости передачи одного уровня как разность с другим. Так же для каждого уровня i добавим ребро между вершиной 0 и i стоимости n·m, т.е. стоимости передачи уровня целиком. Каждый способ передать все уровни соответсвует остовному дереву в указанном графе. Таким обзаром необходимо вывести минимальное остовное дерево в этом графе.436D - Pudding MonstersАвтор разбора: Fefer_IvanЗадача решается при помощи динамического программирования. Введем обозначения: sum(l, r) — количество особых клеток на отрезке с l по r, zi — максимальное количество особых клеток, которые можно покрыть, используя только первые i монстров при условии, что i-тый монстр либо остается на месте, либо отправляется влево, di--- максимальное количество особых клеток, которые можно покрыть, используя только первые i монстров при условии, что i-тый монстр остается на месте. Рассмотрим процесс вычисления di. Пусть i-тый монстр находится в клетке r. Переберем самую левую особую клетку, которая будет покрыта блоком монстров, в котором будет находиться i-й монстр. Пусть эта особая клетка находится в клетке l. Тогда нам требуется r - l дополнительных монстров отправить вправо для того, чтобы покрыть эту особую клетку. Тогда ответ будет равен zi - (r - l) + sum(l, r). Для вычисления di надо взять максимум по всем особым клеткам, левее i-того монстра.Теперь, после того, как мы вычислили очередное значение di, необходимо обновить некоторые значения zj. Пусть i-тый монстр находится в клетке l. Переберем самую правую особую клетку, которая будет покрыта блоком монстров, в котором будет находиться i-й монстр. Пусть эта особая клетка находится в клетке r. Тогда нам требуется r - l дополнительных монстров отправить влево для того, чтобы покрыть эту особую клетку. Тогда, zi + (r - l) можно обновить следующим значением di + sum(l + 1, r). Так же необходимо не забыть обновить значение zi значением zi - 1.Как можно видеть это решение имеет сложность O(n·m), так как для каждого из n монстров мы перебираем все m особых клеток, а все вычисления при фиксированной паре монстр-клетка проходят за O(1).При реализации могут возникнуть небольшие тонкости, связанные с монстрами, которые уже в начальном состоянии слиплись в один блок.436E - Cardboard BoxАвтор разбора: GeraldВ задаче E нужно было написать правильную жадность. Правильных жадностей существует несколько, вот одна из них: Посмотрим на некоторый оптимальный ответ (набор как-то пройденных уровней). Отсортируем все уровни по b[i]. Если рассмотреть последний взятый в ответ уровень, пройденный на 2 звезды, то окажется, что все находящиеся до него в таком порядке уровни пройдены хотя бы на одну звезду. Иначе, можно было бы заменить этот уровень на какой-то не пройденный и не увеличить ответ. Пользуясь вышесказанным, зафиксируем префикс L уровней в порядке сортировки по b[i]. Все уровни этого префикса мы должны хоть как-то пройти (либо на 1, либо на 2 звезды). Дополнительно, будет считать, что все уровни пройденные на 2 звезды должны содержаться только в этом префиксе (такой префикс должен существовать для некоторого оптимального ответа, как было показано ранее). Так как мы зафиксировали префикс длиной L уровней, которые мы точно хоть как-то пройдем, можно сказать, что нам осталось добрать w - L звезд. Как мы можем добирать эти звезды? Либо допроходить какие-то уровни из префикса L на 2 звезды, либо проходить уровни не из префикса L на одну (потому что уровни, которые мы проходим на 2 звезды должны содержаться только на зафиксированном префиксе). Понятно, что для того, чтобы получить оптимальный ответ нужно выбрать w - L самых дешевых звезд. Поэтому отсортируем n элементов: L чисел b[i] - a[i] (для всех i ≤ L), n - L чисел a[i] (для всех i > L). Выберем среди этих чисел w - L минимальных. Описанное нужно было реализовывать быстрее, чем за квадрат. Самая очевидная реализация использует декартово дерево, чуть менее очевидная использует дерево отрезков. Итоговая сложность решения: O(n log n).436F - BannersАвтор разбора: GeraldЗадача F была самой сложной задачей контеста. Чтобы лучше представить себе ее решение, можно перейти к геометрическому представлению задачи. Представим, что люди — это точки на плоскости Opc, тогда, то что требуется найти — для каждой прямой c = i, такую прямую p = j, что некоторая функция принимает максимальное значение. Под некоторой функцией понимается следующая: (количество точек не ниже прямой c = i умножить на w·i) плюс (количество точек ниже прямой c = i и не левее прямой p = j умножить на j).Будем двигать сканирующую прямую снизу вверх. Сначала рассматриваем c = 0, затем c = 1 и так далее. При этом для каждого p будем хранить величину d[p] — чему равен ответ на задачу при текущем c, если второй параметр будет равен p. Если у нас есть корректно посчитанный массив d[] и мы переходим от c к c + 1, как пересчитать этот массив для нового c?Посмотрим на всех людей, для которых хоть что-то поменяется, очевидно — это люди у которых b[i] = c. При текущем c они еще пользовались бесплатной версией, но после увеличения на 1, они перестанут ей пользоваться. Понятно, что каждый такой человек i модифицирует массив следующим образом: d[1] +  = 1, d[2] +  = 2, ..., d[b[i]] +  = b[i].Теперь можно переформулировать задачу в терминах структур данных. Есть два вида запросов: прибавить на префиксе возрастающую арифметическую прогрессию, узнать максимум среди всех элементов массива d. Один из способов решить такую задачу — корневая декомпозиция.Разобьем все запросы на группы по sqrt(q) штук, в каждой группе выделим отрезки, на которых к ячейке d[i] значение i прибавляется с одним и тем же коэффициентом. Для каждого такого отрезка построим нижнее огибающее множество прямых y = d[i] + i·x. Так как запросов в группе sqrt(q), то и отрезков будет O(sqrt(q)). Значит прибавление на префиксе и взятие максимума можно будет делать за O(sqrt(q)).Итоговая сложность решения: O(MAXX·sqrt(MAXX)), где MAXX — максимальное значение среди a[i] и b[i].",
          "author": "Fefer_Ivan",
          "url": "https://codeforces.com/blog/entry/12680",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 436\\s*E"
          },
          "content_length": 7921
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 1",
          "code": "You may edit your comment only for fixing grammar mistakes or small changes.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 2",
          "code": "Do not change the main idea of your comment.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 3",
          "code": "All previous revisions are available for others. Are you sure you want to edit comment?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 4",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 5",
          "code": "1 3 5 2\nABA\nBBB\nBBA\nBAB\nABB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 6",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 7",
          "code": "11\n5 0\n2 5\n1 5\n4 2\n3 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 8",
          "code": "if(par[r] = r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 9",
          "code": "if(par[r] == r) return r;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 10",
          "code": "3 1\n0 2 1\n0 3 1\n1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 11",
          "code": "3 1\n0 2 1\n0 3 1\n1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 12",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 13",
          "code": "3 1\n0 1 1\n0 1 1\n1 1 100",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2014 - Codeforces - Code 14",
          "code": "What maximum number of candies can Om Nom eat if he never eats two candies of the same type in a row (Om Nom finds it too boring)?",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12605",
          "author": "viktork"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and w\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 2 * n, \"w\");\n    inf.readEoln();\n\n    // Read the levels\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai + 1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    // Ensure EOF is reached\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and w\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 2 * n, \"w\");\n    inf.readEoln();\n\n    // Read the levels\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai + 1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    // Ensure EOF is reached\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n and w\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 2 * n, \"w\");\n    inf.readEoln();\n\n    // Read the levels\n    for (int i = 0; i < n; ++i) {\n        int ai = inf.readInt(1, 1000000000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(ai + 1, 1000000000, \"bi\");\n        inf.readEoln();\n    }\n\n    // Ensure EOF is reached\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct level {\n    long long a, b;\n};\n\nlong long n, w;\nvector<level> L;\n\n// This function reads a solution from the given stream:\n//  1) Reads the claimed minimum time.\n//  2) Reads a string of n digits ('0', '1', or '2') representing how each level is used.\n// It checks:\n//  - The string has length n.\n//  - Each character is one of '0', '1', or '2'.\n//  - The total stars earned is at least w.\n//  - The actual sum of times matches the claimed minimum time.\n//\n// Returns the sum of times if it's valid; otherwise, it quits with _wa if called with ouf,\n// or _fail if called with ans.\nlong long readSolution(InStream &stream)\n{\n    // Read the claimed minimal time\n    long long claimedTime = stream.readLong(0, LLONG_MAX, \"claimedTime\");\n\n    // Read the scenario string (exactly one token)\n    string scenario = stream.readToken();\n    if ((long long) scenario.size() != n)\n        stream.quitf(_wa, \"scenario string length != n\");\n\n    long long totalTime = 0;\n    long long totalStars = 0;\n    for (int i = 0; i < n; i++)\n    {\n        char c = scenario[i];\n        if (c != '0' && c != '1' && c != '2')\n            stream.quitf(_wa, \"invalid character '%c' at position %d\", c, i + 1);\n\n        if (c == '1')\n        {\n            totalTime += L[i].a;\n            totalStars += 1;\n        }\n        else if (c == '2')\n        {\n            totalTime += L[i].b;\n            totalStars += 2;\n        }\n        // '0' => skip, do nothing\n    }\n\n    if (totalStars < w)\n        stream.quitf(_wa, \"earned only %lld stars but need at least %lld\", totalStars, w);\n\n    if (totalTime != claimedTime)\n        stream.quitf(_wa, \"claimed time = %lld but actual time = %lld\", claimedTime, totalTime);\n\n    return totalTime;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    // Read input from the test data\n    n = inf.readLong(1, 300000, \"n\");\n    w = inf.readLong(1, 2LL * n, \"w\");   // cast to long long to avoid any ambiguity\n    L.resize(n);\n    for (int i = 0; i < n; i++)\n    {\n        L[i].a = inf.readLong(1LL, 1000000000LL, \"a_i\");\n        // Make sure both arguments are of type long long\n        L[i].b = inf.readLong(L[i].a + 1LL, 1000000000LL, \"b_i\"); \n        // b_i > a_i as stated in the problem\n    }\n\n    // Read the jury's solution\n    long long juryTime = readSolution(ans);\n\n    // Read the participant's solution\n    long long partTime = readSolution(ouf);\n\n    // Compare\n    if (partTime < juryTime)\n        quitf(_fail, \"participant's time %lld is better than jury's time %lld\", partTime, juryTime);\n    else if (partTime > juryTime)\n        quitf(_wa, \"participant's time %lld is worse than jury's time %lld\", partTime, juryTime);\n    else\n        quitf(_ok, \"times match: %lld\", partTime);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int w;\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        w = opt<int>(\"w\", rnd.next(1, 2 * n));\n        // Generate random ai and bi, ai < bi\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    } else if (type == \"min\") {\n        w = opt<int>(\"w\", n);\n        // Set ai = 1, bi = 2\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 2;\n        }\n    } else if (type == \"max\") {\n        w = opt<int>(\"w\", 2 * n);\n        // Set ai and bi close to 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = (int)1e9 - 1;\n            b[i] = (int)1e9;\n        }\n    } else if (type == \"equal\") {\n        w = opt<int>(\"w\", n);\n        // bi = ai + 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = a[i] + 1;\n        }\n    } else if (type == \"far\") {\n        w = opt<int>(\"w\", n);\n        // bi = ai + big value\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - (int)1e6);\n            b[i] = a[i] + rnd.next((int)1e6, (int)1e9 - a[i]);\n        }\n    } else if (type == \"duplicate\") {\n        w = opt<int>(\"w\", n);\n        // All ai and bi are the same\n        int ai = rnd.next(1, (int)1e9 - 1);\n        int bi = ai + rnd.next(1, (int)1e9 - ai);\n        for(int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else if (type == \"zigzag\") {\n        w = opt<int>(\"w\", rnd.next(1, 2 * n));\n        // ai alternate between low and high values\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = 1;\n                b[i] = rnd.next(2, (int)1e9);\n            } else {\n                a[i] = rnd.next((int)1e9 / 2, (int)1e9 - 1);\n                b[i] = a[i] + rnd.next(1, (int)1e9 - a[i]);\n            }\n        }\n    } else if (type == \"wmin\") {\n        w = 1;\n        // Generate random ai and bi\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    } else if (type == \"wmax\") {\n        w = 2 * n;\n        // Generate random ai and bi\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    } else {\n        w = opt<int>(\"w\", rnd.next(1, 2 * n));\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    }\n\n    // Ensure w is between 1 and 2n\n    if (w < 1) w = 1;\n    if (w > 2 * n) w = 2 * n;\n\n    // Output the data\n    printf(\"%d %d\\n\", n, w);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int w;\n\n    vector<int> a(n);\n    vector<int> b(n);\n\n    if (type == \"random\") {\n        w = opt<int>(\"w\", rnd.next(1, 2 * n));\n        // Generate random ai and bi, ai < bi\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    } else if (type == \"min\") {\n        w = opt<int>(\"w\", n);\n        // Set ai = 1, bi = 2\n        for(int i = 0; i < n; ++i) {\n            a[i] = 1;\n            b[i] = 2;\n        }\n    } else if (type == \"max\") {\n        w = opt<int>(\"w\", 2 * n);\n        // Set ai and bi close to 1e9\n        for(int i = 0; i < n; ++i) {\n            a[i] = (int)1e9 - 1;\n            b[i] = (int)1e9;\n        }\n    } else if (type == \"equal\") {\n        w = opt<int>(\"w\", n);\n        // bi = ai + 1\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = a[i] + 1;\n        }\n    } else if (type == \"far\") {\n        w = opt<int>(\"w\", n);\n        // bi = ai + big value\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - (int)1e6);\n            b[i] = a[i] + rnd.next((int)1e6, (int)1e9 - a[i]);\n        }\n    } else if (type == \"duplicate\") {\n        w = opt<int>(\"w\", n);\n        // All ai and bi are the same\n        int ai = rnd.next(1, (int)1e9 - 1);\n        int bi = ai + rnd.next(1, (int)1e9 - ai);\n        for(int i = 0; i < n; ++i) {\n            a[i] = ai;\n            b[i] = bi;\n        }\n    } else if (type == \"zigzag\") {\n        w = opt<int>(\"w\", rnd.next(1, 2 * n));\n        // ai alternate between low and high values\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                a[i] = 1;\n                b[i] = rnd.next(2, (int)1e9);\n            } else {\n                a[i] = rnd.next((int)1e9 / 2, (int)1e9 - 1);\n                b[i] = a[i] + rnd.next(1, (int)1e9 - a[i]);\n            }\n        }\n    } else if (type == \"wmin\") {\n        w = 1;\n        // Generate random ai and bi\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    } else if (type == \"wmax\") {\n        w = 2 * n;\n        // Generate random ai and bi\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    } else {\n        w = opt<int>(\"w\", rnd.next(1, 2 * n));\n        // Default to random\n        for(int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, (int)1e9 - 1);\n            b[i] = rnd.next(a[i] + 1, (int)1e9);\n        }\n    }\n\n    // Ensure w is between 1 and 2n\n    if (w < 1) w = 1;\n    if (w > 2 * n) w = 2 * n;\n\n    // Output the data\n    printf(\"%d %d\\n\", n, w);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", a[i], b[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random w\n./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 5 -type random -w 1\n\n# Small n, wmin and wmax\n./gen -n 1 -type wmin\n./gen -n 1 -type wmax\n./gen -n 2 -type wmin\n./gen -n 2 -type wmax\n\n# Medium n\n./gen -n 1000 -type random\n./gen -n 1000 -type min\n./gen -n 1000 -type max\n\n# Medium n, wmin and wmax\n./gen -n 1000 -type wmin\n./gen -n 1000 -type wmax\n\n# Large n\n./gen -n 100000 -type random\n./gen -n 100000 -type min\n./gen -n 100000 -type max\n./gen -n 100000 -type equal\n./gen -n 100000 -type far\n./gen -n 100000 -type duplicate\n\n# Large n, wmin and wmax\n./gen -n 100000 -type wmin\n./gen -n 100000 -type wmax\n\n# Maximum n\n./gen -n 300000 -type random\n./gen -n 300000 -type min\n./gen -n 300000 -type max\n\n# Maximum n, wmin and wmax\n./gen -n 300000 -type wmin\n./gen -n 300000 -type wmax\n\n# Edge case: w = 1\n./gen -n 10000 -type random -w 1\n./gen -n 50000 -type random -w 1\n\n# Edge case: w = 2n\n./gen -n 10000 -type random -w 20000\n./gen -n 50000 -type random -w 100000\n\n# Edge case: n = 1, w = 2\n./gen -n 1 -type random -w 2\n\n# Type zigzag\n./gen -n 1000 -type zigzag\n./gen -n 100000 -type zigzag\n./gen -n 300000 -type zigzag\n\n# Type equal\n./gen -n 1000 -type equal\n./gen -n 100000 -type equal\n./gen -n 300000 -type equal\n\n# Type far\n./gen -n 100000 -type far\n./gen -n 300000 -type far\n\n# Type duplicate\n./gen -n 100000 -type duplicate\n./gen -n 300000 -type duplicate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:04.784110",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "436/F",
      "title": "Problem 436/F",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    for(int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 100000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 100000, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    for(int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 100000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 100000, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int w = inf.readInt(1, 100000, \"w\");\n    inf.readEoln();\n\n    for(int i = 0; i < n; ++i) {\n        int ai = inf.readInt(0, 100000, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(0, 100000, \"bi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Number of users\n    int w = inf.readInt(); // Profit from a single banner\n    \n    vector<int> ai(n); // Users' willingness to pay for the paid version\n    vector<int> bi(n); // Users' tolerance for the number of ad banners\n    int max_bi = 0;\n\n    for (int i = 0; i < n; ++i) {\n        ai[i] = inf.readInt();\n        bi[i] = inf.readInt();\n        max_bi = max(max_bi, bi[i]);\n    }\n\n    int k = max_bi + 2; // Number of lines expected in the outputs\n\n    vector<long long> pay_jury(k);\n    vector<int> p_jury(k);\n\n    // Read jury's answer\n    for (int i = 0; i < k; ++i) {\n        pay_jury[i] = ans.readLong();\n        p_jury[i] = ans.readInt();\n    }\n\n    vector<long long> pay_contestant(k);\n    vector<int> p_contestant(k);\n\n    // Read contestant's answer and validate\n    for (int i = 0; i < k; ++i) {\n        if (ouf.eof())\n            quitf(_wa, \"Unexpected end of file in contestant's output at line %d\", i + 1);\n\n        pay_contestant[i] = ouf.readLong();\n        p_contestant[i] = ouf.readInt();\n\n        // Check if profits match\n        if (pay_contestant[i] != pay_jury[i]) {\n            quitf(_wa, \"At c = %d, expected profit = %lld, contestant's profit = %lld\", i, pay_jury[i], pay_contestant[i]);\n        }\n\n        // Check if p is within the specified range\n        if (p_contestant[i] < 0 || p_contestant[i] > 1000000000) {\n            quitf(_wa, \"At c = %d, p = %d is out of range [0, 1e9]\", i, p_contestant[i]);\n        }\n\n        // Optionally, we can verify that the profit computed with p_contestant[i] matches pay_contestant[i]\n        // However, due to time constraints, we accept the contestant's output if profits match\n    }\n\n    // Ensure there is no extra output\n    if (!ouf.seekEof())\n        quitf(_wa, \"Extra data found in contestant's output.\");\n\n    quitf(_ok, \"All profits match the expected values.\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_AB = 100000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int w = opt<int>(\"w\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n            bi[i] = rnd.next(0, MAX_AB);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = MAX_AB;\n            bi[i] = rnd.next(0, MAX_AB);\n        }\n    } else if (type == \"min_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = 0;\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = MAX_AB;\n        }\n    } else if (type == \"same_ai_bi\") {\n        int a = opt<int>(\"a\", 0);\n        int b = opt<int>(\"b\", 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = a;\n            bi[i] = b;\n        }\n    } else if (type == \"random\") {\n        int min_ai = opt<int>(\"min_ai\", 0);\n        int max_ai = opt<int>(\"max_ai\", MAX_AB);\n        int min_bi = opt<int>(\"min_bi\", 0);\n        int max_bi = opt<int>(\"max_bi\", MAX_AB);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"increasing_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = i * MAX_AB / n;\n            bi[i] = rnd.next(0, MAX_AB);\n        }\n    } else if (type == \"decreasing_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = MAX_AB - (i * MAX_AB / n);\n        }\n    } else if (type == \"edge_ai_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? 0 : MAX_AB;\n            bi[i] = (i % 2 == 0) ? 0 : MAX_AB;\n        }\n    } else if (type == \"random_max_bi\") {\n        int max_bi = opt<int>(\"max_bi\", MAX_AB);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = rnd.next(0, max_bi);\n        }\n    } else if (type == \"random_min_bi\") {\n        int min_bi = opt<int>(\"min_bi\", 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = rnd.next(min_bi, MAX_AB);\n        }\n    } else {\n        // default to random\n        int min_ai = opt<int>(\"min_ai\", 0);\n        int max_ai = opt<int>(\"max_ai\", MAX_AB);\n        int min_bi = opt<int>(\"min_bi\", 0);\n        int max_bi = opt<int>(\"max_bi\", MAX_AB);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, w);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_AB = 100000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int w = opt<int>(\"w\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"min_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = 0;\n            bi[i] = rnd.next(0, MAX_AB);\n        }\n    } else if (type == \"max_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = MAX_AB;\n            bi[i] = rnd.next(0, MAX_AB);\n        }\n    } else if (type == \"min_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = 0;\n        }\n    } else if (type == \"max_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = MAX_AB;\n        }\n    } else if (type == \"same_ai_bi\") {\n        int a = opt<int>(\"a\", 0);\n        int b = opt<int>(\"b\", 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = a;\n            bi[i] = b;\n        }\n    } else if (type == \"random\") {\n        int min_ai = opt<int>(\"min_ai\", 0);\n        int max_ai = opt<int>(\"max_ai\", MAX_AB);\n        int min_bi = opt<int>(\"min_bi\", 0);\n        int max_bi = opt<int>(\"max_bi\", MAX_AB);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    } else if (type == \"increasing_ai\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = i * MAX_AB / n;\n            bi[i] = rnd.next(0, MAX_AB);\n        }\n    } else if (type == \"decreasing_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = MAX_AB - (i * MAX_AB / n);\n        }\n    } else if (type == \"edge_ai_bi\") {\n        for (int i = 0; i < n; ++i) {\n            ai[i] = (i % 2 == 0) ? 0 : MAX_AB;\n            bi[i] = (i % 2 == 0) ? 0 : MAX_AB;\n        }\n    } else if (type == \"random_max_bi\") {\n        int max_bi = opt<int>(\"max_bi\", MAX_AB);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = rnd.next(0, max_bi);\n        }\n    } else if (type == \"random_min_bi\") {\n        int min_bi = opt<int>(\"min_bi\", 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(0, MAX_AB);\n            bi[i] = rnd.next(min_bi, MAX_AB);\n        }\n    } else {\n        // default to random\n        int min_ai = opt<int>(\"min_ai\", 0);\n        int max_ai = opt<int>(\"max_ai\", MAX_AB);\n        int min_bi = opt<int>(\"min_bi\", 0);\n        int max_bi = opt<int>(\"max_bi\", MAX_AB);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(min_ai, max_ai);\n            bi[i] = rnd.next(min_bi, max_bi);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, w);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -w 1 -type min_ai\n./gen -n 1 -w 1 -type max_ai\n./gen -n 1 -w 1 -type min_bi\n./gen -n 1 -w 1 -type max_bi\n./gen -n 1 -w 1 -type random\n\n./gen -n 10 -w 100000 -type random\n./gen -n 100 -w 100000 -type random\n./gen -n 1000 -w 100000 -type random\n./gen -n 10000 -w 100000 -type random\n./gen -n 100000 -w 100000 -type random\n\n./gen -n 100000 -w 1 -type min_ai\n./gen -n 100000 -w 100000 -type max_ai\n\n./gen -n 100000 -w 1 -type min_bi\n./gen -n 100000 -w 100000 -type max_bi\n\n./gen -n 100000 -w 1 -type increasing_ai\n./gen -n 100000 -w 100000 -type decreasing_bi\n\n./gen -n 100000 -w 1 -type edge_ai_bi\n\n./gen -n 100000 -w 100000 -type same_ai_bi -a 0 -b 0\n./gen -n 100000 -w 100000 -type same_ai_bi -a 100000 -b 100000\n./gen -n 100000 -w 1 -type same_ai_bi -a 50000 -b 50000\n\n./gen -n 100000 -w 100000 -type random_max_bi -max_bi 0\n./gen -n 100000 -w 100000 -type random_max_bi -max_bi 50000\n./gen -n 100000 -w 100000 -type random_min_bi -min_bi 50000\n./gen -n 100000 -w 100000 -type random_min_bi -min_bi 100000\n\n./gen -n 2 -w 1 -type random\n./gen -n 3 -w 100000 -type random\n\n./gen -n 100000 -w 1 -type random -min_ai 0 -max_ai 0 -min_bi 0 -max_bi 0\n./gen -n 100000 -w 100000 -type random -min_ai 100000 -max_ai 100000 -min_bi 100000 -max_bi 100000\n\n./gen -n 100000 -w 50000 -type random -min_ai 50000 -max_ai 50000 -min_bi 50000 -max_bi 50000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:07.009699",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "437/A",
      "title": "A. The Child and Homework",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line starts with \"A.\" (without quotes), then followed the description of choice A. The next three lines contains the descriptions of the other choices in the same format. They are given in order: B, C, D. Please note, that the description goes after prefix \"X.\", so the prefix mustn't be counted in description's length.Each description is non-empty and consists of at most 100 characters. Each character can be either uppercase English letter or lowercase English letter, or \"_\".",
      "output_spec": "OutputPrint a single line with the child's choice: \"A\", \"B\", \"C\" or \"D\" (without quotes).",
      "sample_tests": "ExamplesInputCopyA.VFleaKing_is_the_author_of_this_problemB.Picks_is_the_author_of_this_problemC.Picking_is_the_author_of_this_problemD.Ftiasch_is_cuteOutputCopyDInputCopyA.abB.abcdeC.abD.abcOutputCopyCInputCopyA.cB.ccC.cD.cOutputCopyB",
      "description": "A. The Child and Homework\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line starts with \"A.\" (without quotes), then followed the description of choice A. The next three lines contains the descriptions of the other choices in the same format. They are given in order: B, C, D. Please note, that the description goes after prefix \"X.\", so the prefix mustn't be counted in description's length.Each description is non-empty and consists of at most 100 characters. Each character can be either uppercase English letter or lowercase English letter, or \"_\".\n\nOutputPrint a single line with the child's choice: \"A\", \"B\", \"C\" or \"D\" (without quotes).\n\nInputCopyA.VFleaKing_is_the_author_of_this_problemB.Picks_is_the_author_of_this_problemC.Picking_is_the_author_of_this_problemD.Ftiasch_is_cuteOutputCopyDInputCopyA.abB.abcdeC.abD.abcOutputCopyCInputCopyA.cB.ccC.cD.cOutputCopyB\n\nInputCopyA.VFleaKing_is_the_author_of_this_problemB.Picks_is_the_author_of_this_problemC.Picking_is_the_author_of_this_problemD.Ftiasch_is_cute\n\nOutputCopyD\n\nInputCopyA.abB.abcdeC.abD.abc\n\nOutputCopyC\n\nInputCopyA.cB.ccC.cD.c\n\nOutputCopyB\n\nNoteIn the first sample, the first choice has length 39, the second one has length 35, the third one has length 37, and the last one has length 15. The choice D (length 15) is twice shorter than all other choices', so it is great choice. There is no other great choices so the child will choose D.In the second sample, no choice is great, so the child will choose the luckiest choice C.In the third sample, the choice B (length 2) is twice longer than all other choices', so it is great choice. There is no other great choices so the child will choose B.",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 437\\s*A"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (char c = 'A'; c <= 'D'; ++c) {\n        string line = inf.readLine();\n        ensuref(line.size() >= 2, \"Line starting with %c. is too short\", c);\n        ensuref(line[0] == c, \"Expected line to start with %c.\", c);\n        ensuref(line[1] == '.', \"Expected line to start with %c.\", c);\n        string desc = line.substr(2);\n        int desc_length = desc.size();\n        ensuref(desc_length >= 1 && desc_length <= 100, \"Description length should be between 1 and 100, but was %d\", desc_length);\n        for (char ch : desc) {\n            ensuref((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_', \"Invalid character '%c' in description\", ch);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (char c = 'A'; c <= 'D'; ++c) {\n        string line = inf.readLine();\n        ensuref(line.size() >= 2, \"Line starting with %c. is too short\", c);\n        ensuref(line[0] == c, \"Expected line to start with %c.\", c);\n        ensuref(line[1] == '.', \"Expected line to start with %c.\", c);\n        string desc = line.substr(2);\n        int desc_length = desc.size();\n        ensuref(desc_length >= 1 && desc_length <= 100, \"Description length should be between 1 and 100, but was %d\", desc_length);\n        for (char ch : desc) {\n            ensuref((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_', \"Invalid character '%c' in description\", ch);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    for (char c = 'A'; c <= 'D'; ++c) {\n        string line = inf.readLine();\n        ensuref(line.size() >= 2, \"Line starting with %c. is too short\", c);\n        ensuref(line[0] == c, \"Expected line to start with %c.\", c);\n        ensuref(line[1] == '.', \"Expected line to start with %c.\", c);\n        string desc = line.substr(2);\n        int desc_length = desc.size();\n        ensuref(desc_length >= 1 && desc_length <= 100, \"Description length should be between 1 and 100, but was %d\", desc_length);\n        for (char ch : desc) {\n            ensuref((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || ch == '_', \"Invalid character '%c' in description\", ch);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one multiple-choice question (4 lines),\n  each line starting with A., B., C., D. respectively, followed by\n  a description.\n\n  The description is a random string consisting of [a-zA-Z_] with length\n  between 1 and 100 (inclusive). The generator supports various \"type\"\n  scenarios to cover potential corner cases:\n\n      - random         : 4 random lengths in [1..maxLen].\n      - smaller        : Exactly one choice is at least 2x shorter than all others.\n      - bigger         : Exactly one choice is at least 2x longer  than all others.\n      - multiplesmall  : Multiple choices are at least 2x shorter than the others.\n      - multiplebig    : Multiple choices are at least 2x longer  than the others.\n      - none           : No single choice that is 2x shorter or 2x longer than all others.\n      - same           : All 4 choices have the same length.\n      - borderline     : Uses the extreme lengths (1 or 100) to check boundary handling.\n\n  Additional parameters:\n      - maxLen (int, default = 10): the upper bound for random lengths.\n*/\n\nstatic const string ALPHABET = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";\n\n// Generate a random string of given length\nstring randomString(int length) {\n    string s;\n    s.reserve(length);\n    for (int i = 0; i < length; i++) {\n        int idx = rnd.next((int)ALPHABET.size());\n        s.push_back(ALPHABET[idx]);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    // Register generator (mandatory)\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\"); \n    int maxLen  = opt<int>(\"maxLen\", 10);\n\n    // We will produce exactly 4 lines for the question's choices: A, B, C, D.\n    // Each prefix \"X.\" does not count toward the length, so we only care\n    // about generating strings of length in [1..100].\n\n    // Safeguard maxLen so that it won't exceed 100 and won't be below 1.\n    if (maxLen < 1)  maxLen = 1;\n    if (maxLen > 100) maxLen = 100;\n\n    // We'll store lengths in L[0..3]\n    vector<int> L(4, 1);\n\n    auto inRange = [&](int low, int high) {\n        // returns a random integer in [low, high], ensuring low <= high\n        if (low > high) return low; // fallback if invalid\n        return rnd.next(low, high);\n    };\n\n    // A small utility to ensure x >= 1 and x <= 100\n    auto clampLength = [&](int x){\n        if (x < 1) return 1;\n        if (x > 100) return 100;\n        return x;\n    };\n\n    if (type == \"random\") {\n        for(int i=0; i<4; i++){\n            L[i] = inRange(1, maxLen);\n        }\n    }\n    else if (type == \"smaller\") {\n        // Exactly one is at least 2x shorter than the other three.\n        // We'll pick an index i that is \"small\", then the others are big enough.\n        int smallIdx = rnd.next(0, 3);\n        // pick a small length\n        int smallLen = inRange(1, maxLen / 2 == 0 ? 1 : maxLen / 2);\n        L[smallIdx] = clampLength(smallLen);\n\n        // for each other j != smallIdx, ensure L[j] >= 2 * L[smallIdx]\n        for(int j=0; j<4; j++){\n            if (j == smallIdx) continue;\n            int bigLen = inRange(2 * smallLen, maxLen);\n            L[j]       = clampLength(bigLen);\n        }\n    }\n    else if (type == \"bigger\") {\n        // Exactly one is at least 2x longer than the other three.\n        int bigIdx = rnd.next(0, 3);\n        // first pick smaller lengths for others\n        // then pick bigLen >= 2 * (their max)\n        // step 1: pick the smaller 3\n        int lowLen1 = inRange(1, maxLen);\n        int lowLen2 = inRange(1, maxLen);\n        int lowLen3 = inRange(1, maxLen);\n        // find the max among these 3\n        int otherMax = max({lowLen1, lowLen2, lowLen3});\n        // step 2: pick bigLen\n        int bigLen   = inRange(2 * otherMax, maxLen);\n        if(bigLen < 1) bigLen = 1; \n        if(bigLen > 100) bigLen = 100;\n\n        // place them\n        // bigIdx gets bigLen\n        // others get the smaller\n        int idx=0;\n        for(int j=0; j<4; j++){\n            if(j == bigIdx) continue;\n            if(idx == 0) { L[j]=lowLen1; idx++; }\n            else if(idx==1){ L[j]=lowLen2; idx++;}\n            else { L[j]=lowLen3; idx++;}\n        }\n        L[bigIdx] = bigLen;\n    }\n    else if (type == \"multiplesmall\") {\n        // More than one choice is 2x smaller than the other(s).\n        // e.g. Two or three choices are all smaller than the rest.\n        // We'll do a simple fixed approach: pick two very small, two big.\n        // or create a random variant of that.\n        // For example: L0=1, L1=1, L2= in [2..maxLen], L3= in [2..maxLen]\n        // ensuring L2, L3 >= 2\n        L[0] = 1;\n        L[1] = 1;\n        L[2] = inRange(2, maxLen);\n        L[3] = inRange(2, maxLen);\n    }\n    else if (type == \"multiplebig\") {\n        // More than one choice is 2x bigger than the rest.\n        // We'll pick two very large, two small. Example:\n        // L0= in [1..x], L1= in [1..x], L2= ? >=2*( max(L0,L1) ), L3= ? >=2*( max(L0,L1))\n        int s1 = inRange(1, maxLen);\n        int s2 = inRange(1, maxLen);\n        int baseMax = max(s1, s2);\n        int b1 = inRange(2 * baseMax, maxLen);\n        int b2 = inRange(2 * baseMax, maxLen);\n        L[0] = s1;\n        L[1] = s2;\n        L[2] = b1;\n        L[3] = b2;\n    }\n    else if (type == \"none\") {\n        // No single choice is >=2x bigger or <=(1/2)x smaller than all others.\n        // We'll pick 4 lengths that do not differ by a factor of 2, e.g. 2,3,4,5 or something around a small range.\n        // We do it randomly but ensure ratio constraints are not triggered.\n        // E.g. pick an integer base in [2..maxLen-3], then do base, base+1, base+2, base+3 if they are <= maxLen\n        int base = inRange(1, maxLen - 3);\n        if(base < 1) base=1;\n        if(base+3>maxLen) base=1; \n        L[0] = base;\n        L[1] = base+1;\n        L[2] = base+2;\n        L[3] = base+3;\n    }\n    else if (type == \"same\") {\n        // All the same length\n        int lengthAll = inRange(1, maxLen);\n        for(int i=0; i<4; i++){\n            L[i] = lengthAll;\n        }\n    }\n    else if (type == \"borderline\") {\n        // Use extremes 1 and 100 (or up to maxLen if it's less than 100).\n        // We'll create a pattern: L0=1, L1=maxLen, L2=somewhere in [2..maxLen-1], L3=somewhere in [2..maxLen-1]\n        // This can catch boundary issues in solutions.\n        L[0] = 1;\n        L[1] = maxLen; // if maxLen <100, this is the borderline we have\n        int mid1 = inRange(2, maxLen-1 < 2 ? 2 : maxLen-1);\n        int mid2 = inRange(2, maxLen-1 < 2 ? 2 : maxLen-1);\n        L[2] = clampLength(mid1);\n        L[3] = clampLength(mid2);\n    }\n    else {\n        // If an unknown type is passed, fallback to random.\n        for(int i=0; i<4; i++){\n            L[i] = inRange(1, maxLen);\n        }\n    }\n\n    // Now we print out the final 4 lines.\n    // Prefixes must not be included in the length count, so \"A.\",\"B.\",\"C.\",\"D.\"\n    // are just printed. Then we append the random strings of lengths L[i].\n    static const char* prefix[4] = {\"A.\",\"B.\",\"C.\",\"D.\"};\n    for(int i=0; i<4; i++){\n        cout << prefix[i] << randomString(L[i]) << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces exactly one multiple-choice question (4 lines),\n  each line starting with A., B., C., D. respectively, followed by\n  a description.\n\n  The description is a random string consisting of [a-zA-Z_] with length\n  between 1 and 100 (inclusive). The generator supports various \"type\"\n  scenarios to cover potential corner cases:\n\n      - random         : 4 random lengths in [1..maxLen].\n      - smaller        : Exactly one choice is at least 2x shorter than all others.\n      - bigger         : Exactly one choice is at least 2x longer  than all others.\n      - multiplesmall  : Multiple choices are at least 2x shorter than the others.\n      - multiplebig    : Multiple choices are at least 2x longer  than the others.\n      - none           : No single choice that is 2x shorter or 2x longer than all others.\n      - same           : All 4 choices have the same length.\n      - borderline     : Uses the extreme lengths (1 or 100) to check boundary handling.\n\n  Additional parameters:\n      - maxLen (int, default = 10): the upper bound for random lengths.\n*/\n\nstatic const string ALPHABET = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\";\n\n// Generate a random string of given length\nstring randomString(int length) {\n    string s;\n    s.reserve(length);\n    for (int i = 0; i < length; i++) {\n        int idx = rnd.next((int)ALPHABET.size());\n        s.push_back(ALPHABET[idx]);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    // Register generator (mandatory)\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    string type = opt<string>(\"type\", \"random\"); \n    int maxLen  = opt<int>(\"maxLen\", 10);\n\n    // We will produce exactly 4 lines for the question's choices: A, B, C, D.\n    // Each prefix \"X.\" does not count toward the length, so we only care\n    // about generating strings of length in [1..100].\n\n    // Safeguard maxLen so that it won't exceed 100 and won't be below 1.\n    if (maxLen < 1)  maxLen = 1;\n    if (maxLen > 100) maxLen = 100;\n\n    // We'll store lengths in L[0..3]\n    vector<int> L(4, 1);\n\n    auto inRange = [&](int low, int high) {\n        // returns a random integer in [low, high], ensuring low <= high\n        if (low > high) return low; // fallback if invalid\n        return rnd.next(low, high);\n    };\n\n    // A small utility to ensure x >= 1 and x <= 100\n    auto clampLength = [&](int x){\n        if (x < 1) return 1;\n        if (x > 100) return 100;\n        return x;\n    };\n\n    if (type == \"random\") {\n        for(int i=0; i<4; i++){\n            L[i] = inRange(1, maxLen);\n        }\n    }\n    else if (type == \"smaller\") {\n        // Exactly one is at least 2x shorter than the other three.\n        // We'll pick an index i that is \"small\", then the others are big enough.\n        int smallIdx = rnd.next(0, 3);\n        // pick a small length\n        int smallLen = inRange(1, maxLen / 2 == 0 ? 1 : maxLen / 2);\n        L[smallIdx] = clampLength(smallLen);\n\n        // for each other j != smallIdx, ensure L[j] >= 2 * L[smallIdx]\n        for(int j=0; j<4; j++){\n            if (j == smallIdx) continue;\n            int bigLen = inRange(2 * smallLen, maxLen);\n            L[j]       = clampLength(bigLen);\n        }\n    }\n    else if (type == \"bigger\") {\n        // Exactly one is at least 2x longer than the other three.\n        int bigIdx = rnd.next(0, 3);\n        // first pick smaller lengths for others\n        // then pick bigLen >= 2 * (their max)\n        // step 1: pick the smaller 3\n        int lowLen1 = inRange(1, maxLen);\n        int lowLen2 = inRange(1, maxLen);\n        int lowLen3 = inRange(1, maxLen);\n        // find the max among these 3\n        int otherMax = max({lowLen1, lowLen2, lowLen3});\n        // step 2: pick bigLen\n        int bigLen   = inRange(2 * otherMax, maxLen);\n        if(bigLen < 1) bigLen = 1; \n        if(bigLen > 100) bigLen = 100;\n\n        // place them\n        // bigIdx gets bigLen\n        // others get the smaller\n        int idx=0;\n        for(int j=0; j<4; j++){\n            if(j == bigIdx) continue;\n            if(idx == 0) { L[j]=lowLen1; idx++; }\n            else if(idx==1){ L[j]=lowLen2; idx++;}\n            else { L[j]=lowLen3; idx++;}\n        }\n        L[bigIdx] = bigLen;\n    }\n    else if (type == \"multiplesmall\") {\n        // More than one choice is 2x smaller than the other(s).\n        // e.g. Two or three choices are all smaller than the rest.\n        // We'll do a simple fixed approach: pick two very small, two big.\n        // or create a random variant of that.\n        // For example: L0=1, L1=1, L2= in [2..maxLen], L3= in [2..maxLen]\n        // ensuring L2, L3 >= 2\n        L[0] = 1;\n        L[1] = 1;\n        L[2] = inRange(2, maxLen);\n        L[3] = inRange(2, maxLen);\n    }\n    else if (type == \"multiplebig\") {\n        // More than one choice is 2x bigger than the rest.\n        // We'll pick two very large, two small. Example:\n        // L0= in [1..x], L1= in [1..x], L2= ? >=2*( max(L0,L1) ), L3= ? >=2*( max(L0,L1))\n        int s1 = inRange(1, maxLen);\n        int s2 = inRange(1, maxLen);\n        int baseMax = max(s1, s2);\n        int b1 = inRange(2 * baseMax, maxLen);\n        int b2 = inRange(2 * baseMax, maxLen);\n        L[0] = s1;\n        L[1] = s2;\n        L[2] = b1;\n        L[3] = b2;\n    }\n    else if (type == \"none\") {\n        // No single choice is >=2x bigger or <=(1/2)x smaller than all others.\n        // We'll pick 4 lengths that do not differ by a factor of 2, e.g. 2,3,4,5 or something around a small range.\n        // We do it randomly but ensure ratio constraints are not triggered.\n        // E.g. pick an integer base in [2..maxLen-3], then do base, base+1, base+2, base+3 if they are <= maxLen\n        int base = inRange(1, maxLen - 3);\n        if(base < 1) base=1;\n        if(base+3>maxLen) base=1; \n        L[0] = base;\n        L[1] = base+1;\n        L[2] = base+2;\n        L[3] = base+3;\n    }\n    else if (type == \"same\") {\n        // All the same length\n        int lengthAll = inRange(1, maxLen);\n        for(int i=0; i<4; i++){\n            L[i] = lengthAll;\n        }\n    }\n    else if (type == \"borderline\") {\n        // Use extremes 1 and 100 (or up to maxLen if it's less than 100).\n        // We'll create a pattern: L0=1, L1=maxLen, L2=somewhere in [2..maxLen-1], L3=somewhere in [2..maxLen-1]\n        // This can catch boundary issues in solutions.\n        L[0] = 1;\n        L[1] = maxLen; // if maxLen <100, this is the borderline we have\n        int mid1 = inRange(2, maxLen-1 < 2 ? 2 : maxLen-1);\n        int mid2 = inRange(2, maxLen-1 < 2 ? 2 : maxLen-1);\n        L[2] = clampLength(mid1);\n        L[3] = clampLength(mid2);\n    }\n    else {\n        // If an unknown type is passed, fallback to random.\n        for(int i=0; i<4; i++){\n            L[i] = inRange(1, maxLen);\n        }\n    }\n\n    // Now we print out the final 4 lines.\n    // Prefixes must not be included in the length count, so \"A.\",\"B.\",\"C.\",\"D.\"\n    // are just printed. Then we append the random strings of lengths L[i].\n    static const char* prefix[4] = {\"A.\",\"B.\",\"C.\",\"D.\"};\n    for(int i=0; i<4; i++){\n        cout << prefix[i] << randomString(L[i]) << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -maxLen 5\n./gen -type random -maxLen 10\n./gen -type random -maxLen 20\n\n./gen -type smaller -maxLen 5\n./gen -type smaller -maxLen 10\n./gen -type bigger  -maxLen 5\n./gen -type bigger  -maxLen 10\n\n./gen -type multiplesmall -maxLen 10\n./gen -type multiplebig   -maxLen 10\n\n./gen -type none  -maxLen 5\n./gen -type none  -maxLen 10\n./gen -type none  -maxLen 20\n\n./gen -type same -maxLen 5\n./gen -type same -maxLen 10\n./gen -type same -maxLen 100\n\n./gen -type borderline -maxLen 5\n./gen -type borderline -maxLen 10\n./gen -type borderline -maxLen 50\n./gen -type borderline -maxLen 100\n\n./gen -type random -maxLen 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:08.650966",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "437/B",
      "title": "B. The Child and Set",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers: sum, limit (1 ≤ sum, limit ≤ 105).",
      "output_spec": "OutputIn the first line print an integer n (1 ≤ n ≤ 105), denoting the size of S. Then print the elements of set S in any order. If there are multiple answers, print any of them.If it's impossible to find a suitable set, print -1.",
      "sample_tests": "ExamplesInputCopy5 5OutputCopy24 5InputCopy4 3OutputCopy32 3 1InputCopy5 1OutputCopy-1",
      "description": "B. The Child and Set\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers: sum, limit (1 ≤ sum, limit ≤ 105).\n\nOutputIn the first line print an integer n (1 ≤ n ≤ 105), denoting the size of S. Then print the elements of set S in any order. If there are multiple answers, print any of them.If it's impossible to find a suitable set, print -1.\n\nInputCopy5 5OutputCopy24 5InputCopy4 3OutputCopy32 3 1InputCopy5 1OutputCopy-1\n\nInputCopy5 5\n\nOutputCopy24 5\n\nInputCopy4 3\n\nOutputCopy32 3 1\n\nInputCopy5 1\n\nOutputCopy-1\n\nNoteIn sample test 1: lowbit(4) = 4, lowbit(5) = 1, 4 + 1 = 5.In sample test 2: lowbit(1) = 1, lowbit(2) = 2, lowbit(3) = 1, 1 + 2 + 1 = 4.",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 437\\s*B"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int sum = inf.readInt(1, 100000, \"sum\");\n    inf.readSpace();\n    int limit = inf.readInt(1, 100000, \"limit\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int sum = inf.readInt(1, 100000, \"sum\");\n    inf.readSpace();\n    int limit = inf.readInt(1, 100000, \"limit\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int sum = inf.readInt(1, 100000, \"sum\");\n    inf.readSpace();\n    int limit = inf.readInt(1, 100000, \"limit\");\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPossible(int sum, int limit) {\n    const int MAX_LOG = 20;\n    vector<int> cnt(MAX_LOG, 0);\n    for (int x = 1; x <= limit; ++x) {\n        int low = x & -x;\n        int k = __builtin_ctz(low);\n        cnt[k]++;\n    }\n    vector<bool> dp(sum + 1, false);\n    dp[0] = true;\n    for (int k = 0; k < MAX_LOG; ++k) {\n        int lowbit = 1 << k;\n        int c = cnt[k];\n        for (int b = 1; c > 0; b <<= 1) {\n            int num = min(b, c);\n            int val = num * lowbit;\n            for (int s = sum; s >= val; --s) {\n                if (dp[s - val]) dp[s] = true;\n            }\n            c -= num;\n        }\n    }\n    return dp[sum];\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    // Read the sum and limit from the input file\n    int sum = inf.readInt();\n    int limit = inf.readInt();\n    \n    // Read the contestant's output\n    int n = ouf.readInt(-1, limit, \"n\");\n    if (n == -1) {\n        // Contestant reports impossible\n        if (isPossible(sum, limit)) {\n            quitf(_wa, \"Solution exists but contestant reports impossible\");\n        } else {\n            quitf(_ok, \"Correctly reports impossible\");\n        }\n    } else {\n        // Check that n is within valid range\n        if (n < 1 || n > limit)\n            quitf(_wa, \"Invalid size of S: n = %d\", n);\n        // Read n integers\n        vector<int> S = ouf.readInts(n, 1, limit, \"S\");\n        // Check that elements are distinct\n        set<int> S_set(S.begin(), S.end());\n        if ((int)S_set.size() != n) {\n            quitf(_wa, \"Elements of S are not distinct\");\n        }\n        // Compute sum over lowbit(x)\n        int s = 0;\n        for (int x : S) {\n            s += x & -x;\n        }\n        if (s != sum) {\n            quitf(_wa, \"Sum of lowbit(x) = %d, expected %d\", s, sum);\n        } else {\n            quitf(_ok, \"Correct answer\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int limit = opt<int>(\"limit\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(limit == -1)\n        limit = rnd.next(1, 100000);\n    else if(limit < 1 || limit > 100000) {\n        cerr << \"Error: limit must be between 1 and 100000\" << endl;\n        exit(1);\n    }\n\n    int sum = -1;\n\n    if (type == \"possible\") {\n        // sum should be less than or equal to limit\n        sum = rnd.next(1, limit);\n    } else if (type == \"impossible\") {\n        // sum greater than limit, but sum <= 100000\n        if (limit >= 100000) limit = 99999;\n        int extra = rnd.next(1, min(100000 - limit, 10));\n        sum = limit + extra;\n        if (sum > 100000) sum = 100000;\n    } else if (type == \"max_sum\") {\n        sum = limit;\n    } else if (type == \"min_sum\") {\n        sum = 1;\n    } else if (type == \"random\") {\n        // Random sum, possibly impossible\n        if (rnd.next(0, 1)) {\n            sum = rnd.next(1, limit);\n        } else {\n            if (limit >= 100000) limit = 99999;\n            int extra = rnd.next(1, min(100000 - limit, 10));\n            sum = limit + extra;\n            if (sum > 100000) sum = 100000;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", sum, limit);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int limit = opt<int>(\"limit\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    if(limit == -1)\n        limit = rnd.next(1, 100000);\n    else if(limit < 1 || limit > 100000) {\n        cerr << \"Error: limit must be between 1 and 100000\" << endl;\n        exit(1);\n    }\n\n    int sum = -1;\n\n    if (type == \"possible\") {\n        // sum should be less than or equal to limit\n        sum = rnd.next(1, limit);\n    } else if (type == \"impossible\") {\n        // sum greater than limit, but sum <= 100000\n        if (limit >= 100000) limit = 99999;\n        int extra = rnd.next(1, min(100000 - limit, 10));\n        sum = limit + extra;\n        if (sum > 100000) sum = 100000;\n    } else if (type == \"max_sum\") {\n        sum = limit;\n    } else if (type == \"min_sum\") {\n        sum = 1;\n    } else if (type == \"random\") {\n        // Random sum, possibly impossible\n        if (rnd.next(0, 1)) {\n            sum = rnd.next(1, limit);\n        } else {\n            if (limit >= 100000) limit = 99999;\n            int extra = rnd.next(1, min(100000 - limit, 10));\n            sum = limit + extra;\n            if (sum > 100000) sum = 100000;\n        }\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        exit(1);\n    }\n\n    printf(\"%d %d\\n\", sum, limit);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type possible -limit 1\n./gen -type possible -limit 10\n./gen -type possible -limit 100\n./gen -type possible -limit 1000\n./gen -type possible -limit 10000\n./gen -type possible -limit 100000\n\n./gen -type impossible -limit 1\n./gen -type impossible -limit 10\n./gen -type impossible -limit 100\n./gen -type impossible -limit 1000\n./gen -type impossible -limit 10000\n./gen -type impossible -limit 99999\n\n./gen -type max_sum -limit 1\n./gen -type max_sum -limit 10\n./gen -type max_sum -limit 100\n./gen -type max_sum -limit 1000\n./gen -type max_sum -limit 10000\n./gen -type max_sum -limit 100000\n\n./gen -type min_sum -limit 1\n./gen -type min_sum -limit 10\n./gen -type min_sum -limit 100\n./gen -type min_sum -limit 1000\n./gen -type min_sum -limit 10000\n./gen -type min_sum -limit 100000\n\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:10.985582",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "437/C",
      "title": "C. Ребенок и игрушка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа, n и m (1 ≤ n ≤ 1000; 0 ≤ m ≤ 2000). Во второй строке записано n целых чисел: v1, v2, ..., vn (0 ≤ vi ≤ 105). Затем следует m строк, в каждой записано по два целых числа, xi и yi, обозначающих веревочку, соединяющую детали xi и yi (1 ≤ xi, yi ≤ n; xi ≠ yi).Считайте, что все детали пронумерованы от 1 до n.",
      "output_spec": "Выходные данныеВыведите минимальную суммарную энергию, необходимую для отрывания всех n деталей игрушки.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 310 20 30 401 41 22 3Выходные данныеСкопировать40Входные данныеСкопировать4 4100 100 100 1001 22 32 43 4Выходные данныеСкопировать400Входные данныеСкопировать7 1040 10 20 10 20 80 401 54 74 55 25 76 41 61 34 31 4Выходные данныеСкопировать160",
      "description": "C. Ребенок и игрушка\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа, n и m (1 ≤ n ≤ 1000; 0 ≤ m ≤ 2000). Во второй строке записано n целых чисел: v1, v2, ..., vn (0 ≤ vi ≤ 105). Затем следует m строк, в каждой записано по два целых числа, xi и yi, обозначающих веревочку, соединяющую детали xi и yi (1 ≤ xi, yi ≤ n; xi ≠ yi).Считайте, что все детали пронумерованы от 1 до n.\n\nВходные данные\n\nВыходные данныеВыведите минимальную суммарную энергию, необходимую для отрывания всех n деталей игрушки.\n\nВыходные данные\n\nВходные данныеСкопировать4 310 20 30 401 41 22 3Выходные данныеСкопировать40Входные данныеСкопировать4 4100 100 100 1001 22 32 43 4Выходные данныеСкопировать400Входные данныеСкопировать7 1040 10 20 10 20 80 401 54 74 55 25 76 41 61 34 31 4Выходные данныеСкопировать160\n\nВходные данныеСкопировать4 310 20 30 401 41 22 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать40\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 4100 100 100 1001 22 32 43 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать400\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 1040 10 20 10 20 80 401 54 74 55 25 76 41 61 34 31 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать160\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОдна из оптимальных последовательностей действий в первом примере такова:  Сначала оторвите деталь 3, затрата энергии равна 20.  Затем оторвите деталь 2, затрата энергии равна 10.  Потом оторвите деталь 4, затрата энергии равна 10.  Наконец, оторвите деталь 1, затрата энергии равна 0. Таким образом, всего ребенок затрачивает 20 + 10 + 10 + 0 = 40 единиц энергии, это минимально возможный ответ.Во втором примере ребенок потратит 400 единиц энергии вне зависимости от порядка отрывания деталей.",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Поздравляю всех с днем защиты детей! Наверное, вы задаете себе вопрос: как отпраздновать этот необычный праздник? Конечно, написать очередной Codeforces Round — самый лучший выбор!Сегодня главным героем задач будет маленький ребенок. Он столкнулся с огромным количеством алгоритмических задач, сможете ли вы помочь ему?Приглашаем вас поучаствовать в Codeforces Round #250, который состоится в 17:00 первого июня в день защиты детей. Соревнование будет проводиться для участников обоих дивизионов.Обратите внимание на необычное время начала раунда. Вероятно, вам интересно почему время раунда не стандартное? Все потому что это очередной раунд, подготовленный командой авторов из Китая! Мы постарались приготовить для вас много интересных задач. Вы заинтригованы? Тогда не пропускайте раунд!Соревнование подготовлено группой авторов: delayyy, Picks и я. Это наш первый раунд Codeforces~~~~.Большое спасибо Gerald, за помощь с подготовкой раунда; а также спасибо ftiasch, Kissshot и jqdai0815, они тестировали задачи; традиционно благодарим MikeMirzayanov за создание замечательной платформы Codeforces.Разбалловка для первого дивизиона: 500-1000-1500-2000-3000.Разбалловка для второго дивизиона: 500-1500-1500-2000-2500.Не упустите шанс поднять свой рейтинг Codeforces! Желаем вам удачи и удовольствия от решения задач!UPD: Контест завершен! Поздравляем победителей!Top 5 участников Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 участников Div. 2: tohdon KFDong function348 104325EA Boyuede1 К сожалению, никто не решил задачу E в обоих дивизионах. Очень жаль.... Разбор будет опубликован очень скоро.UPD2: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1634
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 437\\s*C"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> vi = inf.readInts(n, 0, 100000, \"v_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d is a self-loop: xi = yi = %d\", i + 1, xi);\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n\n        ensuref(edges.count(make_pair(u, v)) == 0, \"Duplicate edge between %d and %d found at edge %d\", u, v, i + 1);\n        edges.insert(make_pair(u, v));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> vi = inf.readInts(n, 0, 100000, \"v_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d is a self-loop: xi = yi = %d\", i + 1, xi);\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n\n        ensuref(edges.count(make_pair(u, v)) == 0, \"Duplicate edge between %d and %d found at edge %d\", u, v, i + 1);\n        edges.insert(make_pair(u, v));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> vi = inf.readInts(n, 0, 100000, \"v_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n    for (int i = 0; i < m; i++) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Edge %d is a self-loop: xi = yi = %d\", i + 1, xi);\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n\n        ensuref(edges.count(make_pair(u, v)) == 0, \"Duplicate edge between %d and %d found at edge %d\", u, v, i + 1);\n        edges.insert(make_pair(u, v));\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string vtype = opt<string>(\"vtype\", \"random\");\n\n    const int MAX_V = 100000;\n\n    vector<int> v(n);\n    if (vtype == \"zeros\") {\n        for (int i = 0; i < n; ++i) v[i] = 0;\n    } else if (vtype == \"ones\") {\n        for (int i = 0; i < n; ++i) v[i] = 1;\n    } else if (vtype == \"max\") {\n        for (int i = 0; i < n; ++i) v[i] = MAX_V;\n    } else { // random\n        for (int i = 0; i < n; ++i) v[i] = rnd.next(0, MAX_V);\n    }\n\n    // Generate edges\n    set<pair<int,int>> edges_set;\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        if (n < 2) {\n            // no edges\n        } else {\n            for (int i = 1; i < n; ++i) {\n                int u = i - 1;\n                int v = i;\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n    } else if (type == \"star\") {\n        if (n < 2) {\n            // no edges\n        } else {\n            int center = 0;\n            for (int i = 1; i < n; ++i) {\n                int u = center;\n                int v = i;\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n    } else if (type == \"complete\") {\n        int max_edges = n * (n -1) / 2;\n        if (m == -1 || m > max_edges) m = max_edges;\n        for (int u = 0; u < n; ++u) {\n            for (int v = u+1; v < n; ++v) {\n                edges.push_back({u, v});\n                edges_set.insert({u, v});\n            }\n        }\n        // Shuffle and take m edges\n        shuffle(edges.begin(), edges.end());\n        edges.resize(min((int)edges.size(), m));\n    } else if (type == \"sparse\") {\n        // Minimal number of edges\n        if (m == -1) m = n - 1;\n        if (m > 2000) m = 2000; // ensure m ≤ 2000\n        // Create a spanning tree first\n        if (n >= 2) {\n            for (int i = 1; i < n; ++i) {\n                int u = rnd.next(0, i - 1);\n                int v = i;\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n        // Add random edges until reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(0, n -1);\n            int v = rnd.next(0, n -1);\n            if (u == v) continue;\n            pair<int,int> e = {min(u, v), max(u, v)};\n            if (edges_set.count(e)) continue;\n            edges_set.insert(e);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"disconnected\") {\n        // Create multiple components\n        if (m == -1) m = n - 1; // minimal edges\n        if (m > 2000) m = 2000;\n        int num_components = rnd.next(2, min(n, 10));\n        vector<vector<int>> components(num_components);\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            components[idx].push_back(i);\n            idx = (idx + 1) % num_components;\n        }\n        // For each component, create a spanning tree\n        for (auto &comp : components) {\n            if (comp.size() < 2) continue;\n            for (int i = 1; i < (int)comp.size(); ++i) {\n                int u = comp[i - 1];\n                int v = comp[i];\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n        // Add random edges until m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(0, n -1);\n            int v = rnd.next(0, n -1);\n            if (u == v) continue;\n            pair<int,int> e = {min(u, v), max(u, v)};\n            if (edges_set.count(e)) continue;\n            edges_set.insert(e);\n            edges.push_back(e);\n        }\n    } else { // random\n        int max_edges = n * (n -1) /2;\n        if (m == -1) m = rnd.next(0, min(2000, max_edges));\n        if (m > 2000) m = 2000;\n        while ((int)edges.size() < m) {\n            int u = rnd.next(0, n -1);\n            int v = rnd.next(0, n -1);\n            if (u == v) continue;\n            pair<int,int> e = {min(u, v), max(u, v)};\n            if (edges_set.count(e)) continue;\n            edges_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n\n    m = edges.size();\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output v_i's\n    for (int i = 0; i < n; ++i) printf(\"%d%c\", v[i], i == n - 1 ? '\\n' : ' ');\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the edges\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", edges[i].first +1, edges[i].second+1); // output 1-based indexing\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    string vtype = opt<string>(\"vtype\", \"random\");\n\n    const int MAX_V = 100000;\n\n    vector<int> v(n);\n    if (vtype == \"zeros\") {\n        for (int i = 0; i < n; ++i) v[i] = 0;\n    } else if (vtype == \"ones\") {\n        for (int i = 0; i < n; ++i) v[i] = 1;\n    } else if (vtype == \"max\") {\n        for (int i = 0; i < n; ++i) v[i] = MAX_V;\n    } else { // random\n        for (int i = 0; i < n; ++i) v[i] = rnd.next(0, MAX_V);\n    }\n\n    // Generate edges\n    set<pair<int,int>> edges_set;\n    vector<pair<int,int>> edges;\n\n    if (type == \"chain\") {\n        if (n < 2) {\n            // no edges\n        } else {\n            for (int i = 1; i < n; ++i) {\n                int u = i - 1;\n                int v = i;\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n    } else if (type == \"star\") {\n        if (n < 2) {\n            // no edges\n        } else {\n            int center = 0;\n            for (int i = 1; i < n; ++i) {\n                int u = center;\n                int v = i;\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n    } else if (type == \"complete\") {\n        int max_edges = n * (n -1) / 2;\n        if (m == -1 || m > max_edges) m = max_edges;\n        for (int u = 0; u < n; ++u) {\n            for (int v = u+1; v < n; ++v) {\n                edges.push_back({u, v});\n                edges_set.insert({u, v});\n            }\n        }\n        // Shuffle and take m edges\n        shuffle(edges.begin(), edges.end());\n        edges.resize(min((int)edges.size(), m));\n    } else if (type == \"sparse\") {\n        // Minimal number of edges\n        if (m == -1) m = n - 1;\n        if (m > 2000) m = 2000; // ensure m ≤ 2000\n        // Create a spanning tree first\n        if (n >= 2) {\n            for (int i = 1; i < n; ++i) {\n                int u = rnd.next(0, i - 1);\n                int v = i;\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n        // Add random edges until reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(0, n -1);\n            int v = rnd.next(0, n -1);\n            if (u == v) continue;\n            pair<int,int> e = {min(u, v), max(u, v)};\n            if (edges_set.count(e)) continue;\n            edges_set.insert(e);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"disconnected\") {\n        // Create multiple components\n        if (m == -1) m = n - 1; // minimal edges\n        if (m > 2000) m = 2000;\n        int num_components = rnd.next(2, min(n, 10));\n        vector<vector<int>> components(num_components);\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            components[idx].push_back(i);\n            idx = (idx + 1) % num_components;\n        }\n        // For each component, create a spanning tree\n        for (auto &comp : components) {\n            if (comp.size() < 2) continue;\n            for (int i = 1; i < (int)comp.size(); ++i) {\n                int u = comp[i - 1];\n                int v = comp[i];\n                edges.push_back({u, v});\n                edges_set.insert({min(u, v), max(u, v)});\n            }\n        }\n        // Add random edges until m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(0, n -1);\n            int v = rnd.next(0, n -1);\n            if (u == v) continue;\n            pair<int,int> e = {min(u, v), max(u, v)};\n            if (edges_set.count(e)) continue;\n            edges_set.insert(e);\n            edges.push_back(e);\n        }\n    } else { // random\n        int max_edges = n * (n -1) /2;\n        if (m == -1) m = rnd.next(0, min(2000, max_edges));\n        if (m > 2000) m = 2000;\n        while ((int)edges.size() < m) {\n            int u = rnd.next(0, n -1);\n            int v = rnd.next(0, n -1);\n            if (u == v) continue;\n            pair<int,int> e = {min(u, v), max(u, v)};\n            if (edges_set.count(e)) continue;\n            edges_set.insert(e);\n            edges.push_back(e);\n        }\n    }\n\n    m = edges.size();\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output v_i's\n    for (int i = 0; i < n; ++i) printf(\"%d%c\", v[i], i == n - 1 ? '\\n' : ' ');\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output the edges\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", edges[i].first +1, edges[i].second+1); // output 1-based indexing\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random -vtype zeros\n./gen -n 1 -type random -vtype ones\n./gen -n 1 -type random -vtype max\n\n./gen -n 2 -type chain -vtype random\n./gen -n 2 -type star -vtype random\n./gen -n 2 -type complete -vtype random\n\n./gen -n 10 -type chain -vtype zeros\n./gen -n 10 -type star -vtype ones\n./gen -n 10 -type complete -vtype max\n./gen -n 10 -type random -vtype random\n\n./gen -n 100 -type chain -vtype random\n./gen -n 100 -type star -vtype random\n./gen -n 100 -type complete -vtype random\n./gen -n 100 -type sparse -vtype random\n./gen -n 100 -type disconnected -vtype random\n./gen -n 100 -type random -vtype random\n\n./gen -n 500 -type chain -vtype zeros\n./gen -n 500 -type star -vtype max\n./gen -n 500 -type complete -vtype random\n./gen -n 500 -type sparse -vtype ones\n./gen -n 500 -type disconnected -vtype random\n./gen -n 500 -type random -vtype random\n\n./gen -n 999 -type chain -vtype random\n./gen -n 999 -type star -vtype random\n./gen -n 999 -type complete -vtype random\n./gen -n 999 -type sparse -vtype random\n./gen -n 999 -type disconnected -vtype random\n./gen -n 999 -type random -vtype random\n\n./gen -n 1000 -type chain -vtype random\n./gen -n 1000 -type star -vtype random\n./gen -n 1000 -type complete -vtype random\n./gen -n 1000 -type sparse -vtype random\n./gen -n 1000 -type disconnected -vtype random\n./gen -n 1000 -type random -vtype random\n\n# Edge cases with m specified\n./gen -n 1000 -m 0 -type random -vtype random\n./gen -n 1000 -m 1 -type random -vtype random\n./gen -n 1000 -m 2000 -type random -vtype random\n\n# Edge cases with v_i's all zero or max\n./gen -n 1000 -type random -vtype zeros\n./gen -n 1000 -type random -vtype max\n\n# Large sparse graphs\n./gen -n 1000 -m 999 -type sparse -vtype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:12.837153",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "437/D",
      "title": "D. Ребенок и зоопарк",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа, n и m (2 ≤ n ≤ 105; 0 ≤ m ≤ 105). Во второй строке записано n целых чисел: a1, a2, ..., an (0 ≤ ai ≤ 105). Затем следуют m строк, каждая строка содержит два целых числа, xi и yi (1 ≤ xi, yi ≤ n; xi ≠ yi), обозначающих дорогу между вольерами xi и yi.Все дороги двусторонние, каждая пара вольеров соединена не более чем одной дорогой.",
      "output_spec": "Выходные данныеВыведите вещественное число — значение .Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 4.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 310 20 30 401 32 34 3Выходные данныеСкопировать16.666667Входные данныеСкопировать3 310 20 301 22 33 1Выходные данныеСкопировать13.333333Входные данныеСкопировать7 840 20 10 30 20 50 401 22 33 44 55 66 71 45 7Выходные данныеСкопировать18.571429",
      "description": "D. Ребенок и зоопарк\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа, n и m (2 ≤ n ≤ 105; 0 ≤ m ≤ 105). Во второй строке записано n целых чисел: a1, a2, ..., an (0 ≤ ai ≤ 105). Затем следуют m строк, каждая строка содержит два целых числа, xi и yi (1 ≤ xi, yi ≤ n; xi ≠ yi), обозначающих дорогу между вольерами xi и yi.Все дороги двусторонние, каждая пара вольеров соединена не более чем одной дорогой.\n\nВходные данные\n\nВыходные данныеВыведите вещественное число — значение .Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 4.\n\nВыходные данные\n\nВходные данныеСкопировать4 310 20 30 401 32 34 3Выходные данныеСкопировать16.666667Входные данныеСкопировать3 310 20 301 22 33 1Выходные данныеСкопировать13.333333Входные данныеСкопировать7 840 20 10 30 20 50 401 22 33 44 55 66 71 45 7Выходные данныеСкопировать18.571429\n\nВходные данныеСкопировать4 310 20 30 401 32 34 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16.666667\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 310 20 301 22 33 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13.333333\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 840 20 10 30 20 50 401 22 33 44 55 66 71 45 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18.571429\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Существует 12 возможных пар вольеров:  p = 1, q = 3, f(p, q) = 10.  p = 2, q = 3, f(p, q) = 20.  p = 4, q = 3, f(p, q) = 30.  p = 1, q = 2, f(p, q) = 10.  p = 2, q = 4, f(p, q) = 20.  p = 4, q = 1, f(p, q) = 10. Еще 6 случаев симметричны приведенному выше. Среднее значение равно .Рассмотрим второй пример. Существует 6 возможных пар вольеров:  p = 1, q = 2, f(p, q) = 10.  p = 2, q = 3, f(p, q) = 20.  p = 1, q = 3, f(p, q) = 10. Еще 3 случая симметричны приведенному выше. Среднее значение равно .",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Поздравляю всех с днем защиты детей! Наверное, вы задаете себе вопрос: как отпраздновать этот необычный праздник? Конечно, написать очередной Codeforces Round — самый лучший выбор!Сегодня главным героем задач будет маленький ребенок. Он столкнулся с огромным количеством алгоритмических задач, сможете ли вы помочь ему?Приглашаем вас поучаствовать в Codeforces Round #250, который состоится в 17:00 первого июня в день защиты детей. Соревнование будет проводиться для участников обоих дивизионов.Обратите внимание на необычное время начала раунда. Вероятно, вам интересно почему время раунда не стандартное? Все потому что это очередной раунд, подготовленный командой авторов из Китая! Мы постарались приготовить для вас много интересных задач. Вы заинтригованы? Тогда не пропускайте раунд!Соревнование подготовлено группой авторов: delayyy, Picks и я. Это наш первый раунд Codeforces~~~~.Большое спасибо Gerald, за помощь с подготовкой раунда; а также спасибо ftiasch, Kissshot и jqdai0815, они тестировали задачи; традиционно благодарим MikeMirzayanov за создание замечательной платформы Codeforces.Разбалловка для первого дивизиона: 500-1000-1500-2000-3000.Разбалловка для второго дивизиона: 500-1500-1500-2000-2500.Не упустите шанс поднять свой рейтинг Codeforces! Желаем вам удачи и удовольствия от решения задач!UPD: Контест завершен! Поздравляем победителей!Top 5 участников Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 участников Div. 2: tohdon KFDong function348 104325EA Boyuede1 К сожалению, никто не решил задачу E в обоих дивизионах. Очень жаль.... Разбор будет опубликован очень скоро.UPD2: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1634
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 437\\s*D"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    // DSU\n    vector<int> parent(n+1);\n    for(int i=1; i<=n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if(parent[x]!=x)\n            parent[x]=find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x != y) {\n            parent[y] = x;\n        }\n    };\n\n    for(int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edges must connect different nodes (edge %d: %d == %d)\", i+1, x, y);\n        pair<int,int> edge = make_pair(min(x,y), max(x,y));\n        ensuref(edges.count(edge) == 0, \"Multiple edges between same pair of nodes (%d, %d)\", x, y);\n        edges.insert(edge);\n\n        unite(x, y);\n    }\n\n    // After processing all edges, check connectivity\n    int root = find(1);\n    for(int i=2; i<=n; ++i) {\n        ensuref(find(i) == root, \"The graph must be connected (%d is not connected to 1)\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    // DSU\n    vector<int> parent(n+1);\n    for(int i=1; i<=n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if(parent[x]!=x)\n            parent[x]=find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x != y) {\n            parent[y] = x;\n        }\n    };\n\n    for(int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edges must connect different nodes (edge %d: %d == %d)\", i+1, x, y);\n        pair<int,int> edge = make_pair(min(x,y), max(x,y));\n        ensuref(edges.count(edge) == 0, \"Multiple edges between same pair of nodes (%d, %d)\", x, y);\n        edges.insert(edge);\n\n        unite(x, y);\n    }\n\n    // After processing all edges, check connectivity\n    int root = find(1);\n    for(int i=2; i<=n; ++i) {\n        ensuref(find(i) == root, \"The graph must be connected (%d is not connected to 1)\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    set<pair<int,int>> edges;\n\n    // DSU\n    vector<int> parent(n+1);\n    for(int i=1; i<=n; ++i) parent[i] = i;\n\n    function<int(int)> find = [&](int x) {\n        if(parent[x]!=x)\n            parent[x]=find(parent[x]);\n        return parent[x];\n    };\n\n    auto unite = [&](int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x != y) {\n            parent[y] = x;\n        }\n    };\n\n    for(int i = 0; i < m; ++i) {\n        int x = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(x != y, \"Edges must connect different nodes (edge %d: %d == %d)\", i+1, x, y);\n        pair<int,int> edge = make_pair(min(x,y), max(x,y));\n        ensuref(edges.count(edge) == 0, \"Multiple edges between same pair of nodes (%d, %d)\", x, y);\n        edges.insert(edge);\n\n        unite(x, y);\n    }\n\n    // After processing all edges, check connectivity\n    int root = find(1);\n    for(int i=2; i<=n; ++i) {\n        ensuref(find(i) == root, \"The graph must be connected (%d is not connected to 1)\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string gtype = opt<string>(\"gtype\", \"random\");\n    string atype = opt<string>(\"atype\", \"random\");\n\n    // Adjust m if necessary\n    if (gtype == \"tree\" || gtype == \"path\" || gtype == \"star\") {\n        m = n - 1;\n    } else if (gtype == \"cycle\") {\n        m = n;\n    } else {\n        if (m < n - 1) {\n            m = n - 1;\n        } else {\n            long long max_edges = (long long)n * (n - 1) / 2;\n            if (max_edges > 1e5) max_edges = 1e5;\n            if (m > max_edges)\n                m = max_edges;\n        }\n    }\n\n    // Generate ai according to atype\n    vector<int> a(n);\n    if (atype == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (atype == \"all_max\") {\n        fill(a.begin(), a.end(), 100000);\n    } else if (atype == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(100000, i + 1); // Ensure ai ≤ 1e5\n    } else if (atype == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(100000, n - i); // Ensure ai ≤ 1e5\n    } else if (atype == \"random_small\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 10);\n    } else if (atype == \"random_large\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(99990, 100000);\n    } else { // \"random\"\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000);\n    }\n\n    // Generate edges\n    vector<pii> edges;\n\n    if (gtype == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (gtype == \"path\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (gtype == \"cycle\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n, 1});\n    } else if (gtype == \"tree\") {\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i -1);\n            edges.push_back({i, parent});\n        }\n    } else { // \"random\" or \"dense\"\n        // First, generate a spanning tree to ensure connectedness\n        vector<int> p(n + 1);\n        for (int i = 1; i <= n; ++i)\n            p[i] = i;\n\n        // Union-Find functions\n        function<int(int)> find = [&](int x) {\n            return p[x] == x ? x : p[x] = find(p[x]);\n        };\n        auto unite = [&](int x, int y) {\n            int fx = find(x), fy = find(y);\n            if (fx != fy)\n                p[fx] = fy;\n        };\n\n        set<pii> edge_set;\n        for (int i = 0; i < n - 1; ) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int fu = find(u), fv = find(v);\n            if (fu != fv) {\n                unite(u, v);\n                if (u > v) swap(u, v);\n                edge_set.insert({u, v});\n                ++i;\n            }\n        }\n        // Add extra edges\n        for (int i = n - 1; i < m; ) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            ++i;\n        }\n        // Convert set to vector\n        for (const auto& e : edge_set)\n            edges.push_back(e);\n    }\n\n    // Shuffle node indices\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i + 1;\n    shuffle(perm.begin(), perm.end());\n\n    map<int,int> mapping;\n    for (int i = 0; i < n; ++i)\n        mapping[i + 1] = perm[i];\n\n    // Apply permutation to edges\n    for (auto& e : edges) {\n        e.first = mapping[e.first];\n        e.second = mapping[e.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[perm[i] -1], i == n -1 ? '\\n' : ' ');\n    for (const auto& e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string gtype = opt<string>(\"gtype\", \"random\");\n    string atype = opt<string>(\"atype\", \"random\");\n\n    // Adjust m if necessary\n    if (gtype == \"tree\" || gtype == \"path\" || gtype == \"star\") {\n        m = n - 1;\n    } else if (gtype == \"cycle\") {\n        m = n;\n    } else {\n        if (m < n - 1) {\n            m = n - 1;\n        } else {\n            long long max_edges = (long long)n * (n - 1) / 2;\n            if (max_edges > 1e5) max_edges = 1e5;\n            if (m > max_edges)\n                m = max_edges;\n        }\n    }\n\n    // Generate ai according to atype\n    vector<int> a(n);\n    if (atype == \"all_zero\") {\n        fill(a.begin(), a.end(), 0);\n    } else if (atype == \"all_max\") {\n        fill(a.begin(), a.end(), 100000);\n    } else if (atype == \"ascending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(100000, i + 1); // Ensure ai ≤ 1e5\n    } else if (atype == \"descending\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = min(100000, n - i); // Ensure ai ≤ 1e5\n    } else if (atype == \"random_small\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 10);\n    } else if (atype == \"random_large\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(99990, 100000);\n    } else { // \"random\"\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(0, 100000);\n    }\n\n    // Generate edges\n    vector<pii> edges;\n\n    if (gtype == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (gtype == \"path\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n    } else if (gtype == \"cycle\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i+1});\n        }\n        edges.push_back({n, 1});\n    } else if (gtype == \"tree\") {\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i -1);\n            edges.push_back({i, parent});\n        }\n    } else { // \"random\" or \"dense\"\n        // First, generate a spanning tree to ensure connectedness\n        vector<int> p(n + 1);\n        for (int i = 1; i <= n; ++i)\n            p[i] = i;\n\n        // Union-Find functions\n        function<int(int)> find = [&](int x) {\n            return p[x] == x ? x : p[x] = find(p[x]);\n        };\n        auto unite = [&](int x, int y) {\n            int fx = find(x), fy = find(y);\n            if (fx != fy)\n                p[fx] = fy;\n        };\n\n        set<pii> edge_set;\n        for (int i = 0; i < n - 1; ) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            int fu = find(u), fv = find(v);\n            if (fu != fv) {\n                unite(u, v);\n                if (u > v) swap(u, v);\n                edge_set.insert({u, v});\n                ++i;\n            }\n        }\n        // Add extra edges\n        for (int i = n - 1; i < m; ) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n            ++i;\n        }\n        // Convert set to vector\n        for (const auto& e : edge_set)\n            edges.push_back(e);\n    }\n\n    // Shuffle node indices\n    vector<int> perm(n);\n    for (int i = 0; i < n; ++i)\n        perm[i] = i + 1;\n    shuffle(perm.begin(), perm.end());\n\n    map<int,int> mapping;\n    for (int i = 0; i < n; ++i)\n        mapping[i + 1] = perm[i];\n\n    // Apply permutation to edges\n    for (auto& e : edges) {\n        e.first = mapping[e.first];\n        e.second = mapping[e.second];\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[perm[i] -1], i == n -1 ? '\\n' : ' ');\n    for (const auto& e : edges)\n        printf(\"%d %d\\n\", e.first, e.second);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -gtype path -atype all_zero\n./gen -n 3 -m 2 -gtype path -atype all_max\n./gen -n 4 -m 3 -gtype star -atype ascending\n./gen -n 5 -m 5 -gtype cycle -atype descending\n./gen -n 10 -m 9 -gtype tree -atype random_small\n./gen -n 1000 -m 999 -gtype path -atype random_large\n./gen -n 1000 -m 1000 -gtype cycle -atype random\n./gen -n 1000 -m 100000 -gtype random -atype random\n./gen -n 100000 -m 100000 -gtype random -atype random\n./gen -n 100000 -m 100000 -gtype random -atype all_zero\n./gen -n 100000 -m 100000 -gtype random -atype all_max\n./gen -n 100000 -m 100000 -gtype random -atype ascending\n./gen -n 100000 -m 100000 -gtype random -atype descending\n./gen -n 100000 -m 100000 -gtype random -atype random_small\n./gen -n 100000 -m 100000 -gtype random -atype random_large\n./gen -n 100000 -m 100000 -gtype star -atype random\n./gen -n 100000 -m 100000 -gtype cycle -atype random\n./gen -n 50000 -m 100000 -gtype random -atype random\n./gen -n 100000 -m 99999 -gtype path -atype random\n./gen -n 2 -m 1 -gtype star -atype random_small\n./gen -n 2 -m 1 -gtype tree -atype random_large\n./gen -n 3 -m 3 -gtype cycle -atype random\n./gen -n 4 -m 6 -gtype random -atype ascending\n./gen -n 4 -m 6 -gtype random -atype descending\n./gen -n 5 -m 10 -gtype random -atype random_small\n./gen -n 100000 -m 100000 -gtype random -atype random_small\n./gen -n 100000 -m 100000 -gtype random -atype random_large\n./gen -n 50000 -m 50000 -gtype random -atype random\n./gen -n 50000 -m 60000 -gtype random -atype random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:14.849240",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "437/E",
      "title": "E. The Child and Polygon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer n (3 ≤ n ≤ 200) — the number of vertices of the polygon. Then follow n lines, each line containing two integers. The i-th line contains xi, yi (|xi|, |yi| ≤ 107) — the i-th vertex of the polygon in clockwise or counterclockwise order.It's guaranteed that the polygon is simple.",
      "output_spec": "OutputOutput the number of ways modulo 1000000007 (109  +  7).",
      "sample_tests": "ExamplesInputCopy40 00 11 11 0OutputCopy2InputCopy40 01 00 1-1 0OutputCopy1InputCopy50 01 01 10 1-2 -1OutputCopy3",
      "description": "E. The Child and Polygon\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer n (3 ≤ n ≤ 200) — the number of vertices of the polygon. Then follow n lines, each line containing two integers. The i-th line contains xi, yi (|xi|, |yi| ≤ 107) — the i-th vertex of the polygon in clockwise or counterclockwise order.It's guaranteed that the polygon is simple.\n\nOutputOutput the number of ways modulo 1000000007 (109  +  7).\n\nInputCopy40 00 11 11 0OutputCopy2InputCopy40 01 00 1-1 0OutputCopy1InputCopy50 01 01 10 1-2 -1OutputCopy3\n\nInputCopy40 00 11 11 0\n\nOutputCopy2\n\nInputCopy40 01 00 1-1 0\n\nOutputCopy1\n\nInputCopy50 01 01 10 1-2 -1\n\nOutputCopy3\n\nNoteIn the first sample, there are two possible splittings:  In the second sample, there are only one possible splitting:",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 437\\s*E"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n    int x, y;\n    Point(int x=0, int y=0): x(x), y(y) {}\n};\n\nint orientation(Point p, Point q, Point r) {\n    int64_t val = int64_t(q.y - p.y) * (r.x - q.x) - int64_t(q.x - p.x)*(r.y - q.y);\n    if (val == 0) return 0;  // colinear\n    return (val > 0)? 1: 2;  // clockwise or counterclock wise\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    if (min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&\n        min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y))\n        return true;\n    return false;\n}\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    // Find the four orientations needed for general and special cases\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false; // Doesn't fall in any of the above cases\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n\n    vector<Point> polygon(n);\n    set<pair<int, int>> point_set;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-10000000, 10000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-10000000, 10000000, \"y_i\");\n        inf.readEoln();\n        auto res = point_set.insert({x, y});\n        ensuref(res.second, \"Point (%d, %d) is repeated at position %d\", x, y, i+1);\n        polygon[i] = Point(x, y);\n    }\n\n    // Check that the polygon is simple\n    for(int i = 0; i < n; ++i) {\n        Point a1 = polygon[i];\n        Point a2 = polygon[(i+1)%n];\n        for(int j = i+1; j < n; ++j) {\n            if ((i+1)%n == j || i == (j+1)%n)\n                continue; // Adjacent edges, skip\n            Point b1 = polygon[j];\n            Point b2 = polygon[(j+1)%n];\n\n            if (segmentsIntersect(a1, a2, b1, b2)) {\n                ensuref(false, \"Polygon is not simple: edges %d-%d and %d-%d intersect\", i+1, ((i+1)%n)+1, j+1, ((j+1)%n)+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n    int x, y;\n    Point(int x=0, int y=0): x(x), y(y) {}\n};\n\nint orientation(Point p, Point q, Point r) {\n    int64_t val = int64_t(q.y - p.y) * (r.x - q.x) - int64_t(q.x - p.x)*(r.y - q.y);\n    if (val == 0) return 0;  // colinear\n    return (val > 0)? 1: 2;  // clockwise or counterclock wise\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    if (min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&\n        min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y))\n        return true;\n    return false;\n}\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    // Find the four orientations needed for general and special cases\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false; // Doesn't fall in any of the above cases\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n\n    vector<Point> polygon(n);\n    set<pair<int, int>> point_set;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-10000000, 10000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-10000000, 10000000, \"y_i\");\n        inf.readEoln();\n        auto res = point_set.insert({x, y});\n        ensuref(res.second, \"Point (%d, %d) is repeated at position %d\", x, y, i+1);\n        polygon[i] = Point(x, y);\n    }\n\n    // Check that the polygon is simple\n    for(int i = 0; i < n; ++i) {\n        Point a1 = polygon[i];\n        Point a2 = polygon[(i+1)%n];\n        for(int j = i+1; j < n; ++j) {\n            if ((i+1)%n == j || i == (j+1)%n)\n                continue; // Adjacent edges, skip\n            Point b1 = polygon[j];\n            Point b2 = polygon[(j+1)%n];\n\n            if (segmentsIntersect(a1, a2, b1, b2)) {\n                ensuref(false, \"Polygon is not simple: edges %d-%d and %d-%d intersect\", i+1, ((i+1)%n)+1, j+1, ((j+1)%n)+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n    int x, y;\n    Point(int x=0, int y=0): x(x), y(y) {}\n};\n\nint orientation(Point p, Point q, Point r) {\n    int64_t val = int64_t(q.y - p.y) * (r.x - q.x) - int64_t(q.x - p.x)*(r.y - q.y);\n    if (val == 0) return 0;  // colinear\n    return (val > 0)? 1: 2;  // clockwise or counterclock wise\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    if (min(p.x, r.x) <= q.x && q.x <= max(p.x, r.x) &&\n        min(p.y, r.y) <= q.y && q.y <= max(p.y, r.y))\n        return true;\n    return false;\n}\n\nbool segmentsIntersect(Point p1, Point q1, Point p2, Point q2) {\n    // Find the four orientations needed for general and special cases\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false; // Doesn't fall in any of the above cases\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n\n    vector<Point> polygon(n);\n    set<pair<int, int>> point_set;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(-10000000, 10000000, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(-10000000, 10000000, \"y_i\");\n        inf.readEoln();\n        auto res = point_set.insert({x, y});\n        ensuref(res.second, \"Point (%d, %d) is repeated at position %d\", x, y, i+1);\n        polygon[i] = Point(x, y);\n    }\n\n    // Check that the polygon is simple\n    for(int i = 0; i < n; ++i) {\n        Point a1 = polygon[i];\n        Point a2 = polygon[(i+1)%n];\n        for(int j = i+1; j < n; ++j) {\n            if ((i+1)%n == j || i == (j+1)%n)\n                continue; // Adjacent edges, skip\n            Point b1 = polygon[j];\n            Point b2 = polygon[(j+1)%n];\n\n            if (segmentsIntersect(a1, a2, b1, b2)) {\n                ensuref(false, \"Polygon is not simple: edges %d-%d and %d-%d intersect\", i+1, ((i+1)%n)+1, j+1, ((j+1)%n)+1);\n            }\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nvoid generate_convex_polygon(int n, int max_coord, vector<pair<int, int>>& polygon) {\n    vector<double> angles(n);\n    for (int i = 0; i < n; ++i) {\n        angles[i] = rnd.next(0.0, 2*PI);\n    }\n    sort(angles.begin(), angles.end());\n    double min_radius = max_coord * 0.3;\n    double max_radius = max_coord * 1.0;\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double radius = rnd.next(min_radius, max_radius);\n        int x = (int)(radius * cos(angle));\n        int y = (int)(radius * sin(angle));\n        polygon.push_back({x, y});\n    }\n}\n\nvoid generate_concave_polygon(int n, int max_coord, vector<pair<int,int>>& polygon) {\n    // First generate convex polygon\n    vector<double> angles(n);\n    for (int i = 0; i < n; ++i) {\n        angles[i] = rnd.next(0.0, 2*PI);\n    }\n    sort(angles.begin(), angles.end());\n    vector<pair<double, double>> points;\n    double min_radius = max_coord * 0.5;\n    double max_radius = max_coord * 1.0;\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double radius = rnd.next(min_radius, max_radius);\n        double x = radius * cos(angle);\n        double y = radius * sin(angle);\n        points.push_back({x, y});\n    }\n\n    // Move one point toward the center to create a concavity\n    int idx = rnd.next(1, n-2); // avoid first and last point\n    points[idx].first *= rnd.next(0.1, 0.5);\n    points[idx].second *= rnd.next(0.1, 0.5);\n\n    // Convert to integer coordinates\n    for (int i = 0; i < n; ++i) {\n        int x = (int)(points[i].first);\n        int y = (int)(points[i].second);\n        polygon.push_back({x, y});\n    }\n}\n\nvoid generate_small_polygon(int n, vector<pair<int,int>>& polygon) {\n    if (n == 3) {\n        polygon.push_back({0, 0});\n        polygon.push_back({1, 0});\n        polygon.push_back({0, 1});\n    } else if (n == 4) {\n        polygon.push_back({0, 0});\n        polygon.push_back({1, 0});\n        polygon.push_back({1, 1});\n        polygon.push_back({0, 1});\n    } else if (n ==5) {\n        // Regular pentagon\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * PI * i / n;\n            int x = (int)(100 * cos(angle));\n            int y = (int)(100 * sin(angle));\n            polygon.push_back({x, y});\n        }\n    } else {\n        // For n >5, generate convex polygon\n        generate_convex_polygon(n, 1000, polygon);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n    int max_coord = opt<int>(\"max_coord\", 10000000);\n\n    vector<pair<int, int>> polygon;\n\n    if (type == \"convex\") {\n        generate_convex_polygon(n, max_coord, polygon);\n    } else if (type == \"concave\") {\n        generate_concave_polygon(n, max_coord, polygon);\n    } else if (type == \"small\") {\n        generate_small_polygon(n, polygon);\n    } else {\n        // default: convex\n        generate_convex_polygon(n, max_coord, polygon);\n    }\n\n    // Output the polygon\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", polygon[i].first, polygon[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst double PI = acos(-1.0);\n\nvoid generate_convex_polygon(int n, int max_coord, vector<pair<int, int>>& polygon) {\n    vector<double> angles(n);\n    for (int i = 0; i < n; ++i) {\n        angles[i] = rnd.next(0.0, 2*PI);\n    }\n    sort(angles.begin(), angles.end());\n    double min_radius = max_coord * 0.3;\n    double max_radius = max_coord * 1.0;\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double radius = rnd.next(min_radius, max_radius);\n        int x = (int)(radius * cos(angle));\n        int y = (int)(radius * sin(angle));\n        polygon.push_back({x, y});\n    }\n}\n\nvoid generate_concave_polygon(int n, int max_coord, vector<pair<int,int>>& polygon) {\n    // First generate convex polygon\n    vector<double> angles(n);\n    for (int i = 0; i < n; ++i) {\n        angles[i] = rnd.next(0.0, 2*PI);\n    }\n    sort(angles.begin(), angles.end());\n    vector<pair<double, double>> points;\n    double min_radius = max_coord * 0.5;\n    double max_radius = max_coord * 1.0;\n    for (int i = 0; i < n; ++i) {\n        double angle = angles[i];\n        double radius = rnd.next(min_radius, max_radius);\n        double x = radius * cos(angle);\n        double y = radius * sin(angle);\n        points.push_back({x, y});\n    }\n\n    // Move one point toward the center to create a concavity\n    int idx = rnd.next(1, n-2); // avoid first and last point\n    points[idx].first *= rnd.next(0.1, 0.5);\n    points[idx].second *= rnd.next(0.1, 0.5);\n\n    // Convert to integer coordinates\n    for (int i = 0; i < n; ++i) {\n        int x = (int)(points[i].first);\n        int y = (int)(points[i].second);\n        polygon.push_back({x, y});\n    }\n}\n\nvoid generate_small_polygon(int n, vector<pair<int,int>>& polygon) {\n    if (n == 3) {\n        polygon.push_back({0, 0});\n        polygon.push_back({1, 0});\n        polygon.push_back({0, 1});\n    } else if (n == 4) {\n        polygon.push_back({0, 0});\n        polygon.push_back({1, 0});\n        polygon.push_back({1, 1});\n        polygon.push_back({0, 1});\n    } else if (n ==5) {\n        // Regular pentagon\n        for (int i = 0; i < n; ++i) {\n            double angle = 2 * PI * i / n;\n            int x = (int)(100 * cos(angle));\n            int y = (int)(100 * sin(angle));\n            polygon.push_back({x, y});\n        }\n    } else {\n        // For n >5, generate convex polygon\n        generate_convex_polygon(n, 1000, polygon);\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n    int max_coord = opt<int>(\"max_coord\", 10000000);\n\n    vector<pair<int, int>> polygon;\n\n    if (type == \"convex\") {\n        generate_convex_polygon(n, max_coord, polygon);\n    } else if (type == \"concave\") {\n        generate_concave_polygon(n, max_coord, polygon);\n    } else if (type == \"small\") {\n        generate_small_polygon(n, polygon);\n    } else {\n        // default: convex\n        generate_convex_polygon(n, max_coord, polygon);\n    }\n\n    // Output the polygon\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", polygon[i].first, polygon[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small polygons\n./gen -n 3 -type small\n./gen -n 4 -type small\n./gen -n 5 -type small\n\n# Convex polygons with varying n\n./gen -n 10 -type convex\n./gen -n 25 -type convex\n./gen -n 50 -type convex\n./gen -n 75 -type convex\n./gen -n 100 -type convex\n./gen -n 150 -type convex\n./gen -n 200 -type convex\n\n# Concave polygons with varying n\n./gen -n 5 -type concave\n./gen -n 10 -type concave\n./gen -n 25 -type concave\n./gen -n 50 -type concave\n./gen -n 75 -type concave\n./gen -n 100 -type concave\n./gen -n 150 -type concave\n./gen -n 200 -type concave\n\n# Polygons with maximum coordinates\n./gen -n 50 -type convex -max_coord 10000000\n./gen -n 100 -type convex -max_coord 10000000\n./gen -n 200 -type convex -max_coord 10000000\n\n# Polygons with small coordinate values\n./gen -n 50 -type convex -max_coord 10\n./gen -n 100 -type convex -max_coord 10\n\n# Default type (convex)\n./gen -n 50\n./gen -n 100\n./gen -n 200\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:16.740929",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "438/A",
      "title": "A. The Child and Toy",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n ≤ 1000; 0 ≤ m ≤ 2000). The second line contains n integers: v1, v2, ..., vn (0 ≤ vi ≤ 105). Then followed m lines, each line contains two integers xi and yi, representing a rope from part xi to part yi (1 ≤ xi, yi ≤ n; xi ≠ yi).Consider all the parts are numbered from 1 to n.",
      "output_spec": "OutputOutput the minimum total energy the child should spend to remove all n parts of the toy.",
      "sample_tests": "ExamplesInputCopy4 310 20 30 401 41 22 3OutputCopy40InputCopy4 4100 100 100 1001 22 32 43 4OutputCopy400InputCopy7 1040 10 20 10 20 80 401 54 74 55 25 76 41 61 34 31 4OutputCopy160",
      "description": "A. The Child and Toy\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n ≤ 1000; 0 ≤ m ≤ 2000). The second line contains n integers: v1, v2, ..., vn (0 ≤ vi ≤ 105). Then followed m lines, each line contains two integers xi and yi, representing a rope from part xi to part yi (1 ≤ xi, yi ≤ n; xi ≠ yi).Consider all the parts are numbered from 1 to n.\n\nOutputOutput the minimum total energy the child should spend to remove all n parts of the toy.\n\nInputCopy4 310 20 30 401 41 22 3OutputCopy40InputCopy4 4100 100 100 1001 22 32 43 4OutputCopy400InputCopy7 1040 10 20 10 20 80 401 54 74 55 25 76 41 61 34 31 4OutputCopy160\n\nInputCopy4 310 20 30 401 41 22 3\n\nOutputCopy40\n\nInputCopy4 4100 100 100 1001 22 32 43 4\n\nOutputCopy400\n\nInputCopy7 1040 10 20 10 20 80 401 54 74 55 25 76 41 61 34 31 4\n\nOutputCopy160\n\nNoteOne of the optimal sequence of actions in the first sample is:  First, remove part 3, cost of the action is 20.  Then, remove part 2, cost of the action is 10.  Next, remove part 4, cost of the action is 10.  At last, remove part 1, cost of the action is 0. So the total energy the child paid is 20 + 10 + 10 + 0 = 40, which is the minimum.In the second sample, the child will spend 400 no matter in what order he will remove the parts.",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 438 和字母"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, 0, 100000, \"v_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(x != y, \"xi and yi must be different on line %d\", i + 3);\n\n        int u = min(x, y);\n        int w = max(x, y);\n\n        ensuref(edgeSet.find({u, w}) == edgeSet.end(), \"Multiple edges between %d and %d\", u, w);\n        edgeSet.insert({u, w});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, 0, 100000, \"v_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(x != y, \"xi and yi must be different on line %d\", i + 3);\n\n        int u = min(x, y);\n        int w = max(x, y);\n\n        ensuref(edgeSet.find({u, w}) == edgeSet.end(), \"Multiple edges between %d and %d\", u, w);\n        edgeSet.insert({u, w});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 2000, \"m\");\n    inf.readEoln();\n\n    vector<int> v = inf.readInts(n, 0, 100000, \"v_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    for (int i = 0; i < m; i++) {\n        int x = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(x != y, \"xi and yi must be different on line %d\", i + 3);\n\n        int u = min(x, y);\n        int w = max(x, y);\n\n        ensuref(edgeSet.find({u, w}) == edgeSet.end(), \"Multiple edges between %d and %d\", u, w);\n        edgeSet.insert({u, w});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default -1, compute based on graph_type if m not provided\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string vi_type = opt<string>(\"vi_type\", \"random\");\n    int vi_min = opt<int>(\"vi_min\", 0);\n    int vi_max = opt<int>(\"vi_max\", 100000);\n    int vi_value = opt<int>(\"vi_value\", 0); // for constant vi_type\n\n    // Generate vi\n    vector<int> vi(n);\n    if (vi_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = rnd.next(vi_min, vi_max);\n    } else if (vi_type == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = 0;\n    } else if (vi_type == \"constant\") {\n        vi_value = opt<int>(\"vi_value\", 0); // default 0\n        for (int i = 0; i < n; ++i)\n            vi[i] = vi_value;\n    } else if (vi_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = vi_min + (vi_max - vi_min) * i / max(n - 1, 1);\n    } else if (vi_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = vi_max - (vi_max - vi_min) * i / max(n - 1, 1);\n    } else {\n        cerr << \"Invalid vi_type\" << endl;\n        return 1;\n    }\n\n    // Generate edges based on graph_type\n    set<pair<int, int>> edges_set;\n    vector<pair<int, int>> edges;\n    int max_edges = n * (n - 1) / 2;\n    max_edges = min(max_edges, 2000); // m ≤ 2000\n\n    if (graph_type == \"complete\") {\n        if (m == -1 || m > max_edges) m = max_edges;\n        for (int i = 0; i < n && edges.size() < m; ++i) {\n            for (int j = i + 1; j < n && edges.size() < m; ++j) {\n                edges.push_back({i + 1, j + 1});\n            }\n        }\n    } else if (graph_type == \"star\") {\n        if (m == -1) m = n - 1;\n        if (m > n - 1) m = n - 1;\n        for (int i = 1; i < n && edges.size() < m; ++i) {\n            edges.push_back({1, i + 1});\n        }\n    } else if (graph_type == \"path\") {\n        if (m == -1) m = n - 1;\n        for (int i = 0; i < n - 1 && edges.size() < m; ++i) {\n            edges.push_back({i + 1, i + 2});\n        }\n    } else if (graph_type == \"cycle\") {\n        if (m == -1) m = n;\n        for (int i = 0; i < n - 1 && edges.size() < m; ++i) {\n            edges.push_back({i + 1, i + 2});\n        }\n        if(edges.size() < m && n > 2) {\n            edges.push_back({n, 1});\n        }\n    } else if (graph_type == \"tree\") {\n        if (m == -1) m = n - 1;\n        // Generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i + 1;\n            int v = rnd.next(1, i); // connect to any previous node\n            edges.push_back({u, v});\n        }\n    } else if (graph_type == \"random\") {\n        if (m == -1 || m > max_edges) m = rnd.next(0, max_edges);\n        // Generate random edges\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = {u, v};\n            if (edges_set.count(edge)) continue;\n            edges_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } else if (graph_type == \"connected\") {\n        // First create a spanning tree\n        // m must be at least n-1\n        if (m == -1) m = n - 1;\n        if (m < n -1) {\n            cerr << \"Cannot generate connected graph with m < n - 1\" << endl;\n            return 1;\n        }\n        if (m > max_edges) m = max_edges;\n        // Use union-find to avoid cycles\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        auto unite = [&](int x, int y) {\n            x = find(x); y = find(y);\n            if (x != y) parent[x] = y;\n        };\n        // Build a random spanning tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i -1);\n            unite(u, v);\n            edges.push_back({u, v});\n            edges_set.insert({min(u, v), max(u, v)});\n        }\n        // Now add random edges\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = {u, v};\n            if (edges_set.count(edge)) continue;\n            edges_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } else if (graph_type == \"disconnected\") {\n        // Generate components\n        if (m == -1) m = 0;\n        if (m > max_edges) m = max_edges;\n        // For simplicity, create isolated nodes and random edges that don't necessarily connect the graph\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = {u, v};\n            if (edges_set.count(edge)) continue;\n            edges_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } else {\n        cerr << \"Invalid graph_type\" << endl;\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output vi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", vi[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default -1, compute based on graph_type if m not provided\n    string graph_type = opt<string>(\"graph_type\", \"random\");\n    string vi_type = opt<string>(\"vi_type\", \"random\");\n    int vi_min = opt<int>(\"vi_min\", 0);\n    int vi_max = opt<int>(\"vi_max\", 100000);\n    int vi_value = opt<int>(\"vi_value\", 0); // for constant vi_type\n\n    // Generate vi\n    vector<int> vi(n);\n    if (vi_type == \"random\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = rnd.next(vi_min, vi_max);\n    } else if (vi_type == \"zero\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = 0;\n    } else if (vi_type == \"constant\") {\n        vi_value = opt<int>(\"vi_value\", 0); // default 0\n        for (int i = 0; i < n; ++i)\n            vi[i] = vi_value;\n    } else if (vi_type == \"increasing\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = vi_min + (vi_max - vi_min) * i / max(n - 1, 1);\n    } else if (vi_type == \"decreasing\") {\n        for (int i = 0; i < n; ++i)\n            vi[i] = vi_max - (vi_max - vi_min) * i / max(n - 1, 1);\n    } else {\n        cerr << \"Invalid vi_type\" << endl;\n        return 1;\n    }\n\n    // Generate edges based on graph_type\n    set<pair<int, int>> edges_set;\n    vector<pair<int, int>> edges;\n    int max_edges = n * (n - 1) / 2;\n    max_edges = min(max_edges, 2000); // m ≤ 2000\n\n    if (graph_type == \"complete\") {\n        if (m == -1 || m > max_edges) m = max_edges;\n        for (int i = 0; i < n && edges.size() < m; ++i) {\n            for (int j = i + 1; j < n && edges.size() < m; ++j) {\n                edges.push_back({i + 1, j + 1});\n            }\n        }\n    } else if (graph_type == \"star\") {\n        if (m == -1) m = n - 1;\n        if (m > n - 1) m = n - 1;\n        for (int i = 1; i < n && edges.size() < m; ++i) {\n            edges.push_back({1, i + 1});\n        }\n    } else if (graph_type == \"path\") {\n        if (m == -1) m = n - 1;\n        for (int i = 0; i < n - 1 && edges.size() < m; ++i) {\n            edges.push_back({i + 1, i + 2});\n        }\n    } else if (graph_type == \"cycle\") {\n        if (m == -1) m = n;\n        for (int i = 0; i < n - 1 && edges.size() < m; ++i) {\n            edges.push_back({i + 1, i + 2});\n        }\n        if(edges.size() < m && n > 2) {\n            edges.push_back({n, 1});\n        }\n    } else if (graph_type == \"tree\") {\n        if (m == -1) m = n - 1;\n        // Generate a random tree\n        for (int i = 1; i < n; ++i) {\n            int u = i + 1;\n            int v = rnd.next(1, i); // connect to any previous node\n            edges.push_back({u, v});\n        }\n    } else if (graph_type == \"random\") {\n        if (m == -1 || m > max_edges) m = rnd.next(0, max_edges);\n        // Generate random edges\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = {u, v};\n            if (edges_set.count(edge)) continue;\n            edges_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } else if (graph_type == \"connected\") {\n        // First create a spanning tree\n        // m must be at least n-1\n        if (m == -1) m = n - 1;\n        if (m < n -1) {\n            cerr << \"Cannot generate connected graph with m < n - 1\" << endl;\n            return 1;\n        }\n        if (m > max_edges) m = max_edges;\n        // Use union-find to avoid cycles\n        vector<int> parent(n + 1);\n        for (int i = 1; i <= n; ++i) parent[i] = i;\n        function<int(int)> find = [&](int x) {\n            return parent[x] == x ? x : parent[x] = find(parent[x]);\n        };\n        auto unite = [&](int x, int y) {\n            x = find(x); y = find(y);\n            if (x != y) parent[x] = y;\n        };\n        // Build a random spanning tree\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i -1);\n            unite(u, v);\n            edges.push_back({u, v});\n            edges_set.insert({min(u, v), max(u, v)});\n        }\n        // Now add random edges\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = {u, v};\n            if (edges_set.count(edge)) continue;\n            edges_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } else if (graph_type == \"disconnected\") {\n        // Generate components\n        if (m == -1) m = 0;\n        if (m > max_edges) m = max_edges;\n        // For simplicity, create isolated nodes and random edges that don't necessarily connect the graph\n        while (edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            pair<int, int> edge = {u, v};\n            if (edges_set.count(edge)) continue;\n            edges_set.insert(edge);\n            edges.push_back(edge);\n        }\n    } else {\n        cerr << \"Invalid graph_type\" << endl;\n        return 1;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    // Output vi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", vi[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Output edges\n    for (auto& e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random graph, random vi\n./gen -n 5 -graph_type random -vi_type random\n\n# Small n, complete graph\n./gen -n 5 -graph_type complete -vi_type constant -vi_value 0\n\n# Small n, star graph, increasing vi\n./gen -n 5 -graph_type star -vi_type increasing -vi_min 0 -vi_max 100\n\n# Small n, path graph, decreasing vi\n./gen -n 5 -graph_type path -vi_type decreasing -vi_min 0 -vi_max 100\n\n# Small n, disconnected graph\n./gen -n 5 -graph_type disconnected -vi_type zero\n\n# Medium n, random graph m specified\n./gen -n 100 -m 200 -graph_type random -vi_type random\n\n# Medium n, connected graph\n./gen -n 100 -graph_type connected -vi_type constant -vi_value 1\n\n# Medium n, tree\n./gen -n 100 -graph_type tree -vi_type increasing -vi_min 1 -vi_max 100000\n\n# Medium n, complete graph, vi zero\n./gen -n 64 -graph_type complete -vi_type zero\n\n# Medium n, cycle\n./gen -n 50 -graph_type cycle -vi_type random\n\n# Medium n, disconnected\n./gen -n 100 -graph_type disconnected -m 50 -vi_type random\n\n# Medium n, random graph with m = 0\n./gen -n 100 -graph_type random -m 0 -vi_type random\n\n# Medium n, random vi between min and max\n./gen -n 100 -graph_type random -vi_type random -vi_min 50 -vi_max 10000\n\n# Large n, random graph\n./gen -n 1000 -graph_type random -vi_type random\n\n# Large n, connected graph\n./gen -n 1000 -graph_type connected -vi_type constant -vi_value 100000\n\n# Large n, tree\n./gen -n 1000 -graph_type tree -vi_type decreasing -vi_min 0 -vi_max 100000\n\n# Large n, star graph\n./gen -n 1000 -graph_type star -vi_type increasing -vi_min 0 -vi_max 100000\n\n# Large n, complete graph (limited by m≤2000)\n./gen -n 64 -graph_type complete -vi_type random\n\n# Large n, cycle\n./gen -n 1000 -graph_type cycle -vi_type random\n\n# Large n, disconnected, m = 0\n./gen -n 1000 -graph_type disconnected -m 0 -vi_type random\n\n# Large n, disconnected, m = 2000\n./gen -n 1000 -graph_type disconnected -m 2000 -vi_type random\n\n# Large n, random graph with maximum m\n./gen -n 1000 -m 2000 -graph_type random -vi_type random\n\n# Large n, random graph with small m\n./gen -n 1000 -m 100 -graph_type random -vi_type zero\n\n# Edge cases, n = 1\n./gen -n 1 -graph_type random -vi_type random\n\n# Edge case, n = maximum, vi all zeros\n./gen -n 1000 -m 0 -graph_type random -vi_type zero\n\n# Edge case, n = maximum, vi all maximum\n./gen -n 1000 -graph_type connected -vi_type constant -vi_value 100000\n\n# Edge case, m = maximum\n./gen -n 45 -graph_type complete -vi_type random\n\n# Edge case, vi ranges, min and max equal zero\n./gen -n 1000 -graph_type random -vi_type random -vi_min 0 -vi_max 0\n\n# Edge case, vi ranges, min and max equal maximum\n./gen -n 1000 -graph_type random -vi_type random -vi_min 100000 -vi_max 100000\n\n# Random graph with varying m\n./gen -n 500 -m 1000 -graph_type random -vi_type random\n\n./gen -n 500 -m 500 -graph_type random -vi_type random\n\n./gen -n 500 -m 0 -graph_type random -vi_type random\n\n# Random vi, n small\n./gen -n 2 -graph_type random -vi_type random\n\n# Random vi, n small, m = 1\n./gen -n 2 -graph_type random -m 1 -vi_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:18.626145",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "438/B",
      "title": "B. Ребенок и зоопарк",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа, n и m (2 ≤ n ≤ 105; 0 ≤ m ≤ 105). Во второй строке записано n целых чисел: a1, a2, ..., an (0 ≤ ai ≤ 105). Затем следуют m строк, каждая строка содержит два целых числа, xi и yi (1 ≤ xi, yi ≤ n; xi ≠ yi), обозначающих дорогу между вольерами xi и yi.Все дороги двусторонние, каждая пара вольеров соединена не более чем одной дорогой.",
      "output_spec": "Выходные данныеВыведите вещественное число — значение .Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 4.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 310 20 30 401 32 34 3Выходные данныеСкопировать16.666667Входные данныеСкопировать3 310 20 301 22 33 1Выходные данныеСкопировать13.333333Входные данныеСкопировать7 840 20 10 30 20 50 401 22 33 44 55 66 71 45 7Выходные данныеСкопировать18.571429",
      "description": "B. Ребенок и зоопарк\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа, n и m (2 ≤ n ≤ 105; 0 ≤ m ≤ 105). Во второй строке записано n целых чисел: a1, a2, ..., an (0 ≤ ai ≤ 105). Затем следуют m строк, каждая строка содержит два целых числа, xi и yi (1 ≤ xi, yi ≤ n; xi ≠ yi), обозначающих дорогу между вольерами xi и yi.Все дороги двусторонние, каждая пара вольеров соединена не более чем одной дорогой.\n\nВходные данные\n\nВыходные данныеВыведите вещественное число — значение .Ответ будет считаться правильным, если его относительная или абсолютная погрешность не превышает 10 - 4.\n\nВыходные данные\n\nВходные данныеСкопировать4 310 20 30 401 32 34 3Выходные данныеСкопировать16.666667Входные данныеСкопировать3 310 20 301 22 33 1Выходные данныеСкопировать13.333333Входные данныеСкопировать7 840 20 10 30 20 50 401 22 33 44 55 66 71 45 7Выходные данныеСкопировать18.571429\n\nВходные данныеСкопировать4 310 20 30 401 32 34 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16.666667\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 310 20 301 22 33 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13.333333\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7 840 20 10 30 20 50 401 22 33 44 55 66 71 45 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать18.571429\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый пример. Существует 12 возможных пар вольеров:  p = 1, q = 3, f(p, q) = 10.  p = 2, q = 3, f(p, q) = 20.  p = 4, q = 3, f(p, q) = 30.  p = 1, q = 2, f(p, q) = 10.  p = 2, q = 4, f(p, q) = 20.  p = 4, q = 1, f(p, q) = 10. Еще 6 случаев симметричны приведенному выше. Среднее значение равно .Рассмотрим второй пример. Существует 6 возможных пар вольеров:  p = 1, q = 2, f(p, q) = 10.  p = 2, q = 3, f(p, q) = 20.  p = 1, q = 3, f(p, q) = 10. Еще 3 случая симметричны приведенному выше. Среднее значение равно .",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Поздравляю всех с днем защиты детей! Наверное, вы задаете себе вопрос: как отпраздновать этот необычный праздник? Конечно, написать очередной Codeforces Round — самый лучший выбор!Сегодня главным героем задач будет маленький ребенок. Он столкнулся с огромным количеством алгоритмических задач, сможете ли вы помочь ему?Приглашаем вас поучаствовать в Codeforces Round #250, который состоится в 17:00 первого июня в день защиты детей. Соревнование будет проводиться для участников обоих дивизионов.Обратите внимание на необычное время начала раунда. Вероятно, вам интересно почему время раунда не стандартное? Все потому что это очередной раунд, подготовленный командой авторов из Китая! Мы постарались приготовить для вас много интересных задач. Вы заинтригованы? Тогда не пропускайте раунд!Соревнование подготовлено группой авторов: delayyy, Picks и я. Это наш первый раунд Codeforces~~~~.Большое спасибо Gerald, за помощь с подготовкой раунда; а также спасибо ftiasch, Kissshot и jqdai0815, они тестировали задачи; традиционно благодарим MikeMirzayanov за создание замечательной платформы Codeforces.Разбалловка для первого дивизиона: 500-1000-1500-2000-3000.Разбалловка для второго дивизиона: 500-1500-1500-2000-2500.Не упустите шанс поднять свой рейтинг Codeforces! Желаем вам удачи и удовольствия от решения задач!UPD: Контест завершен! Поздравляем победителей!Top 5 участников Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 участников Div. 2: tohdon KFDong function348 104325EA Boyuede1 К сожалению, никто не решил задачу E в обоих дивизионах. Очень жаль.... Разбор будет опубликован очень скоро.UPD2: Разбор задач",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1634
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 438 和字母"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint find(vector<int>& parent, int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent, parent[u]);\n    }\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(m >= n - 1, \"Graph must be connected, so m >= n - 1, but m = %d, n = %d\", m, n);\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Self-loops are not allowed: xi = %d, yi = %d\", xi, yi);\n\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n\n        ensuref(edges.find({u, v}) == edges.end(), \"Multiple edges between the same nodes are not allowed: edge (%d, %d) appears multiple times\", u, v);\n        edges.insert({u, v});\n\n        int pu = find(parent, u);\n        int pv = find(parent, v);\n\n        if (pu != pv) {\n            parent[pu] = pv;\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"The graph must be connected, but it has %d connected components\", components);\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint find(vector<int>& parent, int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent, parent[u]);\n    }\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(m >= n - 1, \"Graph must be connected, so m >= n - 1, but m = %d, n = %d\", m, n);\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Self-loops are not allowed: xi = %d, yi = %d\", xi, yi);\n\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n\n        ensuref(edges.find({u, v}) == edges.end(), \"Multiple edges between the same nodes are not allowed: edge (%d, %d) appears multiple times\", u, v);\n        edges.insert({u, v});\n\n        int pu = find(parent, u);\n        int pv = find(parent, v);\n\n        if (pu != pv) {\n            parent[pu] = pv;\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"The graph must be connected, but it has %d connected components\", components);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint find(vector<int>& parent, int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent, parent[u]);\n    }\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 100000, \"m\");\n    inf.readEoln();\n\n    ensuref(m >= n - 1, \"Graph must be connected, so m >= n - 1, but m = %d, n = %d\", m, n);\n\n    vector<int> a = inf.readInts(n, 0, 100000, \"a_i\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; ++i) {\n        parent[i] = i;\n    }\n\n    int components = n;\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(1, n, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"yi\");\n        inf.readEoln();\n\n        ensuref(xi != yi, \"Self-loops are not allowed: xi = %d, yi = %d\", xi, yi);\n\n        int u = min(xi, yi);\n        int v = max(xi, yi);\n\n        ensuref(edges.find({u, v}) == edges.end(), \"Multiple edges between the same nodes are not allowed: edge (%d, %d) appears multiple times\", u, v);\n        edges.insert({u, v});\n\n        int pu = find(parent, u);\n        int pv = find(parent, v);\n\n        if (pu != pv) {\n            parent[pu] = pv;\n            components--;\n        }\n    }\n\n    ensuref(components == 1, \"The graph must be connected, but it has %d connected components\", components);\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default to -1, we handle it later\n    string graphType = opt<string>(\"graph\", \"random\");\n    string aType = opt<string>(\"aType\", \"random\");\n    int aMin = opt<int>(\"aMin\", 0);\n    int aMax = opt<int>(\"aMax\", 100000);\n    int aValue = opt<int>(\"aValue\", -1); // Used when aType is \"constant\"\n\n    // Ensure n is within constraints\n    ensure(2 <= n && n <= 100000);\n\n    // Handle default value for m\n    if (m == -1) {\n        if (graphType == \"path\" || graphType == \"star\" || graphType == \"tree\") {\n            m = n - 1;\n        } else if (graphType == \"complete\") {\n            m = min(100000LL, 1LL * n * (n - 1) / 2);\n            m = (int)m;\n        } else {\n            m = n - 1; // default to minimal connected graph\n        }\n    }\n\n    // Ensure m is within constraints\n    ensure((n - 1) <= m && m <= min(100000LL, 1LL * n * (n - 1) / 2));\n\n    // Generate ai[]\n    vector<int> a(n);\n    if (aType == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(aMin, aMax);\n        }\n    } else if (aType == \"constant\") {\n        ensure(aValue != -1);\n        ensure(0 <= aValue && aValue <= 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = aValue;\n        }\n    } else if (aType == \"increasing\") {\n        int range = aMax - aMin + 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = aMin + i % range;\n        }\n    } else if (aType == \"decreasing\") {\n        int range = aMax - aMin + 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = aMax - i % range;\n        }\n    } else if (aType == \"zero\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (aType == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n    } else if (aType == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = aMin;\n            else\n                a[i] = aMax;\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(aMin, aMax);\n        }\n    }\n\n    // Generate graph edges\n    vector<pair<int, int>> edges;\n\n    if (graphType == \"path\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (graphType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (graphType == \"complete\") {\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (graphType == \"random\") {\n        // Generate random spanning tree\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 1; i < n; ++i) {\n            int u = p[rnd.next(0, i - 1)];\n            int v = p[i];\n            edges.push_back({u, v});\n        }\n\n        // Add random edges\n        set<pair<int, int>> edgeSet(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v)\n                continue;\n            if (u > v)\n                swap(u, v);\n            if (edgeSet.count({u, v}) == 0) {\n                edges.push_back({u, v});\n                edgeSet.insert({u, v});\n            }\n        }\n\n    } else {\n        // Default: generate a random connected graph\n        // Generate random spanning tree\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 1; i < n; ++i) {\n            int u = p[rnd.next(0, i - 1)];\n            int v = p[i];\n            edges.push_back({u, v});\n        }\n\n        // Add random edges to reach m edges\n        set<pair<int, int>> edgeSet(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v)\n                continue;\n            if (u > v)\n                swap(u, v);\n            if (edgeSet.count({u, v}) == 0) {\n                edges.push_back({u, v});\n                edgeSet.insert({u, v});\n            }\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default to -1, we handle it later\n    string graphType = opt<string>(\"graph\", \"random\");\n    string aType = opt<string>(\"aType\", \"random\");\n    int aMin = opt<int>(\"aMin\", 0);\n    int aMax = opt<int>(\"aMax\", 100000);\n    int aValue = opt<int>(\"aValue\", -1); // Used when aType is \"constant\"\n\n    // Ensure n is within constraints\n    ensure(2 <= n && n <= 100000);\n\n    // Handle default value for m\n    if (m == -1) {\n        if (graphType == \"path\" || graphType == \"star\" || graphType == \"tree\") {\n            m = n - 1;\n        } else if (graphType == \"complete\") {\n            m = min(100000LL, 1LL * n * (n - 1) / 2);\n            m = (int)m;\n        } else {\n            m = n - 1; // default to minimal connected graph\n        }\n    }\n\n    // Ensure m is within constraints\n    ensure((n - 1) <= m && m <= min(100000LL, 1LL * n * (n - 1) / 2));\n\n    // Generate ai[]\n    vector<int> a(n);\n    if (aType == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(aMin, aMax);\n        }\n    } else if (aType == \"constant\") {\n        ensure(aValue != -1);\n        ensure(0 <= aValue && aValue <= 100000);\n        for (int i = 0; i < n; ++i) {\n            a[i] = aValue;\n        }\n    } else if (aType == \"increasing\") {\n        int range = aMax - aMin + 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = aMin + i % range;\n        }\n    } else if (aType == \"decreasing\") {\n        int range = aMax - aMin + 1;\n        for (int i = 0; i < n; ++i) {\n            a[i] = aMax - i % range;\n        }\n    } else if (aType == \"zero\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (aType == \"max\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = 100000;\n        }\n    } else if (aType == \"alternating\") {\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                a[i] = aMin;\n            else\n                a[i] = aMax;\n        }\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(aMin, aMax);\n        }\n    }\n\n    // Generate graph edges\n    vector<pair<int, int>> edges;\n\n    if (graphType == \"path\") {\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (graphType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (graphType == \"complete\") {\n        for (int i = 1; i <= n && (int)edges.size() < m; ++i) {\n            for (int j = i + 1; j <= n && (int)edges.size() < m; ++j) {\n                edges.push_back({i, j});\n            }\n        }\n    } else if (graphType == \"random\") {\n        // Generate random spanning tree\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 1; i < n; ++i) {\n            int u = p[rnd.next(0, i - 1)];\n            int v = p[i];\n            edges.push_back({u, v});\n        }\n\n        // Add random edges\n        set<pair<int, int>> edgeSet(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v)\n                continue;\n            if (u > v)\n                swap(u, v);\n            if (edgeSet.count({u, v}) == 0) {\n                edges.push_back({u, v});\n                edgeSet.insert({u, v});\n            }\n        }\n\n    } else {\n        // Default: generate a random connected graph\n        // Generate random spanning tree\n        vector<int> p(n);\n        for (int i = 0; i < n; ++i)\n            p[i] = i + 1;\n        shuffle(p.begin(), p.end());\n        for (int i = 1; i < n; ++i) {\n            int u = p[rnd.next(0, i - 1)];\n            int v = p[i];\n            edges.push_back({u, v});\n        }\n\n        // Add random edges to reach m edges\n        set<pair<int, int>> edgeSet(edges.begin(), edges.end());\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v)\n                continue;\n            if (u > v)\n                swap(u, v);\n            if (edgeSet.count({u, v}) == 0) {\n                edges.push_back({u, v});\n                edgeSet.insert({u, v});\n            }\n        }\n    }\n\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n    for (auto &e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -graph path -aType constant -aValue 0\n./gen -n 2 -m 1 -graph path -aType constant -aValue 100000\n./gen -n 2 -graph star -aType random -aMin 0 -aMax 0\n./gen -n 3 -m 2 -graph path -aType increasing -aMin 0 -aMax 100000\n./gen -n 3 -m 3 -graph complete -aType decreasing -aMin 0 -aMax 100000\n./gen -n 10 -m 9 -graph path -aType random -aMin 0 -aMax 0\n./gen -n 10 -m 30 -graph random -aType constant -aValue 100000\n./gen -n 100 -m 99 -graph star -aType zero\n./gen -n 1000 -m 999 -graph path -aType max\n./gen -n 10000 -m 100000 -graph random -aType random\n./gen -n 100000 -m 99999 -graph path -aType constant -aValue 50000\n./gen -n 100000 -m 100000 -graph random -aType random -aMin 0 -aMax 100000\n./gen -n 99999 -m 100000 -graph random -aType zero\n./gen -n 100000 -m 100000 -graph random -aType constant -aValue 0 # Edge case with minimal ai\n./gen -n 100000 -m 100000 -graph random -aType constant -aValue 100000 # Edge case with maximal ai\n./gen -n 100000 -m 100000 -graph random -aType increasing -aMin 0 -aMax 100000 # Mix of zeros and max ai\n./gen -n 100000 -m 100000 -graph random -aType decreasing -aMin 0 -aMax 100000 # Decreasing ai values\n./gen -n 2 -graph path -aType random -aMin 1 -aMax 1 # n = 2, test minimal n\n./gen -n 100000 -m 100000 -graph random -aType random -aMin 0 -aMax 100000 # Max m, connected graph\n./gen -n 100000 -graph star -aType max # Test star graph with max ai\n./gen -n 100000 -graph star -aType zero # Test star graph with zero ai\n./gen -n 100000 -m 99999 -graph random -aType random # Random graph with minimal edges\n./gen -n 500 -graph complete -aType random # Complete graph of small size\n./gen -n 20000 -m 100000 -graph random -aType random # Random graph with m = 1e5\n./gen -n 100000 -graph path -aType alternating -aMin 0 -aMax 100000 # Path with alternating ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:20.812262",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "438/C",
      "title": "C. The Child and Polygon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer n (3 ≤ n ≤ 200) — the number of vertices of the polygon. Then follow n lines, each line containing two integers. The i-th line contains xi, yi (|xi|, |yi| ≤ 107) — the i-th vertex of the polygon in clockwise or counterclockwise order.It's guaranteed that the polygon is simple.",
      "output_spec": "OutputOutput the number of ways modulo 1000000007 (109  +  7).",
      "sample_tests": "ExamplesInputCopy40 00 11 11 0OutputCopy2InputCopy40 01 00 1-1 0OutputCopy1InputCopy50 01 01 10 1-2 -1OutputCopy3",
      "description": "C. The Child and Polygon\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer n (3 ≤ n ≤ 200) — the number of vertices of the polygon. Then follow n lines, each line containing two integers. The i-th line contains xi, yi (|xi|, |yi| ≤ 107) — the i-th vertex of the polygon in clockwise or counterclockwise order.It's guaranteed that the polygon is simple.\n\nOutputOutput the number of ways modulo 1000000007 (109  +  7).\n\nInputCopy40 00 11 11 0OutputCopy2InputCopy40 01 00 1-1 0OutputCopy1InputCopy50 01 01 10 1-2 -1OutputCopy3\n\nInputCopy40 00 11 11 0\n\nOutputCopy2\n\nInputCopy40 01 00 1-1 0\n\nOutputCopy1\n\nInputCopy50 01 01 10 1-2 -1\n\nOutputCopy3\n\nNoteIn the first sample, there are two possible splittings:  In the second sample, there are only one possible splitting:",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 438 和字母"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check orientation\nint orientation(pair<int,int> p, pair<int,int> q, pair<int,int> r) {\n    long long val = (long long)(q.second - p.second)*(r.first - q.first) - \n                    (long long)(q.first - p.first)*(r.second - q.second);\n    if (val == 0) return 0; // colinear\n    return (val > 0)? 1: 2; // 1 for clockwise, 2 for counterclockwise\n}\n\n// Function to check if point q lies on segment pr\nbool onSegment(pair<int,int> p, pair<int,int> q, pair<int,int> r) {\n    if (q.first <= max(p.first, r.first) && q.first >= min(p.first, r.first) &&\n        q.second <= max(p.second, r.second) && q.second >= min(p.second, r.second))\n        return true;\n    return false;\n}\n\n// Function to check if segments p1q1 and p2q2 intersect\nbool doIntersect(pair<int,int> p1, pair<int,int> q1, pair<int,int> p2, pair<int,int> q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if(o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    if(o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if(o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if(o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if(o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n    vector<int> x(n), y(n);\n    set<pair<int,int>> points;\n    for(int i = 0; i < n; ++i){\n        x[i] = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        y[i] = inf.readInt(-10000000, 10000000);\n        inf.readEoln();\n        pair<int,int> p = make_pair(x[i], y[i]);\n        ensuref(points.find(p) == points.end(), \"point (%d, %d) is duplicated\", x[i], y[i]);\n        points.insert(p);\n    }\n    // Check that the polygon is simple\n    for(int i = 0; i < n; ++i){\n        int i_next = (i + 1) % n;\n        for(int j = i + 1; j < n; ++j){\n            int j_next = (j + 1) % n;\n            if(i == j || i_next == j || i == j_next) continue;\n            pair<int,int> p1 = make_pair(x[i], y[i]);\n            pair<int,int> q1 = make_pair(x[i_next], y[i_next]);\n            pair<int,int> p2 = make_pair(x[j], y[j]);\n            pair<int,int> q2 = make_pair(x[j_next], y[j_next]);\n            if(doIntersect(p1, q1, p2, q2)){\n                ensuref(false, \"Edges (%d-%d) and (%d-%d) intersect\", i+1, i_next+1, j+1, j_next+1);\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check orientation\nint orientation(pair<int,int> p, pair<int,int> q, pair<int,int> r) {\n    long long val = (long long)(q.second - p.second)*(r.first - q.first) - \n                    (long long)(q.first - p.first)*(r.second - q.second);\n    if (val == 0) return 0; // colinear\n    return (val > 0)? 1: 2; // 1 for clockwise, 2 for counterclockwise\n}\n\n// Function to check if point q lies on segment pr\nbool onSegment(pair<int,int> p, pair<int,int> q, pair<int,int> r) {\n    if (q.first <= max(p.first, r.first) && q.first >= min(p.first, r.first) &&\n        q.second <= max(p.second, r.second) && q.second >= min(p.second, r.second))\n        return true;\n    return false;\n}\n\n// Function to check if segments p1q1 and p2q2 intersect\nbool doIntersect(pair<int,int> p1, pair<int,int> q1, pair<int,int> p2, pair<int,int> q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if(o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    if(o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if(o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if(o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if(o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n    vector<int> x(n), y(n);\n    set<pair<int,int>> points;\n    for(int i = 0; i < n; ++i){\n        x[i] = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        y[i] = inf.readInt(-10000000, 10000000);\n        inf.readEoln();\n        pair<int,int> p = make_pair(x[i], y[i]);\n        ensuref(points.find(p) == points.end(), \"point (%d, %d) is duplicated\", x[i], y[i]);\n        points.insert(p);\n    }\n    // Check that the polygon is simple\n    for(int i = 0; i < n; ++i){\n        int i_next = (i + 1) % n;\n        for(int j = i + 1; j < n; ++j){\n            int j_next = (j + 1) % n;\n            if(i == j || i_next == j || i == j_next) continue;\n            pair<int,int> p1 = make_pair(x[i], y[i]);\n            pair<int,int> q1 = make_pair(x[i_next], y[i_next]);\n            pair<int,int> p2 = make_pair(x[j], y[j]);\n            pair<int,int> q2 = make_pair(x[j_next], y[j_next]);\n            if(doIntersect(p1, q1, p2, q2)){\n                ensuref(false, \"Edges (%d-%d) and (%d-%d) intersect\", i+1, i_next+1, j+1, j_next+1);\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to check orientation\nint orientation(pair<int,int> p, pair<int,int> q, pair<int,int> r) {\n    long long val = (long long)(q.second - p.second)*(r.first - q.first) - \n                    (long long)(q.first - p.first)*(r.second - q.second);\n    if (val == 0) return 0; // colinear\n    return (val > 0)? 1: 2; // 1 for clockwise, 2 for counterclockwise\n}\n\n// Function to check if point q lies on segment pr\nbool onSegment(pair<int,int> p, pair<int,int> q, pair<int,int> r) {\n    if (q.first <= max(p.first, r.first) && q.first >= min(p.first, r.first) &&\n        q.second <= max(p.second, r.second) && q.second >= min(p.second, r.second))\n        return true;\n    return false;\n}\n\n// Function to check if segments p1q1 and p2q2 intersect\nbool doIntersect(pair<int,int> p1, pair<int,int> q1, pair<int,int> p2, pair<int,int> q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    // General case\n    if(o1 != o2 && o3 != o4)\n        return true;\n\n    // Special Cases\n    if(o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if(o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if(o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if(o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 200, \"n\");\n    inf.readEoln();\n    vector<int> x(n), y(n);\n    set<pair<int,int>> points;\n    for(int i = 0; i < n; ++i){\n        x[i] = inf.readInt(-10000000, 10000000);\n        inf.readSpace();\n        y[i] = inf.readInt(-10000000, 10000000);\n        inf.readEoln();\n        pair<int,int> p = make_pair(x[i], y[i]);\n        ensuref(points.find(p) == points.end(), \"point (%d, %d) is duplicated\", x[i], y[i]);\n        points.insert(p);\n    }\n    // Check that the polygon is simple\n    for(int i = 0; i < n; ++i){\n        int i_next = (i + 1) % n;\n        for(int j = i + 1; j < n; ++j){\n            int j_next = (j + 1) % n;\n            if(i == j || i_next == j || i == j_next) continue;\n            pair<int,int> p1 = make_pair(x[i], y[i]);\n            pair<int,int> q1 = make_pair(x[i_next], y[i_next]);\n            pair<int,int> p2 = make_pair(x[j], y[j]);\n            pair<int,int> q2 = make_pair(x[j_next], y[j_next]);\n            if(doIntersect(p1, q1, p2, q2)){\n                ensuref(false, \"Edges (%d-%d) and (%d-%d) intersect\", i+1, i_next+1, j+1, j_next+1);\n            }\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n// Function to generate a regular convex polygon with n vertices\nvector<pair<int,int>> generateConvexPolygon(int n) {\n    double R = 1e7 / 2.0;\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points[i].first = (int)round(x);\n        points[i].second = (int)round(y);\n    }\n    return points;\n}\n\n// Function to generate a star-shaped polygon (concave) with n vertices\nvector<pair<int,int>> generateStarShapedPolygon(int n) {\n    double R_outer = 1e7 / 2.0;\n    double R_inner = R_outer / 2.0;\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n;\n        double R = (i % 2 == 0) ? R_outer : R_inner;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points[i].first = (int)round(x);\n        points[i].second = (int)round(y);\n    }\n    return points;\n}\n\n// Function to generate a concave polygon by modifying a convex polygon\nvector<pair<int,int>> generateConcavePolygon(int n) {\n    vector<pair<double,double>> points_d(n);\n    double R = 1e7 / 2.0;\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points_d[i] = {x, y};\n    }\n    // Push one vertex inward\n    int idx = rnd.next(0, n-1);\n    double factor = rnd.next(2, 8) / 10.0; // Between 0.2 and 0.8\n    points_d[idx].first *= factor;\n    points_d[idx].second *= factor;\n    // Convert to integers\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        points[i].first = (int)round(points_d[i].first);\n        points[i].second = (int)round(points_d[i].second);\n    }\n    return points;\n}\n\n// Function to generate a 'thin' polygon\nvector<pair<int,int>> generateThinPolygon(int n) {\n    vector<pair<int,int>> points(n);\n    int x0 = rnd.next(-1e7, 1e7);\n    int y0 = rnd.next(-1e7, 1e7);\n    int dx = rnd.next(-100, 100);\n    int dy = rnd.next(-100, 100);\n    for(int i = 0; i < n; ++i) {\n        points[i].first = x0 + i * dx + rnd.next(-10,10);\n        points[i].second = y0 + i * dy + rnd.next(-10,10);\n    }\n    return points;\n}\n\n// Function to generate a spiral polygon\nvector<pair<int,int>> generateSpiralPolygon(int n) {\n    vector<pair<double,double>> points_d(n);\n    double R = 0.0;\n    double max_R = 1e7 / 2.0;\n    double dR = max_R / n;\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n * 2; // Make two turns\n        R += dR;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points_d[i] = {x, y};\n    }\n    // Convert to integers\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        points[i].first = (int)round(points_d[i].first);\n        points[i].second = (int)round(points_d[i].second);\n    }\n    return points;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n\n    // Generate polygon of n vertices, depending on the type\n    vector<pair<int,int>> polygon;\n\n    if (type == \"convex\") {\n        polygon = generateConvexPolygon(n);\n    } else if (type == \"concave\") {\n        polygon = generateConcavePolygon(n);\n    } else if (type == \"star\") {\n        polygon = generateStarShapedPolygon(n);\n    } else if (type == \"thin\") {\n        polygon = generateThinPolygon(n);\n    } else if (type == \"spiral\") {\n        polygon = generateSpiralPolygon(n);\n    } else {\n        // Default: Generate convex polygon\n        polygon = generateConvexPolygon(n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the points\n    for (auto& p : polygon) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n// Function to generate a regular convex polygon with n vertices\nvector<pair<int,int>> generateConvexPolygon(int n) {\n    double R = 1e7 / 2.0;\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points[i].first = (int)round(x);\n        points[i].second = (int)round(y);\n    }\n    return points;\n}\n\n// Function to generate a star-shaped polygon (concave) with n vertices\nvector<pair<int,int>> generateStarShapedPolygon(int n) {\n    double R_outer = 1e7 / 2.0;\n    double R_inner = R_outer / 2.0;\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n;\n        double R = (i % 2 == 0) ? R_outer : R_inner;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points[i].first = (int)round(x);\n        points[i].second = (int)round(y);\n    }\n    return points;\n}\n\n// Function to generate a concave polygon by modifying a convex polygon\nvector<pair<int,int>> generateConcavePolygon(int n) {\n    vector<pair<double,double>> points_d(n);\n    double R = 1e7 / 2.0;\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points_d[i] = {x, y};\n    }\n    // Push one vertex inward\n    int idx = rnd.next(0, n-1);\n    double factor = rnd.next(2, 8) / 10.0; // Between 0.2 and 0.8\n    points_d[idx].first *= factor;\n    points_d[idx].second *= factor;\n    // Convert to integers\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        points[i].first = (int)round(points_d[i].first);\n        points[i].second = (int)round(points_d[i].second);\n    }\n    return points;\n}\n\n// Function to generate a 'thin' polygon\nvector<pair<int,int>> generateThinPolygon(int n) {\n    vector<pair<int,int>> points(n);\n    int x0 = rnd.next(-1e7, 1e7);\n    int y0 = rnd.next(-1e7, 1e7);\n    int dx = rnd.next(-100, 100);\n    int dy = rnd.next(-100, 100);\n    for(int i = 0; i < n; ++i) {\n        points[i].first = x0 + i * dx + rnd.next(-10,10);\n        points[i].second = y0 + i * dy + rnd.next(-10,10);\n    }\n    return points;\n}\n\n// Function to generate a spiral polygon\nvector<pair<int,int>> generateSpiralPolygon(int n) {\n    vector<pair<double,double>> points_d(n);\n    double R = 0.0;\n    double max_R = 1e7 / 2.0;\n    double dR = max_R / n;\n    for(int i = 0; i < n; ++i) {\n        double angle = (2 * M_PI * i) / n * 2; // Make two turns\n        R += dR;\n        double x = R * cos(angle);\n        double y = R * sin(angle);\n        points_d[i] = {x, y};\n    }\n    // Convert to integers\n    vector<pair<int,int>> points(n);\n    for(int i = 0; i < n; ++i) {\n        points[i].first = (int)round(points_d[i].first);\n        points[i].second = (int)round(points_d[i].second);\n    }\n    return points;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"convex\");\n\n    // Generate polygon of n vertices, depending on the type\n    vector<pair<int,int>> polygon;\n\n    if (type == \"convex\") {\n        polygon = generateConvexPolygon(n);\n    } else if (type == \"concave\") {\n        polygon = generateConcavePolygon(n);\n    } else if (type == \"star\") {\n        polygon = generateStarShapedPolygon(n);\n    } else if (type == \"thin\") {\n        polygon = generateThinPolygon(n);\n    } else if (type == \"spiral\") {\n        polygon = generateSpiralPolygon(n);\n    } else {\n        // Default: Generate convex polygon\n        polygon = generateConvexPolygon(n);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output the points\n    for (auto& p : polygon) {\n        printf(\"%d %d\\n\", p.first, p.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type convex\n./gen -n 3 -type concave\n./gen -n 4 -type convex\n./gen -n 4 -type concave\n./gen -n 4 -type star\n./gen -n 4 -type thin\n./gen -n 5 -type convex\n./gen -n 5 -type concave\n./gen -n 5 -type star\n./gen -n 5 -type spiral\n./gen -n 10 -type convex\n./gen -n 10 -type concave\n./gen -n 10 -type thin\n./gen -n 20 -type convex\n./gen -n 20 -type concave\n./gen -n 20 -type spiral\n./gen -n 50 -type convex\n./gen -n 50 -type concave\n./gen -n 50 -type star\n./gen -n 100 -type convex\n./gen -n 100 -type concave\n./gen -n 100 -type thin\n./gen -n 200 -type convex\n./gen -n 200 -type concave\n./gen -n 200 -type spiral\n./gen -n 199 -type convex\n./gen -n 199 -type concave\n./gen -n 198 -type star\n./gen -n 197 -type thin\n./gen -n 3 -type spiral\n./gen -n 6 -type spiral\n./gen -n 7 -type thin\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:22.676328",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "438/D",
      "title": "D. The Child and Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains two integer: n, m (1 ≤ n, m ≤ 105). The second line contains n integers, separated by space: a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — initial value of array elements.Each of the next m lines begins with a number type .   If type = 1, there will be two integers more in the line: l, r (1 ≤ l ≤ r ≤ n), which correspond the operation 1.  If type = 2, there will be three integers more in the line: l, r, x (1 ≤ l ≤ r ≤ n; 1 ≤ x ≤ 109), which correspond the operation 2.  If type = 3, there will be two integers more in the line: k, x (1 ≤ k ≤ n; 1 ≤ x ≤ 109), which correspond the operation 3.",
      "output_spec": "OutputFor each operation 1, please print a line containing the answer. Notice that the answer may exceed the 32-bit integer.",
      "sample_tests": "ExamplesInputCopy5 51 2 3 4 52 3 5 43 3 51 2 52 1 3 31 1 3OutputCopy85InputCopy10 106 9 6 7 6 1 10 10 9 51 3 92 7 10 92 5 10 81 4 73 3 72 7 9 91 2 41 6 61 5 93 1 10OutputCopy49152319",
      "description": "D. The Child and Sequence\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains two integer: n, m (1 ≤ n, m ≤ 105). The second line contains n integers, separated by space: a[1], a[2], ..., a[n] (1 ≤ a[i] ≤ 109) — initial value of array elements.Each of the next m lines begins with a number type .   If type = 1, there will be two integers more in the line: l, r (1 ≤ l ≤ r ≤ n), which correspond the operation 1.  If type = 2, there will be three integers more in the line: l, r, x (1 ≤ l ≤ r ≤ n; 1 ≤ x ≤ 109), which correspond the operation 2.  If type = 3, there will be two integers more in the line: k, x (1 ≤ k ≤ n; 1 ≤ x ≤ 109), which correspond the operation 3.\n\nOutputFor each operation 1, please print a line containing the answer. Notice that the answer may exceed the 32-bit integer.\n\nInputCopy5 51 2 3 4 52 3 5 43 3 51 2 52 1 3 31 1 3OutputCopy85InputCopy10 106 9 6 7 6 1 10 10 9 51 3 92 7 10 92 5 10 81 4 73 3 72 7 9 91 2 41 6 61 5 93 1 10OutputCopy49152319\n\nInputCopy5 51 2 3 4 52 3 5 43 3 51 2 52 1 3 31 1 3\n\nOutputCopy85\n\nInputCopy10 106 9 6 7 6 1 10 10 9 51 3 92 7 10 92 5 10 81 4 73 3 72 7 9 91 2 41 6 61 5 93 1 10\n\nOutputCopy49152319\n\nNoteConsider the first testcase:  At first, a = {1, 2, 3, 4, 5}.  After operation 1, a = {1, 2, 3, 0, 1}.  After operation 2, a = {1, 2, 5, 0, 1}.  At operation 3, 2 + 5 + 0 + 1 = 8.  After operation 4, a = {1, 2, 2, 0, 1}.  At operation 5, 1 + 2 + 2 = 5.",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 438\\s*D"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++) {\n        int type = inf.readInt(1, 3, \"type\");\n\n        if (type == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readEoln();\n        } else if (type == 2) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000000, \"x\");\n            inf.readEoln();\n        } else { // type == 3\n            inf.readSpace();\n            int k = inf.readInt(1, n, \"k\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000000, \"x\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++) {\n        int type = inf.readInt(1, 3, \"type\");\n\n        if (type == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readEoln();\n        } else if (type == 2) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000000, \"x\");\n            inf.readEoln();\n        } else { // type == 3\n            inf.readSpace();\n            int k = inf.readInt(1, n, \"k\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000000, \"x\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    for(int i = 0; i < m; i++) {\n        int type = inf.readInt(1, 3, \"type\");\n\n        if (type == 1) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readEoln();\n        } else if (type == 2) {\n            inf.readSpace();\n            int l = inf.readInt(1, n, \"l\");\n            inf.readSpace();\n            int r = inf.readInt(l, n, \"r\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000000, \"x\");\n            inf.readEoln();\n        } else { // type == 3\n            inf.readSpace();\n            int k = inf.readInt(1, n, \"k\");\n            inf.readSpace();\n            int x = inf.readInt(1, 1000000000, \"x\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_A = 1'000'000'000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string op_type = opt<string>(\"op_type\", \"random\");\n    string x_type = opt<string>(\"x_type\", \"random\");\n\n    // Generate initial array a[1..n]\n    vector<int> a(n);\n    if (array_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    } else if (array_type == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (array_type == \"max\") {\n        fill(a.begin(), a.end(), MAX_A);\n    } else if (array_type == \"ascending\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (array_type == \"descending\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    }\n\n    // Generate operations\n    vector<vector<int>> ops;\n    for (int i = 0; i < m; ++i) {\n        int op_type_num;\n        if (op_type == \"random\") {\n            op_type_num = rnd.next(1, 3);\n        } else if (op_type == \"all_print\") {\n            op_type_num = 1;\n        } else if (op_type == \"all_modulo\") {\n            op_type_num = 2;\n        } else if (op_type == \"all_set\") {\n            op_type_num = 3;\n        } else if (op_type == \"alternating\") {\n            op_type_num = (i % 3) + 1;\n        } else if (op_type == \"worst_modulo\") {\n            op_type_num = 2;\n        } else {\n            // Default to random\n            op_type_num = rnd.next(1, 3);\n        }\n\n        if (op_type_num == 1) {\n            // Print operation\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            ops.push_back({1, l, r});\n        } else if (op_type_num == 2) {\n            // Modulo operation\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n\n            int x;\n            if (x_type == \"random\") {\n                x = rnd.next(1, MAX_A);\n            } else if (x_type == \"small\") {\n                x = rnd.next(1, 10);\n            } else if (x_type == \"large\") {\n                x = rnd.next(MAX_A - 10, MAX_A);\n            } else if (x_type == \"one\") {\n                x = 1;\n            } else {\n                // Default to random\n                x = rnd.next(1, MAX_A);\n            }\n\n            ops.push_back({2, l, r, x});\n        } else if (op_type_num == 3) {\n            // Set operation\n            int k = rnd.next(1, n);\n\n            int x;\n            if (x_type == \"random\") {\n                x = rnd.next(1, MAX_A);\n            } else if (x_type == \"small\") {\n                x = rnd.next(1, 10);\n            } else if (x_type == \"large\") {\n                x = rnd.next(MAX_A - 10, MAX_A);\n            } else if (x_type == \"one\") {\n                x = 1;\n            } else {\n                // Default to random\n                x = rnd.next(1, MAX_A);\n            }\n\n            ops.push_back({3, k, x});\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (auto& op : ops) {\n        printf(\"%d\", op[0]);\n        for (size_t j = 1; j < op.size(); ++j) {\n            printf(\" %d\", op[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_A = 1'000'000'000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string array_type = opt<string>(\"array_type\", \"random\");\n    string op_type = opt<string>(\"op_type\", \"random\");\n    string x_type = opt<string>(\"x_type\", \"random\");\n\n    // Generate initial array a[1..n]\n    vector<int> a(n);\n    if (array_type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    } else if (array_type == \"ones\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (array_type == \"max\") {\n        fill(a.begin(), a.end(), MAX_A);\n    } else if (array_type == \"ascending\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = i + 1;\n        }\n    } else if (array_type == \"descending\") {\n        for (int i = 0; i < n; ++i) {\n            a[i] = n - i;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, MAX_A);\n        }\n    }\n\n    // Generate operations\n    vector<vector<int>> ops;\n    for (int i = 0; i < m; ++i) {\n        int op_type_num;\n        if (op_type == \"random\") {\n            op_type_num = rnd.next(1, 3);\n        } else if (op_type == \"all_print\") {\n            op_type_num = 1;\n        } else if (op_type == \"all_modulo\") {\n            op_type_num = 2;\n        } else if (op_type == \"all_set\") {\n            op_type_num = 3;\n        } else if (op_type == \"alternating\") {\n            op_type_num = (i % 3) + 1;\n        } else if (op_type == \"worst_modulo\") {\n            op_type_num = 2;\n        } else {\n            // Default to random\n            op_type_num = rnd.next(1, 3);\n        }\n\n        if (op_type_num == 1) {\n            // Print operation\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n            ops.push_back({1, l, r});\n        } else if (op_type_num == 2) {\n            // Modulo operation\n            int l = rnd.next(1, n);\n            int r = rnd.next(l, n);\n\n            int x;\n            if (x_type == \"random\") {\n                x = rnd.next(1, MAX_A);\n            } else if (x_type == \"small\") {\n                x = rnd.next(1, 10);\n            } else if (x_type == \"large\") {\n                x = rnd.next(MAX_A - 10, MAX_A);\n            } else if (x_type == \"one\") {\n                x = 1;\n            } else {\n                // Default to random\n                x = rnd.next(1, MAX_A);\n            }\n\n            ops.push_back({2, l, r, x});\n        } else if (op_type_num == 3) {\n            // Set operation\n            int k = rnd.next(1, n);\n\n            int x;\n            if (x_type == \"random\") {\n                x = rnd.next(1, MAX_A);\n            } else if (x_type == \"small\") {\n                x = rnd.next(1, 10);\n            } else if (x_type == \"large\") {\n                x = rnd.next(MAX_A - 10, MAX_A);\n            } else if (x_type == \"one\") {\n                x = 1;\n            } else {\n                // Default to random\n                x = rnd.next(1, MAX_A);\n            }\n\n            ops.push_back({3, k, x});\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    for (auto& op : ops) {\n        printf(\"%d\", op[0]);\n        for (size_t j = 1; j < op.size(); ++j) {\n            printf(\" %d\", op[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n and m, random array, random operations\n./gen -n 5 -m 5 -array_type random -op_type random\n\n# Small n and m, all ones array, all print operations\n./gen -n 5 -m 5 -array_type ones -op_type all_print\n\n# Small n and m, max values in array, all set operations\n./gen -n 5 -m 5 -array_type max -op_type all_set\n\n# Small n and m, ascending array, alternating operations\n./gen -n 5 -m 5 -array_type ascending -op_type alternating\n\n# Small n and m, descending array, all modulo operations\n./gen -n 5 -m 5 -array_type descending -op_type all_modulo -x_type small\n\n# Maximum n and m, random array, random operations\n./gen -n 100000 -m 100000 -array_type random -op_type random\n\n# Maximum n and m, ones array, all modulo operations with x=1\n./gen -n 100000 -m 100000 -array_type ones -op_type all_modulo -x_type one\n\n# Maximum n and m, max values in array, all set operations\n./gen -n 100000 -m 100000 -array_type max -op_type all_set\n\n# Maximum n and m, ascending array, alternating operations\n./gen -n 100000 -m 100000 -array_type ascending -op_type alternating\n\n# Maximum n and m, descending array, all modulo operations with large x\n./gen -n 100000 -m 100000 -array_type descending -op_type all_modulo -x_type large\n\n# Medium n and m, random array, all print operations\n./gen -n 50000 -m 50000 -array_type random -op_type all_print\n\n# Medium n and m, random array, worst case modulo operations\n./gen -n 50000 -m 50000 -array_type random -op_type worst_modulo -x_type small\n\n# Small n and m, random array, modulo operations with x=2\n./gen -n 10 -m 10 -array_type random -op_type all_modulo -x_type small\n\n# Edge case: operations on single element ranges\n./gen -n 100000 -m 100000 -array_type random -op_type random\n\n# Edge case: operations on full range\n./gen -n 100000 -m 100000 -array_type random -op_type random\n\n# Small n and m, ones array, all set operations setting to max values\n./gen -n 5 -m 5 -array_type ones -op_type all_set -x_type large\n\n# Maximum n and m, ones array, all set operations setting to max values\n./gen -n 100000 -m 100000 -array_type ones -op_type all_set -x_type large\n\n# Random n and m, random array, random operations\n./gen -n 75000 -m 75000 -array_type random -op_type random\n\n# Small n and m, ascending array, all print operations\n./gen -n 5 -m 5 -array_type ascending -op_type all_print\n\n# Medium n and m, descending array, alternating operations\n./gen -n 50000 -m 50000 -array_type descending -op_type alternating\n\n# Edge case: modulo operations with x=1\n./gen -n 100000 -m 100000 -array_type random -op_type all_modulo -x_type one\n\n# Edge case: modulo operations with x=MAX_A\n./gen -n 100000 -m 100000 -array_type random -op_type all_modulo -x_type large\n\n# Random n and m, max array, random operations\n./gen -n 75000 -m 75000 -array_type max -op_type random\n\n# Edge case: set operations setting to 1\n./gen -n 100000 -m 100000 -array_type random -op_type all_set -x_type one\n\n# Small n and m, ones array, alternating operations\n./gen -n 5 -m 5 -array_type ones -op_type alternating\n\n# Test with maximum m and small n\n./gen -n 10 -m 100000 -array_type random -op_type random\n\n# Test with maximum n and small m\n./gen -n 100000 -m 10 -array_type random -op_type random\n\n# Edge case: all operations are print over full range\n./gen -n 100000 -m 100000 -array_type random -op_type all_print\n\n# Edge case: all set operations on the same index\n./gen -n 100000 -m 100000 -array_type random -op_type all_set -x_type random\n\n# Edge case: operations on last element\n./gen -n 100000 -m 100000 -array_type random -op_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:24.505286",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "438/E",
      "title": "E. The Child and Binary Tree",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test7 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, m (1 ≤ n ≤ 105; 1 ≤ m ≤ 105). The second line contains n space-separated pairwise distinct integers c1, c2, ..., cn. (1 ≤ ci ≤ 105).",
      "output_spec": "OutputPrint m lines, each line containing a single integer. The i-th line must contain the number of good vertex-weighted rooted binary trees whose weight exactly equal to i. Print the answers modulo 998244353 (7 × 17 × 223 + 1, a prime number).",
      "sample_tests": "ExamplesInputCopy2 31 2OutputCopy139InputCopy3 109 4 3OutputCopy00110242615InputCopy5 1013 10 6 4 15OutputCopy0001010205",
      "description": "E. The Child and Binary Tree\n\ntime limit per test7 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n, m (1 ≤ n ≤ 105; 1 ≤ m ≤ 105). The second line contains n space-separated pairwise distinct integers c1, c2, ..., cn. (1 ≤ ci ≤ 105).\n\nOutputPrint m lines, each line containing a single integer. The i-th line must contain the number of good vertex-weighted rooted binary trees whose weight exactly equal to i. Print the answers modulo 998244353 (7 × 17 × 223 + 1, a prime number).\n\nInputCopy2 31 2OutputCopy139InputCopy3 109 4 3OutputCopy00110242615InputCopy5 1013 10 6 4 15OutputCopy0001010205\n\nInputCopy2 31 2\n\nOutputCopy139\n\nInputCopy3 109 4 3\n\nOutputCopy00110242615\n\nInputCopy5 1013 10 6 4 15\n\nOutputCopy0001010205\n\nNoteIn the first example, there are 9 good vertex-weighted rooted binary trees whose weight exactly equal to 3:",
      "solutions": [
        {
          "title": "Codeforces Round #250 - Codeforces",
          "content": "Happy Children's Day everyone. What should you do to celebrate the special holiday?Of course, another Codeforces Round is your best choice!There is a child who is our friend. Now he has faced a lot of algorithm problem, could you please help him?We invite you to participate in Codeforces Round #250, which will take place at 17:00 MSK on 6.1 — Children's Day. This round will be held in both divisions. Note that the starting time of this round is quite unusual.Why? Because it's yet another CF Round held by Chinese! We prepared many interesting problems for you.Are you getting excited? Don't miss this round!The problems were prepared by delayyy, Picks and me. This is our first Codeforces round~~~~.Many thanks to Gerald, who gave us enormous help during the preparations for this round; to ftiasch, Kissshot and jqdai0815, who are the testers of this round; and to MikeMirzayanov, who created such a wonderful platform.In Div. 1, scores for each problem will be 500-1000-1500-2000-3000.In Div. 2, scores for each problem will be 500-1500-1500-2000-2500.Look! Your high rating is waiting for you! What are you waiting for?Just participate in this contest and write code fast and nicely, and you will take the high rating home!Good luck and have fun!UPD: The contest is over! Congratulations to winners!Top 5 of Div. 1: Alex_2oo8 Petr Dmitry_Egorov TankEngineer al13n Top 5 of Div. 2: tohdon KFDong function348 104325EA Boyuede1 Unfortunately, no one has solved the problem E in both divisions. What a sad story.... Editorial for the round will be added soon.UPD2: Editorial for the round can be found here: Editorial",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12490",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1621
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces",
          "content": "437A - The Child and HomeworkWe enumerate each choice i, and then enumerate another choice j (j ≠ i), let cnt = 0 at first, if choice j is twice longer than i let cnt = cnt + 1, if choice j is twice shorter than i let cnt = cnt - 1. So i is great if and only if cnt = 3 or cnt =  - 3.If there is exactly one great choice, output it, otherwise output C.437B - The Child and SetWe could deal with this by digits.Because lowbit(x) is taking out the lowest 1 of the number x, we can enumerate the number of the lowest zero.Then, if we enumerate x as the number of zero, we enumerate a as well, which a × 2x is no more than limit and a is odd. We can find out that lowbit(a × 2x) = 2x.In this order, we would find out that the lowbit() we are considering is monotonically decresing.Because for every two number x, y, lowbit(x) is a divisor of lowbit(y) or lowbit(y) is a divisor of lowbit(x).We can solve it by greedy. When we enumerate x by descending order, we check whether 2x is no more than sum, and check whether there is such a. We minus 2x from sum if x and a exist.If at last sum is not equal to 0, then it must be an impossible test.Why? Because if we don't choose a number whose lowbit = 2x, then we shouldn't choose two numbers whose lowbit = 2x - 1. (Otherwise we can replace these two numbers with one number)If we choose one number whose lowbit = 2x - 1, then we can choose at most one number whose lowbit = 2x - 2, at most one number whose lowbit = 2x - 3 and so on. So the total sum of them is less than 2x and we can't merge them into sum.If we don't choose one number whose lowbit = 2x - 1, then it's just the same as we don't choose one number whose lowbit = 2x.So the total time complexity is O(limit). 437C - The Child and ToyThe best way to delete all n nodes is deleting them in decreasing order of their value.Proof:Consider each edge (x, y), it will contribute to the total cost vx or vy when it is deleted.If we delete the vertices in decreasing order, then it will contribute only min(vx, vy), so the total costs is the lowest.437D - The Child and ZooFirst, there is nothing in the graph. We sort all the areas of the original graph by their animal numbers in decreasing order, and then add them one by one.When we add area i, we add all the roads (i, j), where j is some area that has been added.After doing so, we have merged some connected components. If p and q are two areas in different connected components we have merged just then, f(p, q) must equals the vi, because they are not connected until we add node i.So we use Union-Find Set to do such procedure, and maintain the size of each connected component, then we can calculate the answer easily.437E - The Child and PolygonIn this problem, you are asked to count the triangulations of a simple polygon.First we label the vertex of polygon from 0 to n - 1.Then we let f[i][j] be the number of triangulations from vertex i to vertex j. (Suppose there is no other vertices and there is an edge between i and j)If the line segment (i, j) cross with the original polygon or is outside the polygon, f[i][j] is just 0. We can check it in O(n) time.Otherwise, we have , which means we split the polygon into the triangulation from vertex i to vertex k, a triangle (i, k, j) and the triangulation from vertex k to vertex j. We can sum these terms in O(n) time.Finally,the answer is f[0][n - 1]. It's obvious that we didn't miss some triangulation. And we use a triangle to split the polygon each time, so if the triangle is different then the triangulation must be different, too. So we didn't count some triangulation more than once.So the total time complexity is O(n3), which is sufficient for this problem.438D - The Child and SequenceThe important idea of this problem is the property of .Let .So, .If k = 0, remains to be x.If k ≠ 0, .We realize every time a change happening on x, x will be reduced by at least a half.So let the energy of x become . Every time when we modify x, it may take at least 1 energy.The initial energy of the sequence is .We use a segment tree to support the query to the maximum among an interval. When we need to deal with the operation 2, we modify the maximum of the segment until it is less than x.Now let's face with the operation 3.Every time we modify an element on the segment tree, we'll charge a element with power.So the total time complexity is : .By the way, we can extend the operation 3 to assign all the elements in the interval to the same number in the same time complexity. This is an interesting idea also, but a bit harder. You can think of it.438E - The Child and Binary TreeLet f[s] be the number of good vertex-weighted rooted binary trees whose weight exactly equal to s, then we have:f[0] = 1Let F(z) be the generating function of f. That is, And then let So we have:F(z) = C(z)F(z)2 + 1`` + 1'' is for f[0] = 1.Solve this equation we have:So the remaining question is: how to calculate the multiplication inverse of a power series and the square root of a power series?There is an interesting algorithm which calculate the inverse of a power series F(z):We use f(z) ≡ g(z) (mod zn) to denote that the first n terms of f(z) and g(z) are the same.We can simply calculate a formal power series R1(z) which satisfies R1(z)F(z) ≡ 1 (mod z1)Next, if we have Rn(z) which satisfies Rn(z)F(z) ≡ 1 (mod zn), we will get:(Rn(z)F(z) - 1)2 ≡ 0 (mod z2n)Rn(z)2F(z)2 - 2Rn(z)F(z) + 1 ≡ 0 (mod z2n)1 ≡ 2Rn(z)F(z) - Rn(z)2F(z)2 (mod z2n)R2n(z) ≡ 2Rn(z) - Rn(z)2F(z) (mod z2n)We can simplely use Fast Fourier Transform to deal with multiplication. Note the unusual mod 998244353 (7 × 17 × 223 + 1), thus we can use Number Theoretic Transform.By doubling n repeatedly, we can get the first n terms of the inverse of F(z) in time. It's because that We can just use the idea of this algorithm to calculate the square root of a power series F(z):We can simply calculate a power series S1(z) which satisfies S1(z)2 ≡ F(z) (mod z2n)Next, if we have Sn(z) which satisfies Sn(z)2 ≡ F(z) (mod zn), we will get:(Sn(z)2 - F(z))2 ≡ 0 (mod z2n)Sn(z)4 - 2Sn(z)2F(z) + F(z)2 ≡ 0 (mod z2n)Sn(z)2 - 2F(z) + F(z)2Sn(z) - 2 ≡ 0 (mod z2n)4F(z) ≡ Sn(z)2 + 2F(z) + F(z)2Sn(z) - 2 (mod z2n)4F(z) ≡ (Sn(z) + F(z)Sn(z) - 1)2 (mod z2n)So, By doubling n repeatedly, we can get the first n terms of the square root of F(z) in time.That's all. What I want to share with others is this beautiful doubling algorithm.So the total time complexity of the solution to the original problem is .My codeThere is an algorithm solving this problem using divide and conquer and Fast Fourier Transform, which runs in . See the C++ code and the Java code for details.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/12513",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 438\\s*E"
          },
          "content_length": 6643
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #250 - Codeforces - Code 1",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 2",
          "code": "long long ago;\t// in a galaxy far far away",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 3",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 4",
          "code": "if(nd[i].m<x) return;\n...\nnd[i].m=nd[i].s;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 5",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 6",
          "code": "5 4\n10 20 20 20 20\n1 2\n1 3\n1 4\n1 5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 7",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 8",
          "code": "3 2\n3 2 2\n1 2\n1 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 9",
          "code": "[0 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 10",
          "code": "[X + 1 .. X + lowbit(M)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 11",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 - Codeforces - Code 12",
          "code": "A.aaaa\nB.aa\nC.aa\nD.a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12490",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 1",
          "code": "ceil(limit / 2)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 2",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 3",
          "code": "sum <= ones",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 4",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 5",
          "code": "If there is exactly one great choice then the child chooses it. Otherwise the child chooses C (the child think it is the luckiest choice).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 6",
          "code": "438D - The Child and Sequence",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 7",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #250 Editorial - Codeforces - Code 8",
          "code": "4 3\n10 20 30 40\n1 3\n2 3\n4 3",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12513",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 100000, \"c_i\");\n    inf.readEoln();\n\n    set<int> c_set(c.begin(), c.end());\n    ensuref(int(c_set.size()) == n, \"Values of c_i must be pairwise distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 100000, \"c_i\");\n    inf.readEoln();\n\n    set<int> c_set(c.begin(), c.end());\n    ensuref(int(c_set.size()) == n, \"Values of c_i must be pairwise distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> c = inf.readInts(n, 1, 100000, \"c_i\");\n    inf.readEoln();\n\n    set<int> c_set(c.begin(), c.end());\n    ensuref(int(c_set.size()) == n, \"Values of c_i must be pairwise distinct\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        /* Generate n distinct random integers between 1 and 100000 */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else if (type == \"consecutive\") {\n        /* Generate c as consecutive numbers */\n        int start = rnd.next(1, 100000 - n + 1);\n        for(int i = 0; i < n; ++i) {\n            c[i] = start + i;\n        }\n    } else if (type == \"powers_of_2\") {\n        /* Generate c as powers of 2 */\n        vector<int> powers;\n        for(int i = 0; i < 17; ++i) { // 2^17 = 131072\n            int val = 1 << i;\n            if (val <= 100000) {\n                powers.push_back(val);\n            }\n        }\n        /* If n is greater than number of powers, fill remaining with random distinct numbers */\n        set<int> c_set(powers.begin(), powers.end());\n        while (c_set.size() < n) {\n            int num = rnd.next(1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else if (type == \"primes\") {\n        /* Generate c as sequence of primes */\n        vector<int> primes;\n        vector<bool> is_prime(100001, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= 100000; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for (long long j = (long long)i * i; j <= 100000; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        for(int i = 0; i < n && i < (int)primes.size(); ++i) {\n            c[i] = primes[i];\n        }\n        if (n > (int)primes.size()) {\n            /* Fill the rest with random distinct numbers */\n            set<int> c_set(c.begin(), c.begin() + primes.size());\n            while (c_set.size() < n) {\n                int num = rnd.next(1, 100000);\n                c_set.insert(num);\n            }\n            c.assign(c_set.begin(), c_set.end());\n            shuffle(c.begin(), c.end());\n        }\n    } else if (type == \"large_c\") {\n        /* Generate c as large numbers close to 100000 */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(100000 - n + 1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else if (type == \"small_c\") {\n        /* Generate c as small numbers starting from 1 */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(1, min(100000, n * 2));\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else {\n        /* default to random */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    }\n\n    /* Output n and m */\n    printf(\"%d %d\\n\", n, m);\n    /* Output c1, c2, ..., cn */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> c(n);\n\n    if (type == \"random\") {\n        /* Generate n distinct random integers between 1 and 100000 */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else if (type == \"consecutive\") {\n        /* Generate c as consecutive numbers */\n        int start = rnd.next(1, 100000 - n + 1);\n        for(int i = 0; i < n; ++i) {\n            c[i] = start + i;\n        }\n    } else if (type == \"powers_of_2\") {\n        /* Generate c as powers of 2 */\n        vector<int> powers;\n        for(int i = 0; i < 17; ++i) { // 2^17 = 131072\n            int val = 1 << i;\n            if (val <= 100000) {\n                powers.push_back(val);\n            }\n        }\n        /* If n is greater than number of powers, fill remaining with random distinct numbers */\n        set<int> c_set(powers.begin(), powers.end());\n        while (c_set.size() < n) {\n            int num = rnd.next(1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else if (type == \"primes\") {\n        /* Generate c as sequence of primes */\n        vector<int> primes;\n        vector<bool> is_prime(100001, true);\n        is_prime[0] = is_prime[1] = false;\n        for(int i = 2; i <= 100000; ++i) {\n            if(is_prime[i]) {\n                primes.push_back(i);\n                for (long long j = (long long)i * i; j <= 100000; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        for(int i = 0; i < n && i < (int)primes.size(); ++i) {\n            c[i] = primes[i];\n        }\n        if (n > (int)primes.size()) {\n            /* Fill the rest with random distinct numbers */\n            set<int> c_set(c.begin(), c.begin() + primes.size());\n            while (c_set.size() < n) {\n                int num = rnd.next(1, 100000);\n                c_set.insert(num);\n            }\n            c.assign(c_set.begin(), c_set.end());\n            shuffle(c.begin(), c.end());\n        }\n    } else if (type == \"large_c\") {\n        /* Generate c as large numbers close to 100000 */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(100000 - n + 1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else if (type == \"small_c\") {\n        /* Generate c as small numbers starting from 1 */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(1, min(100000, n * 2));\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    } else {\n        /* default to random */\n        set<int> c_set;\n        while (c_set.size() < n) {\n            int num = rnd.next(1, 100000);\n            c_set.insert(num);\n        }\n        c.assign(c_set.begin(), c_set.end());\n        shuffle(c.begin(), c.end());\n    }\n\n    /* Output n and m */\n    printf(\"%d %d\\n\", n, m);\n    /* Output c1, c2, ..., cn */\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d%c\", c[i], \" \\n\"[i == n - 1]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type small_c\n./gen -n 1 -m 100000 -type small_c\n./gen -n 1 -m 1 -type large_c\n./gen -n 1 -m 100000 -type large_c\n./gen -n 2 -m 2 -type consecutive\n./gen -n 2 -m 100000 -type consecutive\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 100000 -type random\n./gen -n 100000 -m 1 -type small_c\n./gen -n 100000 -m 1 -type large_c\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 100000 -type powers_of_2\n./gen -n 99999 -m 99999 -type consecutive\n./gen -n 100000 -m 50000 -type small_c\n./gen -n 100000 -m 50000 -type large_c\n./gen -n 100000 -m 100000 -type primes\n./gen -n 50000 -m 100000 -type primes\n./gen -n 100000 -m 100000 -type powers_of_2\n./gen -n 99999 -m 100000 -type powers_of_2\n./gen -n 100000 -m 2 -type small_c\n./gen -n 1 -m 100000 -type small_c\n./gen -n 100000 -m 3 -type small_c\n./gen -n 100000 -m 99999 -type consecutive\n./gen -n 50000 -m 100000 -type consecutive\n./gen -n 100000 -m 1 -type random\n./gen -n 100 -m 2 -type random\n./gen -n 1000 -m 100000 -type consecutive\n./gen -n 1000 -m 100000 -type powers_of_2\n./gen -n 1000 -m 100000 -type random\n./gen -n 1000 -m 100000 -type primes\n./gen -n 1000 -m 100000 -type large_c\n./gen -n 100 -m 100000 -type small_c\n./gen -n 100 -m 100000 -type random\n./gen -n 99999 -m 99999 -type small_c\n./gen -n 99999 -m 99999 -type large_c\n./gen -n 100000 -m 100000 -type primes\n./gen -n 100000 -m 100000 -type random\n./gen -n 2 -m 3 -type random\n./gen -n 3 -m 6 -type small_c\n./gen -n 100000 -m 100000 -type small_c\n./gen -n 100000 -m 100000 -type large_c\n./gen -n 50000 -m 50000 -type small_c\n./gen -n 50000 -m 50000 -type large_c\n./gen -n 1000 -m 1000 -type consecutive\n./gen -n 1000 -m 1000 -type powers_of_2\n./gen -n 1000 -m 1000 -type random\n./gen -n 2 -m 100000 -type powers_of_2\n./gen -n 100000 -m 100000 -type consecutive\n./gen -n 100000 -m 1 -type random\n./gen -n 1 -m 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:26.494445",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "439/A",
      "title": "A. Devu, the Singer and Churu, the Joker",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two space separated integers n, d (1 ≤ n ≤ 100; 1 ≤ d ≤ 10000). The second line contains n space-separated integers: t1, t2, ..., tn (1 ≤ ti ≤ 100).",
      "output_spec": "OutputIf there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.",
      "sample_tests": "ExamplesInputCopy3 302 2 1OutputCopy5InputCopy3 202 1 1OutputCopy-1",
      "description": "A. Devu, the Singer and Churu, the Joker\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two space separated integers n, d (1 ≤ n ≤ 100; 1 ≤ d ≤ 10000). The second line contains n space-separated integers: t1, t2, ..., tn (1 ≤ ti ≤ 100).\n\nOutputIf there is no way to conduct all the songs of Devu, output -1. Otherwise output the maximum number of jokes that Churu can crack in the grand event.\n\nInputCopy3 302 2 1OutputCopy5InputCopy3 202 1 1OutputCopy-1\n\nInputCopy3 302 2 1\n\nOutputCopy5\n\nInputCopy3 202 1 1\n\nOutputCopy-1\n\nNoteConsider the first example. The duration of the event is 30 minutes. There could be maximum 5 jokes in the following way:  First Churu cracks a joke in 5 minutes.  Then Devu performs the first song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now Devu performs second song for 2 minutes.  Then Churu cracks 2 jokes in 10 minutes.  Now finally Devu will perform his last song in 1 minutes.  Total time spent is 5 + 2 + 10 + 2 + 10 + 1 = 30 minutes.Consider the second example. There is no way of organizing Devu's all songs. Hence the answer is -1.",
      "solutions": [
        {
          "title": "Codeforces Round #251 - Codeforces",
          "content": "Hi everyone, Codeforces round #251 for division 2 participants will start at June 4, Wednesday, 19:30 MSK (usual time). Traditionally we invite Div.1 participants to take part out of the competition.The round was prepared by me (PraveenDhinwa). This is my first codeforces round. I have tried my best to make the problem statements as clear as possible. I hope that everyone will enjoy the round.Special thanks to Gerald(Gerald), for his extensive help in problem ideas verification, problem testing, without his help the contest would not have seen the day. English translation is done by me with a lot of help from Gerald Agapov(Gerald). Problems are translated in Russian by Maria Belova(Delinur).Many thanks to Pratik Moona(pratikmoona), Varun Nitish(JuanMata) for providing their help in testing of round. Their help is greatly appreciated :)Many thanks to Devendra Agrawal(devu)Utkarsh Lath(utkarshl) to helping me in verifying the ideas of problem statements. Many thanks to Mike Mirzayanov(MikeMirzayanov) for creating this wonderful platform :)The contest problems are dedicated to my dear friend Devu (devu), He once proposed problem titled \"Churu, the thief\". Churu is my nick-name. So it is now time to take some revenge in a funny way :P Score distribution for the contest is standard: 500-1000-1500-2000-2500.I have a good news for you too. Tutorial of the contest will be available as soon as the contest ends :).I wish all the participants good luck, high rating and lot of hacks :) Don't miss the round.UPD Thank you everyone for participating. I hope that you have enjoyed the round, Thank you all !!Editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12518",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1627
        },
        {
          "title": "Codeforces Round #251 Editorial - Codeforces",
          "content": "439A - Devu, the Singer and Churu, the JokerFor checking whether there is a way to conduct all the songs of the singer, you can conduct the event in the following way. First singer will sing a song. Then during 10 minutes rest of the singer, the joker will crack 2 jokes(each of 5 minutes) Then singer will again sing a song, then joker, etc. After the singer has completes all his songs, the joker will keep on cracking jokes of 5 minutes each. Hence minimum duration of the even needed such that sing could sing all his songs will be t1 + 10 + t2 + 10 + ... +tn = sum + (n - 1) * 10 where sum denote the total time of the songs of the singer.So for checking feasibility of the solution, just check whether sum + (n - 1) * 10 ≤ duration or not?. If it is feasible, then time remaining for joker will be the entire duration except the time when the singer is singing the song. Hence time available for the joker will be duration - sum. In that time joker will sing songs.Solution codes my solution 439B - Devu, the Dumb GuyYou can formulate the problem in following way. Given two arrays a and b. Find minimum cost of matching the elements of array a to b. For our problem the array a will be same as b. The array b will have content x, x — 1, , 1, 1. For a general version of this problem, we can use min cost max flow(min cost matching), but for this problem following simple greedy solution will work. Sort the array a in increasing and b in decreasing order (or vice versa). Now match ith element of the array a with ith element of array b. Proof:It can be easily proved by exchange argument. Solution Codes my solution 439C - Devu and Partitioning of the ArrayLet us first try to find the condition required to make sure the existence of the partitions. Notice the following points. If the parity of sum does not match with parity of number of odd partitions (k - p) , then we can't create the required partitions. eg. a = [1;2], k = 2, p = 0, Then you can not create two partitions of odd size, because then sum of the elements of the partitions of the array will be even whereas the sum of elements of the array is odd. If number of odd elements in a are less than k - p (number of required partitions with odd sum), then we can not do a valid partitioning. If number of even elements are less than p, then we can not create even partitions simply by using even numbers, we have to use odd numbers too. Notice the simple fact that sum of two odd numbers is even. Hence we will try to include 2 odd elements in our partitions too. So if we can create oddsRemaining / 2 partitions in which every partition contains 2 odd elements, then we can do a valid partitioning otherwise we can't. Here oddsRemaining denotes the number of odd elements which are not used in any of the partitions made up to now. Let oddElements denotes the number of odd elements in array a. Similarly evenElements denotes the number of even elements.So the answer exists if Number of possible odd partitions are  ≥  k - p i.e. oddElements ≥ k - p. Number of possible even partitions are  ≥  p i.e. evenElements + (oddRemaining) / 2 ≥ p. where oddRemaining is oddElements - (k - p). For generating the actual partitions, you can follow the same strategy used in detecting the existence of the partitions. We will first generate any valid p partitions (forget about the condition of using the entire array), then we can simply include the remaining elements of the array in the last partition and we are done.Solution Codes [user:Gerald]'s solution my code 439D - Devu and his BrotherYou can solve the problem in two ways. By using ternary search Let us define a function f. Function f(k) = cost needed to make array a elements  ≥  k + cost needed to make array b elements  ≤  kInstead of proving it formally, try checking the property on many random test cases. You will realize that f is convex.Claim: f is convex:Proof:It is fairly easy to prove. See the derivative of f. = — (# of elements of b > k) + (# of elements of a < k)The first term (without sign) can only decrease as k increases whereas second term can only increase as k increases.So, By using the fact that optimal values are attainable at the array values: All the extremum points will lie in the elements from the any of the arrays because f is convex and at the event points (or the points of array a and b).For learning more about ternary search, you can see following topcoder discussionAnother smart solutionPlease see following comment of goovie and proof is given in the reply by himankSolutions Code ternary search solution my solution using 2nd fact [user:Gerald] solution [user:triveni] solution using smart solution 439E - Devu and Birthday CelebrationThere are two possible solutions.dp solutionLet P(n, f) be total number of ways of partitioning n into f segments such that each ai is positive. With some manipulations of the generating function, you can find that this is equal to .So Let F(n, f, g) denotes partitions of n into f parts such that gcd of all the ai's is g.Note that F(n, f, 1) = P(n, f) — sum of F(n, f, g) over all possible gcd g's. So g will be a divisor of n.In other words, As .You can implement this solution by a simple dp.You can pre-calculate factorials which will help you to calculate .Complexity of this solution will be nlogn over all the test cases.Please note that this solution might get time limit exceeded in Java. Please read the comment. Mathematical solutionNote that F(n, f, 1) = P(n, f) — sum of F(n, f, g) over all possible gcd g's (g > 1 such that g is a divisor of n.In other words, As F(n, f, g) = .Now you have to use Möbius inversion formula.Theorem:If f and g are two arithmetic functions satisfyingthen So In our case: g(n) is P(n, f) and f(n) is F(n, f, 1).For proving complexity: Use the fact that total number of divisors of a number from 1 to n is Please also see xorfire comment for understanding the relation between mobius function and the solution using inclusion exclusion principle.Solution Codes my solution using mobius function [user:Gerald]'s code based on first solution [user:Balajiganapathi,2014-06-05]'s inclusion exclusion principle",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/12545",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 439\\s*A"
          },
          "content_length": 6154
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #251 - Codeforces - Code 1",
          "code": "void main ( )",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12518",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #251 - Codeforces - Code 2",
          "code": "#undef int\nint main() {\n#define int long long",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12518",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #251 - Codeforces - Code 3",
          "code": "#undef int\nint main() {\n#define int long long",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/12518",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #251 - Codeforces - Code 4",
          "code": "if (Ge[p-1].size()==0)\n{\n     cout<<\"NO\\n\";\n     return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12518",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #251 - Codeforces - Code 5",
          "code": "if (Ge[p-1].size()==0)\n{\n     cout<<\"NO\\n\";\n     return 0;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12518",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #251 Editorial - Codeforces - Code 1",
          "code": "Collections.sort()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12545",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #251 Editorial - Codeforces - Code 2",
          "code": "Long Key =  (( Long ) N <<  32 )  + F ;  if  ( cache . containsKey ( Key ))  {              return cache . Get ( Key );    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/12545",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 100, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 100, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int d = inf.readInt(1, 10000, \"d\");\n    inf.readEoln();\n    vector<int> t = inf.readInts(n, 1, 100, \"t_i\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int min_t = opt<int>(\"min_t\", 1);\n    int max_t = opt<int>(\"max_t\", 100);\n    string t_type = opt<string>(\"t_type\", \"random\"); // Type of t_i values: \"random\", \"min\", \"max\", \"increasing\", \"decreasing\"\n    string d_type = opt<string>(\"d_type\", \"random\"); // Total duration type: \"impossible\", \"exact\", \"extra\"\n    int extra_time = opt<int>(\"extra_time\", 0);      // Extra time in case d_type is \"extra\"\n\n    // Generate t_i according to t_type\n    vector<int> t(n);\n    if (t_type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = min_t;\n    } else if (t_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = max_t;\n    } else if (t_type == \"increasing\") {\n        int step = (max_t - min_t) / max(1, n - 1);\n        for (int i = 0; i < n; ++i)\n            t[i] = min_t + step * i;\n    } else if (t_type == \"decreasing\") {\n        int step = (max_t - min_t) / max(1, n - 1);\n        for (int i = 0; i < n; ++i)\n            t[i] = max_t - step * i;\n    } else {\n        // Random t_i between min_t and max_t\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(min_t, max_t);\n    }\n\n    // Compute totalDevuTime = sum(ti) + 10 * (n - 1)\n    long long sum_ti = accumulate(t.begin(), t.end(), 0LL);\n    long long totalDevuTime = sum_ti + 10LL * (n - 1);\n\n    // Determine d according to d_type\n    long long d;\n    if (d_type == \"impossible\") {\n        // Set d less than totalDevuTime\n        d = totalDevuTime - rnd.next(1, 20); // Ensure d < totalDevuTime\n        if (d < 1) d = 1; // Ensure d >= 1\n    } else if (d_type == \"exact\") {\n        // Set d equal to totalDevuTime\n        d = totalDevuTime;\n    } else if (d_type == \"extra\") {\n        // Set d greater than totalDevuTime\n        d = totalDevuTime + extra_time;\n        if (d > 10000) d = 10000; // Ensure d <= 10000\n    } else {\n        // Random d between totalDevuTime and 10000\n        d = rnd.next(totalDevuTime, min(10000LL, totalDevuTime + 1000));\n    }\n\n    // Ensure d is within [1, 10000]\n    if (d < 1) d = 1;\n    if (d > 10000) d = 10000;\n\n    // Adjust t_i to ensure they are within [1, 100]\n    for (int i = 0; i < n; ++i) {\n        if (t[i] < 1) t[i] = 1;\n        if (t[i] > 100) t[i] = 100;\n    }\n\n    // Output n and d\n    printf(\"%d %lld\\n\", n, d);\n\n    // Output t_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int min_t = opt<int>(\"min_t\", 1);\n    int max_t = opt<int>(\"max_t\", 100);\n    string t_type = opt<string>(\"t_type\", \"random\"); // Type of t_i values: \"random\", \"min\", \"max\", \"increasing\", \"decreasing\"\n    string d_type = opt<string>(\"d_type\", \"random\"); // Total duration type: \"impossible\", \"exact\", \"extra\"\n    int extra_time = opt<int>(\"extra_time\", 0);      // Extra time in case d_type is \"extra\"\n\n    // Generate t_i according to t_type\n    vector<int> t(n);\n    if (t_type == \"min\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = min_t;\n    } else if (t_type == \"max\") {\n        for (int i = 0; i < n; ++i)\n            t[i] = max_t;\n    } else if (t_type == \"increasing\") {\n        int step = (max_t - min_t) / max(1, n - 1);\n        for (int i = 0; i < n; ++i)\n            t[i] = min_t + step * i;\n    } else if (t_type == \"decreasing\") {\n        int step = (max_t - min_t) / max(1, n - 1);\n        for (int i = 0; i < n; ++i)\n            t[i] = max_t - step * i;\n    } else {\n        // Random t_i between min_t and max_t\n        for (int i = 0; i < n; ++i)\n            t[i] = rnd.next(min_t, max_t);\n    }\n\n    // Compute totalDevuTime = sum(ti) + 10 * (n - 1)\n    long long sum_ti = accumulate(t.begin(), t.end(), 0LL);\n    long long totalDevuTime = sum_ti + 10LL * (n - 1);\n\n    // Determine d according to d_type\n    long long d;\n    if (d_type == \"impossible\") {\n        // Set d less than totalDevuTime\n        d = totalDevuTime - rnd.next(1, 20); // Ensure d < totalDevuTime\n        if (d < 1) d = 1; // Ensure d >= 1\n    } else if (d_type == \"exact\") {\n        // Set d equal to totalDevuTime\n        d = totalDevuTime;\n    } else if (d_type == \"extra\") {\n        // Set d greater than totalDevuTime\n        d = totalDevuTime + extra_time;\n        if (d > 10000) d = 10000; // Ensure d <= 10000\n    } else {\n        // Random d between totalDevuTime and 10000\n        d = rnd.next(totalDevuTime, min(10000LL, totalDevuTime + 1000));\n    }\n\n    // Ensure d is within [1, 10000]\n    if (d < 1) d = 1;\n    if (d > 10000) d = 10000;\n\n    // Adjust t_i to ensure they are within [1, 100]\n    for (int i = 0; i < n; ++i) {\n        if (t[i] < 1) t[i] = 1;\n        if (t[i] > 100) t[i] = 100;\n    }\n\n    // Output n and d\n    printf(\"%d %lld\\n\", n, d);\n\n    // Output t_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", t[i]);\n        if (i < n - 1)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal input case\n./gen -n 1 -t_type min -d_type exact\n\n# Maximal input case\n./gen -n 100 -t_type max -d_type exact\n\n# Random t_i, totalDevuTime equals d\n./gen -n 50 -t_type random -d_type exact\n\n# Random t_i, totalDevuTime less than d\n./gen -n 50 -t_type random -d_type extra -extra_time 100\n\n# Random t_i, totalDevuTime greater than d (impossible case)\n./gen -n 50 -t_type random -d_type impossible\n\n# All t_i minimal, d minimal\n./gen -n 10 -t_type min -d_type exact\n\n# All t_i maximal, d maximal\n./gen -n 10 -t_type max -d_type exact\n\n# Increasing t_i, totalDevuTime equals d\n./gen -n 20 -t_type increasing -d_type exact\n\n# Decreasing t_i, totalDevuTime equals d\n./gen -n 20 -t_type decreasing -d_type exact\n\n# Random t_i, totalDevuTime is slightly less than d\n./gen -n 30 -t_type random -d_type extra -extra_time 5\n\n# Random t_i, RemainingTime less than 5 (no extra jokes)\n./gen -n 40 -t_type random -d_type exact\n\n# Random t_i, RemainingTime exactly 4 (less than 5)\n./gen -n 40 -t_type random -d_type extra -extra_time 4\n\n# Random t_i, RemainingTime is 0\n./gen -n 60 -t_type random -d_type exact\n\n# Random t_i, RemainingTime is exactly 5\n./gen -n 70 -t_type random -d_type extra -extra_time 5\n\n# Random t_i, sum(t_i) is large, rest time is small\n./gen -n 100 -t_type max -d_type extra -extra_time 50\n\n# Random t_i, sum(t_i) is small, rest time is large\n./gen -n 100 -t_type min -d_type extra -extra_time 500\n\n# Random t_i, n is minimal\n./gen -n 1 -t_type random -d_type extra -extra_time 10\n\n# Random t_i, n is maximal\n./gen -n 100 -t_type random -d_type extra -extra_time 200\n\n# Random t_i, totalDevuTime is just less than d\n./gen -n 80 -t_type random -d_type extra -extra_time 2\n\n# Random t_i, totalDevuTime is just more than d (impossible case)\n./gen -n 80 -t_type random -d_type impossible\n\n# All t_i are 1, minimal rest time\n./gen -n 100 -min_t 1 -max_t 1 -t_type min -d_type extra -extra_time 10\n\n# All t_i are 100, maximal rest time\n./gen -n 100 -min_t 100 -max_t 100 -t_type max -d_type extra -extra_time 10\n\n# Random t_i, varying extra_time\n./gen -n 50 -t_type random -d_type extra -extra_time 15\n./gen -n 50 -t_type random -d_type extra -extra_time 30\n./gen -n 50 -t_type random -d_type extra -extra_time 100\n\n# Edge case: d = 1\n./gen -n 1 -t_type min -d_type impossible\n\n# Edge case: d = 10000\n./gen -n 100 -t_type max -d_type extra -extra_time 10000\n\n# Edge case: n = 1, t_i = 100, d minimal\n./gen -n 1 -min_t 100 -max_t 100 -t_type max -d_type exact\n\n# Edge case: n = 100, t_i = 1, d maximal\n./gen -n 100 -min_t 1 -max_t 1 -t_type min -d_type extra -extra_time 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:28:28.365316",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}