{
  "metadata": {
    "batch_number": 48,
    "batch_size": 100,
    "problems_in_batch": 100,
    "total_processed": 4900,
    "created_at": "2025-08-28T20:45:17.020445",
    "format": "wenjiajia_v1.0_incremental"
  },
  "problems": [
    {
      "problem_id": "512/E",
      "title": "E. Fox And Polygon",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contain an integer n (4 ≤ n ≤ 1000), number of edges of the regular polygon. Then follows two groups of (n - 3) lines describing the original triangulation and goal triangulation.Description of each triangulation consists of (n - 3) lines. Each line contains 2 integers ai and bi (1 ≤ ai, bi ≤ n), describing a diagonal ai – bi.It is guaranteed that both original and goal triangulations are correct (i. e. no two diagonals share a common internal point in both of these triangulations).",
      "output_spec": "OutputFirst, output an integer k (0 ≤ k ≤ 20, 000): number of steps.Then output k lines, each containing 2 integers ai and bi: the endpoints of a diagonal you are going to flip at step i. You may output ai and bi in any order.If there are several possible solutions, output any of them.",
      "sample_tests": "ExamplesInputCopy41 32 4OutputCopy11 3InputCopy62 63 64 66 25 24 2OutputCopy26 36 4InputCopy87 12 77 36 34 66 16 26 36 46 8OutputCopy37 37 27 1",
      "description": "E. Fox And Polygon\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contain an integer n (4 ≤ n ≤ 1000), number of edges of the regular polygon. Then follows two groups of (n - 3) lines describing the original triangulation and goal triangulation.Description of each triangulation consists of (n - 3) lines. Each line contains 2 integers ai and bi (1 ≤ ai, bi ≤ n), describing a diagonal ai – bi.It is guaranteed that both original and goal triangulations are correct (i. e. no two diagonals share a common internal point in both of these triangulations).\n\nOutputFirst, output an integer k (0 ≤ k ≤ 20, 000): number of steps.Then output k lines, each containing 2 integers ai and bi: the endpoints of a diagonal you are going to flip at step i. You may output ai and bi in any order.If there are several possible solutions, output any of them.\n\nInputCopy41 32 4OutputCopy11 3InputCopy62 63 64 66 25 24 2OutputCopy26 36 4InputCopy87 12 77 36 34 66 16 26 36 46 8OutputCopy37 37 27 1\n\nInputCopy41 32 4\n\nOutputCopy11 3\n\nInputCopy62 63 64 66 25 24 2\n\nOutputCopy26 36 4\n\nInputCopy87 12 77 36 34 66 16 26 36 46 8\n\nOutputCopy37 37 27 1\n\nNoteSample test 2 is discussed above and shown on the picture.",
      "solutions": [
        {
          "title": "Codeforces Round #290 - Codeforces",
          "content": "Fox Ciel is back!I invite you to participate in Codeforces Round #290, which will start at the standard time on next Monday: This is my 4th round on Codeforces, my previous rounds: #190, #228, #270.Last Div1 Round (#286) is so hard, so after notice that, we decide to reduce the difficulty of this round. (For example, current Div1-E was used as Div1-D) I hope more people can enjoy all tasks in this round: this time no task requires advanced knowledge like linear space or Fourier Transform.The background story will be Fox Ciel's life: learning programming, play games, traveling, have dinner and so on.Like Round #228, top-20 contestants that are currently at Petrozavodsk training camp will be rewarded with nice Codefores T-Shirts. Contestant may be a team member, jury, coach, organizer, or whoever else involved in camp, no matter of status.As usual, thanks to Zlobober for giving great suggestions and test my round, and MikeMirzayanov for the platform (Codeforces and Polygon). Good luck and have fun!Update1: Score Distribution is ... Div2: Standard (500 — 1000 — 1500 — 2000 — 2500), Div1: a bit unusual ... (500 — 1000 — 1500 — 2250 — 2250)Update2: Editorial: http://codeforces.com/blog/entry/16173Update3: Congratulation to our winners:Div1: Petr Endagorion mmaxio jqdai0815 tourist They are all people who solved 5 tasks!Div2: SkullSkin joshkirstein gabrielinelus UnknownNooby Andrey_WK",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16147",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1401
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces",
          "content": "Update 1 : here are the reference solutions for this contest: Div2-A: http://ideone.com/JP1Ksj DIv2-B: http://ideone.com/udz3bN Div2-C / Div1-A: http://ideone.com/KVobNb Div2-D / Div1-B: http://ideone.com/7MQqOm Div2-E / Div1-C: http://ideone.com/z3FsU2 Div1-D: http://ideone.com/Y7j21a Div1-E: http://ideone.com/Orbacp Note that for Div2-E / Div1-C, it is for the harder version: we need to handle '1' in the cycle.510A - Fox And SnakeThere are 2 different ways to solve this kind of task:First one is to simulate the movement of the snake head, and you draw '#'s on the board. The code will look like: head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the boardAnother way is to do some observation about the result, you can find this pattern: (4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"510B - Fox And Two DotsThis task is essentially ask if there is a cycle in an undirected graph: treat each cell as a node, and add an edge if two cells are neighborhood and have some color.There are lots of ways to do this, for example: Run dfs / bfs, if an edge lead you to a visited node, then there must be a cycle. For each connected component, test if |#edges| = |#nodes| - 1, if not then there must be a cycle. 510C - Fox And Names / 512A - Fox And NamesLet's first think about what S < T can tell us: suppose S = abcxyz and T = abcuv. Then we know that S < T if and only if x < u by the definition.So we can transform the conditions name1 < name2, name2 < name3 ... into the order of letters.Then the question become: do we have a permutation that satisfy those conditions. It is actually the classic topological order question.One trick in this task is that, if we have something like xy < x then there is no solution. This is not covered in pretests. :)510D - Fox And Jumping / 512B - Fox And JumpingThis task equals to: what is the minimal sum of costs that we can select k cards, so their GCD is 1.First observation is that: GCD(x1, x2, ..., xk) = 1 means that for any prime p, there exist i such that xi is not dividable by p. So we only care about what prime factors a number contain. (So for example, 12 -> {2, 3}, 6 -> {2, 3}, 9 -> {3]})The second observation is: If x ≤ 109 then it has at most 9 prime factors.So after we select one number, we only care about these 9 or less primes. Then this problem equals to set covering problem (SCP), it can be done by mask DP. It can run in about O(2^9 * n^2).510E - Fox And Dinner / 512C - Fox And DinnerFirst finding is: if a + b is a prime, then one of them is an odd number, another is an even number. (that's why we set 2 ≤ xi)Then we could find: every odd number have exactly 2 even number as neighborhood, and every even number have exactly 2 odd number as neighborhood. And that means we need |#even| = |#odd| to have a solution.So it looks like bipartite graph matching, but every element matched 2 elements. And in fact it can be handled by maxflow: For each odd number, we add a node on the left side and link it from source with capacity equals to 2, and for each even number, we add a node on the right side and link it to sink with capacity equals to 2. And if sum of two numbers is a prime number, we link them with capacity equals to 1.Then we solve the max flow, it have solution if and only if maxflow = 2 * |#even|.We can construct the answer(cycles) from the matches.Note: Actually this task is still solvable if we allow ai = 1. But you need some clever way to deal with it. We think it is too hard so we removed this case. What do you think about this decision?512D - Fox And TravellingWe could find that some nodes cannot be visited. And more specific, if one node is in a cycle then it cannot be visited. So what about the structure of nodes that we can visit?Let's first find a way to get all nodes that could be visited. We can deal with this by something like biconnected decomposition, but that is not easy to implement. In fact we can use this simple method: each time we pick one node that have at most 1 neighborhood and delete it. Repeat this process until we can't do it anymore.We could find these nodes are actually belonging to these 2 kinds: 1. A tree. 2. Rooted tree. (that means, the root is attached to a cycle)The rooted tree case is simple: we can solve it by tree DP. The state will be dp[i][j] = the way to remove j nodes in the subtree rooted at i.Then how to solve the unrooted tree case? The way to deal with that is to transform it into rooted case. We have 2 solution: We select one unvisited node as the root by some rules: for example, we select one with minimal index. Then we just need to modify the DP a bit to adjust this additional condition. We could find if the tree has n nodes and we visit k nodes in the end, then there will be max(1, n-k) ways to choose the root. That means if we choose every node as the root and sum up them, we will count this case exactly max(1, n-k) times. So we just do the rooted DP for from node n times, and divide max(1, n-k) for ans[k]. The overall complicity is O(n4), and it can be optimize into O(n3) if you like.512E - Fox And PolygonTriangulation of polygon is something hard to think about. So the first key observation is that, we can transform this task into operations on rooted trees!One Triangulation of polygon can be mapping to one rooted tree. And the flip operation can be mapping to the rotation of trees. (It is the operation we used to balance our BST) You can find the mapping from above picture. The red lines indicate the edge that will be flipped and the nodes we rotated.Then we should find a standard shape of the tree, and solve this task: how to rotate any tree into this standard shape?My solution is to choose the balanced tree as standard shape. The way to do that is this: find the node that the index is the middle number, rotate it to the top(that what we did for splay tree), and do the same thing for each subtree.It is easy to see it could work in O(nlogn) steps.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16173",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 512\\s*E"
          },
          "content_length": 6165
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #290 - Codeforces - Code 1",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 - Codeforces - Code 2",
          "code": "26\na\nb\nc\n...\nz",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16147",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 1",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 2",
          "code": "head = (1, 1)\nrepeat:\n\trepeat m-1 times: head move to right\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\n\trepeat m-1 times: head move to left\n\trepeat 2 times: head move down\n\trepeat 2 times: head move down\nuntil head is out of the board",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 3",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 4",
          "code": "(4k+1) / (4k+3) line: \"#######\"\n(4k+2) line: \".......#\"\n(4k+0) line: \"#.......\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 5",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 6",
          "code": "for (i64 i = 0; i < n; i++) {\n    hepsi[ l[i] ] = c[i];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 7",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 8",
          "code": "hepsi[ 0 ] = 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 9",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 10",
          "code": "s = primes.size();\n\nfor(int mask = 0; mask < (1<<s); mask++){\n\tdp[mask] = INF;\n}\n\t\t\ndp[m[i]] = c[i];\n\t\t\nfor(int mask = 0; mask < (1<<s); mask++){\n\tfor(int j = 0; j < n; j++){\n\t\tif(dp[mask] != INF)\n\t\t\tdp[mask | m[j]] = min(dp[mask | m[j]], dp[mask] + c[j]);\n\t}\n}\n\nans = min(ans, dp[(1<<s) - 1]);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 11",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 12",
          "code": "3 3\nBAB\nAAA\nBAB",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 13",
          "code": "#include<Stdio.h>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 14",
          "code": "dp[i][sz[i]] = dp[i][sz[i] - 1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 15",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 16",
          "code": "dpValue dfs(int cur, int from)\n{\n\tdpValue ret;\n\tret.x[0] = 1;\n\tfor(int i = 0; i < e[cur].size(); i++)\n\t{\n\t\tint t = e[cur][i];\n\t\tif(t == from) continue;\n\t\tret = combine(ret, dfs(t, cur));\n\t}\n\tfor(int i = 0; i < MAXN; i++)\n\t\tif(ret.x[i] == 0)\n\t\t{\n\t\t\tret.x[i] = ret.x[i-1];\n\t\t\tbreak;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 17",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 18",
          "code": "dpValue combine(dpValue A, dpValue B)\n{\n\tdpValue ret;\n\tfor(int i = 0; i < MAXN; i++)\n\t\tfor(int j = 0; i+j < MAXN; j++)\n\t\t{\n\t\t\tret.x[i+j] += ((A.x[i] * B.x[j]) % mod) * C(i+j, i);\n\t\t\tret.x[i+j] %= mod;\n\t\t}\n\treturn ret;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 19",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #290 Editorial - Codeforces - Code 20",
          "code": "4\n2 4 5 7\n1 1 1 1000000000",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16173",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nbool isBetween(int a, int b, int c)\n{\n    // Return true if c is strictly between a and b in the polygon\n    if (a == b)\n        return false; // No length\n    int n = ::n; // Use global n\n    int dist_ac = (c - a + n) % n;\n    int dist_ab = (b - a + n) % n;\n    if (dist_ab == 0)\n        return false; // Should not happen\n    return 0 < dist_ac && dist_ac < dist_ab;\n}\n\nbool segmentsCross(int a1, int b1, int a2, int b2)\n{\n    if (a1 == a2 || a1 == b2 || b1 == a2 || b1 == b2)\n        return false; // Share endpoint, that's okay\n    bool cond1 = isBetween(a1, b1, a2);\n    bool cond2 = isBetween(a1, b1, b2);\n    bool cond3 = isBetween(a2, b2, a1);\n    bool cond4 = isBetween(a2, b2, b1);\n    return (cond1 != cond2) && (cond3 != cond4);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    n = inf.readInt(4, 1000, \"n\");\n    inf.readEoln();\n    \n    // Build the set of edges of the polygon\n    set<pair<int,int>> edges;\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i + 1) % n;\n        if (u > v) swap(u, v);\n        edges.insert(make_pair(u, v));\n    }\n    \n    for (int t = 0; t < 2; ++t) { // For each of the two triangulations\n        vector<pair<int,int>> diagonals;\n        set<pair<int,int>> diagonalSet;\n        for (int i = 0; i < n - 3; ++i) {\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            inf.readEoln();\n            \n            int u = ai - 1; // Adjust to 0-based indexing\n            int v = bi - 1;\n            \n            ensuref(u != v, \"Diagonal endpoints must be different: (%d, %d)\", ai, bi);\n            ensuref(0 <= u && u < n, \"Vertex index out of range: %d\", ai);\n            ensuref(0 <= v && v < n, \"Vertex index out of range: %d\", bi);\n            \n            int a = min(u, v);\n            int b = max(u, v);\n            \n            ensuref(edges.find(make_pair(a, b)) == edges.end(), \"Diagonal (%d, %d) cannot be an edge of the polygon\", ai, bi);\n            ensuref(diagonalSet.find(make_pair(a, b)) == diagonalSet.end(), \"Duplicate diagonal (%d, %d)\", ai, bi);\n            \n            diagonalSet.insert(make_pair(a, b));\n            diagonals.push_back(make_pair(u, v));\n        }\n        \n        // Check for crossings\n        int m = diagonals.size();\n        for (int i = 0; i < m; ++i) {\n            int a1 = diagonals[i].first;\n            int b1 = diagonals[i].second;\n            for (int j = i + 1; j < m; ++j) {\n                int a2 = diagonals[j].first;\n                int b2 = diagonals[j].second;\n                if (segmentsCross(a1, b1, a2, b2)) {\n                    ensuref(false, \"Diagonals (%d, %d) and (%d, %d) cross\", a1 + 1, b1 + 1, a2 + 1, b2 + 1);\n                }\n            }\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nbool isBetween(int a, int b, int c)\n{\n    // Return true if c is strictly between a and b in the polygon\n    if (a == b)\n        return false; // No length\n    int n = ::n; // Use global n\n    int dist_ac = (c - a + n) % n;\n    int dist_ab = (b - a + n) % n;\n    if (dist_ab == 0)\n        return false; // Should not happen\n    return 0 < dist_ac && dist_ac < dist_ab;\n}\n\nbool segmentsCross(int a1, int b1, int a2, int b2)\n{\n    if (a1 == a2 || a1 == b2 || b1 == a2 || b1 == b2)\n        return false; // Share endpoint, that's okay\n    bool cond1 = isBetween(a1, b1, a2);\n    bool cond2 = isBetween(a1, b1, b2);\n    bool cond3 = isBetween(a2, b2, a1);\n    bool cond4 = isBetween(a2, b2, b1);\n    return (cond1 != cond2) && (cond3 != cond4);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    n = inf.readInt(4, 1000, \"n\");\n    inf.readEoln();\n    \n    // Build the set of edges of the polygon\n    set<pair<int,int>> edges;\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i + 1) % n;\n        if (u > v) swap(u, v);\n        edges.insert(make_pair(u, v));\n    }\n    \n    for (int t = 0; t < 2; ++t) { // For each of the two triangulations\n        vector<pair<int,int>> diagonals;\n        set<pair<int,int>> diagonalSet;\n        for (int i = 0; i < n - 3; ++i) {\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            inf.readEoln();\n            \n            int u = ai - 1; // Adjust to 0-based indexing\n            int v = bi - 1;\n            \n            ensuref(u != v, \"Diagonal endpoints must be different: (%d, %d)\", ai, bi);\n            ensuref(0 <= u && u < n, \"Vertex index out of range: %d\", ai);\n            ensuref(0 <= v && v < n, \"Vertex index out of range: %d\", bi);\n            \n            int a = min(u, v);\n            int b = max(u, v);\n            \n            ensuref(edges.find(make_pair(a, b)) == edges.end(), \"Diagonal (%d, %d) cannot be an edge of the polygon\", ai, bi);\n            ensuref(diagonalSet.find(make_pair(a, b)) == diagonalSet.end(), \"Duplicate diagonal (%d, %d)\", ai, bi);\n            \n            diagonalSet.insert(make_pair(a, b));\n            diagonals.push_back(make_pair(u, v));\n        }\n        \n        // Check for crossings\n        int m = diagonals.size();\n        for (int i = 0; i < m; ++i) {\n            int a1 = diagonals[i].first;\n            int b1 = diagonals[i].second;\n            for (int j = i + 1; j < m; ++j) {\n                int a2 = diagonals[j].first;\n                int b2 = diagonals[j].second;\n                if (segmentsCross(a1, b1, a2, b2)) {\n                    ensuref(false, \"Diagonals (%d, %d) and (%d, %d) cross\", a1 + 1, b1 + 1, a2 + 1, b2 + 1);\n                }\n            }\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nbool isBetween(int a, int b, int c)\n{\n    // Return true if c is strictly between a and b in the polygon\n    if (a == b)\n        return false; // No length\n    int n = ::n; // Use global n\n    int dist_ac = (c - a + n) % n;\n    int dist_ab = (b - a + n) % n;\n    if (dist_ab == 0)\n        return false; // Should not happen\n    return 0 < dist_ac && dist_ac < dist_ab;\n}\n\nbool segmentsCross(int a1, int b1, int a2, int b2)\n{\n    if (a1 == a2 || a1 == b2 || b1 == a2 || b1 == b2)\n        return false; // Share endpoint, that's okay\n    bool cond1 = isBetween(a1, b1, a2);\n    bool cond2 = isBetween(a1, b1, b2);\n    bool cond3 = isBetween(a2, b2, a1);\n    bool cond4 = isBetween(a2, b2, b1);\n    return (cond1 != cond2) && (cond3 != cond4);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    n = inf.readInt(4, 1000, \"n\");\n    inf.readEoln();\n    \n    // Build the set of edges of the polygon\n    set<pair<int,int>> edges;\n    for (int i = 0; i < n; ++i) {\n        int u = i;\n        int v = (i + 1) % n;\n        if (u > v) swap(u, v);\n        edges.insert(make_pair(u, v));\n    }\n    \n    for (int t = 0; t < 2; ++t) { // For each of the two triangulations\n        vector<pair<int,int>> diagonals;\n        set<pair<int,int>> diagonalSet;\n        for (int i = 0; i < n - 3; ++i) {\n            int ai = inf.readInt(1, n, \"ai\");\n            inf.readSpace();\n            int bi = inf.readInt(1, n, \"bi\");\n            inf.readEoln();\n            \n            int u = ai - 1; // Adjust to 0-based indexing\n            int v = bi - 1;\n            \n            ensuref(u != v, \"Diagonal endpoints must be different: (%d, %d)\", ai, bi);\n            ensuref(0 <= u && u < n, \"Vertex index out of range: %d\", ai);\n            ensuref(0 <= v && v < n, \"Vertex index out of range: %d\", bi);\n            \n            int a = min(u, v);\n            int b = max(u, v);\n            \n            ensuref(edges.find(make_pair(a, b)) == edges.end(), \"Diagonal (%d, %d) cannot be an edge of the polygon\", ai, bi);\n            ensuref(diagonalSet.find(make_pair(a, b)) == diagonalSet.end(), \"Duplicate diagonal (%d, %d)\", ai, bi);\n            \n            diagonalSet.insert(make_pair(a, b));\n            diagonals.push_back(make_pair(u, v));\n        }\n        \n        // Check for crossings\n        int m = diagonals.size();\n        for (int i = 0; i < m; ++i) {\n            int a1 = diagonals[i].first;\n            int b1 = diagonals[i].second;\n            for (int j = i + 1; j < m; ++j) {\n                int a2 = diagonals[j].first;\n                int b2 = diagonals[j].second;\n                if (segmentsCross(a1, b1, a2, b2)) {\n                    ensuref(false, \"Diagonals (%d, %d) and (%d, %d) cross\", a1 + 1, b1 + 1, a2 + 1, b2 + 1);\n                }\n            }\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\n\nset<pair<int, int>> polygon_edges; // Sides of the polygon\nset<pair<int, int>> initial_diagonals, goal_diagonals; // Initial and goal diagonals\n\n// Function to normalize edge representation (ensure a < b)\npair<int, int> normalize_edge(int a, int b) {\n    if (a > b) swap(a, b);\n    return {a, b};\n}\n\n// Function to check if two edges are equal\nbool edges_equal(pair<int, int> e1, pair<int, int> e2) {\n    return e1.first == e2.first && e1.second == e2.second;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(4, 1000, \"n\");\n\n    // Build the set of polygon edges (sides)\n    for (int i = 1; i <= n; i++) {\n        int a = i;\n        int b = (i % n) + 1;\n        polygon_edges.insert(normalize_edge(a, b));\n    }\n\n    int num_diagonals = n - 3;\n\n    // Read the initial triangulation diagonals\n    for (int i = 0; i < num_diagonals; i++) {\n        int a = inf.readInt(1, n, \"initial ai\");\n        int b = inf.readInt(1, n, \"initial bi\");\n        ensuref(a != b, \"Invalid diagonal in initial triangulation: %d %d\", a, b);\n        initial_diagonals.insert(normalize_edge(a, b));\n    }\n\n    // Read the goal triangulation diagonals\n    for (int i = 0; i < num_diagonals; i++) {\n        int a = inf.readInt(1, n, \"goal ai\");\n        int b = inf.readInt(1, n, \"goal bi\");\n        ensuref(a != b, \"Invalid diagonal in goal triangulation: %d %d\", a, b);\n        goal_diagonals.insert(normalize_edge(a, b));\n    }\n\n    // Build the initial triangulation edges (polygon edges + initial diagonals)\n    set<pair<int, int>> current_edges = polygon_edges;\n    for (auto e : initial_diagonals) {\n        current_edges.insert(e);\n    }\n\n    // Read the contestant's output\n    int k = ouf.readInt(0, 20000, \"k\");\n    for (int i = 1; i <= k; i++) {\n        int a = ouf.readInt(1, n, \"flip ai\");\n        int b = ouf.readInt(1, n, \"flip bi\");\n        ensuref(a != b, \"Invalid flip at step %d: %d %d\", i, a, b);\n        pair<int, int> edge = normalize_edge(a, b);\n        ensuref(current_edges.count(edge) == 1, \"Edge to flip does not exist at step %d: %d %d\", i, a, b);\n        ensuref(polygon_edges.count(edge) == 0, \"Cannot flip polygon side at step %d: %d %d\", i, a, b);\n\n        // Find the vertices c and d to determine the new diagonal (c, d)\n        // Build adjacency lists\n        map<int, set<int>> adj;\n        for (auto e : current_edges) {\n            adj[e.first].insert(e.second);\n            adj[e.second].insert(e.first);\n        }\n\n        // Find common neighbors of a and b excluding a and b\n        set<int> common_neighbors;\n        for (int x : adj[a]) {\n            if (x != b && adj[b].count(x)) {\n                common_neighbors.insert(x);\n            }\n        }\n\n        ensuref(common_neighbors.size() == 2, \"Invalid number of common neighbors at step %d: %d\", i, (int)common_neighbors.size());\n        auto it = common_neighbors.begin();\n        int c = *it;\n        int d = *(++it);\n\n        // Remove edge (a, b) and add edge (c, d)\n        current_edges.erase(edge);\n        pair<int, int> new_edge = normalize_edge(c, d);\n        ensuref(current_edges.count(new_edge) == 0, \"New edge already exists at step %d: %d %d\", i, c, d);\n        current_edges.insert(new_edge);\n    }\n\n    // After applying all flips, the current_edges should match the goal triangulation\n    // Build the expected edge set (polygon edges + goal diagonals)\n    set<pair<int, int>> goal_edges = polygon_edges;\n    for (auto e : goal_diagonals) {\n        goal_edges.insert(e);\n    }\n\n    if (current_edges != goal_edges) {\n        quitf(_wa, \"Final triangulation does not match goal triangulation\");\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct solution in %d steps\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    Edge(int a, int b) {\n        u = min(a, b);\n        v = max(a, b);\n    }\n    bool operator<(const Edge &e) const {\n        if (u != e.u)\n            return u < e.u;\n        return v < e.v;\n    }\n};\n\nstruct Triangle {\n    int a, b, c;\n    Triangle(int _a, int _b, int _c) {\n        a = _a;\n        b = _b;\n        c = _c;\n    }\n    vector<Edge> getEdges() {\n        return {Edge(a, b), Edge(b, c), Edge(c, a)};\n    }\n};\n\nint n;\nstring type;\n\nvector<Triangle> triangulation;\nmap<Edge, vector<int>> edgeToTriangles; // Edge to list of triangle indices\n\nvoid buildInitialTriangulation() {\n    triangulation.clear();\n    edgeToTriangles.clear();\n\n    // Star triangulation: triangles (1, i, i+1)\n    for (int i = 2; i <= n - 1; ++i) {\n        Triangle tri(1, i, i + 1);\n        triangulation.push_back(tri);\n    }\n\n    // Last triangle (1, n, 2)\n    // Only if n > 3\n    // But in the star triangulation, we can omit this as it's redundant\n\n    // Build edge to triangle mapping\n    for (int idx = 0; idx < triangulation.size(); ++idx) {\n        Triangle &tri = triangulation[idx];\n        vector<Edge> edges = tri.getEdges();\n        for (Edge &e : edges) {\n            edgeToTriangles[e].push_back(idx);\n        }\n    }\n}\n\nvoid flipDiagonal(Edge diag) {\n    // Check if diagonal exists and has two adjacent triangles\n    if (edgeToTriangles.count(diag) == 0 || edgeToTriangles[diag].size() != 2) {\n        // Cannot flip this diagonal\n        return;\n    }\n\n    int t_idx1 = edgeToTriangles[diag][0];\n    int t_idx2 = edgeToTriangles[diag][1];\n\n    Triangle t1 = triangulation[t_idx1];\n    Triangle t2 = triangulation[t_idx2];\n\n    // Get the vertices opposite to the diagonal in each triangle\n    int a = diag.u;\n    int b = diag.v;\n\n    int c = -1, d = -1;\n\n    // t1 contains a, b, c\n    if (t1.a != a && t1.a != b)\n        c = t1.a;\n    if (t1.b != a && t1.b != b)\n        c = t1.b;\n    if (t1.c != a && t1.c != b)\n        c = t1.c;\n\n    // t2 contains a, b, d\n    if (t2.a != a && t2.a != b)\n        d = t2.a;\n    if (t2.b != a && t2.b != b)\n        d = t2.b;\n    if (t2.c != a && t2.c != b)\n        d = t2.c;\n\n    if (c == -1 || d == -1)\n        return; // Invalid\n\n    // Remove old triangles from edge mappings\n    vector<Edge> edges_t1 = t1.getEdges();\n    vector<Edge> edges_t2 = t2.getEdges();\n    for (Edge &e : edges_t1) {\n        auto &vec = edgeToTriangles[e];\n        vec.erase(remove(vec.begin(), vec.end(), t_idx1), vec.end());\n        if (vec.empty())\n            edgeToTriangles.erase(e);\n    }\n    for (Edge &e : edges_t2) {\n        auto &vec = edgeToTriangles[e];\n        vec.erase(remove(vec.begin(), vec.end(), t_idx2), vec.end());\n        if (vec.empty())\n            edgeToTriangles.erase(e);\n    }\n\n    // Create new triangles c-d-a and c-d-b\n    Triangle new_t1(c, d, a);\n    Triangle new_t2(c, d, b);\n\n    triangulation[t_idx1] = new_t1;\n    triangulation[t_idx2] = new_t2;\n\n    // Add new edges to mapping\n    vector<Edge> edges_new_t1 = new_t1.getEdges();\n    vector<Edge> edges_new_t2 = new_t2.getEdges();\n    for (Edge &e : edges_new_t1) {\n        edgeToTriangles[e].push_back(t_idx1);\n    }\n    for (Edge &e : edges_new_t2) {\n        edgeToTriangles[e].push_back(t_idx2);\n    }\n}\n\nvector<pair<int, int>> getDiagonals() {\n    set<Edge> diagonals;\n    // Sides of the polygon\n    set<Edge> sides;\n    for (int i = 1; i <= n; ++i) {\n        int u = i;\n        int v = (i % n) + 1;\n        sides.insert(Edge(u, v));\n    }\n\n    for (auto &entry : edgeToTriangles) {\n        if (sides.count(entry.first) == 0) {\n            diagonals.insert(entry.first);\n        }\n    }\n\n    vector<pair<int, int>> result;\n    for (Edge e : diagonals) {\n        result.push_back({e.u, e.v});\n    }\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    type = opt<string>(\"type\", \"random\");\n\n    if (n < 4 || n > 1000) {\n        fprintf(stderr, \"Invalid value of n: %d\\n\", n);\n        return 1;\n    }\n\n    buildInitialTriangulation();\n\n    vector<pair<int, int>> initial_diagonals = getDiagonals();\n    vector<pair<int, int>> goal_diagonals;\n\n    if (type == \"same\") {\n        goal_diagonals = initial_diagonals;\n    } else if (type == \"one_flip\") {\n        // Perform one flip\n        // Choose a random diagonal to flip\n        if (initial_diagonals.size() == 0) {\n            goal_diagonals = initial_diagonals;\n        } else {\n            int idx = rnd.next(initial_diagonals.size());\n            Edge diag(initial_diagonals[idx].first, initial_diagonals[idx].second);\n            flipDiagonal(diag);\n            goal_diagonals = getDiagonals();\n        }\n    } else if (type == \"max_flips\") {\n        // Perform n*log(n) random flips\n        int num_flips = n * log(n) + 1;\n        for (int i = 0; i < num_flips; ++i) {\n            vector<pair<int, int>> diagonals = getDiagonals();\n            if (diagonals.size() == 0)\n                break;\n            int idx = rnd.next(diagonals.size());\n            Edge diag(diagonals[idx].first, diagonals[idx].second);\n            flipDiagonal(diag);\n        }\n        goal_diagonals = getDiagonals();\n    } else if (type == \"random\") {\n        // Perform n*log(n) random flips on initial triangulation to get random triangulation\n        int num_flips = n * log(n) + 1;\n        for (int i = 0; i < num_flips; ++i) {\n            vector<pair<int, int>> diagonals = getDiagonals();\n            if (diagonals.size() == 0)\n                break;\n            int idx = rnd.next(diagonals.size());\n            Edge diag(diagonals[idx].first, diagonals[idx].second);\n            flipDiagonal(diag);\n        }\n        goal_diagonals = getDiagonals();\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output initial triangulation\n    for (auto &d : initial_diagonals) {\n        printf(\"%d %d\\n\", d.first, d.second);\n    }\n\n    // Output goal triangulation\n    for (auto &d : goal_diagonals) {\n        printf(\"%d %d\\n\", d.first, d.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    Edge(int a, int b) {\n        u = min(a, b);\n        v = max(a, b);\n    }\n    bool operator<(const Edge &e) const {\n        if (u != e.u)\n            return u < e.u;\n        return v < e.v;\n    }\n};\n\nstruct Triangle {\n    int a, b, c;\n    Triangle(int _a, int _b, int _c) {\n        a = _a;\n        b = _b;\n        c = _c;\n    }\n    vector<Edge> getEdges() {\n        return {Edge(a, b), Edge(b, c), Edge(c, a)};\n    }\n};\n\nint n;\nstring type;\n\nvector<Triangle> triangulation;\nmap<Edge, vector<int>> edgeToTriangles; // Edge to list of triangle indices\n\nvoid buildInitialTriangulation() {\n    triangulation.clear();\n    edgeToTriangles.clear();\n\n    // Star triangulation: triangles (1, i, i+1)\n    for (int i = 2; i <= n - 1; ++i) {\n        Triangle tri(1, i, i + 1);\n        triangulation.push_back(tri);\n    }\n\n    // Last triangle (1, n, 2)\n    // Only if n > 3\n    // But in the star triangulation, we can omit this as it's redundant\n\n    // Build edge to triangle mapping\n    for (int idx = 0; idx < triangulation.size(); ++idx) {\n        Triangle &tri = triangulation[idx];\n        vector<Edge> edges = tri.getEdges();\n        for (Edge &e : edges) {\n            edgeToTriangles[e].push_back(idx);\n        }\n    }\n}\n\nvoid flipDiagonal(Edge diag) {\n    // Check if diagonal exists and has two adjacent triangles\n    if (edgeToTriangles.count(diag) == 0 || edgeToTriangles[diag].size() != 2) {\n        // Cannot flip this diagonal\n        return;\n    }\n\n    int t_idx1 = edgeToTriangles[diag][0];\n    int t_idx2 = edgeToTriangles[diag][1];\n\n    Triangle t1 = triangulation[t_idx1];\n    Triangle t2 = triangulation[t_idx2];\n\n    // Get the vertices opposite to the diagonal in each triangle\n    int a = diag.u;\n    int b = diag.v;\n\n    int c = -1, d = -1;\n\n    // t1 contains a, b, c\n    if (t1.a != a && t1.a != b)\n        c = t1.a;\n    if (t1.b != a && t1.b != b)\n        c = t1.b;\n    if (t1.c != a && t1.c != b)\n        c = t1.c;\n\n    // t2 contains a, b, d\n    if (t2.a != a && t2.a != b)\n        d = t2.a;\n    if (t2.b != a && t2.b != b)\n        d = t2.b;\n    if (t2.c != a && t2.c != b)\n        d = t2.c;\n\n    if (c == -1 || d == -1)\n        return; // Invalid\n\n    // Remove old triangles from edge mappings\n    vector<Edge> edges_t1 = t1.getEdges();\n    vector<Edge> edges_t2 = t2.getEdges();\n    for (Edge &e : edges_t1) {\n        auto &vec = edgeToTriangles[e];\n        vec.erase(remove(vec.begin(), vec.end(), t_idx1), vec.end());\n        if (vec.empty())\n            edgeToTriangles.erase(e);\n    }\n    for (Edge &e : edges_t2) {\n        auto &vec = edgeToTriangles[e];\n        vec.erase(remove(vec.begin(), vec.end(), t_idx2), vec.end());\n        if (vec.empty())\n            edgeToTriangles.erase(e);\n    }\n\n    // Create new triangles c-d-a and c-d-b\n    Triangle new_t1(c, d, a);\n    Triangle new_t2(c, d, b);\n\n    triangulation[t_idx1] = new_t1;\n    triangulation[t_idx2] = new_t2;\n\n    // Add new edges to mapping\n    vector<Edge> edges_new_t1 = new_t1.getEdges();\n    vector<Edge> edges_new_t2 = new_t2.getEdges();\n    for (Edge &e : edges_new_t1) {\n        edgeToTriangles[e].push_back(t_idx1);\n    }\n    for (Edge &e : edges_new_t2) {\n        edgeToTriangles[e].push_back(t_idx2);\n    }\n}\n\nvector<pair<int, int>> getDiagonals() {\n    set<Edge> diagonals;\n    // Sides of the polygon\n    set<Edge> sides;\n    for (int i = 1; i <= n; ++i) {\n        int u = i;\n        int v = (i % n) + 1;\n        sides.insert(Edge(u, v));\n    }\n\n    for (auto &entry : edgeToTriangles) {\n        if (sides.count(entry.first) == 0) {\n            diagonals.insert(entry.first);\n        }\n    }\n\n    vector<pair<int, int>> result;\n    for (Edge e : diagonals) {\n        result.push_back({e.u, e.v});\n    }\n    return result;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    n = opt<int>(\"n\");\n    type = opt<string>(\"type\", \"random\");\n\n    if (n < 4 || n > 1000) {\n        fprintf(stderr, \"Invalid value of n: %d\\n\", n);\n        return 1;\n    }\n\n    buildInitialTriangulation();\n\n    vector<pair<int, int>> initial_diagonals = getDiagonals();\n    vector<pair<int, int>> goal_diagonals;\n\n    if (type == \"same\") {\n        goal_diagonals = initial_diagonals;\n    } else if (type == \"one_flip\") {\n        // Perform one flip\n        // Choose a random diagonal to flip\n        if (initial_diagonals.size() == 0) {\n            goal_diagonals = initial_diagonals;\n        } else {\n            int idx = rnd.next(initial_diagonals.size());\n            Edge diag(initial_diagonals[idx].first, initial_diagonals[idx].second);\n            flipDiagonal(diag);\n            goal_diagonals = getDiagonals();\n        }\n    } else if (type == \"max_flips\") {\n        // Perform n*log(n) random flips\n        int num_flips = n * log(n) + 1;\n        for (int i = 0; i < num_flips; ++i) {\n            vector<pair<int, int>> diagonals = getDiagonals();\n            if (diagonals.size() == 0)\n                break;\n            int idx = rnd.next(diagonals.size());\n            Edge diag(diagonals[idx].first, diagonals[idx].second);\n            flipDiagonal(diag);\n        }\n        goal_diagonals = getDiagonals();\n    } else if (type == \"random\") {\n        // Perform n*log(n) random flips on initial triangulation to get random triangulation\n        int num_flips = n * log(n) + 1;\n        for (int i = 0; i < num_flips; ++i) {\n            vector<pair<int, int>> diagonals = getDiagonals();\n            if (diagonals.size() == 0)\n                break;\n            int idx = rnd.next(diagonals.size());\n            Edge diag(diagonals[idx].first, diagonals[idx].second);\n            flipDiagonal(diag);\n        }\n        goal_diagonals = getDiagonals();\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output initial triangulation\n    for (auto &d : initial_diagonals) {\n        printf(\"%d %d\\n\", d.first, d.second);\n    }\n\n    // Output goal triangulation\n    for (auto &d : goal_diagonals) {\n        printf(\"%d %d\\n\", d.first, d.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -type same\n./gen -n 4 -type one_flip\n./gen -n 4 -type random\n./gen -n 5 -type same\n./gen -n 5 -type one_flip\n./gen -n 5 -type random\n./gen -n 10 -type same\n./gen -n 10 -type one_flip\n./gen -n 10 -type random\n./gen -n 50 -type same\n./gen -n 50 -type one_flip\n./gen -n 50 -type random\n./gen -n 100 -type same\n./gen -n 100 -type one_flip\n./gen -n 100 -type random\n./gen -n 500 -type same\n./gen -n 500 -type one_flip\n./gen -n 500 -type random\n./gen -n 1000 -type same\n./gen -n 1000 -type one_flip\n./gen -n 1000 -type random\n./gen -n 1000 -type max_flips\n./gen -n 999 -type max_flips\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n./gen -n 1000 -type random\n./gen -n 4 -type max_flips\n./gen -n 10 -type max_flips\n./gen -n 20 -type max_flips\n./gen -n 50 -type max_flips\n./gen -n 100 -type max_flips\n./gen -n 500 -type max_flips\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:52.729810",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "513/A",
      "title": "A. Игра",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеЕдинственная строка входных данных содержит четыре целых числа n1, n2, k1, k2. Все числа во входных данных не меньше 1 и не больше 50.В этой задаче нет подзадач. За ее решение вы получите 3 балла.",
      "output_spec": "Выходные данныеВыведите \"First\" если выигрывает первый игрок и \"Second\" в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 2 1 2Выходные данныеСкопироватьSecondВходные данныеСкопировать2 1 1 1Выходные данныеСкопироватьFirst",
      "description": "ограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеЕдинственная строка входных данных содержит четыре целых числа n1, n2, k1, k2. Все числа во входных данных не меньше 1 и не больше 50.В этой задаче нет подзадач. За ее решение вы получите 3 балла.\n\nВходные данные\n\nВыходные данныеВыведите \"First\" если выигрывает первый игрок и \"Second\" в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать2 2 1 2Выходные данныеСкопироватьSecondВходные данныеСкопировать2 1 1 1Выходные данныеСкопироватьFirst\n\nВходные данныеСкопировать2 2 1 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьSecond\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 1 1 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFirst\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРассмотрим первый тест из условия. Каждый игрок владеет коробкой с двумя шарами. Первый игрок может взять только один шар за один ход, а второй игрок за один ход может взять либо один либо два шара. Нетрудно заметить, что вне зависимости от ходов первого, второй игрок всегда выигрывает, если играет оптимально.",
      "solutions": [
        {
          "title": "Rockethon 2015 — Анонс - Codeforces",
          "content": "Привет, Codeforces!Я рад анонсировать, что компания Rocket Fuel Inc. снова будет проводить соревнование Rockethon! Контест подготовили сотрудники компании Эльдар Богданов, Антон Ломонос, Лаша Лакирбая, Александр Рафф, Никил Гоял и я, Евгений Соболев. Мы надеемся, что каждый из вас найдет для себя интересные задачи на контесте и от решения этих задач вы получите не меньше удовольствия, чем получили мы от их подготовки. Как и в прошлом году, лучшие участники получат ценные призы и футболки. Помимо этого, Rocket Fuel заинтересован в рекрутинге людей после соревнования, поэтому, пожалуйста, заполните простую форму при регистрации.О Rocket FuelRocket Fuel is building technology platform to do automatic targeting and optimization of ads across all channels — display, video, mobile and social. Our pitch to advertisers is very simple \"If you can measure metrics of success of your campaign, we can optimize\". We run campaigns for many large advertisers and our clients include many top companies within the following industries: autos, airlines, commercial banks, telecom, food services, insurance, etc. Examples include BMW, Pizza Hut, Brooks Running Shoes and many more!We buy all our inventory through real time bidding on ad exchanges like Google and Yahoo. Ad exchanges are similar to stock exchanges except the commodity being traded is ad slots on web pages. Our serving systems currently process over 60B bid requests/ day with a response time requirement of 100ms. Our data platform has 64 PBs data that is used for analytics as well as modeling.Our engineering team is still small (~150) enough for any one person like yourself to make a huge impact. The team represents many top schools in US and outside — Stanford, Carnegie Mellon, MIT, Wisconsin-Madison, IIT (India), Tsinghua (China).Rocket Fuel has been named #4 on Forbes Most Promising Companies in America List in 2013 and #1 Fastest Growing Company in North America on Deloitte’s 2013 Tech Fast 500 and our CEO George John was recently named “Most Admired CEO” by the SF Business Times in 2014.Мои впечатленияОколо года назад я зашел на Codeforces и увидел объявление о Rockethon 2014. Моей первой мыслью было: \"Круто! Еще одно соревнование от крупной компании!\" Я поучаствовал, выступил достаточно неплохо, после чего со мной связались рекрутеры Rocket Fuel и назначили несколько собеседований. Я прошел собеседования и теперь я здесь, в Rocket Fuel.Работа в Rocket Fuel — это отличная возможность изучить продвинутые вещи в software engineering, так как вокруг работают много умных людей, которые всегда готовы делиться своими знаниями. Конечно, наша деятельность не ограничивается только лишь написанием кода — мы играем в баскетбол, футбол, настольный теннис. Я приглашаю каждого из вас принять участие в соревновании и буду рад услышать если вы задумываетесь о трудоустройстве в Rocket Fuel.Обзор соревнованияКонтест начнется 7-го февраля в 20:00 МСК.Продолжительность контеста — 3 часа.Тестирование посылок будет производиться сразу же после их отправления и вердикты тестирования будут немедленно показаны авторам посылок.В контесте будет 7 задач, каждая из которых может иметь от одной до трех подзадач. Каждая подзадача будет стоить некоторое фиксированное число баллов. Если несколько участников наберут одинаковое число баллов, выше будет стоять тот участник у которого будет меньше штрафное время, вычисляемое аналогично ACM-системе.ПризыТри лучших участника получат следующие призы:1) IPhone 6 (16 Gb)2) Участник может выбрать Apple Watch или Samsung Gear S3) Участник может выбрать Apple Watch или Samsung Gear SЛучшие 150 участников получат футбоолки Rockethon с оригинальным дизайном соревнования.Если вы не можете принять участие в соревновании, но заинтересованы в трудоустройстве в Rocket Fuel, мы будем обрабатывать резюме отправленные через специальную форму.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/16140",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3854
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces",
          "content": "(This is a beta version of editorial. It will be changed later)I hope everybody enjoyed the contest. Here we'll present some of the author's solutions to the problems together with some other approaches that we came up with. The editorial is prepared by Lasha Lakirbaia, Anton Lomonos, and Ievgen Soboliev.A — Game(developed by Ievgen Soboliev & Eldar Bogdanov, editorial written by Lasha Lakirbaia)The problem can be solved with dynamic programming technique. Let winner[a][b][move] denote who wins if both players play optimally and the first has a balls left in his box, the second has b balls left in his box and move defines who is to move next. To determine the value of winner[a][b][move], we should consider all the possible moves the next player can make and see whether any of them lead into the position winner[x][y][move2] in which this player can win with optimal play. Thus, values of winner can be defined recursively.Ok it was a joke, the solution is just this one line: println (n1 > n2 ? “First” : “Second”).B — Permutations(developed by Ievgen Soboliev & Eldar Bogdanov, editorial written by Lasha Lakirbaia)For a given array p1, p2, ..., pk let’s call the value of that expression the value of that array.For the first subproblem, we can just consider all n! permutations in lexicographic order and keep 2 variables — one of them should be the highest value so far, and the other should be the list of permutations with that highest value. Than we can update this variables like this: When he have a new permutation, if it has smaller value, we disregard it. If it has larger value, we assign the first variable this new value and to the second variable we assign 1-element list, containing this current permutation only. In the end we just pick m-th element from the second variable. From now on we’ll concentrate on solving the harder one.First of all let’s find out which permutations have the highest values among all the permutations of (1, 2, ..., n). It's easy to note that whenever we have some n-element array, in the highest valued permutations the position of the smallest element of the array will be either first or the last in the permutation. This can be proved easily as follows: There can't be an optimal (highest valued) permutation where the smallest element is in the middle (I mean after the first and before the last), because moving this element to either beginning or ending would obviously increase the value, that would thus contradict the statement that the original permutation had the highest value. So we proved that the position of 1 should either be at the beginning or at the end of a highest valued permutation. Moreover, it’s easy to see that in both cases, the value will be the same. After we decide on which end 1 will be, than we can move on to the remaining array (2, 3, ..., n) and do the same for 2 as we did for 1. Than we go on and do the same for 3, 4, ..., n. From here we can clearly say what are all the permutations with the highest value — all the permutations which can be derived by the following algorithm: Consider numbers (1, 2, ..., n) in the reverse order. Each time add the current number to one of the ends of the current permutation (initially the permutation is empty). For example, for n=5 the possible permutations are (1, 2, 3, 4, 5), (1, 3, 5, 4, 2), (5, 4, 3, 2, 1) and (1, 2, 5, 4, 3). One more important thing to note is that the number of highest valued permutations of any n-element array is equal to 2n - 1, which easily follows from the way we’re constructing all these permutations. With all that said, the rest of the solution is pretty straightforward. Let’s consider numbers 1, 2, ..., n in this order and apply the following recursive approach: If we’re currently on pos-th position and searching for m-th element, having already decided the indices of all the elements less than pos, then there are 2 cases: We know that number of possible permutations is 2n - pos - 1. If m ≤ 2n - pos - 1, then we put pos element in the beginning of the array and recursively go to the state (pos + 1, m). Otherwise, we’ll put pos in the end of the array and recursively go to the state (pos + 1, 2n - pos - 1 - m). The total running time of this solution is O(n), if implemented in optimal way but almost any kind of implementation of this idea would work, as the value of n is relatively small.Note 1: From the solution it's visible that m ≤ 249, and also for n = 50 m can be as big as 249, which doesn't fit in int but fits in long.Note 2: This last steps can also be implemented by just considering the binary representation of m.C — Second Price Auction(developed by Ievgen Soboliev & Eldar Bogdanov, editorial written by Lasha Lakirbaia)This problem can be solved in many different ways. Here we’ll explain 3 of them. Let’s denote by P(b) the probability of second highest bid being equal to b. Obviously, possible values of b are only integers from 1 to 10, 000. If we can calculate P(b) for each b in that range, then the desired expected value is just . Now let’s concentrate on calculating P(b) for a given b. These 3 solutions have different approaches to calculating the value of P(b).First solution (the easiest) — brute forceLet’s consider every partition of a set of bidders into 3 subsets, such that in the first set each bidder had higher bid than b, in second set each bid was equal to b, while in the third set each bid was less than b. As we assume that b is the second highest bid, it’s easy to notice that the first set contains either 0 or 1 element, while the second set contains at least 1 element. (Also, if the first set is empty, the second set must contain at least 2 elements) Number of such partitions is O(2n·n). After we have this partition, for each bidder we know if its bid should be more, equal or less then b. Probability of any of these can easily be counted in O(1). So in the end we get the complexity of O(2n·n·max(R - L + 1)), which is good enough for given constraints.Second solution — dynamic programmingLet’s consider the following dynamic programming approach. Denote by (pos, moreCount, equalCount) the state, when we already considered all bidders with indices less then pos, the second largest bid in the end must be equal to b, currently the number of bidders with bid higher than b is moreCount and the number of bidders with bid equal to b is equalCount. Finally, dp(pos, moreCount, equalCount) denotes the value of P(b) for this state. Note, that we don’t have to consider the states where moreCount > 1, because for them P(b) = 0. Also, we don’t need to distinguish between states where some of them has equalCount = 2 and some of them has equalCount > 2. They have same values. So we’ll assume that equalCount < 3 and moreCount < 2. Transitions for this dynamic programming are as follows: - Consider current bid to be higher than b. It’s only possible if moreCount = 0, because otherwise the probability of P(b) will be 0. If moreCount = 0, the transition will be to dp(pos + 1, 1, equalCount). - Consider current bid to be equal to b. It will lead us to a transition to dp(pos + 1, moreCount, min(equalCount + 1, 2)). - Consider current bid to be less than b. Transition in the case will be dp(pos + 1, moreCount, equalCount).All these cases have their respective probabilities, which are straightforward to calculate in O(1). So as we see, the number of states of dynamic programming is O(n), while calculating each state take O(1). So in total, calculating P(b) takes O(n) time, which leads us to the solution of the initial problem in O(n * max(R - L + 1)).Third solution — pure mathP(b) = Pr.(maxBid = b, secondMaxBid = b) + Pr.(maxBid > b, secondMaxBid = b). Let’s calculate these 2 summands separately. Denote by ri a random bid of i - th bidder.Pr.(maxBid = b, secondMaxBid = b) = Pr.(maxBidb) - Pr.(maxBid < b) . Now let’s calculate the other summand: .Note that each of Pr.(ri > b), Pr.(ri = b) and Pr.(ri < b) can be calculated in O(1), so P(b) can be calculated in O(n2). So in the end, we get the running time of O(n2·max(R - L + 1)). However, the last step can easily be implemented in O(n), which would give us the total running time of O(n·max(R - L + 1)), but in this problem it’s not required as n ≤ 5.Note: As you can see, using second and third solutions the problem could be solvable for much larger values of n. However, we felt like all three approaches are equally interesting and let any of them pass. Bonus: assuming that we can multiply doubles without precision loss in polynomial time, can you solve the problem in polynomial time if the bid ranges of each company are unbounded?D — Constrained Tree(developed by Eldar Bogdanov, Alexander Ruff and Anton Lomonos, editorial written by Anton Lomonos)Let's try to construct this tree from top to bottom trying to comply with given set of constraints. The first observation you need to make is if vertices i and j (i < j) should be in a given subtree then any vertex k (i < k < j) should also be in this subtree. It leads to 2 important conclusions: Our task \"find a tree rooted at vertex 1 which should contain N vertices and comply to the given set of constraints\" can be rephrased to \"find a tree rooted at vertex 1 which should comply to the given set of constraints, contain the least number of vertices as possible, and contain vertex N\". We need to know only minimums and maximums for left and right parts of each subtree. Let's assume we are trying to construct subtree rooted at i that should contain vertex m, vertices [j1..j2] to the left of the root, and vertices [k1..k2] to the right of the root. If we don't have constraints for the left part or for the right part of the subtree then we can place all the vertices utterly to the right or to the left (we still need to check constraints for sanity). Otherwise, the conditions i < j1, j2 < k1 should take place. The vertex i + 1 should be the left child of the root. Vertices [j2 + 1;k1 - 1] may be placed to the left or to the right which depends on the constraints. Let's construct the left subtree rooted at i + 1 in such a way that it should contain the vertex j2 and contain at least number of vertices as possible. Let's assume the vertex with the biggest label in this subtree is mid. Condition mid < k1 should take place. Then we can make right child of the root to be mid + 1, and we need to construct subtree rooted at mid + 1 that should contain at least number of vertices as possible and should contain vertex max(k2, m)The complexity of algorithm is O(N + C).E — Subarray Cuts(proposed by Nikhil Goyal, developed by Anton Lomonos and Lasha Lakirbaia, editorial written by Anton Lomonos and Lasha Lakirbaia)This problem can be solved in several ways. One of the expected solution for the easier part has complexity O(n2k), which will be presented later. For now let's discuss another solution, which is also good enough for first subproblem and has complexity of O(nk2).Let’s call the set of all possible k-tuples of partitions A; So we’re concentrating on finding the element of A with the maximal sum value. Let’s consider another set of tuples of partitions but with the following properties: We have at most k disjoint subarrays chosen. Call their sums s1, s2, …, sm (m is the number of subarrays and m ≤ k). For each 1 ≤ i ≤ (m - 1), (s(i - 1) - si) * (si - s(i + 1)) < 0. In other words, si is not between its neighbors by value. (For example, if its neighbors are 3 and 11, it will be either greater than 11 or less than 3). The number of unused (not picked) elements from the initial array is at least (k - m). In other words, we are able to add enough disjoint subarrays to this m subarrays so that in the end we have exactly k of them. Let’s call this set B.It can be easily proved, that the maximal valued elements in A and B have the same value. The proof of this statement is given in the very end of the solution. For now let’s believe it and solve the problem.So from now on we concentrate on finding the maximal value with the property of B.Note that the value of any element of B with sums s1, s2, …, sm is equal to the maximum of ( + s1 - 2·s2 + 2·s3 - 2·s4 + …) and ( - s1 + 2 cdots2 - 2 cdots3 + 2·s4 - …). The important catch here is that we can ignore the property of B which says that each sum of subarray is NOT between it’s neighboring sums, because in the end we’ll get the same answers. So we just ignore that property and solve the problem without that restriction. The only restriction remaining is that they should be disjoint and the total number of unused elements should be at least (k - m). Here is the sketch of the proof why will it give the same answer: s1 - 2·s2 + 2·s3 - … = (s1 - s2) + (s3 - s2) + … ≤ |s1 - s2| + |s2 - s3| + …, as well as ( - s1 + 2·s2 - 2·s3 + ...). It means that when they’re both maximum, they equal to each other.So we can instead concentrate on finding the maximal possible ( + s1 - 2·s2 + 2·s3 - 2·s4 + …) and ( - s1 + 2·s2 - 2·s3 + 2·s4 - …) values and it will coincide with the answer to our problem.Denote by dp(pos, sign, first, last, unused, max) — the answer for the subproblem (apos, a(pos + 1), …) where sign means the sign of the first chosen subarray, first and last denote whether the current subarray should be first, last or none of them, unused denotes the number of unused elements that we should preserve and max denotes the maximum number of subarrays we may take. There are O(nk2) states here, cause sign, first and last each have just 2 options. Important part here is how we make transitions in O(1) and thus solve the entire problem in O(nk2). First transition would correspond to ignoring pos-th element — dp(pos + 1, sign, first, last, min(unused + 1, k), max). Otherwise we are taking apos in the first chosen subarray. There are 2 cases here: Either the current interval is just (pos, pos), or it’s length is more than 1. In the first case, the value is signapos·((firstorlast)?1: 2) + dp(pos + 1,  - sign, false, 0or1, unused, max - 1). In the second case, the value would be sign·apos·((firstorlast)?1: 2) + dp(pos + 1, sign, first, last, unused, max).Hence, in total we have 3 transitions and thus we calculate each dp(pos, sign, first, last, unused, max) in O(1). It means the entire complexity of the solution is O(nk2). Note: We didn’t present every detail and corner case, because it would be very boring to read otherwise.Below we’ll present the solution for the harder version of this problem.In general case we are trying to calculate this expression:max(... + |sj - 2 - sj - 1| + |sj - 1 - sj| + |sj - sj + 1| + ...) = max(... ± (sj - 2 - sj - 1) ± (sj - 1 - sj) ± (sj - sj + 1) ± ...)This task can be solved by using dynamic programming. Let's try to calculate recurrently the following function where we should pick subarrays j..k from array [i; n]:f(i, j, c1, c2) = max(... ± (0 - 0) c1 (0 - sj) c2 (sj - sj + 1) ± (sj + 1 - sj + 2) ± ...), where are defined.The recurrent formula for this function is:f(i, j, c1, c2) = maxp1, p2(c1 ( - sump = p1..p2ap) c2 (sump = p1..p2ap) + f(p2 + 1, j + 1, c2,  ± ))We can easily get rid of using p1:f(i, j, c1, c2) = max(f(i + 1, j, c1, c2), maxp2(c1 ( - sump = i..p2ap) c2 (sump = i..p2ap) + f(p2 + 1, j + 1, c2,  ± ))We can get rid from p2 by using additional function g(i, j, c1, c2), which states that subarray j already has some elements in it:f(i, j, c1, c2) = max(f(i + 1, j, c1, c2), c1 ( - ai) c2 ai + g(i + 1, j, c1, c2))g(i, j, c1, c2) = max(f(i, j + 1, c2,  + ), f(i, j + 1, c2,  - ), c1 ( - ai) c2 (ai) + g(i + 1, j, c1, c2))There is still a matter of handling the beginning and ending of dynamic programming. There are several ways to do it. For example, we can calculate maximums and minimums of values s1 or sk based on their endings or beginnings, or we can make exceptions for using c1 and c2 if j = 1 or j = k.The complexity of the algorithm is O(n * k).F — Scaygerboss(developed by Anton Lomonos, editorial written by Anton Lomonos)The task reduces to the situation when we have k females and k males, and we need to connect them in such a way, that there will be no more than one pair in each cell. This task can be solved by using maximum flow algorithm. Firstly we need to choose the value of our answer ans (for example, by binary search) and check if they can connect in a time no more than ans. Let's make edges of capacity 1 between source and females, between males and sink, and between inputs and outputs of each cell. Then let's make edges of capacity 1 between females and inputs of cells and between outputs of cells and males if they can reach this cell within ans (we can calculate these values by using breadth-first algorithm). If we can get a maximum flow of capacity k on this graph then they can reach each other within ans.The above approach is enough to solve the first part of the task. It has complexity of O(k3·log(k)). For solving second part of the task one should optimize the above solution. Highly optimized solution with complexity of O(k3·log(k)) could pass, but there exists a solution with complexity O(k3). The first observation you need to make is you don't need to reconstruct the graph each time for running maximum flow algorithm. If you run the algorithm for ans = a, and then run the algorithm for ans = b, b > a, you would just need to add additional edges and \"continue to run\" maximum flow algorithm. The complexity of this would be O(k3 + l·k2) where l is the number of times you do this trick. Using this observations in different ways could be enough to pass the second part of the task. You can achieve the complexity of O(k3) by using square root decomposition. You need to divide k2 edges to k batches of k edges based on the values of ans you can use these edges for. Running maximum flow algorithm after adding each of these batches would get you O(k3) complexity. Then you know which batch would tell you what the answer is, and you run maximum flow algorithm for this batch, which is O(k3) complexity too. You can also divide edges to batches not based by their quantities, but based by their values. You will be adding the edges of the same values to the graph in the same blow. That way your algorithm would run even faster.I (White_Bear) would like to give special congratulations to mmaxio, Petr, niyaznigmatul, and Egor who solved F2 using Java.G — Inversions Problem(proposed by Ievgen Soboiliev, developed by Ievgen Soboiliev, editorial written by Lasha Lakirbaia, to be changed)This is a draft of solution to this problem. It will be changed later. Currently it contains solutions of first 2 subproblems.The first subproblem can be solved many ways. The easiest probably is the following: consider the dynamic programming approach where the state is (perm, m) — where perm is the current permutation and m is the number of operations that are going to be performed over it. Transitions are just all the possible permutations that can be derived in the next turns (with their respective probabilities) and obviously the other variable will be just (m - 1). The running time for this approach is O(n! * n3 * k), which is good enough for the given constraints. Note that even though for small n the number of possible permutations is pretty small and k is also small, solutions based on simulation are not working at the precision level that’s required. To solve 2 other subproblems, we are gonna need more observations. First one is the linearity of expected value. It basically means that the expected value of a sum of random variables is equal to the sum of expected values of those variables, even if they’re somehow dependent on each other. Let’s see how we can use this idea to solve this problem. For this we have to look at the number of inversions a bit differently. For each possible pair (i, j) with 1 ≤ i < j ≤ n, let’s define the random variable b(i, j) to be 0 if i - th and j - th elements will preserve the order after k operations and 1 otherwise. Now, the number of inversions in terms of these variables is equal to . So if we can find the expected values of each b(i, j) variables, than calculating the answer will be straightforward.Another observation is that the expected value of a binary variables is the same as it’s probability of being equal to 1. It means that the expected value of b(i, j) is same as probability that i - th and j - th elements will swap the order in the end, after k moves. From now on, let’s denote by p(i, j, m) the probability, that after m steps the i - th and j - th elements will swap the order (in other words, probability that the final position of the i - th element will be to the right side of the final position of j - th element). The solutions of second and third subproblems differ only in ways of calculating these values.Easier way to find these values is to use recursive approach: Consider all the possible next moves — namely all possible intervals (x, y) on which the next step will be performed. Each of them has probability equal to . There are several cases:(1) Intervals (x, y) and (i, j) are either disjoint, or i < x, y < j. In both cases, the transition will be just p(i, j, m - 1).(2) x ≤ i ≤ y < j. In this case the transition is gonna be p(x + y - i, j, m - 1).(3) i < x ≤ j ≤ y. In this case the transition will be p(i, x + y - j, m - 1).(4) x ≤ i ≤ j ≤ y. In this case the transition will be p(x + y - i, x + y - j, m - 1).The running time of this solution will be O(n4 * k), which is good enough for 2-nd subproblem, but not for the third one. This solution can actually be optimized. For this, we will need to deal with above 4 cases in O(n) each, instead of O(n2).(1) We just count how many (x, y) intervals are of this type (i < x, y < j) and than multiply this number by p(i, j, m - 1).(2) For each fixed possible value of (x + y), count how many (x, y) exist with that sum such that x ≤ i ≤ y < j. It can easily be done in O(1). As there are O(n) possible values of (x + y), this whole step takes O(n).(3) The approach here is exactly the same as in the second case.(4) For each possible value of s = x + y such that x ≤ i ≤ j ≤ y and sum up (1 - p(s - j, s - i, m - 1)). There are O(n) possible values of s, so this whole step takes O(n) time.As these 4 steps each take at most O(n), the total running time will be O(n3·k). The fastest solution works in O(n2·min(k, 2000)). This solution will be described later.",
          "author": "llaki",
          "url": "https://codeforces.com/blog/entry/16260",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 22414
        }
      ],
      "code_examples": [
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 1",
          "code": "3 3\n1 2 LEFT\n1 3 RIGHT\n2 3 RIGHT",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 2",
          "code": "3 3\n1 2 LEFT\n1 3 RIGHT\n2 3 RIGHT",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 3",
          "code": "1 << length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 4",
          "code": "1LL << length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 5",
          "code": "if (k > 1000) {\n    k = 1000;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 6",
          "code": "if (k > 1000) {\n    k = 1000;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 — Анонс - Codeforces - Code 7",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 1",
          "code": "sum = 0\nfor simulation = 1 --> 10^6:\n  A = initial array\n  for i = 1 --> k:\n    u = random(1, n)\n    v = random(1, n)\n    reverse(A[u] .. A[v])\n  sum += count_inversions(A)\n\nprint(sum / 10^6)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 2",
          "code": "sum = 0\nfor simulation = 1 --> 10^6:\n  A = initial array\n  for i = 1 --> k:\n    u = random(1, n)\n    v = random(1, n)\n    reverse(A[u] .. A[v])\n  sum += count_inversions(A)\n\nprint(sum / 10^6)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 3",
          "code": "Note 2: This last steps can also be implemented by just considering the binary representation of m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 4",
          "code": "m-2^(n-pos-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 5",
          "code": "4\n1 5\n1 6\n7 10\n7 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 6",
          "code": "4\n1 5\n1 6\n7 10\n7 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 7",
          "code": "{(1, 5), (1, 6)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n1 = inf.readInt(1, 50, \"n1\");\n    inf.readSpace();\n    int n2 = inf.readInt(1, 50, \"n2\");\n    inf.readSpace();\n    int k1 = inf.readInt(1, 50, \"k1\");\n    inf.readSpace();\n    int k2 = inf.readInt(1, 50, \"k2\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n1 = inf.readInt(1, 50, \"n1\");\n    inf.readSpace();\n    int n2 = inf.readInt(1, 50, \"n2\");\n    inf.readSpace();\n    int k1 = inf.readInt(1, 50, \"k1\");\n    inf.readSpace();\n    int k2 = inf.readInt(1, 50, \"k2\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n1 = inf.readInt(1, 50, \"n1\");\n    inf.readSpace();\n    int n2 = inf.readInt(1, 50, \"n2\");\n    inf.readSpace();\n    int k1 = inf.readInt(1, 50, \"k1\");\n    inf.readSpace();\n    int k2 = inf.readInt(1, 50, \"k2\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Parse the parameters\n    int n1 = opt<int>(\"n1\", -1);\n    int n2 = opt<int>(\"n2\", -1);\n    int k1 = opt<int>(\"k1\", -1);\n    int k2 = opt<int>(\"k2\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Based on type, set n1, n2, k1, k2\n    if (type == \"edge\") {\n        // All variables are 1 or maximum.\n        int min_or_max = rnd.next(2);\n        if (min_or_max == 0) {\n            n1 = n2 = k1 = k2 = 1;\n        } else {\n            n1 = n2 = k1 = k2 = 50;\n        }\n    } else if (type == \"k1_large_k2_small\") {\n        n1 = rnd.next(1, 50);\n        n2 = rnd.next(1, 50);\n        k1 = rnd.next(26, 50);\n        k2 = rnd.next(1, 25);\n    } else if (type == \"k1_small_k2_large\") {\n        n1 = rnd.next(1, 50);\n        n2 = rnd.next(1, 50);\n        k1 = rnd.next(1, 25);\n        k2 = rnd.next(26, 50);\n    } else if (type == \"n1_gt_n2\") {\n        n1 = rnd.next(26, 50);\n        n2 = rnd.next(1, 25);\n        k1 = rnd.next(1, 50);\n        k2 = rnd.next(1, 50);\n    } else if (type == \"n1_lt_n2\") {\n        n1 = rnd.next(1, 25);\n        n2 = rnd.next(26, 50);\n        k1 = rnd.next(1, 50);\n        k2 = rnd.next(1, 50);\n    } else if (type == \"equal\") {\n        n1 = n2 = rnd.next(1,50);\n        k1 = k2 = rnd.next(1,50);\n    } else if (type == \"random\") {\n        n1 = rnd.next(1,50);\n        n2 = rnd.next(1,50);\n        k1 = rnd.next(1,50);\n        k2 = rnd.next(1,50);\n    } else if (type == \"n1_equals_k1\") {\n        n1 = k1 = rnd.next(1,50);\n        n2 = rnd.next(1,50);\n        k2 = rnd.next(1,50);\n    } else if (type == \"n2_equals_k2\") {\n        n2 = k2 = rnd.next(1,50);\n        n1 = rnd.next(1,50);\n        k1 = rnd.next(1,50);\n    } else if (type == \"max\") {\n        n1 = n2 = k1 = k2 = 50;\n    } else {\n        // If n1, n2, k1, k2 are specified as parameters, use them\n        if (n1 == -1) n1 = rnd.next(1,50);\n        if (n2 == -1) n2 = rnd.next(1,50);\n        if (k1 == -1) k1 = rnd.next(1,50);\n        if (k2 == -1) k2 = rnd.next(1,50);\n    }\n    \n    // Final check to make sure n1, n2, k1, k2 are within bounds\n    n1 = max(1,min(50,n1));\n    n2 = max(1,min(50,n2));\n    k1 = max(1,min(50,k1));\n    k2 = max(1,min(50,k2));\n    \n    // Output\n    printf(\"%d %d %d %d\\n\", n1, n2, k1, k2);\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Parse the parameters\n    int n1 = opt<int>(\"n1\", -1);\n    int n2 = opt<int>(\"n2\", -1);\n    int k1 = opt<int>(\"k1\", -1);\n    int k2 = opt<int>(\"k2\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    \n    // Based on type, set n1, n2, k1, k2\n    if (type == \"edge\") {\n        // All variables are 1 or maximum.\n        int min_or_max = rnd.next(2);\n        if (min_or_max == 0) {\n            n1 = n2 = k1 = k2 = 1;\n        } else {\n            n1 = n2 = k1 = k2 = 50;\n        }\n    } else if (type == \"k1_large_k2_small\") {\n        n1 = rnd.next(1, 50);\n        n2 = rnd.next(1, 50);\n        k1 = rnd.next(26, 50);\n        k2 = rnd.next(1, 25);\n    } else if (type == \"k1_small_k2_large\") {\n        n1 = rnd.next(1, 50);\n        n2 = rnd.next(1, 50);\n        k1 = rnd.next(1, 25);\n        k2 = rnd.next(26, 50);\n    } else if (type == \"n1_gt_n2\") {\n        n1 = rnd.next(26, 50);\n        n2 = rnd.next(1, 25);\n        k1 = rnd.next(1, 50);\n        k2 = rnd.next(1, 50);\n    } else if (type == \"n1_lt_n2\") {\n        n1 = rnd.next(1, 25);\n        n2 = rnd.next(26, 50);\n        k1 = rnd.next(1, 50);\n        k2 = rnd.next(1, 50);\n    } else if (type == \"equal\") {\n        n1 = n2 = rnd.next(1,50);\n        k1 = k2 = rnd.next(1,50);\n    } else if (type == \"random\") {\n        n1 = rnd.next(1,50);\n        n2 = rnd.next(1,50);\n        k1 = rnd.next(1,50);\n        k2 = rnd.next(1,50);\n    } else if (type == \"n1_equals_k1\") {\n        n1 = k1 = rnd.next(1,50);\n        n2 = rnd.next(1,50);\n        k2 = rnd.next(1,50);\n    } else if (type == \"n2_equals_k2\") {\n        n2 = k2 = rnd.next(1,50);\n        n1 = rnd.next(1,50);\n        k1 = rnd.next(1,50);\n    } else if (type == \"max\") {\n        n1 = n2 = k1 = k2 = 50;\n    } else {\n        // If n1, n2, k1, k2 are specified as parameters, use them\n        if (n1 == -1) n1 = rnd.next(1,50);\n        if (n2 == -1) n2 = rnd.next(1,50);\n        if (k1 == -1) k1 = rnd.next(1,50);\n        if (k2 == -1) k2 = rnd.next(1,50);\n    }\n    \n    // Final check to make sure n1, n2, k1, k2 are within bounds\n    n1 = max(1,min(50,n1));\n    n2 = max(1,min(50,n2));\n    k1 = max(1,min(50,k1));\n    k2 = max(1,min(50,k2));\n    \n    // Output\n    printf(\"%d %d %d %d\\n\", n1, n2, k1, k2);\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type edge\n./gen -type max\n./gen -type random\n./gen -type random\n./gen -type random\n\n./gen -type n1_gt_n2\n./gen -type n1_gt_n2\n./gen -type n1_lt_n2\n./gen -type n1_lt_n2\n./gen -type equal\n./gen -type equal\n\n./gen -type k1_large_k2_small\n./gen -type k1_large_k2_small\n./gen -type k1_small_k2_large\n./gen -type k1_small_k2_large\n\n./gen -type n1_equals_k1\n./gen -type n2_equals_k2\n\n# Edge cases with specified values\n./gen -n1 1 -n2 1 -k1 1 -k2 1\n./gen -n1 1 -n2 1 -k1 50 -k2 50\n./gen -n1 50 -n2 50 -k1 1 -k2 1\n./gen -n1 50 -n2 50 -k1 50 -k2 50\n\n# Specific corner cases\n./gen -n1 50 -n2 1 -k1 50 -k2 1\n./gen -n1 1 -n2 50 -k1 1 -k2 50\n\n# Random test cases with specified parameters\n./gen -n1 25 -n2 25 -k1 13 -k2 13\n./gen -n1 13 -n2 13 -k1 25 -k2 25\n\n# More random test cases\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:54.625851",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "513/C",
      "title": "C. Second price auction",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains an integer number n (2 ≤ n ≤ 5). n lines follow, the i-th of them containing two numbers Li and Ri (1 ≤ Li ≤ Ri ≤ 10000) describing the i-th company's bid preferences.This problem doesn't have subproblems. You will get 8 points for the correct submission.",
      "output_spec": "OutputOutput the answer with absolute or relative error no more than 1e - 9.",
      "sample_tests": "ExamplesInputCopy34 78 105 5OutputCopy5.7500000000InputCopy32 53 41 6OutputCopy3.5000000000",
      "description": "C. Second price auction\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line of input contains an integer number n (2 ≤ n ≤ 5). n lines follow, the i-th of them containing two numbers Li and Ri (1 ≤ Li ≤ Ri ≤ 10000) describing the i-th company's bid preferences.This problem doesn't have subproblems. You will get 8 points for the correct submission.\n\nOutputOutput the answer with absolute or relative error no more than 1e - 9.\n\nInputCopy34 78 105 5OutputCopy5.7500000000InputCopy32 53 41 6OutputCopy3.5000000000\n\nInputCopy34 78 105 5\n\nOutputCopy5.7500000000\n\nInputCopy32 53 41 6\n\nOutputCopy3.5000000000\n\nNoteConsider the first example. The first company bids a random integer number of microdollars in range [4, 7]; the second company bids between 8 and 10, and the third company bids 5 microdollars. The second company will win regardless of the exact value it bids, however the price it will pay depends on the value of first company's bid. With probability 0.5 the first company will bid at most 5 microdollars, and the second-highest price of the whole auction will be 5. With probability 0.25 it will bid 6 microdollars, and with probability 0.25 it will bid 7 microdollars. Thus, the expected value the second company will have to pay is 0.5·5 + 0.25·6 + 0.25·7 = 5.75.",
      "solutions": [
        {
          "title": "Rockethon 2015 Announcement - Codeforces",
          "content": "Hello Codeforces community,I am happy to announce that Rocket Fuel Inc. will be hosting a Rockethon competition again! The contest is prepared by Rocket Fuel employees Eldar Bogdanov, Anton Lomonos, Lasha Lakirbaia, Alexander Ruff, Nikhil Goyal and me, Ievgen Soboliev. We hope everyone will find some interesting problems in the contest and everyone will have as much fun solving these problems as we had preparing them. Just like last year, the best participants will receive valuable prizes and top performers will get Rockethon 2015 T-shirts! Also, Rocket Fuel is interested in hiring people after this event, so please fill out the simple form during registration.About Rocket FuelRocket Fuel is building technology platform to do automatic targeting and optimization of ads across all channels — display, video, mobile and social. Our pitch to advertisers is very simple \"If you can measure metrics of success of your campaign, we can optimize\". We run campaigns for many large advertisers and our clients include many top companies within the following industries: autos, airlines, commercial banks, telecom, food services, insurance, etc. Examples include BMW, Pizza Hut, Brooks Running Shoes and many more!We buy all our inventory through real time bidding on ad exchanges like Google and Yahoo. Ad exchanges are similar to stock exchanges except the commodity being traded is ad slots on web pages. Our serving systems currently process over 60B bid requests/ day with a response time requirement of 100ms. Our data platform has 64 PBs data that is used for analytics as well as modeling.Our engineering team is still small (~150) enough for any one person like yourself to make a huge impact. The team represents many top schools in US and outside — Stanford, Carnegie Mellon, MIT, Wisconsin-Madison, IIT (India), Tsinghua (China).Rocket Fuel has been named #4 on Forbes Most Promising Companies in America List in 2013 and #1 Fastest Growing Company in North America on Deloitte’s 2013 Tech Fast 500 and our CEO George John was recently named “Most Admired CEO” by the SF Business Times in 2014.My Personal StoryAbout one year ago I visited CodeForces and saw an announcement of Rockethon 2014. My first thought was \"Another competition from a big company, that's nice!\". I took part in this contest, performed quite well and recruiters from Rocket Fuel have contacted me and scheduled some interviews. I passed the interviews and now I'm here, in Rocket Fuel.It has been a nice opportunity to learn advanced concepts of software engineering from a huge amount of smart people working with you. Also, our activities here are not limited only to writing code — we do fun things here like playing basketball, soccer, table tennis. I invite everybody to take a part in the competition and would be glad to hear if any of you thinking about joining Rocket Fuel.Contest OverviewThe contest will begin on February 7, 9AM PST.The contest length is 3 hours.The testing of each submission will be performed as soon as the submission is received and the verdict will be delivered to the submission author right away.The problemset will consist of 7 problems. Each problem can contain from one to three subproblems. Each subproblem will be worth a fixed amount of points. The ties between contestants with the same score will be broken by penalty time which is computed similar to ACM scoring system.PrizesThe top three contestants will receive the following prizes:1) IPhone 6 (16 Gb)2) Participant can choose Apple Watch or Samsung Gear S3) Participant can choose Apple Watch or Samsung Gear SThe top 150 performers will receive a Rockethon T-shirt designed specially for this contest.If you are unable to take part in the competition but are interested in joining Rocket Fuel, we will be screening resumes submitted through the special form.",
          "author": "Seyaua",
          "url": "https://codeforces.com/blog/entry/16140",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3845
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces",
          "content": "(This is a beta version of editorial. It will be changed later)I hope everybody enjoyed the contest. Here we'll present some of the author's solutions to the problems together with some other approaches that we came up with. The editorial is prepared by Lasha Lakirbaia, Anton Lomonos, and Ievgen Soboliev.A — Game(developed by Ievgen Soboliev & Eldar Bogdanov, editorial written by Lasha Lakirbaia)The problem can be solved with dynamic programming technique. Let winner[a][b][move] denote who wins if both players play optimally and the first has a balls left in his box, the second has b balls left in his box and move defines who is to move next. To determine the value of winner[a][b][move], we should consider all the possible moves the next player can make and see whether any of them lead into the position winner[x][y][move2] in which this player can win with optimal play. Thus, values of winner can be defined recursively.Ok it was a joke, the solution is just this one line: println (n1 > n2 ? “First” : “Second”).B — Permutations(developed by Ievgen Soboliev & Eldar Bogdanov, editorial written by Lasha Lakirbaia)For a given array p1, p2, ..., pk let’s call the value of that expression the value of that array.For the first subproblem, we can just consider all n! permutations in lexicographic order and keep 2 variables — one of them should be the highest value so far, and the other should be the list of permutations with that highest value. Than we can update this variables like this: When he have a new permutation, if it has smaller value, we disregard it. If it has larger value, we assign the first variable this new value and to the second variable we assign 1-element list, containing this current permutation only. In the end we just pick m-th element from the second variable. From now on we’ll concentrate on solving the harder one.First of all let’s find out which permutations have the highest values among all the permutations of (1, 2, ..., n). It's easy to note that whenever we have some n-element array, in the highest valued permutations the position of the smallest element of the array will be either first or the last in the permutation. This can be proved easily as follows: There can't be an optimal (highest valued) permutation where the smallest element is in the middle (I mean after the first and before the last), because moving this element to either beginning or ending would obviously increase the value, that would thus contradict the statement that the original permutation had the highest value. So we proved that the position of 1 should either be at the beginning or at the end of a highest valued permutation. Moreover, it’s easy to see that in both cases, the value will be the same. After we decide on which end 1 will be, than we can move on to the remaining array (2, 3, ..., n) and do the same for 2 as we did for 1. Than we go on and do the same for 3, 4, ..., n. From here we can clearly say what are all the permutations with the highest value — all the permutations which can be derived by the following algorithm: Consider numbers (1, 2, ..., n) in the reverse order. Each time add the current number to one of the ends of the current permutation (initially the permutation is empty). For example, for n=5 the possible permutations are (1, 2, 3, 4, 5), (1, 3, 5, 4, 2), (5, 4, 3, 2, 1) and (1, 2, 5, 4, 3). One more important thing to note is that the number of highest valued permutations of any n-element array is equal to 2n - 1, which easily follows from the way we’re constructing all these permutations. With all that said, the rest of the solution is pretty straightforward. Let’s consider numbers 1, 2, ..., n in this order and apply the following recursive approach: If we’re currently on pos-th position and searching for m-th element, having already decided the indices of all the elements less than pos, then there are 2 cases: We know that number of possible permutations is 2n - pos - 1. If m ≤ 2n - pos - 1, then we put pos element in the beginning of the array and recursively go to the state (pos + 1, m). Otherwise, we’ll put pos in the end of the array and recursively go to the state (pos + 1, 2n - pos - 1 - m). The total running time of this solution is O(n), if implemented in optimal way but almost any kind of implementation of this idea would work, as the value of n is relatively small.Note 1: From the solution it's visible that m ≤ 249, and also for n = 50 m can be as big as 249, which doesn't fit in int but fits in long.Note 2: This last steps can also be implemented by just considering the binary representation of m.C — Second Price Auction(developed by Ievgen Soboliev & Eldar Bogdanov, editorial written by Lasha Lakirbaia)This problem can be solved in many different ways. Here we’ll explain 3 of them. Let’s denote by P(b) the probability of second highest bid being equal to b. Obviously, possible values of b are only integers from 1 to 10, 000. If we can calculate P(b) for each b in that range, then the desired expected value is just . Now let’s concentrate on calculating P(b) for a given b. These 3 solutions have different approaches to calculating the value of P(b).First solution (the easiest) — brute forceLet’s consider every partition of a set of bidders into 3 subsets, such that in the first set each bidder had higher bid than b, in second set each bid was equal to b, while in the third set each bid was less than b. As we assume that b is the second highest bid, it’s easy to notice that the first set contains either 0 or 1 element, while the second set contains at least 1 element. (Also, if the first set is empty, the second set must contain at least 2 elements) Number of such partitions is O(2n·n). After we have this partition, for each bidder we know if its bid should be more, equal or less then b. Probability of any of these can easily be counted in O(1). So in the end we get the complexity of O(2n·n·max(R - L + 1)), which is good enough for given constraints.Second solution — dynamic programmingLet’s consider the following dynamic programming approach. Denote by (pos, moreCount, equalCount) the state, when we already considered all bidders with indices less then pos, the second largest bid in the end must be equal to b, currently the number of bidders with bid higher than b is moreCount and the number of bidders with bid equal to b is equalCount. Finally, dp(pos, moreCount, equalCount) denotes the value of P(b) for this state. Note, that we don’t have to consider the states where moreCount > 1, because for them P(b) = 0. Also, we don’t need to distinguish between states where some of them has equalCount = 2 and some of them has equalCount > 2. They have same values. So we’ll assume that equalCount < 3 and moreCount < 2. Transitions for this dynamic programming are as follows: - Consider current bid to be higher than b. It’s only possible if moreCount = 0, because otherwise the probability of P(b) will be 0. If moreCount = 0, the transition will be to dp(pos + 1, 1, equalCount). - Consider current bid to be equal to b. It will lead us to a transition to dp(pos + 1, moreCount, min(equalCount + 1, 2)). - Consider current bid to be less than b. Transition in the case will be dp(pos + 1, moreCount, equalCount).All these cases have their respective probabilities, which are straightforward to calculate in O(1). So as we see, the number of states of dynamic programming is O(n), while calculating each state take O(1). So in total, calculating P(b) takes O(n) time, which leads us to the solution of the initial problem in O(n * max(R - L + 1)).Third solution — pure mathP(b) = Pr.(maxBid = b, secondMaxBid = b) + Pr.(maxBid > b, secondMaxBid = b). Let’s calculate these 2 summands separately. Denote by ri a random bid of i - th bidder.Pr.(maxBid = b, secondMaxBid = b) = Pr.(maxBidb) - Pr.(maxBid < b) . Now let’s calculate the other summand: .Note that each of Pr.(ri > b), Pr.(ri = b) and Pr.(ri < b) can be calculated in O(1), so P(b) can be calculated in O(n2). So in the end, we get the running time of O(n2·max(R - L + 1)). However, the last step can easily be implemented in O(n), which would give us the total running time of O(n·max(R - L + 1)), but in this problem it’s not required as n ≤ 5.Note: As you can see, using second and third solutions the problem could be solvable for much larger values of n. However, we felt like all three approaches are equally interesting and let any of them pass. Bonus: assuming that we can multiply doubles without precision loss in polynomial time, can you solve the problem in polynomial time if the bid ranges of each company are unbounded?D — Constrained Tree(developed by Eldar Bogdanov, Alexander Ruff and Anton Lomonos, editorial written by Anton Lomonos)Let's try to construct this tree from top to bottom trying to comply with given set of constraints. The first observation you need to make is if vertices i and j (i < j) should be in a given subtree then any vertex k (i < k < j) should also be in this subtree. It leads to 2 important conclusions: Our task \"find a tree rooted at vertex 1 which should contain N vertices and comply to the given set of constraints\" can be rephrased to \"find a tree rooted at vertex 1 which should comply to the given set of constraints, contain the least number of vertices as possible, and contain vertex N\". We need to know only minimums and maximums for left and right parts of each subtree. Let's assume we are trying to construct subtree rooted at i that should contain vertex m, vertices [j1..j2] to the left of the root, and vertices [k1..k2] to the right of the root. If we don't have constraints for the left part or for the right part of the subtree then we can place all the vertices utterly to the right or to the left (we still need to check constraints for sanity). Otherwise, the conditions i < j1, j2 < k1 should take place. The vertex i + 1 should be the left child of the root. Vertices [j2 + 1;k1 - 1] may be placed to the left or to the right which depends on the constraints. Let's construct the left subtree rooted at i + 1 in such a way that it should contain the vertex j2 and contain at least number of vertices as possible. Let's assume the vertex with the biggest label in this subtree is mid. Condition mid < k1 should take place. Then we can make right child of the root to be mid + 1, and we need to construct subtree rooted at mid + 1 that should contain at least number of vertices as possible and should contain vertex max(k2, m)The complexity of algorithm is O(N + C).E — Subarray Cuts(proposed by Nikhil Goyal, developed by Anton Lomonos and Lasha Lakirbaia, editorial written by Anton Lomonos and Lasha Lakirbaia)This problem can be solved in several ways. One of the expected solution for the easier part has complexity O(n2k), which will be presented later. For now let's discuss another solution, which is also good enough for first subproblem and has complexity of O(nk2).Let’s call the set of all possible k-tuples of partitions A; So we’re concentrating on finding the element of A with the maximal sum value. Let’s consider another set of tuples of partitions but with the following properties: We have at most k disjoint subarrays chosen. Call their sums s1, s2, …, sm (m is the number of subarrays and m ≤ k). For each 1 ≤ i ≤ (m - 1), (s(i - 1) - si) * (si - s(i + 1)) < 0. In other words, si is not between its neighbors by value. (For example, if its neighbors are 3 and 11, it will be either greater than 11 or less than 3). The number of unused (not picked) elements from the initial array is at least (k - m). In other words, we are able to add enough disjoint subarrays to this m subarrays so that in the end we have exactly k of them. Let’s call this set B.It can be easily proved, that the maximal valued elements in A and B have the same value. The proof of this statement is given in the very end of the solution. For now let’s believe it and solve the problem.So from now on we concentrate on finding the maximal value with the property of B.Note that the value of any element of B with sums s1, s2, …, sm is equal to the maximum of ( + s1 - 2·s2 + 2·s3 - 2·s4 + …) and ( - s1 + 2 cdots2 - 2 cdots3 + 2·s4 - …). The important catch here is that we can ignore the property of B which says that each sum of subarray is NOT between it’s neighboring sums, because in the end we’ll get the same answers. So we just ignore that property and solve the problem without that restriction. The only restriction remaining is that they should be disjoint and the total number of unused elements should be at least (k - m). Here is the sketch of the proof why will it give the same answer: s1 - 2·s2 + 2·s3 - … = (s1 - s2) + (s3 - s2) + … ≤ |s1 - s2| + |s2 - s3| + …, as well as ( - s1 + 2·s2 - 2·s3 + ...). It means that when they’re both maximum, they equal to each other.So we can instead concentrate on finding the maximal possible ( + s1 - 2·s2 + 2·s3 - 2·s4 + …) and ( - s1 + 2·s2 - 2·s3 + 2·s4 - …) values and it will coincide with the answer to our problem.Denote by dp(pos, sign, first, last, unused, max) — the answer for the subproblem (apos, a(pos + 1), …) where sign means the sign of the first chosen subarray, first and last denote whether the current subarray should be first, last or none of them, unused denotes the number of unused elements that we should preserve and max denotes the maximum number of subarrays we may take. There are O(nk2) states here, cause sign, first and last each have just 2 options. Important part here is how we make transitions in O(1) and thus solve the entire problem in O(nk2). First transition would correspond to ignoring pos-th element — dp(pos + 1, sign, first, last, min(unused + 1, k), max). Otherwise we are taking apos in the first chosen subarray. There are 2 cases here: Either the current interval is just (pos, pos), or it’s length is more than 1. In the first case, the value is signapos·((firstorlast)?1: 2) + dp(pos + 1,  - sign, false, 0or1, unused, max - 1). In the second case, the value would be sign·apos·((firstorlast)?1: 2) + dp(pos + 1, sign, first, last, unused, max).Hence, in total we have 3 transitions and thus we calculate each dp(pos, sign, first, last, unused, max) in O(1). It means the entire complexity of the solution is O(nk2). Note: We didn’t present every detail and corner case, because it would be very boring to read otherwise.Below we’ll present the solution for the harder version of this problem.In general case we are trying to calculate this expression:max(... + |sj - 2 - sj - 1| + |sj - 1 - sj| + |sj - sj + 1| + ...) = max(... ± (sj - 2 - sj - 1) ± (sj - 1 - sj) ± (sj - sj + 1) ± ...)This task can be solved by using dynamic programming. Let's try to calculate recurrently the following function where we should pick subarrays j..k from array [i; n]:f(i, j, c1, c2) = max(... ± (0 - 0) c1 (0 - sj) c2 (sj - sj + 1) ± (sj + 1 - sj + 2) ± ...), where are defined.The recurrent formula for this function is:f(i, j, c1, c2) = maxp1, p2(c1 ( - sump = p1..p2ap) c2 (sump = p1..p2ap) + f(p2 + 1, j + 1, c2,  ± ))We can easily get rid of using p1:f(i, j, c1, c2) = max(f(i + 1, j, c1, c2), maxp2(c1 ( - sump = i..p2ap) c2 (sump = i..p2ap) + f(p2 + 1, j + 1, c2,  ± ))We can get rid from p2 by using additional function g(i, j, c1, c2), which states that subarray j already has some elements in it:f(i, j, c1, c2) = max(f(i + 1, j, c1, c2), c1 ( - ai) c2 ai + g(i + 1, j, c1, c2))g(i, j, c1, c2) = max(f(i, j + 1, c2,  + ), f(i, j + 1, c2,  - ), c1 ( - ai) c2 (ai) + g(i + 1, j, c1, c2))There is still a matter of handling the beginning and ending of dynamic programming. There are several ways to do it. For example, we can calculate maximums and minimums of values s1 or sk based on their endings or beginnings, or we can make exceptions for using c1 and c2 if j = 1 or j = k.The complexity of the algorithm is O(n * k).F — Scaygerboss(developed by Anton Lomonos, editorial written by Anton Lomonos)The task reduces to the situation when we have k females and k males, and we need to connect them in such a way, that there will be no more than one pair in each cell. This task can be solved by using maximum flow algorithm. Firstly we need to choose the value of our answer ans (for example, by binary search) and check if they can connect in a time no more than ans. Let's make edges of capacity 1 between source and females, between males and sink, and between inputs and outputs of each cell. Then let's make edges of capacity 1 between females and inputs of cells and between outputs of cells and males if they can reach this cell within ans (we can calculate these values by using breadth-first algorithm). If we can get a maximum flow of capacity k on this graph then they can reach each other within ans.The above approach is enough to solve the first part of the task. It has complexity of O(k3·log(k)). For solving second part of the task one should optimize the above solution. Highly optimized solution with complexity of O(k3·log(k)) could pass, but there exists a solution with complexity O(k3). The first observation you need to make is you don't need to reconstruct the graph each time for running maximum flow algorithm. If you run the algorithm for ans = a, and then run the algorithm for ans = b, b > a, you would just need to add additional edges and \"continue to run\" maximum flow algorithm. The complexity of this would be O(k3 + l·k2) where l is the number of times you do this trick. Using this observations in different ways could be enough to pass the second part of the task. You can achieve the complexity of O(k3) by using square root decomposition. You need to divide k2 edges to k batches of k edges based on the values of ans you can use these edges for. Running maximum flow algorithm after adding each of these batches would get you O(k3) complexity. Then you know which batch would tell you what the answer is, and you run maximum flow algorithm for this batch, which is O(k3) complexity too. You can also divide edges to batches not based by their quantities, but based by their values. You will be adding the edges of the same values to the graph in the same blow. That way your algorithm would run even faster.I (White_Bear) would like to give special congratulations to mmaxio, Petr, niyaznigmatul, and Egor who solved F2 using Java.G — Inversions Problem(proposed by Ievgen Soboiliev, developed by Ievgen Soboiliev, editorial written by Lasha Lakirbaia, to be changed)This is a draft of solution to this problem. It will be changed later. Currently it contains solutions of first 2 subproblems.The first subproblem can be solved many ways. The easiest probably is the following: consider the dynamic programming approach where the state is (perm, m) — where perm is the current permutation and m is the number of operations that are going to be performed over it. Transitions are just all the possible permutations that can be derived in the next turns (with their respective probabilities) and obviously the other variable will be just (m - 1). The running time for this approach is O(n! * n3 * k), which is good enough for the given constraints. Note that even though for small n the number of possible permutations is pretty small and k is also small, solutions based on simulation are not working at the precision level that’s required. To solve 2 other subproblems, we are gonna need more observations. First one is the linearity of expected value. It basically means that the expected value of a sum of random variables is equal to the sum of expected values of those variables, even if they’re somehow dependent on each other. Let’s see how we can use this idea to solve this problem. For this we have to look at the number of inversions a bit differently. For each possible pair (i, j) with 1 ≤ i < j ≤ n, let’s define the random variable b(i, j) to be 0 if i - th and j - th elements will preserve the order after k operations and 1 otherwise. Now, the number of inversions in terms of these variables is equal to . So if we can find the expected values of each b(i, j) variables, than calculating the answer will be straightforward.Another observation is that the expected value of a binary variables is the same as it’s probability of being equal to 1. It means that the expected value of b(i, j) is same as probability that i - th and j - th elements will swap the order in the end, after k moves. From now on, let’s denote by p(i, j, m) the probability, that after m steps the i - th and j - th elements will swap the order (in other words, probability that the final position of the i - th element will be to the right side of the final position of j - th element). The solutions of second and third subproblems differ only in ways of calculating these values.Easier way to find these values is to use recursive approach: Consider all the possible next moves — namely all possible intervals (x, y) on which the next step will be performed. Each of them has probability equal to . There are several cases:(1) Intervals (x, y) and (i, j) are either disjoint, or i < x, y < j. In both cases, the transition will be just p(i, j, m - 1).(2) x ≤ i ≤ y < j. In this case the transition is gonna be p(x + y - i, j, m - 1).(3) i < x ≤ j ≤ y. In this case the transition will be p(i, x + y - j, m - 1).(4) x ≤ i ≤ j ≤ y. In this case the transition will be p(x + y - i, x + y - j, m - 1).The running time of this solution will be O(n4 * k), which is good enough for 2-nd subproblem, but not for the third one. This solution can actually be optimized. For this, we will need to deal with above 4 cases in O(n) each, instead of O(n2).(1) We just count how many (x, y) intervals are of this type (i < x, y < j) and than multiply this number by p(i, j, m - 1).(2) For each fixed possible value of (x + y), count how many (x, y) exist with that sum such that x ≤ i ≤ y < j. It can easily be done in O(1). As there are O(n) possible values of (x + y), this whole step takes O(n).(3) The approach here is exactly the same as in the second case.(4) For each possible value of s = x + y such that x ≤ i ≤ j ≤ y and sum up (1 - p(s - j, s - i, m - 1)). There are O(n) possible values of s, so this whole step takes O(n) time.As these 4 steps each take at most O(n), the total running time will be O(n3·k). The fastest solution works in O(n2·min(k, 2000)). This solution will be described later.",
          "author": "llaki",
          "url": "https://codeforces.com/blog/entry/16260",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 22414
        }
      ],
      "code_examples": [
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 1",
          "code": "3 3\n1 2 LEFT\n1 3 RIGHT\n2 3 RIGHT",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 2",
          "code": "3 3\n1 2 LEFT\n1 3 RIGHT\n2 3 RIGHT",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 3",
          "code": "1 << length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 4",
          "code": "1LL << length",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 5",
          "code": "if (k > 1000) {\n    k = 1000;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 6",
          "code": "if (k > 1000) {\n    k = 1000;\n  }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Announcement - Codeforces - Code 7",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16140",
          "author": "Seyaua"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 1",
          "code": "sum = 0\nfor simulation = 1 --> 10^6:\n  A = initial array\n  for i = 1 --> k:\n    u = random(1, n)\n    v = random(1, n)\n    reverse(A[u] .. A[v])\n  sum += count_inversions(A)\n\nprint(sum / 10^6)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 2",
          "code": "sum = 0\nfor simulation = 1 --> 10^6:\n  A = initial array\n  for i = 1 --> k:\n    u = random(1, n)\n    v = random(1, n)\n    reverse(A[u] .. A[v])\n  sum += count_inversions(A)\n\nprint(sum / 10^6)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 3",
          "code": "Note 2: This last steps can also be implemented by just considering the binary representation of m.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 4",
          "code": "m-2^(n-pos-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 5",
          "code": "4\n1 5\n1 6\n7 10\n7 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 6",
          "code": "4\n1 5\n1 6\n7 10\n7 10",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        },
        {
          "title": "Rockethon 2015 Editorial - Codeforces - Code 7",
          "code": "{(1, 5), (1, 6)}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16260",
          "author": "llaki"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int Li = inf.readInt(1, 10000, \"Li\");\n        inf.readSpace();\n        int Ri = inf.readInt(Li, 10000, \"Ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int Li = inf.readInt(1, 10000, \"Li\");\n        inf.readSpace();\n        int Ri = inf.readInt(Li, 10000, \"Ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 5, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int Li = inf.readInt(1, 10000, \"Li\");\n        inf.readSpace();\n        int Ri = inf.readInt(Li, 10000, \"Ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-9;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.10f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.10f', found: '%.10f', error = '%.10f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.10f', expected '%.10f', error '%.10f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default is \"random\"\n\n    assert(2 <= n && n <= 5); // Ensure n is within the constraints\n\n    vector<pair<int, int>> ranges(n);\n\n    if (type == \"random\") {\n        // Generate random Li and Ri within constraints\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(1, 10000);\n            int R = rnd.next(L, 10000);\n            ranges[i] = {L, R};\n        }\n    } else if (type == \"fixed\") {\n        // Li == Ri\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(1, 10000);\n            ranges[i] = {L, L};\n        }\n    } else if (type == \"identical\") {\n        // All companies have the same [L,R]\n        int L = rnd.next(1, 10000);\n        int R = rnd.next(L, 10000);\n        for (int i = 0; i < n; ++i) {\n            ranges[i] = {L, R};\n        }\n    } else if (type == \"overlap\") {\n        // All ranges overlap\n        int commonL = rnd.next(1, 9000);\n        int commonR = rnd.next(commonL + 1, 10000);\n        for (int i = 0; i < n; ++i) {\n            int Li = rnd.next(commonL, commonR - 1);\n            int Ri = rnd.next(Li + 1, commonR);\n            ranges[i] = {Li, Ri};\n        }\n    } else if (type == \"nonoverlap\") {\n        // Ranges do not overlap\n        int start = 1;\n        int chunk = (10000 + n - 1) / n;\n        for (int i = 0; i < n; ++i) {\n            int Li = start;\n            int Ri = min(start + chunk - 1, 10000);\n            ranges[i] = {Li, Ri};\n            start += chunk;\n        }\n    } else if (type == \"wide-range\") {\n        // One company has wide range, others have small ranges\n        int wideIndex = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == wideIndex) {\n                ranges[i] = {1, 10000};\n            } else {\n                int L = rnd.next(1, 10000);\n                ranges[i] = {L, L}; // Fixed bid\n            }\n        }\n    } else if (type == \"min-max\") {\n        // Some companies bid minimum, some bid maximum\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ranges[i] = {1, 1};\n            } else {\n                ranges[i] = {10000, 10000};\n            }\n        }\n    } else if (type == \"equal-bids\") {\n        // All bids are equal, Li == Ri == K\n        int K = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            ranges[i] = {K, K};\n        }\n    } else if (type == \"max-bids\") {\n        // All companies bid maximum\n        for (int i = 0; i < n; ++i)\n            ranges[i] = {10000, 10000};\n    } else if (type == \"min-bids\") {\n        // All companies bid minimum\n        for (int i = 0; i < n; ++i)\n            ranges[i] = {1, 1};\n    } else if (type == \"single-high\") {\n        // One company with high range, others with low ranges\n        int highIndex = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == highIndex) {\n                ranges[i] = {9000, 10000};\n            } else {\n                int L = rnd.next(1, 1000);\n                ranges[i] = {L, rnd.next(L, 1000)};\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(1, 10000);\n            int R = rnd.next(L, 10000);\n            ranges[i] = {L, R};\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ranges\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ranges[i].first, ranges[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default is \"random\"\n\n    assert(2 <= n && n <= 5); // Ensure n is within the constraints\n\n    vector<pair<int, int>> ranges(n);\n\n    if (type == \"random\") {\n        // Generate random Li and Ri within constraints\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(1, 10000);\n            int R = rnd.next(L, 10000);\n            ranges[i] = {L, R};\n        }\n    } else if (type == \"fixed\") {\n        // Li == Ri\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(1, 10000);\n            ranges[i] = {L, L};\n        }\n    } else if (type == \"identical\") {\n        // All companies have the same [L,R]\n        int L = rnd.next(1, 10000);\n        int R = rnd.next(L, 10000);\n        for (int i = 0; i < n; ++i) {\n            ranges[i] = {L, R};\n        }\n    } else if (type == \"overlap\") {\n        // All ranges overlap\n        int commonL = rnd.next(1, 9000);\n        int commonR = rnd.next(commonL + 1, 10000);\n        for (int i = 0; i < n; ++i) {\n            int Li = rnd.next(commonL, commonR - 1);\n            int Ri = rnd.next(Li + 1, commonR);\n            ranges[i] = {Li, Ri};\n        }\n    } else if (type == \"nonoverlap\") {\n        // Ranges do not overlap\n        int start = 1;\n        int chunk = (10000 + n - 1) / n;\n        for (int i = 0; i < n; ++i) {\n            int Li = start;\n            int Ri = min(start + chunk - 1, 10000);\n            ranges[i] = {Li, Ri};\n            start += chunk;\n        }\n    } else if (type == \"wide-range\") {\n        // One company has wide range, others have small ranges\n        int wideIndex = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == wideIndex) {\n                ranges[i] = {1, 10000};\n            } else {\n                int L = rnd.next(1, 10000);\n                ranges[i] = {L, L}; // Fixed bid\n            }\n        }\n    } else if (type == \"min-max\") {\n        // Some companies bid minimum, some bid maximum\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                ranges[i] = {1, 1};\n            } else {\n                ranges[i] = {10000, 10000};\n            }\n        }\n    } else if (type == \"equal-bids\") {\n        // All bids are equal, Li == Ri == K\n        int K = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            ranges[i] = {K, K};\n        }\n    } else if (type == \"max-bids\") {\n        // All companies bid maximum\n        for (int i = 0; i < n; ++i)\n            ranges[i] = {10000, 10000};\n    } else if (type == \"min-bids\") {\n        // All companies bid minimum\n        for (int i = 0; i < n; ++i)\n            ranges[i] = {1, 1};\n    } else if (type == \"single-high\") {\n        // One company with high range, others with low ranges\n        int highIndex = rnd.next(0, n - 1);\n        for (int i = 0; i < n; ++i) {\n            if (i == highIndex) {\n                ranges[i] = {9000, 10000};\n            } else {\n                int L = rnd.next(1, 1000);\n                ranges[i] = {L, rnd.next(L, 1000)};\n            }\n        }\n    } else {\n        // Default is random\n        for (int i = 0; i < n; ++i) {\n            int L = rnd.next(1, 10000);\n            int R = rnd.next(L, 10000);\n            ranges[i] = {L, R};\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ranges\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", ranges[i].first, ranges[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type fixed\n./gen -n 2 -type identical\n./gen -n 2 -type nonoverlap\n./gen -n 2 -type single-high\n./gen -n 2 -type equal-bids\n\n./gen -n 3 -type random\n./gen -n 3 -type fixed\n./gen -n 3 -type identical\n./gen -n 3 -type nonoverlap\n./gen -n 3 -type single-high\n./gen -n 3 -type equal-bids\n\n./gen -n 4 -type random\n./gen -n 4 -type fixed\n./gen -n 4 -type identical\n./gen -n 4 -type nonoverlap\n./gen -n 4 -type single-high\n./gen -n 4 -type equal-bids\n\n./gen -n 5 -type random\n./gen -n 5 -type fixed\n./gen -n 5 -type identical\n./gen -n 5 -type nonoverlap\n./gen -n 5 -type single-high\n./gen -n 5 -type equal-bids\n\n# Additional commands\n./gen -n 2 -type wide-range\n./gen -n 3 -type min-max\n./gen -n 4 -type max-bids\n./gen -n 5 -type min-bids\n./gen -n 2 -type overlap\n./gen -n 3 -type overlap\n./gen -n 4 -type overlap\n./gen -n 5 -type overlap\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:56.760881",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "514/A",
      "title": "A. Chewbaсca and Number",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer x (1 ≤ x ≤ 1018) — the number that Luke Skywalker gave to Chewbacca.",
      "output_spec": "OutputPrint the minimum possible positive number that Chewbacca can obtain after inverting some digits. The number shouldn't contain leading zeroes.",
      "sample_tests": "ExamplesInputCopy27OutputCopy22InputCopy4545OutputCopy4444",
      "description": "A. Chewbaсca and Number\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains a single integer x (1 ≤ x ≤ 1018) — the number that Luke Skywalker gave to Chewbacca.\n\nOutputPrint the minimum possible positive number that Chewbacca can obtain after inverting some digits. The number shouldn't contain leading zeroes.\n\nInputCopy27OutputCopy22InputCopy4545OutputCopy4444\n\nInputCopy27\n\nOutputCopy22\n\nInputCopy4545\n\nOutputCopy4444",
      "solutions": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #291 (Div. 2). It'll be held on Saturday, February 14 at 19:30 MSK.Great thanks Maxim Akhmedov (Zlobober), Vasya Antoniuk (Antoniuk) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.Good luck everyone!UPD: Score distribution will be the next — 500-1000-2000-2000-2500.UPD: Editorial. Sorry for the delay)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16365",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 492
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces",
          "content": "514A - Chewbaсca and NumberAuthor: RebrykIt is obvious that all the digits, which are greater than 4, need to be inverted. The only exception is 9, if it's the first digit.Complexity: 514B - Han Solo and Lazer GunAuthor: AntoniukLet's run through every point, where the stormtroopers are situated. If in current point stormtroopers are still alive, let's make a shot and destroy every stormtrooper on the same line with gun and current point.Points (x1, y1), (x2, y2), (x3, y3) are on the same line, if (x2 - x1)(y3 - y1) = (x3 - x1)(y2 - y1).Complexity: 514C - Watto and MechanismAuthor: RebrykWhile adding a string to the set, let's count its polynomial hash and add it to an array. Then let's sort this array. Now, to know the query answer, let's try to change every symbol in the string and check with binary search if its hash can be found in the array (recounting hashes with complexity). If the hash is found in the array, the answer is \"YES\", otherwise \"NO\".Complexity: , where L is total length of all strings.514D - R2D2 and Droid ArmyAuthor: RebrykTo destroy all the droids on a segment of l to r, we need to make shots, where cnt[i][j] — number of j-type details in i-th droid. Let's support two pointers — on the beginning and on the end of the segment, which we want to destroy all the droids on. If we can destroy droids on current segment, let's increase right border of the segment, otherwise increase left border, updating the answer after every segment change. Let's use a queue in order to find the segment maximum effectively.Complexity: 514E - Darth Vader and TreeAuthor: AntoniukIt's easy to realize that , where dp[i] is number of vertices, which are situated on a distance i from the root, and cnt[j] is number of children, which are situated on a distance j. Answer .Let the dynamics conditionLet's build a transformation matrix of 101 × 101 sizeNow, to move to the next condition, we need to multiply A by B. So, if matrix C = A·Bx - 100, then the answer will be situated in the very right cell of this matrix. For x < 100 we'll find the answer using dynamics explained in the beginning.In order to find Bk let's use binary power.Complexity:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16398",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 514\\s*A"
          },
          "content_length": 2168
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 1",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 2",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 3",
          "code": "ax+by+c = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 4",
          "code": "gcd(a,b,c) = 1 and a > 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 5",
          "code": "n equation (a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 6",
          "code": "(a_i,b_i,c_i) == (a_j,b_j,c_j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 7",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 8",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 9",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 10",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 11",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 12",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 13",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 14",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 15",
          "code": "m string query",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 16",
          "code": "string x = s",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 17",
          "code": "set x[j] = {'a','b','c' \\ x[j] != s[j]}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 18",
          "code": "The total length of lines in the input doesn't exceed 6·10^5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 19",
          "code": "my standing not low",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 20",
          "code": "deque.back()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 21",
          "code": "deque.push_back(a[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 22",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 23",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 24",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 25",
          "code": "set <string> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 26",
          "code": "if (f.find(s) != f.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 27",
          "code": "map <string, bool> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 28",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 29",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "H = (H * p + s[i]) % q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "set<string>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "O(log n) or O(L log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool operator<(const T&a,const T&b)const;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include<string>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "GNU libstdc++",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "newfp -= Pow*(p[j]-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "newfp += Pow*(k-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "a = ((a - b) % m + m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long x = inf.readLong(1LL, 1000000000000000000LL, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long x = inf.readLong(1LL, 1000000000000000000LL, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long x = inf.readLong(1LL, 1000000000000000000LL, \"x\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring generate_number(int n, string type) {\n    string x;\n\n    if (type == \"random\") {\n        x.resize(n);\n        x[0] = '1' + rnd.next(9); // First digit from '1' to '9'\n        for (int i = 1; i < n; i++) {\n            x[i] = '0' + rnd.next(10); // '0' to '9'\n        }\n    }\n    else if (type == \"all9\") {\n        x = string(n, '9');\n    }\n    else if (type == \"all5\") {\n        x = string(n, '5');\n    }\n    else if (type == \"all4\") {\n        x = string(n, '4');\n    }\n    else if (type == \"leading9\") {\n        x.resize(n);\n        x[0] = '9';\n        for (int i = 1; i < n; i++) {\n            x[i] = '0' + rnd.next(10); // Digit from '0' to '9'\n        }\n    }\n    else if (type == \"alternating45\") {\n        x.resize(n);\n        for (int i = 0; i < n; i++) {\n            x[i] = (i % 2 == 0) ? '4' : '5';\n        }\n    }\n    else if (type == \"alternating49\") {\n        x.resize(n);\n        for (int i = 0; i < n; i++) {\n            x[i] = (i % 2 == 0) ? '4' : '9';\n        }\n    }\n    else if (type == \"max\") {\n        x = string(18, '9'); // x = 10^18 - 1\n    }\n    else if (type == \"min\") {\n        x = \"1\";\n    }\n    else {\n        // Default to random\n        x.resize(n);\n        x[0] = '1' + rnd.next(9); // First digit non-zero\n        for (int i = 1; i < n; i++) {\n            x[i] = '0' + rnd.next(10);\n        }\n    }\n\n    // Truncate x if longer than 18 digits\n    if (x.size() > 18) {\n        x = x.substr(0, 18);\n    }\n    // Ensure x is not empty\n    if (x.empty()) {\n        x = \"1\";\n    }\n\n    return x;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string x = generate_number(n, type);\n\n    cout << x << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring generate_number(int n, string type) {\n    string x;\n\n    if (type == \"random\") {\n        x.resize(n);\n        x[0] = '1' + rnd.next(9); // First digit from '1' to '9'\n        for (int i = 1; i < n; i++) {\n            x[i] = '0' + rnd.next(10); // '0' to '9'\n        }\n    }\n    else if (type == \"all9\") {\n        x = string(n, '9');\n    }\n    else if (type == \"all5\") {\n        x = string(n, '5');\n    }\n    else if (type == \"all4\") {\n        x = string(n, '4');\n    }\n    else if (type == \"leading9\") {\n        x.resize(n);\n        x[0] = '9';\n        for (int i = 1; i < n; i++) {\n            x[i] = '0' + rnd.next(10); // Digit from '0' to '9'\n        }\n    }\n    else if (type == \"alternating45\") {\n        x.resize(n);\n        for (int i = 0; i < n; i++) {\n            x[i] = (i % 2 == 0) ? '4' : '5';\n        }\n    }\n    else if (type == \"alternating49\") {\n        x.resize(n);\n        for (int i = 0; i < n; i++) {\n            x[i] = (i % 2 == 0) ? '4' : '9';\n        }\n    }\n    else if (type == \"max\") {\n        x = string(18, '9'); // x = 10^18 - 1\n    }\n    else if (type == \"min\") {\n        x = \"1\";\n    }\n    else {\n        // Default to random\n        x.resize(n);\n        x[0] = '1' + rnd.next(9); // First digit non-zero\n        for (int i = 1; i < n; i++) {\n            x[i] = '0' + rnd.next(10);\n        }\n    }\n\n    // Truncate x if longer than 18 digits\n    if (x.size() > 18) {\n        x = x.substr(0, 18);\n    }\n    // Ensure x is not empty\n    if (x.empty()) {\n        x = \"1\";\n    }\n\n    return x;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string x = generate_number(n, type);\n\n    cout << x << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 1 -type random\n./gen -n 1 -type all9\n./gen -n 1 -type all5\n./gen -n 1 -type all4\n./gen -n 1 -type leading9\n./gen -n 1 -type alternating45\n./gen -n 1 -type alternating49\n\n./gen -n 2 -type random\n./gen -n 2 -type all9\n./gen -n 2 -type all5\n./gen -n 2 -type all4\n./gen -n 2 -type leading9\n./gen -n 2 -type alternating45\n./gen -n 2 -type alternating49\n\n./gen -n 5 -type random\n./gen -n 5 -type all9\n./gen -n 5 -type all5\n./gen -n 5 -type all4\n./gen -n 5 -type leading9\n./gen -n 5 -type alternating45\n./gen -n 5 -type alternating49\n\n./gen -n 10 -type random\n./gen -n 10 -type all9\n./gen -n 10 -type all5\n./gen -n 10 -type all4\n./gen -n 10 -type leading9\n./gen -n 10 -type alternating45\n./gen -n 10 -type alternating49\n\n./gen -n 18 -type max\n./gen -n 18 -type random\n./gen -n 18 -type all9\n./gen -n 18 -type all5\n./gen -n 18 -type all4\n./gen -n 18 -type leading9\n./gen -n 18 -type alternating45\n./gen -n 18 -type alternating49\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:41:59.249794",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "514/B",
      "title": "B. Han Solo and Lazer Gun",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, x0 и y0 (1 ≤ n ≤ 1000,  - 104 ≤ x0, y0 ≤ 104) — the number of stormtroopers on the battle field and the coordinates of your gun.Next n lines contain two integers each xi, yi ( - 104 ≤ xi, yi ≤ 104) — the coordinates of the stormtroopers on the battlefield. It is guaranteed that no stormtrooper stands at the same point with the gun. Multiple stormtroopers can stand at the same point.",
      "output_spec": "OutputPrint a single integer — the minimum number of shots Han Solo needs to destroy all the stormtroopers.",
      "sample_tests": "ExamplesInputCopy4 0 01 12 22 0-1 -1OutputCopy2InputCopy2 1 21 11 0OutputCopy1",
      "description": "B. Han Solo and Lazer Gun\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, x0 и y0 (1 ≤ n ≤ 1000,  - 104 ≤ x0, y0 ≤ 104) — the number of stormtroopers on the battle field and the coordinates of your gun.Next n lines contain two integers each xi, yi ( - 104 ≤ xi, yi ≤ 104) — the coordinates of the stormtroopers on the battlefield. It is guaranteed that no stormtrooper stands at the same point with the gun. Multiple stormtroopers can stand at the same point.\n\nOutputPrint a single integer — the minimum number of shots Han Solo needs to destroy all the stormtroopers.\n\nInputCopy4 0 01 12 22 0-1 -1OutputCopy2InputCopy2 1 21 11 0OutputCopy1\n\nInputCopy4 0 01 12 22 0-1 -1\n\nOutputCopy2\n\nInputCopy2 1 21 11 0\n\nOutputCopy1\n\nNoteExplanation to the first and second samples from the statement, respectively:",
      "solutions": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #291 (Div. 2). It'll be held on Saturday, February 14 at 19:30 MSK.Great thanks Maxim Akhmedov (Zlobober), Vasya Antoniuk (Antoniuk) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.Good luck everyone!UPD: Score distribution will be the next — 500-1000-2000-2000-2500.UPD: Editorial. Sorry for the delay)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16365",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 492
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces",
          "content": "514A - Chewbaсca and NumberAuthor: RebrykIt is obvious that all the digits, which are greater than 4, need to be inverted. The only exception is 9, if it's the first digit.Complexity: 514B - Han Solo and Lazer GunAuthor: AntoniukLet's run through every point, where the stormtroopers are situated. If in current point stormtroopers are still alive, let's make a shot and destroy every stormtrooper on the same line with gun and current point.Points (x1, y1), (x2, y2), (x3, y3) are on the same line, if (x2 - x1)(y3 - y1) = (x3 - x1)(y2 - y1).Complexity: 514C - Watto and MechanismAuthor: RebrykWhile adding a string to the set, let's count its polynomial hash and add it to an array. Then let's sort this array. Now, to know the query answer, let's try to change every symbol in the string and check with binary search if its hash can be found in the array (recounting hashes with complexity). If the hash is found in the array, the answer is \"YES\", otherwise \"NO\".Complexity: , where L is total length of all strings.514D - R2D2 and Droid ArmyAuthor: RebrykTo destroy all the droids on a segment of l to r, we need to make shots, where cnt[i][j] — number of j-type details in i-th droid. Let's support two pointers — on the beginning and on the end of the segment, which we want to destroy all the droids on. If we can destroy droids on current segment, let's increase right border of the segment, otherwise increase left border, updating the answer after every segment change. Let's use a queue in order to find the segment maximum effectively.Complexity: 514E - Darth Vader and TreeAuthor: AntoniukIt's easy to realize that , where dp[i] is number of vertices, which are situated on a distance i from the root, and cnt[j] is number of children, which are situated on a distance j. Answer .Let the dynamics conditionLet's build a transformation matrix of 101 × 101 sizeNow, to move to the next condition, we need to multiply A by B. So, if matrix C = A·Bx - 100, then the answer will be situated in the very right cell of this matrix. For x < 100 we'll find the answer using dynamics explained in the beginning.In order to find Bk let's use binary power.Complexity:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16398",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 514\\s*B"
          },
          "content_length": 2168
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 1",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 2",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 3",
          "code": "ax+by+c = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 4",
          "code": "gcd(a,b,c) = 1 and a > 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 5",
          "code": "n equation (a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 6",
          "code": "(a_i,b_i,c_i) == (a_j,b_j,c_j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 7",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 8",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 9",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 10",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 11",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 12",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 13",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 14",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 15",
          "code": "m string query",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 16",
          "code": "string x = s",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 17",
          "code": "set x[j] = {'a','b','c' \\ x[j] != s[j]}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 18",
          "code": "The total length of lines in the input doesn't exceed 6·10^5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 19",
          "code": "my standing not low",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 20",
          "code": "deque.back()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 21",
          "code": "deque.push_back(a[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 22",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 23",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 24",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 25",
          "code": "set <string> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 26",
          "code": "if (f.find(s) != f.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 27",
          "code": "map <string, bool> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 28",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 29",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "H = (H * p + s[i]) % q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "set<string>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "O(log n) or O(L log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool operator<(const T&a,const T&b)const;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include<string>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "GNU libstdc++",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "newfp -= Pow*(p[j]-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "newfp += Pow*(k-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "a = ((a - b) % m + m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x0 = inf.readInt(-10000, 10000, \"x0\");\n    inf.readSpace();\n    int y0 = inf.readInt(-10000, 10000, \"y0\");\n    inf.readEoln();\n    \n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n        ensuref(!(xi == x0 && yi == y0), \"Stormtrooper cannot stand at the same point as the gun\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x0 = inf.readInt(-10000, 10000, \"x0\");\n    inf.readSpace();\n    int y0 = inf.readInt(-10000, 10000, \"y0\");\n    inf.readEoln();\n    \n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n        ensuref(!(xi == x0 && yi == y0), \"Stormtrooper cannot stand at the same point as the gun\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int x0 = inf.readInt(-10000, 10000, \"x0\");\n    inf.readSpace();\n    int y0 = inf.readInt(-10000, 10000, \"y0\");\n    inf.readEoln();\n    \n    for(int i = 0; i < n; i++) {\n        int xi = inf.readInt(-10000, 10000, \"xi\");\n        inf.readSpace();\n        int yi = inf.readInt(-10000, 10000, \"yi\");\n        inf.readEoln();\n        ensuref(!(xi == x0 && yi == y0), \"Stormtrooper cannot stand at the same point as the gun\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int x0 = opt<int>(\"x0\", 0);\n    int y0 = opt<int>(\"y0\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > positions;\n\n    if (type == \"random\") {\n        // Generate random positions, avoiding (x0, y0)\n        for (int i = 0; i < n; ++i) {\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (xi == x0 && yi == y0);\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"same_line\") {\n        // All stormtroopers are on the same line through (x0, y0)\n        // Let's choose another point (x1, y1) different from (x0, y0)\n        int x1, y1;\n        do {\n            x1 = rnd.next(-10000, 10000);\n            y1 = rnd.next(-10000, 10000);\n        } while (x1 == x0 && y1 == y0);\n\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(-1000, 1000);\n            long long xi = x0 + (long long)(x1 - x0) * t;\n            long long yi = y0 + (long long)(y1 - y0) * t;\n            // Ensure xi, yi within [-1e4, 1e4]\n            xi = max(-10000LL, min(10000LL, xi));\n            yi = max(-10000LL, min(10000LL, yi));\n\n            // Avoid (x0, y0)\n            if (xi == x0 && yi == y0) {\n                if (xi != -10000)\n                    xi--;\n                else\n                    xi++;\n            }\n            positions.push_back(make_pair((int)xi, (int)yi));\n        }\n    } else if (type == \"vertical_line\") {\n        // xi = x0, yi ≠ y0\n        set<int> y_values;\n        y_values.insert(y0); // to avoid (x0, y0)\n        for (int i = 0; i < n; ++i) {\n            int yi;\n            do {\n                yi = rnd.next(-10000, 10000);\n            } while (y_values.count(yi));\n            y_values.insert(yi);\n            positions.push_back(make_pair(x0, yi));\n        }\n    } else if (type == \"horizontal_line\") {\n        // yi = y0, xi ≠ x0\n        set<int> x_values;\n        x_values.insert(x0); // to avoid (x0, y0)\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-10000, 10000);\n            } while (x_values.count(xi));\n            x_values.insert(xi);\n            positions.push_back(make_pair(xi, y0));\n        }\n    } else if (type == \"max_shots\") {\n        // All stormtroopers are at unique directions from (x0, y0)\n        // For each stormtrooper, need to make (yi - y0)/(xi - x0) unique\n        set<long double> slopes;\n        for (int i = 0; i < n; ++i) {\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n                // Avoid (x0, y0)\n                if (xi == x0 && yi == y0)\n                    continue;\n                long double slope;\n                if (xi == x0)\n                    slope = 1e9 + yi; // Use yi to make it unique\n                else\n                    slope = (long double)(yi - y0) / (xi - x0);\n                if (slopes.count(slope)) {\n                    continue;\n                }\n                slopes.insert(slope);\n                break;\n            } while (true);\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"same_point\") {\n        // All stormtroopers at the same point (xi, yi), not equal to (x0, y0)\n        int xi, yi;\n        do {\n            xi = rnd.next(-10000, 10000);\n            yi = rnd.next(-10000, 10000);\n        } while (xi == x0 && yi == y0);\n        positions = vector<pair<int, int> >(n, make_pair(xi, yi));\n    } else if (type == \"extreme_coordinates\") {\n        // Generate positions at the extremes\n        for (int i = 0; i < n; ++i) {\n            int xi = (i % 2 == 0) ? -10000 : 10000;\n            int yi = (i % 3 == 0) ? -10000 : 10000;\n            if (xi == x0 && yi == y0) {\n                xi = xi == 10000 ? -10000 : 10000;\n            }\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"precision\") {\n        // Generate stormtrooper positions leading to slopes with large numerators and denominators\n        for (int i = 0; i < n; ++i) {\n            int dx = rnd.next(1, 10000);\n            int dy = rnd.next(1, 10000);\n            int xi = x0 + dx * 1000;\n            int yi = y0 + dy * 5000;\n            if (xi > 10000) xi -= 20000;\n            if (xi < -10000) xi += 20000;\n            if (yi > 10000) yi -= 20000;\n            if (yi < -10000) yi += 20000;\n            // Avoid (x0, y0)\n            if (xi == x0 && yi == y0) {\n                xi = xi == 10000 ? -10000 : 10000;\n            }\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else {\n        // Default to random positions\n        for (int i = 0; i < n; ++i) {\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (xi == x0 && yi == y0);\n            positions.push_back(make_pair(xi, yi));\n        }\n    }\n\n    // Now, output the test case\n    printf(\"%d %d %d\\n\", n, x0, y0);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", positions[i].first, positions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int x0 = opt<int>(\"x0\", 0);\n    int y0 = opt<int>(\"y0\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int> > positions;\n\n    if (type == \"random\") {\n        // Generate random positions, avoiding (x0, y0)\n        for (int i = 0; i < n; ++i) {\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (xi == x0 && yi == y0);\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"same_line\") {\n        // All stormtroopers are on the same line through (x0, y0)\n        // Let's choose another point (x1, y1) different from (x0, y0)\n        int x1, y1;\n        do {\n            x1 = rnd.next(-10000, 10000);\n            y1 = rnd.next(-10000, 10000);\n        } while (x1 == x0 && y1 == y0);\n\n        for (int i = 0; i < n; ++i) {\n            int t = rnd.next(-1000, 1000);\n            long long xi = x0 + (long long)(x1 - x0) * t;\n            long long yi = y0 + (long long)(y1 - y0) * t;\n            // Ensure xi, yi within [-1e4, 1e4]\n            xi = max(-10000LL, min(10000LL, xi));\n            yi = max(-10000LL, min(10000LL, yi));\n\n            // Avoid (x0, y0)\n            if (xi == x0 && yi == y0) {\n                if (xi != -10000)\n                    xi--;\n                else\n                    xi++;\n            }\n            positions.push_back(make_pair((int)xi, (int)yi));\n        }\n    } else if (type == \"vertical_line\") {\n        // xi = x0, yi ≠ y0\n        set<int> y_values;\n        y_values.insert(y0); // to avoid (x0, y0)\n        for (int i = 0; i < n; ++i) {\n            int yi;\n            do {\n                yi = rnd.next(-10000, 10000);\n            } while (y_values.count(yi));\n            y_values.insert(yi);\n            positions.push_back(make_pair(x0, yi));\n        }\n    } else if (type == \"horizontal_line\") {\n        // yi = y0, xi ≠ x0\n        set<int> x_values;\n        x_values.insert(x0); // to avoid (x0, y0)\n        for (int i = 0; i < n; ++i) {\n            int xi;\n            do {\n                xi = rnd.next(-10000, 10000);\n            } while (x_values.count(xi));\n            x_values.insert(xi);\n            positions.push_back(make_pair(xi, y0));\n        }\n    } else if (type == \"max_shots\") {\n        // All stormtroopers are at unique directions from (x0, y0)\n        // For each stormtrooper, need to make (yi - y0)/(xi - x0) unique\n        set<long double> slopes;\n        for (int i = 0; i < n; ++i) {\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n                // Avoid (x0, y0)\n                if (xi == x0 && yi == y0)\n                    continue;\n                long double slope;\n                if (xi == x0)\n                    slope = 1e9 + yi; // Use yi to make it unique\n                else\n                    slope = (long double)(yi - y0) / (xi - x0);\n                if (slopes.count(slope)) {\n                    continue;\n                }\n                slopes.insert(slope);\n                break;\n            } while (true);\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"same_point\") {\n        // All stormtroopers at the same point (xi, yi), not equal to (x0, y0)\n        int xi, yi;\n        do {\n            xi = rnd.next(-10000, 10000);\n            yi = rnd.next(-10000, 10000);\n        } while (xi == x0 && yi == y0);\n        positions = vector<pair<int, int> >(n, make_pair(xi, yi));\n    } else if (type == \"extreme_coordinates\") {\n        // Generate positions at the extremes\n        for (int i = 0; i < n; ++i) {\n            int xi = (i % 2 == 0) ? -10000 : 10000;\n            int yi = (i % 3 == 0) ? -10000 : 10000;\n            if (xi == x0 && yi == y0) {\n                xi = xi == 10000 ? -10000 : 10000;\n            }\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else if (type == \"precision\") {\n        // Generate stormtrooper positions leading to slopes with large numerators and denominators\n        for (int i = 0; i < n; ++i) {\n            int dx = rnd.next(1, 10000);\n            int dy = rnd.next(1, 10000);\n            int xi = x0 + dx * 1000;\n            int yi = y0 + dy * 5000;\n            if (xi > 10000) xi -= 20000;\n            if (xi < -10000) xi += 20000;\n            if (yi > 10000) yi -= 20000;\n            if (yi < -10000) yi += 20000;\n            // Avoid (x0, y0)\n            if (xi == x0 && yi == y0) {\n                xi = xi == 10000 ? -10000 : 10000;\n            }\n            positions.push_back(make_pair(xi, yi));\n        }\n    } else {\n        // Default to random positions\n        for (int i = 0; i < n; ++i) {\n            int xi, yi;\n            do {\n                xi = rnd.next(-10000, 10000);\n                yi = rnd.next(-10000, 10000);\n            } while (xi == x0 && yi == y0);\n            positions.push_back(make_pair(xi, yi));\n        }\n    }\n\n    // Now, output the test case\n    printf(\"%d %d %d\\n\", n, x0, y0);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", positions[i].first, positions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, random positions\n./gen -n 5 -x0 0 -y0 0 -type random\n./gen -n 10 -x0 100 -y0 -100 -type random\n\n# Medium n, random positions\n./gen -n 100 -x0 -5000 -y0 5000 -type random\n\n# Maximum n, random positions\n./gen -n 1000 -x0 9999 -y0 -9999 -type random\n\n# Small n, same line\n./gen -n 5 -x0 0 -y0 0 -type same_line\n./gen -n 10 -x0 -1000 -y0 1000 -type same_line\n\n# Medium n, same line\n./gen -n 500 -x0 555 -y0 555 -type same_line\n\n# Maximum n, same line\n./gen -n 1000 -x0 -10000 -y0 -10000 -type same_line\n\n# Small n, vertical line\n./gen -n 10 -x0 0 -y0 0 -type vertical_line\n\n# Medium n, vertical line\n./gen -n 500 -x0 2000 -y0 -2000 -type vertical_line\n\n# Maximum n, vertical line\n./gen -n 1000 -x0 -9999 -y0 9999 -type vertical_line\n\n# Small n, horizontal line\n./gen -n 10 -x0 0 -y0 0 -type horizontal_line\n\n# Medium n, horizontal line\n./gen -n 500 -x0 -3000 -y0 3000 -type horizontal_line\n\n# Maximum n, horizontal line\n./gen -n 1000 -x0 8888 -y0 -8888 -type horizontal_line\n\n# Small n, max shots (each stormtrooper requires a separate shot)\n./gen -n 10 -x0 0 -y0 0 -type max_shots\n\n# Medium n, max shots\n./gen -n 500 -x0 0 -y0 0 -type max_shots\n\n# Maximum n, max shots\n./gen -n 1000 -x0 -1 -y0 -1 -type max_shots\n\n# Small n, same point\n./gen -n 5 -x0 0 -y0 0 -type same_point\n\n# Medium n, same point\n./gen -n 500 -x0 -5000 -y0 5000 -type same_point\n\n# Maximum n, same point\n./gen -n 1000 -x0 9999 -y0 -9999 -type same_point\n\n# Small n, extreme coordinates\n./gen -n 10 -x0 0 -y0 0 -type extreme_coordinates\n\n# Medium n, extreme coordinates\n./gen -n 500 -x0 -10000 -y0 10000 -type extreme_coordinates\n\n# Maximum n, extreme coordinates\n./gen -n 1000 -x0 10000 -y0 -10000 -type extreme_coordinates\n\n# Small n, precision\n./gen -n 10 -x0 0 -y0 0 -type precision\n\n# Medium n, precision\n./gen -n 500 -x0 5000 -y0 -5000 -type precision\n\n# Maximum n, precision\n./gen -n 1000 -x0 -9999 -y0 9999 -type precision\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:01.594736",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "514/C",
      "title": "C. Watto and Mechanism",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two non-negative numbers n and m (0 ≤ n ≤ 3·105, 0 ≤ m ≤ 3·105) — the number of the initial strings and the number of queries, respectively.Next follow n non-empty strings that are uploaded to the memory of the mechanism.Next follow m non-empty strings that are the queries to the mechanism.The total length of lines in the input doesn't exceed 6·105. Each line consists only of letters 'a', 'b', 'c'.",
      "output_spec": "OutputFor each query print on a single line \"YES\" (without the quotes), if the memory of the mechanism contains the required string, otherwise print \"NO\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy2 3aaaaaacacacaaabaaccacacccaaacOutputCopyYESNONO",
      "description": "C. Watto and Mechanism\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two non-negative numbers n and m (0 ≤ n ≤ 3·105, 0 ≤ m ≤ 3·105) — the number of the initial strings and the number of queries, respectively.Next follow n non-empty strings that are uploaded to the memory of the mechanism.Next follow m non-empty strings that are the queries to the mechanism.The total length of lines in the input doesn't exceed 6·105. Each line consists only of letters 'a', 'b', 'c'.\n\nOutputFor each query print on a single line \"YES\" (without the quotes), if the memory of the mechanism contains the required string, otherwise print \"NO\" (without the quotes).\n\nInputCopy2 3aaaaaacacacaaabaaccacacccaaacOutputCopyYESNONO\n\nInputCopy2 3aaaaaacacacaaabaaccacacccaaac\n\nOutputCopyYESNONO",
      "solutions": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #291 (Div. 2). It'll be held on Saturday, February 14 at 19:30 MSK.Great thanks Maxim Akhmedov (Zlobober), Vasya Antoniuk (Antoniuk) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.Good luck everyone!UPD: Score distribution will be the next — 500-1000-2000-2000-2500.UPD: Editorial. Sorry for the delay)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16365",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 492
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces",
          "content": "514A - Chewbaсca and NumberAuthor: RebrykIt is obvious that all the digits, which are greater than 4, need to be inverted. The only exception is 9, if it's the first digit.Complexity: 514B - Han Solo and Lazer GunAuthor: AntoniukLet's run through every point, where the stormtroopers are situated. If in current point stormtroopers are still alive, let's make a shot and destroy every stormtrooper on the same line with gun and current point.Points (x1, y1), (x2, y2), (x3, y3) are on the same line, if (x2 - x1)(y3 - y1) = (x3 - x1)(y2 - y1).Complexity: 514C - Watto and MechanismAuthor: RebrykWhile adding a string to the set, let's count its polynomial hash and add it to an array. Then let's sort this array. Now, to know the query answer, let's try to change every symbol in the string and check with binary search if its hash can be found in the array (recounting hashes with complexity). If the hash is found in the array, the answer is \"YES\", otherwise \"NO\".Complexity: , where L is total length of all strings.514D - R2D2 and Droid ArmyAuthor: RebrykTo destroy all the droids on a segment of l to r, we need to make shots, where cnt[i][j] — number of j-type details in i-th droid. Let's support two pointers — on the beginning and on the end of the segment, which we want to destroy all the droids on. If we can destroy droids on current segment, let's increase right border of the segment, otherwise increase left border, updating the answer after every segment change. Let's use a queue in order to find the segment maximum effectively.Complexity: 514E - Darth Vader and TreeAuthor: AntoniukIt's easy to realize that , where dp[i] is number of vertices, which are situated on a distance i from the root, and cnt[j] is number of children, which are situated on a distance j. Answer .Let the dynamics conditionLet's build a transformation matrix of 101 × 101 sizeNow, to move to the next condition, we need to multiply A by B. So, if matrix C = A·Bx - 100, then the answer will be situated in the very right cell of this matrix. For x < 100 we'll find the answer using dynamics explained in the beginning.In order to find Bk let's use binary power.Complexity:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16398",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 514\\s*C"
          },
          "content_length": 2168
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 1",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 2",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 3",
          "code": "ax+by+c = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 4",
          "code": "gcd(a,b,c) = 1 and a > 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 5",
          "code": "n equation (a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 6",
          "code": "(a_i,b_i,c_i) == (a_j,b_j,c_j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 7",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 8",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 9",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 10",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 11",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 12",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 13",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 14",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 15",
          "code": "m string query",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 16",
          "code": "string x = s",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 17",
          "code": "set x[j] = {'a','b','c' \\ x[j] != s[j]}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 18",
          "code": "The total length of lines in the input doesn't exceed 6·10^5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 19",
          "code": "my standing not low",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 20",
          "code": "deque.back()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 21",
          "code": "deque.push_back(a[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 22",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 23",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 24",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 25",
          "code": "set <string> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 26",
          "code": "if (f.find(s) != f.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 27",
          "code": "map <string, bool> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 28",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 29",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "H = (H * p + s[i]) % q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "set<string>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "O(log n) or O(L log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool operator<(const T&a,const T&b)const;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include<string>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "GNU libstdc++",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "newfp -= Pow*(p[j]-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "newfp += Pow*(k-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "a = ((a - b) % m + m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int totalLength = 0;\n\n    string firstLine = inf.readLine();\n    totalLength += firstLine.length();\n\n    int n, m;\n    istringstream iss(firstLine);\n    if (!(iss >> n >> m))\n        quitf(_fail, \"First line does not contain two integers\");\n\n    string extra;\n    if (iss >> extra)\n        quitf(_fail, \"First line contains extra data\");\n\n    ensuref(0 <= n && n <= 300000, \"n is out of bounds\");\n    ensuref(0 <= m && m <= 300000, \"m is out of bounds\");\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[abc]+\");\n        totalLength += s.length();\n    }\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine(\"[abc]+\");\n        totalLength += s.length();\n    }\n\n    ensuref(totalLength <= 600000, \"Total length of input lines exceeds 600000\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int totalLength = 0;\n\n    string firstLine = inf.readLine();\n    totalLength += firstLine.length();\n\n    int n, m;\n    istringstream iss(firstLine);\n    if (!(iss >> n >> m))\n        quitf(_fail, \"First line does not contain two integers\");\n\n    string extra;\n    if (iss >> extra)\n        quitf(_fail, \"First line contains extra data\");\n\n    ensuref(0 <= n && n <= 300000, \"n is out of bounds\");\n    ensuref(0 <= m && m <= 300000, \"m is out of bounds\");\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[abc]+\");\n        totalLength += s.length();\n    }\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine(\"[abc]+\");\n        totalLength += s.length();\n    }\n\n    ensuref(totalLength <= 600000, \"Total length of input lines exceeds 600000\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int totalLength = 0;\n\n    string firstLine = inf.readLine();\n    totalLength += firstLine.length();\n\n    int n, m;\n    istringstream iss(firstLine);\n    if (!(iss >> n >> m))\n        quitf(_fail, \"First line does not contain two integers\");\n\n    string extra;\n    if (iss >> extra)\n        quitf(_fail, \"First line contains extra data\");\n\n    ensuref(0 <= n && n <= 300000, \"n is out of bounds\");\n    ensuref(0 <= m && m <= 300000, \"m is out of bounds\");\n\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine(\"[abc]+\");\n        totalLength += s.length();\n    }\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine(\"[abc]+\");\n        totalLength += s.length();\n    }\n\n    ensuref(totalLength <= 600000, \"Total length of input lines exceeds 600000\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    int m = opt<int>(\"m\", 0);\n    int minlen = opt<int>(\"minlen\", 1);\n    int maxlen = opt<int>(\"maxlen\", 1000);\n    int maxTotalLength = opt<int>(\"maxTotalLength\", 600000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    int totalStrings = n + m;\n\n    int len_per_string;\n    \n    if (totalStrings == 0) len_per_string = 0;\n    else len_per_string = max(minlen, min(maxlen, maxTotalLength / totalStrings));\n\n    vector<string> initial_strings;\n    vector<string> query_strings;\n\n    if (type == \"random\") {\n        // Generate random strings of length len_per_string\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    } else if (type == \"max_length\") {\n        len_per_string = maxlen;\n        // Adjust lengths if necessary\n        if (len_per_string * totalStrings > maxTotalLength) {\n            len_per_string = maxTotalLength / totalStrings;\n        }\n        // Generate strings of length len_per_string\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    } else if (type == \"min_length\") {\n        len_per_string = minlen;\n        // Generate strings of length len_per_string\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    } else if (type == \"same_strings\") {\n        len_per_string = max(minlen, min(maxlen, maxTotalLength / totalStrings));\n        string s;\n        for (int j = 0; j < len_per_string; ++j) {\n            s += (char)('a' + rnd.next(3));\n        }\n        for (int i = 0; i < n; ++i) {\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            query_strings.push_back(s);\n        }\n    } else if (type == \"strings_differ_by_one\") {\n        // For this type, we can generate initial strings, and make queries differ by one character.\n        len_per_string = max(minlen, min(maxlen, maxTotalLength / totalStrings));\n        string base_string;\n        for (int j = 0; j < len_per_string; ++j) {\n            base_string += 'a';\n        }\n        for (int i = 0; i < n; ++i) {\n            string s = base_string;\n            int pos = rnd.next(len_per_string);\n            s[pos] = (char)('a' + (rnd.next(1, 3) % 3));\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            // Each query will differ from base string by one character\n            string s = base_string;\n            int pos = rnd.next(len_per_string);\n            s[pos] = (char)('a' + (s[pos] - 'a' + 1) % 3);\n            query_strings.push_back(s);\n        }\n    } else if (type == \"varying_lengths\") {\n        // Generate strings with varying lengths\n        int total_length = 0;\n        for (int i = 0; i < n; ++i) {\n            int remaining_strings = n + m - (i);\n            int remaining_length = maxTotalLength - total_length;\n            int max_length = min(maxlen, remaining_length - minlen * (remaining_strings - 1));\n            if (max_length < minlen) max_length = minlen;\n            int len = rnd.next(minlen, max_length);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n            total_length += len;\n        }\n        for (int i = 0; i < m; ++i) {\n            int remaining_strings = m - i;\n            int remaining_length = maxTotalLength - total_length;\n            int max_length = min(maxlen, remaining_length - minlen * (remaining_strings - 1));\n            if (max_length < minlen) max_length = minlen;\n            int len = rnd.next(minlen, max_length);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n            total_length += len;\n        }\n    } else {\n        // default to 'random'\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output initial strings\n    for (const string& s : initial_strings) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    // Output query strings\n    for (const string& s : query_strings) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    int m = opt<int>(\"m\", 0);\n    int minlen = opt<int>(\"minlen\", 1);\n    int maxlen = opt<int>(\"maxlen\", 1000);\n    int maxTotalLength = opt<int>(\"maxTotalLength\", 600000);\n    string type = opt<string>(\"type\", \"random\");\n    \n    int totalStrings = n + m;\n\n    int len_per_string;\n    \n    if (totalStrings == 0) len_per_string = 0;\n    else len_per_string = max(minlen, min(maxlen, maxTotalLength / totalStrings));\n\n    vector<string> initial_strings;\n    vector<string> query_strings;\n\n    if (type == \"random\") {\n        // Generate random strings of length len_per_string\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    } else if (type == \"max_length\") {\n        len_per_string = maxlen;\n        // Adjust lengths if necessary\n        if (len_per_string * totalStrings > maxTotalLength) {\n            len_per_string = maxTotalLength / totalStrings;\n        }\n        // Generate strings of length len_per_string\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    } else if (type == \"min_length\") {\n        len_per_string = minlen;\n        // Generate strings of length len_per_string\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    } else if (type == \"same_strings\") {\n        len_per_string = max(minlen, min(maxlen, maxTotalLength / totalStrings));\n        string s;\n        for (int j = 0; j < len_per_string; ++j) {\n            s += (char)('a' + rnd.next(3));\n        }\n        for (int i = 0; i < n; ++i) {\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            query_strings.push_back(s);\n        }\n    } else if (type == \"strings_differ_by_one\") {\n        // For this type, we can generate initial strings, and make queries differ by one character.\n        len_per_string = max(minlen, min(maxlen, maxTotalLength / totalStrings));\n        string base_string;\n        for (int j = 0; j < len_per_string; ++j) {\n            base_string += 'a';\n        }\n        for (int i = 0; i < n; ++i) {\n            string s = base_string;\n            int pos = rnd.next(len_per_string);\n            s[pos] = (char)('a' + (rnd.next(1, 3) % 3));\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            // Each query will differ from base string by one character\n            string s = base_string;\n            int pos = rnd.next(len_per_string);\n            s[pos] = (char)('a' + (s[pos] - 'a' + 1) % 3);\n            query_strings.push_back(s);\n        }\n    } else if (type == \"varying_lengths\") {\n        // Generate strings with varying lengths\n        int total_length = 0;\n        for (int i = 0; i < n; ++i) {\n            int remaining_strings = n + m - (i);\n            int remaining_length = maxTotalLength - total_length;\n            int max_length = min(maxlen, remaining_length - minlen * (remaining_strings - 1));\n            if (max_length < minlen) max_length = minlen;\n            int len = rnd.next(minlen, max_length);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n            total_length += len;\n        }\n        for (int i = 0; i < m; ++i) {\n            int remaining_strings = m - i;\n            int remaining_length = maxTotalLength - total_length;\n            int max_length = min(maxlen, remaining_length - minlen * (remaining_strings - 1));\n            if (max_length < minlen) max_length = minlen;\n            int len = rnd.next(minlen, max_length);\n            string s;\n            for (int j = 0; j < len; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n            total_length += len;\n        }\n    } else {\n        // default to 'random'\n        for (int i = 0; i < n; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            initial_strings.push_back(s);\n        }\n        for (int i = 0; i < m; ++i) {\n            string s;\n            for (int j = 0; j < len_per_string; ++j) {\n                s += (char)('a' + rnd.next(3));\n            }\n            query_strings.push_back(s);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output initial strings\n    for (const string& s : initial_strings) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    // Output query strings\n    for (const string& s : query_strings) {\n        printf(\"%s\\n\", s.c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 0 -m 0 -type random\n./gen -n 1 -m 1 -type random\n./gen -n 1 -m 0 -type min_length\n./gen -n 0 -m 1 -type min_length\n./gen -n 5 -m 5 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 1000 -m 1000 -type random\n./gen -n 300000 -m 300000 -type min_length\n./gen -n 300000 -m 300000 -type max_length -maxlen 1\n./gen -n 300000 -m 300000 -type max_length -maxlen 2\n./gen -n 10000 -m 10000 -type strings_differ_by_one\n./gen -n 10000 -m 10000 -type same_strings\n./gen -n 0 -m 300000 -type random\n./gen -n 300000 -m 0 -type random\n./gen -n 100000 -m 200000 -type varying_lengths\n./gen -n 0 -m 0 -type random\n./gen -n 3 -m 5 -type varying_lengths -maxlen 1000\n./gen -n 1000 -m 1000 -type varying_lengths -minlen 1 -maxlen 10000\n./gen -n 100000 -m 200000 -type random -maxTotalLength 600000\n./gen -n 200000 -m 100000 -type random -maxTotalLength 600000\n./gen -n 300000 -m 300000 -type random -maxlen 2\n./gen -n 300000 -m 300000 -type strings_differ_by_one -minlen 2 -maxlen 2\n./gen -n 3 -m 3 -type same_strings\n./gen -n 10 -m 10 -type same_strings\n./gen -n 1 -m 1 -type same_strings\n./gen -n 3 -m 3 -type random -minlen 1 -maxlen 1\n./gen -n 3 -m 3 -type random -minlen 1 -maxlen 3\n./gen -n 3 -m 3 -type random -minlen 3 -maxlen 3\n./gen -n 3 -m 3 -type random -minlen 4 -maxlen 5\n./gen -n 300000 -m 300000 -type varying_lengths\n./gen -n 300000 -m 0 -type varying_lengths\n./gen -n 0 -m 300000 -type varying_lengths\n./gen -n 150000 -m 150000 -type varying_lengths\n./gen -n 200000 -m 100000 -type varying_lengths\n./gen -n 100000 -m 200000 -type varying_lengths\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:03.569211",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "514/D",
      "title": "D. R2D2 and Droid Army",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m, k (1 ≤ n ≤ 105, 1 ≤ m ≤ 5, 0 ≤ k ≤ 109) — the number of droids, the number of detail types and the number of available shots, respectively.Next n lines follow describing the droids. Each line contains m integers a1, a2, ..., am (0 ≤ ai ≤ 108), where ai is the number of details of the i-th type for the respective robot.",
      "output_spec": "OutputPrint m space-separated integers, where the i-th number is the number of shots from the weapon of the i-th type that the robot should make to destroy the subsequence of consecutive droids of the maximum length.If there are multiple optimal solutions, print any of them. It is not necessary to make exactly k shots, the number of shots can be less.",
      "sample_tests": "ExamplesInputCopy5 2 44 01 22 10 21 3OutputCopy2 2InputCopy3 2 41 21 32 2OutputCopy1 3",
      "description": "D. R2D2 and Droid Army\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m, k (1 ≤ n ≤ 105, 1 ≤ m ≤ 5, 0 ≤ k ≤ 109) — the number of droids, the number of detail types and the number of available shots, respectively.Next n lines follow describing the droids. Each line contains m integers a1, a2, ..., am (0 ≤ ai ≤ 108), where ai is the number of details of the i-th type for the respective robot.\n\nOutputPrint m space-separated integers, where the i-th number is the number of shots from the weapon of the i-th type that the robot should make to destroy the subsequence of consecutive droids of the maximum length.If there are multiple optimal solutions, print any of them. It is not necessary to make exactly k shots, the number of shots can be less.\n\nInputCopy5 2 44 01 22 10 21 3OutputCopy2 2InputCopy3 2 41 21 32 2OutputCopy1 3\n\nInputCopy5 2 44 01 22 10 21 3\n\nOutputCopy2 2\n\nInputCopy3 2 41 21 32 2\n\nOutputCopy1 3\n\nNoteIn the first test the second, third and fourth droids will be destroyed. In the second test the first and second droids will be destroyed.",
      "solutions": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #291 (Div. 2). It'll be held on Saturday, February 14 at 19:30 MSK.Great thanks Maxim Akhmedov (Zlobober), Vasya Antoniuk (Antoniuk) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform.Good luck everyone!UPD: Score distribution will be the next — 500-1000-2000-2000-2500.UPD: Editorial. Sorry for the delay)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16365",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 492
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces",
          "content": "514A - Chewbaсca and NumberAuthor: RebrykIt is obvious that all the digits, which are greater than 4, need to be inverted. The only exception is 9, if it's the first digit.Complexity: 514B - Han Solo and Lazer GunAuthor: AntoniukLet's run through every point, where the stormtroopers are situated. If in current point stormtroopers are still alive, let's make a shot and destroy every stormtrooper on the same line with gun and current point.Points (x1, y1), (x2, y2), (x3, y3) are on the same line, if (x2 - x1)(y3 - y1) = (x3 - x1)(y2 - y1).Complexity: 514C - Watto and MechanismAuthor: RebrykWhile adding a string to the set, let's count its polynomial hash and add it to an array. Then let's sort this array. Now, to know the query answer, let's try to change every symbol in the string and check with binary search if its hash can be found in the array (recounting hashes with complexity). If the hash is found in the array, the answer is \"YES\", otherwise \"NO\".Complexity: , where L is total length of all strings.514D - R2D2 and Droid ArmyAuthor: RebrykTo destroy all the droids on a segment of l to r, we need to make shots, where cnt[i][j] — number of j-type details in i-th droid. Let's support two pointers — on the beginning and on the end of the segment, which we want to destroy all the droids on. If we can destroy droids on current segment, let's increase right border of the segment, otherwise increase left border, updating the answer after every segment change. Let's use a queue in order to find the segment maximum effectively.Complexity: 514E - Darth Vader and TreeAuthor: AntoniukIt's easy to realize that , where dp[i] is number of vertices, which are situated on a distance i from the root, and cnt[j] is number of children, which are situated on a distance j. Answer .Let the dynamics conditionLet's build a transformation matrix of 101 × 101 sizeNow, to move to the next condition, we need to multiply A by B. So, if matrix C = A·Bx - 100, then the answer will be situated in the very right cell of this matrix. For x < 100 we'll find the answer using dynamics explained in the beginning.In order to find Bk let's use binary power.Complexity:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16398",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 514\\s*D"
          },
          "content_length": 2168
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 1",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 2",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 3",
          "code": "ax+by+c = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 4",
          "code": "gcd(a,b,c) = 1 and a > 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 5",
          "code": "n equation (a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 6",
          "code": "(a_i,b_i,c_i) == (a_j,b_j,c_j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 7",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 8",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 9",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 10",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 11",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 12",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 13",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 14",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 15",
          "code": "m string query",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 16",
          "code": "string x = s",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 17",
          "code": "set x[j] = {'a','b','c' \\ x[j] != s[j]}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 18",
          "code": "The total length of lines in the input doesn't exceed 6·10^5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 19",
          "code": "my standing not low",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 20",
          "code": "deque.back()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 21",
          "code": "deque.push_back(a[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 22",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 23",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 24",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 25",
          "code": "set <string> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 26",
          "code": "if (f.find(s) != f.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 27",
          "code": "map <string, bool> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 28",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 29",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "H = (H * p + s[i]) % q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "set<string>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "O(log n) or O(L log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "bool operator<(const T&a,const T&b)const;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "#include<string>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "GNU libstdc++",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "newfp -= Pow*(p[j]-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 8",
          "code": "newfp += Pow*(k-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 9",
          "code": "a = ((a - b) % m + m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 10",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) Editorial - Codeforces - Code 11",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> ai = inf.readInts(m, 0, 100000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> ai = inf.readInts(m, 0, 100000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 5, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(0, 1000000000, \"k\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        vector<int> ai = inf.readInts(m, 0, 100000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m;\nlong long k;\nvector<vector<int> > Ai; // Ai[i][j]: number of details of type j in droid i\n\n// Reads the answer from the given stream, validates it, and returns the shots per weapon.\n// Also ensures that the total number of shots does not exceed k.\nvector<long long> readAns(InStream& stream) {\n    vector<long long> shots(m);\n\n    // Read m integers representing the number of shots per weapon\n    for (int i = 0; i < m; i++) {\n        shots[i] = stream.readLong(0, k, format(\"shots[%d]\", i + 1).c_str());\n    }\n\n    long long total_shots = 0;\n    for (int i = 0; i < m; i++) {\n        total_shots += shots[i];\n    }\n\n    if (total_shots > k) {\n        stream.quitf(_wa, \"Total number of shots %lld exceeds k = %lld\", total_shots, k);\n    }\n\n    return shots;\n}\n\n// Computes the maximum length of consecutive destroyed droids given the shots per weapon\nint computeMaxLength(const vector<long long>& shots) {\n    int max_length = 0;\n    int current_length = 0;\n\n    for (int i = 0; i < n; i++) {\n        bool destroyed = true;\n        for (int j = 0; j < m; j++) {\n            if (Ai[i][j] > shots[j]) {\n                destroyed = false;\n                break;\n            }\n        }\n        if (destroyed) {\n            current_length++;\n            max_length = max(max_length, current_length);\n        } else {\n            current_length = 0;\n        }\n    }\n    return max_length;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from inf\n    n = inf.readInt();\n    m = inf.readInt();\n    k = inf.readLong();\n    Ai.resize(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            Ai[i][j] = inf.readInt(0, 100000000);\n        }\n    }\n\n    // Read jury's answer and compute maximum possible length\n    vector<long long> shots_jury = readAns(ans);\n    int max_length_jury = computeMaxLength(shots_jury);\n\n    // Read participant's answer and compute their maximum length\n    vector<long long> shots_participant = readAns(ouf);\n    int max_length_participant = computeMaxLength(shots_participant);\n\n    if (max_length_participant == max_length_jury) {\n        quitf(_ok, \"Correct answer with maximum length %d\", max_length_participant);\n    } else if (max_length_participant < max_length_jury) {\n        quitf(_wa, \"Participant's maximum length %d is less than expected %d\", max_length_participant, max_length_jury);\n    } else {\n        quitf(_fail, \"Participant's maximum length %d exceeds jury's maximum length %d\", max_length_participant, max_length_jury);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n\n    int m = opt<int>(\"m\", 1);\n    if (m < 1 || m > 5) {\n        fprintf(stderr, \"Invalid m: %d\\n\", m);\n        exit(1);\n    }\n\n    long long k = opt<long long>(\"k\", 1000000000);\n    if (k < 0 || k > 1000000000) {\n        fprintf(stderr, \"Invalid k: %lld\\n\", k);\n        exit(1);\n    }\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 100000000);\n    if (max_ai < 0 || max_ai > 100000000) {\n        fprintf(stderr, \"Invalid max_ai: %d\\n\", max_ai);\n        exit(1);\n    }\n\n    vector<vector<int>> a;\n\n    if (type == \"ai-all-zero\") {\n        a.assign(n, vector<int>(m, 0));\n    } else if (type == \"ai-all-max\") {\n        a.assign(n, vector<int>(m, max_ai));\n    } else if (type == \"random\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, max_ai);\n    } else if (type == \"ai-increasing\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = min(max_ai, i);\n    } else if (type == \"ai-decreasing\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = min(max_ai, n - i);\n    } else if (type == \"ai-alternating-zero-max\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            int val = (i % 2 == 0) ? 0 : max_ai;\n            for (int j = 0; j < m; ++j)\n                a[i][j] = val;\n        }\n    } else if (type == \"ai-zeros-then-max\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            int val = (i < n / 2) ? 0 : max_ai;\n            for (int j = 0; j < m; ++j)\n                a[i][j] = val;\n        }\n    } else if (type == \"single-droid\") {\n        n = 1;\n        a.assign(1, vector<int>(m));\n        for (int j = 0; j < m; ++j)\n            a[0][j] = rnd.next(0, max_ai);\n    } else if (type == \"k-zero\") {\n        k = 0;\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, max_ai);\n    } else if (type == \"k-max\") {\n        k = 1000000000;\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, max_ai);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d %lld\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", a[i][j], j + 1 == m ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    if (n < 1 || n > 100000) {\n        fprintf(stderr, \"Invalid n: %d\\n\", n);\n        exit(1);\n    }\n\n    int m = opt<int>(\"m\", 1);\n    if (m < 1 || m > 5) {\n        fprintf(stderr, \"Invalid m: %d\\n\", m);\n        exit(1);\n    }\n\n    long long k = opt<long long>(\"k\", 1000000000);\n    if (k < 0 || k > 1000000000) {\n        fprintf(stderr, \"Invalid k: %lld\\n\", k);\n        exit(1);\n    }\n\n    string type = opt<string>(\"type\", \"random\");\n    int max_ai = opt<int>(\"max_ai\", 100000000);\n    if (max_ai < 0 || max_ai > 100000000) {\n        fprintf(stderr, \"Invalid max_ai: %d\\n\", max_ai);\n        exit(1);\n    }\n\n    vector<vector<int>> a;\n\n    if (type == \"ai-all-zero\") {\n        a.assign(n, vector<int>(m, 0));\n    } else if (type == \"ai-all-max\") {\n        a.assign(n, vector<int>(m, max_ai));\n    } else if (type == \"random\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, max_ai);\n    } else if (type == \"ai-increasing\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = min(max_ai, i);\n    } else if (type == \"ai-decreasing\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = min(max_ai, n - i);\n    } else if (type == \"ai-alternating-zero-max\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            int val = (i % 2 == 0) ? 0 : max_ai;\n            for (int j = 0; j < m; ++j)\n                a[i][j] = val;\n        }\n    } else if (type == \"ai-zeros-then-max\") {\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i) {\n            int val = (i < n / 2) ? 0 : max_ai;\n            for (int j = 0; j < m; ++j)\n                a[i][j] = val;\n        }\n    } else if (type == \"single-droid\") {\n        n = 1;\n        a.assign(1, vector<int>(m));\n        for (int j = 0; j < m; ++j)\n            a[0][j] = rnd.next(0, max_ai);\n    } else if (type == \"k-zero\") {\n        k = 0;\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, max_ai);\n    } else if (type == \"k-max\") {\n        k = 1000000000;\n        a.assign(n, vector<int>(m));\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                a[i][j] = rnd.next(0, max_ai);\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    printf(\"%d %d %lld\\n\", n, m, k);\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            printf(\"%d%c\", a[i][j], j + 1 == m ? '\\n' : ' ');\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen --n=1 --m=1 --k=0 --type=ai-all-zero\n./gen --n=1 --m=5 --k=1000000000 --type=ai-all-max\n./gen --n=2 --m=2 --k=10 --type=random\n./gen --n=5 --m=3 --k=100 --type=random\n./gen --n=50 --m=3 --k=100 --type=random\n./gen --n=100 --m=5 --k=1000 --type=random\n./gen --n=1000 --m=5 --k=1000 --type=random\n./gen --n=10000 --m=5 --k=10000 --type=ai-increasing\n./gen --n=10000 --m=5 --k=10000 --type=ai-decreasing\n./gen --n=100000 --m=5 --k=1000000000 --type=random\n./gen --n=100000 --m=5 --k=0 --type=k-zero\n./gen --n=100000 --m=1 --k=1000000000 --type=k-max\n./gen --n=100000 --m=5 --k=1000000000 --type=ai-alternating-zero-max\n./gen --n=100000 --m=5 --k=1000000000 --type=ai-zeros-then-max\n./gen --n=100000 --m=5 --k=1000000000 --type=ai-all-zero\n./gen --n=100000 --m=5 --k=1000000000 --type=ai-all-max\n./gen --n=100000 --m=1 --k=1000000000 --type=ai-all-zero\n./gen --n=100000 --m=1 --k=1000000000 --type=ai-all-max\n./gen --n=100000 --m=1 --k=0 --type=k-zero\n./gen --n=100000 --m=5 --k=0 --type=k-zero\n./gen --n=100000 --m=5 --k=0 --type=ai-all-zero\n./gen --n=100000 --m=5 --k=1 --type=random\n./gen --n=1 --m=5 --k=1000000000 --type=single-droid\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:05.883344",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "514/E",
      "title": "E. Дарт Вейдер и дерево",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке через пробел записано два целых числа n и x (1 ≤ n ≤ 105, 0 ≤ x ≤ 109) — количество сыновей каждой вершины и расстояние от корня, в пределах которого требуется посчитать вершины.В следующей строке через пробел следуют n чисел di (1 ≤ di ≤ 100) — длина ребра, соединяющего каждую вершину с её i-м сыном.",
      "output_spec": "Выходные данныеВыведите одно число — количество вершин в дереве на расстоянии от корня не более x.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 31 2 3Выходные данныеСкопировать8",
      "description": "E. Дарт Вейдер и дерево\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке через пробел записано два целых числа n и x (1 ≤ n ≤ 105, 0 ≤ x ≤ 109) — количество сыновей каждой вершины и расстояние от корня, в пределах которого требуется посчитать вершины.В следующей строке через пробел следуют n чисел di (1 ≤ di ≤ 100) — длина ребра, соединяющего каждую вершину с её i-м сыном.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество вершин в дереве на расстоянии от корня не более x.\n\nВыходные данные\n\nВходные данныеСкопировать3 31 2 3Выходные данныеСкопировать8\n\nВходные данныеСкопировать3 31 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРисунок к примеру (желтым помечены вершины, расстояние до которых не больше трех)",
      "solutions": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!14 февраля 2015 года в 19:30 MSK состоится раунд Codeforces #291 (Div. 2) для участников из второго дивизиона.Это мой первый Codeforces раунд. Надеюсь, он вам понравится.Большое спасибо Максиму Ахмедову (Zlobober), Василию Антонюку (Antoniuk) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за платформы Codeforces и Polygon.Удачи всем!UPD: Распределение баллов по задачам будет таким — 500-1000-2000-2000-2500.UPD: Разбор. Простите за задержку)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16365",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 540
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces",
          "content": "514A - Чубакка и числоАвтор: RebrykОчевидно, что все цифры, которые больше 4, нужно инвертировать. Кроме цифры 9, если она первая цифра числа.Асимптотика: 514B - Хан Соло и лазерная пушкаАвтор: AntoniukПереберем точки, в которых находятся солдаты. Если в данной точке солдаты еще не убиты, то сделаем выстрел и уничтожим всех солдатов, находящихся на прямой, проходящей через месторасположение пушки и данную точку.Точки (x1, y1), (x2, y2), (x3, y3) лежат на одной прямой, если (x2 - x1)(y3 - y1) = (x3 - x1)(y2 - y1).Асимптотика: 514C - Уотто и механизмАвтор: RebrykПри добавлении строки в множество, посчитаем от нее полиномиальный хэш и добавим его в массив. Затем этот массив отсортируем. Теперь для ответа на запрос будем пробовать менять каждый символ в строке и с помощью бинарного поиска проверять, встречается ли ее хеш в массиве (пересчитывая хэш за ). Если хэш встречается, то ответ на запрос \"YES\", иначе \"NO\".Асимптотика: , где L — суммарная длина всех строк.514D - R2-D2 и армия дроидовАвтор: RebrykЧтобы уничтожить всех роботов на отрезке с l по r, нужно сделать выстрелов, где cnt[i][j] — кол-во деталей j-го типа у i-го дроида.Будем поддерживать указатели на начало и конец отрезка, на котором хотим уничтожить всех дроидов. Пока мы можем уничтожить дроидов на текущем отрезке, будем увеличивать правую границу отрезка, иначе — левую, каждый раз обновляя ответ.Чтобы эффективно находить максимум на отрезке, будем использовать очередь.Асимптотика: 514E - Дарт Вейдер и деревоАвтор: AntoniukНетрудно понять, что , где dp[i] — кол-во вершин, которые находятся на расстоянии i от корня, а cnt[j] — кол-во детей, расстояние до которых j. Ответ .Пусть состояние динамикиПостроим матрицу перехода размера 101 × 101Теперь, чтобы перейти к следующему состоянию, нужно A умножить на B. Следовательно, если мы рассмотрим матрицу C = A·Bx - 100, то ответ на задачу будет находиться в самой правой ячейке этой матрицы. Для x < 100 ответ будем находить динамикой, которая была изложена в начале.Для нахождения Bk будем пользоваться бинарным возведением в степень.Асимптотика:",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16398",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 514\\s*E"
          },
          "content_length": 2079
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 1",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 2",
          "code": "1 1\naaa\naaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 3",
          "code": "int mult(int a, int b, int mod) {\nreturn (a*1LL*b) % mod; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 4",
          "code": "int mult(int a, int b, int mod) {\nreturn (a*1LL*b) % mod; }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 5",
          "code": "ax+by+c = 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 6",
          "code": "gcd(a,b,c) = 1 and a > 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 7",
          "code": "n equation (a,b,c)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 8",
          "code": "(a_i,b_i,c_i) == (a_j,b_j,c_j)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 9",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 10",
          "code": "4 0 0\n0 1\n0 -1\n1 0\n-1 0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 11",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 12",
          "code": "2 -10000 -10000\n7711 946\n946 -3235",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 13",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 14",
          "code": "set<double>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 15",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 16",
          "code": "class Fraction {\n\tpublic int a;\n\tpublic int b;\n\tpublic Fraction(int a, int b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t}\n\t@Override\n\tpublic boolean equals(Object ff) {\n\t\tFraction f = (Fraction)ff;\n\t\treturn (this.a*f.b == this.b*f.a);\n\t}\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 17",
          "code": "m string query",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 18",
          "code": "string x = s",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 19",
          "code": "set x[j] = {'a','b','c' \\ x[j] != s[j]}.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 20",
          "code": "The total length of lines in the input doesn't exceed 6·10^5",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 21",
          "code": "my standing not low",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 22",
          "code": "deque.back()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 23",
          "code": "deque.push_back(a[j])",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 24",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 25",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 26",
          "code": "deque.front()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 27",
          "code": "set <string> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 28",
          "code": "if (f.find(s) != f.end())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 29",
          "code": "map <string, bool> f",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 30",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #291 (Div. 2) - Codeforces - Code 31",
          "code": "1 1\nabc\nbabc",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16365",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 1",
          "code": "H = (H * p + s[i]) % q",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 2",
          "code": "set<string>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 3",
          "code": "O(log n) or O(L log n)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 4",
          "code": "bool operator<(const T&a,const T&b)const;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 5",
          "code": "#include<string>",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 6",
          "code": "GNU libstdc++",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 7",
          "code": "newfp -= Pow*(p[j]-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 8",
          "code": "newfp += Pow*(k-'a'+1)%PRIME_Q;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 9",
          "code": "a = ((a - b) % m + m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 10",
          "code": "1 1\naaaaaaaaaa\naab",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 11",
          "code": "1 1\naaaaaaaaaa\naab",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 12",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #291 (Div. 2) - Codeforces - Code 13",
          "code": "template <class T, class F = function<T (const T&, const T&)>>\nstruct SparseTable {\n  int n;\n  vector<vector<T>> st;\n  F func;\n\n  SparseTable () {}\n\n  SparseTable (const vector<T>& a, const F& f) : func(f) {\n    n = static_cast<int>(a.size());\n    int maxlg = 32 - __builtin_clz(n);\n    st.resize(maxlg);\n    st[0] = a;\n    for (int j = 1; j < maxlg; j++) {\n      st[j].resize(n - (1 << j) + 1);\n      for (int i = 0; i <= n - (1 << j); i++) {\n        st[j][i] = func(st[j-1][i], st[j-1][i + (1 << (j-1))]);\n      }\n    }\n  }\n\n  T get (int l, int r) const {\n    int lg = 32 - __builtin_clz(r - l + 1) - 1;\n    return func(st[lg][l], st[lg][r - (1 << lg) + 1]);\n  }\n};\n\nsigned main() {\n#ifdef READ_FILE\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(10);\n  int n, m, k;\n  cin >> n >> m >> k;\n  vector<vector<int>> a(m, vector<int>(n));\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < m; j++) cin >> a[j][i];\n  }\n  vector<SparseTable<int>> st(m);\n  for (int i = 0; i < m; i++) {\n    st[i] = SparseTable<int>(a[i], [&] (int px, int py) {\n      return (px > py)? px: py;\n    });\n  }\n  vector<int> res(m, 0);\n  int ans = 0;\n  for (int i = 0; i < n; i++) {\n    int lo = i;\n    int hi = n - 1;\n    int mid = lo + (hi - lo) / 2;\n    while (lo <= hi) {\n      long long cur = 0;\n      for (int j = 0; j < m; j++) cur += st[j].get(i, mid);\n      debug(i, lo, hi ,mid, cur);\n      if (cur > k) {\n        hi = mid - 1;\n      } else {\n        lo = mid + 1;\n        if (ans < (mid - i + 1)) {\n          ans = mid - i + 1;\n          for (int j = 0; j < m; j++) res[j] = st[j].get(i, mid);\n        }\n      }\n      mid = lo + (hi - lo) / 2;\n    }\n  }\n  //cout << ans << \"\\n\";\n  for (auto x : res) cout << x << \" \";\n  cout << \"\\n\";\n  return 0;\n}",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16398",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readEoln();\n    vector<int> d = inf.readInts(n, 1, 100, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readEoln();\n    vector<int> d = inf.readInts(n, 1, 100, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int x = inf.readInt(0, 1000000000, \"x\");\n    inf.readEoln();\n    vector<int> d = inf.readInts(n, 1, 100, \"d\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n    string di_mode = opt<string>(\"di_mode\", \"random\");\n    int k = opt<int>(\"k\", 1);\n\n    vector<int> di(n);\n\n    if (di_mode == \"const\") {\n        // All di are equal to k\n        if (k < 1 || k > 100) {\n            fprintf(stderr, \"Error: k must be between 1 and 100 inclusive.\\n\");\n            return 1;\n        }\n        fill(di.begin(), di.end(), k);\n    } else if (di_mode == \"min\") {\n        // All di are 1\n        fill(di.begin(), di.end(), 1);\n    } else if (di_mode == \"max\") {\n        // All di are 100\n        fill(di.begin(), di.end(), 100);\n    } else if (di_mode == \"inc\") {\n        // di increases from 1 to 100 repeatedly\n        for (int i = 0; i < n; ++i) {\n            di[i] = 1 + i % 100;\n        }\n    } else if (di_mode == \"dec\") {\n        // di decreases from 100 to 1 repeatedly\n        for (int i = 0; i < n; ++i) {\n            di[i] = 100 - i % 100;\n        }\n    } else if (di_mode == \"zigzag\") {\n        // di alternates between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            di[i] = (i % 2 == 0) ? 1 : 100;\n        }\n    } else if (di_mode == \"random\") {\n        // di are random integers between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            di[i] = rnd.next(1, 100);\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown di_mode '%s'.\\n\", di_mode.c_str());\n        return 1;\n    }\n\n    // Output n and x\n    printf(\"%d %lld\\n\", n, x);\n\n    // Output di[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    long long x = opt<long long>(\"x\");\n    string di_mode = opt<string>(\"di_mode\", \"random\");\n    int k = opt<int>(\"k\", 1);\n\n    vector<int> di(n);\n\n    if (di_mode == \"const\") {\n        // All di are equal to k\n        if (k < 1 || k > 100) {\n            fprintf(stderr, \"Error: k must be between 1 and 100 inclusive.\\n\");\n            return 1;\n        }\n        fill(di.begin(), di.end(), k);\n    } else if (di_mode == \"min\") {\n        // All di are 1\n        fill(di.begin(), di.end(), 1);\n    } else if (di_mode == \"max\") {\n        // All di are 100\n        fill(di.begin(), di.end(), 100);\n    } else if (di_mode == \"inc\") {\n        // di increases from 1 to 100 repeatedly\n        for (int i = 0; i < n; ++i) {\n            di[i] = 1 + i % 100;\n        }\n    } else if (di_mode == \"dec\") {\n        // di decreases from 100 to 1 repeatedly\n        for (int i = 0; i < n; ++i) {\n            di[i] = 100 - i % 100;\n        }\n    } else if (di_mode == \"zigzag\") {\n        // di alternates between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            di[i] = (i % 2 == 0) ? 1 : 100;\n        }\n    } else if (di_mode == \"random\") {\n        // di are random integers between 1 and 100\n        for (int i = 0; i < n; ++i) {\n            di[i] = rnd.next(1, 100);\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown di_mode '%s'.\\n\", di_mode.c_str());\n        return 1;\n    }\n\n    // Output n and x\n    printf(\"%d %lld\\n\", n, x);\n\n    // Output di[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n, x = 0, di_mode = min\n./gen -n 1 -x 0 -di_mode min\n\n# Small n, x = 0, di_mode = max\n./gen -n 1 -x 0 -di_mode max\n\n# Small n, small x, di_mode = const k=1\n./gen -n 5 -x 5 -di_mode const -k 1\n\n# Small n, small x, di_mode = const k=100\n./gen -n 5 -x 500 -di_mode const -k 100\n\n# Small n, small x, di_mode = inc\n./gen -n 10 -x 50 -di_mode inc\n\n# Small n, small x, di_mode = dec\n./gen -n 10 -x 50 -di_mode dec\n\n# Small n, small x, di_mode = zigzag\n./gen -n 10 -x 50 -di_mode zigzag\n\n# Small n, small x, di_mode = random\n./gen -n 10 -x 50 -di_mode random\n\n# n = 1e5, x = 1e9, di_mode = min\n./gen -n 100000 -x 1000000000 -di_mode min\n\n# n = 1e5, x = 1e9, di_mode = max\n./gen -n 100000 -x 1000000000 -di_mode max\n\n# n = 1e5, x = 1e9, di_mode = const k=50\n./gen -n 100000 -x 1000000000 -di_mode const -k 50\n\n# n = 1e5, x = 0, di_mode = random\n./gen -n 100000 -x 0 -di_mode random\n\n# n = 1e5, x = 0, di_mode = inc\n./gen -n 100000 -x 0 -di_mode inc\n\n# n = 1e5, x = large value, di_mode = dec\n./gen -n 100000 -x 1000000000 -di_mode dec\n\n# n = 1e5, x = half of total distance, di_mode = zigzag\n./gen -n 100000 -x 5000000 -di_mode zigzag\n\n# Medium n, x = max value, di_mode = random\n./gen -n 50000 -x 1000000000 -di_mode random\n\n# n = 2, x = small value, di_mode = random\n./gen -n 2 -x 1 -di_mode random\n\n# n = 2, x = large value, di_mode = random\n./gen -n 2 -x 1000000000 -di_mode random\n\n# n = 99999, x = 99999, di_mode = inc\n./gen -n 99999 -x 99999 -di_mode inc\n\n# n = 100000, x = 1e5, di_mode = dec\n./gen -n 100000 -x 100000 -di_mode dec\n\n# n = 100000, x = 1e8, di_mode = const k=1\n./gen -n 100000 -x 100000000 -di_mode const -k 1\n\n# n = 100000, x = 100, di_mode = const k=100\n./gen -n 100000 -x 100 -di_mode const -k 100\n\n# n = 100000, x = 5000000, di_mode = random\n./gen -n 100000 -x 5000000 -di_mode random\n\n# n = 100000, x = 1e9, di_mode = zigzag\n./gen -n 100000 -x 1000000000 -di_mode zigzag\n\n# n = 1, x = 0, di_mode = min\n./gen -n 1 -x 0 -di_mode min\n\n# n = 1, x = 1e9, di_mode = max\n./gen -n 1 -x 1000000000 -di_mode max\n\n# n = 50000, x = 123456789, di_mode = random\n./gen -n 50000 -x 123456789 -di_mode random\n\n# n = 100000, x = 999999999, di_mode = inc\n./gen -n 100000 -x 999999999 -di_mode inc\n\n# n = 100000, x = 1e9, di_mode = dec\n./gen -n 100000 -x 1000000000 -di_mode dec\n\n# n = 100000, x = 0, di_mode = min\n./gen -n 100000 -x 0 -di_mode min\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:07.776421",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "515/A",
      "title": "A. Drazil and Date",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputYou are given three integers a, b, and s ( - 109 ≤ a, b ≤ 109, 1 ≤ s ≤ 2·109) in a single line.",
      "output_spec": "OutputIf you think Drazil made a mistake and it is impossible to take exactly s steps and get from his home to Varda's home, print \"No\" (without quotes).Otherwise, print \"Yes\".",
      "sample_tests": "ExamplesInputCopy5 5 11OutputCopyNoInputCopy10 15 25OutputCopyYesInputCopy0 5 1OutputCopyNoInputCopy0 0 2OutputCopyYes",
      "description": "A. Drazil and Date\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputYou are given three integers a, b, and s ( - 109 ≤ a, b ≤ 109, 1 ≤ s ≤ 2·109) in a single line.\n\nOutputIf you think Drazil made a mistake and it is impossible to take exactly s steps and get from his home to Varda's home, print \"No\" (without quotes).Otherwise, print \"Yes\".\n\nInputCopy5 5 11OutputCopyNoInputCopy10 15 25OutputCopyYesInputCopy0 5 1OutputCopyNoInputCopy0 0 2OutputCopyYes\n\nInputCopy5 5 11\n\nOutputCopyNo\n\nInputCopy10 15 25\n\nOutputCopyYes\n\nInputCopy0 5 1\n\nOutputCopyNo\n\nInputCopy0 0 2\n\nOutputCopyYes\n\nNoteIn fourth sample case one possible route is: .",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 515 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int s = inf.readInt(1, 2000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int s = inf.readInt(1, 2000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int a = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int b = inf.readInt(-1000000000, 1000000000);\n    inf.readSpace();\n    int s = inf.readInt(1, 2000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n    long long MaxA = opt<long long>(\"MaxA\", 1000000000LL);\n    long long MaxB = opt<long long>(\"MaxB\", 1000000000LL);\n    string signA = opt<string>(\"signA\", \"any\");\n    string signB = opt<string>(\"signB\", \"any\");\n\n    long long a, b, s;\n\n    auto get_random_value = [&](long long MaxValue, string sign) {\n        long long val = 0;\n        if (sign == \"pos\") {\n            val = rnd.next(1LL, MaxValue);\n        } else if (sign == \"neg\") {\n            val = -rnd.next(1LL, MaxValue);\n        } else if (sign == \"zero\") {\n            val = 0;\n        } else { // \"any\"\n            int sign_choice = rnd.next(3);\n            if (sign_choice == 0) {\n                val = rnd.next(1LL, MaxValue);\n            } else if (sign_choice == 1) {\n                val = -rnd.next(1LL, MaxValue);\n            } else {\n                val = 0;\n            }\n        }\n        return val;\n    };\n\n    if (type == \"min_equal_s\") {\n        // Generate a and b\n        a = get_random_value(MaxA, signA);\n        b = get_random_value(MaxB, signB);\n        long long minimal_steps = abs(a) + abs(b);\n        if (minimal_steps == 0) {\n            // s must be even and s ≥2\n            s = 2;\n        } else {\n            s = minimal_steps;\n        }\n    } else if (type == \"s_gt_min_even\") {\n        // Generate a and b\n        while (true) {\n            a = get_random_value(MaxA, signA);\n            b = get_random_value(MaxB, signB);\n            long long minimal_steps = abs(a) + abs(b);\n            long long max_delta = 2000000000LL - minimal_steps;\n            if (max_delta >= 2) {\n                long long max_k = max_delta / 2;\n                long long k = rnd.next(1LL, max_k); // k ≥1\n                long long delta = k * 2;\n                s = minimal_steps + delta;\n                break;\n            }\n            // Else, try again\n        }\n    } else if (type == \"s_gt_min_odd\") {\n        // Generate a and b\n        while (true) {\n            a = get_random_value(MaxA, signA);\n            b = get_random_value(MaxB, signB);\n            long long minimal_steps = abs(a) + abs(b);\n            long long max_delta = 2000000000LL - minimal_steps;\n            if (max_delta >= 1) {\n                long long max_k = (max_delta -1) / 2;\n                if (max_k >= 0) {\n                    long long k = rnd.next(0LL, max_k); // k ≥0\n                    long long delta = k * 2 +1; // delta ≥1, odd\n                    s = minimal_steps + delta;\n                    break;\n                }\n            }\n            // Else, try again\n        }\n    } else if (type == \"s_lt_min\") {\n        // Generate a and b with minimal_steps ≥2\n        while(true) {\n            a = get_random_value(MaxA, signA);\n            b = get_random_value(MaxB, signB);\n            long long minimal_steps = abs(a) + abs(b);\n            if (minimal_steps > 1) {\n                s = rnd.next(1LL, minimal_steps -1);\n                break;\n            }\n            // Else, try again\n        }\n    } else { // random\n        a = get_random_value(MaxA, signA);\n        b = get_random_value(MaxB, signB);\n        // Generate random s between 1 and 2e9\n        s = rnd.next(1LL, 2000000000LL);\n    }\n\n    // Output a, b, s\n    printf(\"%lld %lld %lld\\n\", a, b, s);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    // Read parameters\n    string type = opt<string>(\"type\", \"random\");\n    long long MaxA = opt<long long>(\"MaxA\", 1000000000LL);\n    long long MaxB = opt<long long>(\"MaxB\", 1000000000LL);\n    string signA = opt<string>(\"signA\", \"any\");\n    string signB = opt<string>(\"signB\", \"any\");\n\n    long long a, b, s;\n\n    auto get_random_value = [&](long long MaxValue, string sign) {\n        long long val = 0;\n        if (sign == \"pos\") {\n            val = rnd.next(1LL, MaxValue);\n        } else if (sign == \"neg\") {\n            val = -rnd.next(1LL, MaxValue);\n        } else if (sign == \"zero\") {\n            val = 0;\n        } else { // \"any\"\n            int sign_choice = rnd.next(3);\n            if (sign_choice == 0) {\n                val = rnd.next(1LL, MaxValue);\n            } else if (sign_choice == 1) {\n                val = -rnd.next(1LL, MaxValue);\n            } else {\n                val = 0;\n            }\n        }\n        return val;\n    };\n\n    if (type == \"min_equal_s\") {\n        // Generate a and b\n        a = get_random_value(MaxA, signA);\n        b = get_random_value(MaxB, signB);\n        long long minimal_steps = abs(a) + abs(b);\n        if (minimal_steps == 0) {\n            // s must be even and s ≥2\n            s = 2;\n        } else {\n            s = minimal_steps;\n        }\n    } else if (type == \"s_gt_min_even\") {\n        // Generate a and b\n        while (true) {\n            a = get_random_value(MaxA, signA);\n            b = get_random_value(MaxB, signB);\n            long long minimal_steps = abs(a) + abs(b);\n            long long max_delta = 2000000000LL - minimal_steps;\n            if (max_delta >= 2) {\n                long long max_k = max_delta / 2;\n                long long k = rnd.next(1LL, max_k); // k ≥1\n                long long delta = k * 2;\n                s = minimal_steps + delta;\n                break;\n            }\n            // Else, try again\n        }\n    } else if (type == \"s_gt_min_odd\") {\n        // Generate a and b\n        while (true) {\n            a = get_random_value(MaxA, signA);\n            b = get_random_value(MaxB, signB);\n            long long minimal_steps = abs(a) + abs(b);\n            long long max_delta = 2000000000LL - minimal_steps;\n            if (max_delta >= 1) {\n                long long max_k = (max_delta -1) / 2;\n                if (max_k >= 0) {\n                    long long k = rnd.next(0LL, max_k); // k ≥0\n                    long long delta = k * 2 +1; // delta ≥1, odd\n                    s = minimal_steps + delta;\n                    break;\n                }\n            }\n            // Else, try again\n        }\n    } else if (type == \"s_lt_min\") {\n        // Generate a and b with minimal_steps ≥2\n        while(true) {\n            a = get_random_value(MaxA, signA);\n            b = get_random_value(MaxB, signB);\n            long long minimal_steps = abs(a) + abs(b);\n            if (minimal_steps > 1) {\n                s = rnd.next(1LL, minimal_steps -1);\n                break;\n            }\n            // Else, try again\n        }\n    } else { // random\n        a = get_random_value(MaxA, signA);\n        b = get_random_value(MaxB, signB);\n        // Generate random s between 1 and 2e9\n        s = rnd.next(1LL, 2000000000LL);\n    }\n\n    // Output a, b, s\n    printf(\"%lld %lld %lld\\n\", a, b, s);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_equal_s -signA pos -signB pos\n./gen -type min_equal_s -signA pos -signB neg\n./gen -type min_equal_s -signA neg -signB pos\n./gen -type min_equal_s -signA neg -signB neg\n./gen -type min_equal_s -signA zero -signB pos\n./gen -type min_equal_s -signA pos -signB zero\n./gen -type min_equal_s -signA zero -signB zero\n\n./gen -type s_gt_min_even -signA pos -signB pos\n./gen -type s_gt_min_even -signA neg -signB neg\n./gen -type s_gt_min_even -signA pos -signB neg\n./gen -type s_gt_min_even -signA neg -signB pos\n./gen -type s_gt_min_even -signA zero -signB any\n./gen -type s_gt_min_even -signA any -signB zero\n./gen -type s_gt_min_even -signA zero -signB zero\n\n./gen -type s_gt_min_odd -signA pos -signB pos\n./gen -type s_gt_min_odd -signA neg -signB neg\n./gen -type s_gt_min_odd -signA pos -signB zero\n./gen -type s_gt_min_odd -signA zero -signB pos\n./gen -type s_gt_min_odd -signA zero -signB zero\n\n./gen -type s_lt_min -signA pos -signB pos\n./gen -type s_lt_min -signA neg -signB pos\n./gen -type s_lt_min -signA pos -signB neg\n./gen -type s_lt_min -signA neg -signB neg\n\n./gen -type random\n./gen -type random -signA pos -signB pos\n./gen -type random -signA neg -signB pos\n./gen -type random -signA zero -signB zero\n./gen -type random -MaxA 1 -MaxB 1\n./gen -type random -MaxA 1000000000 -MaxB 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:10.131304",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "515/B",
      "title": "B. Drazil and His Happy Friends",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integer n and m (1 ≤ n, m ≤ 100).The second line contains integer b (0 ≤ b ≤ n), denoting the number of happy boys among friends of Drazil, and then follow b distinct integers x1, x2, ..., xb (0 ≤ xi < n), denoting the list of indices of happy boys.The third line conatins integer g (0 ≤ g ≤ m), denoting the number of happy girls among friends of Drazil, and then follow g distinct integers y1, y2, ... , yg (0 ≤ yj < m), denoting the list of indices of happy girls.It is guaranteed that there is at least one person that is unhappy among his friends.",
      "output_spec": "OutputIf Drazil can make all his friends become happy by this plan, print \"Yes\". Otherwise, print \"No\".",
      "sample_tests": "ExamplesInputCopy2 301 0OutputCopyYesInputCopy2 41 01 2OutputCopyNoInputCopy2 31 01 1OutputCopyYes",
      "description": "B. Drazil and His Happy Friends\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integer n and m (1 ≤ n, m ≤ 100).The second line contains integer b (0 ≤ b ≤ n), denoting the number of happy boys among friends of Drazil, and then follow b distinct integers x1, x2, ..., xb (0 ≤ xi < n), denoting the list of indices of happy boys.The third line conatins integer g (0 ≤ g ≤ m), denoting the number of happy girls among friends of Drazil, and then follow g distinct integers y1, y2, ... , yg (0 ≤ yj < m), denoting the list of indices of happy girls.It is guaranteed that there is at least one person that is unhappy among his friends.\n\nOutputIf Drazil can make all his friends become happy by this plan, print \"Yes\". Otherwise, print \"No\".\n\nInputCopy2 301 0OutputCopyYesInputCopy2 41 01 2OutputCopyNoInputCopy2 31 01 1OutputCopyYes\n\nInputCopy2 301 0\n\nOutputCopyYes\n\nInputCopy2 41 01 2\n\nOutputCopyNo\n\nInputCopy2 31 01 1\n\nOutputCopyYes\n\nNoteBy  we define the remainder of integer division of i by k.In first sample case:   On the 0-th day, Drazil invites 0-th boy and 0-th girl. Because 0-th girl is happy at the beginning, 0-th boy become happy at this day.  On the 1-st day, Drazil invites 1-st boy and 1-st girl. They are both unhappy, so nothing changes at this day.  On the 2-nd day, Drazil invites 0-th boy and 2-nd girl. Because 0-th boy is already happy he makes 2-nd girl become happy at this day.  On the 3-rd day, Drazil invites 1-st boy and 0-th girl. 0-th girl is happy, so she makes 1-st boy happy.  On the 4-th day, Drazil invites 0-th boy and 1-st girl. 0-th boy is happy, so he makes the 1-st girl happy. So, all friends become happy at this moment.",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 515 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int b = inf.readInt(0, n, \"b\");\n    vector<int> boys;\n    if (b == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        boys = inf.readInts(b, 0, n - 1, \"xi\");\n        inf.readEoln();\n        set<int> boysSet(boys.begin(), boys.end());\n        ensuref((int)boysSet.size() == b, \"Boys indices must be distinct\");\n    }\n\n    int g = inf.readInt(0, m, \"g\");\n    vector<int> girls;\n    if (g == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        girls = inf.readInts(g, 0, m - 1, \"yj\");\n        inf.readEoln();\n        set<int> girlsSet(girls.begin(), girls.end());\n        ensuref((int)girlsSet.size() == g, \"Girls indices must be distinct\");\n    }\n\n    ensuref(b + g < n + m, \"There must be at least one unhappy friend\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int b = inf.readInt(0, n, \"b\");\n    vector<int> boys;\n    if (b == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        boys = inf.readInts(b, 0, n - 1, \"xi\");\n        inf.readEoln();\n        set<int> boysSet(boys.begin(), boys.end());\n        ensuref((int)boysSet.size() == b, \"Boys indices must be distinct\");\n    }\n\n    int g = inf.readInt(0, m, \"g\");\n    vector<int> girls;\n    if (g == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        girls = inf.readInts(g, 0, m - 1, \"yj\");\n        inf.readEoln();\n        set<int> girlsSet(girls.begin(), girls.end());\n        ensuref((int)girlsSet.size() == g, \"Girls indices must be distinct\");\n    }\n\n    ensuref(b + g < n + m, \"There must be at least one unhappy friend\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100, \"m\");\n    inf.readEoln();\n\n    int b = inf.readInt(0, n, \"b\");\n    vector<int> boys;\n    if (b == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        boys = inf.readInts(b, 0, n - 1, \"xi\");\n        inf.readEoln();\n        set<int> boysSet(boys.begin(), boys.end());\n        ensuref((int)boysSet.size() == b, \"Boys indices must be distinct\");\n    }\n\n    int g = inf.readInt(0, m, \"g\");\n    vector<int> girls;\n    if (g == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        girls = inf.readInts(g, 0, m - 1, \"yj\");\n        inf.readEoln();\n        set<int> girlsSet(girls.begin(), girls.end());\n        ensuref((int)girlsSet.size() == g, \"Girls indices must be distinct\");\n    }\n\n    ensuref(b + g < n + m, \"There must be at least one unhappy friend\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int b = 0;\n    vector<int> hb;\n\n    int g = 0;\n    vector<int> hg;\n\n    if (type == \"random\") {\n        /* Randomly choose b and g */\n        b = rnd.next(0, n);\n        g = rnd.next(0, m);\n\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    } else if (type == \"all_happy_boys\") {\n        /* All boys are happy, some girls are unhappy */\n        b = n;\n        hb.resize(b);\n        for (int i = 0; i < n; i++) hb[i] = i;\n\n        if (m == 1) g = 0;\n        else g = rnd.next(0, m - 1);\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    } else if (type == \"all_happy_girls\") {\n        /* All girls are happy, some boys are unhappy */\n        g = m;\n        hg.resize(g);\n        for (int i = 0; i < m; i++) hg[i] = i;\n\n        if (n == 1) b = 0;\n        else b = rnd.next(0, n - 1);\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n    } else if (type == \"no_happy\") {\n        /* No one is happy */\n        b = 0;\n        g = 0;\n    } else if (type == \"some_happy_boys\") {\n        /* Some boys are happy, no girls are happy */\n        if (n == 1) b = 1;\n        else b = rnd.next(1, n - 1);\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n        g = 0;\n    } else if (type == \"some_happy_girls\") {\n        /* Some girls are happy, no boys are happy */\n        if (m == 1) g = 1;\n        else g = rnd.next(1, m - 1);\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n        b = 0;\n    } else if (type == \"gcd_1\") {\n        /* n and m are coprime */\n        do {\n            n = rnd.next(1, 100);\n            m = rnd.next(1, 100);\n        } while (__gcd(n, m) != 1);\n\n        /* Random happy boys and girls */\n        b = rnd.next(0, n);\n        g = rnd.next(0, m);\n\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    } else if (type == \"max_n_m\") {\n        /* n and m are maximum */\n        n = 100;\n        m = 100;\n\n        /* Random happy boys and girls */\n        b = rnd.next(0, n);\n        g = rnd.next(0, m);\n\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    }\n\n    /* Ensure at least one person is unhappy */\n    if (b == n && g == m) {\n        if (n > 1) {\n            b--;\n            hb.pop_back();\n        } else if (m > 1) {\n            g--;\n            hg.pop_back();\n        } else {\n            b = 1;\n            g = 0;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d\", b);\n    for (int i = 0; i < b; i++) {\n        printf(\" %d\", hb[i]);\n    }\n    printf(\"\\n\");\n    printf(\"%d\", g);\n    for (int i = 0; i < g; i++) {\n        printf(\" %d\", hg[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int b = 0;\n    vector<int> hb;\n\n    int g = 0;\n    vector<int> hg;\n\n    if (type == \"random\") {\n        /* Randomly choose b and g */\n        b = rnd.next(0, n);\n        g = rnd.next(0, m);\n\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    } else if (type == \"all_happy_boys\") {\n        /* All boys are happy, some girls are unhappy */\n        b = n;\n        hb.resize(b);\n        for (int i = 0; i < n; i++) hb[i] = i;\n\n        if (m == 1) g = 0;\n        else g = rnd.next(0, m - 1);\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    } else if (type == \"all_happy_girls\") {\n        /* All girls are happy, some boys are unhappy */\n        g = m;\n        hg.resize(g);\n        for (int i = 0; i < m; i++) hg[i] = i;\n\n        if (n == 1) b = 0;\n        else b = rnd.next(0, n - 1);\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n    } else if (type == \"no_happy\") {\n        /* No one is happy */\n        b = 0;\n        g = 0;\n    } else if (type == \"some_happy_boys\") {\n        /* Some boys are happy, no girls are happy */\n        if (n == 1) b = 1;\n        else b = rnd.next(1, n - 1);\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n        g = 0;\n    } else if (type == \"some_happy_girls\") {\n        /* Some girls are happy, no boys are happy */\n        if (m == 1) g = 1;\n        else g = rnd.next(1, m - 1);\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n        b = 0;\n    } else if (type == \"gcd_1\") {\n        /* n and m are coprime */\n        do {\n            n = rnd.next(1, 100);\n            m = rnd.next(1, 100);\n        } while (__gcd(n, m) != 1);\n\n        /* Random happy boys and girls */\n        b = rnd.next(0, n);\n        g = rnd.next(0, m);\n\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    } else if (type == \"max_n_m\") {\n        /* n and m are maximum */\n        n = 100;\n        m = 100;\n\n        /* Random happy boys and girls */\n        b = rnd.next(0, n);\n        g = rnd.next(0, m);\n\n        vector<int> all_boys(n);\n        for (int i = 0; i < n; i++) all_boys[i] = i;\n        shuffle(all_boys.begin(), all_boys.end());\n\n        hb.resize(b);\n        for (int i = 0; i < b; i++) {\n            hb[i] = all_boys[i];\n        }\n        sort(hb.begin(), hb.end());\n\n        vector<int> all_girls(m);\n        for (int i = 0; i < m; i++) all_girls[i] = i;\n        shuffle(all_girls.begin(), all_girls.end());\n\n        hg.resize(g);\n        for (int i = 0; i < g; i++) {\n            hg[i] = all_girls[i];\n        }\n        sort(hg.begin(), hg.end());\n    }\n\n    /* Ensure at least one person is unhappy */\n    if (b == n && g == m) {\n        if (n > 1) {\n            b--;\n            hb.pop_back();\n        } else if (m > 1) {\n            g--;\n            hg.pop_back();\n        } else {\n            b = 1;\n            g = 0;\n        }\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d\", b);\n    for (int i = 0; i < b; i++) {\n        printf(\" %d\", hb[i]);\n    }\n    printf(\"\\n\");\n    printf(\"%d\", g);\n    for (int i = 0; i < g; i++) {\n        printf(\" %d\", hg[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type random\n./gen -n 1 -m 1 -type no_happy\n./gen -n 1 -m 1 -type all_happy_boys\n./gen -n 1 -m 1 -type all_happy_girls\n\n./gen -n 2 -m 2 -type random\n./gen -n 2 -m 2 -type no_happy\n./gen -n 2 -m 2 -type some_happy_boys\n./gen -n 2 -m 2 -type some_happy_girls\n./gen -n 2 -m 2 -type all_happy_boys\n./gen -n 2 -m 2 -type all_happy_girls\n\n./gen -n 2 -m 3 -type gcd_1\n\n./gen -n 4 -m 6 -type random\n\n./gen -n 5 -m 5 -type no_happy\n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 10 -type some_happy_boys\n./gen -n 10 -m 10 -type some_happy_girls\n\n./gen -n 99 -m 100 -type random\n\n./gen -n 100 -m 100 -type max_n_m\n./gen -n 100 -m 100 -type no_happy\n./gen -n 100 -m 99 -type random\n\n./gen -n 100 -m 100 -type all_happy_boys\n./gen -n 100 -m 100 -type all_happy_girls\n\n./gen -n 100 -m 99 -type random\n./gen -n 99 -m 100 -type random\n\n./gen -n 17 -m 29 -type gcd_1\n\n./gen -n 100 -m 100 -type gcd_not_1\n\n./gen -n 97 -m 97 -type random\n\n./gen -n 1 -m 100 -type random\n\n./gen -n 100 -m 1 -type random\n\n./gen -n 50 -m 50 -type no_happy\n\n./gen -n 50 -m 50 -type all_happy_boys\n\n./gen -n 50 -m 50 -type all_happy_girls\n\n./gen -n 50 -m 50 -type some_happy_boys\n\n./gen -n 50 -m 50 -type some_happy_girls\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:12.324845",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "515/C",
      "title": "C. Drazil и факториал",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (1 ≤ n ≤ 15) — количество цифр в числе a.Во второй строке записано n цифр числа a. В числе a есть не менее одной цифры, превышающей 1. Число a может содержать ведущие нули.",
      "output_spec": "Выходные данныеВыведите наибольшее возможное целое число, удовлетворяющее условиям, данным выше. В десятичной записи этого числа не должно быть нулей и единиц.",
      "sample_tests": "ПримерыВходные данныеСкопировать41234Выходные данныеСкопировать33222Входные данныеСкопировать3555Выходные данныеСкопировать555",
      "description": "C. Drazil и факториал\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано целое число n (1 ≤ n ≤ 15) — количество цифр в числе a.Во второй строке записано n цифр числа a. В числе a есть не менее одной цифры, превышающей 1. Число a может содержать ведущие нули.\n\nВходные данные\n\nВыходные данныеВыведите наибольшее возможное целое число, удовлетворяющее условиям, данным выше. В десятичной записи этого числа не должно быть нулей и единиц.\n\nВыходные данные\n\nВходные данныеСкопировать41234Выходные данныеСкопировать33222Входные данныеСкопировать3555Выходные данныеСкопировать555\n\nВходные данныеСкопировать41234\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать33222\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3555\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать555\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 515 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n    string a = inf.readLine();\n    ensuref((int)a.length() == n, \"Length of a (%d) should be equal to n (%d)\", (int)a.length(), n);\n    bool has_digit_larger_than_one = false;\n    for (int i = 0; i < n; ++i) {\n        ensuref(isdigit(a[i]), \"All characters in a should be digits\");\n        int digit = a[i] - '0';\n        if (digit > 1) has_digit_larger_than_one = true;\n    }\n    ensuref(has_digit_larger_than_one, \"There should be at least one digit larger than 1 in a\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n    string a = inf.readLine();\n    ensuref((int)a.length() == n, \"Length of a (%d) should be equal to n (%d)\", (int)a.length(), n);\n    bool has_digit_larger_than_one = false;\n    for (int i = 0; i < n; ++i) {\n        ensuref(isdigit(a[i]), \"All characters in a should be digits\");\n        int digit = a[i] - '0';\n        if (digit > 1) has_digit_larger_than_one = true;\n    }\n    ensuref(has_digit_larger_than_one, \"There should be at least one digit larger than 1 in a\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n    string a = inf.readLine();\n    ensuref((int)a.length() == n, \"Length of a (%d) should be equal to n (%d)\", (int)a.length(), n);\n    bool has_digit_larger_than_one = false;\n    for (int i = 0; i < n; ++i) {\n        ensuref(isdigit(a[i]), \"All characters in a should be digits\");\n        int digit = a[i] - '0';\n        if (digit > 1) has_digit_larger_than_one = true;\n    }\n    ensuref(has_digit_larger_than_one, \"There should be at least one digit larger than 1 in a\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> digits;\n\n    if (type == \"max\") {\n        /* 'a' consists of '9's */\n        for(int i = 0; i < n; ++i)\n            digits.push_back('9');\n    } else if (type == \"min\") {\n        /* 'a' consists of '2's */\n        for(int i = 0; i < n; ++i)\n            digits.push_back('2');\n    } else if (type == \"leading_zeros\") {\n        /* 'a' has leading zeros */\n        int num_zeros = rnd.next(1, n - 1);\n        for(int i = 0; i < num_zeros; ++i)\n            digits.push_back('0');\n        for(int i = num_zeros; i < n; ++i)\n            digits.push_back('2');  // Ensure at least one digit > 1\n    } else if (type == \"all_digits\") {\n        /* 'a' contains all digits from '0' to '9' */\n        string all_digits = \"0123456789\";\n        if (n < (int)all_digits.size()) {\n            // Not enough space, fill with random digits >1\n            for(int i = 0; i < n; ++i)\n                digits.push_back('0' + rnd.next(2, 9));\n        } else {\n            // Add all digits, then fill the rest randomly\n            for(char d : all_digits)\n                digits.push_back(d);\n            while ((int)digits.size() < n)\n                digits.push_back('0' + rnd.next(0, 9));\n        }\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"many_zeros_and_ones\") {\n        /* 'a' has many zeros and ones */\n        int num_special = n - 1;\n        for(int i = 0; i < num_special; ++i)\n            digits.push_back('0' + rnd.next(0, 1));\n        // Ensure at least one digit >1\n        digits.push_back('0' + rnd.next(2, 9));\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"max_length\") {\n        /* 'a' consists of '9's and length is 15 */\n        if (n != 15) {\n            fprintf(stderr, \"For 'max_length' type, n must be 15\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i)\n            digits.push_back('9');\n    } else { // Default is \"random\"\n        /* Random 'a' satisfying the constraints */\n        digits.resize(n);\n        // Ensure at least one digit >1\n        int index = rnd.next(n);\n        digits[index] = '0' + rnd.next(2, 9); // Digit >1\n        for(int i = 0; i < n; ++i) {\n            if (i == index) continue;\n            digits[i] = '0' + rnd.next(0, 9);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the n digits */\n    for(char d : digits)\n        printf(\"%c\", d);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<char> digits;\n\n    if (type == \"max\") {\n        /* 'a' consists of '9's */\n        for(int i = 0; i < n; ++i)\n            digits.push_back('9');\n    } else if (type == \"min\") {\n        /* 'a' consists of '2's */\n        for(int i = 0; i < n; ++i)\n            digits.push_back('2');\n    } else if (type == \"leading_zeros\") {\n        /* 'a' has leading zeros */\n        int num_zeros = rnd.next(1, n - 1);\n        for(int i = 0; i < num_zeros; ++i)\n            digits.push_back('0');\n        for(int i = num_zeros; i < n; ++i)\n            digits.push_back('2');  // Ensure at least one digit > 1\n    } else if (type == \"all_digits\") {\n        /* 'a' contains all digits from '0' to '9' */\n        string all_digits = \"0123456789\";\n        if (n < (int)all_digits.size()) {\n            // Not enough space, fill with random digits >1\n            for(int i = 0; i < n; ++i)\n                digits.push_back('0' + rnd.next(2, 9));\n        } else {\n            // Add all digits, then fill the rest randomly\n            for(char d : all_digits)\n                digits.push_back(d);\n            while ((int)digits.size() < n)\n                digits.push_back('0' + rnd.next(0, 9));\n        }\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"many_zeros_and_ones\") {\n        /* 'a' has many zeros and ones */\n        int num_special = n - 1;\n        for(int i = 0; i < num_special; ++i)\n            digits.push_back('0' + rnd.next(0, 1));\n        // Ensure at least one digit >1\n        digits.push_back('0' + rnd.next(2, 9));\n        shuffle(digits.begin(), digits.end());\n    } else if (type == \"max_length\") {\n        /* 'a' consists of '9's and length is 15 */\n        if (n != 15) {\n            fprintf(stderr, \"For 'max_length' type, n must be 15\\n\");\n            return 1;\n        }\n        for(int i = 0; i < n; ++i)\n            digits.push_back('9');\n    } else { // Default is \"random\"\n        /* Random 'a' satisfying the constraints */\n        digits.resize(n);\n        // Ensure at least one digit >1\n        int index = rnd.next(n);\n        digits[index] = '0' + rnd.next(2, 9); // Digit >1\n        for(int i = 0; i < n; ++i) {\n            if (i == index) continue;\n            digits[i] = '0' + rnd.next(0, 9);\n        }\n    }\n\n    /* Output n */\n    printf(\"%d\\n\", n);\n\n    /* Output the n digits */\n    for(char d : digits)\n        printf(\"%c\", d);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min\n./gen -n 1 -type max\n./gen -n 1 -type random\n\n./gen -n 2 -type min\n./gen -n 2 -type max\n./gen -n 2 -type random\n\n./gen -n 5 -type leading_zeros\n./gen -n 5 -type many_zeros_and_ones\n./gen -n 5 -type random\n./gen -n 5 -type all_digits\n\n./gen -n 10 -type min\n./gen -n 10 -type max\n./gen -n 10 -type leading_zeros\n./gen -n 10 -type many_zeros_and_ones\n./gen -n 10 -type random\n./gen -n 10 -type all_digits\n\n./gen -n 14 -type min\n./gen -n 14 -type max\n./gen -n 14 -type leading_zeros\n./gen -n 14 -type many_zeros_and_ones\n./gen -n 14 -type random\n./gen -n 14 -type all_digits\n\n./gen -n 15 -type min\n./gen -n 15 -type max\n./gen -n 15 -type leading_zeros\n./gen -n 15 -type many_zeros_and_ones\n./gen -n 15 -type random\n./gen -n 15 -type all_digits\n./gen -n 15 -type max_length\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:14.619833",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "515/D",
      "title": "D. Drazil и плитка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке следуют два целых числа n и m (1 ≤ n, m ≤ 2000).В следующих n строках описывается поле. Символ '.' обозначает пустую ячейку, а символ '*' обозначает занятую ячейку.",
      "output_spec": "Выходные данныеЕсли решения не существует, или же оно не уникальное, выведите строку \"Not unique\".В противном случае требуется вывести вариант покрытия всех пустых ячеек плитками размера 1 × 2. Обозначайте горизонтальные плитки символами \"<>\", а вертикальные плитки — символами \"^v\". Для полного понимания формата вывода обратитесь к примерам вывода.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 3....*....Выходные данныеСкопироватьNot uniqueВходные данныеСкопировать4 4..***...*.**....Выходные данныеСкопировать<>***^<>*v**<><>Входные данныеСкопировать2 4*..*....Выходные данныеСкопировать*<>*<><>Входные данныеСкопировать1 1.Выходные данныеСкопироватьNot uniqueВходные данныеСкопировать1 1*Выходные данныеСкопировать*",
      "description": "D. Drazil и плитка\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке следуют два целых числа n и m (1 ≤ n, m ≤ 2000).В следующих n строках описывается поле. Символ '.' обозначает пустую ячейку, а символ '*' обозначает занятую ячейку.\n\nВходные данные\n\nВыходные данныеЕсли решения не существует, или же оно не уникальное, выведите строку \"Not unique\".В противном случае требуется вывести вариант покрытия всех пустых ячеек плитками размера 1 × 2. Обозначайте горизонтальные плитки символами \"<>\", а вертикальные плитки — символами \"^v\". Для полного понимания формата вывода обратитесь к примерам вывода.\n\nВыходные данные\n\nВходные данныеСкопировать3 3....*....Выходные данныеСкопироватьNot uniqueВходные данныеСкопировать4 4..***...*.**....Выходные данныеСкопировать<>***^<>*v**<><>Входные данныеСкопировать2 4*..*....Выходные данныеСкопировать*<>*<><>Входные данныеСкопировать1 1.Выходные данныеСкопироватьNot uniqueВходные данныеСкопировать1 1*Выходные данныеСкопировать*\n\nВходные данныеСкопировать3 3....*....\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNot unique\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 4..***...*.**....\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать<>***^<>*v**<><>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 4*..*....\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать*<>*<><>\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1.\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьNot unique\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 1*\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать*\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере действительно существует два решения исходной задачи:<>^^*vv<>и^<>v*^<>vТаким образом, ответ — \"Not unique\".",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 515 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d should have exactly %d characters, but has %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at line %d, position %d\", s[j], i + 1, j + 1);\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d should have exactly %d characters, but has %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at line %d, position %d\", s[j], i + 1, j + 1);\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d should have exactly %d characters, but has %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at line %d, position %d\", s[j], i + 1, j + 1);\n        }\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize grid with empty cells\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"unique\") {\n        // Generate a grid where the tiling is unique\n        // Alternate rows of empty cells and obstacle rows\n        for (int i = 0; i < n; i++) {\n            if (i % 2 != 0) {\n                // Set entire row to obstacles\n                for (int j = 0; j < m; j++) {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    } else if (type == \"multiple\") {\n        // Generate an empty grid\n        // All cells are already '.'\n    } else if (type == \"no_solution\") {\n        // Generate a grid with an odd number of empty cells\n        int total_cells = n * m;\n        int empty_cells = total_cells;\n        if (empty_cells % 2 == 0) {\n            // Make one cell an obstacle to make empty cells count odd\n            grid[0][0] = '*';\n            empty_cells--;\n        }\n    } else if (type == \"random\") {\n        // Optionally read p (probability of obstacle)\n        double p = opt<double>(\"p\", 0.3); // Default 30% obstacles\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if (rnd.next(0.0, 1.0) < p) {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Initialize grid with empty cells\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"unique\") {\n        // Generate a grid where the tiling is unique\n        // Alternate rows of empty cells and obstacle rows\n        for (int i = 0; i < n; i++) {\n            if (i % 2 != 0) {\n                // Set entire row to obstacles\n                for (int j = 0; j < m; j++) {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    } else if (type == \"multiple\") {\n        // Generate an empty grid\n        // All cells are already '.'\n    } else if (type == \"no_solution\") {\n        // Generate a grid with an odd number of empty cells\n        int total_cells = n * m;\n        int empty_cells = total_cells;\n        if (empty_cells % 2 == 0) {\n            // Make one cell an obstacle to make empty cells count odd\n            grid[0][0] = '*';\n            empty_cells--;\n        }\n    } else if (type == \"random\") {\n        // Optionally read p (probability of obstacle)\n        double p = opt<double>(\"p\", 0.3); // Default 30% obstacles\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < m; j++) {\n                if (rnd.next(0.0, 1.0) < p) {\n                    grid[i][j] = '*';\n                }\n            }\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for(int i = 0; i < n; i++) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type unique\n./gen -n 2 -m 2 -type multiple\n./gen -n 2 -m 2 -type no_solution\n\n./gen -n 3 -m 3 -type unique\n./gen -n 3 -m 3 -type multiple\n./gen -n 3 -m 3 -type no_solution\n\n./gen -n 4 -m 4 -type unique\n./gen -n 4 -m 4 -type multiple\n./gen -n 4 -m 4 -type no_solution\n\n./gen -n 5 -m 5 -type random -p 0.1\n./gen -n 5 -m 5 -type random -p 0.3\n./gen -n 5 -m 5 -type random -p 0.5\n./gen -n 5 -m 5 -type random -p 0.7\n./gen -n 5 -m 5 -type random -p 0.9\n\n./gen -n 10 -m 10 -type unique\n./gen -n 10 -m 10 -type multiple\n./gen -n 10 -m 10 -type no_solution\n\n./gen -n 50 -m 50 -type random -p 0.2\n./gen -n 50 -m 50 -type random -p 0.5\n\n./gen -n 100 -m 100 -type unique\n./gen -n 100 -m 100 -type multiple\n./gen -n 100 -m 100 -type no_solution\n\n./gen -n 200 -m 200 -type random -p 0.3\n./gen -n 200 -m 200 -type random -p 0.6\n\n./gen -n 500 -m 500 -type unique\n./gen -n 500 -m 500 -type multiple\n./gen -n 500 -m 500 -type no_solution\n\n./gen -n 1000 -m 1000 -type unique\n./gen -n 1000 -m 1000 -type multiple\n./gen -n 1000 -m 1000 -type no_solution\n\n./gen -n 2000 -m 2000 -type random -p 0.1\n./gen -n 2000 -m 2000 -type random -p 0.4\n./gen -n 2000 -m 2000 -type random -p 0.7\n\n./gen -n 2000 -m 2000 -type unique\n./gen -n 2000 -m 2000 -type multiple\n./gen -n 2000 -m 2000 -type no_solution\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:16.527024",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "515/E",
      "title": "E. Drazil and Park",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integer n and m (3 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting number of trees and number of days, respectively. The second line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 109), the distances between consecutive trees.The third line contains n integers h1, h2, ..., hn (1 ≤ hi ≤ 109), the heights of trees.Each of following m lines contains two integers ai and bi (1 ≤ ai, bi ≤ n) describing each new day. There are always at least two different trees Drazil can choose that are not affected by children.",
      "output_spec": "OutputFor each day print the answer in a separate line.",
      "sample_tests": "ExamplesInputCopy5 32 2 2 2 23 5 2 1 41 32 24 5OutputCopy121618InputCopy3 35 1 45 1 43 32 21 1OutputCopy172211",
      "description": "E. Drazil and Park\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integer n and m (3 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting number of trees and number of days, respectively. The second line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 109), the distances between consecutive trees.The third line contains n integers h1, h2, ..., hn (1 ≤ hi ≤ 109), the heights of trees.Each of following m lines contains two integers ai and bi (1 ≤ ai, bi ≤ n) describing each new day. There are always at least two different trees Drazil can choose that are not affected by children.\n\nOutputFor each day print the answer in a separate line.\n\nInputCopy5 32 2 2 2 23 5 2 1 41 32 24 5OutputCopy121618InputCopy3 35 1 45 1 43 32 21 1OutputCopy172211\n\nInputCopy5 32 2 2 2 23 5 2 1 41 32 24 5\n\nOutputCopy121618\n\nInputCopy3 35 1 45 1 43 32 21 1\n\nOutputCopy172211",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 515 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    vector<int> d = inf.readInts(n, 1, 1000000000, \"d\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    vector<int> d = inf.readInts(n, 1, 1000000000, \"d\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    \n    vector<int> d = inf.readInts(n, 1, 1000000000, \"d\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, 1000000000, \"h\");\n    inf.readEoln();\n    \n    for (int i = 0; i < m; ++i) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n    }\n    \n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string hType = opt<string>(\"hType\", \"random\");\n    string dType = opt<string>(\"dType\", \"random\");\n    string dayType = opt<string>(\"dayType\", \"random\");\n\n    // Generate n distances di.\n    vector<int> di(n);\n    if (dType == \"constant\") {\n        int dVal = opt<int>(\"dVal\", 1);\n        for (int i = 0; i < n; ++i)\n            di[i] = dVal;\n    } else if (dType == \"max\") {\n        for (int i = 0; i < n; ++i)\n            di[i] = (int)1e9;\n    } else if (dType == \"min\") {\n        for (int i = 0; i < n; ++i)\n            di[i] = 1;\n    } else if (dType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            di[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Generate n heights hi.\n    vector<int> hi(n);\n    if (hType == \"constant\") {\n        int hVal = opt<int>(\"hVal\", 1);\n        for (int i = 0; i < n; ++i)\n            hi[i] = hVal;\n    } else if (hType == \"max\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = (int)1e9;\n    } else if (hType == \"min\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = 1;\n    } else if (hType == \"increase\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = i + 1;\n    } else if (hType == \"decrease\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = n - i;\n    } else if (hType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Generate m days ai and bi\n    vector<int> ai(m), bi(m);\n    for (int i = 0; i < m; ++i) {\n        int affected_length;\n        if (dayType == \"max_children\") {\n            // children play around n - 2 trees\n            affected_length = n - 2;\n        } else if (dayType == \"min_children\") {\n            // children play around 1 tree\n            affected_length = 1;\n        } else { // dayType == \"random\"\n            affected_length = rnd.next(1, n - 2);\n        }\n        int start = rnd.next(1, n);\n        int end = (start + affected_length - 2) % n + 1;\n        ai[i] = start;\n        bi[i] = end;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output di\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Output hi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", hi[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Output m days\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string hType = opt<string>(\"hType\", \"random\");\n    string dType = opt<string>(\"dType\", \"random\");\n    string dayType = opt<string>(\"dayType\", \"random\");\n\n    // Generate n distances di.\n    vector<int> di(n);\n    if (dType == \"constant\") {\n        int dVal = opt<int>(\"dVal\", 1);\n        for (int i = 0; i < n; ++i)\n            di[i] = dVal;\n    } else if (dType == \"max\") {\n        for (int i = 0; i < n; ++i)\n            di[i] = (int)1e9;\n    } else if (dType == \"min\") {\n        for (int i = 0; i < n; ++i)\n            di[i] = 1;\n    } else if (dType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            di[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Generate n heights hi.\n    vector<int> hi(n);\n    if (hType == \"constant\") {\n        int hVal = opt<int>(\"hVal\", 1);\n        for (int i = 0; i < n; ++i)\n            hi[i] = hVal;\n    } else if (hType == \"max\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = (int)1e9;\n    } else if (hType == \"min\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = 1;\n    } else if (hType == \"increase\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = i + 1;\n    } else if (hType == \"decrease\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = n - i;\n    } else if (hType == \"random\") {\n        for (int i = 0; i < n; ++i)\n            hi[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Generate m days ai and bi\n    vector<int> ai(m), bi(m);\n    for (int i = 0; i < m; ++i) {\n        int affected_length;\n        if (dayType == \"max_children\") {\n            // children play around n - 2 trees\n            affected_length = n - 2;\n        } else if (dayType == \"min_children\") {\n            // children play around 1 tree\n            affected_length = 1;\n        } else { // dayType == \"random\"\n            affected_length = rnd.next(1, n - 2);\n        }\n        int start = rnd.next(1, n);\n        int end = (start + affected_length - 2) % n + 1;\n        ai[i] = start;\n        bi[i] = end;\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output di\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Output hi\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", hi[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Output m days\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 1 -hType constant -hVal 1 -dType constant -dVal 1 -dayType min_children\n./gen -n 3 -m 1 -hType random -dType random -dayType random\n./gen -n 10 -m 5 -hType increase -dType random -dayType random\n./gen -n 10 -m 5 -hType decrease -dType random -dayType random\n./gen -n 100 -m 50 -hType random -dType random -dayType random\n./gen -n 100 -m 50 -hType max -dType max -dayType max_children\n./gen -n 1000 -m 500 -hType min -dType min -dayType min_children\n./gen -n 1000 -m 500 -hType random -dType constant -dVal 1 -dayType random\n./gen -n 1000 -m 500 -hType constant -hVal 1000000000 -dType random -dayType random\n./gen -n 10000 -m 5000 -hType random -dType random -dayType random\n./gen -n 10000 -m 5000 -hType increase -dType random -dayType random\n./gen -n 100000 -m 100000 -hType random -dType random -dayType random\n./gen -n 100000 -m 100000 -hType random -dType random -dayType max_children\n./gen -n 100000 -m 100000 -hType random -dType random -dayType min_children\n./gen -n 100000 -m 100000 -hType max -dType max -dayType random\n./gen -n 100000 -m 100000 -hType min -dType min -dayType random\n./gen -n 99999 -m 99999 -hType random -dType random -dayType random\n./gen -n 3 -m 1 -hType random -dType random -dayType max_children\n./gen -n 3 -m 1 -hType random -dType random -dayType min_children\n./gen -n 50000 -m 50000 -hType random -dType random -dayType random\n./gen -n 50000 -m 50000 -hType increase -dType decrease -dayType random\n./gen -n 1e5 -m 1e5 -hType random -dType random -dayType random\n./gen -n 99999 -m 49999 -hType random -dType random -dayType random\n./gen -n 50000 -m 25000 -hType increase -dType increase -dayType random\n./gen -n 50000 -m 25000 -hType decrease -dType decrease -dayType random\n./gen -n 100000 -m 100000 -hType random -dType random -dayType random\n./gen -n 3 -m 3 -hType random -dType random -dayType random\n./gen -n 100000 -m 1 -hType random -dType random -dayType random\n./gen -n 100000 -m 1 -hType max -dType max -dayType max_children\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:18.858863",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "516/A",
      "title": "A. Drazil and Factorial",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 15) — the number of digits in a.The second line contains n digits of a. There is at least one digit in a that is larger than 1. Number a may possibly contain leading zeroes.",
      "output_spec": "OutputOutput a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.",
      "sample_tests": "ExamplesInputCopy41234OutputCopy33222InputCopy3555OutputCopy555",
      "description": "A. Drazil and Factorial\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 15) — the number of digits in a.The second line contains n digits of a. There is at least one digit in a that is larger than 1. Number a may possibly contain leading zeroes.\n\nOutputOutput a maximum possible integer satisfying the conditions above. There should be no zeroes and ones in this number decimal representation.\n\nInputCopy41234OutputCopy33222InputCopy3555OutputCopy555\n\nInputCopy41234\n\nOutputCopy33222\n\nInputCopy3555\n\nOutputCopy555\n\nNoteIn the first case,",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 516 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n\n    string regexPattern = \"[0-9]{\" + to_string(n) + \"}\";\n    string a = inf.readLine(regexPattern, \"a\");\n\n    bool hasDigitLargerThan1 = false;\n    for (char c : a) {\n        if (c > '1') {\n            hasDigitLargerThan1 = true;\n            break;\n        }\n    }\n    ensuref(hasDigitLargerThan1, \"a must contain at least one digit larger than 1\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n\n    string regexPattern = \"[0-9]{\" + to_string(n) + \"}\";\n    string a = inf.readLine(regexPattern, \"a\");\n\n    bool hasDigitLargerThan1 = false;\n    for (char c : a) {\n        if (c > '1') {\n            hasDigitLargerThan1 = true;\n            break;\n        }\n    }\n    ensuref(hasDigitLargerThan1, \"a must contain at least one digit larger than 1\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 15, \"n\");\n    inf.readEoln();\n\n    string regexPattern = \"[0-9]{\" + to_string(n) + \"}\";\n    string a = inf.readLine(regexPattern, \"a\");\n\n    bool hasDigitLargerThan1 = false;\n    for (char c : a) {\n        if (c > '1') {\n            hasDigitLargerThan1 = true;\n            break;\n        }\n    }\n    ensuref(hasDigitLargerThan1, \"a must contain at least one digit larger than 1\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\npattern pnum(\"0|-?[1-9][0-9]*\");\r\n\r\nbool isNumeric(const string &p) {\r\n    return pnum.matches(p);\r\n}\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two signed huge integers\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    string ja = ans.readWord();\r\n    string pa = ouf.readWord();\r\n\r\n    if (!isNumeric(ja))\r\n        quitf(_fail, \"%s is not a valid integer\", compress(ja).c_str());\r\n\r\n    if (!ans.seekEof())\r\n        quitf(_fail, \"expected exactly one token in the answer file\");\r\n\r\n    if (!isNumeric(pa))\r\n        quitf(_pe, \"%s is not a valid integer\", compress(pa).c_str());\r\n\r\n    if (ja != pa)\r\n        quitf(_wa, \"expected '%s', found '%s'\", compress(ja).c_str(), compress(pa).c_str());\r\n\r\n    quitf(_ok, \"answer is '%s'\", compress(ja).c_str());\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> digits(n);\n\n    if (type == \"random\") {\n        // Generate n digits, at least one digit >1\n        int count_gt1 = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0,9);\n            digits[i] = d;\n            if (d > 1) \n                count_gt1++;\n        }\n        if (count_gt1 == 0) {\n            // Ensure at least one digit >1\n            int pos = rnd.next(0,n-1);\n            digits[pos] = rnd.next(2,9);\n        }\n    } else if (type == \"leading_zeros\") {\n        // Generate a number with leading zeros\n        // Random number of leading zeros\n        int num_leading_zeros = rnd.next(1, n-1);\n        int count_gt1 = 0;\n        for (int i = 0; i < num_leading_zeros; ++i)\n            digits[i] = 0;\n        for (int i = num_leading_zeros; i < n; ++i) {\n            int d = rnd.next(0,9);\n            digits[i] = d;\n            if (d >1)\n                count_gt1++;\n        }\n        if (count_gt1 == 0) {\n            // Ensure at least one digit >1\n            int pos = rnd.next(num_leading_zeros, n-1);\n            digits[pos] = rnd.next(2,9);\n        }\n    } else if (type == \"all_same\") {\n        // Generate number with all same digits\n        int d = rnd.next(2,9); // digits larger than 1\n        for (int i = 0; i < n; ++i)\n            digits[i] = d;\n    } else if (type == \"max_digits\") {\n        // Generate number with digits 9\n        for (int i = 0; i < n; ++i)\n            digits[i] = 9;\n    } else if (type == \"min_nontrivial\") {\n        // n must be 1\n        if (n != 1) {\n            fprintf(stderr, \"n must be 1 for type min_nontrivial\\n\");\n            exit(1);\n        }\n        digits[0] = rnd.next(2,9);\n    } else if (type == \"increasing\") {\n        // Generate digits increasing from 2\n        int d = 2;\n        for (int i = 0; i < n; ++i) {\n            digits[i] = d;\n            d++;\n            if (d > 9)\n                d = 2;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate digits decreasing from 9\n        int d = 9;\n        for (int i = 0; i < n; ++i) {\n            digits[i] = d;\n            d--;\n            if (d < 2)\n                d = 9;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the digits\n    for (int i = 0; i < n; ++i)\n        printf(\"%d\", digits[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> digits(n);\n\n    if (type == \"random\") {\n        // Generate n digits, at least one digit >1\n        int count_gt1 = 0;\n        for (int i = 0; i < n; ++i) {\n            int d = rnd.next(0,9);\n            digits[i] = d;\n            if (d > 1) \n                count_gt1++;\n        }\n        if (count_gt1 == 0) {\n            // Ensure at least one digit >1\n            int pos = rnd.next(0,n-1);\n            digits[pos] = rnd.next(2,9);\n        }\n    } else if (type == \"leading_zeros\") {\n        // Generate a number with leading zeros\n        // Random number of leading zeros\n        int num_leading_zeros = rnd.next(1, n-1);\n        int count_gt1 = 0;\n        for (int i = 0; i < num_leading_zeros; ++i)\n            digits[i] = 0;\n        for (int i = num_leading_zeros; i < n; ++i) {\n            int d = rnd.next(0,9);\n            digits[i] = d;\n            if (d >1)\n                count_gt1++;\n        }\n        if (count_gt1 == 0) {\n            // Ensure at least one digit >1\n            int pos = rnd.next(num_leading_zeros, n-1);\n            digits[pos] = rnd.next(2,9);\n        }\n    } else if (type == \"all_same\") {\n        // Generate number with all same digits\n        int d = rnd.next(2,9); // digits larger than 1\n        for (int i = 0; i < n; ++i)\n            digits[i] = d;\n    } else if (type == \"max_digits\") {\n        // Generate number with digits 9\n        for (int i = 0; i < n; ++i)\n            digits[i] = 9;\n    } else if (type == \"min_nontrivial\") {\n        // n must be 1\n        if (n != 1) {\n            fprintf(stderr, \"n must be 1 for type min_nontrivial\\n\");\n            exit(1);\n        }\n        digits[0] = rnd.next(2,9);\n    } else if (type == \"increasing\") {\n        // Generate digits increasing from 2\n        int d = 2;\n        for (int i = 0; i < n; ++i) {\n            digits[i] = d;\n            d++;\n            if (d > 9)\n                d = 2;\n        }\n    } else if (type == \"decreasing\") {\n        // Generate digits decreasing from 9\n        int d = 9;\n        for (int i = 0; i < n; ++i) {\n            digits[i] = d;\n            d--;\n            if (d < 2)\n                d = 9;\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output the digits\n    for (int i = 0; i < n; ++i)\n        printf(\"%d\", digits[i]);\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_nontrivial\n./gen -n 1 -type random\n./gen -n 1 -type max_digits\n./gen -n 1 -type all_same\n\n./gen -n 2 -type random\n./gen -n 2 -type leading_zeros\n./gen -n 2 -type increasing\n\n./gen -n 3 -type decreasing\n./gen -n 3 -type max_digits\n./gen -n 3 -type all_same\n\n./gen -n 5 -type random\n./gen -n 5 -type leading_zeros\n./gen -n 5 -type increasing\n\n./gen -n 8 -type decreasing\n./gen -n 8 -type max_digits\n./gen -n 8 -type all_same\n\n./gen -n 10 -type random\n./gen -n 10 -type leading_zeros\n./gen -n 10 -type increasing\n\n./gen -n 15 -type random\n./gen -n 15 -type leading_zeros\n./gen -n 15 -type increasing\n./gen -n 15 -type decreasing\n./gen -n 15 -type max_digits\n./gen -n 15 -type all_same\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:20.972942",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "516/B",
      "title": "B. Drazil and Tiles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 2000).The following n lines describe the grid rows. Character '.' denotes an empty cell, and the character '*' denotes a cell that is occupied.",
      "output_spec": "OutputIf there is no solution or the solution is not unique, you should print the string \"Not unique\".Otherwise you should print how to cover all empty cells with 1 × 2 tiles. Use characters \"<>\" to denote horizontal tiles and characters \"^v\" to denote vertical tiles. Refer to the sample test for the output format example.",
      "sample_tests": "ExamplesInputCopy3 3....*....OutputCopyNot uniqueInputCopy4 4..***...*.**....OutputCopy<>***^<>*v**<><>InputCopy2 4*..*....OutputCopy*<>*<><>InputCopy1 1.OutputCopyNot uniqueInputCopy1 1*OutputCopy*",
      "description": "B. Drazil and Tiles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 2000).The following n lines describe the grid rows. Character '.' denotes an empty cell, and the character '*' denotes a cell that is occupied.\n\nOutputIf there is no solution or the solution is not unique, you should print the string \"Not unique\".Otherwise you should print how to cover all empty cells with 1 × 2 tiles. Use characters \"<>\" to denote horizontal tiles and characters \"^v\" to denote vertical tiles. Refer to the sample test for the output format example.\n\nInputCopy3 3....*....OutputCopyNot uniqueInputCopy4 4..***...*.**....OutputCopy<>***^<>*v**<><>InputCopy2 4*..*....OutputCopy*<>*<><>InputCopy1 1.OutputCopyNot uniqueInputCopy1 1*OutputCopy*\n\nInputCopy3 3....*....\n\nOutputCopyNot unique\n\nInputCopy4 4..***...*.**....\n\nOutputCopy<>***^<>*v**<><>\n\nInputCopy2 4*..*....\n\nOutputCopy*<>*<><>\n\nInputCopy1 1.\n\nOutputCopyNot unique\n\nInputCopy1 1*\n\nOutputCopy*\n\nNoteIn the first case, there are indeed two solutions:<>^^*vv<>and^<>v*^<>vso the answer is \"Not unique\".",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 516 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[.*]{%d}\", m);\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, format(\"grid line %d\", i + 1));\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[.*]{%d}\", m);\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, format(\"grid line %d\", i + 1));\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n\n    string pattern = format(\"[.*]{%d}\", m);\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine(pattern, format(\"grid line %d\", i + 1));\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.')); // Initialize empty grid\n\n    if (type == \"random\") {\n        // Randomly assign '.' or '*' to each cell\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0, 1) == 0)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '*';\n            }\n        }\n    } else if (type == \"unique\") {\n        // Create a snake-like path to ensure unique tiling\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*'); // Fill grid with occupied cells\n\n        int x = 0, y = 0;\n        bool right = true;\n        while (x < n && y < m) {\n            grid[x][y] = '.';\n            if (right) {\n                if (y + 1 < m && grid[x][y + 1] == '*')\n                    y++;\n                else {\n                    x++;\n                    right = false;\n                }\n            } else {\n                if (y - 1 >= 0 && grid[x][y - 1] == '*')\n                    y--;\n                else {\n                    x++;\n                    right = true;\n                }\n            }\n        }\n    } else if (type == \"nonunique\") {\n        // Generate an empty grid where multiple tilings are possible\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '.'); // All cells are empty\n    } else if (type == \"nosolution\") {\n        // Create a grid with an odd number of empty cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '.'); // All cells are empty\n        if ((n * m) % 2 == 0)\n            grid[0][0] = '*'; // Occupy one cell to make empty cells count odd\n    } else if (type == \"block\") {\n        // Create a grid with isolated empty cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*'); // All cells are occupied\n\n        int numEmpty = rnd.next(1, n * m / 2);\n        set<pair<int, int>> positions;\n\n        while ((int)positions.size() < numEmpty) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            positions.insert({x, y});\n        }\n\n        for (auto pos : positions)\n            grid[pos.first][pos.second] = '.';\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.')); // Initialize empty grid\n\n    if (type == \"random\") {\n        // Randomly assign '.' or '*' to each cell\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(0, 1) == 0)\n                    grid[i][j] = '.';\n                else\n                    grid[i][j] = '*';\n            }\n        }\n    } else if (type == \"unique\") {\n        // Create a snake-like path to ensure unique tiling\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*'); // Fill grid with occupied cells\n\n        int x = 0, y = 0;\n        bool right = true;\n        while (x < n && y < m) {\n            grid[x][y] = '.';\n            if (right) {\n                if (y + 1 < m && grid[x][y + 1] == '*')\n                    y++;\n                else {\n                    x++;\n                    right = false;\n                }\n            } else {\n                if (y - 1 >= 0 && grid[x][y - 1] == '*')\n                    y--;\n                else {\n                    x++;\n                    right = true;\n                }\n            }\n        }\n    } else if (type == \"nonunique\") {\n        // Generate an empty grid where multiple tilings are possible\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '.'); // All cells are empty\n    } else if (type == \"nosolution\") {\n        // Create a grid with an odd number of empty cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '.'); // All cells are empty\n        if ((n * m) % 2 == 0)\n            grid[0][0] = '*'; // Occupy one cell to make empty cells count odd\n    } else if (type == \"block\") {\n        // Create a grid with isolated empty cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*'); // All cells are occupied\n\n        int numEmpty = rnd.next(1, n * m / 2);\n        set<pair<int, int>> positions;\n\n        while ((int)positions.size() < numEmpty) {\n            int x = rnd.next(0, n - 1);\n            int y = rnd.next(0, m - 1);\n            positions.insert({x, y});\n        }\n\n        for (auto pos : positions)\n            grid[pos.first][pos.second] = '.';\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output the grid\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -type random\n./gen -n 3 -m 3 -type unique\n./gen -n 3 -m 3 -type nonunique\n./gen -n 3 -m 3 -type nosolution\n./gen -n 3 -m 3 -type block\n\n./gen -n 10 -m 10 -type random\n./gen -n 15 -m 15 -type unique\n./gen -n 20 -m 20 -type nonunique\n./gen -n 25 -m 25 -type nosolution\n./gen -n 30 -m 30 -type block\n\n./gen -n 50 -m 100 -type random\n./gen -n 100 -m 50 -type unique\n./gen -n 100 -m 100 -type nonunique\n./gen -n 100 -m 100 -type nosolution\n./gen -n 100 -m 100 -type block\n\n./gen -n 200 -m 200 -type random\n./gen -n 500 -m 500 -type unique\n./gen -n 500 -m 500 -type nonunique\n./gen -n 500 -m 500 -type nosolution\n./gen -n 500 -m 500 -type block\n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1500 -m 1500 -type unique\n./gen -n 2000 -m 2000 -type nonunique\n./gen -n 2000 -m 2000 -type nosolution\n./gen -n 2000 -m 2000 -type block\n\n./gen -n 1 -m 2000 -type random\n./gen -n 2000 -m 1 -type unique\n./gen -n 1000 -m 2000 -type nonunique\n./gen -n 2000 -m 1000 -type nosolution\n./gen -n 2000 -m 2000 -type block\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:22.685706",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "516/C",
      "title": "C. Drazil and Park",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line contains two integer n and m (3 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting number of trees and number of days, respectively. The second line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 109), the distances between consecutive trees.The third line contains n integers h1, h2, ..., hn (1 ≤ hi ≤ 109), the heights of trees.Each of following m lines contains two integers ai and bi (1 ≤ ai, bi ≤ n) describing each new day. There are always at least two different trees Drazil can choose that are not affected by children.",
      "output_spec": "OutputFor each day print the answer in a separate line.",
      "sample_tests": "ExamplesInputCopy5 32 2 2 2 23 5 2 1 41 32 24 5OutputCopy121618InputCopy3 35 1 45 1 43 32 21 1OutputCopy172211",
      "description": "C. Drazil and Park\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integer n and m (3 ≤ n ≤ 105, 1 ≤ m ≤ 105), denoting number of trees and number of days, respectively. The second line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 109), the distances between consecutive trees.The third line contains n integers h1, h2, ..., hn (1 ≤ hi ≤ 109), the heights of trees.Each of following m lines contains two integers ai and bi (1 ≤ ai, bi ≤ n) describing each new day. There are always at least two different trees Drazil can choose that are not affected by children.\n\nOutputFor each day print the answer in a separate line.\n\nInputCopy5 32 2 2 2 23 5 2 1 41 32 24 5OutputCopy121618InputCopy3 35 1 45 1 43 32 21 1OutputCopy172211\n\nInputCopy5 32 2 2 2 23 5 2 1 41 32 24 5\n\nOutputCopy121618\n\nInputCopy3 35 1 45 1 43 32 21 1\n\nOutputCopy172211",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 516 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> d(n);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        d[i] = inf.readInt(1, 1000000000, format(\"d[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        h[i] = inf.readInt(1, 1000000000, format(\"h[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, format(\"a[%d]\", i + 1));\n        inf.readSpace();\n        int b = inf.readInt(1, n, format(\"b[%d]\", i + 1));\n        inf.readEoln();\n\n        int num_affected;\n        if (a <= b) {\n            num_affected = b - a + 1;\n        } else {\n            num_affected = n - (a - 1) + b;\n        }\n        int num_unaffected = n - num_affected;\n        ensuref(num_unaffected >= 2, \"At least two unaffected trees should exist on day %d, but only %d unaffected trees found\", i + 1, num_unaffected);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> d(n);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        d[i] = inf.readInt(1, 1000000000, format(\"d[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        h[i] = inf.readInt(1, 1000000000, format(\"h[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, format(\"a[%d]\", i + 1));\n        inf.readSpace();\n        int b = inf.readInt(1, n, format(\"b[%d]\", i + 1));\n        inf.readEoln();\n\n        int num_affected;\n        if (a <= b) {\n            num_affected = b - a + 1;\n        } else {\n            num_affected = n - (a - 1) + b;\n        }\n        int num_unaffected = n - num_affected;\n        ensuref(num_unaffected >= 2, \"At least two unaffected trees should exist on day %d, but only %d unaffected trees found\", i + 1, num_unaffected);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    vector<int> d(n);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        d[i] = inf.readInt(1, 1000000000, format(\"d[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    vector<int> h(n);\n    for (int i = 0; i < n; i++) {\n        if (i > 0) inf.readSpace();\n        h[i] = inf.readInt(1, 1000000000, format(\"h[%d]\", i + 1));\n    }\n    inf.readEoln();\n\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, format(\"a[%d]\", i + 1));\n        inf.readSpace();\n        int b = inf.readInt(1, n, format(\"b[%d]\", i + 1));\n        inf.readEoln();\n\n        int num_affected;\n        if (a <= b) {\n            num_affected = b - a + 1;\n        } else {\n            num_affected = n - (a - 1) + b;\n        }\n        int num_unaffected = n - num_affected;\n        ensuref(num_unaffected >= 2, \"At least two unaffected trees should exist on day %d, but only %d unaffected trees found\", i + 1, num_unaffected);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxh = opt<int>(\"maxh\", 1000000000);\n    int minh = opt<int>(\"minh\", 1);\n    int maxd = opt<int>(\"maxd\", 1000000000);\n    int mind = opt<int>(\"mind\", 1);\n    int cover_len = opt<int>(\"cover_len\", -1); // If not provided, we can decide based on type\n\n    if(cover_len == -1) {\n        if(type == \"max_children_area\") {\n            cover_len = n - 2;\n        } else if(type == \"min_children_area\") {\n            cover_len = 1;\n        } else { // Random or any other\n            cover_len = rnd.next(1, n - 2);\n        }\n    }\n\n    // Generate heights h[i] and distances d[i] based on the 'type'.\n    vector<int> h(n);\n    vector<int> d(n);\n\n    if(type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            h[i] = maxh;\n            d[i] = maxd;\n        }\n    } else if(type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            h[i] = minh;\n            d[i] = mind;\n        }\n    } else if(type == \"alternate\") {\n        for(int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? maxh : minh;\n            d[i] = (i % 2 == 0) ? maxd : mind;\n        }\n    } else if(type == \"equal_heights\") {\n        int hval = rnd.next(minh, maxh);\n        for(int i = 0; i < n; ++i) {\n            h[i] = hval;\n            d[i] = rnd.next(mind, maxd);\n        }\n    } else if(type == \"equal_distances\") {\n        int dval = rnd.next(mind, maxd);\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(minh, maxh);\n            d[i] = dval;\n        }\n    } else {\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(minh, maxh);\n            d[i] = rnd.next(mind, maxd);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output distances d[i]\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", d[i], (i+1 == n)?'\\n':' ');\n\n    // Output heights h[i]\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", h[i], (i+1 == n)?'\\n':' ');\n\n    // Generate ai and bi for each day\n    vector<int> ai(m), bi(m);\n    for(int i = 0; i < m; ++i) {\n        int ai0 = rnd.next(0, n - 1); // ai in 0-based index\n        int len = cover_len;\n        int dir = rnd.next(0,1); // 0 for forward, 1 for backward\n        int bi0;\n        if (dir == 0) {\n            // Moving forward\n            bi0 = (ai0 + len - 1) % n;\n        } else {\n            // Moving backward\n            bi0 = (ai0 - (len -1) + n) % n;\n        }\n\n        // Now convert back to 1-based indices\n        ai[i] = ai0 +1;\n        bi[i] = bi0 +1;\n    }\n\n    // Output ai and bi\n    for(int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Parse parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    int maxh = opt<int>(\"maxh\", 1000000000);\n    int minh = opt<int>(\"minh\", 1);\n    int maxd = opt<int>(\"maxd\", 1000000000);\n    int mind = opt<int>(\"mind\", 1);\n    int cover_len = opt<int>(\"cover_len\", -1); // If not provided, we can decide based on type\n\n    if(cover_len == -1) {\n        if(type == \"max_children_area\") {\n            cover_len = n - 2;\n        } else if(type == \"min_children_area\") {\n            cover_len = 1;\n        } else { // Random or any other\n            cover_len = rnd.next(1, n - 2);\n        }\n    }\n\n    // Generate heights h[i] and distances d[i] based on the 'type'.\n    vector<int> h(n);\n    vector<int> d(n);\n\n    if(type == \"max\") {\n        for(int i = 0; i < n; ++i) {\n            h[i] = maxh;\n            d[i] = maxd;\n        }\n    } else if(type == \"min\") {\n        for(int i = 0; i < n; ++i) {\n            h[i] = minh;\n            d[i] = mind;\n        }\n    } else if(type == \"alternate\") {\n        for(int i = 0; i < n; ++i) {\n            h[i] = (i % 2 == 0) ? maxh : minh;\n            d[i] = (i % 2 == 0) ? maxd : mind;\n        }\n    } else if(type == \"equal_heights\") {\n        int hval = rnd.next(minh, maxh);\n        for(int i = 0; i < n; ++i) {\n            h[i] = hval;\n            d[i] = rnd.next(mind, maxd);\n        }\n    } else if(type == \"equal_distances\") {\n        int dval = rnd.next(mind, maxd);\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(minh, maxh);\n            d[i] = dval;\n        }\n    } else {\n        for(int i = 0; i < n; ++i) {\n            h[i] = rnd.next(minh, maxh);\n            d[i] = rnd.next(mind, maxd);\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    // Output distances d[i]\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", d[i], (i+1 == n)?'\\n':' ');\n\n    // Output heights h[i]\n    for(int i = 0; i < n; ++i)\n        printf(\"%d%c\", h[i], (i+1 == n)?'\\n':' ');\n\n    // Generate ai and bi for each day\n    vector<int> ai(m), bi(m);\n    for(int i = 0; i < m; ++i) {\n        int ai0 = rnd.next(0, n - 1); // ai in 0-based index\n        int len = cover_len;\n        int dir = rnd.next(0,1); // 0 for forward, 1 for backward\n        int bi0;\n        if (dir == 0) {\n            // Moving forward\n            bi0 = (ai0 + len - 1) % n;\n        } else {\n            // Moving backward\n            bi0 = (ai0 - (len -1) + n) % n;\n        }\n\n        // Now convert back to 1-based indices\n        ai[i] = ai0 +1;\n        bi[i] = bi0 +1;\n    }\n\n    // Output ai and bi\n    for(int i = 0; i < m; ++i)\n        printf(\"%d %d\\n\", ai[i], bi[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 1 -type min\n./gen -n 100000 -m 100000 -type max\n./gen -n 50000 -m 50000 -type random\n\n./gen -n 100000 -m 100000 -type equal_heights -maxh 1\n./gen -n 100000 -m 100000 -type equal_heights -maxh 1000000000\n./gen -n 100000 -m 100000 -type equal_distances -maxd 1\n./gen -n 100000 -m 100000 -type equal_distances -maxd 1000000000\n\n./gen -n 100000 -m 10 -type min_children_area\n./gen -n 100000 -m 10 -type max_children_area\n\n./gen -n 1000 -m 1000 -type alternate\n./gen -n 99999 -m 99999 -type random\n\n./gen -n 50000 -m 50000 -type random -cover_len 1\n\n./gen -n 50000 -m 50000 -type random\n\n./gen -n 10000 -m 20000 -type random\n./gen -n 20000 -m 10000 -type random\n./gen -n 30000 -m 30000 -type random\n\n./gen -n 100000 -m 100000 -type random -cover_len 1\n./gen -n 100000 -m 100000 -type random -cover_len 99998\n\n./gen -n 98765 -m 12345 -type random\n./gen -n 54321 -m 67890 -type random\n./gen -n 1000 -m 1000 -type random\n\n./gen -n 100000 -m 100000 -type random -maxh 1 -minh 1 -maxd 1 -mind 1\n./gen -n 100000 -m 100000 -type random -maxh 1000000000 -minh 1000000000 -maxd 1000000000 -mind 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:24.749683",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "516/D",
      "title": "D. Drazil and Morning Exercise",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains one integer n denoting how many rooms there are in the hole (2 ≤ n ≤ 105).Then there are n - 1 lines following. Each of these lines contains three integers x, y, v (1 ≤ x, y ≤ n, 1 ≤ v ≤ 106) denoting there is a small tunnel between room x and room y that takes time v to pass. Suppose that the time for an earthworm to get out to the ground from any leaf room is the same.The next line contains an integer q (1 ≤ q ≤ 50), denoting the number of different value of l you need to process.The last line contains q numbers, each number denoting a value of l (1 ≤ l ≤ 1011).",
      "output_spec": "OutputYou should print q lines. Each line should contain one integer denoting the answer for a corresponding value of l.",
      "sample_tests": "ExamplesInputCopy51 2 32 3 44 5 33 4 251 2 3 4 5OutputCopy13335InputCopy125 9 32 1 711 7 26 5 52 5 36 7 21 4 48 5 71 3 811 12 310 8 21013 14 14 13 13 4 6 7 2 1OutputCopy101010101033521",
      "description": "D. Drazil and Morning Exercise\n\ntime limit per test3.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains one integer n denoting how many rooms there are in the hole (2 ≤ n ≤ 105).Then there are n - 1 lines following. Each of these lines contains three integers x, y, v (1 ≤ x, y ≤ n, 1 ≤ v ≤ 106) denoting there is a small tunnel between room x and room y that takes time v to pass. Suppose that the time for an earthworm to get out to the ground from any leaf room is the same.The next line contains an integer q (1 ≤ q ≤ 50), denoting the number of different value of l you need to process.The last line contains q numbers, each number denoting a value of l (1 ≤ l ≤ 1011).\n\nOutputYou should print q lines. Each line should contain one integer denoting the answer for a corresponding value of l.\n\nInputCopy51 2 32 3 44 5 33 4 251 2 3 4 5OutputCopy13335InputCopy125 9 32 1 711 7 26 5 52 5 36 7 21 4 48 5 71 3 811 12 310 8 21013 14 14 13 13 4 6 7 2 1OutputCopy101010101033521\n\nInputCopy51 2 32 3 44 5 33 4 251 2 3 4 5\n\nOutputCopy13335\n\nInputCopy125 9 32 1 711 7 26 5 52 5 36 7 21 4 48 5 71 3 811 12 310 8 21013 14 14 13 13 4 6 7 2 1\n\nOutputCopy101010101033521\n\nNoteFor the first sample the hole looks like the following. Rooms 1 and 5 are leaves, so they contain a vertical tunnel connecting them to the ground. The lengths of farthest path from rooms 1 – 5 to the ground are 12, 9, 7, 9, 12 respectively. If l = 1, we may only choose any single room. If l = 2..4, we may choose rooms 2, 3, and 4 as the answer. If l = 5, we may choose all rooms.",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Codeforces Round #292 - Codeforces &nbsp; Enter | Register Home Top Catalog Contests Gym Problemset Groups Rating Edu API Calendar Help Rayan Codeforces and Polygon may be unavailable from August 25, 16:30 (UTC) to August 26, 6:00 (UTC) due to technical maintenance. ×",
          "author": "Unknown",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 268
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 516 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> parent(n + 1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n    function<int(int)> find = [&](int x) {\n        if(parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for(int i = 0; i < n - 1; ++i){\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, 1000000, \"v_i\");\n        inf.readEoln();\n\n        int xroot = find(x);\n        int yroot = find(y);\n        ensuref(xroot != yroot, \"Graph is not a tree, found cycle at edge %d\", i + 1);\n        parent[xroot] = yroot;\n    }\n    int q = inf.readInt(1, 50, \"q\");\n    inf.readEoln();\n    vector<long long> l = inf.readLongs(q, 1, 100000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> parent(n + 1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n    function<int(int)> find = [&](int x) {\n        if(parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for(int i = 0; i < n - 1; ++i){\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, 1000000, \"v_i\");\n        inf.readEoln();\n\n        int xroot = find(x);\n        int yroot = find(y);\n        ensuref(xroot != yroot, \"Graph is not a tree, found cycle at edge %d\", i + 1);\n        parent[xroot] = yroot;\n    }\n    int q = inf.readInt(1, 50, \"q\");\n    inf.readEoln();\n    vector<long long> l = inf.readLongs(q, 1, 100000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n    vector<int> parent(n + 1);\n    for(int i = 1; i <= n; i++) parent[i] = i;\n    function<int(int)> find = [&](int x) {\n        if(parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    };\n\n    for(int i = 0; i < n - 1; ++i){\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, n, \"y_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, 1000000, \"v_i\");\n        inf.readEoln();\n\n        int xroot = find(x);\n        int yroot = find(y);\n        ensuref(xroot != yroot, \"Graph is not a tree, found cycle at edge %d\", i + 1);\n        parent[xroot] = yroot;\n    }\n    int q = inf.readInt(1, 50, \"q\");\n    inf.readEoln();\n    vector<long long> l = inf.readLongs(q, 1, 100000000000LL);\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of nodes\n    string treeType = opt<string>(\"treeType\", \"random\"); // type of tree\n    string weightType = opt<string>(\"weightType\", \"random\"); // type of edge weights\n    int q = opt<int>(\"q\", rnd.next(1, 50)); // number of queries\n    string lType = opt<string>(\"lType\", \"random\"); // type of l values\n\n    // Generate tree edges\n    vector<pair<int, int>> edges;\n    if (treeType == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (treeType == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (treeType == \"binary\") {\n        // Balanced binary tree\n        vector<int> nodes;\n        nodes.push_back(1);\n        int cur = 2;\n        while (cur <= n) {\n            vector<int> next_level;\n            for (int parent : nodes) {\n                if (cur > n) break;\n                edges.push_back({parent, cur});\n                next_level.push_back(cur);\n                ++cur;\n                if (cur > n) break;\n                edges.push_back({parent, cur});\n                next_level.push_back(cur);\n                ++cur;\n            }\n            nodes = next_level;\n        }\n    } else if (treeType == \"unbalanced\") {\n        // Unbalanced tree\n        int k = n / 2;\n        for (int i = 2; i <= k; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        for (int i = k + 1; i <= n; ++i) {\n            int u = rnd.next(1, k);\n            edges.push_back({u, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    }\n\n    // Generate edge weights\n    vector<int> weights;\n    if (weightType == \"constant\") {\n        int w = opt<int>(\"weightValue\", 1); // default weight value is 1\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights.push_back(w);\n        }\n    } else if (weightType == \"random\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights.push_back(rnd.next(1, 1000000));\n        }\n    } else if (weightType == \"skewed\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            if (rnd.next(0, 1) == 0) {\n                weights.push_back(1);\n            } else {\n                weights.push_back(1000000);\n            }\n        }\n    } else {\n        // Default to random\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights.push_back(rnd.next(1, 1000000));\n        }\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Apply permutation to edges\n    for (size_t i = 0; i < edges.size(); ++i) {\n        edges[i].first = perm[edges[i].first];\n        edges[i].second = perm[edges[i].second];\n    }\n\n    // Shuffle edges\n    vector<tuple<int, int, int>> finalEdges;\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int x = edges[i].first;\n        int y = edges[i].second;\n        int w = weights[i];\n        finalEdges.emplace_back(x, y, w);\n    }\n    shuffle(finalEdges.begin(), finalEdges.end());\n\n    // Generate l values\n    vector<long long> ls;\n    if (lType == \"min\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(1);\n        }\n    } else if (lType == \"max\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(100000000000LL);\n        }\n    } else if (lType == \"small\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(rnd.next(1LL, 100LL));\n        }\n    } else if (lType == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(rnd.next(100000000LL, 100000000000LL));\n        }\n    } else {\n        // \"random\"\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(rnd.next(1LL, 100000000000LL));\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < finalEdges.size(); ++i) {\n        int x = get<0>(finalEdges[i]);\n        int y = get<1>(finalEdges[i]);\n        int v = get<2>(finalEdges[i]);\n        printf(\"%d %d %d\\n\", x, y, v);\n    }\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%lld\", ls[i]);\n        if (i + 1 < q) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // number of nodes\n    string treeType = opt<string>(\"treeType\", \"random\"); // type of tree\n    string weightType = opt<string>(\"weightType\", \"random\"); // type of edge weights\n    int q = opt<int>(\"q\", rnd.next(1, 50)); // number of queries\n    string lType = opt<string>(\"lType\", \"random\"); // type of l values\n\n    // Generate tree edges\n    vector<pair<int, int>> edges;\n    if (treeType == \"chain\") {\n        // Chain tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (treeType == \"star\") {\n        // Star tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (treeType == \"binary\") {\n        // Balanced binary tree\n        vector<int> nodes;\n        nodes.push_back(1);\n        int cur = 2;\n        while (cur <= n) {\n            vector<int> next_level;\n            for (int parent : nodes) {\n                if (cur > n) break;\n                edges.push_back({parent, cur});\n                next_level.push_back(cur);\n                ++cur;\n                if (cur > n) break;\n                edges.push_back({parent, cur});\n                next_level.push_back(cur);\n                ++cur;\n            }\n            nodes = next_level;\n        }\n    } else if (treeType == \"unbalanced\") {\n        // Unbalanced tree\n        int k = n / 2;\n        for (int i = 2; i <= k; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        for (int i = k + 1; i <= n; ++i) {\n            int u = rnd.next(1, k);\n            edges.push_back({u, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n    }\n\n    // Generate edge weights\n    vector<int> weights;\n    if (weightType == \"constant\") {\n        int w = opt<int>(\"weightValue\", 1); // default weight value is 1\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights.push_back(w);\n        }\n    } else if (weightType == \"random\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights.push_back(rnd.next(1, 1000000));\n        }\n    } else if (weightType == \"skewed\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            if (rnd.next(0, 1) == 0) {\n                weights.push_back(1);\n            } else {\n                weights.push_back(1000000);\n            }\n        }\n    } else {\n        // Default to random\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights.push_back(rnd.next(1, 1000000));\n        }\n    }\n\n    // Shuffle node labels\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Apply permutation to edges\n    for (size_t i = 0; i < edges.size(); ++i) {\n        edges[i].first = perm[edges[i].first];\n        edges[i].second = perm[edges[i].second];\n    }\n\n    // Shuffle edges\n    vector<tuple<int, int, int>> finalEdges;\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int x = edges[i].first;\n        int y = edges[i].second;\n        int w = weights[i];\n        finalEdges.emplace_back(x, y, w);\n    }\n    shuffle(finalEdges.begin(), finalEdges.end());\n\n    // Generate l values\n    vector<long long> ls;\n    if (lType == \"min\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(1);\n        }\n    } else if (lType == \"max\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(100000000000LL);\n        }\n    } else if (lType == \"small\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(rnd.next(1LL, 100LL));\n        }\n    } else if (lType == \"large\") {\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(rnd.next(100000000LL, 100000000000LL));\n        }\n    } else {\n        // \"random\"\n        for (int i = 0; i < q; ++i) {\n            ls.push_back(rnd.next(1LL, 100000000000LL));\n        }\n    }\n\n    // Output the data\n    printf(\"%d\\n\", n);\n    for (size_t i = 0; i < finalEdges.size(); ++i) {\n        int x = get<0>(finalEdges[i]);\n        int y = get<1>(finalEdges[i]);\n        int v = get<2>(finalEdges[i]);\n        printf(\"%d %d %d\\n\", x, y, v);\n    }\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i) {\n        printf(\"%lld\", ls[i]);\n        if (i + 1 < q) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -treeType chain -q 1 -lType min\n./gen -n 2 -treeType chain -q 1 -lType max\n./gen -n 5 -treeType star -q 5 -lType small\n./gen -n 10 -treeType random -q 10 -lType random\n./gen -n 1000 -treeType chain -weightType constant -q 10 -lType small\n./gen -n 1000 -treeType chain -weightType constant -q 10 -lType large\n./gen -n 5000 -treeType star -weightType random -q 50 -lType min\n./gen -n 10000 -treeType binary -weightType skewed -q 50 -lType small\n./gen -n 20000 -treeType random -weightType random -q 45 -lType random\n./gen -n 30000 -treeType unbalanced -weightType constant -q 25 -lType large\n./gen -n 40000 -treeType unbalanced -weightType skewed -q 25 -lType small\n./gen -n 50000 -treeType chain -weightType constant -q 30 -lType random\n./gen -n 60000 -treeType star -weightType random -q 50 -lType random\n./gen -n 70000 -treeType random -weightType random -q 50 -lType random\n./gen -n 80000 -treeType unbalanced -weightType constant -q 50 -lType small\n./gen -n 90000 -treeType random -weightType random -q 50 -lType large\n./gen -n 100000 -treeType chain -weightType constant -q 50 -lType max\n./gen -n 100000 -treeType star -weightType random -q 50 -lType min\n./gen -n 99999 -treeType random -weightType random -q 50 -lType small\n./gen -n 100000 -treeType binary -weightType skewed -q 50 -lType small\n./gen -n 100000 -treeType random -weightType random -q 1 -lType random\n./gen -n 2 -treeType star -q 50 -lType random\n./gen -n 100000 -treeType chain -q 50 -lType small\n./gen -n 2 -treeType chain -q 50 -lType random\n./gen -n 100000 -treeType random -weightType skewed -q 50 -lType small\n./gen -n 75000 -treeType unbalanced -weightType skewed -q 50 -lType small\n./gen -n 50000 -treeType random -weightType random -q 50 -lType random\n./gen -n 50000 -treeType chain -weightType constant -q 30 -lType random\n./gen -n 50000 -treeType star -weightType random -q 30 -lType random\n./gen -n 100000 -treeType random -weightType skewed -q 50 -lType small\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:26.798105",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "516/E",
      "title": "E. Drazil and His Happy Friends",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test4 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integer n and m (1 ≤ n, m ≤ 109).The second line contains integer b (0 ≤ b ≤ min(n, 105)), denoting the number of happy boys among friends of Drazil, and then follow b distinct integers x1, x2, ..., xb (0 ≤ xi < n), denoting the list of indices of happy boys.The third line conatins integer g (0 ≤ g ≤ min(m, 105)), denoting the number of happy girls among friends of Drazil, and then follow g distinct integers y1, y2, ... , yg (0 ≤ yj < m), denoting the list of indices of happy girls.It is guaranteed that there is at least one person that is unhappy among his friends.",
      "output_spec": "OutputPrint the number of the first day that all friends of Drazil become happy. If this day won't come at all, you print -1.",
      "sample_tests": "ExamplesInputCopy2 301 0OutputCopy4InputCopy2 41 01 2OutputCopy-1InputCopy2 31 01 1OutputCopy2InputCopy99999 1000002 514 4152 50216 61205OutputCopy4970100515",
      "description": "E. Drazil and His Happy Friends\n\ntime limit per test4 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integer n and m (1 ≤ n, m ≤ 109).The second line contains integer b (0 ≤ b ≤ min(n, 105)), denoting the number of happy boys among friends of Drazil, and then follow b distinct integers x1, x2, ..., xb (0 ≤ xi < n), denoting the list of indices of happy boys.The third line conatins integer g (0 ≤ g ≤ min(m, 105)), denoting the number of happy girls among friends of Drazil, and then follow g distinct integers y1, y2, ... , yg (0 ≤ yj < m), denoting the list of indices of happy girls.It is guaranteed that there is at least one person that is unhappy among his friends.\n\nOutputPrint the number of the first day that all friends of Drazil become happy. If this day won't come at all, you print -1.\n\nInputCopy2 301 0OutputCopy4InputCopy2 41 01 2OutputCopy-1InputCopy2 31 01 1OutputCopy2InputCopy99999 1000002 514 4152 50216 61205OutputCopy4970100515\n\nInputCopy2 301 0\n\nOutputCopy4\n\nInputCopy2 41 01 2\n\nOutputCopy-1\n\nInputCopy2 31 01 1\n\nOutputCopy2\n\nInputCopy99999 1000002 514 4152 50216 61205\n\nOutputCopy4970100515\n\nNoteBy  we define the remainder of integer division of i by k.In first sample case:   On the 0-th day, Drazil invites 0-th boy and 0-th girl. Because 0-th girl is happy at the beginning, 0-th boy become happy at this day.  On the 1-st day, Drazil invites 1-st boy and 1-st girl. They are both unhappy, so nothing changes at this day.  On the 2-nd day, Drazil invites 0-th boy and 2-nd girl. Because 0-th boy is already happy he makes 2-nd girl become happy at this day.  On the 3-rd day, Drazil invites 1-st boy and 0-th girl. 0-th girl is happy, so she makes 1-st boy happy.  On the 4-th day, Drazil invites 0-th boy and 1-st girl. 0-th boy is happy, so he makes the 1-st girl happy. So, all friends become happy at this moment.",
      "solutions": [
        {
          "title": "Codeforces Round #292 - Codeforces",
          "content": "Hello, everyone! Codeforces Round #292 will be held at Feb/17/2015 19:30 MSK. We're looking forward to your participation!The problems are from dreamoon_love_AA, and thanks Shik for some discussion. Also we want to thank Zlobober for helping me prepare the round, AlexFetisov and winger for testing this round , Delinur for translating the statement into Russian, and MikeMirzayanov for Codeforces and Polygon.This is first time I provide all problems for a Codeforces round. I hope you'll find it interesting! Please read all problem statements and discover what the main character drazil do in those problems for he's really cute =)Finally, I would like to ask sorry_dreamoon to participate this round. I believe everyone have the same curiosity as me about your behavior in Dreamoon's round =) May I have the honor of inviting you?Update1 : Because problems of this round are hard to determine their difficulty, We will use Dynamic score for this round. Then the order of problems is from easy to hard by sense of me and testers.Update2 : Due to technical reasons we have to move round on five minutes.Update3 : Congratulation to our winners:Div 1: Haghani sorry_dreamoon Endagorion jcvb xyz111 Also, special congrats on rng_58, who solved problem E in Div.1, which anyone else could not solve.Div 2: EarthQuito I.Smirn0ff zclimber Chipe1 tylerbrazill Between them, EarthQuito is the only person who solve all problems!Update4 : link to editorial",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1449
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces",
          "content": "Thanks to johnathan79717 fo polish my words.515-A Drazil and DateIf Drazil chooses the shortest path from (0,0) to (a,b), it takes |a| + |b| steps.So we know that all numbers less than |a| + |b| are impossible to be the number of steps that Drazil took.Now consider when the number of steps is not less than |a| + |b|.When Drazil arrives at (a, b), he can take two more steps such as (a, b) -> (a, b + 1) -> (a, b) to remain at the same position.So we know that for all s such that s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0, there exists a way for Drazil to get to (a, b) in exactly s steps.The last part we should prove is that it's impossible for Drazil to arrive at (a,b) in exactly s steps when (s - (|a| + |b|))%2 = 1.We can color all positions (x, y) where (x + y)%2 = 0 as white and color other points as black.After each step, the color of the position you're at always changes.So we know that it's impossible for Drazil to get to (a, b) in odd/even steps if the color of (a, b) is white/black.Conclusion: If s ≥ |a| + |b| and (s - (|a| + |b|))%2 = 0 print \"Yes\", Otherwise print \"No\".Time Complexity: O(1).author's code515-B Drazil and His Happy FriendsYou may notice that Drazil invites his friends periodically, and the period of invitation patterns is at most n * m (because there are only n * m possible pairs of boys and girls).So if no one changes from unhappy to happy in consecutive n * m days, there won't be any changes anymore since then.We can simulate the process of having dinner until there are no status changes in consecutive n * m days.Because there are only n+m people, it's easy to prove the simulation requires O((n + m) * n * m) days.But in fact, the simulation takes only O(n * m) days.(More accurately, the bound is (min(n, m) + 1) * (max(n, m) - 1) )What happens? You can do some experiments by yourself. =) (you can suppose that only one person is happy in the beginning.)In fact, this problem can be solved in O(n + m).Let g be the greatest common divisor of n and m. If the i-th person is happy, then all people with number x satisfying will become happy some day because of this person.So for each 0 ≤ i ≤ g - 1, we only need to check if there exists at least one person whose number mod g is i and is happy.If it exists for all i, the answer is 'Yes', otherwise the answer is 'No'.author's code515-C Drazil and FactorialConclusion first:First, we transform each digit of the original number as follows:0, 1 -> empty2 -> 23 -> 34 -> 3225 -> 56 -> 537 -> 78 -> 72229 -> 7332Then, sort all digits in decreasing order as a new number, then it will be the answer.Proof:We can observe that our answer won't contain digits 4,6,8,9, because we can always transform digits 4,6,8,9 to more digits as in the conclusion, and it makes the number larger.Then, how can we make sure that the result is the largest after this transformation?We can prove the following lemma:For any positive integer x, if it can be written as the form (2!)c2 * (3!)c3 * (5!)c5 * (7!)c7, there will be only one unique way.Suppose that there exists two ways to write down x in this form, we can assume that the two ways are (2!)a2 * (3!)a3 * (5!)a5 * (7!)a7 and (2!)b2 * (3!)b3 * (5!)b5 * (7!)b7.We find the largest i such that ai ≠ bi, Then we know there exists at least one prime number whose factor is different in the two ways.But according to the Fundamental Theorem of Arithmetic, there is only one prime factorization of each integer. So we get a contradiction.After getting the result, we don't need to worry about other numbers being larger than ours.Time Complexity: O(n).author's code515-D Drazil and TilesAgain we give conclusion first: First, view each cell as a vertex and connect two adjacent cells by an edge.Then, build a queue and push all vertices of degree 1 in it.Finally, in each iteration, we pop a vertex from the queue until the queue is empty. If the vertex is used, go to the next iteration. Otherwise, we put a tile on the vertex and its adjacent vertex, and erase these two vertices from the graph. If it yields a new vertex with degree 1, push it into the queue.When the queue is empty, if there are still some cells not covered by any tiles, the answer will be \"Not unique.\"It's easy to understand that if we can put tiles on all cells by the above steps, the result is correct. But how about the remaining cases?We will prove that when the degrees of all vertices are at least two, the solution is never unique.Suppose there is at least one solution.According to this solution, we can color those edges covered by tiles as black and color other edges as white.We can always find a cycle without any adjacent edges having the same colors. (I'll leave it as an exercise. You should notice that the graph is a bipartite graph first.)Then we can move the tiles from black edges to white edges.So if there is at least one solution, there are in fact at least two solutions.Time Complexity: O(nm)author's code515-E Drazil and ParkThere are many methods for this problem. I'll only explain the one that I used.Let's split a circle at some point (for example between 1 and n) and draw a picture twice (i. e. 1 2 3 ... n 1 2 3 ... n), thus changing the problem from a circle to a line.Remember that if two trees Drazil chooses are x and y, the energy he consumes is dx + dx + 1 + ... + dy - 1 + 2 * (hx + hy).Now rewrite this formula to (d1 + d2 + ... + dy - 1 + 2 * hy) + (2 * hx - (d1 + d2 + ... + dx - 1))Denote (d1 + d2 + ... + dk - 1 + 2 * hk) as Rk and denote (2 * hk - (d1 + d2 + ... + dk - 1)) as LkWhen a query about range [a, b] comes (The range [a, b] is where Drazil can choose, but not the range where the children are playing), it's equivalent to querying the maximum value of Lu + Rv, where u and v are in [a, b] and u < v.Another important thing is that Lu + Rv always bigger than Lv + Ru when u < v.So we can almost solve the problem just by finding the maximum value of Lu and Rv by RMQ separately and sum them up.However, there is a special case: u = v, but we can handle it by making RMQ find the two maximum values.Time Complexity: O(n + m).author's code (implement with )More information about RMQ: editorial from Topcoder516-D Drazil and Morning ExerciseWe can use dfs twice to get the farthest distance from each node to any leaves (detail omitted here), and denote the longest distance from the i-th node to any leaves as di.Then we choose a node with minimum value of di as the root. We will find that for any node x, dx isn't greater than dy for any node y in the subtree of node x.Next, we solve the problem when there's only one query of L. In all valid groups of nodes, where node x is the nearest to the root, obviously we can choose all nodes with di ≤ dx + L into the group. Now we want to enumerate all nodes as the nearest node to the root. We denote the group of nodes generated from node i as Gi.We can do it in using dfs only once. (if the length of every edge is 1, we can do it in O(n))Imagine that Gi will almost be as same as the union of all Gj where node j is a child of node i, but some nodes which are too far from node i are kicked out. Each node will be kicked out from the groups we considered at most once in the whole process. Now we want to know when it happens. We solve it as follows: When we do dfs, we reserve a stack to record which nodes we have visited and still need to come back to. Yes, it's just like the implementation of recursive functions. Then we can just use binary search to find the node in the stack that when we go back to it, the current node will be kicked out (the closest node with |dx - di| ≥ L).So the time complexity of the above algorithm is Now we provide another algorithm with O(qnα(n) + nlog(n)) by union find. (Thanks Shik for providing this method.)First, sort all nodes by di.Then for each query, consider each node one by one from larger di's to smaller di's.At the beginning, set each node as a group of its own. We also need to record how many nodes each group contains.When handling a node x, union all groups of itself and its children. At the same time, for each node j with dj > dx + L, we minus 1 from the record of how many nodes j's group has.By doing these, we can get the number of nodes j in x's subtree with dj <  = dx + L. That's exactly what we want to know in the last algorithm.author's code (implement with O(qnα(n) + nlog(n))))516-E Drazil and His Happy FriendsSimplifying this question, suppose that n and m are coprime. If n and m are not coprime and the gcd of n and m is g, then we can divide all people into g groups by the values of their id mod g and find the maximum answer between them. Obviously, If there is at least one group of friends which are all unhappy in the beginning, the answer is -1.Now we determine the last one becoming happy, for boys and girls separately.In fact, there's an easy way to explain this problem — finding the shortest path! View all friends as points, and add another point as the source. For all friends, we will view the distance from the source as the time becoming happy. And define two types of edges.(1)There is a fact: If a girl x become happy in time t, then the girl (x + n)%m will become happy in time t + n. So we can build a directed edge from point x to (x + n)%m with length n. Similar for boys.(2)If the i-th boy/girlfriend is happy originally, we can connect it to the source with an edge of length i. At the same time, we also connect the source to i%n-th boy(i%m for girl) with an edge of length i. You can imagine that the same gender of friends form a cycle. (eg. the (i * m)%n-th boy is connected to the ((i + 1) * m)%n)-th boy for i from 0 to n - 1)With these two types of edges, we can find that if a friend is unhappy originally, he/she will become happy at the time value which is the length of the shortest path from the source.The only question is that there are too many points and edges!We can solve this problem by considering only some \"important\" points. Points connected by the second type of edges. Points connected to important points in 1., by the first type of edges. And we can combine some consecutive edges of the first type to a new edge. The group of edges is the maximal edges that contain deleted points.(These deleted points always form a line).Finally we find the maximum value of the shortest path from the source to these friends which is unhappy originally in the reduced graph.Time complexity: author's code",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16468",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 516 和字母"
          },
          "content_length": 10431
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #292 - Codeforces - Code 1",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 2",
          "code": "may be not :D\nUPD: maybe yes :|",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 3",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 4",
          "code": "<><>*\n^**<>\nv***^\n<><>v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 5",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 6",
          "code": "^<>^*\nv**v^\n^***v\nv<><>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 7",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 8",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 9",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 10",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 11",
          "code": "ios_base::sync_with_stdio(0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 12",
          "code": "ios_base::sync_with_stdio(0)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 13",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 14",
          "code": "for(i=0; i<n; i++){\n        for(j=i; j<(i+m); j+=n){\n            graph[i].pb(n+(j%m));\n            graph[n+(j%m)].pb(i);\n        }\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 15",
          "code": "arr[index++] = 7;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 16",
          "code": "Queue.add(new Point(x, y))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 - Codeforces - Code 17",
          "code": "Queue.add(x); Queue.add(y);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16446",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 1",
          "code": "Time Complexity: O(n+m).",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 2",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 3",
          "code": "12 <-> 9 <-> 7 <-> 9 <-> 12",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 4",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 5",
          "code": "cin.sync_with_stdio(false)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 6",
          "code": "boys[Bindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 7",
          "code": "girls[Gindex]== true;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 8",
          "code": "There are another import thing is Lu + Rv always bigger than Lv + Ru when u < v.",
          "language": "Python",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 9",
          "code": "So we can almost just find the maximum value of Lu and Rv by RMQ separately and sum them up.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 10",
          "code": "x, y and x > v",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 11",
          "code": "Lx + Ry > Lu + Rv",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 12",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #292 Editorial - Codeforces - Code 13",
          "code": "First, view each cell as a vertex and connect two adjacent cells by an edge.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16468",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\"); // n in [1, 1e9]\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\"); // m in [1, 1e9]\n    inf.readEoln();\n\n    int b_limit = min(n, 100000);\n    int b = inf.readInt(0, b_limit, \"b\"); // b in [0, min(n,1e5)]\n    vector<int> xs;\n    if (b == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        xs = inf.readInts(b, 0, n - 1, \"xi\");\n        inf.readEoln();\n        set<int> xs_set(xs.begin(), xs.end());\n        ensuref((int)xs_set.size() == b, \"xi must be distinct\");\n    }\n\n    int g_limit = min(m, 100000);\n    int g = inf.readInt(0, g_limit, \"g\"); // g in [0, min(m,1e5)]\n    vector<int> ys;\n    if (g == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        ys = inf.readInts(g, 0, m - 1, \"yj\");\n        inf.readEoln();\n        set<int> ys_set(ys.begin(), ys.end());\n        ensuref((int)ys_set.size() == g, \"yj must be distinct\");\n    }\n\n    long long total_friends = (long long)n + (long long)m;\n    long long happy_friends = (long long)b + (long long)g;\n    ensuref(happy_friends < total_friends, \"There must be at least one unhappy person among his friends\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\"); // n in [1, 1e9]\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\"); // m in [1, 1e9]\n    inf.readEoln();\n\n    int b_limit = min(n, 100000);\n    int b = inf.readInt(0, b_limit, \"b\"); // b in [0, min(n,1e5)]\n    vector<int> xs;\n    if (b == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        xs = inf.readInts(b, 0, n - 1, \"xi\");\n        inf.readEoln();\n        set<int> xs_set(xs.begin(), xs.end());\n        ensuref((int)xs_set.size() == b, \"xi must be distinct\");\n    }\n\n    int g_limit = min(m, 100000);\n    int g = inf.readInt(0, g_limit, \"g\"); // g in [0, min(m,1e5)]\n    vector<int> ys;\n    if (g == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        ys = inf.readInts(g, 0, m - 1, \"yj\");\n        inf.readEoln();\n        set<int> ys_set(ys.begin(), ys.end());\n        ensuref((int)ys_set.size() == g, \"yj must be distinct\");\n    }\n\n    long long total_friends = (long long)n + (long long)m;\n    long long happy_friends = (long long)b + (long long)g;\n    ensuref(happy_friends < total_friends, \"There must be at least one unhappy person among his friends\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000000, \"n\"); // n in [1, 1e9]\n    inf.readSpace();\n    int m = inf.readInt(1, 1000000000, \"m\"); // m in [1, 1e9]\n    inf.readEoln();\n\n    int b_limit = min(n, 100000);\n    int b = inf.readInt(0, b_limit, \"b\"); // b in [0, min(n,1e5)]\n    vector<int> xs;\n    if (b == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        xs = inf.readInts(b, 0, n - 1, \"xi\");\n        inf.readEoln();\n        set<int> xs_set(xs.begin(), xs.end());\n        ensuref((int)xs_set.size() == b, \"xi must be distinct\");\n    }\n\n    int g_limit = min(m, 100000);\n    int g = inf.readInt(0, g_limit, \"g\"); // g in [0, min(m,1e5)]\n    vector<int> ys;\n    if (g == 0) {\n        inf.readEoln();\n    } else {\n        inf.readSpace();\n        ys = inf.readInts(g, 0, m - 1, \"yj\");\n        inf.readEoln();\n        set<int> ys_set(ys.begin(), ys.end());\n        ensuref((int)ys_set.size() == g, \"yj must be distinct\");\n    }\n\n    long long total_friends = (long long)n + (long long)m;\n    long long happy_friends = (long long)b + (long long)g;\n    ensuref(happy_friends < total_friends, \"There must be at least one unhappy person among his friends\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nenum AnswerType {\n    TYPE_INTEGER,\n    TYPE_YESNO\n};\n\nstruct ParsedAnswer {\n    AnswerType type;\n    long long integerVal; // valid if type == TYPE_INTEGER\n    bool yesVal;          // valid if type == TYPE_YESNO\n};\n\nstatic ParsedAnswer readAnswer(InStream &stream, const char *sourceName) {\n    string token = stream.readToken();\n\n    // Convert token to lowercase for yes/no check\n    {\n        string lowerToken = token;\n        for (auto &c : lowerToken) {\n            c = tolower(c);\n        }\n        if (lowerToken == \"yes\") {\n            return {TYPE_YESNO, 0, true};\n        }\n        else if (lowerToken == \"no\") {\n            return {TYPE_YESNO, 0, false};\n        }\n    }\n\n    // Otherwise, try to parse as 64-bit integer\n    try {\n        long long val = stoll(token);\n        return {TYPE_INTEGER, val, false};\n    } catch (...) {\n        stream.quitf(_wa,\n                     \"Expected a 64-bit integer or \\\"Yes\\\"/\\\"No\\\", but found \\\"%s\\\" in %s's answer\",\n                     token.c_str(), sourceName);\n    }\n    // unreachable\n    return {TYPE_INTEGER, 0, false};\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    ParsedAnswer juryAns = readAnswer(ans, \"jury\");\n    ParsedAnswer partAns = readAnswer(ouf, \"participant\");\n\n    // Compare types first\n    if (juryAns.type != partAns.type) {\n        // Construct string representations for meaningful error\n        string juryStr = (juryAns.type == TYPE_YESNO)\n                             ? (juryAns.yesVal ? \"Yes\" : \"No\")\n                             : to_string(juryAns.integerVal);\n        string partStr = (partAns.type == TYPE_YESNO)\n                             ? (partAns.yesVal ? \"Yes\" : \"No\")\n                             : to_string(partAns.integerVal);\n        quitf(_wa, \"Expected \\\"%s\\\", but found \\\"%s\\\"\", juryStr.c_str(), partStr.c_str());\n    }\n\n    // Types are the same\n    if (juryAns.type == TYPE_YESNO) {\n        if (juryAns.yesVal != partAns.yesVal) {\n            quitf(_wa, \"Expected \\\"%s\\\", but found \\\"%s\\\"\",\n                  (juryAns.yesVal ? \"Yes\" : \"No\"),\n                  (partAns.yesVal ? \"Yes\" : \"No\"));\n        } else {\n            // Both are the same yes/no\n            quitf(_ok, \"Both are %s\", (juryAns.yesVal ? \"Yes\" : \"No\"));\n        }\n    }\n    else {\n        // TYPE_INTEGER\n        if (juryAns.integerVal != partAns.integerVal) {\n            quitf(_wa, \"Expected %lld but found %lld\",\n                  juryAns.integerVal, partAns.integerVal);\n        } else {\n            quitf(_ok, \"Correct answer: %lld\", partAns.integerVal);\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the main parameters\n    long long n = opt<long long>(\"n\");  // number of boys\n    long long m = opt<long long>(\"m\");  // number of girls\n    string type = opt<string>(\"type\", \"random\");\n\n    // -------------------------------------------------------------------------\n    // A helper lambda to generate k distinct indices in [0..limit-1].\n    // k must be <= limit (we rely on problem constraints to ensure that).\n    // We also cap k at 100000 because the problem statement says:\n    // b <= min(n, 10^5), g <= min(m, 10^5).\n    auto generateDistinct = [&](long long limit, int k) {\n        // We'll store the result in a vector<int> (the problem demands 0..limit-1).\n        vector<int> arr;\n        arr.reserve(k);\n        // We can pick distinct indices by sampling or by shuffling a small range\n        // if k close to limit, etc. We'll do a simple approach:\n        // 1) Create array [0..limit-1], shuffle it, then take first k.\n        //    but note limit can be as large as 1e9, so we can't build in memory.\n        // For large limit, we must do slower sampling. But we are limited by k <= 1e5.\n        // The approach: pick distinct numbers by using a set or \"reservoir sampling.\"\n        // But we can do a simpler approach because k <= 1e5. We can store them in a set.\n\n        // If limit is huge, we either do:\n        //   - use an unordered_set<int> and repeatedly call rnd.next(limit).\n        //   - keep picking until we have k distinct.\n        // This is simpler to implement. For extremely large limit, it is still feasible for k up to 1e5.\n\n        unordered_set<int> chosen;\n        chosen.reserve(k * 2);\n\n        while ((int)chosen.size() < k) {\n            // randomly pick in [0..limit-1]\n            long long val = rnd.next(limit); \n            chosen.insert((int)val);\n        }\n\n        // Put them into a vector and sort just to have a consistent output order\n        // (the problem does not require sorting, but it's more readable).\n        vector<int> ret(chosen.begin(), chosen.end());\n        sort(ret.begin(), ret.end());\n\n        return ret;\n    };\n\n    // We will decide b (number of happy boys) and g (number of happy girls)\n    // according to the \"type\".\n    // IMPORTANT: We must ensure at least one total unhappy person overall:\n    // i.e. not (b == n and g == m).\n    // Also if b or g might exceed problem constraints, we clamp them.\n    \n    // We'll define some small helper function for clamping:\n    auto clampTo = [&](long long val, long long hi) {\n        if (val < 0) return 0LL;\n        if (val > hi) return hi;\n        return val;\n    };\n\n    // Decide b, g\n    long long B = 0;  // how many happy boys we will generate\n    long long G = 0;  // how many happy girls\n\n    // If n,m are up to 1e9, b,g can be up to min(n,1e5), min(m,1e5).\n    // We'll store final b,g as int because it cannot exceed 1e5.\n    // But watch out if n < 1e5 or m < 1e5. Then b <= n, g <= m, so cast carefully.\n\n    if (type == \"random\") {\n        // Generate random b, g in [0..min(n,100000]] and [0..min(m,100000]].\n        // Then if both are at maximum (i.e. b == n and g == m) we force at least one to reduce by 1.\n        // We do it in a simple manner.\n\n        // upper bound for boys/girls\n        long long limitB = std::min(n, 100000LL);\n        long long limitG = std::min(m, 100000LL);\n\n        B = rnd.next(limitB + 1); // random in [0..limitB]\n        G = rnd.next(limitG + 1); // random in [0..limitG]\n\n        // Ensure at least one unhappy person: if B == n and G == m, stealth adjust:\n        if (B == n && G == m) {\n            if (B > 0) B--; \n            // else if we cannot reduce B, then we reduce G if possible\n            else if (G > 0) G--;\n        }\n    }\n    else if (type == \"noneOfBoys\") {\n        // Make all boys unhappy: b=0\n        // Then pick g in [0..min(m, 100000]], but ensure not all are happy\n        // so if g == m (and m <= 100000) we reduce by 1.\n        B = 0;\n        long long limitG = min(m, 100000LL);\n        G = rnd.next(limitG + 1);\n        // Ensure at least one unhappy\n        if (G == m) { \n            if (G > 0) G--;\n        }\n    }\n    else if (type == \"noneOfGirls\") {\n        // Make all girls unhappy: g=0\n        // Then pick b in [0..min(n, 100000]], but ensure not all are happy\n        long long limitB = min(n, 100000LL);\n        B = rnd.next(limitB + 1);\n        G = 0;\n        // Ensure at least one unhappy\n        if (B == n) { \n            if (B > 0) B--;\n        }\n    }\n    else if (type == \"allButOneBoy\") {\n        // Make n-1 boys happy if possible, plus random G\n        // Must ensure n >= 2 for \"allButOneBoy\" to make sense, but the user might call it for n=1. \n        // If n=1, \"allButOneBoy\" means b=0. We'll handle that gracefully.\n        if (n > 1) {\n            B = n - 1; \n            if (B > 100000) B = 100000; // clamp\n        } else {\n            // n==1, so \"allButOneBoy\" effectively means b=0\n            B = 0;\n        }\n        long long limitG = min(m, 100000LL);\n        G = rnd.next(limitG + 1);\n        // ensure at least one person unhappy overall:\n        // if B==n, G==m\n        // But we set B=n-1 or 0, so B can't be n. \n        // We can skip any further check here unless B=0 & G=m. If n=1, B=0 => if G=m we reduce G\n        if (B == 0 && G == m) {\n            if (G > 0) G--;\n        }\n    }\n    else if (type == \"allButOneGirl\") {\n        // Make m-1 girls happy if possible, plus random B\n        if (m > 1) {\n            G = m - 1;\n            if (G > 100000) G = 100000; \n        } else {\n            G = 0;\n        }\n        long long limitB = min(n, 100000LL);\n        B = rnd.next(limitB + 1);\n        // Similar reasoning as above\n        if (G == 0 && B == n) {\n            if (B > 0) B--;\n        }\n    }\n    else if (type == \"small\") {\n        // We'll pick small n,m in [1..10], ignoring the user-supplied n,m.\n        // This is to produce small corner-case tests.\n        // Then pick random B,G. We do still need to ensure at least one is unhappy.\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n\n        long long limitB = min(n, 100000LL);\n        long long limitG = min(m, 100000LL);\n\n        B = rnd.next(limitB + 1);\n        G = rnd.next(limitG + 1);\n\n        // fix the corner case that all are happy\n        if (B == n && G == m) {\n            if (B > 0) B--;\n            else if (G > 0) G--;\n        }\n    }\n    else {\n        // default fallback is also random\n        long long limitB = min(n, 100000LL);\n        long long limitG = min(m, 100000LL);\n\n        B = rnd.next(limitB + 1);\n        G = rnd.next(limitG + 1);\n\n        if (B == n && G == m) {\n            if (B > 0) B--;\n            else if (G > 0) G--;\n        }\n    }\n\n    // Now clamp to be sure B <= n, G <= m, B,G <= 100000\n    if (B > n) B = n; \n    if (G > m) G = m;\n    if (B > 100000) B = 100000;\n    if (G > 100000) G = 100000;\n\n    // If by chance B == n and G == m, adjust again to avoid \"all happy\".\n    if (B == n && G == m) {\n        if (B > 0) B--;\n        else if (G > 0) G--;\n    }\n    \n    // Convert to int for indexing\n    int b = (int)B;\n    int g = (int)G;\n\n    // Generate distinct indices for those happy\n    vector<int> happyBoys = generateDistinct(n, b);\n    vector<int> happyGirls = generateDistinct(m, g);\n\n    // -------------------------------------------------------------------------\n    // OUTPUT\n    // Format:\n    // 1) n m\n    // 2) b x1 x2 ...\n    // 3) g y1 y2 ...\n    // Must follow the problem's instructions exactly.\n    // \"The first line: n, m\"\n    // \"The second line: b, then b distinct indices\"\n    // \"The third line: g, then g distinct indices\"\n\n    // Print n, m\n    cout << n << \" \" << m << \"\\n\";\n\n    // Print the line for boys\n    cout << b;\n    for (auto &idx : happyBoys) {\n        cout << \" \" << idx;\n    }\n    cout << \"\\n\";\n\n    // Print the line for girls\n    cout << g;\n    for (auto &idx : happyGirls) {\n        cout << \" \" << idx;\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the main parameters\n    long long n = opt<long long>(\"n\");  // number of boys\n    long long m = opt<long long>(\"m\");  // number of girls\n    string type = opt<string>(\"type\", \"random\");\n\n    // -------------------------------------------------------------------------\n    // A helper lambda to generate k distinct indices in [0..limit-1].\n    // k must be <= limit (we rely on problem constraints to ensure that).\n    // We also cap k at 100000 because the problem statement says:\n    // b <= min(n, 10^5), g <= min(m, 10^5).\n    auto generateDistinct = [&](long long limit, int k) {\n        // We'll store the result in a vector<int> (the problem demands 0..limit-1).\n        vector<int> arr;\n        arr.reserve(k);\n        // We can pick distinct indices by sampling or by shuffling a small range\n        // if k close to limit, etc. We'll do a simple approach:\n        // 1) Create array [0..limit-1], shuffle it, then take first k.\n        //    but note limit can be as large as 1e9, so we can't build in memory.\n        // For large limit, we must do slower sampling. But we are limited by k <= 1e5.\n        // The approach: pick distinct numbers by using a set or \"reservoir sampling.\"\n        // But we can do a simpler approach because k <= 1e5. We can store them in a set.\n\n        // If limit is huge, we either do:\n        //   - use an unordered_set<int> and repeatedly call rnd.next(limit).\n        //   - keep picking until we have k distinct.\n        // This is simpler to implement. For extremely large limit, it is still feasible for k up to 1e5.\n\n        unordered_set<int> chosen;\n        chosen.reserve(k * 2);\n\n        while ((int)chosen.size() < k) {\n            // randomly pick in [0..limit-1]\n            long long val = rnd.next(limit); \n            chosen.insert((int)val);\n        }\n\n        // Put them into a vector and sort just to have a consistent output order\n        // (the problem does not require sorting, but it's more readable).\n        vector<int> ret(chosen.begin(), chosen.end());\n        sort(ret.begin(), ret.end());\n\n        return ret;\n    };\n\n    // We will decide b (number of happy boys) and g (number of happy girls)\n    // according to the \"type\".\n    // IMPORTANT: We must ensure at least one total unhappy person overall:\n    // i.e. not (b == n and g == m).\n    // Also if b or g might exceed problem constraints, we clamp them.\n    \n    // We'll define some small helper function for clamping:\n    auto clampTo = [&](long long val, long long hi) {\n        if (val < 0) return 0LL;\n        if (val > hi) return hi;\n        return val;\n    };\n\n    // Decide b, g\n    long long B = 0;  // how many happy boys we will generate\n    long long G = 0;  // how many happy girls\n\n    // If n,m are up to 1e9, b,g can be up to min(n,1e5), min(m,1e5).\n    // We'll store final b,g as int because it cannot exceed 1e5.\n    // But watch out if n < 1e5 or m < 1e5. Then b <= n, g <= m, so cast carefully.\n\n    if (type == \"random\") {\n        // Generate random b, g in [0..min(n,100000]] and [0..min(m,100000]].\n        // Then if both are at maximum (i.e. b == n and g == m) we force at least one to reduce by 1.\n        // We do it in a simple manner.\n\n        // upper bound for boys/girls\n        long long limitB = std::min(n, 100000LL);\n        long long limitG = std::min(m, 100000LL);\n\n        B = rnd.next(limitB + 1); // random in [0..limitB]\n        G = rnd.next(limitG + 1); // random in [0..limitG]\n\n        // Ensure at least one unhappy person: if B == n and G == m, stealth adjust:\n        if (B == n && G == m) {\n            if (B > 0) B--; \n            // else if we cannot reduce B, then we reduce G if possible\n            else if (G > 0) G--;\n        }\n    }\n    else if (type == \"noneOfBoys\") {\n        // Make all boys unhappy: b=0\n        // Then pick g in [0..min(m, 100000]], but ensure not all are happy\n        // so if g == m (and m <= 100000) we reduce by 1.\n        B = 0;\n        long long limitG = min(m, 100000LL);\n        G = rnd.next(limitG + 1);\n        // Ensure at least one unhappy\n        if (G == m) { \n            if (G > 0) G--;\n        }\n    }\n    else if (type == \"noneOfGirls\") {\n        // Make all girls unhappy: g=0\n        // Then pick b in [0..min(n, 100000]], but ensure not all are happy\n        long long limitB = min(n, 100000LL);\n        B = rnd.next(limitB + 1);\n        G = 0;\n        // Ensure at least one unhappy\n        if (B == n) { \n            if (B > 0) B--;\n        }\n    }\n    else if (type == \"allButOneBoy\") {\n        // Make n-1 boys happy if possible, plus random G\n        // Must ensure n >= 2 for \"allButOneBoy\" to make sense, but the user might call it for n=1. \n        // If n=1, \"allButOneBoy\" means b=0. We'll handle that gracefully.\n        if (n > 1) {\n            B = n - 1; \n            if (B > 100000) B = 100000; // clamp\n        } else {\n            // n==1, so \"allButOneBoy\" effectively means b=0\n            B = 0;\n        }\n        long long limitG = min(m, 100000LL);\n        G = rnd.next(limitG + 1);\n        // ensure at least one person unhappy overall:\n        // if B==n, G==m\n        // But we set B=n-1 or 0, so B can't be n. \n        // We can skip any further check here unless B=0 & G=m. If n=1, B=0 => if G=m we reduce G\n        if (B == 0 && G == m) {\n            if (G > 0) G--;\n        }\n    }\n    else if (type == \"allButOneGirl\") {\n        // Make m-1 girls happy if possible, plus random B\n        if (m > 1) {\n            G = m - 1;\n            if (G > 100000) G = 100000; \n        } else {\n            G = 0;\n        }\n        long long limitB = min(n, 100000LL);\n        B = rnd.next(limitB + 1);\n        // Similar reasoning as above\n        if (G == 0 && B == n) {\n            if (B > 0) B--;\n        }\n    }\n    else if (type == \"small\") {\n        // We'll pick small n,m in [1..10], ignoring the user-supplied n,m.\n        // This is to produce small corner-case tests.\n        // Then pick random B,G. We do still need to ensure at least one is unhappy.\n        n = rnd.next(1, 10);\n        m = rnd.next(1, 10);\n\n        long long limitB = min(n, 100000LL);\n        long long limitG = min(m, 100000LL);\n\n        B = rnd.next(limitB + 1);\n        G = rnd.next(limitG + 1);\n\n        // fix the corner case that all are happy\n        if (B == n && G == m) {\n            if (B > 0) B--;\n            else if (G > 0) G--;\n        }\n    }\n    else {\n        // default fallback is also random\n        long long limitB = min(n, 100000LL);\n        long long limitG = min(m, 100000LL);\n\n        B = rnd.next(limitB + 1);\n        G = rnd.next(limitG + 1);\n\n        if (B == n && G == m) {\n            if (B > 0) B--;\n            else if (G > 0) G--;\n        }\n    }\n\n    // Now clamp to be sure B <= n, G <= m, B,G <= 100000\n    if (B > n) B = n; \n    if (G > m) G = m;\n    if (B > 100000) B = 100000;\n    if (G > 100000) G = 100000;\n\n    // If by chance B == n and G == m, adjust again to avoid \"all happy\".\n    if (B == n && G == m) {\n        if (B > 0) B--;\n        else if (G > 0) G--;\n    }\n    \n    // Convert to int for indexing\n    int b = (int)B;\n    int g = (int)G;\n\n    // Generate distinct indices for those happy\n    vector<int> happyBoys = generateDistinct(n, b);\n    vector<int> happyGirls = generateDistinct(m, g);\n\n    // -------------------------------------------------------------------------\n    // OUTPUT\n    // Format:\n    // 1) n m\n    // 2) b x1 x2 ...\n    // 3) g y1 y2 ...\n    // Must follow the problem's instructions exactly.\n    // \"The first line: n, m\"\n    // \"The second line: b, then b distinct indices\"\n    // \"The third line: g, then g distinct indices\"\n\n    // Print n, m\n    cout << n << \" \" << m << \"\\n\";\n\n    // Print the line for boys\n    cout << b;\n    for (auto &idx : happyBoys) {\n        cout << \" \" << idx;\n    }\n    cout << \"\\n\";\n\n    // Print the line for girls\n    cout << g;\n    for (auto &idx : happyGirls) {\n        cout << \" \" << idx;\n    }\n    cout << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# 1. Small random\r\n./gen -n 5 -m 5 -type small\r\n\r\n# 2. Another small random\r\n./gen -n 1 -m 10 -type small\r\n\r\n# 3. None of the boys happy, random girls\r\n./gen -n 10 -m 10 -type noneOfBoys\r\n\r\n# 4. None of the girls happy, random boys\r\n./gen -n 10 -m 10 -type noneOfGirls\r\n\r\n# 5. All but one boy happy\r\n./gen -n 10 -m 10 -type allButOneBoy\r\n\r\n# 6. All but one girl happy\r\n./gen -n 10 -m 10 -type allButOneGirl\r\n\r\n# 7. Random distribution, moderate range\r\n./gen -n 100 -m 100 -type random\r\n\r\n# 8. Another random distribution, moderate range\r\n./gen -n 123 -m 456 -type random\r\n\r\n# 9. Large random distribution\r\n./gen -n 1000000000 -m 999999999 -type random\r\n\r\n# 10. Another variation of large random\r\n./gen -n 999999999 -m 1000000000 -type random\r\n\r\n# 11. All but one boy, large scenario\r\n./gen -n 1000000000 -m 999999999 -type allButOneBoy\r\n\r\n# 12. All but one girl, large scenario\r\n./gen -n 999999999 -m 1000000000 -type allButOneGirl\r\n\r\n# 13. None of boys, large scenario\r\n./gen -n 999999999 -m 1000000000 -type noneOfBoys\r\n\r\n# 14. None of girls, large scenario\r\n./gen -n 999999999 -m 1000000000 -type noneOfGirls\r\n\r\n# 15. Small but with noneOfBoys\r\n./gen -n 2 -m 2 -type noneOfBoys\r\n\r\n# 16. Small but with noneOfGirls\r\n./gen -n 2 -m 2 -type noneOfGirls\r\n\r\n# 17. Another simple random\r\n./gen -n 4 -m 7 -type random\r\n\r\n# 18. Edge case: n=1, m=1\r\n./gen -n 1 -m 1 -type random\r\n\r\n# 19. Edge case: n=1, m=100\r\n./gen -n 1 -m 100 -type random\r\n\r\n# 20. Edge case: n=100, m=1\r\n./gen -n 100 -m 1 -type random\r\n\r\n# 21. Another \"allButOneGirl\" test\r\n./gen -n 15 -m 15 -type allButOneGirl\r\n\r\n# 22. Another \"allButOneBoy\" test\r\n./gen -n 20 -m 5 -type allButOneBoy\r\n\r\n# 23. Another small\r\n./gen -n 3 -m 9 -type small\r\n\r\n# 24. Another random\r\n./gen -n 50 -m 50 -type random\r\n\r\n# 25. Another random with nonsquare\r\n./gen -n 37 -m 999 -type random\r\n\r\n# 26. Another noneOfBoys\r\n./gen -n 999999998 -m 999999999 -type noneOfBoys",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:28.726772",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "518/A",
      "title": "A. Vitaly and Strings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains string s (1 ≤ |s| ≤ 100), consisting of lowercase English letters. Here, |s| denotes the length of the string.The second line contains string t (|t| = |s|), consisting of lowercase English letters.It is guaranteed that the lengths of strings s and t are the same and string s is lexicographically less than string t.",
      "output_spec": "OutputIf the string that meets the given requirements doesn't exist, print a single string \"No such string\" (without the quotes).If such string exists, print it. If there are multiple valid strings, you may print any of them.",
      "sample_tests": "ExamplesInputCopyacOutputCopybInputCopyaaazzzOutputCopykkkInputCopyabcdefgabcdefhOutputCopyNo such string",
      "description": "A. Vitaly and Strings\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains string s (1 ≤ |s| ≤ 100), consisting of lowercase English letters. Here, |s| denotes the length of the string.The second line contains string t (|t| = |s|), consisting of lowercase English letters.It is guaranteed that the lengths of strings s and t are the same and string s is lexicographically less than string t.\n\nOutputIf the string that meets the given requirements doesn't exist, print a single string \"No such string\" (without the quotes).If such string exists, print it. If there are multiple valid strings, you may print any of them.\n\nInputCopyacOutputCopybInputCopyaaazzzOutputCopykkkInputCopyabcdefgabcdefhOutputCopyNo such string\n\nInputCopyac\n\nOutputCopyb\n\nInputCopyaaazzz\n\nOutputCopykkk\n\nInputCopyabcdefgabcdefh\n\nOutputCopyNo such string\n\nNoteString s = s1s2... sn is said to be lexicographically smaller than t = t1t2... tn, if there exists such i, that s1 = t1, s2 = t2, ... si - 1 = ti - 1, si < ti.",
      "solutions": [
        {
          "title": "Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #293 (Div. 2). It will be held on Tuesday, February 24 at 19:30 MSK and as usual Div. 1 participants are invited to join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear friends Pavel Kholkin (HolkinPV), Arthur Svechnikov (ikar) and Vitaliy Kudasov (kuviman) for writing solutions.It will be a little unusual round — you will be given six problems and two and half hours to solve them.UPD Score distribution will be 500-1000-1500-2000-2500-2500. Good luck everyone!UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! urkkvr145 0o00oo0o000oo00o sorry_t0nyukuk NgocHai GintokiSakata",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces",
          "content": "517A — Vitaly and StringsTo solve this problem we can, for example, find string next, which lexicographically next to string s and check that string next is lexicographically less than string t. If string next is lexicographically smaller than string t, print string next and finish algorithm. If string next is equal to string t print No such string.To find string next, which lexicographically next to string s, at first we need to find maximal suffix of string s, consisting from letters 'z', change all letters 'z' in this suffix on letters 'a', and then letter before this suffix increase on one. I.e. if before suffix was letter, for example, 'd', we need to change it on letter 'e'.Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.517B — Tanya and PostcardTo solve this problem at first will count array cnt[], where cnt[c] — how many times letter c found in string t. We will count two numbers ans1 and ans2 — how many times Tanya will shouts joyfully YAY! and how many times Tanya will says WHOOPS.Let's iterate on string s and if cnt[s[i]] > 0, then increase ans1 on one and decrease cnt[s[i]] on one.Then let's again iterate on string s. Let c is letter which equal to s[i],but in the opposite case for it. I. e. if s[i] = 'w', then c = 'W'. Now, if cnt[c] > 0, then increase ans2 on one and decrease cnt[с] on one.Now, print two numbers — ans1 and ans2.Asymptotic behavior of this solution — O(|s| + |t|), where |s| — length of string s and |t| — length of string t.517C — Anya and SmartphoneTo solve this problem we will store two arrays — a[] and pos[]. In array a[] will store current order of icons, i. e. in a[i] store number of application, icon which stay on position i. In array pos[] will store on which place in list stays icons, i. e. in pos[i] store in which position of array a[] stay icon of application number i. We will count answer in variable ans. Let's iterate on applications which we need to open. Let current application has number num. Then to ans we need add (pos[num] / k + 1). Now, if icon of application number num doesn't stay on first position in list of applications, we make the following — swap a[pos[num]] and a[pos[num] - 1] and update values in array pos[] for indexes of two icons which numbers a[pos[num]] and a[pos[num] - 1] . Asymptotic behavior of this solution — O(n + m), where n — number of applications, m — number of requests to start applications.517D — Ilya and EscalatorTo solve this problem let's use dynamic programming. We will store two-dimensional array z[][] with type double. In z[i][j] will store the likelihood that after i seconds j people are on escalator.In dynamic will be following transitions. If j = n, i. e. all n people already on escalator then we make transition z[i + 1][j] +  = z[i][j]. Else, or person number j go to escalator in i + 1 second, i. e. z[i + 1][j + 1] +  = z[i][j] * p, or person number j stays on his place, i. e. z[i + 1][j] +  = z[i][j] * (1 – p).Now we need to count answer — it is sum on j from 0 to n inclusive z[t][j] * j.Asymptotic behavior of this solution — O(t * n), where t — on which moment we must count answer, n — how many people stay before escalator in the beginning.517E — Arthur and QuestionsAt first let's take two sums a1 + a2 + ... + ak and a2 + a3 + ... + ak + 1. It is correct that a1 + a2 + ... + ak < a2 + a3 + ... + ak + 1. If move from right to left all elements apart from ak + 1, all of them will reduce and will left only a1 < ak + 1. If write further all sums we will obtain that sequence disintegrate on k disjoint chains: a1 < ak + 1 < a2k + 1 < a3k + 1..., a2 < ak + 2 < a2k + 2 < a3k + 2..., ..., ak < a2k < a3k....We will solve the problem for every chain separately. Let's iterate on first chain and find all pair of indexes i, j (i < j), that a[i] and a[j] are numbers (not questions) in given sequence, and for all k from i + 1 to j - 1 in a[k] stay questions. All this questions we need to change on numbers so does not violate the terms of the increase and minimize sum of absolute values of this numbers.Between indexes i and j stay j - i - 1 questions, we can change them on a[j] - a[i] - 1 numbers. If j - i - 1 > a[j] - a[i] - 1, then we need to print Incorrect sequence and finish algorithm. Else we need to change all this questions to numbers in greedy way. Here we have several cases. Will review one case when a[i] >  = 0 and a[j] >  = 0. Let current chain (3, ?, ?, ?, 9), i = 1, j = 5. We need to change questions on numbers in the following way — (3, 4, 5, 6, 9). In other cases (when a[i] <  = 0, a[j] <  = 0 and when a[i] <  = 0, a[j] >  = 0) we need to use greedy similary to first so does not violate the terms of the increase and minimize sum of absolute values of this numbers.Asymptotic behavior of this solution — O(n), where n — count of elements in given sequence.517F — Pasha and PipeAt first let's count two two-dimensional arrays of prefix sums sumv[][] and sumg[][]. In sumv[i][j] store how many grids are in column j beginning from row 1 to row i. In sumg[i][j] store how many grid are in row i beginning from column 1 to column j.Let's count ans0 — how many pipes without bending we can pave. Count how many vertical pipes — we can pave. Iterate on j from 2 to m — 1 and, if sumg[n][j] — sumg[n][0] = 0 (i. e. in this column zero grids), increase ans0 on one. Similary count number of horizontal pipes.Let's count ans1 — how many pipes with 1 bending we can pave. We need to brute cell, in which will bending. There are four cases. Let's consider first case, others we can count similary. This case — pipe begin in left column, go to current cell in brute and then go to top row. If brute cell in row i and column j then to ans1 we need to add one, if (sumg[i][j] — sumg[i][0]) + (sumv[i][j] — sumv[0][j]) = 0.Let's count ans2 — how many pipes with 2 bendings we can pave. Let's count how many tunes begin from top row and end in top or bottom row and add this number to ans2. Then rotate our matrix three times on 90 degrees and after every rotate add to ans2 count of pipes, which begin from top row and end in top or bottom row. Then we need divide ans2 to 2, because every pipe will count twice.How we can count to current matrix how many pipes begin from top row and end in top or bottom row? Let's count four two-dimension arrays lf[][], rg[][], sumUp[][], sumDown[][]. If i — number of row, j — number of column of current cell, then in position (i, lf[i][j]) in matrix are nearest from left grid for cell (i, j), and in position (i, rg[i][j]) in matrix are nearest from right grid for cell (i, j). sumUp[i][j] — how many columns without grids are in submatrix from (1, 1) to (i, j) of given matrix. sumDown[i][j] — how many columns without grids are in submatrix from (i, 1) to (n, j) of given matrix. Then let's brute cell in which will be the first bending of pipe (pipe goes from top row and in this cell turned to left or to right), check, that in column j above this cell 0 grids, with help of arrays lf and rg find out as far as pipe can go to left or to right and with help of arrays sumUp and sumDown carefully update answer. Now print number ans1 + ans2 + ans3.Asymptotic behavior of this solution — O(n * m * const), where n — hoew many rows in given matrix, m — how many columns in given matrix, const takes different values depending on the implementation, in solution from editorial const = 10.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16598",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7412
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 2",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 3",
          "code": "M[i][i] = (1-p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 4",
          "code": "M[i][i-1]=p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 5",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 6",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 7",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 8",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 9",
          "code": "std::cout.precision(8)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::iostream::operator <<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 11",
          "code": "for (int i = 0; i < (int)strlen(A); i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 12",
          "code": "int lenA = strlen(A); for (int i = 0; i < len; i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    // Read t\n    string t = inf.readLine(\"[a-z]{1,100}\", \"t\");\n    // Check that lengths are equal\n    ensuref(s.length() == t.length(), \"Length of s (%d) and t (%d) should be equal\", (int)s.length(), (int)t.length());\n    // Check s < t lexicographically\n    ensuref(s < t, \"s should be lexicographically smaller than t\");\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    // Read t\n    string t = inf.readLine(\"[a-z]{1,100}\", \"t\");\n    // Check that lengths are equal\n    ensuref(s.length() == t.length(), \"Length of s (%d) and t (%d) should be equal\", (int)s.length(), (int)t.length());\n    // Check s < t lexicographically\n    ensuref(s < t, \"s should be lexicographically smaller than t\");\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read s\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n    // Read t\n    string t = inf.readLine(\"[a-z]{1,100}\", \"t\");\n    // Check that lengths are equal\n    ensuref(s.length() == t.length(), \"Length of s (%d) and t (%d) should be equal\", (int)s.length(), (int)t.length());\n    // Check s < t lexicographically\n    ensuref(s < t, \"s should be lexicographically smaller than t\");\n    // Ensure end of file\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n    string s = inf.readToken(); // read s from input file\n    string t = inf.readToken(); // read t from input file\n\n    // Read participant's output\n    string u = ouf.readLine(); // read the participant's output line\n\n    // Remove any trailing or leading whitespaces\n    u = trim(u);\n\n    // Check if u is \"No such string\"\n    if (u == \"No such string\") {\n        // Need to check whether there exists any string between s and t\n        // Let's try to find the next lexicographical string after s\n        string s_plus = s;\n        int n = s.size();\n        int i = n - 1;\n        bool incremented = false;\n\n        while (i >= 0 && !incremented) {\n            if (s_plus[i] != 'z') {\n                s_plus[i]++;\n                incremented = true;\n            } else {\n                s_plus[i] = 'a';\n                i--;\n            }\n        }\n\n        if (!incremented) {\n            // s was all 'z's and cannot be incremented\n            quitf(_ok, \"No such string exists and participant correctly outputs 'No such string'\");\n        } else {\n            // Check if s_plus is less than t\n            if (s_plus < t) {\n                quitf(_wa, \"Participant outputs 'No such string' but a valid string exists between s and t\");\n            } else {\n                quitf(_ok, \"No such string exists and participant correctly outputs 'No such string'\");\n            }\n        }\n    } else {\n        // Participant outputs a string u\n        // First, check that u has the same length as s and t\n        if (u.size() != s.size()) {\n            quitf(_wa, \"Output string length is %d, but expected length is %d\", u.size(), s.size());\n        }\n\n        // Check that u consists of lowercase English letters\n        for (char c : u) {\n            if (!('a' <= c && c <= 'z')) {\n                quitf(_wa, \"Output contains invalid character '%c', only lowercase letters allowed\", c);\n            }\n        }\n\n        // Check that s < u < t lexicographically\n        if (!(s < u && u < t)) {\n            quitf(_wa, \"Output string '%s' is not lexicographically between s ('%s') and t ('%s')\", u.c_str(), s.c_str(), t.c_str());\n        }\n\n        // Participant's output is correct\n        quitf(_ok, \"Participant outputs a valid string '%s'\", u.c_str());\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring next_string(string s) {\n    int n = s.length();\n    int i = n -1;\n    while (i >= 0 && s[i] == 'z') {\n        s[i] = 'a';\n        i--;\n    }\n    if (i >= 0) {\n        s[i] = s[i] + 1;\n        return s;\n    } else {\n        // Reached 'z...z', no next string\n        return \"\";\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, t;\n\n    if (type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += rnd.next('a', 'z');\n        }\n        t = s;\n\n        int idx = -1;\n        for(int i = 0; i < n; i++) {\n            if (s[i] != 'z') {\n                idx = i;\n                break;\n            }\n        }\n\n        if (idx == -1) {\n            // s is 'z...z'\n            s[n - 1] = 'y';\n            t = s;\n            t[n - 1 ] = 'z';  // s < t\n        } else {\n            t[idx] = rnd.next(s[idx] + 1, 'z');\n            for (int i = idx + 1; i < n; i++) {\n                t[i] = rnd.next('a', 'z');\n            }\n        }\n    } else if (type == \"no_solution\") {\n        s = \"\";\n        int count_z = 0;\n        for (int i = 0; i < n; i++) {\n            char c = rnd.next('a', 'z');\n            s += c;\n            if (c == 'z') count_z++;\n        }\n        if(count_z == n) {\n            // s is 'z...z', cannot increment\n            s[n - 1] = 'y';\n        }\n\n        t = next_string(s);\n        if (t == \"\") {\n            // Should not happen if s != 'z...z'\n            s[n - 1 ] = 'y';\n            t = next_string(s);\n        }\n        // Now s < t, and no strings between s and t\n    } else if (type == \"edge_case\") {\n        // s = 'z...z' - 1, t = 'z...z'\n        s = string(n, 'z');\n        int idx = n - 1;\n        while (idx >= 0 && s[idx] == 'a') {\n            s[idx] = 'z';\n            idx--;\n        }\n        if (idx >= 0) {\n            s[idx] = s[idx] - 1;\n            t = string(n, 'z');\n        } else {\n            // s is 'a...a', cannot decrement\n            s[ n - 1 ] = 'a';\n            t = s;\n            t[ n - 1 ] = 'b';\n        }\n    } else if (type == \"min_string\") {\n        s = string(n, 'a');\n        t = s;\n        t[ n -1 ] = 'a' + 1;\n    } else if (type == \"max_string\"){\n        s = string(n, 'z');\n        if (n >=1) s[n-1] = 'y';\n        t = string(n, 'z');\n    } else if (type == \"diff_last_char\"){\n        s = \"\";\n        for(int i= 0; i < n-1; i++){\n            char ch = rnd.next('a','z');\n            s += ch;\n        }\n        char ch_s = rnd.next('a', 'y'); // 'a' to 'y'\n        char ch_t = ch_s + 1; // 'b' to 'z'\n        s += ch_s;\n        t = s;\n        t[n-1] = ch_t;\n    } else if (type == \"single_char_diff\"){\n        s = \"\";\n        t = \"\";\n        for(int i = 0; i < n; i++){\n            char ch = rnd.next('a','z');\n            s += ch;\n            t += ch;\n        }\n        int idx = rnd.next(0, n - 1);\n        if(s[idx] == 'z'){\n            s[idx] = 'y';\n            t[idx] = 'z';\n        } else {\n            t[idx] = s[idx] + 1;\n        }\n        if(s >= t){\n            swap(s, t);\n        }\n    } else if (type == \"max_length\") {\n        n = 100;\n        s = string(100, 'a');\n        t = string(100, 'z');\n    } else {\n        // default random\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += rnd.next('a', 'z');\n        }\n        t = s;\n\n        int idx = -1;\n        for(int i = 0; i < n; i++) {\n            if (s[i] != 'z') {\n                idx = i;\n                break;\n            }\n        }\n\n        if (idx == -1) {\n            // s is 'z...z'\n            s[n - 1] = 'y';\n            t = s;\n            t[n - 1 ] = 'z';  // s < t\n        } else {\n            t[idx] = rnd.next(s[idx] + 1, 'z');\n            for (int i = idx + 1; i < n; i++) {\n                t[i] = rnd.next('a', 'z');\n            }\n        }\n    }\n\n    // Output s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring next_string(string s) {\n    int n = s.length();\n    int i = n -1;\n    while (i >= 0 && s[i] == 'z') {\n        s[i] = 'a';\n        i--;\n    }\n    if (i >= 0) {\n        s[i] = s[i] + 1;\n        return s;\n    } else {\n        // Reached 'z...z', no next string\n        return \"\";\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s, t;\n\n    if (type == \"random\") {\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += rnd.next('a', 'z');\n        }\n        t = s;\n\n        int idx = -1;\n        for(int i = 0; i < n; i++) {\n            if (s[i] != 'z') {\n                idx = i;\n                break;\n            }\n        }\n\n        if (idx == -1) {\n            // s is 'z...z'\n            s[n - 1] = 'y';\n            t = s;\n            t[n - 1 ] = 'z';  // s < t\n        } else {\n            t[idx] = rnd.next(s[idx] + 1, 'z');\n            for (int i = idx + 1; i < n; i++) {\n                t[i] = rnd.next('a', 'z');\n            }\n        }\n    } else if (type == \"no_solution\") {\n        s = \"\";\n        int count_z = 0;\n        for (int i = 0; i < n; i++) {\n            char c = rnd.next('a', 'z');\n            s += c;\n            if (c == 'z') count_z++;\n        }\n        if(count_z == n) {\n            // s is 'z...z', cannot increment\n            s[n - 1] = 'y';\n        }\n\n        t = next_string(s);\n        if (t == \"\") {\n            // Should not happen if s != 'z...z'\n            s[n - 1 ] = 'y';\n            t = next_string(s);\n        }\n        // Now s < t, and no strings between s and t\n    } else if (type == \"edge_case\") {\n        // s = 'z...z' - 1, t = 'z...z'\n        s = string(n, 'z');\n        int idx = n - 1;\n        while (idx >= 0 && s[idx] == 'a') {\n            s[idx] = 'z';\n            idx--;\n        }\n        if (idx >= 0) {\n            s[idx] = s[idx] - 1;\n            t = string(n, 'z');\n        } else {\n            // s is 'a...a', cannot decrement\n            s[ n - 1 ] = 'a';\n            t = s;\n            t[ n - 1 ] = 'b';\n        }\n    } else if (type == \"min_string\") {\n        s = string(n, 'a');\n        t = s;\n        t[ n -1 ] = 'a' + 1;\n    } else if (type == \"max_string\"){\n        s = string(n, 'z');\n        if (n >=1) s[n-1] = 'y';\n        t = string(n, 'z');\n    } else if (type == \"diff_last_char\"){\n        s = \"\";\n        for(int i= 0; i < n-1; i++){\n            char ch = rnd.next('a','z');\n            s += ch;\n        }\n        char ch_s = rnd.next('a', 'y'); // 'a' to 'y'\n        char ch_t = ch_s + 1; // 'b' to 'z'\n        s += ch_s;\n        t = s;\n        t[n-1] = ch_t;\n    } else if (type == \"single_char_diff\"){\n        s = \"\";\n        t = \"\";\n        for(int i = 0; i < n; i++){\n            char ch = rnd.next('a','z');\n            s += ch;\n            t += ch;\n        }\n        int idx = rnd.next(0, n - 1);\n        if(s[idx] == 'z'){\n            s[idx] = 'y';\n            t[idx] = 'z';\n        } else {\n            t[idx] = s[idx] + 1;\n        }\n        if(s >= t){\n            swap(s, t);\n        }\n    } else if (type == \"max_length\") {\n        n = 100;\n        s = string(100, 'a');\n        t = string(100, 'z');\n    } else {\n        // default random\n        s = \"\";\n        for (int i = 0; i < n; i++) {\n            s += rnd.next('a', 'z');\n        }\n        t = s;\n\n        int idx = -1;\n        for(int i = 0; i < n; i++) {\n            if (s[i] != 'z') {\n                idx = i;\n                break;\n            }\n        }\n\n        if (idx == -1) {\n            // s is 'z...z'\n            s[n - 1] = 'y';\n            t = s;\n            t[n - 1 ] = 'z';  // s < t\n        } else {\n            t[idx] = rnd.next(s[idx] + 1, 'z');\n            for (int i = idx + 1; i < n; i++) {\n                t[i] = rnd.next('a', 'z');\n            }\n        }\n    }\n\n    // Output s and t\n    printf(\"%s\\n\", s.c_str());\n    printf(\"%s\\n\", t.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_string\n./gen -n 1 -type max_string\n./gen -n 1 -type random\n./gen -n 1 -type no_solution\n./gen -n 1 -type diff_last_char\n./gen -n 1 -type single_char_diff\n\n./gen -n 2 -type min_string\n./gen -n 2 -type max_string\n./gen -n 2 -type random\n./gen -n 2 -type no_solution\n./gen -n 2 -type diff_last_char\n./gen -n 2 -type single_char_diff\n\n./gen -n 10 -type min_string\n./gen -n 10 -type max_string\n./gen -n 10 -type random\n./gen -n 10 -type no_solution\n./gen -n 10 -type diff_last_char\n./gen -n 10 -type single_char_diff\n\n./gen -n 50 -type min_string\n./gen -n 50 -type max_string\n./gen -n 50 -type random\n./gen -n 50 -type no_solution\n./gen -n 50 -type diff_last_char\n./gen -n 50 -type single_char_diff\n\n./gen -n 100 -type min_string\n./gen -n 100 -type max_string\n./gen -n 100 -type random\n./gen -n 100 -type no_solution\n./gen -n 100 -type diff_last_char\n./gen -n 100 -type single_char_diff\n\n# Edge case\n./gen -n 100 -type edge_case\n\n# Using default 'random' type without specifying type\n./gen -n 10\n./gen -n 50\n./gen -n 100\n\n# Additional random cases for more data\n./gen -n 100 -type random\n./gen -n 100 -type random\n./gen -n 100 -type random\n\n# Using 'no_solution' type with varying n\n./gen -n 5 -type no_solution\n./gen -n 50 -type no_solution\n./gen -n 99 -type no_solution\n\n# Using 'diff_last_char' with varying n\n./gen -n 20 -type diff_last_char\n./gen -n 75 -type diff_last_char\n./gen -n 100 -type diff_last_char\n\n# Using 'single_char_diff' with varying n\n./gen -n 30 -type single_char_diff\n./gen -n 80 -type single_char_diff\n./gen -n 100 -type single_char_diff\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:31.139435",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "518/B",
      "title": "B. Tanya and Postcard",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains line s (1 ≤ |s| ≤ 2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.The second line contains line t (|s| ≤ |t| ≤ 2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.Here |a| means the length of the string a.",
      "output_spec": "OutputPrint two integers separated by a space:  the first number is the number of times Tanya shouts \"YAY!\" while making the message,  the second number is the number of times Tanya says \"WHOOPS\" while making the message.",
      "sample_tests": "ExamplesInputCopyAbCDCbAOutputCopy3 0InputCopyABCabcOutputCopy0 3InputCopyabacabaAbaCaBAOutputCopy3 4",
      "description": "B. Tanya and Postcard\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains line s (1 ≤ |s| ≤ 2·105), consisting of uppercase and lowercase English letters — the text of Tanya's message.The second line contains line t (|s| ≤ |t| ≤ 2·105), consisting of uppercase and lowercase English letters — the text written in the newspaper.Here |a| means the length of the string a.\n\nOutputPrint two integers separated by a space:  the first number is the number of times Tanya shouts \"YAY!\" while making the message,  the second number is the number of times Tanya says \"WHOOPS\" while making the message.\n\nInputCopyAbCDCbAOutputCopy3 0InputCopyABCabcOutputCopy0 3InputCopyabacabaAbaCaBAOutputCopy3 4\n\nInputCopyAbCDCbA\n\nOutputCopy3 0\n\nInputCopyABCabc\n\nOutputCopy0 3\n\nInputCopyabacabaAbaCaBA\n\nOutputCopy3 4",
      "solutions": [
        {
          "title": "Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #293 (Div. 2). It will be held on Tuesday, February 24 at 19:30 MSK and as usual Div. 1 participants are invited to join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear friends Pavel Kholkin (HolkinPV), Arthur Svechnikov (ikar) and Vitaliy Kudasov (kuviman) for writing solutions.It will be a little unusual round — you will be given six problems and two and half hours to solve them.UPD Score distribution will be 500-1000-1500-2000-2500-2500. Good luck everyone!UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! urkkvr145 0o00oo0o000oo00o sorry_t0nyukuk NgocHai GintokiSakata",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces",
          "content": "517A — Vitaly and StringsTo solve this problem we can, for example, find string next, which lexicographically next to string s and check that string next is lexicographically less than string t. If string next is lexicographically smaller than string t, print string next and finish algorithm. If string next is equal to string t print No such string.To find string next, which lexicographically next to string s, at first we need to find maximal suffix of string s, consisting from letters 'z', change all letters 'z' in this suffix on letters 'a', and then letter before this suffix increase on one. I.e. if before suffix was letter, for example, 'd', we need to change it on letter 'e'.Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.517B — Tanya and PostcardTo solve this problem at first will count array cnt[], where cnt[c] — how many times letter c found in string t. We will count two numbers ans1 and ans2 — how many times Tanya will shouts joyfully YAY! and how many times Tanya will says WHOOPS.Let's iterate on string s and if cnt[s[i]] > 0, then increase ans1 on one and decrease cnt[s[i]] on one.Then let's again iterate on string s. Let c is letter which equal to s[i],but in the opposite case for it. I. e. if s[i] = 'w', then c = 'W'. Now, if cnt[c] > 0, then increase ans2 on one and decrease cnt[с] on one.Now, print two numbers — ans1 and ans2.Asymptotic behavior of this solution — O(|s| + |t|), where |s| — length of string s and |t| — length of string t.517C — Anya and SmartphoneTo solve this problem we will store two arrays — a[] and pos[]. In array a[] will store current order of icons, i. e. in a[i] store number of application, icon which stay on position i. In array pos[] will store on which place in list stays icons, i. e. in pos[i] store in which position of array a[] stay icon of application number i. We will count answer in variable ans. Let's iterate on applications which we need to open. Let current application has number num. Then to ans we need add (pos[num] / k + 1). Now, if icon of application number num doesn't stay on first position in list of applications, we make the following — swap a[pos[num]] and a[pos[num] - 1] and update values in array pos[] for indexes of two icons which numbers a[pos[num]] and a[pos[num] - 1] . Asymptotic behavior of this solution — O(n + m), where n — number of applications, m — number of requests to start applications.517D — Ilya and EscalatorTo solve this problem let's use dynamic programming. We will store two-dimensional array z[][] with type double. In z[i][j] will store the likelihood that after i seconds j people are on escalator.In dynamic will be following transitions. If j = n, i. e. all n people already on escalator then we make transition z[i + 1][j] +  = z[i][j]. Else, or person number j go to escalator in i + 1 second, i. e. z[i + 1][j + 1] +  = z[i][j] * p, or person number j stays on his place, i. e. z[i + 1][j] +  = z[i][j] * (1 – p).Now we need to count answer — it is sum on j from 0 to n inclusive z[t][j] * j.Asymptotic behavior of this solution — O(t * n), where t — on which moment we must count answer, n — how many people stay before escalator in the beginning.517E — Arthur and QuestionsAt first let's take two sums a1 + a2 + ... + ak and a2 + a3 + ... + ak + 1. It is correct that a1 + a2 + ... + ak < a2 + a3 + ... + ak + 1. If move from right to left all elements apart from ak + 1, all of them will reduce and will left only a1 < ak + 1. If write further all sums we will obtain that sequence disintegrate on k disjoint chains: a1 < ak + 1 < a2k + 1 < a3k + 1..., a2 < ak + 2 < a2k + 2 < a3k + 2..., ..., ak < a2k < a3k....We will solve the problem for every chain separately. Let's iterate on first chain and find all pair of indexes i, j (i < j), that a[i] and a[j] are numbers (not questions) in given sequence, and for all k from i + 1 to j - 1 in a[k] stay questions. All this questions we need to change on numbers so does not violate the terms of the increase and minimize sum of absolute values of this numbers.Between indexes i and j stay j - i - 1 questions, we can change them on a[j] - a[i] - 1 numbers. If j - i - 1 > a[j] - a[i] - 1, then we need to print Incorrect sequence and finish algorithm. Else we need to change all this questions to numbers in greedy way. Here we have several cases. Will review one case when a[i] >  = 0 and a[j] >  = 0. Let current chain (3, ?, ?, ?, 9), i = 1, j = 5. We need to change questions on numbers in the following way — (3, 4, 5, 6, 9). In other cases (when a[i] <  = 0, a[j] <  = 0 and when a[i] <  = 0, a[j] >  = 0) we need to use greedy similary to first so does not violate the terms of the increase and minimize sum of absolute values of this numbers.Asymptotic behavior of this solution — O(n), where n — count of elements in given sequence.517F — Pasha and PipeAt first let's count two two-dimensional arrays of prefix sums sumv[][] and sumg[][]. In sumv[i][j] store how many grids are in column j beginning from row 1 to row i. In sumg[i][j] store how many grid are in row i beginning from column 1 to column j.Let's count ans0 — how many pipes without bending we can pave. Count how many vertical pipes — we can pave. Iterate on j from 2 to m — 1 and, if sumg[n][j] — sumg[n][0] = 0 (i. e. in this column zero grids), increase ans0 on one. Similary count number of horizontal pipes.Let's count ans1 — how many pipes with 1 bending we can pave. We need to brute cell, in which will bending. There are four cases. Let's consider first case, others we can count similary. This case — pipe begin in left column, go to current cell in brute and then go to top row. If brute cell in row i and column j then to ans1 we need to add one, if (sumg[i][j] — sumg[i][0]) + (sumv[i][j] — sumv[0][j]) = 0.Let's count ans2 — how many pipes with 2 bendings we can pave. Let's count how many tunes begin from top row and end in top or bottom row and add this number to ans2. Then rotate our matrix three times on 90 degrees and after every rotate add to ans2 count of pipes, which begin from top row and end in top or bottom row. Then we need divide ans2 to 2, because every pipe will count twice.How we can count to current matrix how many pipes begin from top row and end in top or bottom row? Let's count four two-dimension arrays lf[][], rg[][], sumUp[][], sumDown[][]. If i — number of row, j — number of column of current cell, then in position (i, lf[i][j]) in matrix are nearest from left grid for cell (i, j), and in position (i, rg[i][j]) in matrix are nearest from right grid for cell (i, j). sumUp[i][j] — how many columns without grids are in submatrix from (1, 1) to (i, j) of given matrix. sumDown[i][j] — how many columns without grids are in submatrix from (i, 1) to (n, j) of given matrix. Then let's brute cell in which will be the first bending of pipe (pipe goes from top row and in this cell turned to left or to right), check, that in column j above this cell 0 grids, with help of arrays lf and rg find out as far as pipe can go to left or to right and with help of arrays sumUp and sumDown carefully update answer. Now print number ans1 + ans2 + ans3.Asymptotic behavior of this solution — O(n * m * const), where n — hoew many rows in given matrix, m — how many columns in given matrix, const takes different values depending on the implementation, in solution from editorial const = 10.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16598",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7412
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 2",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 3",
          "code": "M[i][i] = (1-p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 4",
          "code": "M[i][i-1]=p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 5",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 6",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 7",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 8",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 9",
          "code": "std::cout.precision(8)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::iostream::operator <<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 11",
          "code": "for (int i = 0; i < (int)strlen(A); i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 12",
          "code": "int lenA = strlen(A); for (int i = 0; i < len; i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 200000;\n    string s = inf.readLine();\n    int s_length = int(s.size());\n    ensuref(1 <= s_length && s_length <= MAX_N, \"Length of s must be between 1 and %d, but got %d\", MAX_N, s_length);\n    for (char c : s) {\n        ensuref(isalpha(c), \"String s must contain only English letters, but found '%c'\", c);\n    }\n    string t = inf.readLine();\n    int t_length = int(t.size());\n    ensuref(s_length <= t_length && t_length <= MAX_N, \"Length of t must be between %d and %d, but got t.size()=%d and s.size()=%d\", s_length, MAX_N, t_length, s_length);\n    for (char c : t) {\n        ensuref(isalpha(c), \"String t must contain only English letters, but found '%c'\", c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 200000;\n    string s = inf.readLine();\n    int s_length = int(s.size());\n    ensuref(1 <= s_length && s_length <= MAX_N, \"Length of s must be between 1 and %d, but got %d\", MAX_N, s_length);\n    for (char c : s) {\n        ensuref(isalpha(c), \"String s must contain only English letters, but found '%c'\", c);\n    }\n    string t = inf.readLine();\n    int t_length = int(t.size());\n    ensuref(s_length <= t_length && t_length <= MAX_N, \"Length of t must be between %d and %d, but got t.size()=%d and s.size()=%d\", s_length, MAX_N, t_length, s_length);\n    for (char c : t) {\n        ensuref(isalpha(c), \"String t must contain only English letters, but found '%c'\", c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    const int MAX_N = 200000;\n    string s = inf.readLine();\n    int s_length = int(s.size());\n    ensuref(1 <= s_length && s_length <= MAX_N, \"Length of s must be between 1 and %d, but got %d\", MAX_N, s_length);\n    for (char c : s) {\n        ensuref(isalpha(c), \"String s must contain only English letters, but found '%c'\", c);\n    }\n    string t = inf.readLine();\n    int t_length = int(t.size());\n    ensuref(s_length <= t_length && t_length <= MAX_N, \"Length of t must be between %d and %d, but got t.size()=%d and s.size()=%d\", s_length, MAX_N, t_length, s_length);\n    for (char c : t) {\n        ensuref(isalpha(c), \"String t must contain only English letters, but found '%c'\", c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to generate a string of given length and type */\nstring generate_string(int length, string type) {\n    string s(length, 'a');\n    if (type == \"random\") {\n        for (int i = 0; i < length; ++i) {\n            int letter = rnd.next(0, 51); // 26 uppercase + 26 lowercase letters\n            if (letter < 26)\n                s[i] = 'A' + letter; // Uppercase letters\n            else\n                s[i] = 'a' + (letter - 26); // Lowercase letters\n        }\n    } else if (type == \"uppercase\") {\n        for (int i = 0; i < length; ++i) {\n            s[i] = 'A' + rnd.next(0, 25);\n        }\n    } else if (type == \"lowercase\") {\n        for (int i = 0; i < length; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    } else if (type == \"alternating_case\") {\n        for (int i = 0; i < length; ++i) {\n            char base = (i % 2 == 0) ? 'a' : 'A';\n            s[i] = base + rnd.next(0, 25);\n        }\n    } else if (type == \"same_letter\") {\n        char c;\n        int letter = rnd.next(0, 51);\n        if (letter < 26)\n            c = 'A' + letter;\n        else\n            c = 'a' + (letter - 26);\n        s = string(length, c);\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i < (length + 1) / 2; ++i) {\n            int letter = rnd.next(0, 51);\n            char c;\n            if (letter < 26)\n                c = 'A' + letter;\n            else\n                c = 'a' + (letter - 26);\n            s[i] = c;\n            s[length - i - 1] = c;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < length; ++i) {\n            int letter = rnd.next(0, 51);\n            if (letter < 26)\n                s[i] = 'A' + letter;\n            else\n                s[i] = 'a' + (letter - 26);\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Length of s\n    int m = opt<int>(\"m\", n); // Length of t, default to n if not specified\n\n    // Check constraints\n    if (n < 1 || n > 200000) {\n        cerr << \"n is out of bounds\" << endl;\n        return 1;\n    }\n    if (m < n || m > 200000) {\n        cerr << \"m is out of bounds or less than n\" << endl;\n        return 1;\n    }\n\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string t_type = opt<string>(\"t_type\", \"random\");\n\n    // Generate string s\n    string s = generate_string(n, s_type);\n    string t;\n\n    // Generate string t based on t_type\n    if (t_type == \"same_as_s\") {\n        t = s;\n    } else if (t_type == \"random_shuffle_s\") {\n        vector<char> chars(s.begin(), s.end());\n        shuffle(chars.begin(), chars.end());\n        t = string(chars.begin(), chars.end());\n        // Add random letters if t needs to be longer\n        while ((int)t.size() < m) {\n            t += generate_string(1, \"random\");\n        }\n    } else if (t_type == \"reverse_s\") {\n        t = s;\n        reverse(t.begin(), t.end());\n        // Add random letters if t needs to be longer\n        while ((int)t.size() < m) {\n            t += generate_string(1, \"random\");\n        }\n    } else if (t_type == \"uppercase\") {\n        t = generate_string(m, \"uppercase\");\n    } else if (t_type == \"lowercase\") {\n        t = generate_string(m, \"lowercase\");\n    } else if (t_type == \"missing_letters\") {\n        t = \"\";\n        set<char> letters_in_s(s.begin(), s.end());\n        set<char> letters_to_use;\n        for (char c = 'A'; c <= 'Z'; ++c) letters_to_use.insert(c);\n        for (char c = 'a'; c <= 'z'; ++c) letters_to_use.insert(c);\n        // Remove some letters present in s from letters_to_use\n        int num_missing = min((int)letters_in_s.size(), rnd.next(1, (int)letters_in_s.size()));\n        vector<char> letters_vec(letters_in_s.begin(), letters_in_s.end());\n        shuffle(letters_vec.begin(), letters_vec.end());\n        for (int i = 0; i < num_missing; ++i) {\n            letters_to_use.erase(letters_vec[i]);\n        }\n        // Build t from letters_to_use\n        vector<char> letters_pool(letters_to_use.begin(), letters_to_use.end());\n        for (int i = 0; i < m; ++i) {\n            char c = letters_pool[rnd.next(0, (int)letters_pool.size() - 1)];\n            t += c;\n        }\n    } else if (t_type == \"all_different\") {\n        // t does not share any letters with s\n        set<char> letters_in_s(s.begin(), s.end());\n        set<char> letters_in_t;\n        for (char c = 'A'; c <= 'Z'; ++c) {\n            if (!letters_in_s.count(c))\n                letters_in_t.insert(c);\n        }\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (!letters_in_s.count(c))\n                letters_in_t.insert(c);\n        }\n        // If letters_in_t is empty, generate random t\n        if (letters_in_t.empty()) {\n            t = generate_string(m, \"random\");\n        } else {\n            // Build t from letters_in_t\n            vector<char> letters_pool(letters_in_t.begin(), letters_in_t.end());\n            for (int i = 0; i < m; ++i) {\n                char c = letters_pool[rnd.next(0, (int)letters_pool.size() - 1)];\n                t += c;\n            }\n        }\n    } else {\n        // Default to random\n        t = generate_string(m, t_type);\n    }\n\n    // Ensure that t has length exactly m\n    if ((int)t.size() > m) {\n        t = t.substr(0, m);\n    } else {\n        while ((int)t.size() < m) {\n            t += generate_string(1, \"random\");\n        }\n    }\n\n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Function to generate a string of given length and type */\nstring generate_string(int length, string type) {\n    string s(length, 'a');\n    if (type == \"random\") {\n        for (int i = 0; i < length; ++i) {\n            int letter = rnd.next(0, 51); // 26 uppercase + 26 lowercase letters\n            if (letter < 26)\n                s[i] = 'A' + letter; // Uppercase letters\n            else\n                s[i] = 'a' + (letter - 26); // Lowercase letters\n        }\n    } else if (type == \"uppercase\") {\n        for (int i = 0; i < length; ++i) {\n            s[i] = 'A' + rnd.next(0, 25);\n        }\n    } else if (type == \"lowercase\") {\n        for (int i = 0; i < length; ++i) {\n            s[i] = 'a' + rnd.next(0, 25);\n        }\n    } else if (type == \"alternating_case\") {\n        for (int i = 0; i < length; ++i) {\n            char base = (i % 2 == 0) ? 'a' : 'A';\n            s[i] = base + rnd.next(0, 25);\n        }\n    } else if (type == \"same_letter\") {\n        char c;\n        int letter = rnd.next(0, 51);\n        if (letter < 26)\n            c = 'A' + letter;\n        else\n            c = 'a' + (letter - 26);\n        s = string(length, c);\n    } else if (type == \"palindrome\") {\n        for (int i = 0; i < (length + 1) / 2; ++i) {\n            int letter = rnd.next(0, 51);\n            char c;\n            if (letter < 26)\n                c = 'A' + letter;\n            else\n                c = 'a' + (letter - 26);\n            s[i] = c;\n            s[length - i - 1] = c;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < length; ++i) {\n            int letter = rnd.next(0, 51);\n            if (letter < 26)\n                s[i] = 'A' + letter;\n            else\n                s[i] = 'a' + (letter - 26);\n        }\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\"); // Length of s\n    int m = opt<int>(\"m\", n); // Length of t, default to n if not specified\n\n    // Check constraints\n    if (n < 1 || n > 200000) {\n        cerr << \"n is out of bounds\" << endl;\n        return 1;\n    }\n    if (m < n || m > 200000) {\n        cerr << \"m is out of bounds or less than n\" << endl;\n        return 1;\n    }\n\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string t_type = opt<string>(\"t_type\", \"random\");\n\n    // Generate string s\n    string s = generate_string(n, s_type);\n    string t;\n\n    // Generate string t based on t_type\n    if (t_type == \"same_as_s\") {\n        t = s;\n    } else if (t_type == \"random_shuffle_s\") {\n        vector<char> chars(s.begin(), s.end());\n        shuffle(chars.begin(), chars.end());\n        t = string(chars.begin(), chars.end());\n        // Add random letters if t needs to be longer\n        while ((int)t.size() < m) {\n            t += generate_string(1, \"random\");\n        }\n    } else if (t_type == \"reverse_s\") {\n        t = s;\n        reverse(t.begin(), t.end());\n        // Add random letters if t needs to be longer\n        while ((int)t.size() < m) {\n            t += generate_string(1, \"random\");\n        }\n    } else if (t_type == \"uppercase\") {\n        t = generate_string(m, \"uppercase\");\n    } else if (t_type == \"lowercase\") {\n        t = generate_string(m, \"lowercase\");\n    } else if (t_type == \"missing_letters\") {\n        t = \"\";\n        set<char> letters_in_s(s.begin(), s.end());\n        set<char> letters_to_use;\n        for (char c = 'A'; c <= 'Z'; ++c) letters_to_use.insert(c);\n        for (char c = 'a'; c <= 'z'; ++c) letters_to_use.insert(c);\n        // Remove some letters present in s from letters_to_use\n        int num_missing = min((int)letters_in_s.size(), rnd.next(1, (int)letters_in_s.size()));\n        vector<char> letters_vec(letters_in_s.begin(), letters_in_s.end());\n        shuffle(letters_vec.begin(), letters_vec.end());\n        for (int i = 0; i < num_missing; ++i) {\n            letters_to_use.erase(letters_vec[i]);\n        }\n        // Build t from letters_to_use\n        vector<char> letters_pool(letters_to_use.begin(), letters_to_use.end());\n        for (int i = 0; i < m; ++i) {\n            char c = letters_pool[rnd.next(0, (int)letters_pool.size() - 1)];\n            t += c;\n        }\n    } else if (t_type == \"all_different\") {\n        // t does not share any letters with s\n        set<char> letters_in_s(s.begin(), s.end());\n        set<char> letters_in_t;\n        for (char c = 'A'; c <= 'Z'; ++c) {\n            if (!letters_in_s.count(c))\n                letters_in_t.insert(c);\n        }\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (!letters_in_s.count(c))\n                letters_in_t.insert(c);\n        }\n        // If letters_in_t is empty, generate random t\n        if (letters_in_t.empty()) {\n            t = generate_string(m, \"random\");\n        } else {\n            // Build t from letters_in_t\n            vector<char> letters_pool(letters_in_t.begin(), letters_in_t.end());\n            for (int i = 0; i < m; ++i) {\n                char c = letters_pool[rnd.next(0, (int)letters_pool.size() - 1)];\n                t += c;\n            }\n        }\n    } else {\n        // Default to random\n        t = generate_string(m, t_type);\n    }\n\n    // Ensure that t has length exactly m\n    if ((int)t.size() > m) {\n        t = t.substr(0, m);\n    } else {\n        while ((int)t.size() < m) {\n            t += generate_string(1, \"random\");\n        }\n    }\n\n    // Output s and t\n    cout << s << endl;\n    cout << t << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -s_type random -t_type random\n./gen -n 1 -m 1 -s_type uppercase -t_type uppercase\n./gen -n 1 -m 1 -s_type lowercase -t_type lowercase\n\n./gen -n 2 -s_type lowercase -t_type uppercase\n./gen -n 2 -s_type uppercase -t_type lowercase\n\n./gen -n 5 -s_type same_letter -t_type same_letter\n\n./gen -n 10 -s_type random -t_type random\n./gen -n 10 -s_type uppercase -t_type random\n./gen -n 10 -s_type random -t_type uppercase\n\n./gen -n 100 -s_type random -t_type random\n\n./gen -n 1000 -s_type alternating_case -t_type alternating_case\n\n./gen -n 10000 -s_type random -t_type random\n\n./gen -n 200000 -s_type random -t_type same_as_s\n\n./gen -n 200000 -m 200000 -s_type random -t_type random\n\n./gen -n 200000 -s_type random -t_type reverse_s\n\n./gen -n 200000 -s_type random -t_type random_shuffle_s\n\n./gen -n 200000 -s_type uppercase -t_type lowercase\n\n./gen -n 200000 -s_type lowercase -t_type uppercase\n\n./gen -n 50000 -s_type random -t_type missing_letters\n\n./gen -n 100000 -s_type random -t_type all_different\n\n./gen -n 200000 -s_type palindrome -t_type palindrome\n\n./gen -n 200000 -s_type same_letter -t_type random\n\n./gen -n 200000 -s_type random -t_type same_as_s\n\n./gen -n 200000 -s_type random -t_type random\n\n./gen -n 200000 -s_type random -t_type random\n\n./gen -n 200000 -s_type random -t_type random\n\n./gen -n 200000 -s_type random -t_type random\n\n./gen -n 2 -m 200000 -s_type random -t_type random\n\n./gen -n 100000 -m 200000 -s_type random -t_type random\n\n./gen -n 150000 -m 200000 -s_type alternating_case -t_type random\n\n./gen -n 150000 -m 200000 -s_type random -t_type alternating_case\n\n./gen -n 1 -m 200000 -s_type random -t_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:33.114046",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "518/C",
      "title": "C. Аня и смартфон",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных следуют три целых числа n, m, k (1 ≤ n, m, k ≤ 105) — количество приложений, имеющихся на смартфоне Ани, количество приложений, которые будут запущены, и количество иконок, которые помещаются на одном экране соответственно.Следующая строка содержит n целых чисел, перестановку a1, a2, ..., an — изначальный порядок иконок слева направо в меню (от первой до последней), ai — это номер приложения, иконка которого i-я в меню. Каждое целое число от 1 до n встречается ровно один раз среди ai.Третья строка содержит m целых чисел b1, b2, ..., bm(1 ≤ bi ≤ n) — номера запускаемых приложений в запланированном порядке. Одно приложение может быть запущено несколько раз.",
      "output_spec": "Выходные данныеВыведите одно целое число — сколько движений пальцем надо сделать Ане, чтобы запустить приложения в запланированном ею порядке.",
      "sample_tests": "ПримерыВходные данныеСкопировать8 3 31 2 3 4 5 6 7 87 8 1Выходные данныеСкопировать7Входные данныеСкопировать5 4 23 1 5 2 44 4 4 4Выходные данныеСкопировать8",
      "description": "C. Аня и смартфон\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных следуют три целых числа n, m, k (1 ≤ n, m, k ≤ 105) — количество приложений, имеющихся на смартфоне Ани, количество приложений, которые будут запущены, и количество иконок, которые помещаются на одном экране соответственно.Следующая строка содержит n целых чисел, перестановку a1, a2, ..., an — изначальный порядок иконок слева направо в меню (от первой до последней), ai — это номер приложения, иконка которого i-я в меню. Каждое целое число от 1 до n встречается ровно один раз среди ai.Третья строка содержит m целых чисел b1, b2, ..., bm(1 ≤ bi ≤ n) — номера запускаемых приложений в запланированном порядке. Одно приложение может быть запущено несколько раз.\n\nВходные данные\n\nВыходные данныеВыведите одно целое число — сколько движений пальцем надо сделать Ане, чтобы запустить приложения в запланированном ею порядке.\n\nВыходные данные\n\nВходные данныеСкопировать8 3 31 2 3 4 5 6 7 87 8 1Выходные данныеСкопировать7Входные данныеСкопировать5 4 23 1 5 2 44 4 4 4Выходные данныеСкопировать8\n\nВходные данныеСкопировать8 3 31 2 3 4 5 6 7 87 8 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 4 23 1 5 2 44 4 4 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте исходная конфигурация выглядит как (123)(456)(78), то есть на первом экране расположены иконки приложений 1, 2, 3, на втором экране — 4, 5, 6, а на третьем экране — 7, 8. После запуска приложения номер 7 получим новое расположение иконок — (123)(457)(68). При этом для его запуска необходимо сделать 3 движения пальцем. После запуска приложения номер 8 получим конфигурацию — (123)(457)(86). При этом для его запуска необходимо сделать 3 движения пальцем. После запуска приложения номер 1 расположение иконок на экранах не меняется. При этом для его запуска необходимо сделать 1 движение пальцем.Итого, Аня сделает 7 движений пальцем.",
      "solutions": [
        {
          "title": "Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!24 февраля 2015 года в 19:30 MSK состоится очередной раунд Codeforces #293 для участников из второго дивизиона. Традиционно, участники из первого дивизиона приглашаются поучаствовать в соревновании вне конкурса.Это мой второй Codeforces раунд, и я надеюсь, что Вам понравятся задачи, и все пройдет хорошо.Хотелось бы сказать большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon и за идеи некоторых задач, а также моим дорогим друзьям Павлу Холкину (HolkinPV), Артуру Свечникову (ikar) и Виталию Кудасову (kuviman) за прорешивание задач.Раунд будет немного необычным — участникам будет предложено шесть задач и два с половиной часа на их решение.UPD Разбалловка задач 500-1000-1500-2000-2500-2500. Всем удачи!UPD2 Соревнование завершено! Всем спасибо!UPD3 Разбор вы можете найти здесь.UPD4 Поздравляем победителей! urkkvr145 0o00oo0o000oo00o sorry_t0nyukuk NgocHai GintokiSakata",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1057
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "517A — Виталий и строкиДля решения данной задачи можно было, например, найти строку next, лексикографически следующую за строкой s и проверить, что строка next лексикографически меньше строки t. Если строка next оказалась меньше строки t, выведем ее и закончим алгоритм. Если же строка next совпала со строкой t, следовало вывести No such string.Чтобы найти строку next, лексикографически следующую за s, нужно сначала найти максимальный суффикс строки s, состоящий из букв 'z', заменить все буквы 'z' в этом суффиксе на буквы 'a', а затем букву, стоящую перед этим суффиксом, увеличить на единицу. То есть, если перед суффиксом стояла, например, буква 'd', ее следует заменить на букву 'e'.Асимптотика решения — O(|s|), где |s| — длина строки s.517B — Таня и поздравлениеДля решения данной задачи, сначала насчитаем массив cnt[], где cnt[c] — сколько раз буква c встречалась в строке t. Будем считать два числа ans1 и ans2 — сколько раз Таня прокричит УРА! и сколько раз Таня произнесет ОПА.Теперь проитерируемся по строке s, и если cnt[s[i]] > 0, то прибавим к ans1 единицу и уменьшим cnt[s[i]] на единицу.Теперь вновь проитерируемся по строке s. Пусть c это буква равная s[i], но в обратном ей регистре. То есть если s[i] = 'w', то c = 'W'. Теперь, если cnt[c] > 0, то прибавим к ans2 единицу и уменьшим cnt[с] на единицу.Осталось вывести два числа — ans1 и ans2.Асимптотика решения — O(|s| + |t|), где |s| — длина строки s, а |t| — длина строки t.517C — Аня и смартфонДля решения данной задачи будем хранить два массива — a[] и pos[]. В массиве a[] будем хранить текущий порядок расположения иконок, то есть в a[i] хранится номер приложения, иконка которого стоит на i-м месте. В массиве pos[] будем хранить на каком месте в списке находятся иконки, то есть в pos[i] хранится в какой позиции массива a[] находится иконка приложения номер i. Будем считать ответ в переменной ans. Проитерируемся по приложениям, которые нужно открыть. Пусть текущее приложение имеет номер num. Тогда нужно к ans прибавить pos[num] / k + 1 (первый член суммы — количество движений пальцем, чтобы долистать до нужного экрана, второй член суммы — одно движение пальцем для открытия приложения). Теперь, если иконка приложения номер num не стоит на первом месте в списке приложений, сделаем следующее — поменяем местами значения a[pos[num]] и a[pos[num] - 1] и обновим значения pos[] для иконок приложений, чьи номера равны a[pos[num]] и a[pos[num] - 1]. Асимптотика решения — O(n + m), где n — количество приложений, m — количество запросов на запуск приложений.517D — Илья и эскалаторДля решения данной задачи воспользуемся динамическим программированием. Будем хранить двумерный массив z типа double . В z[i][j] будет храниться вероятность того, что через i секунд j человек зашли на эскалатор.В динамике будут следующие переходы. Если j = n, то есть все n людей уже находятся на эскалаторе, тогда сделаем переход z[i + 1][j] +  = z[i][j]. Иначе, либо j-й человек зайдет на эскалатор в i + 1 секунду, то есть z[i + 1][j + 1] +  = z[i][j] * p, либо j-й человек останется на месте, то есть z[i + 1][j] +  = z[i][j] * (1 – p).Осталось посчитать ответ (математическое ожидание количества людей на эскалаторе) — это сумма по j от 0 до n включительно z[t][j] * j.Асимптотика решения — O(t * n), где t — на какой момент нужно посчитать матожидание, n — сколько людей сначала стоит у эскалатора.517E — Артур и вопросыСначала заметим следующий факт. Возьмем первые две суммы a1 + a2 + ... + ak и a2 + a3 + ... + ak + 1. Должно выполниться неравенство a1 + a2 + ... + ak < a2 + a3 + ... + ak + 1. Если перенести справа налево все элементы кроме ak + 1, все они сократятся и останется a1 < ak + 1. Если выписать далее все подобные суммы получится, что последовательность распадается на k непересекающихся цепочек: a1 < ak + 1 < a2k + 1 < a3k + 1..., a2 < ak + 2 < a2k + 2 < a3k + 2..., ..., ak < a2k < a3k....Будем решать задачу для каждой цепочки отдельно. Рассмотрим первую цепочку a1, ak + 1, a2k + 1.... Проитерируемся по ней, и найдем все пары индексов i, j (i < j), что a[i] и a[j] это числа, а не вопросы, в заданной последовательности, а для всех k от i + 1 до j - 1 в a[k] стоят знаки вопроса. Тогда понятно, что все эти вопросы нужно заменить на числа таким образом, чтобы не нарушить условие возрастания и при этом минимизировать сумму модулей поставленных чисел.Понятно, что между индексами i и j стоит j - i - 1 знак вопроса, их можно заменить на a[j] - a[i] - 1 чисел. Если j - i - 1 > a[j] - a[i] - 1, тогда нужно вывести Incorrect sequence и закончить алгоритм. Иначе нужно жадным образом заменить все эти вопросы на числа. Здесь возможно несколько случаев. Рассмотрим один из них, когда a[i] >  = 0 и a[j] >  = 0. Пусть текущая цепочка (3, ?, ?, ?, 9), i = 1, j = 5. Знаки вопроса нужно заменить следующим образом — (3, 4, 5, 6, 9). Осталось два случая, когда a[i] <  = 0, a[j] <  = 0, и случай, когда a[i] <  = 0, a[j] >  = 0. В таких случаях нужно поступать жадным образом, аналогично первому, не нарушая условие возрастания и минимизируя сумму модулей поставленных чисел.Асимптотика решения — O(n), где n — количество элементов в заданной последовательности.517F — Паша и трубаБудем решать данную задачу поэтапно. Сначала насчитаем два двумерных массива частичных сумм sumv[][] и sumg[][]. В sumv[i][j] хранится сколько решеток стоит в столбце j начиная со строки 1 до строки i. В sumg[i][j] хранится сколько решеток стоит в строке i начиная со столбца 1 до столбца j.Посчитаем ans0 — сколько труб без изгибов можно проложить. Посчитаем количество вертикальных труб — проитерируемся по j от 2 до m — 1 и, если sumg[n][j] — sumg[n][0] = 0 (то есть в этом столбце нет ни одной решетки), прибавим к ans0 единицу. Аналогично посчитаем количество горизонтальных труб.Посчитаем ans1 — сколько труб с 1 изгибом можно проложить. Переберем клетку, в которой будет изгиб (по условию эта клетка не должна лежать на краях поля). Возможны четыре случая: труба начинается слева, доходит до текущей перебираемой клетки и поворачивает вверх; труба начинается сверху, доходит до текущей перебираемой клетки и поворачивает вправо; труба начинается справа, доходит до текущей перебираемой клетки и поворачивает вниз; труба начинается снизу, доходит до текущей перебираемой клетки и поворачивает влево.Рассмотрим первый случай — труба начинается слева, доходит до текущей перебираемой клетки и поворачивает вверх. Пусть клетка поворота находится в i-й строке и j-м столбце. Тогда к ans1 нужно прибавить единицу, если (sumg[i][j] — sumg[i][0]) + (sumv[i][j] — sumv[0][j]) = 0. Для оставшихся случаев нужно сделать аналогичным образом.Осталось посчитать ans2 — сколько труб с 2 изгибами можно проложить. Поступим следующим образом. Посчитаем сколько труб начинаются сверху и заканчиваются сверху или снизу, и прибавим это число к ans2. Затем повернем матрицу три раза на 90 градусов и после каждого поворота прибавим к ans2 количество труб, начинающихся сверху и заканчивающихся сверху или снизу. Если считать таким образом, каждая труба посчитается по два раза, поэтому ans2 нужно поделить пополам.Как посчитать для текущей матрицы сколько труб начинаются сверху и заканчиваются сверху или снизу. Насчитаем четыре двумерных массива lf[][], rg[][], sumUp[][], sumDown[][]. Пусть i — номер строки, j — номер столбца текущей клетки. Тогда в позиции (i, lf[i][j]) в матрице находится ближайшая слева решетка для клетки (i, j), а в позиции (i, rg[i][j]) в матрице находится ближайшая справа решетка для клетки (i, j). В sumUp[i][j] должно быть число — сколько столбцов без решеток содержится в подматрице от (1, 1) до (i, j) исходной матрицы. В sumDown[i][j] должно быть число — сколько столбцов без решеток содержится в подматрице от (i, 1) до (n, j) исходной матрицы. Осталось перебрать клетку, в которой произойдет первый поворот трубы (она шла сверху и повернула направо или налево), проверить что в столбце j над этой клеткой нет решеток, с помощью массивов lf и rg узнать насколько труба могла идти налево или направо и с помощью массивов sumUp и sumDown аккуратно пересчитать ответ. Осталось вывести число ans1 + ans2 + ans3.Асимптотика решения — O(n * m * const), где n — количество строк в заданной матрице, m — количество столбцов в заданной матрице, const принимает различные значения в зависимости от реализации, в решении из разбора const = 10.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16598",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 8324
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 3",
          "code": "M[i][i] = (1-p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 4",
          "code": "M[i][i-1]=p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 5",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 6",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 7",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 8",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 9",
          "code": "std::cout.precision(8)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 10",
          "code": "std::iostream::operator <<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 11",
          "code": "for (int i = 0; i < (int)strlen(A); i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 12",
          "code": "int lenA = strlen(A); for (int i = 0; i < len; i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    // Check that 'a' is a permutation of 1 to n\n    vector<bool> seen(n+1, false);\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!seen[ai], \"Element %d occurs multiple times in 'a'\", ai);\n        seen[ai] = true;\n    }\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    // Check that 'a' is a permutation of 1 to n\n    vector<bool> seen(n+1, false);\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!seen[ai], \"Element %d occurs multiple times in 'a'\", ai);\n        seen[ai] = true;\n    }\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, n, \"a\");\n    inf.readEoln();\n\n    // Check that 'a' is a permutation of 1 to n\n    vector<bool> seen(n+1, false);\n    for (int i = 0; i < n; ++i) {\n        int ai = a[i];\n        ensuref(!seen[ai], \"Element %d occurs multiple times in 'a'\", ai);\n        seen[ai] = true;\n    }\n\n    vector<int> b = inf.readInts(m, 1, n, \"b\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n\n    string initial = opt<string>(\"initial\", \"random\");\n    string btype = opt<string>(\"btype\", \"random\");\n    int app = opt<int>(\"app\", 1);\n\n    // Ensure parameters are within constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 100000);\n    ensure(1 <= k && k <= 100000);\n    ensure(1 <= app && app <= n);\n\n    vector<int> a(n);\n\n    if (initial == \"sorted\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n    } else if (initial == \"reversed\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = n - i;\n        }\n    } else if (initial == \"almostsorted\") {\n        // Swap a few elements.\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        int swaps = n / 10; // Swap 10% of the elements.\n        for (int i = 0; i < swaps; i++) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            swap(a[u], a[v]);\n        }\n    } else if (initial == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    vector<int> b(m);\n\n    if (btype == \"random\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n    } else if (btype == \"same\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = app;\n        }\n    } else if (btype == \"increasing\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = (i % n) + 1;\n        }\n    } else if (btype == \"decreasing\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = n - (i % n);\n        }\n    } else if (btype == \"front\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = 1;\n        }\n    } else if (btype == \"back\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = n;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; i++) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n\n    string initial = opt<string>(\"initial\", \"random\");\n    string btype = opt<string>(\"btype\", \"random\");\n    int app = opt<int>(\"app\", 1);\n\n    // Ensure parameters are within constraints\n    ensure(1 <= n && n <= 100000);\n    ensure(1 <= m && m <= 100000);\n    ensure(1 <= k && k <= 100000);\n    ensure(1 <= app && app <= n);\n\n    vector<int> a(n);\n\n    if (initial == \"sorted\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n    } else if (initial == \"reversed\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = n - i;\n        }\n    } else if (initial == \"almostsorted\") {\n        // Swap a few elements.\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        int swaps = n / 10; // Swap 10% of the elements.\n        for (int i = 0; i < swaps; i++) {\n            int u = rnd.next(0, n - 1);\n            int v = rnd.next(0, n - 1);\n            swap(a[u], a[v]);\n        }\n    } else if (initial == \"random\") {\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            a[i] = i + 1;\n        }\n        shuffle(a.begin(), a.end());\n    }\n\n    vector<int> b(m);\n\n    if (btype == \"random\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n    } else if (btype == \"same\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = app;\n        }\n    } else if (btype == \"increasing\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = (i % n) + 1;\n        }\n    } else if (btype == \"decreasing\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = n - (i % n);\n        }\n    } else if (btype == \"front\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = 1;\n        }\n    } else if (btype == \"back\") {\n        for (int i = 0; i < m; i++) {\n            b[i] = n;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n    }\n\n    // Output\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < m; i++) {\n        printf(\"%d%c\", b[i], i == m - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -k 1 -initial sorted -btype same -app 1\n./gen -n 2 -m 2 -k 1 -initial sorted -btype decreasing\n./gen -n 5 -m 5 -k 2 -initial reversed -btype increasing\n./gen -n 5 -m 5 -k 3 -initial random -btype random\n\n./gen -n 100 -m 100 -k 10 -initial sorted -btype random\n./gen -n 100 -m 100 -k 10 -initial reversed -btype random\n./gen -n 100 -m 100 -k 1 -initial sorted -btype increasing\n./gen -n 100 -m 100 -k 1 -initial reversed -btype decreasing\n./gen -n 100 -m 100 -k 100 -initial random -btype same -app 1\n./gen -n 100 -m 100 -k 100 -initial sorted -btype same -app 100\n\n./gen -n 100000 -m 100000 -k 1 -initial sorted -btype random\n./gen -n 100000 -m 100000 -k 1 -initial reversed -btype random\n./gen -n 100000 -m 100000 -k 1 -initial sorted -btype increasing\n./gen -n 100000 -m 100000 -k 1 -initial reversed -btype decreasing\n./gen -n 100000 -m 100000 -k 100000 -initial random -btype same -app 1\n./gen -n 100000 -m 100000 -k 100000 -initial sorted -btype same -app 100000\n./gen -n 100000 -m 100000 -k 100000 -initial random -btype random\n./gen -n 100000 -m 100000 -k 50000 -initial sorted -btype random\n./gen -n 100000 -m 100000 -k 50000 -initial reversed -btype random\n\n./gen -n 100000 -m 100000 -k 10 -initial reversed -btype increasing\n./gen -n 100000 -m 100000 -k 10 -initial sorted -btype decreasing\n\n./gen -n 100000 -m 100000 -k 1000 -initial reversed -btype same -app 100000\n./gen -n 100000 -m 100000 -k 1000 -initial sorted -btype same -app 1\n\n./gen -n 100000 -m 100000 -k 1 -initial sorted -btype same -app 1\n./gen -n 100000 -m 100000 -k 1 -initial reversed -btype same -app 1\n\n./gen -n 100000 -m 100000 -k 2 -initial reversed -btype same -app 100000\n\n./gen -n 100000 -m 100000 -k 50000 -initial random -btype random\n\n./gen -n 100000 -m 100000 -k 1 -initial random -btype random\n./gen -n 100000 -m 100000 -k 100000 -initial random -btype random\n\n./gen -n 99999 -m 99999 -k 33333 -initial random -btype random\n\n./gen -n 100000 -m 100000 -k 1000 -initial sorted -btype increasing\n./gen -n 100000 -m 100000 -k 1000 -initial reversed -btype decreasing\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:34.743860",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "518/D",
      "title": "D. Илья и эскалатор",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных следуют три числа n, p, t (1 ≤ n, t ≤ 2000, 0 ≤ p ≤ 1). Числа n и t — целые, чиcло p — вещественное, заданное ровно с двумя знаками после запятой.",
      "output_spec": "Выходные данныеВыведите одно вещественное число — математическое ожидание количества людей, которые будут на эскалаторе через t секунд. Абсолютная или относительная погрешность не должна превышать 10 - 6.",
      "sample_tests": "ПримерыВходные данныеСкопировать1 0.50 1Выходные данныеСкопировать0.5Входные данныеСкопировать1 0.50 4Выходные данныеСкопировать0.9375Входные данныеСкопировать4 0.20 2Выходные данныеСкопировать0.4",
      "description": "D. Илья и эскалатор\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке входных данных следуют три числа n, p, t (1 ≤ n, t ≤ 2000, 0 ≤ p ≤ 1). Числа n и t — целые, чиcло p — вещественное, заданное ровно с двумя знаками после запятой.\n\nВходные данные\n\nВыходные данныеВыведите одно вещественное число — математическое ожидание количества людей, которые будут на эскалаторе через t секунд. Абсолютная или относительная погрешность не должна превышать 10 - 6.\n\nВыходные данные\n\nВходные данныеСкопировать1 0.50 1Выходные данныеСкопировать0.5Входные данныеСкопировать1 0.50 4Выходные данныеСкопировать0.9375Входные данныеСкопировать4 0.20 2Выходные данныеСкопировать0.4\n\nВходные данныеСкопировать1 0.50 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.5\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 0.50 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.9375\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 0.20 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0.4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!24 февраля 2015 года в 19:30 MSK состоится очередной раунд Codeforces #293 для участников из второго дивизиона. Традиционно, участники из первого дивизиона приглашаются поучаствовать в соревновании вне конкурса.Это мой второй Codeforces раунд, и я надеюсь, что Вам понравятся задачи, и все пройдет хорошо.Хотелось бы сказать большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon и за идеи некоторых задач, а также моим дорогим друзьям Павлу Холкину (HolkinPV), Артуру Свечникову (ikar) и Виталию Кудасову (kuviman) за прорешивание задач.Раунд будет немного необычным — участникам будет предложено шесть задач и два с половиной часа на их решение.UPD Разбалловка задач 500-1000-1500-2000-2500-2500. Всем удачи!UPD2 Соревнование завершено! Всем спасибо!UPD3 Разбор вы можете найти здесь.UPD4 Поздравляем победителей! urkkvr145 0o00oo0o000oo00o sorry_t0nyukuk NgocHai GintokiSakata",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1057
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "517A — Виталий и строкиДля решения данной задачи можно было, например, найти строку next, лексикографически следующую за строкой s и проверить, что строка next лексикографически меньше строки t. Если строка next оказалась меньше строки t, выведем ее и закончим алгоритм. Если же строка next совпала со строкой t, следовало вывести No such string.Чтобы найти строку next, лексикографически следующую за s, нужно сначала найти максимальный суффикс строки s, состоящий из букв 'z', заменить все буквы 'z' в этом суффиксе на буквы 'a', а затем букву, стоящую перед этим суффиксом, увеличить на единицу. То есть, если перед суффиксом стояла, например, буква 'd', ее следует заменить на букву 'e'.Асимптотика решения — O(|s|), где |s| — длина строки s.517B — Таня и поздравлениеДля решения данной задачи, сначала насчитаем массив cnt[], где cnt[c] — сколько раз буква c встречалась в строке t. Будем считать два числа ans1 и ans2 — сколько раз Таня прокричит УРА! и сколько раз Таня произнесет ОПА.Теперь проитерируемся по строке s, и если cnt[s[i]] > 0, то прибавим к ans1 единицу и уменьшим cnt[s[i]] на единицу.Теперь вновь проитерируемся по строке s. Пусть c это буква равная s[i], но в обратном ей регистре. То есть если s[i] = 'w', то c = 'W'. Теперь, если cnt[c] > 0, то прибавим к ans2 единицу и уменьшим cnt[с] на единицу.Осталось вывести два числа — ans1 и ans2.Асимптотика решения — O(|s| + |t|), где |s| — длина строки s, а |t| — длина строки t.517C — Аня и смартфонДля решения данной задачи будем хранить два массива — a[] и pos[]. В массиве a[] будем хранить текущий порядок расположения иконок, то есть в a[i] хранится номер приложения, иконка которого стоит на i-м месте. В массиве pos[] будем хранить на каком месте в списке находятся иконки, то есть в pos[i] хранится в какой позиции массива a[] находится иконка приложения номер i. Будем считать ответ в переменной ans. Проитерируемся по приложениям, которые нужно открыть. Пусть текущее приложение имеет номер num. Тогда нужно к ans прибавить pos[num] / k + 1 (первый член суммы — количество движений пальцем, чтобы долистать до нужного экрана, второй член суммы — одно движение пальцем для открытия приложения). Теперь, если иконка приложения номер num не стоит на первом месте в списке приложений, сделаем следующее — поменяем местами значения a[pos[num]] и a[pos[num] - 1] и обновим значения pos[] для иконок приложений, чьи номера равны a[pos[num]] и a[pos[num] - 1]. Асимптотика решения — O(n + m), где n — количество приложений, m — количество запросов на запуск приложений.517D — Илья и эскалаторДля решения данной задачи воспользуемся динамическим программированием. Будем хранить двумерный массив z типа double . В z[i][j] будет храниться вероятность того, что через i секунд j человек зашли на эскалатор.В динамике будут следующие переходы. Если j = n, то есть все n людей уже находятся на эскалаторе, тогда сделаем переход z[i + 1][j] +  = z[i][j]. Иначе, либо j-й человек зайдет на эскалатор в i + 1 секунду, то есть z[i + 1][j + 1] +  = z[i][j] * p, либо j-й человек останется на месте, то есть z[i + 1][j] +  = z[i][j] * (1 – p).Осталось посчитать ответ (математическое ожидание количества людей на эскалаторе) — это сумма по j от 0 до n включительно z[t][j] * j.Асимптотика решения — O(t * n), где t — на какой момент нужно посчитать матожидание, n — сколько людей сначала стоит у эскалатора.517E — Артур и вопросыСначала заметим следующий факт. Возьмем первые две суммы a1 + a2 + ... + ak и a2 + a3 + ... + ak + 1. Должно выполниться неравенство a1 + a2 + ... + ak < a2 + a3 + ... + ak + 1. Если перенести справа налево все элементы кроме ak + 1, все они сократятся и останется a1 < ak + 1. Если выписать далее все подобные суммы получится, что последовательность распадается на k непересекающихся цепочек: a1 < ak + 1 < a2k + 1 < a3k + 1..., a2 < ak + 2 < a2k + 2 < a3k + 2..., ..., ak < a2k < a3k....Будем решать задачу для каждой цепочки отдельно. Рассмотрим первую цепочку a1, ak + 1, a2k + 1.... Проитерируемся по ней, и найдем все пары индексов i, j (i < j), что a[i] и a[j] это числа, а не вопросы, в заданной последовательности, а для всех k от i + 1 до j - 1 в a[k] стоят знаки вопроса. Тогда понятно, что все эти вопросы нужно заменить на числа таким образом, чтобы не нарушить условие возрастания и при этом минимизировать сумму модулей поставленных чисел.Понятно, что между индексами i и j стоит j - i - 1 знак вопроса, их можно заменить на a[j] - a[i] - 1 чисел. Если j - i - 1 > a[j] - a[i] - 1, тогда нужно вывести Incorrect sequence и закончить алгоритм. Иначе нужно жадным образом заменить все эти вопросы на числа. Здесь возможно несколько случаев. Рассмотрим один из них, когда a[i] >  = 0 и a[j] >  = 0. Пусть текущая цепочка (3, ?, ?, ?, 9), i = 1, j = 5. Знаки вопроса нужно заменить следующим образом — (3, 4, 5, 6, 9). Осталось два случая, когда a[i] <  = 0, a[j] <  = 0, и случай, когда a[i] <  = 0, a[j] >  = 0. В таких случаях нужно поступать жадным образом, аналогично первому, не нарушая условие возрастания и минимизируя сумму модулей поставленных чисел.Асимптотика решения — O(n), где n — количество элементов в заданной последовательности.517F — Паша и трубаБудем решать данную задачу поэтапно. Сначала насчитаем два двумерных массива частичных сумм sumv[][] и sumg[][]. В sumv[i][j] хранится сколько решеток стоит в столбце j начиная со строки 1 до строки i. В sumg[i][j] хранится сколько решеток стоит в строке i начиная со столбца 1 до столбца j.Посчитаем ans0 — сколько труб без изгибов можно проложить. Посчитаем количество вертикальных труб — проитерируемся по j от 2 до m — 1 и, если sumg[n][j] — sumg[n][0] = 0 (то есть в этом столбце нет ни одной решетки), прибавим к ans0 единицу. Аналогично посчитаем количество горизонтальных труб.Посчитаем ans1 — сколько труб с 1 изгибом можно проложить. Переберем клетку, в которой будет изгиб (по условию эта клетка не должна лежать на краях поля). Возможны четыре случая: труба начинается слева, доходит до текущей перебираемой клетки и поворачивает вверх; труба начинается сверху, доходит до текущей перебираемой клетки и поворачивает вправо; труба начинается справа, доходит до текущей перебираемой клетки и поворачивает вниз; труба начинается снизу, доходит до текущей перебираемой клетки и поворачивает влево.Рассмотрим первый случай — труба начинается слева, доходит до текущей перебираемой клетки и поворачивает вверх. Пусть клетка поворота находится в i-й строке и j-м столбце. Тогда к ans1 нужно прибавить единицу, если (sumg[i][j] — sumg[i][0]) + (sumv[i][j] — sumv[0][j]) = 0. Для оставшихся случаев нужно сделать аналогичным образом.Осталось посчитать ans2 — сколько труб с 2 изгибами можно проложить. Поступим следующим образом. Посчитаем сколько труб начинаются сверху и заканчиваются сверху или снизу, и прибавим это число к ans2. Затем повернем матрицу три раза на 90 градусов и после каждого поворота прибавим к ans2 количество труб, начинающихся сверху и заканчивающихся сверху или снизу. Если считать таким образом, каждая труба посчитается по два раза, поэтому ans2 нужно поделить пополам.Как посчитать для текущей матрицы сколько труб начинаются сверху и заканчиваются сверху или снизу. Насчитаем четыре двумерных массива lf[][], rg[][], sumUp[][], sumDown[][]. Пусть i — номер строки, j — номер столбца текущей клетки. Тогда в позиции (i, lf[i][j]) в матрице находится ближайшая слева решетка для клетки (i, j), а в позиции (i, rg[i][j]) в матрице находится ближайшая справа решетка для клетки (i, j). В sumUp[i][j] должно быть число — сколько столбцов без решеток содержится в подматрице от (1, 1) до (i, j) исходной матрицы. В sumDown[i][j] должно быть число — сколько столбцов без решеток содержится в подматрице от (i, 1) до (n, j) исходной матрицы. Осталось перебрать клетку, в которой произойдет первый поворот трубы (она шла сверху и повернула направо или налево), проверить что в столбце j над этой клеткой нет решеток, с помощью массивов lf и rg узнать насколько труба могла идти налево или направо и с помощью массивов sumUp и sumDown аккуратно пересчитать ответ. Осталось вывести число ans1 + ans2 + ans3.Асимптотика решения — O(n * m * const), где n — количество строк в заданной матрице, m — количество столбцов в заданной матрице, const принимает различные значения в зависимости от реализации, в решении из разбора const = 10.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16598",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 8324
        }
      ],
      "code_examples": [
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 1",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 2",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 3",
          "code": "M[i][i] = (1-p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 4",
          "code": "M[i][i-1]=p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 5",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 6",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 7",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 8",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 9",
          "code": "std::cout.precision(8)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 10",
          "code": "std::iostream::operator <<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 11",
          "code": "for (int i = 0; i < (int)strlen(A); i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Разбор Codeforces Round #293 (Div. 2) - Codeforces - Code 12",
          "code": "int lenA = strlen(A); for (int i = 0; i < len; i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n\n    string p_str = inf.readToken(\"(0\\\\.[0-9]{2}|1\\\\.00)\", \"p\");\n    inf.readSpace();\n\n    int t = inf.readInt(1, 2000, \"t\");\n    inf.readEoln();\n\n    double p = atof(p_str.c_str());\n    ensuref(0.00 <= p && p <= 1.00, \"p must be between 0.00 and 1.00 inclusively, but found p = %.2lf\", p);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n\n    string p_str = inf.readToken(\"(0\\\\.[0-9]{2}|1\\\\.00)\", \"p\");\n    inf.readSpace();\n\n    int t = inf.readInt(1, 2000, \"t\");\n    inf.readEoln();\n\n    double p = atof(p_str.c_str());\n    ensuref(0.00 <= p && p <= 1.00, \"p must be between 0.00 and 1.00 inclusively, but found p = %.2lf\", p);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n\n    string p_str = inf.readToken(\"(0\\\\.[0-9]{2}|1\\\\.00)\", \"p\");\n    inf.readSpace();\n\n    int t = inf.readInt(1, 2000, \"t\");\n    inf.readEoln();\n\n    double p = atof(p_str.c_str());\n    ensuref(0.00 <= p && p <= 1.00, \"p must be between 0.00 and 1.00 inclusively, but found p = %.2lf\", p);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1E-6;\n\nbool isEqual(double a, double b) {\n    double diff = fabs(a - b);\n    if (diff <= EPS) return true;\n    if (fabs(b) < EPS) return diff <= EPS;\n    return diff / fabs(b) <= EPS;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read the participant's answer\n    double pans = ouf.readDouble();\n    // Read the jury's answer\n    double jans = ans.readDouble();\n\n    if (isnan(pans))\n        quitf(_wa, \"Participant's answer is NaN\");\n\n    // Compare the two answers with the allowed error margin\n    if (!isEqual(pans, jans)) {\n        quitf(_wa, \"Too big difference: expected %.10f, found %.10f\", jans, pans);\n    } else {\n        quitf(_ok, \"Accepted: found %.10f\", pans);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters n and t\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n\n    // Read optional parameters p and type\n    double p = opt<double>(\"p\", -1.0);\n    string type = opt<string>(\"type\", \"random_p\");\n\n    // Ensure n and t are within [1, 2000]\n    n = max(1, min(n, 2000));\n    t = max(1, min(t, 2000));\n\n    // Generate p according to the specified type if p is not provided\n    if (p < 0.0 || p > 1.0) {\n        if (type == \"zero_p\") {\n            p = 0.00;\n        } else if (type == \"one_p\") {\n            p = 1.00;\n        } else if (type == \"half_p\") {\n            p = 0.50;\n        } else if (type == \"small_p\") {\n            int pi = rnd.next(1, 10); // p between 0.01 and 0.10\n            p = pi / 100.0;\n        } else if (type == \"large_p\") {\n            int pi = rnd.next(90, 99); // p between 0.90 and 0.99\n            p = pi / 100.0;\n        } else { // \"random_p\"\n            int pi = rnd.next(0, 100); // p between 0.00 and 1.00\n            p = pi / 100.0;\n        }\n    }\n\n    // Round p to exactly two decimal places\n    p = floor(p * 100 + 0.5) / 100.0;\n\n    // Output n, p, t with correct formatting\n    printf(\"%d %.2f %d\\n\", n, p, t);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters n and t\n    int n = opt<int>(\"n\");\n    int t = opt<int>(\"t\");\n\n    // Read optional parameters p and type\n    double p = opt<double>(\"p\", -1.0);\n    string type = opt<string>(\"type\", \"random_p\");\n\n    // Ensure n and t are within [1, 2000]\n    n = max(1, min(n, 2000));\n    t = max(1, min(t, 2000));\n\n    // Generate p according to the specified type if p is not provided\n    if (p < 0.0 || p > 1.0) {\n        if (type == \"zero_p\") {\n            p = 0.00;\n        } else if (type == \"one_p\") {\n            p = 1.00;\n        } else if (type == \"half_p\") {\n            p = 0.50;\n        } else if (type == \"small_p\") {\n            int pi = rnd.next(1, 10); // p between 0.01 and 0.10\n            p = pi / 100.0;\n        } else if (type == \"large_p\") {\n            int pi = rnd.next(90, 99); // p between 0.90 and 0.99\n            p = pi / 100.0;\n        } else { // \"random_p\"\n            int pi = rnd.next(0, 100); // p between 0.00 and 1.00\n            p = pi / 100.0;\n        }\n    }\n\n    // Round p to exactly two decimal places\n    p = floor(p * 100 + 0.5) / 100.0;\n\n    // Output n, p, t with correct formatting\n    printf(\"%d %.2f %d\\n\", n, p, t);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -t 1 -type zero_p\n./gen -n 1 -t 1 -type one_p\n./gen -n 1 -t 1 -type half_p\n\n./gen -n 2000 -t 2000 -type zero_p\n./gen -n 2000 -t 2000 -type one_p\n./gen -n 2000 -t 2000 -type half_p\n\n./gen -n 1000 -t 1000 -type small_p\n./gen -n 1000 -t 1000 -type large_p\n./gen -n 1000 -t 1000 -type random_p\n\n./gen -n 1000 -t 1000 -p 0.33\n\n./gen -n 2000 -t 1 -type random_p\n./gen -n 1 -t 2000 -type random_p\n\n./gen -n 100 -t 100 -p 0.00\n./gen -n 100 -t 100 -p 1.00\n./gen -n 100 -t 100 -p 0.99\n./gen -n 100 -t 100 -p 0.01\n\n./gen -n 1500 -t 500 -type small_p\n./gen -n 500 -t 1500 -type large_p\n\n./gen -n 2000 -t 2000 -p 0.50\n\n./gen -n 100 -t 2000 -type half_p\n./gen -n 2000 -t 100 -p 0.75\n./gen -n 500 -t 500 -p 0.25\n\n./gen -n 1000 -t 2000 -p 0.00\n./gen -n 2000 -t 1000 -p 1.00\n\n./gen -n 2000 -t 2000 -type random_p\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:36.539132",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "518/E",
      "title": "E. Arthur and Questions",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 105), showing how many numbers are in Arthur's sequence and the lengths of segments respectively.The next line contains n space-separated elements ai (1 ≤ i ≤ n).If ai  =  ?, then the i-th element of Arthur's sequence was replaced by a question mark. Otherwise, ai ( - 109 ≤ ai ≤ 109) is the i-th element of Arthur's sequence.",
      "output_spec": "OutputIf Arthur is wrong at some point and there is no sequence that could fit the given information, print a single string \"Incorrect sequence\" (without the quotes).Otherwise, print n integers — Arthur's favorite sequence. If there are multiple such sequences, print the sequence with the minimum sum |ai|, where |ai| is the absolute value of ai. If there are still several such sequences, you are allowed to print any of them. Print the elements of the sequence without leading zeroes.",
      "sample_tests": "ExamplesInputCopy3 2? 1 2OutputCopy0 1 2 InputCopy5 1-10 -9 ? -7 -6OutputCopy-10 -9 -8 -7 -6 InputCopy5 34 6 7 2 9OutputCopyIncorrect sequence",
      "description": "E. Arthur and Questions\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers n and k (1 ≤ k ≤ n ≤ 105), showing how many numbers are in Arthur's sequence and the lengths of segments respectively.The next line contains n space-separated elements ai (1 ≤ i ≤ n).If ai  =  ?, then the i-th element of Arthur's sequence was replaced by a question mark. Otherwise, ai ( - 109 ≤ ai ≤ 109) is the i-th element of Arthur's sequence.\n\nOutputIf Arthur is wrong at some point and there is no sequence that could fit the given information, print a single string \"Incorrect sequence\" (without the quotes).Otherwise, print n integers — Arthur's favorite sequence. If there are multiple such sequences, print the sequence with the minimum sum |ai|, where |ai| is the absolute value of ai. If there are still several such sequences, you are allowed to print any of them. Print the elements of the sequence without leading zeroes.\n\nInputCopy3 2? 1 2OutputCopy0 1 2 InputCopy5 1-10 -9 ? -7 -6OutputCopy-10 -9 -8 -7 -6 InputCopy5 34 6 7 2 9OutputCopyIncorrect sequence\n\nInputCopy3 2? 1 2\n\nOutputCopy0 1 2\n\nInputCopy5 1-10 -9 ? -7 -6\n\nOutputCopy-10 -9 -8 -7 -6\n\nInputCopy5 34 6 7 2 9\n\nOutputCopyIncorrect sequence",
      "solutions": [
        {
          "title": "Codeforces Round #293 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #293 (Div. 2). It will be held on Tuesday, February 24 at 19:30 MSK and as usual Div. 1 participants are invited to join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my dear friends Pavel Kholkin (HolkinPV), Arthur Svechnikov (ikar) and Vitaliy Kudasov (kuviman) for writing solutions.It will be a little unusual round — you will be given six problems and two and half hours to solve them.UPD Score distribution will be 500-1000-1500-2000-2500-2500. Good luck everyone!UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! urkkvr145 0o00oo0o000oo00o sorry_t0nyukuk NgocHai GintokiSakata",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16592",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 931
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces",
          "content": "517A — Vitaly and StringsTo solve this problem we can, for example, find string next, which lexicographically next to string s and check that string next is lexicographically less than string t. If string next is lexicographically smaller than string t, print string next and finish algorithm. If string next is equal to string t print No such string.To find string next, which lexicographically next to string s, at first we need to find maximal suffix of string s, consisting from letters 'z', change all letters 'z' in this suffix on letters 'a', and then letter before this suffix increase on one. I.e. if before suffix was letter, for example, 'd', we need to change it on letter 'e'.Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.517B — Tanya and PostcardTo solve this problem at first will count array cnt[], where cnt[c] — how many times letter c found in string t. We will count two numbers ans1 and ans2 — how many times Tanya will shouts joyfully YAY! and how many times Tanya will says WHOOPS.Let's iterate on string s and if cnt[s[i]] > 0, then increase ans1 on one and decrease cnt[s[i]] on one.Then let's again iterate on string s. Let c is letter which equal to s[i],but in the opposite case for it. I. e. if s[i] = 'w', then c = 'W'. Now, if cnt[c] > 0, then increase ans2 on one and decrease cnt[с] on one.Now, print two numbers — ans1 and ans2.Asymptotic behavior of this solution — O(|s| + |t|), where |s| — length of string s and |t| — length of string t.517C — Anya and SmartphoneTo solve this problem we will store two arrays — a[] and pos[]. In array a[] will store current order of icons, i. e. in a[i] store number of application, icon which stay on position i. In array pos[] will store on which place in list stays icons, i. e. in pos[i] store in which position of array a[] stay icon of application number i. We will count answer in variable ans. Let's iterate on applications which we need to open. Let current application has number num. Then to ans we need add (pos[num] / k + 1). Now, if icon of application number num doesn't stay on first position in list of applications, we make the following — swap a[pos[num]] and a[pos[num] - 1] and update values in array pos[] for indexes of two icons which numbers a[pos[num]] and a[pos[num] - 1] . Asymptotic behavior of this solution — O(n + m), where n — number of applications, m — number of requests to start applications.517D — Ilya and EscalatorTo solve this problem let's use dynamic programming. We will store two-dimensional array z[][] with type double. In z[i][j] will store the likelihood that after i seconds j people are on escalator.In dynamic will be following transitions. If j = n, i. e. all n people already on escalator then we make transition z[i + 1][j] +  = z[i][j]. Else, or person number j go to escalator in i + 1 second, i. e. z[i + 1][j + 1] +  = z[i][j] * p, or person number j stays on his place, i. e. z[i + 1][j] +  = z[i][j] * (1 – p).Now we need to count answer — it is sum on j from 0 to n inclusive z[t][j] * j.Asymptotic behavior of this solution — O(t * n), where t — on which moment we must count answer, n — how many people stay before escalator in the beginning.517E — Arthur and QuestionsAt first let's take two sums a1 + a2 + ... + ak and a2 + a3 + ... + ak + 1. It is correct that a1 + a2 + ... + ak < a2 + a3 + ... + ak + 1. If move from right to left all elements apart from ak + 1, all of them will reduce and will left only a1 < ak + 1. If write further all sums we will obtain that sequence disintegrate on k disjoint chains: a1 < ak + 1 < a2k + 1 < a3k + 1..., a2 < ak + 2 < a2k + 2 < a3k + 2..., ..., ak < a2k < a3k....We will solve the problem for every chain separately. Let's iterate on first chain and find all pair of indexes i, j (i < j), that a[i] and a[j] are numbers (not questions) in given sequence, and for all k from i + 1 to j - 1 in a[k] stay questions. All this questions we need to change on numbers so does not violate the terms of the increase and minimize sum of absolute values of this numbers.Between indexes i and j stay j - i - 1 questions, we can change them on a[j] - a[i] - 1 numbers. If j - i - 1 > a[j] - a[i] - 1, then we need to print Incorrect sequence and finish algorithm. Else we need to change all this questions to numbers in greedy way. Here we have several cases. Will review one case when a[i] >  = 0 and a[j] >  = 0. Let current chain (3, ?, ?, ?, 9), i = 1, j = 5. We need to change questions on numbers in the following way — (3, 4, 5, 6, 9). In other cases (when a[i] <  = 0, a[j] <  = 0 and when a[i] <  = 0, a[j] >  = 0) we need to use greedy similary to first so does not violate the terms of the increase and minimize sum of absolute values of this numbers.Asymptotic behavior of this solution — O(n), where n — count of elements in given sequence.517F — Pasha and PipeAt first let's count two two-dimensional arrays of prefix sums sumv[][] and sumg[][]. In sumv[i][j] store how many grids are in column j beginning from row 1 to row i. In sumg[i][j] store how many grid are in row i beginning from column 1 to column j.Let's count ans0 — how many pipes without bending we can pave. Count how many vertical pipes — we can pave. Iterate on j from 2 to m — 1 and, if sumg[n][j] — sumg[n][0] = 0 (i. e. in this column zero grids), increase ans0 on one. Similary count number of horizontal pipes.Let's count ans1 — how many pipes with 1 bending we can pave. We need to brute cell, in which will bending. There are four cases. Let's consider first case, others we can count similary. This case — pipe begin in left column, go to current cell in brute and then go to top row. If brute cell in row i and column j then to ans1 we need to add one, if (sumg[i][j] — sumg[i][0]) + (sumv[i][j] — sumv[0][j]) = 0.Let's count ans2 — how many pipes with 2 bendings we can pave. Let's count how many tunes begin from top row and end in top or bottom row and add this number to ans2. Then rotate our matrix three times on 90 degrees and after every rotate add to ans2 count of pipes, which begin from top row and end in top or bottom row. Then we need divide ans2 to 2, because every pipe will count twice.How we can count to current matrix how many pipes begin from top row and end in top or bottom row? Let's count four two-dimension arrays lf[][], rg[][], sumUp[][], sumDown[][]. If i — number of row, j — number of column of current cell, then in position (i, lf[i][j]) in matrix are nearest from left grid for cell (i, j), and in position (i, rg[i][j]) in matrix are nearest from right grid for cell (i, j). sumUp[i][j] — how many columns without grids are in submatrix from (1, 1) to (i, j) of given matrix. sumDown[i][j] — how many columns without grids are in submatrix from (i, 1) to (n, j) of given matrix. Then let's brute cell in which will be the first bending of pipe (pipe goes from top row and in this cell turned to left or to right), check, that in column j above this cell 0 grids, with help of arrays lf and rg find out as far as pipe can go to left or to right and with help of arrays sumUp and sumDown carefully update answer. Now print number ans1 + ans2 + ans3.Asymptotic behavior of this solution — O(n * m * const), where n — hoew many rows in given matrix, m — how many columns in given matrix, const takes different values depending on the implementation, in solution from editorial const = 10.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16598",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 7412
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 1",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 2",
          "code": "printf(\"%p %p\\n\", &s, &t);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 3",
          "code": "M[i][i] = (1-p)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 4",
          "code": "M[i][i-1]=p",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 5",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 6",
          "code": "Matrix M(n+1,n+1), B(n+1,1), Mx, Ex;\n\tM[0][0] = 1.0;\n\tB[0][0] = 1.0;\n\tfor(int i=1;i<n+1; ++i) {\n\t\tM[i][i]   = 1-p;\n\t\tM[i][i-1] =   p;\n\t}\n\tMx  = M.pow(t);\n\tEx  = Mx*B;\n\tfor(int i=1; i<n+1; ++i) {\n\t\tans += Ex[i][0];\n\t}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 7",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 8",
          "code": "if(i==n) dp[i][j]+=dp[i][j-1]+dp[i-1][j-1]*(1-p);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 9",
          "code": "std::cout.precision(8)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 10",
          "code": "std::iostream::operator <<",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 11",
          "code": "for (int i = 0; i < (int)strlen(A); i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #293 (Div.2) Editorial - Codeforces - Code 12",
          "code": "int lenA = strlen(A); for (int i = 0; i < len; i++) {}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16598",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"-?(0|[1-9][0-9]*)|\\\\?\";\n\n    for (int i = 0; i < n; i++) {\n        string s;\n        if (i + 1 < n) {\n            s = inf.readToken(pattern);\n            inf.readSpace();\n        } else {\n            s = inf.readToken(pattern);\n            inf.readEoln();\n        }\n\n        if (s != \"?\") {\n            long long val;\n            try {\n                val = stoll(s);\n            } catch (...) {\n                ensuref(false, \"Invalid integer format: %s\", s.c_str());\n            }\n            ensuref(val >= -1000000000LL && val <= 1000000000LL, \"Integer out of range [-1e9,1e9]: %lld\", val);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"-?(0|[1-9][0-9]*)|\\\\?\";\n\n    for (int i = 0; i < n; i++) {\n        string s;\n        if (i + 1 < n) {\n            s = inf.readToken(pattern);\n            inf.readSpace();\n        } else {\n            s = inf.readToken(pattern);\n            inf.readEoln();\n        }\n\n        if (s != \"?\") {\n            long long val;\n            try {\n                val = stoll(s);\n            } catch (...) {\n                ensuref(false, \"Invalid integer format: %s\", s.c_str());\n            }\n            ensuref(val >= -1000000000LL && val <= 1000000000LL, \"Integer out of range [-1e9,1e9]: %lld\", val);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    string pattern = \"-?(0|[1-9][0-9]*)|\\\\?\";\n\n    for (int i = 0; i < n; i++) {\n        string s;\n        if (i + 1 < n) {\n            s = inf.readToken(pattern);\n            inf.readSpace();\n        } else {\n            s = inf.readToken(pattern);\n            inf.readEoln();\n        }\n\n        if (s != \"?\") {\n            long long val;\n            try {\n                val = stoll(s);\n            } catch (...) {\n                ensuref(false, \"Invalid integer format: %s\", s.c_str());\n            }\n            ensuref(val >= -1000000000LL && val <= 1000000000LL, \"Integer out of range [-1e9,1e9]: %lld\", val);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n    Checker logic:\n\n    1) Read n, k, and the original sequence (which may contain question marks) from the input file.\n    2) Read the jury's answer (\"ans\"):\n       - If the jury's answer is a single token \"Incorrect\" followed by \"sequence\", record that no solution was found by the jury.\n         Otherwise, parse n integers as the claimed solution. Verify:\n           a) The claimed solution matches all fixed (non-'?') positions from the input.\n           b) The k-segment sums are strictly increasing.\n           c) Record the sum of the absolute values of the jury's solution (call that \"jurySum\").\n         If it fails any check, call quitf(_fail, ...), because the jury's solution is invalid.\n    3) Read the participant's answer (\"ouf\"):\n       - If the jury's answer is \"Incorrect sequence\":\n         a) If participant also printed \"Incorrect sequence\", call quitf(_ok, ...).\n         b) If participant tried to provide a sequence, check if that sequence is actually valid.\n            If it is valid, call quitf(_fail, ...)\n            (the jury says no solution is possible, but participant found one).\n            Otherwise, call quitf(_wa, ...).\n       - If the jury's answer is a valid solution with sum = jurySum:\n         a) If participant printed \"Incorrect sequence\", call quitf(_wa, ...).\n         b) Otherwise, parse the participant's n integers. Check:\n            i) Matches all fixed positions from the input.\n            ii) k-segment sums are strictly increasing.\n            iii) Let participant's sum of absolute values be partSum.\n            If (partSum < jurySum) => quitf(_fail, ...),\n               (partSum > jurySum) => quitf(_wa, ...),\n               (partSum == jurySum) => quitf(_ok, ...).\n*/\n\nstatic const string INCORRECT_SEQ = \"Incorrect sequence\";\n\nstruct InputData {\n    int n, k;\n    vector<long long> original; // if original[i] == LLONG_MAX => was a question mark\n};\n\n// Reads the original problem data from inf.\nInputData readProblemData() {\n    InputData ret;\n    ret.n = inf.readInt(1, 100000, \"n\");\n    ret.k = inf.readInt(1, ret.n, \"k\");\n\n    ret.original.resize(ret.n);\n    for (int i = 0; i < ret.n; i++){\n        string token = inf.readToken();\n        if (token == \"?\") {\n            // Mark question marks with sentinel value\n            ret.original[i] = LLONG_MAX;\n        } else {\n            // Should be an integer in [-1e9, 1e9], but we won't re-check that range here\n            // as the statement says it can be from -1e9 to 1e9.\n            long long val = stoll(token);\n            ret.original[i] = val;\n        }\n    }\n    return ret;\n}\n\n// A helper that reads exactly one solution sequence from a given stream, or\n// detects if the solution is \"Incorrect sequence\".\n//\n// If the solution is \"Incorrect sequence\", returns an empty vector.\n// Otherwise, returns the parsed n-element solution.\nvector<long long> readSolutionOrIncorrect(InStream &stream, int n) {\n    // We need to carefully check if the first token is \"Incorrect\".\n    // If it is, we also expect the next token to be \"sequence\".\n    // If that matches, we treat it as \"Incorrect sequence\". Otherwise, we parse n integers.\n    stream.skipBlanks();\n    // Peek next token\n    if (!stream.seekEof()) {\n        // We can attempt to peek a token by using readToken() with restore.\n        // But testlib doesn't provide a direct \"peek\" method. We'll do a small trick:\n        // readToken, if it is \"Incorrect\", then attempt to read the next token \"sequence\".\n        // If successful, we treat as \"Incorrect sequence\" and restore nothing else to parse.\n        // If not, we must interpret we need to parse n longs from the first token onward.\n\n        // We can do a guarded approach: read the first token, if it is \"Incorrect\", read the second token,\n        // if it is \"sequence\", we are done. Otherwise, we interpret them as numbers.\n        // But the participant might actually print \"Incorrect seq???\" - that's invalid but let's handle it gracefully.\n\n        stream.skipBlanks();\n        string first = stream.readToken();\n\n        if (first == \"Incorrect\") {\n            // Then must read next token\n            stream.skipBlanks();\n            string second = stream.readToken();\n            if (second == \"sequence\") {\n                // Then we accept that it's \"Incorrect sequence\" with exact matching\n                // We also check that there's no extra tokens\n                stream.skipBlanks();\n                if (!stream.eof()) {\n                    // If there's something after \"Incorrect sequence\" => invalid format\n                    // but let's treat that as a wrong answer\n                    // The statement says to print a single string \"Incorrect sequence\".\n                    // We'll just consider it a format error => _wa or fail if from the jury.\n                    stream.quitf(_wa, \"Extra tokens after 'Incorrect sequence'\");\n                }\n                // Return empty vector to signify \"Incorrect sequence\".\n                return {};\n            } else {\n                // \"Incorrect\" was read, but next token isn't \"sequence\".\n                // Then presumably these are integers to parse. We'll unify them in a single vector hold.\n                // We'll start from \"Incorrect\" as the first integer => but that doesn't parse as an integer.\n                // This will fail or produce a wrong answer verdict since that doesn't parse as a valid integer.\n\n                // The simplest approach is to fail/wrong answer here.\n                stream.quitf(_wa,\n                             \"Expected \\\"Incorrect sequence\\\" or a valid solution, but got token \\\"%s\\\" after \\\"Incorrect\\\"\",\n                             second.c_str());\n            }\n        } else {\n            // The first token is not \"Incorrect\", so let's parse it as an integer\n            // Then parse the remaining n-1 integers\n            // We'll keep \"first\" as a valid integer and continue\n            long long val;\n            try {\n                val = stoll(first);\n            } catch (...) {\n                stream.quitf(_wa, \"Could not parse the token \\\"%s\\\" as an integer\", first.c_str());\n            }\n            vector<long long> solution(n);\n            solution[0] = val;\n            for (int i = 1; i < n; i++) {\n                solution[i] = stream.readLong(-10000000000LL, 10000000000LL, // somewhat big range\n                                              format(\"solution[%d]\", i+1).c_str());\n            }\n            // After reading n integers, we should have no extra tokens except optional whitespace\n            stream.skipBlanks();\n            if (!stream.eof()) {\n                // if there's more content, that's suspicious\n                stream.quitf(_wa, \"Extra tokens after reading the supposed solution of length %d\", n);\n            }\n            return solution;\n        }\n    } else {\n        // There's no token at all => incomplete\n        stream.quitf(_wa, \"No output given\");\n    }\n    // Should not reach here logically, but just in case\n    return {};\n}\n\n// Check if a solution is valid under the rules:\n// 1) Must match fixed positions from inputData (those not '?' in the original).\n// 2) The sums of each consecutive k segment is strictly increasing.\n// Returns the sum of absolute values if valid; otherwise calls stream.quitf().\nlong long checkSolution(\n    InStream &stream,\n    const InputData &inputData,\n    const vector<long long> &candidate,\n    const string &label // used for error messages\n) {\n    if ((int)candidate.size() != inputData.n) {\n        stream.quitf(_wa, \"%s solution length mismatch, expected %d, got %d\",\n                     label.c_str(), inputData.n, (int)candidate.size());\n    }\n\n    // 1) Must match fixed positions\n    for (int i = 0; i < inputData.n; i++) {\n        if (inputData.original[i] != LLONG_MAX) {\n            // check if candidate differs\n            if (candidate[i] != inputData.original[i]) {\n                stream.quitf(_wa,\n                    \"%s solution does not match the given fixed value at position %d. \"\n                    \"Expected %lld, found %lld\",\n                    label.c_str(), i+1, inputData.original[i], candidate[i]);\n            }\n        }\n    }\n\n    // 2) consecutive k-segment sums strictly increasing\n    // We'll compute partial sums for convenience\n    // sum[i] = candidate[0] + candidate[1] + ... + candidate[i-1], prefix sum of length i\n    vector<long long> prefix(inputData.n+1, 0LL);\n    for (int i = 0; i < inputData.n; i++){\n        prefix[i+1] = prefix[i] + candidate[i];\n    }\n\n    // The sequence of sums for segments of length k is:\n    // p[i] = prefix[i+k] - prefix[i], for i = 0 to n-k\n    // Then p[0] < p[1] < ... < p[n-k].\n    for (int i = 0; i + inputData.k <= inputData.n - 1; i++) {\n        long long curr = prefix[i + inputData.k] - prefix[i];\n        long long nxt = prefix[i + 1 + inputData.k] - prefix[i + 1];\n        if (!(curr < nxt)) {\n            stream.quitf(_wa,\n                \"%s solution fails strict increase for segment sums at position %d: %lld >= %lld\",\n                label.c_str(), i+1, curr, nxt);\n        }\n    }\n\n    // Also check the last transition: from i = n-k to i = n-k => Actually we do that in the loop:\n    // The loop goes up to i + inputData.k <= inputData.n-1 only if i <= n - k - 1\n    // Actually we want i < (n - k), since p[i], p[i+1] up to i+1 < n-k+1 => i+1 <= n-k\n    // We'll correct the loop condition:\n    // the sequence p has length n-k+1, indices 0..(n-k).\n    // consecutive p[i] < p[i+1] for i in [0..(n-k)-1].\n    // So the largest i is n-k. i+1 <= n-k => i <= n-k-1.\n    // We'll use i < (n-k) for the loop condition. That means i+1 <= n-k => i+1 + k <= n\n    // so the partial sums we read are prefix[i + k], prefix[i + 1 + k].\n    // Implementation detail: we do i < n-k for the loop condition.\n\n    // Actually let's do it carefully:\n    // for i in [0..(n-k)], p[i] = prefix[i+k] - prefix[i]\n    // we want p[i] < p[i+1], i in [0..(n-k)-1]\n    // => i in [0..(n-k-1)]\n    // so let's do that:\n    for (int i = 0; i < inputData.n - inputData.k; i++){\n        long long curr = prefix[i + inputData.k] - prefix[i];\n        long long nxt  = prefix[i + 1 + inputData.k] - prefix[i + 1];\n        if (curr >= nxt) {\n            stream.quitf(_wa,\n                \"%s solution fails strict increase for segment sums at index %d (1-based %d): %lld >= %lld\",\n                label.c_str(), i, i+1, curr, nxt);\n        }\n    }\n\n    // If we reached here, it's valid. Return sum of absolute values:\n    long long sumAbs = 0;\n    for (auto &x : candidate) {\n        // risk of overflow if x = -1e9 => abs is 1e9, sums up to 1e5 * 1e9 = 1e14, which fits within 64-bit\n        sumAbs += llabs(x);\n    }\n    return sumAbs;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1) read problem data from inf\n    InputData inputData = readProblemData();\n\n    // 2) read the jury's answer\n    vector<long long> jurySolution = readSolutionOrIncorrect(ans, inputData.n);\n    bool juryIncorrect = jurySolution.empty(); // means \"Incorrect sequence\"\n    long long jurySum = 0; // if there's a solution, we'll store the sum of abs here\n\n    if (juryIncorrect) {\n        // Jury claims no solution is possible. That's okay, but let's ensure no contradictions.\n        // Participant must also print \"Incorrect sequence\" to be correct.\n        // We don't check anything else about the input data, because the jury says no solution is possible.\n    } else {\n        // Check if jury's solution is valid\n        jurySum = checkSolution(ans, inputData, jurySolution, \"jury's\");\n    }\n\n    // 3) read the participant's answer\n    vector<long long> partSolution = readSolutionOrIncorrect(ouf, inputData.n);\n    bool partIncorrect = partSolution.empty();\n    long long partSum = 0; // sum of absolute values for participant\n\n    if (juryIncorrect) {\n        // Jury says \"Incorrect sequence\"\n        if (partIncorrect) {\n            // participant also says no solution\n            quitf(_ok, \"Both jury and participant claim no solution\");\n        } else {\n            // participant claims a solution => either it's valid => jury is wrong => _fail\n            // or it's invalid => participant is wrong => _wa\n            // let's check validity:\n            // if it's valid => _fail\n            // if not => _wa\n            // We'll re-check with a small helper. If not valid, the function will quitf(_wa).\n            // But we want to unify: if we call checkSolution and it fails, it calls ouf.quitf(_wa).\n            // If it passes, we do _fail.\n            long long s = checkSolution(ouf, inputData, partSolution, \"participant's\");\n            // If we are here => participant's solution is valid => conflict with the jury\n            quitf(_fail, \"Jury says no solution, but participant found a valid one (sumAbs=%lld)\", s);\n        }\n    } else {\n        // Jury provided a valid solution with sum = jurySum\n        if (partIncorrect) {\n            // participant says \"Incorrect sequence\" => mismatch\n            quitf(_wa, \"Jury found a valid solution, participant says no solution\");\n        } else {\n            // participant gave a solution => check validity\n            partSum = checkSolution(ouf, inputData, partSolution, \"participant's\");\n            // compare sums\n            if (partSum < jurySum) {\n                // participant has found an even smaller sum => means the jury's solution wasn't minimal\n                quitf(_fail, \"Participant's solution has smaller sum of abs values (%lld) than jury's (%lld)\",\n                               partSum, jurySum);\n            } else if (partSum > jurySum) {\n                quitf(_wa, \"Participant's sum of abs values (%lld) is greater than jury's minimal sum (%lld)\",\n                             partSum, jurySum);\n            } else {\n                // partSum == jurySum => OK\n                quitf(_ok, \"Participant's solution is valid with the same sum of abs values = %lld\", partSum);\n            }\n        }\n    }\n\n    // In theory we should never get here\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"all_known_valid\");\n\n    vector<string> a(n);\n\n    if (type == \"all_known_valid\") {\n        // Generate a valid sequence with all ai known\n        // Initialize a_i = 0 for i = 0..k-1\n        vector<int> ai(n, 0);\n        vector<int> d;\n        for (int i = 0; i < n - k; ++i) {\n            int delta = rnd.next(1, 10); // Random delta >=1 to ensure sums increase\n            d.push_back(delta);\n            ai[i + k] = ai[i] + delta;\n        }\n        // Now ai contains the sequence\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n    } else if (type == \"all_known_invalid\") {\n        // Generate an invalid sequence with all ai known\n        // Let's make sums of k consecutive elements equal somewhere\n        vector<int> ai(n, 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-10, 10);\n        }\n        // Adjust ai to make sums not strictly increasing\n        if (n >= k * 2) {\n            int idx = rnd.next(0, n - k * 2);\n            int sum1 = 0, sum2 = 0;\n            for (int i = idx; i < idx + k; ++i)\n                sum1 += ai[i];\n            for (int i = idx + k; i < idx + 2 * k; ++i)\n                sum2 += ai[i];\n            int diff = sum1 - sum2;\n            // Adjust ai to make sums equal\n            ai[idx + k] += diff;\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n    } else if (type == \"all_unknown\") {\n        // All ai are '?'\n        for (int i = 0; i < n; ++i) {\n            a[i] = \"?\";\n        }\n    } else if (type == \"some_unknown_valid\") {\n        // Generate a valid sequence and replace some ai with '?'\n        vector<int> ai(n, 0);\n        vector<int> d;\n        for (int i = 0; i < n - k; ++i) {\n            int delta = rnd.next(1, 10); // Random delta >=1 to ensure sums increase\n            d.push_back(delta);\n            ai[i + k] = ai[i] + delta;\n        }\n        // Now ai contains the sequence\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n        // Replace random positions with '?'\n        int num_unknown = rnd.next(1, n / 2); // up to half unknown\n        set<int> unknown_indices;\n        while ((int)unknown_indices.size() < num_unknown) {\n            int idx = rnd.next(0, n - 1);\n            unknown_indices.insert(idx);\n        }\n        for (int idx : unknown_indices) {\n            a[idx] = \"?\";\n        }\n    } else if (type == \"some_unknown_invalid\") {\n        // Generate an invalid sequence with some unknowns\n        vector<int> ai(n, 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-1000, 1000);\n        }\n        // Make sums not strictly increasing\n        if (n >= k * 2) {\n            int idx = rnd.next(0, n - k * 2);\n            int sum1 = 0, sum2 = 0;\n            for (int i = idx; i < idx + k; ++i)\n                sum1 += ai[i];\n            for (int i = idx + k; i < idx + 2 * k; ++i)\n                sum2 += ai[i];\n            int diff = sum1 - sum2;\n            // Adjust ai to make sums equal\n            ai[idx + k] += diff;\n        }\n        // Now introduce unknowns\n        int num_unknown = rnd.next(1, n / 2); // up to half unknown\n        set<int> unknown_indices;\n        while ((int)unknown_indices.size() < num_unknown) {\n            int idx = rnd.next(0, n - 1);\n            unknown_indices.insert(idx);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (unknown_indices.count(i)) {\n                a[i] = \"?\";\n            } else {\n                a[i] = to_string(ai[i]);\n            }\n        }\n    } else if (type == \"edge_case\") {\n        // Generate edge case sequences\n\n        // For example, n = 1e5, k = 1\n\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? \"?\" : to_string(rnd.next(-1e9, 1e9));\n        }\n    } else {\n        // Default: all_known_valid\n        // Same as \"all_known_valid\" case\n        vector<int> ai(n, 0);\n        vector<int> d;\n        for (int i = 0; i < n - k; ++i) {\n            int delta = rnd.next(1, 10);\n            d.push_back(delta);\n            ai[i + k] = ai[i] + delta;\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%s\", a[i].c_str());\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char * argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"all_known_valid\");\n\n    vector<string> a(n);\n\n    if (type == \"all_known_valid\") {\n        // Generate a valid sequence with all ai known\n        // Initialize a_i = 0 for i = 0..k-1\n        vector<int> ai(n, 0);\n        vector<int> d;\n        for (int i = 0; i < n - k; ++i) {\n            int delta = rnd.next(1, 10); // Random delta >=1 to ensure sums increase\n            d.push_back(delta);\n            ai[i + k] = ai[i] + delta;\n        }\n        // Now ai contains the sequence\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n    } else if (type == \"all_known_invalid\") {\n        // Generate an invalid sequence with all ai known\n        // Let's make sums of k consecutive elements equal somewhere\n        vector<int> ai(n, 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-10, 10);\n        }\n        // Adjust ai to make sums not strictly increasing\n        if (n >= k * 2) {\n            int idx = rnd.next(0, n - k * 2);\n            int sum1 = 0, sum2 = 0;\n            for (int i = idx; i < idx + k; ++i)\n                sum1 += ai[i];\n            for (int i = idx + k; i < idx + 2 * k; ++i)\n                sum2 += ai[i];\n            int diff = sum1 - sum2;\n            // Adjust ai to make sums equal\n            ai[idx + k] += diff;\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n    } else if (type == \"all_unknown\") {\n        // All ai are '?'\n        for (int i = 0; i < n; ++i) {\n            a[i] = \"?\";\n        }\n    } else if (type == \"some_unknown_valid\") {\n        // Generate a valid sequence and replace some ai with '?'\n        vector<int> ai(n, 0);\n        vector<int> d;\n        for (int i = 0; i < n - k; ++i) {\n            int delta = rnd.next(1, 10); // Random delta >=1 to ensure sums increase\n            d.push_back(delta);\n            ai[i + k] = ai[i] + delta;\n        }\n        // Now ai contains the sequence\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n        // Replace random positions with '?'\n        int num_unknown = rnd.next(1, n / 2); // up to half unknown\n        set<int> unknown_indices;\n        while ((int)unknown_indices.size() < num_unknown) {\n            int idx = rnd.next(0, n - 1);\n            unknown_indices.insert(idx);\n        }\n        for (int idx : unknown_indices) {\n            a[idx] = \"?\";\n        }\n    } else if (type == \"some_unknown_invalid\") {\n        // Generate an invalid sequence with some unknowns\n        vector<int> ai(n, 0);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(-1000, 1000);\n        }\n        // Make sums not strictly increasing\n        if (n >= k * 2) {\n            int idx = rnd.next(0, n - k * 2);\n            int sum1 = 0, sum2 = 0;\n            for (int i = idx; i < idx + k; ++i)\n                sum1 += ai[i];\n            for (int i = idx + k; i < idx + 2 * k; ++i)\n                sum2 += ai[i];\n            int diff = sum1 - sum2;\n            // Adjust ai to make sums equal\n            ai[idx + k] += diff;\n        }\n        // Now introduce unknowns\n        int num_unknown = rnd.next(1, n / 2); // up to half unknown\n        set<int> unknown_indices;\n        while ((int)unknown_indices.size() < num_unknown) {\n            int idx = rnd.next(0, n - 1);\n            unknown_indices.insert(idx);\n        }\n        for (int i = 0; i < n; ++i) {\n            if (unknown_indices.count(i)) {\n                a[i] = \"?\";\n            } else {\n                a[i] = to_string(ai[i]);\n            }\n        }\n    } else if (type == \"edge_case\") {\n        // Generate edge case sequences\n\n        // For example, n = 1e5, k = 1\n\n        for (int i = 0; i < n; ++i) {\n            a[i] = (i % 2 == 0) ? \"?\" : to_string(rnd.next(-1e9, 1e9));\n        }\n    } else {\n        // Default: all_known_valid\n        // Same as \"all_known_valid\" case\n        vector<int> ai(n, 0);\n        vector<int> d;\n        for (int i = 0; i < n - k; ++i) {\n            int delta = rnd.next(1, 10);\n            d.push_back(delta);\n            ai[i + k] = ai[i] + delta;\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = to_string(ai[i]);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the sequence\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%s\", a[i].c_str());\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -k 3 -type all_known_valid\n./gen -n 5 -k 3 -type all_known_invalid\n./gen -n 5 -k 3 -type all_unknown\n./gen -n 5 -k 3 -type some_unknown_valid\n./gen -n 5 -k 3 -type some_unknown_invalid\n./gen -n 1 -k 1 -type edge_case\n\n./gen -n 100 -k 10 -type all_known_valid\n./gen -n 100 -k 10 -type all_known_invalid\n./gen -n 100 -k 10 -type all_unknown\n./gen -n 100 -k 10 -type some_unknown_valid\n./gen -n 100 -k 10 -type some_unknown_invalid\n\n./gen -n 1000 -k 100 -type all_known_valid\n./gen -n 1000 -k 100 -type all_known_invalid\n./gen -n 1000 -k 100 -type all_unknown\n./gen -n 1000 -k 500 -type some_unknown_valid\n./gen -n 1000 -k 500 -type some_unknown_invalid\n\n./gen -n 10000 -k 1 -type all_known_valid\n./gen -n 10000 -k 1 -type all_known_invalid\n./gen -n 10000 -k 1 -type all_unknown\n./gen -n 10000 -k 9999 -type some_unknown_valid\n./gen -n 10000 -k 9999 -type some_unknown_invalid\n\n./gen -n 100000 -k 50000 -type all_known_valid\n./gen -n 100000 -k 50000 -type all_known_invalid\n./gen -n 100000 -k 50000 -type all_unknown\n./gen -n 100000 -k 1 -type some_unknown_valid\n./gen -n 100000 -k 1 -type some_unknown_invalid\n./gen -n 100000 -k 100000 -type edge_case\n\n./gen -n 1 -k 1 -type all_known_valid\n./gen -n 1 -k 1 -type all_unknown\n./gen -n 1 -k 1 -type edge_case\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:38.263124",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "518/F",
      "title": "Problem 518/F",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have exactly %d characters, but has %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '#', \"Invalid character '%c' at line %d column %d\", s[j], i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have exactly %d characters, but has %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '#', \"Invalid character '%c' at line %d column %d\", s[j], i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(2, 2000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have exactly %d characters, but has %d\", i+1, m, (int)s.length());\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '#', \"Invalid character '%c' at line %d column %d\", s[j], i+1, j+1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"empty\");\n\n    cout << n << ' ' << m << '\\n';\n\n    if (type == \"empty\") {\n        // All squares are '.'\n        for (int i = 0; i < n; ++i) {\n            cout << string(m, '.') << '\\n';\n        }\n    }\n    else if (type == \"full\") {\n        // All squares are '#'\n        for (int i = 0; i < n; ++i) {\n            cout << string(m, '#') << '\\n';\n        }\n    }\n    else if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // Probability of being empty '.'\n        for (int i = 0; i < n; ++i) {\n            string row;\n            for (int j = 0; j < m; ++j) {\n                double r = rnd.next(0.0, 1.0);\n                if (r < density) {\n                    row += '.';\n                } else {\n                    row += '#';\n                }\n            }\n            cout << row << '\\n';\n        }\n    }\n    else if (type == \"blocked_edges\") {\n        for (int i = 0; i < n; ++i) {\n            string row;\n            for (int j = 0; j < m; ++j) {\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                    row += '#';\n                } else {\n                    row += '.';\n                }\n            }\n            cout << row << '\\n';\n        }\n    }\n    else if (type == \"single_path\") {\n        vector<string> grid(n, string(m, '#'));\n        int i = n / 2;\n        for (int j = 1; j < m - 1; ++j) {\n            grid[i][j] = '.';\n        }\n        grid[i][0] = '.';\n        grid[i][m - 1] = '.';\n        for (int x = 0; x < n; ++x) {\n            cout << grid[x] << '\\n';\n        }\n    }\n    else if (type == \"maximal_pipes\") {\n        for (int i = 0; i < n; ++i) {\n            cout << string(m, '.') << '\\n';\n        }\n    }\n    else if (type == \"only_corners_empty\") {\n        vector<string> grid(n, string(m, '#'));\n        grid[0][0] = '.';\n        grid[0][m - 1] = '.';\n        grid[n - 1][0] = '.';\n        grid[n - 1][m - 1] = '.';\n        for (int x = 0; x < n; ++x) {\n            cout << grid[x] << '\\n';\n        }\n    }\n    else {\n        cerr << \"Unknown type: \" << type << '\\n';\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"empty\");\n\n    cout << n << ' ' << m << '\\n';\n\n    if (type == \"empty\") {\n        // All squares are '.'\n        for (int i = 0; i < n; ++i) {\n            cout << string(m, '.') << '\\n';\n        }\n    }\n    else if (type == \"full\") {\n        // All squares are '#'\n        for (int i = 0; i < n; ++i) {\n            cout << string(m, '#') << '\\n';\n        }\n    }\n    else if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // Probability of being empty '.'\n        for (int i = 0; i < n; ++i) {\n            string row;\n            for (int j = 0; j < m; ++j) {\n                double r = rnd.next(0.0, 1.0);\n                if (r < density) {\n                    row += '.';\n                } else {\n                    row += '#';\n                }\n            }\n            cout << row << '\\n';\n        }\n    }\n    else if (type == \"blocked_edges\") {\n        for (int i = 0; i < n; ++i) {\n            string row;\n            for (int j = 0; j < m; ++j) {\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\n                    row += '#';\n                } else {\n                    row += '.';\n                }\n            }\n            cout << row << '\\n';\n        }\n    }\n    else if (type == \"single_path\") {\n        vector<string> grid(n, string(m, '#'));\n        int i = n / 2;\n        for (int j = 1; j < m - 1; ++j) {\n            grid[i][j] = '.';\n        }\n        grid[i][0] = '.';\n        grid[i][m - 1] = '.';\n        for (int x = 0; x < n; ++x) {\n            cout << grid[x] << '\\n';\n        }\n    }\n    else if (type == \"maximal_pipes\") {\n        for (int i = 0; i < n; ++i) {\n            cout << string(m, '.') << '\\n';\n        }\n    }\n    else if (type == \"only_corners_empty\") {\n        vector<string> grid(n, string(m, '#'));\n        grid[0][0] = '.';\n        grid[0][m - 1] = '.';\n        grid[n - 1][0] = '.';\n        grid[n - 1][m - 1] = '.';\n        for (int x = 0; x < n; ++x) {\n            cout << grid[x] << '\\n';\n        }\n    }\n    else {\n        cerr << \"Unknown type: \" << type << '\\n';\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type full\n\n./gen -n 4 -m 4 -type random -density 0.5\n./gen -n 4 -m 4 -type random -density 0.3\n./gen -n 4 -m 4 -type random -density 0.9\n\n./gen -n 5 -m 5 -type blocked_edges\n./gen -n 10 -m 10 -type blocked_edges\n\n./gen -n 10 -m 10 -type empty\n./gen -n 100 -m 100 -type empty\n\n./gen -n 10 -m 10 -type full\n./gen -n 100 -m 100 -type full\n\n./gen -n 2000 -m 2000 -type random -density 0.5\n./gen -n 2000 -m 2000 -type random -density 0.2\n./gen -n 2000 -m 2000 -type random -density 0.8\n\n./gen -n 2000 -m 2000 -type empty\n./gen -n 2000 -m 2000 -type full\n\n./gen -n 2 -m 2000 -type empty\n./gen -n 2000 -m 2 -type empty\n./gen -n 2 -m 2000 -type random -density 0.5\n./gen -n 2000 -m 2 -type random -density 0.5\n\n./gen -n 10 -m 10 -type only_corners_empty\n./gen -n 2000 -m 2000 -type only_corners_empty\n\n./gen -n 5 -m 100 -type single_path\n./gen -n 100 -m 5 -type single_path\n\n./gen -n 5 -m 5 -type maximal_pipes\n./gen -n 100 -m 100 -type maximal_pipes\n./gen -n 2000 -m 2000 -type maximal_pipes\n\n./gen -n 50 -m 50 -type random -density 0.1\n./gen -n 2000 -m 2000 -type random -density 0.05\n\n./gen -n 50 -m 50 -type random -density 0.9\n./gen -n 2000 -m 2000 -type random -density 0.95\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:40.497842",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "519/A",
      "title": "A. A and B and Chess",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe input contains eight lines, eight characters each — the board's description.The white pieces on the board are marked with uppercase letters, the black pieces are marked with lowercase letters.The white pieces are denoted as follows: the queen is represented is 'Q', the rook — as 'R', the bishop — as'B', the knight — as 'N', the pawn — as 'P', the king — as 'K'.The black pieces are denoted as 'q', 'r', 'b', 'n', 'p', 'k', respectively.An empty square of the board is marked as '.' (a dot). It is not guaranteed that the given chess position can be achieved in a real game. Specifically, there can be an arbitrary (possibly zero) number pieces of each type, the king may be under attack and so on.",
      "output_spec": "OutputPrint \"White\" (without quotes) if the weight of the position of the white pieces is more than the weight of the position of the black pieces, print \"Black\" if the weight of the black pieces is more than the weight of the white pieces and print \"Draw\" if the weights of the white and black pieces are equal.",
      "sample_tests": "ExamplesInputCopy...QK......................................................rk...OutputCopyWhiteInputCopyrnbqkbnrpppppppp................................PPPPPPPPRNBQKBNROutputCopyDrawInputCopyrppppppr...k....................................K...Q...........OutputCopyBlack",
      "description": "A. A and B and Chess\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe input contains eight lines, eight characters each — the board's description.The white pieces on the board are marked with uppercase letters, the black pieces are marked with lowercase letters.The white pieces are denoted as follows: the queen is represented is 'Q', the rook — as 'R', the bishop — as'B', the knight — as 'N', the pawn — as 'P', the king — as 'K'.The black pieces are denoted as 'q', 'r', 'b', 'n', 'p', 'k', respectively.An empty square of the board is marked as '.' (a dot). It is not guaranteed that the given chess position can be achieved in a real game. Specifically, there can be an arbitrary (possibly zero) number pieces of each type, the king may be under attack and so on.\n\nOutputPrint \"White\" (without quotes) if the weight of the position of the white pieces is more than the weight of the position of the black pieces, print \"Black\" if the weight of the black pieces is more than the weight of the white pieces and print \"Draw\" if the weights of the white and black pieces are equal.\n\nInputCopy...QK......................................................rk...OutputCopyWhiteInputCopyrnbqkbnrpppppppp................................PPPPPPPPRNBQKBNROutputCopyDrawInputCopyrppppppr...k....................................K...Q...........OutputCopyBlack\n\nInputCopy...QK......................................................rk...\n\nOutputCopyWhite\n\nInputCopyrnbqkbnrpppppppp................................PPPPPPPPRNBQKBNR\n\nOutputCopyDraw\n\nInputCopyrppppppr...k....................................K...Q...........\n\nOutputCopyBlack\n\nNoteIn the first test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals 5.In the second test sample the weights of the positions of the black and the white pieces are equal to 39.In the third test sample the weight of the position of the white pieces equals to 9, the weight of the position of the black pieces equals to 16.",
      "solutions": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!My name is Adilet Zhaxybay, and together with Bekzhan Kassenov (BekzhanKassenov) we are authors of Codeforces #294, which will be held on 28th of February at 16:00 MSK. This is our first Codeforces round and we are happy to invite all of you to participate in it. The round will be rated for the second division, however, participants from the first division can, as usually, participate in it unofficially.As far as we know, it is the first Codeforces round, which was completely prepared by the authors from Kazakhstan. We are very honored by this fact and hope that everything will go great. We are encouraging other participants from our country to join us — I am sure, that you can prepare a lot of very nice problems. Preparing Codeforces round is possible ;)We want to thank all the people, who helped us to prepare the contest: Max Akhmedov (Zlobober), who helped us with the problems, Nurlan Kanapin (kt-9) and Mansur Kutybaev (mexmans), who tested the round, and Maria Belova (Delinur), who translated problem statements.Also we want to say great thanks to Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon. We want to congratulate Codeforces with its fifth anniversary. We, authors of the round, were very lucky to start competitive programming at the time, when Codeforces already existed, and it helped us really a lot!We love, when authors of the round write a bit about themselves (we encourage everybody to do so) — this helps to feel that there are real people behind the problems. Thus, we will write a bit about ourselves. We are students from Nazarbayev University (nu.edu.kz). NU is a new university with English as a language of teaching, which is located in the capital of Kazakhstan, Astana. Our university participates in ACM-ICPC only from 2012, but the team from NU already qualified to World Finals twice — in 2014 and 2015. We hope that we will do only better in the future!Good luck to all! UPD Score distribution will be standard (500 — 1000 — 1500 — 2000 — 2500)UPD2 Editorial is available hereCongratulations to winners! AkashiSeijuro fmzbtf937 mxh3777 IGandWFin2019 ruozha2 & i_hate_t0nzuk Round is over, thanks to everybody, who took part in it!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16662",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2217
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces",
          "content": "519A - A and B and ChessAuthor: BekzhanKassenovThis problem asked to determine whose chess position is better.Solution: Iterate over the board and count scores of both player. Then just output the answer.Complexity: O(n2), where n is the length of the side of the board (8 here)Code: 10083191519B - A and B and Compilation ErrorsAuthor: ADJAIn this problem you were given three arrays. Second array is the same as the first array without one element, third array is the same as second array without first element. You were asked to find deleted elements.Solution: I'll describe easiest solution for this problem: Let's denote a as sum of all elements of first array, b as sum of all elements of second array and c as sum of all elements of third array. Then answer is a - b and b - cThere are also some other solutions for this problem which use map, xor, etc.Complexity: O(N)Code: 10083248519C - A and B and Team TrainingAuthor: ADJAIn this problem we should split n experienced participants and m newbies into teams.Solution: Let's denote number teams with 2 experienced partisipants and 1 new participant as type1 and teams with 1 experienced participant and 2 new participants as type2. Let's fix number of teams of type1 and denote it as i. Their amount is not grater than m. Then number of teams of type2 is min(m - 2 * i, n - i). Check all possible i' and update answer.Complexity: O(N)Code: 10083265519D - A and B and Interesting SubstringsAuthor: ADJAIn this problem you were asked to find number of substrings of given string, such that each substring starts and finishes with one and the same letter and sum of weight of letters of that substring without first and last letter is zero.Solution: Let's denote sum[i] as sum of weights of first i letters. Create 26 map < longlong, int > 's, 1 for each letter. Suppose we are on position number i and current character's map is m. Then add m[sum[i - 1]] to the answer and add sum[i] to the m. Complexity: O(NlogN), where N — the length of input string.Code: 10083293519E - A and B and Lecture RoomsAuthor: BekzhanKassenovIn this problem we have to answer to the following queries on tree: for given pairs of vertices your program should output number of eqidistand vertices from them.Let's denote:dist(a, b) as distance between vertices a and b.LCA(a, b) as lowest common ancestor of vertices a and b.depth[a] as distance between root of the tree and vertex a.size[a] as size of subtree of vertex a.On each picture green nodes are equidistant nodes, blue nodes — nodes from query.Preprocessing: Read edges of tree and build data structure for LCA (it is more convenient to use binary raise, becase we will use it further for other purposes). Complexity: O(NlogN)Queries:We have to consider several cases for each query:1) a = b. In that case answer is n.2) dist(a, b) is odd. Then answer is 0.3) dist(a, l) = dist(b, l), where l = LCA(a, b). Find children of l, which are ancestors of a and b (let's denote them as aa and bb). Answer will be n - size[aa] - size[bb].4) All other cases. Assume that depth[a] > depth[b]. Then using binary raise find dist(a, b) / 2-th ancestor of a (let's denote it as p1), dist(a, b) / 2 - 1-th ancestor of vertex a (denote it as p2). Answer will be size[p1] - size[p2].Complexity: O(logN) for each query, O(MlogN) for all queries.Resulting complexity:: O(MlogN + NlogN)Code: 10083310",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16687",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 519\\s*A"
          },
          "content_length": 3374
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "%d%c ... i == n - 1 ? '\\n' : ' '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "A <= 2*B ,  B <= 2*A ,  A <= X , B <= Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const string validChars = \"QRBNPKqrnbpk.\";\n\n    for (int i = 0; i < 8; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() == 8, \"Line %d must be exactly 8 characters long, but it has %d characters\", i + 1, (int)s.length());\n        for (int j = 0; j < 8; ++j) {\n            char c = s[j];\n            ensuref(validChars.find(c) != string::npos, \"Invalid character '%c' at position %d in line %d\", c, j + 1, i + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const string validChars = \"QRBNPKqrnbpk.\";\n\n    for (int i = 0; i < 8; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() == 8, \"Line %d must be exactly 8 characters long, but it has %d characters\", i + 1, (int)s.length());\n        for (int j = 0; j < 8; ++j) {\n            char c = s[j];\n            ensuref(validChars.find(c) != string::npos, \"Invalid character '%c' at position %d in line %d\", c, j + 1, i + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    const string validChars = \"QRBNPKqrnbpk.\";\n\n    for (int i = 0; i < 8; ++i) {\n        string s = inf.readLine();\n        ensuref(s.length() == 8, \"Line %d must be exactly 8 characters long, but it has %d characters\", i + 1, (int)s.length());\n        for (int j = 0; j < 8; ++j) {\n            char c = s[j];\n            ensuref(validChars.find(c) != string::npos, \"Invalid character '%c' at position %d in line %d\", c, j + 1, i + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string testType = opt<string>(\"testType\", \"random_board\");\n\n    vector<string> board(8, string(8, '.'));\n\n    if (testType == \"empty_board\") {\n        // All squares are empty (already initialized with '.')\n    } else if (testType == \"full_board\") {\n        // Fill all squares with pieces, alternate between white and black pieces randomly\n        string pieces = \"QRBNPKqrnbpk\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(12)];\n            }\n        }\n    } else if (testType == \"random_board\") {\n        // Randomly place pieces on the board\n        string pieces = \"QRBNPKqrnbpk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(13)];\n            }\n        }\n    } else if (testType == \"only_white\") {\n        // Fill all squares with white pieces\n        string pieces = \"QRBNPK.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(7)];\n            }\n        }\n    } else if (testType == \"only_black\") {\n        // Fill all squares with black pieces\n        string pieces = \"qrnbpk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(7)];\n            }\n        }\n    } else if (testType == \"only_pawns\") {\n        // Fill the board with pawns (white and black)\n        string pieces = \"Pp.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(3)];\n            }\n        }\n    } else if (testType == \"only_queens\") {\n        // Fill the board with queens (white and black)\n        string pieces = \"Qq.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(3)];\n            }\n        }\n    } else if (testType == \"only_kings\") {\n        // Fill the board with only kings\n        string pieces = \"Kk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(3)];\n            }\n        }\n    } else if (testType == \"white_advantage\") {\n        // Generate a board where white has advantage\n        // Put more white pieces or higher value pieces for white\n        string whitePieces = \"QRBNPK\";\n        string blackPieces = \"qrnbpk\";\n        int whitePiecesCount = rnd.next(20, 32);\n        int blackPiecesCount = rnd.next(0, 20);\n\n        vector<char> pieces;\n\n        for (int i = 0; i < whitePiecesCount; ++i) {\n            pieces.push_back(whitePieces[rnd.next(6)]);\n        }\n        for (int i = 0; i < blackPiecesCount; ++i) {\n            pieces.push_back(blackPieces[rnd.next(6)]);\n        }\n        while (pieces.size() < 64) {\n            pieces.push_back('.');\n        }\n        // Shuffle and assign to board\n        shuffle(pieces.begin(), pieces.end());\n\n        for (int i = 0; i < 64; ++i) {\n            board[i/8][i%8] = pieces[i];\n        }\n    } else if (testType == \"black_advantage\") {\n        // Generate a board where black has advantage\n        string whitePieces = \"QRBNPK\";\n        string blackPieces = \"qrnbpk\";\n        int whitePiecesCount = rnd.next(0, 20);\n        int blackPiecesCount = rnd.next(20, 32);\n\n        vector<char> pieces;\n\n        for (int i = 0; i < whitePiecesCount; ++i) {\n            pieces.push_back(whitePieces[rnd.next(6)]);\n        }\n        for (int i = 0; i < blackPiecesCount; ++i) {\n            pieces.push_back(blackPieces[rnd.next(6)]);\n        }\n        while (pieces.size() < 64) {\n            pieces.push_back('.');\n        }\n        // Shuffle and assign to board\n        shuffle(pieces.begin(), pieces.end());\n\n        for (int i = 0; i < 64; ++i) {\n            board[i/8][i%8] = pieces[i];\n        }\n    } else if (testType == \"draw\") {\n        // Generate a board where both sides have equal weight\n        // For simplicity, place same number of same pieces for both sides\n        string whitePieces = \"QRBNPK\";\n        string blackPieces = \"qrnbpk\";\n        vector<char> pieces;\n\n        int numPieces = rnd.next(0, 16); // number of pieces for each side\n\n        for (int i = 0; i < numPieces; ++i) {\n            char piece = whitePieces[rnd.next(6)];\n            pieces.push_back(piece);\n        }\n        for (int i = 0; i < numPieces; ++i) {\n            char piece = blackPieces[rnd.next(6)];\n            pieces.push_back(piece);\n        }\n\n        while (pieces.size() < 64) {\n            pieces.push_back('.');\n        }\n\n        shuffle(pieces.begin(), pieces.end());\n\n        for (int i = 0; i < 64; ++i) {\n            board[i/8][i%8] = pieces[i];\n        }\n    } else {\n        // Default is random_board\n        string pieces = \"QRBNPKqrnbpk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(13)];\n            }\n        }\n    }\n\n    // Output the board\n    for (int i = 0; i < 8; ++i) {\n        printf(\"%s\\n\", board[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    string testType = opt<string>(\"testType\", \"random_board\");\n\n    vector<string> board(8, string(8, '.'));\n\n    if (testType == \"empty_board\") {\n        // All squares are empty (already initialized with '.')\n    } else if (testType == \"full_board\") {\n        // Fill all squares with pieces, alternate between white and black pieces randomly\n        string pieces = \"QRBNPKqrnbpk\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(12)];\n            }\n        }\n    } else if (testType == \"random_board\") {\n        // Randomly place pieces on the board\n        string pieces = \"QRBNPKqrnbpk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(13)];\n            }\n        }\n    } else if (testType == \"only_white\") {\n        // Fill all squares with white pieces\n        string pieces = \"QRBNPK.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(7)];\n            }\n        }\n    } else if (testType == \"only_black\") {\n        // Fill all squares with black pieces\n        string pieces = \"qrnbpk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(7)];\n            }\n        }\n    } else if (testType == \"only_pawns\") {\n        // Fill the board with pawns (white and black)\n        string pieces = \"Pp.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(3)];\n            }\n        }\n    } else if (testType == \"only_queens\") {\n        // Fill the board with queens (white and black)\n        string pieces = \"Qq.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(3)];\n            }\n        }\n    } else if (testType == \"only_kings\") {\n        // Fill the board with only kings\n        string pieces = \"Kk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(3)];\n            }\n        }\n    } else if (testType == \"white_advantage\") {\n        // Generate a board where white has advantage\n        // Put more white pieces or higher value pieces for white\n        string whitePieces = \"QRBNPK\";\n        string blackPieces = \"qrnbpk\";\n        int whitePiecesCount = rnd.next(20, 32);\n        int blackPiecesCount = rnd.next(0, 20);\n\n        vector<char> pieces;\n\n        for (int i = 0; i < whitePiecesCount; ++i) {\n            pieces.push_back(whitePieces[rnd.next(6)]);\n        }\n        for (int i = 0; i < blackPiecesCount; ++i) {\n            pieces.push_back(blackPieces[rnd.next(6)]);\n        }\n        while (pieces.size() < 64) {\n            pieces.push_back('.');\n        }\n        // Shuffle and assign to board\n        shuffle(pieces.begin(), pieces.end());\n\n        for (int i = 0; i < 64; ++i) {\n            board[i/8][i%8] = pieces[i];\n        }\n    } else if (testType == \"black_advantage\") {\n        // Generate a board where black has advantage\n        string whitePieces = \"QRBNPK\";\n        string blackPieces = \"qrnbpk\";\n        int whitePiecesCount = rnd.next(0, 20);\n        int blackPiecesCount = rnd.next(20, 32);\n\n        vector<char> pieces;\n\n        for (int i = 0; i < whitePiecesCount; ++i) {\n            pieces.push_back(whitePieces[rnd.next(6)]);\n        }\n        for (int i = 0; i < blackPiecesCount; ++i) {\n            pieces.push_back(blackPieces[rnd.next(6)]);\n        }\n        while (pieces.size() < 64) {\n            pieces.push_back('.');\n        }\n        // Shuffle and assign to board\n        shuffle(pieces.begin(), pieces.end());\n\n        for (int i = 0; i < 64; ++i) {\n            board[i/8][i%8] = pieces[i];\n        }\n    } else if (testType == \"draw\") {\n        // Generate a board where both sides have equal weight\n        // For simplicity, place same number of same pieces for both sides\n        string whitePieces = \"QRBNPK\";\n        string blackPieces = \"qrnbpk\";\n        vector<char> pieces;\n\n        int numPieces = rnd.next(0, 16); // number of pieces for each side\n\n        for (int i = 0; i < numPieces; ++i) {\n            char piece = whitePieces[rnd.next(6)];\n            pieces.push_back(piece);\n        }\n        for (int i = 0; i < numPieces; ++i) {\n            char piece = blackPieces[rnd.next(6)];\n            pieces.push_back(piece);\n        }\n\n        while (pieces.size() < 64) {\n            pieces.push_back('.');\n        }\n\n        shuffle(pieces.begin(), pieces.end());\n\n        for (int i = 0; i < 64; ++i) {\n            board[i/8][i%8] = pieces[i];\n        }\n    } else {\n        // Default is random_board\n        string pieces = \"QRBNPKqrnbpk.\";\n        for (int i = 0; i < 8; ++i) {\n            for (int j = 0; j < 8; ++j) {\n                board[i][j] = pieces[rnd.next(13)];\n            }\n        }\n    }\n\n    // Output the board\n    for (int i = 0; i < 8; ++i) {\n        printf(\"%s\\n\", board[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -testType empty_board\n./gen -testType full_board\n\n./gen -testType random_board\n./gen -testType random_board\n./gen -testType random_board\n\n./gen -testType only_white\n./gen -testType only_black\n\n./gen -testType only_pawns\n./gen -testType only_queens\n./gen -testType only_kings\n\n./gen -testType white_advantage\n./gen -testType black_advantage\n./gen -testType draw\n\n./gen -testType white_advantage\n./gen -testType white_advantage\n./gen -testType black_advantage\n./gen -testType black_advantage\n\n./gen -testType draw\n./gen -testType draw\n./gen -testType draw\n\n./gen -testType only_pawns\n./gen -testType only_pawns\n\n./gen -testType only_queens\n./gen -testType only_queens\n\n./gen -testType random_board\n./gen -testType random_board\n./gen -testType random_board\n\n./gen -testType only_kings\n./gen -testType only_kings\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:42.541347",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "519/B",
      "title": "B. A и B и ошибки компиляции",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка входных данных содержит целое число n (3 ≤ n ≤ 105) — изначальное количество ошибок компиляции.Вторая строка содержит n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — номера ошибок, выданных компилятором в первый раз. Третья строка содержит n - 1 целых чисел через пробел b1, b2, ..., bn - 1 — номера ошибок, выданных при второй компиляции. Гарантируется, что последовательность в третьей строке содержит все числа второй строки, за исключением ровно одного. Четвертая строка содержит n - 2 целых чисел через пробел с1, с2, ..., сn - 2 — номера ошибок, выданных при третьей компиляции. Гарантируется, что последовательность в четвертой строке содержит все числа третьей строки, за исключением ровно одного.",
      "output_spec": "Выходные данныеВыведите два числа на отдельной строке: номера ошибок компиляции, исчезнувших после того как B внёс первое и второе исправление соответственно.",
      "sample_tests": "ПримерыВходные данныеСкопировать51 5 8 123 7123 7 5 15 1 7Выходные данныеСкопировать8123Входные данныеСкопировать61 4 3 3 5 73 7 5 4 34 3 7 5Выходные данныеСкопировать13",
      "description": "B. A и B и ошибки компиляции\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка входных данных содержит целое число n (3 ≤ n ≤ 105) — изначальное количество ошибок компиляции.Вторая строка содержит n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — номера ошибок, выданных компилятором в первый раз. Третья строка содержит n - 1 целых чисел через пробел b1, b2, ..., bn - 1 — номера ошибок, выданных при второй компиляции. Гарантируется, что последовательность в третьей строке содержит все числа второй строки, за исключением ровно одного. Четвертая строка содержит n - 2 целых чисел через пробел с1, с2, ..., сn - 2 — номера ошибок, выданных при третьей компиляции. Гарантируется, что последовательность в четвертой строке содержит все числа третьей строки, за исключением ровно одного.\n\nВходные данные\n\nВыходные данныеВыведите два числа на отдельной строке: номера ошибок компиляции, исчезнувших после того как B внёс первое и второе исправление соответственно.\n\nВыходные данные\n\nВходные данныеСкопировать51 5 8 123 7123 7 5 15 1 7Выходные данныеСкопировать8123Входные данныеСкопировать61 4 3 3 5 73 7 5 4 34 3 7 5Выходные данныеСкопировать13\n\nВходные данныеСкопировать51 5 8 123 7123 7 5 15 1 7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать8123\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать61 4 3 3 5 73 7 5 4 34 3 7 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать13\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тестовом примере в первый раз B исправляет ошибку с номером 8, во второй — с номером 123.Во втором тестовом примере в первый раз B исправляет ошибку с номером 1, во второй — с номером 3. Обратите внимание, что если имеются несколько ошибок с одинаковым номером, за один раз B может исправить только одну из них.",
      "solutions": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!Меня зовут Адилет Жаксыбай, и вместе с Бекжаном Касеновым (BekzhanKassenov) мы являемся авторами раунда Codeforces #294, который состоится 28 февраля в 16:00 MSK. Это наш первый раунд Codeforces, и мы рады пригласить всех поучаствовать в нем. Раунд будет рейтинговым для участников второго дивизиона, участники первого дивизиона могут, как обычно, поучаствовать в нем вне конкурса. Насколько мы знаем, это будет первый раунд на Codeforces, полностью подготовленный участниками из Казахстана. Мы очень рады, что нам выпала такая честь, и надеемся, что все пройдет хорошо. Мы призываем всех других участников из нашей страны тоже стать авторами раундов — уверен, вы сможете подготовить множество отличных задач. Сделать раунд Codeforces — реальность ;)Хочется выразить благодарность всем тем, кто помог нам с подготовкой раунда: Максиму Ахмедову (Zlobober), который помог нам с подготовкой задач, Нурлану Канапину (kt-9) и Мансуру Кутыбаеву (mexmans), протестировавшим контест, и Марии Беловой (Delinur), которая перевела условия на английский язык. Отдельное огромное спасибо Михаилу Мирзаянову (MikeMirzayanov) за создание платформ Codeforces и Polygon. Мы бы хотели поздравить Codeforces с недавно прошедшим пятилетием. Нам, авторам раунда, невероятно повезло начать заниматься олимпиадами по программированию, когда сайт Codeforces уже существовал, и он внес невероятный вклад в наше развитие!Нам очень нравится, когда авторы задач пишут в анонсе немного о себе (призываем всех авторов поступать также) — это дает лучше почувствовать, что за задачами стоят реальные люди. Поэтому напишем немного о нас. Мы являемся студентами Назарбаев Университета (nu.edu.kz) — нового университета с английским языком обучения в столице Казахстана, Астане. В ACM-ICPC наш университет участвует лишь с 2012 года, но тем не менее команда с NU уже два раза проходила в финал в 2014 и 2015 году. Мы надеемся и в будущем держать планку спортивного программирования на высоком уровне. Всем удачи! UPD Разбалловка будет стандартной (500 — 1000 — 1500 — 2000 — 2500)UPD2 Разбор можно найти тутПоздравляем победителей: AkashiSeijuro fmzbtf937 mxh3777 IGandWFin2019 ruozha2 & i_hate_t0nzuk Раунд закончен, спасибо всем, кто принял участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16662",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2235
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "519A - A и B и шахматыАвтор: BekzhanKassenovВ этой задаче необходимо было найти чья шахматная позиция сильнее.Решение: Пробегаемся по всей доске, складывая веса фигур игроков, и в конце выводим ответ.Асимптотика: O(n2), где n — длина стороны доски (в этой задаче — 8)Код: 10083191519B - A и B и ошибки компиляцииАвтор: ADJAВ этой задаче вам было дано 3 массива. Второй содержал все элементы первого, за исключением одного, третий массив содержал все элементы второго, за исключением одного. Необходимо было вывести удаленные элементы.Решение: Я опишу простейшее решение этой задачи: Обозначим сумму элементов в первом, втором и третьем массиве как a, b и c соответственно. Ответом будут числа a - b и b - cТакже существуют множество других решений, использующих map, xor и прочее. Асимптотика: O(N)Код: 10083248519C - A и B и командная тренировкаАвтор: ADJAВ этой задаче вам необходимо было поделить n опытных участников и m новичков на команды.Решение: Обозначим команды с 2 опытными участниками и 1 новичком как type1 и команды с 1 опытным участником и 2 новичками как type2. Зафиксируем количество команд type1 как i. Их количество не превышает m. Тогда количество команд type2 равно min(m - 2 * i, n - i). Осталось проверить все возможные варианты i и выбрать оптимальный.Асимптотика: O(N)Код: 10083265.519D - A и B и интересные подстрокиАвтор: ADJAВ этой задаче необходимо было найти количество подстрок данной строки таких, что каждая подстрока начинается и заканчивается на одну и ту же букву и сумма весов букв в этой подстроке (кроме начала и конца) равно нулю.Решение: Обозначим sum[i] как сумму весов первых i букв. Создадим 26 map < longlong, int > -ов, 1 на каждую букву. Пусть в данный момент мы находимся на позиции i и map текущего символа m. Тогда необходимо добавить к ответу m[sum[i — 1]], и sum[i] в m. Асимптотика: O(Nlog(N)), где N — длина исходной строки.Код: 10083293.519E - A и B и аудиторииАвтор: BekzhanKassenovВ задаче необходимо было отвечать на следующие запросы на дереве: для заданных пар вершин найти количество вершин, равноудаленных от них.Принятые обозначения:dist(a, b) — расстояние между вершинами a и b.LCA(a, b) — наименьший общий предок вершин a и b.depth[a] — расстояние от корня дерева до вершины a.size[a] — размер поддерева, корнем которой является вершина a.На каждой картинке вершины, покрашенные в зеленый цвет — вершины из ответа, вершины, покрашенные в синий цвет — вершины из запросов.Препроцессинг: Для начала необходимо считать ребра дерева и построить по ним структуру данных для нахождения LCA (удобнее всего использовать двоичный подъем, так как в будущем он понадобится для других целей). Асимптотика: O(NlogN)Ответы на запросы:Для каждого запроса необходимо рассмотреть несколько случаев:1) a = b. В этом случае ответ равен n.2) dist(a, b) нечетно. Тогда ответом будет 0.3) dist(a, l) = dist(b, l), где l = LCA(a, b). Двоичным подъемом найдем сыновей вершины l, которые являются предками вершин a и b (обозначим их как aa и bb соответственно). Ответом будет n - size[aa] - size[bb].4) Все остальные случаи. Предположим, что depth[a] > depth[b]. Тогда найдем с помощью двоичного подъема dist(a, b) / 2-ого предка вершины a (обозначим его как p1), dist(a, b) / 2 - 1-ого предка вершины a (обозначим его как p2). Ответом будет size[p1] - size[p2].Асимптотика: O(logN) на запрос, O(MlogN) на все запросы.Итоговая асимптотика: O(MlogN + NlogN)Код: 10083310.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16687",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 519\\s*B"
          },
          "content_length": 3410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "%d%c ... i == n - 1 ? '\\n' : ' '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "A <= 2*B ,  B <= 2*A ,  A <= X , B <= Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 6",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 7",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid check_counts(unordered_map<int, int> &count_prev, unordered_map<int, int> &count_next, const char *message) {\n    int missing_count = 0;\n    for (auto &p : count_prev) {\n        int key = p.first;\n        int cp = p.second;\n        int cn = count_next[key];\n        if (cp > cn) {\n            int diff = cp - cn;\n            if (diff == 1) {\n                missing_count++;\n            } else {\n                ensuref(false, \"%s: Count difference for element %d is %d, expected at most 1\", message, key, diff);\n            }\n        } else if (cp == cn) {\n            continue;\n        } else {\n            ensuref(false, \"%s: Count for element %d increased from previous to next\", message, key);\n        }\n    }\n    for (auto &p : count_next) {\n        int key = p.first;\n        if (count_prev.find(key) == count_prev.end()) {\n            ensuref(false, \"%s: Element %d appears in next but not in previous\", message, key);\n        }\n    }\n    ensuref(missing_count == 1, \"%s: Number of missing elements is %d, expected 1\", message, missing_count);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n - 1, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n - 2, 1, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    unordered_map<int, int> count_a, count_b, count_c;\n    for (int x : a) count_a[x]++;\n    for (int x : b) count_b[x]++;\n    for (int x : c) count_c[x]++;\n\n    check_counts(count_a, count_b, \"After first compilation\");\n    check_counts(count_b, count_c, \"After second compilation\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid check_counts(unordered_map<int, int> &count_prev, unordered_map<int, int> &count_next, const char *message) {\n    int missing_count = 0;\n    for (auto &p : count_prev) {\n        int key = p.first;\n        int cp = p.second;\n        int cn = count_next[key];\n        if (cp > cn) {\n            int diff = cp - cn;\n            if (diff == 1) {\n                missing_count++;\n            } else {\n                ensuref(false, \"%s: Count difference for element %d is %d, expected at most 1\", message, key, diff);\n            }\n        } else if (cp == cn) {\n            continue;\n        } else {\n            ensuref(false, \"%s: Count for element %d increased from previous to next\", message, key);\n        }\n    }\n    for (auto &p : count_next) {\n        int key = p.first;\n        if (count_prev.find(key) == count_prev.end()) {\n            ensuref(false, \"%s: Element %d appears in next but not in previous\", message, key);\n        }\n    }\n    ensuref(missing_count == 1, \"%s: Number of missing elements is %d, expected 1\", message, missing_count);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n - 1, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n - 2, 1, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    unordered_map<int, int> count_a, count_b, count_c;\n    for (int x : a) count_a[x]++;\n    for (int x : b) count_b[x]++;\n    for (int x : c) count_c[x]++;\n\n    check_counts(count_a, count_b, \"After first compilation\");\n    check_counts(count_b, count_c, \"After second compilation\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvoid check_counts(unordered_map<int, int> &count_prev, unordered_map<int, int> &count_next, const char *message) {\n    int missing_count = 0;\n    for (auto &p : count_prev) {\n        int key = p.first;\n        int cp = p.second;\n        int cn = count_next[key];\n        if (cp > cn) {\n            int diff = cp - cn;\n            if (diff == 1) {\n                missing_count++;\n            } else {\n                ensuref(false, \"%s: Count difference for element %d is %d, expected at most 1\", message, key, diff);\n            }\n        } else if (cp == cn) {\n            continue;\n        } else {\n            ensuref(false, \"%s: Count for element %d increased from previous to next\", message, key);\n        }\n    }\n    for (auto &p : count_next) {\n        int key = p.first;\n        if (count_prev.find(key) == count_prev.end()) {\n            ensuref(false, \"%s: Element %d appears in next but not in previous\", message, key);\n        }\n    }\n    ensuref(missing_count == 1, \"%s: Number of missing elements is %d, expected 1\", message, missing_count);\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 100000, \"n\");\n    inf.readEoln();\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n    vector<int> b = inf.readInts(n - 1, 1, 1000000000, \"b_i\");\n    inf.readEoln();\n    vector<int> c = inf.readInts(n - 2, 1, 1000000000, \"c_i\");\n    inf.readEoln();\n\n    unordered_map<int, int> count_a, count_b, count_c;\n    for (int x : a) count_a[x]++;\n    for (int x : b) count_b[x]++;\n    for (int x : c) count_c[x]++;\n\n    check_counts(count_a, count_b, \"After first compilation\");\n    check_counts(count_b, count_c, \"After second compilation\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n \n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 1000000000);\n \n    // Generate the initial list of errors a1, ..., an\n    vector<int> a(n);\n \n    if (type == \"random\") {\n        // Random errors, no duplicates\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    } else if (type == \"duplicates\") {\n        // Random errors with duplicates\n        int distinct = rnd.next(1, n);\n        vector<int> distinctErrors(distinct);\n        for (int i = 0; i < distinct; ++i)\n            distinctErrors[i] = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = distinctErrors[rnd.next(0, distinct - 1)];\n    } else if (type == \"all_same\") {\n        // All errors are the same number\n        int num = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = num;\n    } else if (type == \"sorted\") {\n        // Errors are sorted in increasing order\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n        sort(a.begin(), a.end());\n    } else if (type == \"reverse_sorted\") {\n        // Errors are sorted in decreasing order\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n        sort(a.rbegin(), a.rend());\n    } else if (type == \"max\") {\n        // All errors are maxA\n        for (int i = 0; i < n; ++i)\n            a[i] = maxA;\n    } else if (type == \"small\") {\n        // All errors are small numbers\n        maxA = min(maxA, 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    } else if (type == \"one_duplicate\") {\n        // Errors with exactly one duplicate number\n        if (n < 2) {\n            // Can't have duplicates with less than 2 elements\n            for (int i = 0; i < n; ++i)\n                a[i] = rnd.next(1, maxA);\n        } else {\n            int num = rnd.next(1, maxA);\n            a[0] = num;\n            a[1] = num;\n            for (int i = 2; i < n; ++i)\n                a[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"many_duplicates\") {\n        // Errors where multiple numbers are duplicated\n        int k = rnd.next(1, n); // number of distinct errors\n        vector<int> distinctErrors(k);\n        for (int i = 0; i < k; ++i)\n            distinctErrors[i] = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = distinctErrors[rnd.next(0, k - 1)];\n    }\n \n    // Now generate b by removing one error from a\n    vector<int> b = a;\n    int pos1 = rnd.next(0, n - 1);\n    int removed1 = b[pos1];\n    b.erase(b.begin() + pos1);\n \n    // Generate c by removing another error from b\n    int pos2 = rnd.next(0, n - 2);\n    int removed2 = b[pos2];\n    b.erase(b.begin() + pos2);\n    vector<int> c = b;\n \n    // Shuffle errors in a, b, c since the compiler shows errors in random order every time\n    shuffle(a.begin(), a.end());\n    shuffle(b.begin(), b.end());\n    shuffle(c.begin(), c.end());\n \n    // Output the sequences\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    for (int i = 0; i < n - 1; ++i)\n        printf(\"%d%c\", b[i], i + 1 == n - 1 ? '\\n' : ' ');\n    for (int i = 0; i < n - 2; ++i)\n        printf(\"%d%c\", c[i], i + 1 == n - 2 ? '\\n' : ' ');\n \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n \n    // Parse parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int maxA = opt<int>(\"maxA\", 1000000000);\n \n    // Generate the initial list of errors a1, ..., an\n    vector<int> a(n);\n \n    if (type == \"random\") {\n        // Random errors, no duplicates\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    } else if (type == \"duplicates\") {\n        // Random errors with duplicates\n        int distinct = rnd.next(1, n);\n        vector<int> distinctErrors(distinct);\n        for (int i = 0; i < distinct; ++i)\n            distinctErrors[i] = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = distinctErrors[rnd.next(0, distinct - 1)];\n    } else if (type == \"all_same\") {\n        // All errors are the same number\n        int num = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = num;\n    } else if (type == \"sorted\") {\n        // Errors are sorted in increasing order\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n        sort(a.begin(), a.end());\n    } else if (type == \"reverse_sorted\") {\n        // Errors are sorted in decreasing order\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n        sort(a.rbegin(), a.rend());\n    } else if (type == \"max\") {\n        // All errors are maxA\n        for (int i = 0; i < n; ++i)\n            a[i] = maxA;\n    } else if (type == \"small\") {\n        // All errors are small numbers\n        maxA = min(maxA, 10);\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, maxA);\n    } else if (type == \"one_duplicate\") {\n        // Errors with exactly one duplicate number\n        if (n < 2) {\n            // Can't have duplicates with less than 2 elements\n            for (int i = 0; i < n; ++i)\n                a[i] = rnd.next(1, maxA);\n        } else {\n            int num = rnd.next(1, maxA);\n            a[0] = num;\n            a[1] = num;\n            for (int i = 2; i < n; ++i)\n                a[i] = rnd.next(1, maxA);\n        }\n    } else if (type == \"many_duplicates\") {\n        // Errors where multiple numbers are duplicated\n        int k = rnd.next(1, n); // number of distinct errors\n        vector<int> distinctErrors(k);\n        for (int i = 0; i < k; ++i)\n            distinctErrors[i] = rnd.next(1, maxA);\n        for (int i = 0; i < n; ++i)\n            a[i] = distinctErrors[rnd.next(0, k - 1)];\n    }\n \n    // Now generate b by removing one error from a\n    vector<int> b = a;\n    int pos1 = rnd.next(0, n - 1);\n    int removed1 = b[pos1];\n    b.erase(b.begin() + pos1);\n \n    // Generate c by removing another error from b\n    int pos2 = rnd.next(0, n - 2);\n    int removed2 = b[pos2];\n    b.erase(b.begin() + pos2);\n    vector<int> c = b;\n \n    // Shuffle errors in a, b, c since the compiler shows errors in random order every time\n    shuffle(a.begin(), a.end());\n    shuffle(b.begin(), b.end());\n    shuffle(c.begin(), c.end());\n \n    // Output the sequences\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i + 1 == n ? '\\n' : ' ');\n    for (int i = 0; i < n - 1; ++i)\n        printf(\"%d%c\", b[i], i + 1 == n - 1 ? '\\n' : ' ');\n    for (int i = 0; i < n - 2; ++i)\n        printf(\"%d%c\", c[i], i + 1 == n - 2 ? '\\n' : ' ');\n \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -type random\n./gen -n 3 -type duplicates\n./gen -n 3 -type all_same\n\n./gen -n 5 -type random\n./gen -n 5 -type duplicates\n./gen -n 5 -type all_same\n\n./gen -n 10 -type random\n./gen -n 10 -type duplicates\n./gen -n 10 -type all_same\n\n./gen -n 1000 -type random\n./gen -n 1000 -type duplicates\n./gen -n 1000 -type all_same\n\n./gen -n 10000 -type random\n./gen -n 10000 -type duplicates\n./gen -n 10000 -type all_same\n\n./gen -n 100000 -type random\n./gen -n 100000 -type duplicates\n./gen -n 100000 -type all_same\n\n./gen -n 100000 -type sorted\n./gen -n 100000 -type reverse_sorted\n./gen -n 100000 -type max\n./gen -n 100000 -type small -maxA 10\n\n./gen -n 100000 -type one_duplicate\n./gen -n 100000 -type many_duplicates\n\n./gen -n 3 -type small -maxA 2\n./gen -n 5 -type small -maxA 5\n./gen -n 6 -type duplicates\n./gen -n 100000 -type random -maxA 2\n\n./gen -n 99999 -type random\n\n./gen -n 100000 -type duplicates -maxA 1\n\n./gen -n 100000 -type random -maxA 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:44.694728",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "519/C",
      "title": "C. A и B и командная тренировка",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая строка содержит два целых числа n и m (0 ≤ n, m ≤ 5 * 105) — количество опытных участников и новичков, присутствующих на тренировке.",
      "output_spec": "Выходные данныеВыведите максимальное количество команд одного из двух описанных в условии типов, которое может быть сформировано.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 6Выходные данныеСкопировать2Входные данныеСкопировать4 5Выходные данныеСкопировать3",
      "description": "C. A и B и командная тренировка\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеПервая строка содержит два целых числа n и m (0 ≤ n, m ≤ 5 * 105) — количество опытных участников и новичков, присутствующих на тренировке.\n\nВходные данные\n\nВыходные данныеВыведите максимальное количество команд одного из двух описанных в условии типов, которое может быть сформировано.\n\nВыходные данные\n\nВходные данныеСкопировать2 6Выходные данныеСкопировать2Входные данныеСкопировать4 5Выходные данныеСкопировать3\n\nВходные данныеСкопировать2 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать4 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОбозначим опытных участников как О, новичков как Н. В первом тестовом примере команды выглядят так: (О, Н, Н), (О, Н, Н).Во втором тестовом примере команды выглядят так: (О, Н, Н), (О, Н, Н), (О, О, Н).",
      "solutions": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!Меня зовут Адилет Жаксыбай, и вместе с Бекжаном Касеновым (BekzhanKassenov) мы являемся авторами раунда Codeforces #294, который состоится 28 февраля в 16:00 MSK. Это наш первый раунд Codeforces, и мы рады пригласить всех поучаствовать в нем. Раунд будет рейтинговым для участников второго дивизиона, участники первого дивизиона могут, как обычно, поучаствовать в нем вне конкурса. Насколько мы знаем, это будет первый раунд на Codeforces, полностью подготовленный участниками из Казахстана. Мы очень рады, что нам выпала такая честь, и надеемся, что все пройдет хорошо. Мы призываем всех других участников из нашей страны тоже стать авторами раундов — уверен, вы сможете подготовить множество отличных задач. Сделать раунд Codeforces — реальность ;)Хочется выразить благодарность всем тем, кто помог нам с подготовкой раунда: Максиму Ахмедову (Zlobober), который помог нам с подготовкой задач, Нурлану Канапину (kt-9) и Мансуру Кутыбаеву (mexmans), протестировавшим контест, и Марии Беловой (Delinur), которая перевела условия на английский язык. Отдельное огромное спасибо Михаилу Мирзаянову (MikeMirzayanov) за создание платформ Codeforces и Polygon. Мы бы хотели поздравить Codeforces с недавно прошедшим пятилетием. Нам, авторам раунда, невероятно повезло начать заниматься олимпиадами по программированию, когда сайт Codeforces уже существовал, и он внес невероятный вклад в наше развитие!Нам очень нравится, когда авторы задач пишут в анонсе немного о себе (призываем всех авторов поступать также) — это дает лучше почувствовать, что за задачами стоят реальные люди. Поэтому напишем немного о нас. Мы являемся студентами Назарбаев Университета (nu.edu.kz) — нового университета с английским языком обучения в столице Казахстана, Астане. В ACM-ICPC наш университет участвует лишь с 2012 года, но тем не менее команда с NU уже два раза проходила в финал в 2014 и 2015 году. Мы надеемся и в будущем держать планку спортивного программирования на высоком уровне. Всем удачи! UPD Разбалловка будет стандартной (500 — 1000 — 1500 — 2000 — 2500)UPD2 Разбор можно найти тутПоздравляем победителей: AkashiSeijuro fmzbtf937 mxh3777 IGandWFin2019 ruozha2 & i_hate_t0nzuk Раунд закончен, спасибо всем, кто принял участие!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16662",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2235
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "519A - A и B и шахматыАвтор: BekzhanKassenovВ этой задаче необходимо было найти чья шахматная позиция сильнее.Решение: Пробегаемся по всей доске, складывая веса фигур игроков, и в конце выводим ответ.Асимптотика: O(n2), где n — длина стороны доски (в этой задаче — 8)Код: 10083191519B - A и B и ошибки компиляцииАвтор: ADJAВ этой задаче вам было дано 3 массива. Второй содержал все элементы первого, за исключением одного, третий массив содержал все элементы второго, за исключением одного. Необходимо было вывести удаленные элементы.Решение: Я опишу простейшее решение этой задачи: Обозначим сумму элементов в первом, втором и третьем массиве как a, b и c соответственно. Ответом будут числа a - b и b - cТакже существуют множество других решений, использующих map, xor и прочее. Асимптотика: O(N)Код: 10083248519C - A и B и командная тренировкаАвтор: ADJAВ этой задаче вам необходимо было поделить n опытных участников и m новичков на команды.Решение: Обозначим команды с 2 опытными участниками и 1 новичком как type1 и команды с 1 опытным участником и 2 новичками как type2. Зафиксируем количество команд type1 как i. Их количество не превышает m. Тогда количество команд type2 равно min(m - 2 * i, n - i). Осталось проверить все возможные варианты i и выбрать оптимальный.Асимптотика: O(N)Код: 10083265.519D - A и B и интересные подстрокиАвтор: ADJAВ этой задаче необходимо было найти количество подстрок данной строки таких, что каждая подстрока начинается и заканчивается на одну и ту же букву и сумма весов букв в этой подстроке (кроме начала и конца) равно нулю.Решение: Обозначим sum[i] как сумму весов первых i букв. Создадим 26 map < longlong, int > -ов, 1 на каждую букву. Пусть в данный момент мы находимся на позиции i и map текущего символа m. Тогда необходимо добавить к ответу m[sum[i — 1]], и sum[i] в m. Асимптотика: O(Nlog(N)), где N — длина исходной строки.Код: 10083293.519E - A и B и аудиторииАвтор: BekzhanKassenovВ задаче необходимо было отвечать на следующие запросы на дереве: для заданных пар вершин найти количество вершин, равноудаленных от них.Принятые обозначения:dist(a, b) — расстояние между вершинами a и b.LCA(a, b) — наименьший общий предок вершин a и b.depth[a] — расстояние от корня дерева до вершины a.size[a] — размер поддерева, корнем которой является вершина a.На каждой картинке вершины, покрашенные в зеленый цвет — вершины из ответа, вершины, покрашенные в синий цвет — вершины из запросов.Препроцессинг: Для начала необходимо считать ребра дерева и построить по ним структуру данных для нахождения LCA (удобнее всего использовать двоичный подъем, так как в будущем он понадобится для других целей). Асимптотика: O(NlogN)Ответы на запросы:Для каждого запроса необходимо рассмотреть несколько случаев:1) a = b. В этом случае ответ равен n.2) dist(a, b) нечетно. Тогда ответом будет 0.3) dist(a, l) = dist(b, l), где l = LCA(a, b). Двоичным подъемом найдем сыновей вершины l, которые являются предками вершин a и b (обозначим их как aa и bb соответственно). Ответом будет n - size[aa] - size[bb].4) Все остальные случаи. Предположим, что depth[a] > depth[b]. Тогда найдем с помощью двоичного подъема dist(a, b) / 2-ого предка вершины a (обозначим его как p1), dist(a, b) / 2 - 1-ого предка вершины a (обозначим его как p2). Ответом будет size[p1] - size[p2].Асимптотика: O(logN) на запрос, O(MlogN) на все запросы.Итоговая асимптотика: O(MlogN + NlogN)Код: 10083310.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16687",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 519\\s*C"
          },
          "content_length": 3410
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "%d%c ... i == n - 1 ? '\\n' : ' '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "A <= 2*B ,  B <= 2*A ,  A <= X , B <= Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 6",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Разбор задач Codeforces Round #294 (Div. 2) - Codeforces - Code 7",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(0, 500000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, 500000, \"m\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nMin = opt<int>(\"nMin\", 0);\n    int nMax = opt<int>(\"nMax\", 500000);\n    int mMin = opt<int>(\"mMin\", 0);\n    int mMax = opt<int>(\"mMax\", 500000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, m;\n\n    if (type == \"zeros\") {\n        n = 0;\n        m = 0;\n    } else if (type == \"nZero\") {\n        n = 0;\n        m = rnd.next(mMin, mMax);\n    } else if (type == \"mZero\") {\n        n = rnd.next(nMin, nMax);\n        m = 0;\n    } else if (type == \"equal\") {\n        int minVal = max(nMin, mMin);\n        int maxVal = min(nMax, mMax);\n        if (minVal > maxVal) {\n            n = m = minVal; // If ranges do not overlap, set to minVal\n        } else {\n            n = m = rnd.next(minVal, maxVal);\n        }\n    } else if (type == \"nLarge\") {\n        n = rnd.next(nMin, nMax);\n        m = rnd.next(mMin, min(mMin + 10, mMax));\n    } else if (type == \"mLarge\") {\n        n = rnd.next(nMin, min(nMin + 10, nMax));\n        m = rnd.next(mMin, mMax);\n    } else if (type == \"max\") {\n        n = nMax;\n        m = mMax;\n    } else if (type == \"random\") {\n        n = rnd.next(nMin, nMax);\n        m = rnd.next(mMin, mMax);\n    } else {\n        // Default: random\n        n = rnd.next(nMin, nMax);\n        m = rnd.next(mMin, mMax);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int nMin = opt<int>(\"nMin\", 0);\n    int nMax = opt<int>(\"nMax\", 500000);\n    int mMin = opt<int>(\"mMin\", 0);\n    int mMax = opt<int>(\"mMax\", 500000);\n    string type = opt<string>(\"type\", \"random\");\n\n    int n, m;\n\n    if (type == \"zeros\") {\n        n = 0;\n        m = 0;\n    } else if (type == \"nZero\") {\n        n = 0;\n        m = rnd.next(mMin, mMax);\n    } else if (type == \"mZero\") {\n        n = rnd.next(nMin, nMax);\n        m = 0;\n    } else if (type == \"equal\") {\n        int minVal = max(nMin, mMin);\n        int maxVal = min(nMax, mMax);\n        if (minVal > maxVal) {\n            n = m = minVal; // If ranges do not overlap, set to minVal\n        } else {\n            n = m = rnd.next(minVal, maxVal);\n        }\n    } else if (type == \"nLarge\") {\n        n = rnd.next(nMin, nMax);\n        m = rnd.next(mMin, min(mMin + 10, mMax));\n    } else if (type == \"mLarge\") {\n        n = rnd.next(nMin, min(nMin + 10, nMax));\n        m = rnd.next(mMin, mMax);\n    } else if (type == \"max\") {\n        n = nMax;\n        m = mMax;\n    } else if (type == \"random\") {\n        n = rnd.next(nMin, nMax);\n        m = rnd.next(mMin, mMax);\n    } else {\n        // Default: random\n        n = rnd.next(nMin, nMax);\n        m = rnd.next(mMin, mMax);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type zeros\n\n./gen -type nZero -mMin 1 -mMax 10\n./gen -type nZero -mMin 1 -mMax 1000\n./gen -type nZero -mMin 1 -mMax 500000\n\n./gen -type mZero -nMin 1 -nMax 10\n./gen -type mZero -nMin 1 -nMax 1000\n./gen -type mZero -nMin 1 -nMax 500000\n\n./gen -type equal -nMin 1 -nMax 10 -mMin 1 -mMax 10\n./gen -type equal -nMin 1 -nMax 1000 -mMin 1 -mMax 1000\n./gen -type equal -nMin 1 -nMax 500000 -mMin 1 -mMax 500000\n\n./gen -type nLarge -nMin 100000 -nMax 500000 -mMin 1 -mMax 10\n./gen -type nLarge -nMin 500000 -nMax 500000 -mMin 0 -mMax 0\n\n./gen -type mLarge -nMin 1 -nMax 10 -mMin 100000 -mMax 500000\n./gen -type mLarge -nMin 0 -nMax 0 -mMin 500000 -mMax 500000\n\n./gen -type max -nMax 500000 -mMax 500000\n\n./gen -type random -nMin 0 -nMax 500000 -mMin 0 -mMax 500000\n\n./gen -type random -nMin 1 -nMax 100 -mMin 1 -mMax 100\n\n./gen -type random -nMin 200000 -nMax 300000 -mMin 200000 -mMax 300000\n\n./gen -type random -nMin 0 -nMax 5000 -mMin 0 -mMax 5000\n\n./gen -type random -nMin 0 -nMax 1 -mMin 0 -mMax 1\n\n./gen -type random -nMin 0 -nMax 5 -mMin 0 -mMax 5\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:46.568819",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "519/D",
      "title": "D. A and B and Interesting Substrings",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains 26 integers xa, xb, ..., xz ( - 105 ≤ xi ≤ 105) — the value assigned to letters a, b, c, ..., z respectively.The second line contains string s of length between 1 and 105 characters, consisting of Lating lowercase letters— the string for which you need to calculate the answer.",
      "output_spec": "OutputPrint the answer to the problem.",
      "sample_tests": "ExamplesInputCopy1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1xabcabOutputCopy2InputCopy1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1aaaOutputCopy2",
      "description": "D. A and B and Interesting Substrings\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains 26 integers xa, xb, ..., xz ( - 105 ≤ xi ≤ 105) — the value assigned to letters a, b, c, ..., z respectively.The second line contains string s of length between 1 and 105 characters, consisting of Lating lowercase letters— the string for which you need to calculate the answer.\n\nOutputPrint the answer to the problem.\n\nInputCopy1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1xabcabOutputCopy2InputCopy1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1aaaOutputCopy2\n\nInputCopy1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1xabcab\n\nOutputCopy2\n\nInputCopy1 1 -1 1 1 1 1 1 1 1 1 1 1 1 1 7 1 1 1 8 1 1 1 1 1 1aaa\n\nOutputCopy2\n\nNoteIn the first sample test strings satisfying the condition above are abca and bcab.In the second sample test strings satisfying the condition above are two occurences of aa.",
      "solutions": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!My name is Adilet Zhaxybay, and together with Bekzhan Kassenov (BekzhanKassenov) we are authors of Codeforces #294, which will be held on 28th of February at 16:00 MSK. This is our first Codeforces round and we are happy to invite all of you to participate in it. The round will be rated for the second division, however, participants from the first division can, as usually, participate in it unofficially.As far as we know, it is the first Codeforces round, which was completely prepared by the authors from Kazakhstan. We are very honored by this fact and hope that everything will go great. We are encouraging other participants from our country to join us — I am sure, that you can prepare a lot of very nice problems. Preparing Codeforces round is possible ;)We want to thank all the people, who helped us to prepare the contest: Max Akhmedov (Zlobober), who helped us with the problems, Nurlan Kanapin (kt-9) and Mansur Kutybaev (mexmans), who tested the round, and Maria Belova (Delinur), who translated problem statements.Also we want to say great thanks to Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon. We want to congratulate Codeforces with its fifth anniversary. We, authors of the round, were very lucky to start competitive programming at the time, when Codeforces already existed, and it helped us really a lot!We love, when authors of the round write a bit about themselves (we encourage everybody to do so) — this helps to feel that there are real people behind the problems. Thus, we will write a bit about ourselves. We are students from Nazarbayev University (nu.edu.kz). NU is a new university with English as a language of teaching, which is located in the capital of Kazakhstan, Astana. Our university participates in ACM-ICPC only from 2012, but the team from NU already qualified to World Finals twice — in 2014 and 2015. We hope that we will do only better in the future!Good luck to all! UPD Score distribution will be standard (500 — 1000 — 1500 — 2000 — 2500)UPD2 Editorial is available hereCongratulations to winners! AkashiSeijuro fmzbtf937 mxh3777 IGandWFin2019 ruozha2 & i_hate_t0nzuk Round is over, thanks to everybody, who took part in it!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16662",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2217
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces",
          "content": "519A - A and B and ChessAuthor: BekzhanKassenovThis problem asked to determine whose chess position is better.Solution: Iterate over the board and count scores of both player. Then just output the answer.Complexity: O(n2), where n is the length of the side of the board (8 here)Code: 10083191519B - A and B and Compilation ErrorsAuthor: ADJAIn this problem you were given three arrays. Second array is the same as the first array without one element, third array is the same as second array without first element. You were asked to find deleted elements.Solution: I'll describe easiest solution for this problem: Let's denote a as sum of all elements of first array, b as sum of all elements of second array and c as sum of all elements of third array. Then answer is a - b and b - cThere are also some other solutions for this problem which use map, xor, etc.Complexity: O(N)Code: 10083248519C - A and B and Team TrainingAuthor: ADJAIn this problem we should split n experienced participants and m newbies into teams.Solution: Let's denote number teams with 2 experienced partisipants and 1 new participant as type1 and teams with 1 experienced participant and 2 new participants as type2. Let's fix number of teams of type1 and denote it as i. Their amount is not grater than m. Then number of teams of type2 is min(m - 2 * i, n - i). Check all possible i' and update answer.Complexity: O(N)Code: 10083265519D - A and B and Interesting SubstringsAuthor: ADJAIn this problem you were asked to find number of substrings of given string, such that each substring starts and finishes with one and the same letter and sum of weight of letters of that substring without first and last letter is zero.Solution: Let's denote sum[i] as sum of weights of first i letters. Create 26 map < longlong, int > 's, 1 for each letter. Suppose we are on position number i and current character's map is m. Then add m[sum[i - 1]] to the answer and add sum[i] to the m. Complexity: O(NlogN), where N — the length of input string.Code: 10083293519E - A and B and Lecture RoomsAuthor: BekzhanKassenovIn this problem we have to answer to the following queries on tree: for given pairs of vertices your program should output number of eqidistand vertices from them.Let's denote:dist(a, b) as distance between vertices a and b.LCA(a, b) as lowest common ancestor of vertices a and b.depth[a] as distance between root of the tree and vertex a.size[a] as size of subtree of vertex a.On each picture green nodes are equidistant nodes, blue nodes — nodes from query.Preprocessing: Read edges of tree and build data structure for LCA (it is more convenient to use binary raise, becase we will use it further for other purposes). Complexity: O(NlogN)Queries:We have to consider several cases for each query:1) a = b. In that case answer is n.2) dist(a, b) is odd. Then answer is 0.3) dist(a, l) = dist(b, l), where l = LCA(a, b). Find children of l, which are ancestors of a and b (let's denote them as aa and bb). Answer will be n - size[aa] - size[bb].4) All other cases. Assume that depth[a] > depth[b]. Then using binary raise find dist(a, b) / 2-th ancestor of a (let's denote it as p1), dist(a, b) / 2 - 1-th ancestor of vertex a (denote it as p2). Answer will be size[p1] - size[p2].Complexity: O(logN) for each query, O(MlogN) for all queries.Resulting complexity:: O(MlogN + NlogN)Code: 10083310",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16687",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 519\\s*D"
          },
          "content_length": 3374
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "%d%c ... i == n - 1 ? '\\n' : ' '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "A <= 2*B ,  B <= 2*A ,  A <= X , B <= Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> x = inf.readInts(26, -100000, 100000);\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]{1,100000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> x = inf.readInts(26, -100000, 100000);\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]{1,100000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    vector<int> x = inf.readInts(26, -100000, 100000);\n    inf.readEoln();\n\n    string s = inf.readToken(\"[a-z]{1,100000}\", \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator outputs exactly one test case each time it is run.\n  The format of the output is:\n    1) A line with 26 integers (values for letters 'a'..'z'),\n       each in the range [-100000, 100000].\n    2) A line with a string s of length n (1 <= n <= 100000),\n       consisting of lowercase letters.\n\n  Usage:\n    ./gen -n <length_of_string> -valType <how_to_generate_values> -strType <how_to_generate_string>\n\n  Where:\n    - valType can be:\n       \"allzero\": All 26 letter values are zero.\n       \"neg\": Random negative values in [-100000, -1].\n       \"pos\": Random positive values in [1, 100000].\n       \"random\": Random values in [-100000, 100000].\n    - strType can be:\n       \"single\": The entire string is one repeated letter.\n       \"pal\": The string is a palindrome.\n       \"repeat\": A small random pattern repeated to length n.\n       \"random\": Each position is a random letter from 'a'..'z'.\n*/\n\nstatic const int MIN_VAL = -100000;\nstatic const int MAX_VAL = 100000;\n\n/* Generate the 26 integer values according to valType. */\nvector<int> generateValues(const string &valType) {\n    vector<int> vals(26, 0);\n\n    if (valType == \"allzero\") {\n        // Already filled with zeros.\n    } else if (valType == \"neg\") {\n        for (int i = 0; i < 26; i++) {\n            // random negative in [-100000, -1]\n            vals[i] = -rnd.next(1, 100000);\n        }\n    } else if (valType == \"pos\") {\n        for (int i = 0; i < 26; i++) {\n            // random positive in [1, 100000]\n            vals[i] = rnd.next(1, 100000);\n        }\n    } else {\n        // random in [-100000, 100000]\n        for (int i = 0; i < 26; i++) {\n            int x = rnd.next(2*100000+1) - 100000; \n            vals[i] = x;\n        }\n    }\n    return vals;\n}\n\n/* Generate a string of length n according to strType. */\nstring generateString(int n, const string &strType) {\n    // We'll produce a string s of length n, guaranteed n >= 1\n    // (We assume the user passes a valid n).\n    string s(n, 'a');\n\n    if (strType == \"single\") {\n        // All positions are the same letter\n        char c = char('a' + rnd.next(26));\n        for (int i = 0; i < n; i++) {\n            s[i] = c;\n        }\n    } \n    else if (strType == \"pal\") {\n        // Generate a random palindrome\n        // Fill the first half randomly, then mirror\n        // If n is odd, the middle char can be random\n        // If n is even, perfect mirror\n        for (int i = 0; i < (n+1)/2; i++) {\n            s[i] = char('a' + rnd.next(26));\n        }\n        for (int i = 0; i < n/2; i++) {\n            s[n-1-i] = s[i];\n        }\n    } \n    else if (strType == \"repeat\") {\n        // Choose a small pattern length in [1, min(n, 10)]\n        int patternLen = rnd.next(1, min(n, 10));\n        string pattern(patternLen, 'a');\n        for (int i = 0; i < patternLen; i++){\n            pattern[i] = char('a' + rnd.next(26));\n        }\n        // Repeat the pattern to fill length n\n        for (int i = 0; i < n; i++){\n            s[i] = pattern[i % patternLen];\n        }\n    } \n    else {\n        // strType == \"random\" or unrecognized => random for each position\n        for (int i = 0; i < n; i++) {\n            s[i] = char('a' + rnd.next(26));\n        }\n    }\n\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10); // length of the string\n    string valType = opt<string>(\"valType\", \"random\"); // how to generate 26 letter values\n    string strType = opt<string>(\"strType\", \"random\"); // how to generate the string\n\n    // 1) Generate letter values:\n    vector<int> vals = generateValues(valType);\n\n    // 2) Generate string s of length n:\n    //    The problem statement allows 1 <= n <= 100000.\n    //    We'll assume the user won't pass an invalid n.\n    string s = generateString(n, strType);\n\n    // 3) Print the output\n    //    First line: 26 integers\n    //    Second line: the string s\n    for (int i = 0; i < 26; i++) {\n        cout << vals[i];\n        if (i + 1 < 26) cout << \" \";\n    }\n    cout << \"\\n\";\n    cout << s << \"\\n\";\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator outputs exactly one test case each time it is run.\n  The format of the output is:\n    1) A line with 26 integers (values for letters 'a'..'z'),\n       each in the range [-100000, 100000].\n    2) A line with a string s of length n (1 <= n <= 100000),\n       consisting of lowercase letters.\n\n  Usage:\n    ./gen -n <length_of_string> -valType <how_to_generate_values> -strType <how_to_generate_string>\n\n  Where:\n    - valType can be:\n       \"allzero\": All 26 letter values are zero.\n       \"neg\": Random negative values in [-100000, -1].\n       \"pos\": Random positive values in [1, 100000].\n       \"random\": Random values in [-100000, 100000].\n    - strType can be:\n       \"single\": The entire string is one repeated letter.\n       \"pal\": The string is a palindrome.\n       \"repeat\": A small random pattern repeated to length n.\n       \"random\": Each position is a random letter from 'a'..'z'.\n*/\n\nstatic const int MIN_VAL = -100000;\nstatic const int MAX_VAL = 100000;\n\n/* Generate the 26 integer values according to valType. */\nvector<int> generateValues(const string &valType) {\n    vector<int> vals(26, 0);\n\n    if (valType == \"allzero\") {\n        // Already filled with zeros.\n    } else if (valType == \"neg\") {\n        for (int i = 0; i < 26; i++) {\n            // random negative in [-100000, -1]\n            vals[i] = -rnd.next(1, 100000);\n        }\n    } else if (valType == \"pos\") {\n        for (int i = 0; i < 26; i++) {\n            // random positive in [1, 100000]\n            vals[i] = rnd.next(1, 100000);\n        }\n    } else {\n        // random in [-100000, 100000]\n        for (int i = 0; i < 26; i++) {\n            int x = rnd.next(2*100000+1) - 100000; \n            vals[i] = x;\n        }\n    }\n    return vals;\n}\n\n/* Generate a string of length n according to strType. */\nstring generateString(int n, const string &strType) {\n    // We'll produce a string s of length n, guaranteed n >= 1\n    // (We assume the user passes a valid n).\n    string s(n, 'a');\n\n    if (strType == \"single\") {\n        // All positions are the same letter\n        char c = char('a' + rnd.next(26));\n        for (int i = 0; i < n; i++) {\n            s[i] = c;\n        }\n    } \n    else if (strType == \"pal\") {\n        // Generate a random palindrome\n        // Fill the first half randomly, then mirror\n        // If n is odd, the middle char can be random\n        // If n is even, perfect mirror\n        for (int i = 0; i < (n+1)/2; i++) {\n            s[i] = char('a' + rnd.next(26));\n        }\n        for (int i = 0; i < n/2; i++) {\n            s[n-1-i] = s[i];\n        }\n    } \n    else if (strType == \"repeat\") {\n        // Choose a small pattern length in [1, min(n, 10)]\n        int patternLen = rnd.next(1, min(n, 10));\n        string pattern(patternLen, 'a');\n        for (int i = 0; i < patternLen; i++){\n            pattern[i] = char('a' + rnd.next(26));\n        }\n        // Repeat the pattern to fill length n\n        for (int i = 0; i < n; i++){\n            s[i] = pattern[i % patternLen];\n        }\n    } \n    else {\n        // strType == \"random\" or unrecognized => random for each position\n        for (int i = 0; i < n; i++) {\n            s[i] = char('a' + rnd.next(26));\n        }\n    }\n\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10); // length of the string\n    string valType = opt<string>(\"valType\", \"random\"); // how to generate 26 letter values\n    string strType = opt<string>(\"strType\", \"random\"); // how to generate the string\n\n    // 1) Generate letter values:\n    vector<int> vals = generateValues(valType);\n\n    // 2) Generate string s of length n:\n    //    The problem statement allows 1 <= n <= 100000.\n    //    We'll assume the user won't pass an invalid n.\n    string s = generateString(n, strType);\n\n    // 3) Print the output\n    //    First line: 26 integers\n    //    Second line: the string s\n    for (int i = 0; i < 26; i++) {\n        cout << vals[i];\n        if (i + 1 < 26) cout << \" \";\n    }\n    cout << \"\\n\";\n    cout << s << \"\\n\";\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are example commands to run the generator. \n# Each command produces ONE test case with the specified parameters.\n\n# Small strings, specialized value patterns.\n\n./gen -n 1 -valType allzero -strType single\n./gen -n 2 -valType pos -strType single\n./gen -n 5 -valType neg -strType single\n./gen -n 5 -valType allzero -strType pal\n./gen -n 5 -valType random -strType pal\n\n# Medium strings, variety of patterns.\n\n./gen -n 10 -valType allzero -strType repeat\n./gen -n 10 -valType pos -strType random\n./gen -n 10 -valType neg -strType random\n./gen -n 12 -valType random -strType single\n./gen -n 12 -valType random -strType pal\n\n# Larger strings.\n\n./gen -n 50 -valType neg -strType repeat\n./gen -n 50 -valType pos -strType pal\n./gen -n 50 -valType random -strType random\n./gen -n 100 -valType allzero -strType repeat\n./gen -n 100 -valType random -strType pal\n\n# Even larger.\n\n./gen -n 1000 -valType allzero -strType random\n./gen -n 1000 -valType random -strType repeat\n./gen -n 9999 -valType neg -strType random\n./gen -n 9999 -valType pos -strType pal\n./gen -n 10000 -valType random -strType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:48.604663",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "519/E",
      "title": "E. A and B and Lecture Rooms",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of rooms in the University.The next n - 1 lines describe the corridors. The i-th of these lines (1 ≤ i ≤ n - 1) contains two integers ai and bi (1 ≤ ai, bi ≤ n), showing that the i-th corridor connects rooms ai and bi.The next line contains integer m (1 ≤ m ≤ 105) — the number of queries.Next m lines describe the queries. The j-th of these lines (1 ≤ j ≤ m) contains two integers xj and yj (1 ≤ xj, yj ≤ n) that means that on the j-th day A will write the contest in the room xj, B will write in the room yj.",
      "output_spec": "OutputIn the i-th (1 ≤ i ≤ m) line print the number of rooms that are equidistant from the rooms where A and B write contest on the i-th day.",
      "sample_tests": "ExamplesInputCopy41 21 32 412 3OutputCopy1InputCopy41 22 32 421 21 3OutputCopy02",
      "description": "E. A and B and Lecture Rooms\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of rooms in the University.The next n - 1 lines describe the corridors. The i-th of these lines (1 ≤ i ≤ n - 1) contains two integers ai and bi (1 ≤ ai, bi ≤ n), showing that the i-th corridor connects rooms ai and bi.The next line contains integer m (1 ≤ m ≤ 105) — the number of queries.Next m lines describe the queries. The j-th of these lines (1 ≤ j ≤ m) contains two integers xj and yj (1 ≤ xj, yj ≤ n) that means that on the j-th day A will write the contest in the room xj, B will write in the room yj.\n\nOutputIn the i-th (1 ≤ i ≤ m) line print the number of rooms that are equidistant from the rooms where A and B write contest on the i-th day.\n\nInputCopy41 21 32 412 3OutputCopy1InputCopy41 22 32 421 21 3OutputCopy02\n\nInputCopy41 21 32 412 3\n\nOutputCopy1\n\nInputCopy41 22 32 421 21 3\n\nOutputCopy02\n\nNotein the first sample there is only one room at the same distance from rooms number 2 and 3 — room number 1.",
      "solutions": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!My name is Adilet Zhaxybay, and together with Bekzhan Kassenov (BekzhanKassenov) we are authors of Codeforces #294, which will be held on 28th of February at 16:00 MSK. This is our first Codeforces round and we are happy to invite all of you to participate in it. The round will be rated for the second division, however, participants from the first division can, as usually, participate in it unofficially.As far as we know, it is the first Codeforces round, which was completely prepared by the authors from Kazakhstan. We are very honored by this fact and hope that everything will go great. We are encouraging other participants from our country to join us — I am sure, that you can prepare a lot of very nice problems. Preparing Codeforces round is possible ;)We want to thank all the people, who helped us to prepare the contest: Max Akhmedov (Zlobober), who helped us with the problems, Nurlan Kanapin (kt-9) and Mansur Kutybaev (mexmans), who tested the round, and Maria Belova (Delinur), who translated problem statements.Also we want to say great thanks to Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon. We want to congratulate Codeforces with its fifth anniversary. We, authors of the round, were very lucky to start competitive programming at the time, when Codeforces already existed, and it helped us really a lot!We love, when authors of the round write a bit about themselves (we encourage everybody to do so) — this helps to feel that there are real people behind the problems. Thus, we will write a bit about ourselves. We are students from Nazarbayev University (nu.edu.kz). NU is a new university with English as a language of teaching, which is located in the capital of Kazakhstan, Astana. Our university participates in ACM-ICPC only from 2012, but the team from NU already qualified to World Finals twice — in 2014 and 2015. We hope that we will do only better in the future!Good luck to all! UPD Score distribution will be standard (500 — 1000 — 1500 — 2000 — 2500)UPD2 Editorial is available hereCongratulations to winners! AkashiSeijuro fmzbtf937 mxh3777 IGandWFin2019 ruozha2 & i_hate_t0nzuk Round is over, thanks to everybody, who took part in it!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16662",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 2217
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces",
          "content": "519A - A and B and ChessAuthor: BekzhanKassenovThis problem asked to determine whose chess position is better.Solution: Iterate over the board and count scores of both player. Then just output the answer.Complexity: O(n2), where n is the length of the side of the board (8 here)Code: 10083191519B - A and B and Compilation ErrorsAuthor: ADJAIn this problem you were given three arrays. Second array is the same as the first array without one element, third array is the same as second array without first element. You were asked to find deleted elements.Solution: I'll describe easiest solution for this problem: Let's denote a as sum of all elements of first array, b as sum of all elements of second array and c as sum of all elements of third array. Then answer is a - b and b - cThere are also some other solutions for this problem which use map, xor, etc.Complexity: O(N)Code: 10083248519C - A and B and Team TrainingAuthor: ADJAIn this problem we should split n experienced participants and m newbies into teams.Solution: Let's denote number teams with 2 experienced partisipants and 1 new participant as type1 and teams with 1 experienced participant and 2 new participants as type2. Let's fix number of teams of type1 and denote it as i. Their amount is not grater than m. Then number of teams of type2 is min(m - 2 * i, n - i). Check all possible i' and update answer.Complexity: O(N)Code: 10083265519D - A and B and Interesting SubstringsAuthor: ADJAIn this problem you were asked to find number of substrings of given string, such that each substring starts and finishes with one and the same letter and sum of weight of letters of that substring without first and last letter is zero.Solution: Let's denote sum[i] as sum of weights of first i letters. Create 26 map < longlong, int > 's, 1 for each letter. Suppose we are on position number i and current character's map is m. Then add m[sum[i - 1]] to the answer and add sum[i] to the m. Complexity: O(NlogN), where N — the length of input string.Code: 10083293519E - A and B and Lecture RoomsAuthor: BekzhanKassenovIn this problem we have to answer to the following queries on tree: for given pairs of vertices your program should output number of eqidistand vertices from them.Let's denote:dist(a, b) as distance between vertices a and b.LCA(a, b) as lowest common ancestor of vertices a and b.depth[a] as distance between root of the tree and vertex a.size[a] as size of subtree of vertex a.On each picture green nodes are equidistant nodes, blue nodes — nodes from query.Preprocessing: Read edges of tree and build data structure for LCA (it is more convenient to use binary raise, becase we will use it further for other purposes). Complexity: O(NlogN)Queries:We have to consider several cases for each query:1) a = b. In that case answer is n.2) dist(a, b) is odd. Then answer is 0.3) dist(a, l) = dist(b, l), where l = LCA(a, b). Find children of l, which are ancestors of a and b (let's denote them as aa and bb). Answer will be n - size[aa] - size[bb].4) All other cases. Assume that depth[a] > depth[b]. Then using binary raise find dist(a, b) / 2-th ancestor of a (let's denote it as p1), dist(a, b) / 2 - 1-th ancestor of vertex a (denote it as p2). Answer will be size[p1] - size[p2].Complexity: O(logN) for each query, O(MlogN) for all queries.Resulting complexity:: O(MlogN + NlogN)Code: 10083310",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16687",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 519\\s*E"
          },
          "content_length": 3374
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 1",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 2",
          "code": "mymap['K'] = mymap['k'] = 3; //this case",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 3",
          "code": "%d%c ... i == n - 1 ? '\\n' : ' '",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 4",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) - Codeforces - Code 5",
          "code": "3\n1000000000 1000000000 147483648\n1000000000 147483648\n147483648",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16662",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 1",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 2",
          "code": "if( n-(m*2) > 0) cout<<m;\n     else if( m-(n*2) > 0) cout<<n;\n     else cout<<(n+m)/3;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 3",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 4",
          "code": "int res = 0;\nwhile (n > 0 and m > 0 and n + m >= 3) {\n\tif (n < m)\n\t\tn--, m -= 2;\n\telse m--, n -= 2;\n\tres++;\n}\ncout << res << \"\\n\";",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 5",
          "code": "A <= 2*B ,  B <= 2*A ,  A <= X , B <= Y",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 6",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #294 (Div. 2) Editorial - Codeforces - Code 7",
          "code": "for(int k = 0; k < dist / 2 - 1; k++)\n    p = T[p];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16687",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    int components = n;\n\n    for (int i = 1; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Self-loops are not allowed: ai (%d) == bi (%d)\", ai, bi);\n\n        int u_root = find(ai);\n        int v_root = find(bi);\n        if (u_root != v_root) {\n            parent[u_root] = v_root;\n            components--;\n        }\n    }\n    ensuref(components == 1, \"The graph must be connected\");\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= m; i++) {\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    int components = n;\n\n    for (int i = 1; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Self-loops are not allowed: ai (%d) == bi (%d)\", ai, bi);\n\n        int u_root = find(ai);\n        int v_root = find(bi);\n        if (u_root != v_root) {\n            parent[u_root] = v_root;\n            components--;\n        }\n    }\n    ensuref(components == 1, \"The graph must be connected\");\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= m; i++) {\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> parent(n + 1);\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n    }\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u) parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    int components = n;\n\n    for (int i = 1; i < n; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n        ensuref(ai != bi, \"Self-loops are not allowed: ai (%d) == bi (%d)\", ai, bi);\n\n        int u_root = find(ai);\n        int v_root = find(bi);\n        if (u_root != v_root) {\n            parent[u_root] = v_root;\n            components--;\n        }\n    }\n    ensuref(components == 1, \"The graph must be connected\");\n\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n\n    for (int i = 1; i <= m; i++) {\n        int xj = inf.readInt(1, n, \"xj\");\n        inf.readSpace();\n        int yj = inf.readInt(1, n, \"yj\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string query_type = opt<string>(\"query\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    // Generate tree according to tree_type\n    if (tree_type == \"chain\") {\n        // Create a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Create a star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // Create a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Shuffle edges randomly\n    shuffle(edges.begin(), edges.end());\n\n    // Output the number of nodes\n    printf(\"%d\\n\", n);\n    // Output the edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Output the number of queries\n    printf(\"%d\\n\", m);\n\n    // Generate queries according to query_type\n    vector<pair<int, int>> queries;\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.push_back({x, y});\n        }\n    } else if (query_type == \"same\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            queries.push_back({x, x});\n        }\n    } else if (query_type == \"opposite\") {\n        // Nodes at maximum distance\n        int x = 1;\n        int y = n;\n        for (int i = 0; i < m; ++i) {\n            queries.push_back({x, y});\n        }\n    } else if (query_type == \"fixed\") {\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            queries.push_back({x, y});\n        }\n    } else if (query_type == \"near\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = x;\n            while (y == x) {\n                y = rnd.next(max(1, x - 2), min(n, x + 2));\n            }\n            queries.push_back({x, y});\n        }\n    } else {\n        // Default random queries\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.push_back({x, y});\n        }\n    }\n\n    // Output the queries\n    for (auto q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string query_type = opt<string>(\"query\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    // Generate tree according to tree_type\n    if (tree_type == \"chain\") {\n        // Create a chain\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        // Create a star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"binary\") {\n        // Create a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int p = rnd.next(1, i - 1);\n            edges.push_back({p, i});\n        }\n    }\n\n    // Shuffle edges randomly\n    shuffle(edges.begin(), edges.end());\n\n    // Output the number of nodes\n    printf(\"%d\\n\", n);\n    // Output the edges\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    // Output the number of queries\n    printf(\"%d\\n\", m);\n\n    // Generate queries according to query_type\n    vector<pair<int, int>> queries;\n    if (query_type == \"random\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.push_back({x, y});\n        }\n    } else if (query_type == \"same\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            queries.push_back({x, x});\n        }\n    } else if (query_type == \"opposite\") {\n        // Nodes at maximum distance\n        int x = 1;\n        int y = n;\n        for (int i = 0; i < m; ++i) {\n            queries.push_back({x, y});\n        }\n    } else if (query_type == \"fixed\") {\n        int x = rnd.next(1, n);\n        int y = rnd.next(1, n);\n        for (int i = 0; i < m; ++i) {\n            queries.push_back({x, y});\n        }\n    } else if (query_type == \"near\") {\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = x;\n            while (y == x) {\n                y = rnd.next(max(1, x - 2), min(n, x + 2));\n            }\n            queries.push_back({x, y});\n        }\n    } else {\n        // Default random queries\n        for (int i = 0; i < m; ++i) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, n);\n            queries.push_back({x, y});\n        }\n    }\n\n    // Output the queries\n    for (auto q : queries) {\n        printf(\"%d %d\\n\", q.first, q.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -tree chain -query same\n./gen -n 2 -m 1 -tree chain -query random\n./gen -n 5 -m 2 -tree star -query random\n./gen -n 10 -m 5 -tree chain -query random\n./gen -n 10 -m 5 -tree star -query random\n./gen -n 15 -m 10 -tree binary -query random\n./gen -n 20 -m 10 -tree random -query random\n./gen -n 50 -m 25 -tree random -query random\n./gen -n 100 -m 50 -tree random -query random\n./gen -n 200 -m 100 -tree random -query random\n./gen -n 500 -m 250 -tree chain -query random\n./gen -n 1000 -m 500 -tree star -query random\n./gen -n 5000 -m 1000 -tree binary -query random\n./gen -n 10000 -m 1000 -tree random -query random\n./gen -n 20000 -m 5000 -tree random -query random\n./gen -n 50000 -m 10000 -tree binary -query random\n./gen -n 100000 -m 1 -tree random -query random\n./gen -n 100000 -m 2 -tree random -query random\n./gen -n 100000 -m 100000 -tree binary -query random\n./gen -n 100000 -m 100000 -tree chain -query random\n./gen -n 100000 -m 100000 -tree star -query random\n./gen -n 100000 -m 100000 -tree random -query opposite\n./gen -n 100000 -m 100000 -tree chain -query opposite\n./gen -n 100000 -m 100000 -tree random -query same\n./gen -n 100000 -m 100000 -tree chain -query same\n./gen -n 100000 -m 100000 -tree random -query fixed\n./gen -n 100000 -m 100000 -tree binary -query near\n./gen -n 100000 -m 100000 -tree random -query near\n./gen -n 99999 -m 99999 -tree random -query random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:50.857629",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "52/A",
      "title": "A. 123-sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 106). The second line contains a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 3).",
      "output_spec": "OutputPrint the minimum number of replacements needed to be performed to make all the numbers in the sequence equal.",
      "sample_tests": "ExamplesInputCopy91 3 2 2 2 1 1 2 3OutputCopy5",
      "description": "A. 123-sequence\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 106). The second line contains a sequence of integers a1, a2, ..., an (1 ≤ ai ≤ 3).\n\nOutputPrint the minimum number of replacements needed to be performed to make all the numbers in the sequence equal.\n\nInputCopy91 3 2 2 2 1 1 2 3OutputCopy5\n\nInputCopy91 3 2 2 2 1 1 2 3\n\nOutputCopy5\n\nNoteIn the example all the numbers equal to 1 and 3 should be replaced by 2.",
      "solutions": [
        {
          "title": "Codeforces Testing Round #1 - Codeforces",
          "content": "Hello! Tired to rest? Your help is needed. During the period from December 31 until today I have made many changes in the Codeforces. The changes affected only the interior, so you will not notice any change in the user interface. Nevertheless, during this time was changed about 150 project files, database schema, some principles of data storage. In short, after all this, I'm not sure that everything works as expected (although, of course, I spent time on testing). For this reason I decided to organize Codeforces Testing Round #1, which will unrated and his only goal - a comprehensive testing of the project in conditions close to the real contest. It will be three problems (possibly well-known, folklore), but I hope it will be pleasure to solve them. Thanks for the help to Artem Rakhov, Maria Belova, and Max Ivanov MikeMirzayanov. UPD: Thanks to all. The round finished. We didn't notice any bugs. Write suggestions and opinions in the comments.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1048",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 3);\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 3);\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readEoln();\n    inf.readInts(n, 1, 3);\n    inf.readEoln();\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random sequence of numbers from 1 to 3\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 3);\n    } else if (type == \"all_same_1\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"all_same_2\") {\n        fill(a.begin(), a.end(), 2);\n    } else if (type == \"all_same_3\") {\n        fill(a.begin(), a.end(), 3);\n    } else if (type == \"two_equal_freq\") {\n        // Two numbers have equal maximum frequency\n        int freq = n / 2;\n        int idx = 0;\n        for (int i = 0; i < freq; ++i)\n            a[idx++] = 1;\n        for (int i = 0; i < freq; ++i)\n            a[idx++] = 2;\n        while (idx < n)\n            a[idx++] = 3;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"one_dominates\") {\n        // One number appears frequently\n        int dominant = rnd.next(1, 3);\n        int other1 = dominant % 3 + 1;\n        int other2 = other1 % 3 + 1;\n        int idx = 0;\n        for (int i = 0; i < n - 2; ++i)\n            a[idx++] = dominant;\n        a[idx++] = other1;\n        a[idx++] = other2;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"zig_zag\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } else if (type == \"alternating_1_3\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = ((i % 2) == 0) ? 1 : 3;\n    } else if (type == \"min_size\") {\n        a[0] = rnd.next(1, 3);\n    } else if (type == \"max_size\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 3);\n    } else if (type == \"only_1s\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"only_2s\") {\n        fill(a.begin(), a.end(), 2);\n    } else if (type == \"only_3s\") {\n        fill(a.begin(), a.end(), 3);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 3);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    \n    vector<int> a(n);\n\n    if (type == \"random\") {\n        // Random sequence of numbers from 1 to 3\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 3);\n    } else if (type == \"all_same_1\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"all_same_2\") {\n        fill(a.begin(), a.end(), 2);\n    } else if (type == \"all_same_3\") {\n        fill(a.begin(), a.end(), 3);\n    } else if (type == \"two_equal_freq\") {\n        // Two numbers have equal maximum frequency\n        int freq = n / 2;\n        int idx = 0;\n        for (int i = 0; i < freq; ++i)\n            a[idx++] = 1;\n        for (int i = 0; i < freq; ++i)\n            a[idx++] = 2;\n        while (idx < n)\n            a[idx++] = 3;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"one_dominates\") {\n        // One number appears frequently\n        int dominant = rnd.next(1, 3);\n        int other1 = dominant % 3 + 1;\n        int other2 = other1 % 3 + 1;\n        int idx = 0;\n        for (int i = 0; i < n - 2; ++i)\n            a[idx++] = dominant;\n        a[idx++] = other1;\n        a[idx++] = other2;\n        shuffle(a.begin(), a.end());\n    } else if (type == \"zig_zag\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2) + 1;\n    } else if (type == \"alternating_1_3\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = ((i % 2) == 0) ? 1 : 3;\n    } else if (type == \"min_size\") {\n        a[0] = rnd.next(1, 3);\n    } else if (type == \"max_size\") {\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 3);\n    } else if (type == \"only_1s\") {\n        fill(a.begin(), a.end(), 1);\n    } else if (type == \"only_2s\") {\n        fill(a.begin(), a.end(), 2);\n    } else if (type == \"only_3s\") {\n        fill(a.begin(), a.end(), 3);\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 3);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) printf(\" \");\n        else printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_size\n\n./gen -n 2 -type all_same_1\n./gen -n 2 -type all_same_2\n./gen -n 2 -type all_same_3\n\n./gen -n 3 -type two_equal_freq\n\n./gen -n 10 -type random\n./gen -n 10 -type all_same_1\n./gen -n 10 -type all_same_2\n./gen -n 10 -type all_same_3\n./gen -n 10 -type zig_zag\n./gen -n 10 -type alternating_1_3\n\n./gen -n 100 -type random\n./gen -n 100 -type two_equal_freq\n./gen -n 100 -type one_dominates\n./gen -n 100 -type zig_zag\n\n./gen -n 1000 -type random\n./gen -n 1000 -type one_dominates\n./gen -n 1000 -type all_same_1\n./gen -n 1000 -type all_same_2\n./gen -n 1000 -type all_same_3\n\n./gen -n 10000 -type random\n./gen -n 10000 -type two_equal_freq\n./gen -n 10000 -type one_dominates\n./gen -n 10000 -type zig_zag\n\n./gen -n 100000 -type random\n./gen -n 100000 -type one_dominates\n./gen -n 100000 -type two_equal_freq\n./gen -n 100000 -type alternating_1_3\n\n./gen -n 1000000 -type max_size\n./gen -n 1000000 -type one_dominates\n./gen -n 1000000 -type zig_zag\n\n./gen -n 1000000 -type only_1s\n./gen -n 1000000 -type only_2s\n./gen -n 1000000 -type only_3s\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:52.541594",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "52/B",
      "title": "B. Right Triangles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two positive integer numbers n and m (1 ≤ n, m ≤ 1000). The following n lines consist of m characters each, describing the field. Only '.' and '*' are allowed.",
      "output_spec": "OutputOutput a single number — total number of square triangles in the field. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy2 2***.OutputCopy1InputCopy3 4*..*.**.*.**OutputCopy9",
      "description": "B. Right Triangles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two positive integer numbers n and m (1 ≤ n, m ≤ 1000). The following n lines consist of m characters each, describing the field. Only '.' and '*' are allowed.\n\nOutputOutput a single number — total number of square triangles in the field. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n\nInputCopy2 2***.OutputCopy1InputCopy3 4*..*.**.*.**OutputCopy9\n\nInputCopy2 2***.\n\nOutputCopy1\n\nInputCopy3 4*..*.**.*.**\n\nOutputCopy9",
      "solutions": [
        {
          "title": "Codeforces Testing Round #1 - Codeforces",
          "content": "Hello! Tired to rest? Your help is needed. During the period from December 31 until today I have made many changes in the Codeforces. The changes affected only the interior, so you will not notice any change in the user interface. Nevertheless, during this time was changed about 150 project files, database schema, some principles of data storage. In short, after all this, I'm not sure that everything works as expected (although, of course, I spent time on testing). For this reason I decided to organize Codeforces Testing Round #1, which will unrated and his only goal - a comprehensive testing of the project in conditions close to the real contest. It will be three problems (possibly well-known, folklore), but I hope it will be pleasure to solve them. Thanks for the help to Artem Rakhov, Maria Belova, and Max Ivanov MikeMirzayanov. UPD: Thanks to all. The round finished. We didn't notice any bugs. Write suggestions and opinions in the comments.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1048",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d length should be %d, but read %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at line %d, column %d\", s[j], i + 1, j + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d length should be %d, but read %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at line %d, column %d\", s[j], i + 1, j + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 1000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        string s = inf.readLine();\n        ensuref(int(s.length()) == m, \"Line %d length should be %d, but read %d\", i + 1, m, int(s.length()));\n        for (int j = 0; j < m; ++j) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at line %d, column %d\", s[j], i + 1, j + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // Default density is 0.5\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next() < density)\n                    grid[i][j] = '*';\n    } else if (type == \"full\") {\n        // Fill the grid with '*'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n    } else if (type == \"empty\") {\n        // Grid is already initialized with '.'\n    } else if (type == \"row\") {\n        // Fill a specific row with '*'\n        int row = opt<int>(\"row\", rnd.next(0, n - 1));\n        grid[row] = string(m, '*');\n    } else if (type == \"column\") {\n        // Fill a specific column with '*'\n        int col = opt<int>(\"col\", rnd.next(0, m - 1));\n        for (int i = 0; i < n; ++i)\n            grid[i][col] = '*';\n    } else if (type == \"diagonal\") {\n        // Fill the main diagonal with '*'\n        for (int i = 0; i < min(n, m); ++i)\n            grid[i][i] = '*';\n    } else if (type == \"block\") {\n        // Create a block of '*' within the grid\n        int h = opt<int>(\"h\", n);\n        int w = opt<int>(\"w\", m);\n        int r0 = opt<int>(\"r0\", (n - h) / 2);\n        int c0 = opt<int>(\"c0\", (m - w) / 2);\n        for (int i = 0; i < h; ++i)\n            if (0 <= r0 + i && r0 + i < n)\n                for (int j = 0; j < w; ++j)\n                    if (0 <= c0 + j && c0 + j < m)\n                        grid[r0 + i][c0 + j] = '*';\n    } else if (type == \"checkerboard\") {\n        // Fill the grid in a checkerboard pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = '*';\n    } else if (type == \"single\") {\n        // Place a single '*' at a random position\n        int r = opt<int>(\"r\", rnd.next(0, n - 1));\n        int c = opt<int>(\"c\", rnd.next(0, m - 1));\n        grid[r][c] = '*';\n    } else {\n        // Default to a random grid if type is unknown\n        double density = opt<double>(\"density\", 0.5);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next() < density)\n                    grid[i][j] = '*';\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"random\") {\n        double density = opt<double>(\"density\", 0.5); // Default density is 0.5\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next() < density)\n                    grid[i][j] = '*';\n    } else if (type == \"full\") {\n        // Fill the grid with '*'\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n    } else if (type == \"empty\") {\n        // Grid is already initialized with '.'\n    } else if (type == \"row\") {\n        // Fill a specific row with '*'\n        int row = opt<int>(\"row\", rnd.next(0, n - 1));\n        grid[row] = string(m, '*');\n    } else if (type == \"column\") {\n        // Fill a specific column with '*'\n        int col = opt<int>(\"col\", rnd.next(0, m - 1));\n        for (int i = 0; i < n; ++i)\n            grid[i][col] = '*';\n    } else if (type == \"diagonal\") {\n        // Fill the main diagonal with '*'\n        for (int i = 0; i < min(n, m); ++i)\n            grid[i][i] = '*';\n    } else if (type == \"block\") {\n        // Create a block of '*' within the grid\n        int h = opt<int>(\"h\", n);\n        int w = opt<int>(\"w\", m);\n        int r0 = opt<int>(\"r0\", (n - h) / 2);\n        int c0 = opt<int>(\"c0\", (m - w) / 2);\n        for (int i = 0; i < h; ++i)\n            if (0 <= r0 + i && r0 + i < n)\n                for (int j = 0; j < w; ++j)\n                    if (0 <= c0 + j && c0 + j < m)\n                        grid[r0 + i][c0 + j] = '*';\n    } else if (type == \"checkerboard\") {\n        // Fill the grid in a checkerboard pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i + j) % 2 == 0)\n                    grid[i][j] = '*';\n    } else if (type == \"single\") {\n        // Place a single '*' at a random position\n        int r = opt<int>(\"r\", rnd.next(0, n - 1));\n        int c = opt<int>(\"c\", rnd.next(0, m - 1));\n        grid[r][c] = '*';\n    } else {\n        // Default to a random grid if type is unknown\n        double density = opt<double>(\"density\", 0.5);\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if (rnd.next() < density)\n                    grid[i][j] = '*';\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i)\n        printf(\"%s\\n\", grid[i].c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small grids with minimal sizes\n./gen -n 1 -m 1 -type empty\n./gen -n 1 -m 1 -type full\n./gen -n 2 -m 2 -type full\n./gen -n 2 -m 2 -type empty\n./gen -n 2 -m 2 -type checkerboard\n./gen -n 2 -m 2 -type diagonal\n./gen -n 2 -m 3 -type random -density 0.5\n\n# Grid with only one '*'\n./gen -n 5 -m 5 -type single\n\n# Grids with a single row of '*'\n./gen -n 10 -m 10 -type row -row 5\n\n# Grids with a single column of '*'\n./gen -n 10 -m 10 -type column -col 4\n\n# Grids with maximal sizes filled with '*'\n./gen -n 1000 -m 1000 -type full\n\n# Grids with maximal sizes filled with '.'\n./gen -n 1000 -m 1000 -type empty\n\n# Random grids with low density of '*'\n./gen -n 1000 -m 1000 -type random -density 0.01\n\n# Random grids with high density of '*'\n./gen -n 1000 -m 1000 -type random -density 0.99\n\n# Random grids with medium density of '*'\n./gen -n 1000 -m 1000 -type random -density 0.5\n\n# Checkerboard pattern grids\n./gen -n 999 -m 1000 -type checkerboard\n./gen -n 1000 -m 998 -type checkerboard\n\n# Grids with a block of '*' in the center\n./gen -n 1000 -m 1000 -type block -h 500 -w 500\n\n# Grids with a block of '*' covering almost the whole grid\n./gen -n 1000 -m 1000 -type block -h 999 -w 999\n\n# Grids with '*' along the diagonal\n./gen -n 1000 -m 1000 -type diagonal\n\n# Random grids with custom densities\n./gen -n 500 -m 500 -type random -density 0.25\n./gen -n 500 -m 500 -type random -density 0.75\n\n# Grids with a single row\n./gen -n 1 -m 1000 -type random -density 0.5\n\n# Grids with a single column\n./gen -n 1000 -m 1 -type random -density 0.5\n\n# Edge cases with maximal sizes\n./gen -n 1 -m 1000 -type full\n./gen -n 1000 -m 1 -type empty\n\n# Grid with maximal size and a single '*'\n./gen -n 1000 -m 1000 -type single\n\n# Small grids with random patterns\n./gen -n 3 -m 4 -type random -density 0.5\n\n# Grids with specific sizes and densities\n./gen -n 999 -m 999 -type random -density 0.33\n\n# Random grids with default settings (density = 0.5)\n./gen -n 1000 -m 1000\n\n# Grids with a horizontal line of '*'\n./gen -n 1000 -m 1000 -type block -h 1 -w 1000\n\n# Grids with a vertical line of '*'\n./gen -n 1000 -m 1000 -type block -h 1000 -w 1\n\n# Grids with '*' in the first row\n./gen -n 500 -m 500 -type row -row 0\n\n# Grids with '*' in the last column\n./gen -n 500 -m 500 -type column -col 499\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:54.710242",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "52/C",
      "title": "C. Circular RMQ",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1.5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 200000). The next line contains initial state of the array: a0, a1, ..., an - 1 ( - 106 ≤ ai ≤ 106), ai are integer. The third line contains integer m (0 ≤ m ≤ 200000), m — the number of operartons. Next m lines contain one operation each. If line contains two integer lf, rg (0 ≤ lf, rg ≤ n - 1) it means rmq operation, it contains three integers lf, rg, v (0 ≤ lf, rg ≤ n - 1; - 106 ≤ v ≤ 106) — inc operation.",
      "output_spec": "OutputFor each rmq operation write result for it. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).",
      "sample_tests": "ExamplesInputCopy41 2 3 443 03 0 -10 12 1OutputCopy100",
      "description": "C. Circular RMQ\n\ntime limit per test1.5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains integer n (1 ≤ n ≤ 200000). The next line contains initial state of the array: a0, a1, ..., an - 1 ( - 106 ≤ ai ≤ 106), ai are integer. The third line contains integer m (0 ≤ m ≤ 200000), m — the number of operartons. Next m lines contain one operation each. If line contains two integer lf, rg (0 ≤ lf, rg ≤ n - 1) it means rmq operation, it contains three integers lf, rg, v (0 ≤ lf, rg ≤ n - 1; - 106 ≤ v ≤ 106) — inc operation.\n\nOutputFor each rmq operation write result for it. Please, do not use %lld specificator to read or write 64-bit integers in C++. It is preffered to use cout (also you may use %I64d).\n\nInputCopy41 2 3 443 03 0 -10 12 1OutputCopy100\n\nInputCopy41 2 3 443 03 0 -10 12 1\n\nOutputCopy100",
      "solutions": [
        {
          "title": "Codeforces Testing Round #1 - Codeforces",
          "content": "Hello! Tired to rest? Your help is needed. During the period from December 31 until today I have made many changes in the Codeforces. The changes affected only the interior, so you will not notice any change in the user interface. Nevertheless, during this time was changed about 150 project files, database schema, some principles of data storage. In short, after all this, I'm not sure that everything works as expected (although, of course, I spent time on testing). For this reason I decided to organize Codeforces Testing Round #1, which will unrated and his only goal - a comprehensive testing of the project in conditions close to the real contest. It will be three problems (possibly well-known, folklore), but I hope it will be pleasure to solve them. Thanks for the help to Artem Rakhov, Maria Belova, and Max Ivanov MikeMirzayanov. UPD: Thanks to all. The round finished. We didn't notice any bugs. Write suggestions and opinions in the comments.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1048",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 957
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint parseIntInRange(const string& s, int minValue, int maxValue, const string& varname) {\n    if (s.empty()) {\n        ensuref(false, \"Expected integer for %s but got empty string\", varname.c_str());\n    }\n    size_t i = 0;\n    if (s[0] == '-') {\n        if (s.size() == 1) {\n            ensuref(false, \"Expected integer for %s but got '-'\", varname.c_str());\n        }\n        i = 1;\n    }\n    for (; i < s.size(); ++i) {\n        ensuref(isdigit(s[i]), \"Expected integer for %s but got invalid character '%c'\", varname.c_str(), s[i]);\n    }\n    long long value = 0;\n    try {\n        value = stoll(s);\n    } catch (exception& e) {\n        ensuref(false, \"Expected integer for %s but got invalid number '%s'\", varname.c_str(), s.c_str());\n    }\n    ensuref(value >= minValue && value <= maxValue, \"Value of %s (%lld) is not in range [%d, %d]\", varname.c_str(), value, minValue, maxValue);\n    return (int)value;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000, 1000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine();\n\n        istringstream iss(s);\n        vector<string> tokens;\n        string tok;\n        while (iss >> tok) {\n            tokens.push_back(tok);\n        }\n\n        ensuref(tokens.size() == 2 || tokens.size() == 3, \"Operation line %d has incorrect number of tokens: %d\", i + 1, (int)tokens.size());\n\n        int lf = parseIntInRange(tokens[0], 0, n - 1, \"lf\");\n        int rg = parseIntInRange(tokens[1], 0, n - 1, \"rg\");\n\n        if (tokens.size() == 2) {\n            // rmq operation\n            // Do nothing\n        } else {\n            int v = parseIntInRange(tokens[2], -1000000, 1000000, \"v\");\n            // inc operation\n            // Do nothing\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint parseIntInRange(const string& s, int minValue, int maxValue, const string& varname) {\n    if (s.empty()) {\n        ensuref(false, \"Expected integer for %s but got empty string\", varname.c_str());\n    }\n    size_t i = 0;\n    if (s[0] == '-') {\n        if (s.size() == 1) {\n            ensuref(false, \"Expected integer for %s but got '-'\", varname.c_str());\n        }\n        i = 1;\n    }\n    for (; i < s.size(); ++i) {\n        ensuref(isdigit(s[i]), \"Expected integer for %s but got invalid character '%c'\", varname.c_str(), s[i]);\n    }\n    long long value = 0;\n    try {\n        value = stoll(s);\n    } catch (exception& e) {\n        ensuref(false, \"Expected integer for %s but got invalid number '%s'\", varname.c_str(), s.c_str());\n    }\n    ensuref(value >= minValue && value <= maxValue, \"Value of %s (%lld) is not in range [%d, %d]\", varname.c_str(), value, minValue, maxValue);\n    return (int)value;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000, 1000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine();\n\n        istringstream iss(s);\n        vector<string> tokens;\n        string tok;\n        while (iss >> tok) {\n            tokens.push_back(tok);\n        }\n\n        ensuref(tokens.size() == 2 || tokens.size() == 3, \"Operation line %d has incorrect number of tokens: %d\", i + 1, (int)tokens.size());\n\n        int lf = parseIntInRange(tokens[0], 0, n - 1, \"lf\");\n        int rg = parseIntInRange(tokens[1], 0, n - 1, \"rg\");\n\n        if (tokens.size() == 2) {\n            // rmq operation\n            // Do nothing\n        } else {\n            int v = parseIntInRange(tokens[2], -1000000, 1000000, \"v\");\n            // inc operation\n            // Do nothing\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint parseIntInRange(const string& s, int minValue, int maxValue, const string& varname) {\n    if (s.empty()) {\n        ensuref(false, \"Expected integer for %s but got empty string\", varname.c_str());\n    }\n    size_t i = 0;\n    if (s[0] == '-') {\n        if (s.size() == 1) {\n            ensuref(false, \"Expected integer for %s but got '-'\", varname.c_str());\n        }\n        i = 1;\n    }\n    for (; i < s.size(); ++i) {\n        ensuref(isdigit(s[i]), \"Expected integer for %s but got invalid character '%c'\", varname.c_str(), s[i]);\n    }\n    long long value = 0;\n    try {\n        value = stoll(s);\n    } catch (exception& e) {\n        ensuref(false, \"Expected integer for %s but got invalid number '%s'\", varname.c_str(), s.c_str());\n    }\n    ensuref(value >= minValue && value <= maxValue, \"Value of %s (%lld) is not in range [%d, %d]\", varname.c_str(), value, minValue, maxValue);\n    return (int)value;\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, -1000000, 1000000, \"a_i\");\n    inf.readEoln();\n\n    int m = inf.readInt(0, 200000, \"m\");\n    inf.readEoln();\n\n    for (int i = 0; i < m; ++i) {\n        string s = inf.readLine();\n\n        istringstream iss(s);\n        vector<string> tokens;\n        string tok;\n        while (iss >> tok) {\n            tokens.push_back(tok);\n        }\n\n        ensuref(tokens.size() == 2 || tokens.size() == 3, \"Operation line %d has incorrect number of tokens: %d\", i + 1, (int)tokens.size());\n\n        int lf = parseIntInRange(tokens[0], 0, n - 1, \"lf\");\n        int rg = parseIntInRange(tokens[1], 0, n - 1, \"rg\");\n\n        if (tokens.size() == 2) {\n            // rmq operation\n            // Do nothing\n        } else {\n            int v = parseIntInRange(tokens[2], -1000000, 1000000, \"v\");\n            // inc operation\n            // Do nothing\n        }\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case of the circular array problem with\n  \"inc\" and \"rmq\" operations. The parameters are:\n\n    -n <int>       : number of elements in the array (1 <= n <= 200000)\n    -m <int>       : number of operations (0 <= m <= 200000)\n    -type <string> : type of test to generate, default = \"random\"\n\n  Possible types (feel free to add more if you wish):\n    1) \"random\"     : random array, random mix of wrap / non-wrap updates & queries\n    2) \"onlyinc\"    : random array, all operations are inc\n    3) \"onlyquery\"  : random array, all operations are rmq\n    4) \"wrap\"       : random array, all operations have lf > rg (thus wrapping)\n    5) \"allzero\"    : array of all zeros, random operations\n    6) \"allpos\"     : array of only positive values, random operations\n    7) \"allneg\"     : array of only negative values, random operations\n    8) \"sorted\"     : array sorted ascending, random operations\n    9) \"reverse\"    : array sorted descending, random operations\n\n  NOTE:\n  - We do NOT set any random seed here; testlib handles that internally.\n  - We use testlib's rnd for random numbers, not the C++ std random generator.\n  - No redirection (\">\") is needed in this solution. We simply print to stdout.\n*/\n\nstatic const int MIN_VAL = -1000000;\nstatic const int MAX_VAL =  1000000;\n\n// Helper to generate a random integer in [L, R].\nint getRandomInt(int L, int R) {\n    return rnd.next(L, R);\n}\n\n// Generate the array, depending on \"type\".\nvector<int> generateArray(int n, const string &type) {\n    vector<int> arr(n, 0);\n\n    if (type == \"allzero\") {\n        // All zeros\n        // arr is already zero-initialized\n    }\n    else if (type == \"allpos\") {\n        // All positive, random in [1, MAX_VAL]\n        for (int i = 0; i < n; i++) {\n            arr[i] = getRandomInt(1, MAX_VAL);\n        }\n    }\n    else if (type == \"allneg\") {\n        // All negative, random in [MIN_VAL, -1]\n        for (int i = 0; i < n; i++) {\n            arr[i] = getRandomInt(MIN_VAL, -1);\n        }\n    }\n    else if (type == \"sorted\") {\n        // Sorted ascending from MIN_VAL..MAX_VAL or smaller range\n        // We'll pick random range boundaries and fill ascending\n        int start = getRandomInt(-50000, 0);\n        int step  = getRandomInt(1, 10); \n        for (int i = 0; i < n; i++) {\n            arr[i] = start + i * step;\n            if (arr[i] > MAX_VAL) arr[i] = MAX_VAL; // clamp\n        }\n    }\n    else if (type == \"reverse\") {\n        // Sorted descending\n        int start = getRandomInt(0, 50000);\n        int step  = getRandomInt(1, 10);\n        for (int i = 0; i < n; i++) {\n            arr[i] = start - i * step;\n            if (arr[i] < MIN_VAL) arr[i] = MIN_VAL; // clamp\n        }\n    }\n    else {\n        // \"random\", \"onlyinc\", \"onlyquery\", \"wrap\", or anything else\n        // => fill with random values in [MIN_VAL, MAX_VAL].\n        for (int i = 0; i < n; i++) {\n            arr[i] = getRandomInt(MIN_VAL, MAX_VAL);\n        }\n    }\n\n    return arr;\n}\n\n// Print inc operation: \"lf rg v\"\nvoid printInc(int lf, int rg, int v) {\n    // inc(lf, rg, v) => 3 integers\n    printf(\"%d %d %d\\n\", lf, rg, v);\n}\n\n// Print rmq operation: \"lf rg\"\nvoid printRmq(int lf, int rg) {\n    // rmq(lf, rg) => 2 integers\n    printf(\"%d %d\\n\", lf, rg);\n}\n\nint main(int argc, char* argv[]) {\n    // Register the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate the array\n    vector<int> arr = generateArray(n, type);\n\n    // Print n\n    printf(\"%d\\n\", n);\n\n    // Print the array in one line\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", arr[i], (i + 1 < n) ? ' ' : '\\n');\n    }\n\n    // Print m\n    printf(\"%d\\n\", m);\n\n    // Generate operations\n    // For \"onlyinc\": all inc\n    // For \"onlyquery\": all rmq\n    // For \"wrap\": always lf > rg\n    // Otherwise: random mixture\n    if (type == \"onlyinc\") {\n        // All inc\n        for (int i = 0; i < m; i++) {\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n            int v  = getRandomInt(MIN_VAL, MAX_VAL);\n            printInc(lf, rg, v);\n        }\n    }\n    else if (type == \"onlyquery\") {\n        // All rmq\n        for (int i = 0; i < m; i++) {\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n            printRmq(lf, rg);\n        }\n    }\n    else if (type == \"wrap\") {\n        // Always lf > rg => wrap around\n        // random inc or query with equal probability\n        for (int i = 0; i < m; i++) {\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n            // force lf > rg if they are equal or less, swap them\n            if (lf <= rg) {\n                int tmp = lf;\n                lf = rg;\n                rg = tmp;\n            }\n            // choose inc or rmq\n            if (rnd.next(2) == 0) {\n                // inc\n                int v = getRandomInt(MIN_VAL, MAX_VAL);\n                printInc(lf, rg, v);\n            } else {\n                // rmq\n                printRmq(lf, rg);\n            }\n        }\n    }\n    else {\n        // \"random\", \"allzero\", \"allpos\", \"allneg\", \"sorted\", \"reverse\", etc.\n        // random inc / query, random wrap or not\n        for (int i = 0; i < m; i++) {\n            bool doInc = (rnd.next(2) == 0); // 50-50 inc vs. query\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n\n            // 50% chance we ensure wrap, 50% chance we ensure non-wrap\n            // to thoroughly test solutions\n            if (rnd.next(2) == 0) {\n                // might swap to enforce lf <= rg\n                if (lf > rg) std::swap(lf, rg);\n            } else {\n                // might swap to enforce lf > rg\n                if (lf <= rg) std::swap(lf, rg);\n            }\n\n            if (doInc) {\n                int v = getRandomInt(MIN_VAL, MAX_VAL);\n                printInc(lf, rg, v);\n            } else {\n                printRmq(lf, rg);\n            }\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single test case of the circular array problem with\n  \"inc\" and \"rmq\" operations. The parameters are:\n\n    -n <int>       : number of elements in the array (1 <= n <= 200000)\n    -m <int>       : number of operations (0 <= m <= 200000)\n    -type <string> : type of test to generate, default = \"random\"\n\n  Possible types (feel free to add more if you wish):\n    1) \"random\"     : random array, random mix of wrap / non-wrap updates & queries\n    2) \"onlyinc\"    : random array, all operations are inc\n    3) \"onlyquery\"  : random array, all operations are rmq\n    4) \"wrap\"       : random array, all operations have lf > rg (thus wrapping)\n    5) \"allzero\"    : array of all zeros, random operations\n    6) \"allpos\"     : array of only positive values, random operations\n    7) \"allneg\"     : array of only negative values, random operations\n    8) \"sorted\"     : array sorted ascending, random operations\n    9) \"reverse\"    : array sorted descending, random operations\n\n  NOTE:\n  - We do NOT set any random seed here; testlib handles that internally.\n  - We use testlib's rnd for random numbers, not the C++ std random generator.\n  - No redirection (\">\") is needed in this solution. We simply print to stdout.\n*/\n\nstatic const int MIN_VAL = -1000000;\nstatic const int MAX_VAL =  1000000;\n\n// Helper to generate a random integer in [L, R].\nint getRandomInt(int L, int R) {\n    return rnd.next(L, R);\n}\n\n// Generate the array, depending on \"type\".\nvector<int> generateArray(int n, const string &type) {\n    vector<int> arr(n, 0);\n\n    if (type == \"allzero\") {\n        // All zeros\n        // arr is already zero-initialized\n    }\n    else if (type == \"allpos\") {\n        // All positive, random in [1, MAX_VAL]\n        for (int i = 0; i < n; i++) {\n            arr[i] = getRandomInt(1, MAX_VAL);\n        }\n    }\n    else if (type == \"allneg\") {\n        // All negative, random in [MIN_VAL, -1]\n        for (int i = 0; i < n; i++) {\n            arr[i] = getRandomInt(MIN_VAL, -1);\n        }\n    }\n    else if (type == \"sorted\") {\n        // Sorted ascending from MIN_VAL..MAX_VAL or smaller range\n        // We'll pick random range boundaries and fill ascending\n        int start = getRandomInt(-50000, 0);\n        int step  = getRandomInt(1, 10); \n        for (int i = 0; i < n; i++) {\n            arr[i] = start + i * step;\n            if (arr[i] > MAX_VAL) arr[i] = MAX_VAL; // clamp\n        }\n    }\n    else if (type == \"reverse\") {\n        // Sorted descending\n        int start = getRandomInt(0, 50000);\n        int step  = getRandomInt(1, 10);\n        for (int i = 0; i < n; i++) {\n            arr[i] = start - i * step;\n            if (arr[i] < MIN_VAL) arr[i] = MIN_VAL; // clamp\n        }\n    }\n    else {\n        // \"random\", \"onlyinc\", \"onlyquery\", \"wrap\", or anything else\n        // => fill with random values in [MIN_VAL, MAX_VAL].\n        for (int i = 0; i < n; i++) {\n            arr[i] = getRandomInt(MIN_VAL, MAX_VAL);\n        }\n    }\n\n    return arr;\n}\n\n// Print inc operation: \"lf rg v\"\nvoid printInc(int lf, int rg, int v) {\n    // inc(lf, rg, v) => 3 integers\n    printf(\"%d %d %d\\n\", lf, rg, v);\n}\n\n// Print rmq operation: \"lf rg\"\nvoid printRmq(int lf, int rg) {\n    // rmq(lf, rg) => 2 integers\n    printf(\"%d %d\\n\", lf, rg);\n}\n\nint main(int argc, char* argv[]) {\n    // Register the generator\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Generate the array\n    vector<int> arr = generateArray(n, type);\n\n    // Print n\n    printf(\"%d\\n\", n);\n\n    // Print the array in one line\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", arr[i], (i + 1 < n) ? ' ' : '\\n');\n    }\n\n    // Print m\n    printf(\"%d\\n\", m);\n\n    // Generate operations\n    // For \"onlyinc\": all inc\n    // For \"onlyquery\": all rmq\n    // For \"wrap\": always lf > rg\n    // Otherwise: random mixture\n    if (type == \"onlyinc\") {\n        // All inc\n        for (int i = 0; i < m; i++) {\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n            int v  = getRandomInt(MIN_VAL, MAX_VAL);\n            printInc(lf, rg, v);\n        }\n    }\n    else if (type == \"onlyquery\") {\n        // All rmq\n        for (int i = 0; i < m; i++) {\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n            printRmq(lf, rg);\n        }\n    }\n    else if (type == \"wrap\") {\n        // Always lf > rg => wrap around\n        // random inc or query with equal probability\n        for (int i = 0; i < m; i++) {\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n            // force lf > rg if they are equal or less, swap them\n            if (lf <= rg) {\n                int tmp = lf;\n                lf = rg;\n                rg = tmp;\n            }\n            // choose inc or rmq\n            if (rnd.next(2) == 0) {\n                // inc\n                int v = getRandomInt(MIN_VAL, MAX_VAL);\n                printInc(lf, rg, v);\n            } else {\n                // rmq\n                printRmq(lf, rg);\n            }\n        }\n    }\n    else {\n        // \"random\", \"allzero\", \"allpos\", \"allneg\", \"sorted\", \"reverse\", etc.\n        // random inc / query, random wrap or not\n        for (int i = 0; i < m; i++) {\n            bool doInc = (rnd.next(2) == 0); // 50-50 inc vs. query\n            int lf = getRandomInt(0, n - 1);\n            int rg = getRandomInt(0, n - 1);\n\n            // 50% chance we ensure wrap, 50% chance we ensure non-wrap\n            // to thoroughly test solutions\n            if (rnd.next(2) == 0) {\n                // might swap to enforce lf <= rg\n                if (lf > rg) std::swap(lf, rg);\n            } else {\n                // might swap to enforce lf > rg\n                if (lf <= rg) std::swap(lf, rg);\n            }\n\n            if (doInc) {\n                int v = getRandomInt(MIN_VAL, MAX_VAL);\n                printInc(lf, rg, v);\n            } else {\n                printRmq(lf, rg);\n            }\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are various examples of how to run the generator with different parameters.\n# Each command prints exactly ONE test case to stdout. No redirection is shown here.\n\n# 1) Very small n and m, random\n./gen -n 1 -m 0 -type random\n./gen -n 1 -m 5 -type random\n./gen -n 5 -m 5 -type random\n\n# 2) Only inc operations, small to moderate\n./gen -n 5 -m 5 -type onlyinc\n./gen -n 10 -m 10 -type onlyinc\n./gen -n 100 -m 50 -type onlyinc\n\n# 3) Only query operations, small to moderate\n./gen -n 5 -m 5 -type onlyquery\n./gen -n 10 -m 20 -type onlyquery\n./gen -n 100 -m 100 -type onlyquery\n\n# 4) Wrap-only operations\n./gen -n 5 -m 5 -type wrap\n./gen -n 10 -m 10 -type wrap\n./gen -n 100 -m 100 -type wrap\n\n# 5) Special arrays: all-zero, all-pos, all-neg\n./gen -n 5 -m 5 -type allzero\n./gen -n 5 -m 5 -type allpos\n./gen -n 5 -m 5 -type allneg\n\n# 6) Sorted and reversed arrays\n./gen -n 10 -m 5 -type sorted\n./gen -n 10 -m 5 -type reverse\n\n# 7) Larger random tests\n./gen -n 1000 -m 1000 -type random\n./gen -n 20000 -m 20000 -type random\n./gen -n 100000 -m 100000 -type random\n\n# 8) Even larger (maximum constraints)\n./gen -n 200000 -m 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:56.639694",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "520/A",
      "title": "A. Pangram",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of characters in the string.The second line contains the string. The string consists only of uppercase and lowercase Latin letters.",
      "output_spec": "OutputOutput \"YES\", if the string is a pangram and \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopy12toosmallwordOutputCopyNOInputCopy35TheQuickBrownFoxJumpsOverTheLazyDogOutputCopyYES",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number of characters in the string.The second line contains the string. The string consists only of uppercase and lowercase Latin letters.\n\nOutputOutput \"YES\", if the string is a pangram and \"NO\" otherwise.\n\nInputCopy12toosmallwordOutputCopyNOInputCopy35TheQuickBrownFoxJumpsOverTheLazyDogOutputCopyYES\n\nInputCopy12toosmallword\n\nOutputCopyNO\n\nInputCopy35TheQuickBrownFoxJumpsOverTheLazyDog\n\nOutputCopyYES",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Hello, Codeforces!On March, 2nd at 10:00 MSK Codeforces Round #295 will be held in both divisions.The round will be held at the same time with Winter Computer Camp olympiad, the problemsets will be highly similar. The problems are by me (Endagorion) and Evgeny Savinov (savinov). The problems are prepared by members of the Winter Computer Camp technical committee: Georgy Chebanov (gchebanov), Filipp Rukhovich (DPR-pavlin), Alexander Mashrabov (map), Sergey Kiyan (sokian), Konstantin Semenov (zemen), Kinan Alsarmini (Sarkin).Big thanks to Max Akhmedov (Zlobober) for his help with preparing the problems, Maria Belova (Delinur) for translating the statements in English, and Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon systems.The scoring is standard for both divisions: 500-1000-1500-2000-2500.Please note that the Winter Computing Camp olympiad is scheduled to finish later than the Codeforces round. Thus, we ask you not to discuss the problems and solutions in the comments until 14:10 MSK. Also, viewing of other participants' solutions will be closed until that time. The editorial will also be published later.UPD: you are free to discuss the problems now.UPD2: the editorial is finally up! Sorry for the delay.Also, grats to our Div.1 winners: Petr hos.lyric Syloviaely andrew.volchek xyz111 Special respect goes to Petr and rng_58 for solving the hardest problem E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1403
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces",
          "content": "We would like to thank the testers of this round's and Winter Computer Camp olympiad's problems: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Make sure to comment if you find any mistakes.UPD: I've just remembered to put up the usual challenges for the problems. So, here they go.520A - PangramIdea: EndagorionPreparation: EndagorionTo check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE. In the end check that there are 26 TRUEs. That is an O(n) solution. Also don't forget to change all letters to lowercase (or all to uppercase). To make all the letters lowercase, one could use standard functions, like tolower in Python. Also, it is known that the letters from a to z have consecutive ASCII numbers, as well as A to Z; an ASCII number of symbol is ord(c) in most languages. So, to get the number of a lowercase letter in the alphabet one can use ord(c) - ord('a') in most languages, or simply c - 'a' in C++ or C (because a char in C/C++ can be treated as a number); to check if a letter is lowercase, the inequality ord('a') <= ord(c) && ord(c) <= ord('z') should be checked.Challenge: how many pangrams of length n are there? Strings that differ only in capitalization of some letters are considered distinct. Can you find the answer modulo some prime p in linear time?520B - Two ButtonsIdea: EndagorionPreparation: EndagorionThe simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2·104 vertices and 4·104 edges, and the BFS should work real fast.There is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".Suppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in .Challenge: suppose we have a generalized problem: we want to get n starting from m using two operations \"subtract a\" and \"multiply by b\". Generalize the solution to find the minimal number of moves to get from n to m in time if a and b are coprime. Can you do it if a and b may have common divisors greater than 1?520C - DNA Alignment/521A - DNA AlignmentIdea: EndagorionPreparation: EndagorionWhat is ρ(s, t) equal to? For every character of s and every character of t there is a unique cyclic shift of t that superposes these characters (indeed, after 0, ..., n - 1 shifts the character in t occupies different positions, and one of them matches the one of the character of s); therefore, there exist n cyclic shifts of s and t that superpose these characters (the situation is symmetrical for every position of the character of s). It follows that the input in ρ from a single character ti is equal to n × (the number of characters in s equal to ti). Therefore, ρ(s, t) is maximal when every character of t occurs the maximal possible number of times in s. Simply count the number of occurences for every type of characters; the answer is Kn, where K is the number of character types that occur in s most frequently. This is an O(n) solution.Challenge: we know that ρmax(s) = n2·C(s), where C(s) is the maximal number that any character occurs in s. How many strings s of length n with characters from an alphabet of size k have C(s) = m? Can you find an O(kn2) solution? An solution? An solution? Maybe even better? (Hint: the modulo should be an appropriately chosen prime number for a fast solution =)).520D - Cubes/521B - CubesIdea: savinovPreparation: savinov, sokian, zemenBasically, the first player should maximize the lexicographical order of numbers, and the second player should minimize it. Thus, at every move the first player should choose the largest available number, and the second should choose the minimal one.First of all, how do we check if the cube can be removed? It is impossible only if there is some cube \"supported\" by it (i.e., it has coordinates (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)) such that our cube is the only one supporting it. This can be checked explicitly. The large coordinates' limitations do not allow us to store a simply array for that, so we should use an associative array, like a set in C++.Now we should find the maximal/minimal number that can be removed. A simple linear search won't work fast enough, so we store another data structure containing all numbers available to remove; the structure should allow inserting, erasing and finding global minimum/maximum, so the set C++ structure fits again.When we've made our move, some cubes may have become available or unavailable to remove. However, there is an O(1) amount of cubes we have to recheck and possibly insert/erase from our structure: the cubes (x ± 1, y) and (x ± 2, y) may have become unavailable because some higher cube has become dangerous (that is, there is a single cube supporting it), and some of the cubes (x - 1, y - 1), (x, y - 1) and (x + 1, y - 1) may have become available because our cube was the only dangerous cube that it has been supporting. Anyway, a simple recheck for these cubes will handle all the cases.This solution is if using the appropriate data structure.Challenge (inspired by questions from jk_qq and RetiredAmrMahmoud): suppose that the players put the numbers from right to left, that is, from the least significant digit to the most significant. The first player still wants to maximize the resulting number, and the second wants to minimize it. If the original rules of taking cubes apply, finding the optimal strategy for the players seems intractable. Try to solve this problem in the case where all the cubes are stacked in several independent towers; that is, a cube may only be taken from the top of any tower.520E - Pluses everywhere/521C - Pluses everywhereIdea: EndagorionPreparation: gchebanov, DPR-pavlinConsider some way of placing all the pluses, and a single digit di (digits in the string are numbered starting from 0 from left to right). This digit gives input of di·10l to the total sum, where l is the distance to the nearest plus from the right, or to the end of string if there are no pluses there. If we sum up these quantities for all digits and all ways of placing the pluses, we will obtain the answer.For a given digit di and some fixed l, how many ways are there to place the pluses? First of all, consider the case when the part containing the digit di is not last, that is, i + l < n - 1. There are n - 1 gaps to place pluses in total; the constraint about di and the distance l means that after digits di, ..., di + l - 1 there are no pluses, while after the digit di + l there should be a plus. That is, the string should look as follows: Here a dot means a gap without a plus, and a question mark means that it's not important whether there is a plus or not. So, out of n - 1 possible gaps there are l + 1 gaps which states are defined, and there is one plus used in these gaps. That means that the other (n - 1) - (l + 1) = n - l - 2 gaps may contain k - 1 pluses in any possible way; that is, the number of such placements is . A similar reasoning implies that if the digit di is in the last part, that is, i + l = n - 1, the number of placements is .To sum up, the total answer is equal to Let us transform the sum: To compute these sums, we will need to know all powers of 10 up to n-th (modulo 109 + 7), along with the binomial coefficients. To compute the binomials, recall that , so it is enough to know all the numbers k! for k upto n, along with their modular inverses. Also we should use the prefix sums of di, that is, the array . The rest is simple evaluation of the above sums.The total complexity is , because the common algorithms for modular inverses (that is, Ferma's little theorem exponentiation or solving a diophantine equation using the Euclid's algorithm) have theoritcal worst-case complexity of . However, one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O(n); for the description of the method refer to this comment by Kaban-5 (not sure why it has a negative rating, I found this quite insightful; maybe anyone can give a proper source for this method?).Challenge: now we want to find the sum of all expressions that are made by placing k pluses with a ≤ k ≤ b; that is, we want to find the sum of the answers for the original problem with k = a, ..., b; here a and b can be any integers with 0 ≤ a ≤ b ≤ n - 1. There is an obvious O(n2) solution: just find the answers for all k separately. Can you find a linear solution?521D - ShopIdea: EndagorionPreparation: gchebanovSuppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.Now we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a + b1 + ... + bi - 1 to a + b1 + ... + bi - 1 + bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.Finally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.To deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a + b1 + ... + bk to b + b1 + ... + bk. That is, the assignment here behaves pretty much the same way as the addition of b - a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.That is, all largest assigments for each skill should be made into additions of b - a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)Finally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions and we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.Challenge: suppose that you have to compare two fractions and , where a, b, c, d may be up to 1018. What way would you use to do that? Can you find a simple solution that does not involve long arithmetics, floating-point number or magic built-in integer types tricks (but may perform a non-constant number of operations)?521E - Cycling CityIdea: EndagorionPreparation: EndagorionWe have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.First of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.Now, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.Otherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.What if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.Finally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n + m) solution; a few logarithmic factors for simplification here and there are also allowed.Challenge: how many graphs G on n labeled vertices exist such that there exist two vertices of G connected by three disjoint paths? (Hint: we have already shown that it suffices to count the number of disjoint unions of cacti.) Find the answer modulo 109 + 7. Can you come up with any polynomial-time solution? An O(n3) solution? Maybe even better?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 520\\s*A"
          },
          "content_length": 16554
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[a-zA-Z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[a-zA-Z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n    string pattern = \"[a-zA-Z]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst string uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst string lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the correct limits\n    assert(1 <= n && n <= 100);\n\n    string s;\n\n    if (type == \"pangram\") {\n        // Generate a pangram of length n\n        if (n < 26) n = 26; // Adjust n to at least 26\n        s = \"\";\n\n        // Include all 26 letters\n        string letters = lowercase_letters;\n        shuffle(letters.begin(), letters.end());\n        s += letters;\n\n        // Add random letters to reach length n\n        while ((int)s.size() < n) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n\n        // Randomize the cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) {\n                s[i] = toupper(s[i]);\n            }\n        }\n\n        // Shuffle the string\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"nonpangram\") {\n        // Generate a non-pangram string of length n\n        s = \"\";\n        // Exclude some letters\n        int missing_letters_count = rnd.next(1, 5); // Randomly miss 1 to 5 letters\n        set<char> missing_letters;\n        while ((int)missing_letters.size() < missing_letters_count) {\n            char c = rnd.next('a', 'z');\n            missing_letters.insert(c);\n        }\n\n        // Collect the letters to use\n        vector<char> available_letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (missing_letters.find(c) == missing_letters.end()) {\n                available_letters.push_back(c);\n            }\n        }\n\n        // Ensure we have enough letters\n        while ((int)available_letters.size() < n) {\n            char c = available_letters[rnd.next((int)available_letters.size())];\n            available_letters.push_back(c);\n        }\n\n        // Shuffle and select n letters\n        shuffle(available_letters.begin(), available_letters.end());\n        for (int i = 0; i < n; ++i) {\n            s += available_letters[i % available_letters.size()];\n        }\n\n        // Randomize the cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) s[i] = toupper(s[i]);\n        }\n\n        // Shuffle the string\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"missingone\") {\n        // Generate a string missing exactly one letter\n        s = \"\";\n        if (n < 25) n = 25; // Adjust n to at least 25\n        // Select the missing letter\n        char missing_letter = rnd.next('a', 'z');\n\n        // Collect the letters to use\n        vector<char> available_letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (c != missing_letter) {\n                available_letters.push_back(c);\n            }\n        }\n\n        // Add letters to s\n        s.insert(s.end(), available_letters.begin(), available_letters.end());\n\n        // If n > 25, add random letters\n        while ((int)s.size() < n) {\n            char c = available_letters[rnd.next((int)available_letters.size())];\n            s += c;\n        }\n\n        // Randomize the cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) s[i] = toupper(s[i]);\n        }\n\n        // Shuffle the string\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"uppercase\") {\n        // Generate pangram in uppercase\n        if (n < 26) n = 26;\n        s = uppercase_letters;\n        shuffle(s.begin(), s.end());\n\n        while ((int)s.size() < n) {\n            char c = rnd.next('A', 'Z');\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"lowercase\") {\n        // Generate pangram in lowercase\n        if (n < 26) n = 26;\n        s = lowercase_letters;\n        shuffle(s.begin(), s.end());\n\n        while ((int)s.size() < n) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"mixedcase\") {\n        // Generate pangram with mixed cases\n        if (n < 26) n = 26;\n        s = lowercase_letters;\n        // Randomize cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) {\n                s[i] = toupper(s[i]);\n            }\n        }\n        shuffle(s.begin(), s.end());\n\n        while ((int)s.size() < n) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"length1\") {\n        n = 1;\n        s = \"\";\n        char c = rnd.next('a', 'z');\n        if (rnd.next(2) == 0) c = toupper(c);\n        s += c;\n\n    } else if (type == \"length100\") {\n        n = 100;\n        s = \"\";\n        // Include all letters at least once\n        string letters = lowercase_letters;\n        shuffle(letters.begin(), letters.end());\n        s += letters;\n\n        // Fill up to 100 characters\n        while ((int)s.size() < 100) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"repeated\") {\n        // Generate a string with repeated letters\n        s = \"\";\n        char c = rnd.next('a', 'z');\n        if (rnd.next(2) == 0) c = toupper(c);\n        s = string(n, c);\n\n    } else if (type == \"random\") {\n        // Generate a random string\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n\n    } else {\n        // Default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst string uppercase_letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst string lowercase_letters = \"abcdefghijklmnopqrstuvwxyz\";\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure n is within the correct limits\n    assert(1 <= n && n <= 100);\n\n    string s;\n\n    if (type == \"pangram\") {\n        // Generate a pangram of length n\n        if (n < 26) n = 26; // Adjust n to at least 26\n        s = \"\";\n\n        // Include all 26 letters\n        string letters = lowercase_letters;\n        shuffle(letters.begin(), letters.end());\n        s += letters;\n\n        // Add random letters to reach length n\n        while ((int)s.size() < n) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n\n        // Randomize the cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) {\n                s[i] = toupper(s[i]);\n            }\n        }\n\n        // Shuffle the string\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"nonpangram\") {\n        // Generate a non-pangram string of length n\n        s = \"\";\n        // Exclude some letters\n        int missing_letters_count = rnd.next(1, 5); // Randomly miss 1 to 5 letters\n        set<char> missing_letters;\n        while ((int)missing_letters.size() < missing_letters_count) {\n            char c = rnd.next('a', 'z');\n            missing_letters.insert(c);\n        }\n\n        // Collect the letters to use\n        vector<char> available_letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (missing_letters.find(c) == missing_letters.end()) {\n                available_letters.push_back(c);\n            }\n        }\n\n        // Ensure we have enough letters\n        while ((int)available_letters.size() < n) {\n            char c = available_letters[rnd.next((int)available_letters.size())];\n            available_letters.push_back(c);\n        }\n\n        // Shuffle and select n letters\n        shuffle(available_letters.begin(), available_letters.end());\n        for (int i = 0; i < n; ++i) {\n            s += available_letters[i % available_letters.size()];\n        }\n\n        // Randomize the cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) s[i] = toupper(s[i]);\n        }\n\n        // Shuffle the string\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"missingone\") {\n        // Generate a string missing exactly one letter\n        s = \"\";\n        if (n < 25) n = 25; // Adjust n to at least 25\n        // Select the missing letter\n        char missing_letter = rnd.next('a', 'z');\n\n        // Collect the letters to use\n        vector<char> available_letters;\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (c != missing_letter) {\n                available_letters.push_back(c);\n            }\n        }\n\n        // Add letters to s\n        s.insert(s.end(), available_letters.begin(), available_letters.end());\n\n        // If n > 25, add random letters\n        while ((int)s.size() < n) {\n            char c = available_letters[rnd.next((int)available_letters.size())];\n            s += c;\n        }\n\n        // Randomize the cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) s[i] = toupper(s[i]);\n        }\n\n        // Shuffle the string\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"uppercase\") {\n        // Generate pangram in uppercase\n        if (n < 26) n = 26;\n        s = uppercase_letters;\n        shuffle(s.begin(), s.end());\n\n        while ((int)s.size() < n) {\n            char c = rnd.next('A', 'Z');\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"lowercase\") {\n        // Generate pangram in lowercase\n        if (n < 26) n = 26;\n        s = lowercase_letters;\n        shuffle(s.begin(), s.end());\n\n        while ((int)s.size() < n) {\n            char c = rnd.next('a', 'z');\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"mixedcase\") {\n        // Generate pangram with mixed cases\n        if (n < 26) n = 26;\n        s = lowercase_letters;\n        // Randomize cases\n        for (int i = 0; i < (int)s.size(); ++i) {\n            if (rnd.next(2) == 0) {\n                s[i] = toupper(s[i]);\n            }\n        }\n        shuffle(s.begin(), s.end());\n\n        while ((int)s.size() < n) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"length1\") {\n        n = 1;\n        s = \"\";\n        char c = rnd.next('a', 'z');\n        if (rnd.next(2) == 0) c = toupper(c);\n        s += c;\n\n    } else if (type == \"length100\") {\n        n = 100;\n        s = \"\";\n        // Include all letters at least once\n        string letters = lowercase_letters;\n        shuffle(letters.begin(), letters.end());\n        s += letters;\n\n        // Fill up to 100 characters\n        while ((int)s.size() < 100) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n\n        shuffle(s.begin(), s.end());\n\n    } else if (type == \"repeated\") {\n        // Generate a string with repeated letters\n        s = \"\";\n        char c = rnd.next('a', 'z');\n        if (rnd.next(2) == 0) c = toupper(c);\n        s = string(n, c);\n\n    } else if (type == \"random\") {\n        // Generate a random string\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n\n    } else {\n        // Default to random\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            char c = rnd.next('a', 'z');\n            if (rnd.next(2) == 0) c = toupper(c);\n            s += c;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type length1\n./gen -n 26 -type pangram\n./gen -n 50 -type pangram\n./gen -n 100 -type pangram\n\n./gen -n 1 -type repeated\n./gen -n 10 -type repeated\n./gen -n 50 -type repeated\n./gen -n 100 -type repeated\n\n./gen -n 25 -type missingone\n./gen -n 30 -type missingone\n./gen -n 50 -type missingone\n./gen -n 100 -type missingone\n\n./gen -n 10 -type nonpangram\n./gen -n 25 -type nonpangram\n./gen -n 50 -type nonpangram\n./gen -n 100 -type nonpangram\n\n./gen -n 26 -type uppercase\n./gen -n 40 -type uppercase\n\n./gen -n 26 -type lowercase\n./gen -n 40 -type lowercase\n\n./gen -n 26 -type mixedcase\n./gen -n 100 -type mixedcase\n\n./gen -n 50 -type random\n./gen -n 100 -type random\n\n./gen -n 1 -type random\n./gen -n 100 -type length100\n./gen -n 50 -type length100\n\n./gen -n 50 -type uppercase\n./gen -n 50 -type lowercase\n./gen -n 50 -type mixedcase\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:42:58.649342",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "520/B",
      "title": "B. Две кнопки",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеПервая и единственная строка ввода содержит два различных целых числа n и m, разделенных пробелом (1 ≤ n, m ≤ 104).",
      "output_spec": "Выходные данныеВыведите одно число — минимальное количество нажатий на кнопки, необходимое, чтобы получить число m из числа n.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 6Выходные данныеСкопировать2Входные данныеСкопировать10 1Выходные данныеСкопировать9",
      "description": "B. Две кнопки\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеПервая и единственная строка ввода содержит два различных целых числа n и m, разделенных пробелом (1 ≤ n, m ≤ 104).\n\nВходные данные\n\nВыходные данныеВыведите одно число — минимальное количество нажатий на кнопки, необходимое, чтобы получить число m из числа n.\n\nВыходные данные\n\nВходные данныеСкопировать4 6Выходные данныеСкопировать2Входные данныеСкопировать10 1Выходные данныеСкопировать9\n\nВходные данныеСкопировать4 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать10 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере нужно один раз нажать на синюю кнопку, и затем раз один раз на красную кнопку.Во втором примере удваивать число невыгодно, поэтому надо девять раз нажать на синюю кнопку.",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Привет, Codeforces!2 марта в 10:00 MSK состоится раунд #295 для участников из обоих дивизионов.Раунд состоится практически одновременно с олимпиадой Зимней Компьютерной Школы на схожем комплекте задач. Авторы задач — я (Endagorion) и Евгений Савинов (savinov). В подготовке задач принимали участие члены технического комитета Зимней Компьютерной школы: Георгий Чебанов (gchebanov), Филипп Рухович (DPR-pavlin), Александр Машрабов (map), Сергей Киян (sokian), Константин Семенов (zemen), Кинан Альсармини (Sarkin).Спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский язык, Михаилу Мирзаянову (MikeMirzayanov) за вклад в развитие программирования путем создания систем Codeforces и Polygon.Разбалловка в обоих дивизионах стандартная: 500-1000-1500-2000-2500.Обратите внимание, что поскольку олимпиада ЗКШ на похожих задачах заканчивается позже раунда Codeforces, мы просим вас не обсуждать в комментариях задачи и решения до 14:10 MSK сегодняшнего дня. Также до этого времени будет закрыт просмотр кода других участников. Разбор также появится после этого времени.UPD: все, можно обсуждать. =)UPD2: наконец появился разбор ( теперь и на русском!).Также поздравляем победителей в Div.1: Petr hos.lyric Syloviaely andrew.volchek xyz111 Отдельно поздравляем Petr и rng_58, решивших самую сложную задачу E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1370
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces",
          "content": "Мы хотели бы также поблагодарить тестеров задач этого раунда и олимпиады ЗКШ: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Пожалуйста, пишите в комментариях о найденных ошибках.UPD: я вспомнил, что забыл написать регулярные бонусные челленджи. Так что вот, пожалуйста.520A - ПанграммаИдея:EndagorionПодготовка:EndagorionЧтобы проверить, что все буквы присутствуют, заведем массив длины 26 и для каждой буквы поставим в соответствующую ячейку единичку. В конце надо проверить, что все 26 единичек на месте. Решение работает за O(n). Также надо не забыть перевести все буквы к нижнему регистру (или наоборот, все буквы к верхнему).Чтобы перевести буквы в нижний регистр, можно использовать встроенные функции, например, tolower в Python. Также можно пользоваться тем, что буквы от a до z идут подряд по их ASCII-номерам; ASCII-номер для символа можно получить при помощи ord(c) во многих языках. Теперь, чтобы получить номер буквы в алфавите, надо написать ord(c) - ord('a'), а на C++ или C просто c - 'a' (поскольку в C/C++ символ — это число, равное его ASCII-номеру). Также, например, чтобы проверить, что буква имеет нижний регистр, надо написать неравенство ord('a') <= ord(c) && ord(c) <= ord('z').Challenge: сколько существует различных панграмм длины n? Строки, отличающиеся капитализацией некоторых символов, считаются различными. Сможете ли вы придумать линейное по времени решение?520B - Две кнопкиИдея: EndagorionПодготовка: EndagorionСамое простое решение — просто запустить обход в ширину. Построим граф, в котором вершины — числа, а ребра ведут из одного числа в другое, если можно получить второе из первого за одну операцию. Можно заметить, что первое число никогда не выгодно делать больше, чем 2m, поэтому в графе будет не больше 2·104 вершин и 4·104 ребер, и BFS сработает очень быстро.Однако, есть решение гораздо быстрее. Развернем задачу: изначально у нас есть число m, и мы хотим получить число n, пользуясь операциями \"прибавить к числу 1\" и \"поделить число на 2, если оно четно\".Пускай мы в какой-то момент применили две операции типа 1, и потом операцию типа 2; но эти три операции можно заменить на две: сначала операция типа 2, а потом одна операция типа 1, и количество операций от этого уменьшится. Отсюда следует, что применять больше одной операции типа 1 имеет смысл только тогда, когда операций типа 2 больше не будет, то есть, когда n меньше m и осталось сделать несколько прибавлений, чтобы их сравнять. На самом деле, теперь существует ровно одна последовательность операций, удовлетворяющая таким требованиям: если n меньше m, прибавляем единички пока нужно, иначе если n четно, делим на 2, а если нечетно, прибавляем 1 и потом делим на 2. Количество операций в такой последовательности можно найти за время .Challenge: рассмотрим обобщенную задачу: мы хотим получить число n из числа m с помощью операций двух типов \"отнять a\" и \"умножить на b\". Обобщите решение исходной задачи и научитесь находить минимальное количество операций за время в случае, если a и b взаимно просты. Справитесь ли вы, если у a и b могут быть нетривиальные общие делители?520C - Выравнивание ДНК/521A - Выравнивание ДНКИдея: EndagorionПодготовка: EndagorionЧто это за функция — ρ(s, t)? Для каждого символа t и каждого символа s существует ровно один циклический сдвиг, который их совмещает (действительно, после 0, ..., n - 1 сдвигов символ t пробежит все возможные положения в строке, и ровно одно из них — это положение символа из s); поэтому, существует ровно n способов циклически сдвинуть s и t, при которых выбранные символы совместятся (поскольку ситуация симметрична для любого положения символа из s). Таким образом, вклад в ρ, который дает символ ti, равен n × (количество символов s, равных ti). Поэтому ρ(s, t) максимально, когда каждый символ t встречается в s наибольшее количество раз. Посчитаем для каждого символа количество вхождений в s; ответ равен Kn, где K — это количество типов символов, которые встречаются в s чаще всего. Решение за O(n).Challenge: мы знаем, что ρmax(s) = C(s)·n2, где C(s)--- максимальное количество вхождений какого-либо символа. Сколько существует строк s длины n над алфавитом размера k, таких что C(s) = m? Сможете придумать решение за время O(kn2)? За время ? За время ? Может быть, еще быстрее? (Подсказка: для быстрого решения необходим удачно подобранный простой модуль. =))520D - Кубики/521B - КубикиИдея: savinovПодготовка: savinov, sokian, zemenВ эквивалентной формулировке, первый игрок стремится максимизировать лексикографиский порядок последовательности кубиков, а второй игрок — минимизировать его. Поэтому, на каждом шагу первый игрок берет максимальный из доступных кубиков, а второй — минимальный.Сперва научимся проверять, можно ли в текущей ситуации взять некоторый кубик. Его нельзя взять только тогда, когда есть какой-то кубик, который на нем \"стоит\" (т.е. имеет координаты (x - 1, y + 1), (x, y + 1) или (x + 1, y + 1)), и наш кубик является единственным, на котором он стоит. Это условие можно явно проверить. Из-за больших координат это не получится сделать путем простых обращений к массиву, поэтому придется завести ассоциативный массив, например, в C++ можно воспользоваться set.Теперь надо научиться находить максимальный/минимальный кубик среди доступных. Просто линейный проход — это слишком долго, поэтому заведем еще одну структуру, в которой будем хранить номера доступных кубиков. Структура должна уметь добавлять, удалять, а также искать максимум/минимум, так что что-нибудь вроде set нам снова подойдет.После того, как ход сделан, какие-то кубики могли стать доступными или, наоборот, перестать быть доступными. Однако, после каждого хода состояние могло поменяться только для O(1) кубиков: кубики (x ± 1, y) и (x ± 2, y) могли стать недоступными, потому что какой-то из кубиков выше стал опасным (т.е., остался один кубик, на котором он держится), и еще какие-то из кубиков (x - 1, y - 1), (x, y - 1) и (x + 1, y - 1) могли сделаться доступными, потому что единственный опасный кубик, который на них стоял, был удален. В любом случае, для всех них надо просто заново сделать проверку, и про случаи можно особо не думать.Решение с подходящей структурой работает за .Challenge (по мотивам вопросов от jk_qq и RetiredAmrMahmoud): пусть теперь кубики выкладываются в ряд справа налево, т.е. от младших разрядов к старшим. Первый игрок все так же хочет максимизировать итоговое число, второй — минимизировать его. Если оставить правила убирания кубиков такими же, в общем случае задача не выглядит решаемой. Попробуйте решить новую задачу в случае, когда кубики выстроены в несколько независимых башен, т.е. кубик можно убрать, если он находится на вершине своей башни.520E - Сплошные плюсы/521C - Сплошные плюсыИдея: EndagorionПодготовка: gchebanov, DPR-pavlinРассмотрим какой-нибудь способ расставить плюсы, а также какую-то цифру di (цифры пронумеруем с нуля слева направо). Эта цифра дает вклад в сумму чисел, равный di·10l, где l — расстояние до ближайшего плюса справа или до конца строки, если справа нет плюсов. Если просуммировать эти значения по всем цифрам и по всем способам расставить плюсы, получим в точности ответ.Сколько существует способов расставить плюсы для выбранной цифры di и какого-то фиксированного l? Во-первых, рассмотрим случай, когда при разбиении по плюсам часть, содержащая цифру di, не является последней, т.е., i + l < n - 1. Всего существует n - 1 позиция, куда можно ставить плюсы; ограничение, связанное с цифрой di и расстоянием l, означает, что после цифр di, ..., di + l - 1 плюсов не стоит, а после цифры di + l плюс стоит. Иными словами, строка выглядит примерно так: На рисунке точка означает отсутствие плюса, а вопросик значит, что неважно, стоит там плюс или нет. Видно, что из n - 1 возможных позиций для плюсов состояния (l + 1)-ой позиции определены, и среди них использован только один плюс. Это значит, что в остальные (n - 1) - (l + 1) = n - l - 2 надо поставить k - 1 плюс любым из способов; значит, искомое количество способов равно . Рассуждая схожим образом, получим, что если цифра di входит в последнюю часть (т.е. i + l = n - 1), количество способов равно .В итоге получаем, что ответ равен Преобразуем: Чтобы посчитать такие суммы, нам надо предпосчитать все степени 10 до n-ой (по модулю 109 + 7), а также биномиальные коэффициенты. Чтобы их посчитать, вспомним, что , поэтому достаточно вычислить все k! для k вплоть до n, а также их обратные значения по модулю. Помимо этого, нам пригодится массив префиксных сумм для цифр di, т.е., значения . Осталось просто просуммировать произведения этих величин.В итоге получили решение за , поскольку стандартные алгоритмы для поиска обратных по модулю (а именно, малая теорема Ферма с бинарным возведением в степень и решение диофантова уравнения при помощи обобщенного алгоритма Евклида) имеют верхнюю оценку сложности . Однако, можно воспользоваться интересным трюком и вычислить все обратные элементы для первых n чисел за линейное время, после чего итоговоая сложность решения становится O(n); почитать про интересный трюк можно в комментарии от Kaban-5 (непонятно, почему он заминусован; может быть, кто-то вспомнит ссылку на более фундаментальный источник для этого метода?).Challenge: теперь мы хотим посчитать сумму всех выражений, в которых расставлено k плюсов для всех k от a до b; т.е. мы хотим просуммировать ответы для исходной задачи по всем k = a, ..., b. Числа a и b любые, такие что 0 ≤ a ≤ b ≤ n - 1. Решение за O(n2) очевидно: для каждого k посчитаем ответ отдельно. Сможете ли вы придумать решение за линейное время?521D - Магазин Идея: EndagorionПодготовка: gchebanovПусть у нас есть только умножения. Тогда нам даже не важно, в каком порядке их применять, надо просто брать несколько апгрейдов с максимальным bi.Теперь рассмотрим также прибавления, а про умножения временно забудем. Ясно, что для каждого скилла надо взять несколько максимальных прибавлений (возможно, ни одного). Для каждого скилла отсортируем прибавления по невозрастанию bi; теперь для каждого скилла надо взять несколько первых апгрейдов. Итак, теперь для выбранного скилла есть невозрастающая последовательность прибавлений b1, ..., bl, и начальное значение скилла равно какому-то a. Раз мы решили взять некоторый префикс массива b, это значит, что когда мы берем апгрейд bi, значение скилла увеличивается с a + b1 + ... + bi - 1 до a + b1 + ... + bi - 1 + bi. Иными словами, значение, на которое домножится значение скилла (а значит, и все произвдение значений скиллов), равно дроби . Теперь, когда это отношение однозначно определилось для каждого прибавления, мы можем считать любое прибавление умножением. =) Теперь посчитаем такие отношения для всех прибавлений (т.е., отсортируем b-шки для каждого скилла по отдельности и найдем значения всех дробей), и затем посортируем умножения и прибавления вместе по тому, во сколько раз они увеличивают итоговый ответ. Ясно, что все умножения надо использовать уже после того, как были сделаны все прибавления; иными словами, для определения того, какие апгрейды брать, мы сортируем их все вместе по их отношениям, но реальный порядок применения должен быть таким: сперва все прибавления, а потом все умножения.Наконец, разберемся с присваиваниями. Очевидно, что для каждого скилла имеет смысл делать не более одного присваивания, и использовать можно только максимальное присваивание для данного скилла. Кроме того, присваивание необходимо делать перед всеми прибавлениями и умножениями. Поэтому, для каждого скилла надо просто определиться, берем мы для него максимальное присваивание или нет. Однако есть проблема с тем, что когда мы сделали присваивание, отношения для прибавлений стали неправильными, поскольку стартовое значение a поменялось.Представим теперь, что мы уже выбрали, какие прибавления мы сделаем, и теперь решаем, брать присваивание или нет. Если мы берем присваивание, то итоговое значение скилла поменяется с a + b1 + ... + bk на b + b1 + ... + bk. Иными словами, присваивание работает примерно так же, как и прибавление значения b - a. Единственная разница в том, что присваивание необходимо ставить раньше всех прибавлений.Итак, переделаем все максимальные присваивания для каждого скилла в прибавления b - a и обработаем их вместе со всеми остальными присваиваниями (которые, как мы знаем, в итоге станут умножениями =)).В итоге, задача свелась к сортировке отношений для всех апгрейдов. Оценим, какие числа у нас будут стоять в дробях. Отношение для умножения — это целое число до 106; отношение для прибавления — это дробь, которая выглядит как . Поскольку k может быть порядка 105, а bi — порядка 106, числитель и знаменатель дроби могут быть порядка 1011. Когда мы сравниваем дроби и , мы сравниваем произведения ad и bc, которые по нашим оценкам могут быть порядка 1022. Это, к сожалению, приводит к переполнению встроенных целочисленных типов во многих языках. Чтобы разобраться с этой проблемой, вычтем из всех дробей единицу (очевидно, на порядок сортировки это не повлияет), и теперь отношения для прибавлений выглядят как . Теперь, числитель стал всего лишь порядка 106, произведения будут порядка 1017, что уже помещается в стандартный 64-битный тип в любом языке.Challenge: пускай нам надо сравнить две дроби и , где числа a, b, c, d могут быть порядка 1018. Каким способом вы бы это сделали? Сможете ли вы придумать простое решение, которое не использует длинную арифметику, вещественные числа или волшебные целочисленные типы, такие как __int128 и им подобные (однако, возможно, совершает неконстантное число операций)?521E - Cycling CityИдея: EndagorionПодготовка: EndagorionНам нужно найти в неориентированном графе две вершины, такие что их можно соединить тремя вершинно и реберно непересекающимися путями. Это легко решалось бы потоком, если бы не большие ограничения.Во-первых, заметим, что все пути между двумя выбранными вершинами должны проходить внутри одной двусвязной компоненты графа. Действительно, любой простой цикл должен целиком лежать внутри одной двусвязной компоненты, а набор из трех путей можно представить как объединение двух пересекающихся циклов. Поэтому, сперва выделим все двусвязные компоненты графа и попытаемся решить задачу независимо в каждой из них. Двусвязные компонентны можно найти за линейное время; хороший алгоритм, который это делает, можно найти в статье по ссылке выше.Теперь, у нас есть двусвязная компонента и та же самая задача. Во-первых, найдем любой цикл в этой компоненте обычным DFS'ом; единственный случай, когда цикл не найдется, — это когда компонента состоит из одного ребра, но это неинтересный случай. Теперь, предположим, что ни из какой вершины цикла не исходит ребра, которое бы не лежало в цикле; в этом случае цикл не связан ни с какой другой вершиной компоненты, поэтому компонента сама по себе является этим циклом; очевидно, что в этом случае решения также нет.В противном случае, возьмем вершину v, из которой исходит ребро e, не лежащее в выбранном цикле (обозначим цикл за c). Если мы сможем найти такой путь p, который начинался бы с ребра e и заканчивался в какой-то вершине из цикла u (отличной от v), мы сможем выделить три непересекающихся пути между u и v: один из них — это p, а два других — половинки исходного цикла. Чтобы найти путь p, запустим DFS, который начинается с ребра e и заканчивается, как только мы приходим в вершину цикла c, отличную от v, а потом восстанавливает все пути для ответа.Что же делать, если такого пути p не найдется? Обозначим за C компоненту, которую обошел этот DFS. У него не получилось найти пути между вершинами из множества C\\ {v} и множества c\\ {v}, поэтому любой путь между этими двумя множествами должен проходить через v. Но тогда оказывается, что если удалить v, компонента C\\ {v} оказывается отделена от вершин из множества c\\ {v}, что противоречит тому, что исходная компонента была двусвязной. Отсюда следует, что тот DFS, который мы запускали из e, всегда найдет подходящий путь p и получит ответ, если наша двусвязная компонента — не цикл и не отдельное ребро.В итоге мы пришли к тому, что ответа нет в единственном случае, когда все двусвязные компоненты — либо отдельные ребра, либо циклы; другими словами, когда граф является несвязным набором кактусов. В противном случае, за пару запусков DFS'ов мы сможем найти три непересекающихся пути. В итоге получилось решение за время O(n + m); для упрощения можно было бы где-нибудь накрутить парочку логарифмов.Challenge: сколько существует графов G, таких что в G можно выбрать две вершины, соединенные тремя непересекающимися путями? (Подсказка: мы знаем, что достаточно посчитать количество несвязных объединений кактусов.) Можете ли вы придумать какое-нибудь полиномиальное по времени решение? Решение за время O(n3)? Возможно, еще быстрее?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 520\\s*B"
          },
          "content_length": 16705
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 9",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 10",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 11",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 12",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 13",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    ensuref(n != m, \"n and m must be distinct\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    ensuref(n != m, \"n and m must be distinct\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 10000, \"m\");\n    ensuref(n != m, \"n and m must be distinct\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int MIN_N = 1;\n    const int MAX_N = 10000;\n\n    if (n != -1 && m != -1) {\n        // Ensure n and m are within bounds and n != m\n        if (n < MIN_N || n > MAX_N || m < MIN_N || m > MAX_N || n == m) {\n            fprintf(stderr, \"Invalid n or m provided. They must satisfy %d ≤ n, m ≤ %d and n ≠ m.\\n\", MIN_N, MAX_N);\n            return 1;\n        }\n    } else {\n        if (type == \"random\") {\n            n = rnd.next(MIN_N, MAX_N);\n            m = rnd.next(MIN_N, MAX_N);\n            while (n == m) {\n                m = rnd.next(MIN_N, MAX_N);\n            }\n        } else if (type == \"n_greater\") {\n            n = rnd.next(MIN_N + 1, MAX_N);\n            m = rnd.next(MIN_N, n - 1);\n        } else if (type == \"m_greater\") {\n            n = rnd.next(MIN_N, MAX_N - 1);\n            m = rnd.next(n + 1, MAX_N);\n        } else if (type == \"max\") {\n            n = MAX_N;\n            m = MAX_N - 1;\n        } else if (type == \"min\") {\n            n = MIN_N;\n            m = MIN_N + 1;\n        } else if (type == \"close\") {\n            n = rnd.next(MIN_N, MAX_N);\n            if (n == MIN_N) {\n                m = n + 1;\n            } else if (n == MAX_N) {\n                m = n - 1;\n            } else {\n                if (rnd.next(0, 1) == 0) {\n                    m = n - 1;\n                } else {\n                    m = n + 1;\n                }\n            }\n        } else if (type == \"far\") {\n            n = MIN_N;\n            m = MAX_N;\n        } else if (type == \"pathological\") {\n            // Specific cases that may cause errors in incorrect solutions\n            n = MAX_N;\n            m = MIN_N;\n        } else {\n            // Type not recognized, default to random\n            n = rnd.next(MIN_N, MAX_N);\n            m = rnd.next(MIN_N, MAX_N);\n            while (n == m) {\n                m = rnd.next(MIN_N, MAX_N);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Constraints\n    const int MIN_N = 1;\n    const int MAX_N = 10000;\n\n    if (n != -1 && m != -1) {\n        // Ensure n and m are within bounds and n != m\n        if (n < MIN_N || n > MAX_N || m < MIN_N || m > MAX_N || n == m) {\n            fprintf(stderr, \"Invalid n or m provided. They must satisfy %d ≤ n, m ≤ %d and n ≠ m.\\n\", MIN_N, MAX_N);\n            return 1;\n        }\n    } else {\n        if (type == \"random\") {\n            n = rnd.next(MIN_N, MAX_N);\n            m = rnd.next(MIN_N, MAX_N);\n            while (n == m) {\n                m = rnd.next(MIN_N, MAX_N);\n            }\n        } else if (type == \"n_greater\") {\n            n = rnd.next(MIN_N + 1, MAX_N);\n            m = rnd.next(MIN_N, n - 1);\n        } else if (type == \"m_greater\") {\n            n = rnd.next(MIN_N, MAX_N - 1);\n            m = rnd.next(n + 1, MAX_N);\n        } else if (type == \"max\") {\n            n = MAX_N;\n            m = MAX_N - 1;\n        } else if (type == \"min\") {\n            n = MIN_N;\n            m = MIN_N + 1;\n        } else if (type == \"close\") {\n            n = rnd.next(MIN_N, MAX_N);\n            if (n == MIN_N) {\n                m = n + 1;\n            } else if (n == MAX_N) {\n                m = n - 1;\n            } else {\n                if (rnd.next(0, 1) == 0) {\n                    m = n - 1;\n                } else {\n                    m = n + 1;\n                }\n            }\n        } else if (type == \"far\") {\n            n = MIN_N;\n            m = MAX_N;\n        } else if (type == \"pathological\") {\n            // Specific cases that may cause errors in incorrect solutions\n            n = MAX_N;\n            m = MIN_N;\n        } else {\n            // Type not recognized, default to random\n            n = rnd.next(MIN_N, MAX_N);\n            m = rnd.next(MIN_N, MAX_N);\n            while (n == m) {\n                m = rnd.next(MIN_N, MAX_N);\n            }\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random\n./gen -type random\n./gen -type random\n./gen -type n_greater\n./gen -type n_greater\n./gen -type m_greater\n./gen -type m_greater\n./gen -type min\n./gen -type max\n./gen -type close\n./gen -type close\n./gen -type far\n./gen -type pathological\n./gen -n 1 -m 10000\n./gen -n 10000 -m 1\n./gen -n 1 -m 2\n./gen -n 2 -m 1\n./gen -n 10000 -m 9999\n./gen -n 9999 -m 10000\n./gen -n 5000 -m 5001\n./gen -n 5000 -m 4999\n./gen -n 10000 -m 5000\n./gen -n 5000 -m 10000\n./gen -n 1 -m 5000\n./gen -type random\n./gen -type n_greater\n./gen -type m_greater\n./gen -type close\n./gen -type far\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:00.889898",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "520/C",
      "title": "C. Выравнивание ДНК",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано одно целое число n (1 ≤ n ≤ 105).Во второй строке ввода записана одна строка длины n, состоящая из символов \"ACGT\".",
      "output_spec": "Выходные данныеВыведите одно число — ответ по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать1CВыходные данныеСкопировать1Входные данныеСкопировать2AGВыходные данныеСкопировать4Входные данныеСкопировать3TTTВыходные данныеСкопировать1",
      "description": "C. Выравнивание ДНК\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано одно целое число n (1 ≤ n ≤ 105).Во второй строке ввода записана одна строка длины n, состоящая из символов \"ACGT\".\n\nВходные данные\n\nВыходные данныеВыведите одно число — ответ по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать1CВыходные данныеСкопировать1Входные данныеСкопировать2AGВыходные данныеСкопировать4Входные данныеСкопировать3TTTВыходные данныеСкопировать1\n\nВходные данныеСкопировать1C\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2AG\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3TTT\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОбратите внимание, что если для двух различных строк t1 и t2 значения ρ(s, t1) и ρ(s, t2) являются максимальными среди всех возможных строк, то обе строки необходимо учесть в итоговом количестве даже в том случае, когда одну из них можно получить циклическим сдвигом из другой.В первом примере существует ρ(\"C\", \"C\") = 1, для остальных строк t длины 1 значение ρ(s, t) равно 0.Во втором примере ρ(\"AG\", \"AG\") = ρ(\"AG\", \"GA\") = ρ(\"AG\", \"AA\") = ρ(\"AG\", \"GG\") = 4.В третьем примере ρ(\"TTT\", \"TTT\") = 27.",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Привет, Codeforces!2 марта в 10:00 MSK состоится раунд #295 для участников из обоих дивизионов.Раунд состоится практически одновременно с олимпиадой Зимней Компьютерной Школы на схожем комплекте задач. Авторы задач — я (Endagorion) и Евгений Савинов (savinov). В подготовке задач принимали участие члены технического комитета Зимней Компьютерной школы: Георгий Чебанов (gchebanov), Филипп Рухович (DPR-pavlin), Александр Машрабов (map), Сергей Киян (sokian), Константин Семенов (zemen), Кинан Альсармини (Sarkin).Спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский язык, Михаилу Мирзаянову (MikeMirzayanov) за вклад в развитие программирования путем создания систем Codeforces и Polygon.Разбалловка в обоих дивизионах стандартная: 500-1000-1500-2000-2500.Обратите внимание, что поскольку олимпиада ЗКШ на похожих задачах заканчивается позже раунда Codeforces, мы просим вас не обсуждать в комментариях задачи и решения до 14:10 MSK сегодняшнего дня. Также до этого времени будет закрыт просмотр кода других участников. Разбор также появится после этого времени.UPD: все, можно обсуждать. =)UPD2: наконец появился разбор ( теперь и на русском!).Также поздравляем победителей в Div.1: Petr hos.lyric Syloviaely andrew.volchek xyz111 Отдельно поздравляем Petr и rng_58, решивших самую сложную задачу E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1370
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces",
          "content": "Мы хотели бы также поблагодарить тестеров задач этого раунда и олимпиады ЗКШ: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Пожалуйста, пишите в комментариях о найденных ошибках.UPD: я вспомнил, что забыл написать регулярные бонусные челленджи. Так что вот, пожалуйста.520A - ПанграммаИдея:EndagorionПодготовка:EndagorionЧтобы проверить, что все буквы присутствуют, заведем массив длины 26 и для каждой буквы поставим в соответствующую ячейку единичку. В конце надо проверить, что все 26 единичек на месте. Решение работает за O(n). Также надо не забыть перевести все буквы к нижнему регистру (или наоборот, все буквы к верхнему).Чтобы перевести буквы в нижний регистр, можно использовать встроенные функции, например, tolower в Python. Также можно пользоваться тем, что буквы от a до z идут подряд по их ASCII-номерам; ASCII-номер для символа можно получить при помощи ord(c) во многих языках. Теперь, чтобы получить номер буквы в алфавите, надо написать ord(c) - ord('a'), а на C++ или C просто c - 'a' (поскольку в C/C++ символ — это число, равное его ASCII-номеру). Также, например, чтобы проверить, что буква имеет нижний регистр, надо написать неравенство ord('a') <= ord(c) && ord(c) <= ord('z').Challenge: сколько существует различных панграмм длины n? Строки, отличающиеся капитализацией некоторых символов, считаются различными. Сможете ли вы придумать линейное по времени решение?520B - Две кнопкиИдея: EndagorionПодготовка: EndagorionСамое простое решение — просто запустить обход в ширину. Построим граф, в котором вершины — числа, а ребра ведут из одного числа в другое, если можно получить второе из первого за одну операцию. Можно заметить, что первое число никогда не выгодно делать больше, чем 2m, поэтому в графе будет не больше 2·104 вершин и 4·104 ребер, и BFS сработает очень быстро.Однако, есть решение гораздо быстрее. Развернем задачу: изначально у нас есть число m, и мы хотим получить число n, пользуясь операциями \"прибавить к числу 1\" и \"поделить число на 2, если оно четно\".Пускай мы в какой-то момент применили две операции типа 1, и потом операцию типа 2; но эти три операции можно заменить на две: сначала операция типа 2, а потом одна операция типа 1, и количество операций от этого уменьшится. Отсюда следует, что применять больше одной операции типа 1 имеет смысл только тогда, когда операций типа 2 больше не будет, то есть, когда n меньше m и осталось сделать несколько прибавлений, чтобы их сравнять. На самом деле, теперь существует ровно одна последовательность операций, удовлетворяющая таким требованиям: если n меньше m, прибавляем единички пока нужно, иначе если n четно, делим на 2, а если нечетно, прибавляем 1 и потом делим на 2. Количество операций в такой последовательности можно найти за время .Challenge: рассмотрим обобщенную задачу: мы хотим получить число n из числа m с помощью операций двух типов \"отнять a\" и \"умножить на b\". Обобщите решение исходной задачи и научитесь находить минимальное количество операций за время в случае, если a и b взаимно просты. Справитесь ли вы, если у a и b могут быть нетривиальные общие делители?520C - Выравнивание ДНК/521A - Выравнивание ДНКИдея: EndagorionПодготовка: EndagorionЧто это за функция — ρ(s, t)? Для каждого символа t и каждого символа s существует ровно один циклический сдвиг, который их совмещает (действительно, после 0, ..., n - 1 сдвигов символ t пробежит все возможные положения в строке, и ровно одно из них — это положение символа из s); поэтому, существует ровно n способов циклически сдвинуть s и t, при которых выбранные символы совместятся (поскольку ситуация симметрична для любого положения символа из s). Таким образом, вклад в ρ, который дает символ ti, равен n × (количество символов s, равных ti). Поэтому ρ(s, t) максимально, когда каждый символ t встречается в s наибольшее количество раз. Посчитаем для каждого символа количество вхождений в s; ответ равен Kn, где K — это количество типов символов, которые встречаются в s чаще всего. Решение за O(n).Challenge: мы знаем, что ρmax(s) = C(s)·n2, где C(s)--- максимальное количество вхождений какого-либо символа. Сколько существует строк s длины n над алфавитом размера k, таких что C(s) = m? Сможете придумать решение за время O(kn2)? За время ? За время ? Может быть, еще быстрее? (Подсказка: для быстрого решения необходим удачно подобранный простой модуль. =))520D - Кубики/521B - КубикиИдея: savinovПодготовка: savinov, sokian, zemenВ эквивалентной формулировке, первый игрок стремится максимизировать лексикографиский порядок последовательности кубиков, а второй игрок — минимизировать его. Поэтому, на каждом шагу первый игрок берет максимальный из доступных кубиков, а второй — минимальный.Сперва научимся проверять, можно ли в текущей ситуации взять некоторый кубик. Его нельзя взять только тогда, когда есть какой-то кубик, который на нем \"стоит\" (т.е. имеет координаты (x - 1, y + 1), (x, y + 1) или (x + 1, y + 1)), и наш кубик является единственным, на котором он стоит. Это условие можно явно проверить. Из-за больших координат это не получится сделать путем простых обращений к массиву, поэтому придется завести ассоциативный массив, например, в C++ можно воспользоваться set.Теперь надо научиться находить максимальный/минимальный кубик среди доступных. Просто линейный проход — это слишком долго, поэтому заведем еще одну структуру, в которой будем хранить номера доступных кубиков. Структура должна уметь добавлять, удалять, а также искать максимум/минимум, так что что-нибудь вроде set нам снова подойдет.После того, как ход сделан, какие-то кубики могли стать доступными или, наоборот, перестать быть доступными. Однако, после каждого хода состояние могло поменяться только для O(1) кубиков: кубики (x ± 1, y) и (x ± 2, y) могли стать недоступными, потому что какой-то из кубиков выше стал опасным (т.е., остался один кубик, на котором он держится), и еще какие-то из кубиков (x - 1, y - 1), (x, y - 1) и (x + 1, y - 1) могли сделаться доступными, потому что единственный опасный кубик, который на них стоял, был удален. В любом случае, для всех них надо просто заново сделать проверку, и про случаи можно особо не думать.Решение с подходящей структурой работает за .Challenge (по мотивам вопросов от jk_qq и RetiredAmrMahmoud): пусть теперь кубики выкладываются в ряд справа налево, т.е. от младших разрядов к старшим. Первый игрок все так же хочет максимизировать итоговое число, второй — минимизировать его. Если оставить правила убирания кубиков такими же, в общем случае задача не выглядит решаемой. Попробуйте решить новую задачу в случае, когда кубики выстроены в несколько независимых башен, т.е. кубик можно убрать, если он находится на вершине своей башни.520E - Сплошные плюсы/521C - Сплошные плюсыИдея: EndagorionПодготовка: gchebanov, DPR-pavlinРассмотрим какой-нибудь способ расставить плюсы, а также какую-то цифру di (цифры пронумеруем с нуля слева направо). Эта цифра дает вклад в сумму чисел, равный di·10l, где l — расстояние до ближайшего плюса справа или до конца строки, если справа нет плюсов. Если просуммировать эти значения по всем цифрам и по всем способам расставить плюсы, получим в точности ответ.Сколько существует способов расставить плюсы для выбранной цифры di и какого-то фиксированного l? Во-первых, рассмотрим случай, когда при разбиении по плюсам часть, содержащая цифру di, не является последней, т.е., i + l < n - 1. Всего существует n - 1 позиция, куда можно ставить плюсы; ограничение, связанное с цифрой di и расстоянием l, означает, что после цифр di, ..., di + l - 1 плюсов не стоит, а после цифры di + l плюс стоит. Иными словами, строка выглядит примерно так: На рисунке точка означает отсутствие плюса, а вопросик значит, что неважно, стоит там плюс или нет. Видно, что из n - 1 возможных позиций для плюсов состояния (l + 1)-ой позиции определены, и среди них использован только один плюс. Это значит, что в остальные (n - 1) - (l + 1) = n - l - 2 надо поставить k - 1 плюс любым из способов; значит, искомое количество способов равно . Рассуждая схожим образом, получим, что если цифра di входит в последнюю часть (т.е. i + l = n - 1), количество способов равно .В итоге получаем, что ответ равен Преобразуем: Чтобы посчитать такие суммы, нам надо предпосчитать все степени 10 до n-ой (по модулю 109 + 7), а также биномиальные коэффициенты. Чтобы их посчитать, вспомним, что , поэтому достаточно вычислить все k! для k вплоть до n, а также их обратные значения по модулю. Помимо этого, нам пригодится массив префиксных сумм для цифр di, т.е., значения . Осталось просто просуммировать произведения этих величин.В итоге получили решение за , поскольку стандартные алгоритмы для поиска обратных по модулю (а именно, малая теорема Ферма с бинарным возведением в степень и решение диофантова уравнения при помощи обобщенного алгоритма Евклида) имеют верхнюю оценку сложности . Однако, можно воспользоваться интересным трюком и вычислить все обратные элементы для первых n чисел за линейное время, после чего итоговоая сложность решения становится O(n); почитать про интересный трюк можно в комментарии от Kaban-5 (непонятно, почему он заминусован; может быть, кто-то вспомнит ссылку на более фундаментальный источник для этого метода?).Challenge: теперь мы хотим посчитать сумму всех выражений, в которых расставлено k плюсов для всех k от a до b; т.е. мы хотим просуммировать ответы для исходной задачи по всем k = a, ..., b. Числа a и b любые, такие что 0 ≤ a ≤ b ≤ n - 1. Решение за O(n2) очевидно: для каждого k посчитаем ответ отдельно. Сможете ли вы придумать решение за линейное время?521D - Магазин Идея: EndagorionПодготовка: gchebanovПусть у нас есть только умножения. Тогда нам даже не важно, в каком порядке их применять, надо просто брать несколько апгрейдов с максимальным bi.Теперь рассмотрим также прибавления, а про умножения временно забудем. Ясно, что для каждого скилла надо взять несколько максимальных прибавлений (возможно, ни одного). Для каждого скилла отсортируем прибавления по невозрастанию bi; теперь для каждого скилла надо взять несколько первых апгрейдов. Итак, теперь для выбранного скилла есть невозрастающая последовательность прибавлений b1, ..., bl, и начальное значение скилла равно какому-то a. Раз мы решили взять некоторый префикс массива b, это значит, что когда мы берем апгрейд bi, значение скилла увеличивается с a + b1 + ... + bi - 1 до a + b1 + ... + bi - 1 + bi. Иными словами, значение, на которое домножится значение скилла (а значит, и все произвдение значений скиллов), равно дроби . Теперь, когда это отношение однозначно определилось для каждого прибавления, мы можем считать любое прибавление умножением. =) Теперь посчитаем такие отношения для всех прибавлений (т.е., отсортируем b-шки для каждого скилла по отдельности и найдем значения всех дробей), и затем посортируем умножения и прибавления вместе по тому, во сколько раз они увеличивают итоговый ответ. Ясно, что все умножения надо использовать уже после того, как были сделаны все прибавления; иными словами, для определения того, какие апгрейды брать, мы сортируем их все вместе по их отношениям, но реальный порядок применения должен быть таким: сперва все прибавления, а потом все умножения.Наконец, разберемся с присваиваниями. Очевидно, что для каждого скилла имеет смысл делать не более одного присваивания, и использовать можно только максимальное присваивание для данного скилла. Кроме того, присваивание необходимо делать перед всеми прибавлениями и умножениями. Поэтому, для каждого скилла надо просто определиться, берем мы для него максимальное присваивание или нет. Однако есть проблема с тем, что когда мы сделали присваивание, отношения для прибавлений стали неправильными, поскольку стартовое значение a поменялось.Представим теперь, что мы уже выбрали, какие прибавления мы сделаем, и теперь решаем, брать присваивание или нет. Если мы берем присваивание, то итоговое значение скилла поменяется с a + b1 + ... + bk на b + b1 + ... + bk. Иными словами, присваивание работает примерно так же, как и прибавление значения b - a. Единственная разница в том, что присваивание необходимо ставить раньше всех прибавлений.Итак, переделаем все максимальные присваивания для каждого скилла в прибавления b - a и обработаем их вместе со всеми остальными присваиваниями (которые, как мы знаем, в итоге станут умножениями =)).В итоге, задача свелась к сортировке отношений для всех апгрейдов. Оценим, какие числа у нас будут стоять в дробях. Отношение для умножения — это целое число до 106; отношение для прибавления — это дробь, которая выглядит как . Поскольку k может быть порядка 105, а bi — порядка 106, числитель и знаменатель дроби могут быть порядка 1011. Когда мы сравниваем дроби и , мы сравниваем произведения ad и bc, которые по нашим оценкам могут быть порядка 1022. Это, к сожалению, приводит к переполнению встроенных целочисленных типов во многих языках. Чтобы разобраться с этой проблемой, вычтем из всех дробей единицу (очевидно, на порядок сортировки это не повлияет), и теперь отношения для прибавлений выглядят как . Теперь, числитель стал всего лишь порядка 106, произведения будут порядка 1017, что уже помещается в стандартный 64-битный тип в любом языке.Challenge: пускай нам надо сравнить две дроби и , где числа a, b, c, d могут быть порядка 1018. Каким способом вы бы это сделали? Сможете ли вы придумать простое решение, которое не использует длинную арифметику, вещественные числа или волшебные целочисленные типы, такие как __int128 и им подобные (однако, возможно, совершает неконстантное число операций)?521E - Cycling CityИдея: EndagorionПодготовка: EndagorionНам нужно найти в неориентированном графе две вершины, такие что их можно соединить тремя вершинно и реберно непересекающимися путями. Это легко решалось бы потоком, если бы не большие ограничения.Во-первых, заметим, что все пути между двумя выбранными вершинами должны проходить внутри одной двусвязной компоненты графа. Действительно, любой простой цикл должен целиком лежать внутри одной двусвязной компоненты, а набор из трех путей можно представить как объединение двух пересекающихся циклов. Поэтому, сперва выделим все двусвязные компоненты графа и попытаемся решить задачу независимо в каждой из них. Двусвязные компонентны можно найти за линейное время; хороший алгоритм, который это делает, можно найти в статье по ссылке выше.Теперь, у нас есть двусвязная компонента и та же самая задача. Во-первых, найдем любой цикл в этой компоненте обычным DFS'ом; единственный случай, когда цикл не найдется, — это когда компонента состоит из одного ребра, но это неинтересный случай. Теперь, предположим, что ни из какой вершины цикла не исходит ребра, которое бы не лежало в цикле; в этом случае цикл не связан ни с какой другой вершиной компоненты, поэтому компонента сама по себе является этим циклом; очевидно, что в этом случае решения также нет.В противном случае, возьмем вершину v, из которой исходит ребро e, не лежащее в выбранном цикле (обозначим цикл за c). Если мы сможем найти такой путь p, который начинался бы с ребра e и заканчивался в какой-то вершине из цикла u (отличной от v), мы сможем выделить три непересекающихся пути между u и v: один из них — это p, а два других — половинки исходного цикла. Чтобы найти путь p, запустим DFS, который начинается с ребра e и заканчивается, как только мы приходим в вершину цикла c, отличную от v, а потом восстанавливает все пути для ответа.Что же делать, если такого пути p не найдется? Обозначим за C компоненту, которую обошел этот DFS. У него не получилось найти пути между вершинами из множества C\\ {v} и множества c\\ {v}, поэтому любой путь между этими двумя множествами должен проходить через v. Но тогда оказывается, что если удалить v, компонента C\\ {v} оказывается отделена от вершин из множества c\\ {v}, что противоречит тому, что исходная компонента была двусвязной. Отсюда следует, что тот DFS, который мы запускали из e, всегда найдет подходящий путь p и получит ответ, если наша двусвязная компонента — не цикл и не отдельное ребро.В итоге мы пришли к тому, что ответа нет в единственном случае, когда все двусвязные компоненты — либо отдельные ребра, либо циклы; другими словами, когда граф является несвязным набором кактусов. В противном случае, за пару запусков DFS'ов мы сможем найти три непересекающихся пути. В итоге получилось решение за время O(n + m); для упрощения можно было бы где-нибудь накрутить парочку логарифмов.Challenge: сколько существует графов G, таких что в G можно выбрать две вершины, соединенные тремя непересекающимися путями? (Подсказка: мы знаем, что достаточно посчитать количество несвязных объединений кактусов.) Можете ли вы придумать какое-нибудь полиномиальное по времени решение? Решение за время O(n3)? Возможно, еще быстрее?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 520\\s*C"
          },
          "content_length": 16705
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 9",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 10",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 11",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 12",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 13",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of s (%d) is not equal to n (%d)\", int(s.length()), n);\n    for(int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref(c == 'A' || c == 'C' || c == 'G' || c == 'T', \"Invalid character s[%d]='%c'\", i+1, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of s (%d) is not equal to n (%d)\", int(s.length()), n);\n    for(int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref(c == 'A' || c == 'C' || c == 'G' || c == 'T', \"Invalid character s[%d]='%c'\", i+1, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == n, \"Length of s (%d) is not equal to n (%d)\", int(s.length()), n);\n    for(int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref(c == 'A' || c == 'C' || c == 'G' || c == 'T', \"Invalid character s[%d]='%c'\", i+1, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'A'); // Initialize s with 'A's\n\n    if (type == \"random\") {\n        // Generate a random DNA sequence\n        string DNA = \"ACGT\";\n        for(int i = 0; i < n; ++i)\n            s[i] = DNA[rnd.next(4)];\n    } else if (type == \"all_same\") {\n        // Generate a sequence with all characters the same\n        char c = \"ACGT\"[rnd.next(4)];\n        s = string(n, c);\n    } else if (type == \"two_chars\") {\n        // Generate a sequence alternating between two characters\n        char c1 = \"ACGT\"[rnd.next(4)];\n        char c2 = \"ACGT\"[rnd.next(4)];\n        while (c2 == c1) c2 = \"ACGT\"[rnd.next(4)];\n        for(int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0 ? c1 : c2);\n    } else if (type == \"repeating_k\") {\n        // Generate a sequence with a repeating pattern of length k\n        int k = opt<int>(\"k\", 1);\n        if(k > n) k = n;\n        string pattern;\n        string DNA = \"ACGT\";\n        for(int i = 0; i < k; ++i)\n            pattern += DNA[rnd.next(4)];\n        for(int i = 0; i < n; ++i)\n            s[i] = pattern[i % k];\n    } else if (type == \"palindrome\") {\n        // Generate a palindromic sequence\n        string DNA = \"ACGT\";\n        for(int i = 0; i < (n + 1) / 2; ++i) {\n            char c = DNA[rnd.next(4)];\n            s[i] = s[n - i - 1] = c;\n        }\n    } else {\n        // Default to random if type is unrecognized\n        string DNA = \"ACGT\";\n        for(int i = 0; i < n; ++i)\n            s[i] = DNA[rnd.next(4)];\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, 'A'); // Initialize s with 'A's\n\n    if (type == \"random\") {\n        // Generate a random DNA sequence\n        string DNA = \"ACGT\";\n        for(int i = 0; i < n; ++i)\n            s[i] = DNA[rnd.next(4)];\n    } else if (type == \"all_same\") {\n        // Generate a sequence with all characters the same\n        char c = \"ACGT\"[rnd.next(4)];\n        s = string(n, c);\n    } else if (type == \"two_chars\") {\n        // Generate a sequence alternating between two characters\n        char c1 = \"ACGT\"[rnd.next(4)];\n        char c2 = \"ACGT\"[rnd.next(4)];\n        while (c2 == c1) c2 = \"ACGT\"[rnd.next(4)];\n        for(int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0 ? c1 : c2);\n    } else if (type == \"repeating_k\") {\n        // Generate a sequence with a repeating pattern of length k\n        int k = opt<int>(\"k\", 1);\n        if(k > n) k = n;\n        string pattern;\n        string DNA = \"ACGT\";\n        for(int i = 0; i < k; ++i)\n            pattern += DNA[rnd.next(4)];\n        for(int i = 0; i < n; ++i)\n            s[i] = pattern[i % k];\n    } else if (type == \"palindrome\") {\n        // Generate a palindromic sequence\n        string DNA = \"ACGT\";\n        for(int i = 0; i < (n + 1) / 2; ++i) {\n            char c = DNA[rnd.next(4)];\n            s[i] = s[n - i - 1] = c;\n        }\n    } else {\n        // Default to random if type is unrecognized\n        string DNA = \"ACGT\";\n        for(int i = 0; i < n; ++i)\n            s[i] = DNA[rnd.next(4)];\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type all_same\n./gen -n 1 -type two_chars\n./gen -n 1 -type palindrome\n\n./gen -n 2 -type random\n./gen -n 2 -type all_same\n./gen -n 2 -type two_chars\n./gen -n 2 -type palindrome\n\n./gen -n 5 -type random\n./gen -n 5 -type all_same\n./gen -n 5 -type two_chars\n./gen -n 5 -type palindrome\n\n./gen -n 100 -type random\n./gen -n 100 -type all_same\n./gen -n 100 -type two_chars\n./gen -n 100 -type repeating_k -k 2\n./gen -n 100 -type repeating_k -k 3\n./gen -n 100 -type palindrome\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_same\n./gen -n 1000 -type two_chars\n\n./gen -n 10000 -type random\n./gen -n 10000 -type all_same\n./gen -n 10000 -type two_chars\n./gen -n 10000 -type repeating_k -k 4\n./gen -n 10000 -type repeating_k -k 10\n./gen -n 10000 -type palindrome\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_same\n./gen -n 100000 -type two_chars\n./gen -n 100000 -type repeating_k -k 1000\n./gen -n 100000 -type repeating_k -k 10000\n./gen -n 100000 -type palindrome\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:02.892821",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "520/D",
      "title": "D. Cubes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number m (2 ≤ m ≤ 105).The following m lines contain the coordinates of the cubes xi, yi ( - 109 ≤ xi ≤ 109, 0 ≤ yi ≤ 109) in ascending order of numbers written on them. It is guaranteed that the original figure is stable.No two cubes occupy the same place.",
      "output_spec": "OutputIn the only line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy32 11 00 1OutputCopy19InputCopy50 00 10 20 30 4OutputCopy2930",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number m (2 ≤ m ≤ 105).The following m lines contain the coordinates of the cubes xi, yi ( - 109 ≤ xi ≤ 109, 0 ≤ yi ≤ 109) in ascending order of numbers written on them. It is guaranteed that the original figure is stable.No two cubes occupy the same place.\n\nOutputIn the only line print the answer to the problem.\n\nInputCopy32 11 00 1OutputCopy19InputCopy50 00 10 20 30 4OutputCopy2930\n\nInputCopy32 11 00 1\n\nOutputCopy19\n\nInputCopy50 00 10 20 30 4\n\nOutputCopy2930",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Hello, Codeforces!On March, 2nd at 10:00 MSK Codeforces Round #295 will be held in both divisions.The round will be held at the same time with Winter Computer Camp olympiad, the problemsets will be highly similar. The problems are by me (Endagorion) and Evgeny Savinov (savinov). The problems are prepared by members of the Winter Computer Camp technical committee: Georgy Chebanov (gchebanov), Filipp Rukhovich (DPR-pavlin), Alexander Mashrabov (map), Sergey Kiyan (sokian), Konstantin Semenov (zemen), Kinan Alsarmini (Sarkin).Big thanks to Max Akhmedov (Zlobober) for his help with preparing the problems, Maria Belova (Delinur) for translating the statements in English, and Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon systems.The scoring is standard for both divisions: 500-1000-1500-2000-2500.Please note that the Winter Computing Camp olympiad is scheduled to finish later than the Codeforces round. Thus, we ask you not to discuss the problems and solutions in the comments until 14:10 MSK. Also, viewing of other participants' solutions will be closed until that time. The editorial will also be published later.UPD: you are free to discuss the problems now.UPD2: the editorial is finally up! Sorry for the delay.Also, grats to our Div.1 winners: Petr hos.lyric Syloviaely andrew.volchek xyz111 Special respect goes to Petr and rng_58 for solving the hardest problem E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1403
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces",
          "content": "We would like to thank the testers of this round's and Winter Computer Camp olympiad's problems: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Make sure to comment if you find any mistakes.UPD: I've just remembered to put up the usual challenges for the problems. So, here they go.520A - PangramIdea: EndagorionPreparation: EndagorionTo check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE. In the end check that there are 26 TRUEs. That is an O(n) solution. Also don't forget to change all letters to lowercase (or all to uppercase). To make all the letters lowercase, one could use standard functions, like tolower in Python. Also, it is known that the letters from a to z have consecutive ASCII numbers, as well as A to Z; an ASCII number of symbol is ord(c) in most languages. So, to get the number of a lowercase letter in the alphabet one can use ord(c) - ord('a') in most languages, or simply c - 'a' in C++ or C (because a char in C/C++ can be treated as a number); to check if a letter is lowercase, the inequality ord('a') <= ord(c) && ord(c) <= ord('z') should be checked.Challenge: how many pangrams of length n are there? Strings that differ only in capitalization of some letters are considered distinct. Can you find the answer modulo some prime p in linear time?520B - Two ButtonsIdea: EndagorionPreparation: EndagorionThe simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2·104 vertices and 4·104 edges, and the BFS should work real fast.There is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".Suppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in .Challenge: suppose we have a generalized problem: we want to get n starting from m using two operations \"subtract a\" and \"multiply by b\". Generalize the solution to find the minimal number of moves to get from n to m in time if a and b are coprime. Can you do it if a and b may have common divisors greater than 1?520C - DNA Alignment/521A - DNA AlignmentIdea: EndagorionPreparation: EndagorionWhat is ρ(s, t) equal to? For every character of s and every character of t there is a unique cyclic shift of t that superposes these characters (indeed, after 0, ..., n - 1 shifts the character in t occupies different positions, and one of them matches the one of the character of s); therefore, there exist n cyclic shifts of s and t that superpose these characters (the situation is symmetrical for every position of the character of s). It follows that the input in ρ from a single character ti is equal to n × (the number of characters in s equal to ti). Therefore, ρ(s, t) is maximal when every character of t occurs the maximal possible number of times in s. Simply count the number of occurences for every type of characters; the answer is Kn, where K is the number of character types that occur in s most frequently. This is an O(n) solution.Challenge: we know that ρmax(s) = n2·C(s), where C(s) is the maximal number that any character occurs in s. How many strings s of length n with characters from an alphabet of size k have C(s) = m? Can you find an O(kn2) solution? An solution? An solution? Maybe even better? (Hint: the modulo should be an appropriately chosen prime number for a fast solution =)).520D - Cubes/521B - CubesIdea: savinovPreparation: savinov, sokian, zemenBasically, the first player should maximize the lexicographical order of numbers, and the second player should minimize it. Thus, at every move the first player should choose the largest available number, and the second should choose the minimal one.First of all, how do we check if the cube can be removed? It is impossible only if there is some cube \"supported\" by it (i.e., it has coordinates (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)) such that our cube is the only one supporting it. This can be checked explicitly. The large coordinates' limitations do not allow us to store a simply array for that, so we should use an associative array, like a set in C++.Now we should find the maximal/minimal number that can be removed. A simple linear search won't work fast enough, so we store another data structure containing all numbers available to remove; the structure should allow inserting, erasing and finding global minimum/maximum, so the set C++ structure fits again.When we've made our move, some cubes may have become available or unavailable to remove. However, there is an O(1) amount of cubes we have to recheck and possibly insert/erase from our structure: the cubes (x ± 1, y) and (x ± 2, y) may have become unavailable because some higher cube has become dangerous (that is, there is a single cube supporting it), and some of the cubes (x - 1, y - 1), (x, y - 1) and (x + 1, y - 1) may have become available because our cube was the only dangerous cube that it has been supporting. Anyway, a simple recheck for these cubes will handle all the cases.This solution is if using the appropriate data structure.Challenge (inspired by questions from jk_qq and RetiredAmrMahmoud): suppose that the players put the numbers from right to left, that is, from the least significant digit to the most significant. The first player still wants to maximize the resulting number, and the second wants to minimize it. If the original rules of taking cubes apply, finding the optimal strategy for the players seems intractable. Try to solve this problem in the case where all the cubes are stacked in several independent towers; that is, a cube may only be taken from the top of any tower.520E - Pluses everywhere/521C - Pluses everywhereIdea: EndagorionPreparation: gchebanov, DPR-pavlinConsider some way of placing all the pluses, and a single digit di (digits in the string are numbered starting from 0 from left to right). This digit gives input of di·10l to the total sum, where l is the distance to the nearest plus from the right, or to the end of string if there are no pluses there. If we sum up these quantities for all digits and all ways of placing the pluses, we will obtain the answer.For a given digit di and some fixed l, how many ways are there to place the pluses? First of all, consider the case when the part containing the digit di is not last, that is, i + l < n - 1. There are n - 1 gaps to place pluses in total; the constraint about di and the distance l means that after digits di, ..., di + l - 1 there are no pluses, while after the digit di + l there should be a plus. That is, the string should look as follows: Here a dot means a gap without a plus, and a question mark means that it's not important whether there is a plus or not. So, out of n - 1 possible gaps there are l + 1 gaps which states are defined, and there is one plus used in these gaps. That means that the other (n - 1) - (l + 1) = n - l - 2 gaps may contain k - 1 pluses in any possible way; that is, the number of such placements is . A similar reasoning implies that if the digit di is in the last part, that is, i + l = n - 1, the number of placements is .To sum up, the total answer is equal to Let us transform the sum: To compute these sums, we will need to know all powers of 10 up to n-th (modulo 109 + 7), along with the binomial coefficients. To compute the binomials, recall that , so it is enough to know all the numbers k! for k upto n, along with their modular inverses. Also we should use the prefix sums of di, that is, the array . The rest is simple evaluation of the above sums.The total complexity is , because the common algorithms for modular inverses (that is, Ferma's little theorem exponentiation or solving a diophantine equation using the Euclid's algorithm) have theoritcal worst-case complexity of . However, one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O(n); for the description of the method refer to this comment by Kaban-5 (not sure why it has a negative rating, I found this quite insightful; maybe anyone can give a proper source for this method?).Challenge: now we want to find the sum of all expressions that are made by placing k pluses with a ≤ k ≤ b; that is, we want to find the sum of the answers for the original problem with k = a, ..., b; here a and b can be any integers with 0 ≤ a ≤ b ≤ n - 1. There is an obvious O(n2) solution: just find the answers for all k separately. Can you find a linear solution?521D - ShopIdea: EndagorionPreparation: gchebanovSuppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.Now we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a + b1 + ... + bi - 1 to a + b1 + ... + bi - 1 + bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.Finally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.To deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a + b1 + ... + bk to b + b1 + ... + bk. That is, the assignment here behaves pretty much the same way as the addition of b - a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.That is, all largest assigments for each skill should be made into additions of b - a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)Finally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions and we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.Challenge: suppose that you have to compare two fractions and , where a, b, c, d may be up to 1018. What way would you use to do that? Can you find a simple solution that does not involve long arithmetics, floating-point number or magic built-in integer types tricks (but may perform a non-constant number of operations)?521E - Cycling CityIdea: EndagorionPreparation: EndagorionWe have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.First of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.Now, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.Otherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.What if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.Finally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n + m) solution; a few logarithmic factors for simplification here and there are also allowed.Challenge: how many graphs G on n labeled vertices exist such that there exist two vertices of G connected by three disjoint paths? (Hint: we have already shown that it suffices to count the number of disjoint unions of cacti.) Find the answer modulo 109 + 7. Can you come up with any polynomial-time solution? An O(n3) solution? Maybe even better?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 520\\s*D"
          },
          "content_length": 16554
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 100000);\n    inf.readEoln();\n    set<pair<long long, long long>> positions;\n    vector<pair<long long, long long>> cubes;\n    for (int i = 0; i < m; i++) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL);\n        inf.readSpace();\n        long long yi = inf.readLong(0LL, 1000000000LL);\n        inf.readEoln();\n        // Check for uniqueness of positions\n        ensuref(positions.count({xi, yi}) == 0, \"Two cubes occupy the same position (%lld, %lld)\", xi, yi);\n        positions.insert({xi, yi});\n        cubes.push_back({xi, yi});\n    }\n    // Now check stability\n    for (int i = 0; i < m; i++) {\n        long long xi = cubes[i].first;\n        long long yi = cubes[i].second;\n        if (yi == 0) {\n            continue; // On the ground\n        } else {\n            // Check if there is a cube at (xi -1, yi -1), (xi, yi -1), or (xi +1, yi -1)\n            bool has_support = false;\n            if (positions.count({xi -1, yi -1})) has_support = true;\n            if (positions.count({xi, yi -1})) has_support = true;\n            if (positions.count({xi +1, yi -1})) has_support = true;\n            ensuref(has_support, \"Cube at (%lld, %lld) is unsupported\", xi, yi);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 100000);\n    inf.readEoln();\n    set<pair<long long, long long>> positions;\n    vector<pair<long long, long long>> cubes;\n    for (int i = 0; i < m; i++) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL);\n        inf.readSpace();\n        long long yi = inf.readLong(0LL, 1000000000LL);\n        inf.readEoln();\n        // Check for uniqueness of positions\n        ensuref(positions.count({xi, yi}) == 0, \"Two cubes occupy the same position (%lld, %lld)\", xi, yi);\n        positions.insert({xi, yi});\n        cubes.push_back({xi, yi});\n    }\n    // Now check stability\n    for (int i = 0; i < m; i++) {\n        long long xi = cubes[i].first;\n        long long yi = cubes[i].second;\n        if (yi == 0) {\n            continue; // On the ground\n        } else {\n            // Check if there is a cube at (xi -1, yi -1), (xi, yi -1), or (xi +1, yi -1)\n            bool has_support = false;\n            if (positions.count({xi -1, yi -1})) has_support = true;\n            if (positions.count({xi, yi -1})) has_support = true;\n            if (positions.count({xi +1, yi -1})) has_support = true;\n            ensuref(has_support, \"Cube at (%lld, %lld) is unsupported\", xi, yi);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 100000);\n    inf.readEoln();\n    set<pair<long long, long long>> positions;\n    vector<pair<long long, long long>> cubes;\n    for (int i = 0; i < m; i++) {\n        long long xi = inf.readLong(-1000000000LL, 1000000000LL);\n        inf.readSpace();\n        long long yi = inf.readLong(0LL, 1000000000LL);\n        inf.readEoln();\n        // Check for uniqueness of positions\n        ensuref(positions.count({xi, yi}) == 0, \"Two cubes occupy the same position (%lld, %lld)\", xi, yi);\n        positions.insert({xi, yi});\n        cubes.push_back({xi, yi});\n    }\n    // Now check stability\n    for (int i = 0; i < m; i++) {\n        long long xi = cubes[i].first;\n        long long yi = cubes[i].second;\n        if (yi == 0) {\n            continue; // On the ground\n        } else {\n            // Check if there is a cube at (xi -1, yi -1), (xi, yi -1), or (xi +1, yi -1)\n            bool has_support = false;\n            if (positions.count({xi -1, yi -1})) has_support = true;\n            if (positions.count({xi, yi -1})) has_support = true;\n            if (positions.count({xi +1, yi -1})) has_support = true;\n            ensuref(has_support, \"Cube at (%lld, %lld) is unsupported\", xi, yi);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> cubes(m);\n\n    if (type == \"tower\") {\n        // Vertical tower at x = 0\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(0, i);\n        }\n    } else if (type == \"flat\") {\n        // All cubes on the ground level y = 0\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(i, 0);\n        }\n    } else if (type == \"pyramid\") {\n        // Pyramid shape\n        int cubesPlaced = 0;\n        int level = 0;\n        while (cubesPlaced < m) {\n            int numAtLevel = 2 * level + 1;\n            for (int i = 0; i < numAtLevel && cubesPlaced < m; ++i) {\n                int x = -level + i;\n                int y = level;\n                cubes[cubesPlaced++] = make_pair(x, y);\n            }\n            level++;\n        }\n    } else if (type == \"max_coordinates\") {\n        // Cubes with maximum coordinates\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(1000000000, i);\n        }\n    } else if (type == \"min_coordinates\") {\n        // Cubes with minimum coordinates\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(-1000000000, i);\n        }\n    } else if (type == \"negative_coordinates\") {\n        // Cubes with negative x positions\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(-i, i);\n        }\n    } else if (type == \"random\") {\n        // Random cubes satisfying stability condition\n        set<pair<int, int>> occupied; // to avoid duplicates\n        vector<pair<int, int>> currentLayer; // positions at current level\n        vector<pair<int, int>> nextLayer;\n\n        // Place some cubes at y = 0\n        int baseCubes = rnd.next(1, min(m, 1000));\n        for (int i = 0; i < baseCubes; ++i) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (occupied.count(make_pair(x, 0)));\n            occupied.insert(make_pair(x, 0));\n            currentLayer.push_back(make_pair(x, 0));\n        }\n        int cubesPlaced = 0;\n        for (auto pos : currentLayer) {\n            cubes[cubesPlaced++] = pos;\n            if (cubesPlaced == m) break;\n        }\n\n        // Build up layers\n        while (cubesPlaced < m) {\n            nextLayer.clear();\n            for (auto pos : currentLayer) {\n                int x = pos.first;\n                int y = pos.second;\n\n                // Try to place cubes above current cube\n                for (int dx = -1; dx <= 1; ++dx) {\n                    if (rnd.next(0, 1)) {\n                        int newX = x + dx;\n                        int newY = y + 1;\n                        if (occupied.count(make_pair(newX, newY)))\n                            continue;\n                        occupied.insert(make_pair(newX, newY));\n                        nextLayer.push_back(make_pair(newX, newY));\n                        cubes[cubesPlaced++] = make_pair(newX, newY);\n                        if (cubesPlaced == m)\n                            break;\n                    }\n                }\n                if (cubesPlaced == m)\n                    break;\n            }\n            if (nextLayer.empty())\n                break; // No more layers can be built\n            currentLayer = nextLayer;\n        }\n\n        // Fill remaining cubes at y = 0 if necessary\n        while (cubesPlaced < m) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (occupied.count(make_pair(x, 0)));\n            occupied.insert(make_pair(x, 0));\n            cubes[cubesPlaced++] = make_pair(x, 0);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output cubes in order from 0 to m - 1\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", cubes[i].first, cubes[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int,int>> cubes(m);\n\n    if (type == \"tower\") {\n        // Vertical tower at x = 0\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(0, i);\n        }\n    } else if (type == \"flat\") {\n        // All cubes on the ground level y = 0\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(i, 0);\n        }\n    } else if (type == \"pyramid\") {\n        // Pyramid shape\n        int cubesPlaced = 0;\n        int level = 0;\n        while (cubesPlaced < m) {\n            int numAtLevel = 2 * level + 1;\n            for (int i = 0; i < numAtLevel && cubesPlaced < m; ++i) {\n                int x = -level + i;\n                int y = level;\n                cubes[cubesPlaced++] = make_pair(x, y);\n            }\n            level++;\n        }\n    } else if (type == \"max_coordinates\") {\n        // Cubes with maximum coordinates\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(1000000000, i);\n        }\n    } else if (type == \"min_coordinates\") {\n        // Cubes with minimum coordinates\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(-1000000000, i);\n        }\n    } else if (type == \"negative_coordinates\") {\n        // Cubes with negative x positions\n        for (int i = 0; i < m; ++i) {\n            cubes[i] = make_pair(-i, i);\n        }\n    } else if (type == \"random\") {\n        // Random cubes satisfying stability condition\n        set<pair<int, int>> occupied; // to avoid duplicates\n        vector<pair<int, int>> currentLayer; // positions at current level\n        vector<pair<int, int>> nextLayer;\n\n        // Place some cubes at y = 0\n        int baseCubes = rnd.next(1, min(m, 1000));\n        for (int i = 0; i < baseCubes; ++i) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (occupied.count(make_pair(x, 0)));\n            occupied.insert(make_pair(x, 0));\n            currentLayer.push_back(make_pair(x, 0));\n        }\n        int cubesPlaced = 0;\n        for (auto pos : currentLayer) {\n            cubes[cubesPlaced++] = pos;\n            if (cubesPlaced == m) break;\n        }\n\n        // Build up layers\n        while (cubesPlaced < m) {\n            nextLayer.clear();\n            for (auto pos : currentLayer) {\n                int x = pos.first;\n                int y = pos.second;\n\n                // Try to place cubes above current cube\n                for (int dx = -1; dx <= 1; ++dx) {\n                    if (rnd.next(0, 1)) {\n                        int newX = x + dx;\n                        int newY = y + 1;\n                        if (occupied.count(make_pair(newX, newY)))\n                            continue;\n                        occupied.insert(make_pair(newX, newY));\n                        nextLayer.push_back(make_pair(newX, newY));\n                        cubes[cubesPlaced++] = make_pair(newX, newY);\n                        if (cubesPlaced == m)\n                            break;\n                    }\n                }\n                if (cubesPlaced == m)\n                    break;\n            }\n            if (nextLayer.empty())\n                break; // No more layers can be built\n            currentLayer = nextLayer;\n        }\n\n        // Fill remaining cubes at y = 0 if necessary\n        while (cubesPlaced < m) {\n            int x;\n            do {\n                x = rnd.next(-1000000000, 1000000000);\n            } while (occupied.count(make_pair(x, 0)));\n            occupied.insert(make_pair(x, 0));\n            cubes[cubesPlaced++] = make_pair(x, 0);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        return 1;\n    }\n\n    // Output m\n    printf(\"%d\\n\", m);\n\n    // Output cubes in order from 0 to m - 1\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d %d\\n\", cubes[i].first, cubes[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small m, testing minimal case\n./gen -m 2 -type flat\n./gen -m 2 -type tower\n./gen -m 2 -type random\n\n# Medium m, testing various types\n./gen -m 10 -type flat\n./gen -m 10 -type tower\n./gen -m 10 -type pyramid\n./gen -m 10 -type random\n\n# Test with negative coordinates\n./gen -m 100 -type negative_coordinates\n\n# Test with maximum coordinates\n./gen -m 100 -type max_coordinates\n\n# Test with minimum coordinates\n./gen -m 100 -type min_coordinates\n\n# Larger m to test performance and edge cases\n./gen -m 1000 -type flat\n./gen -m 1000 -type tower\n./gen -m 1000 -type pyramid\n./gen -m 1000 -type random\n\n# Test maximum m\n./gen -m 100000 -type flat\n./gen -m 100000 -type tower\n./gen -m 100000 -type pyramid\n\n# Random test cases with maximum m\n./gen -m 100000 -type random\n\n# Edge case with maximum coordinates and maximum m\n./gen -m 100000 -type max_coordinates\n\n# Edge case with minimum coordinates and maximum m\n./gen -m 100000 -type min_coordinates\n\n# Test with cubes having negative x and y coordinates\n./gen -m 10000 -type negative_coordinates\n\n# Mixed random test cases\n./gen -m 50000 -type random\n./gen -m 75000 -type random\n\n# Test with m not a perfect square for pyramid\n./gen -m 12345 -type pyramid\n\n# Extremely tall tower\n./gen -m 100000 -type tower\n\n# Wide flat figure\n./gen -m 100000 -type flat\n\n# Random positions to test stability conditions\n./gen -m 20000 -type random\n\n# Additional random test cases to cover more possibilities\n./gen -m 33333 -type random\n./gen -m 66666 -type random\n./gen -m 99999 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:04.536626",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "520/E",
      "title": "E. Сплошные плюсы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано два целых числа n и k (0 ≤ k < n ≤ 105).Во второй строке записана строка, состоящая из n цифр.",
      "output_spec": "Выходные данныеВыведите ответ на задачу по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать3 1108Выходные данныеСкопировать27Входные данныеСкопировать3 2108Выходные данныеСкопировать9",
      "description": "E. Сплошные плюсы\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записано два целых числа n и k (0 ≤ k < n ≤ 105).Во второй строке записана строка, состоящая из n цифр.\n\nВходные данные\n\nВыходные данныеВыведите ответ на задачу по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать3 1108Выходные данныеСкопировать27Входные данныеСкопировать3 2108Выходные данныеСкопировать9\n\nВходные данныеСкопировать3 1108\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать27\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3 2108\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать9\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере результат равен (1 + 08) + (10 + 8) = 27.Во втором примере результат равен 1 + 0 + 8 = 9.",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Привет, Codeforces!2 марта в 10:00 MSK состоится раунд #295 для участников из обоих дивизионов.Раунд состоится практически одновременно с олимпиадой Зимней Компьютерной Школы на схожем комплекте задач. Авторы задач — я (Endagorion) и Евгений Савинов (savinov). В подготовке задач принимали участие члены технического комитета Зимней Компьютерной школы: Георгий Чебанов (gchebanov), Филипп Рухович (DPR-pavlin), Александр Машрабов (map), Сергей Киян (sokian), Константин Семенов (zemen), Кинан Альсармини (Sarkin).Спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский язык, Михаилу Мирзаянову (MikeMirzayanov) за вклад в развитие программирования путем создания систем Codeforces и Polygon.Разбалловка в обоих дивизионах стандартная: 500-1000-1500-2000-2500.Обратите внимание, что поскольку олимпиада ЗКШ на похожих задачах заканчивается позже раунда Codeforces, мы просим вас не обсуждать в комментариях задачи и решения до 14:10 MSK сегодняшнего дня. Также до этого времени будет закрыт просмотр кода других участников. Разбор также появится после этого времени.UPD: все, можно обсуждать. =)UPD2: наконец появился разбор ( теперь и на русском!).Также поздравляем победителей в Div.1: Petr hos.lyric Syloviaely andrew.volchek xyz111 Отдельно поздравляем Petr и rng_58, решивших самую сложную задачу E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1370
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces",
          "content": "Мы хотели бы также поблагодарить тестеров задач этого раунда и олимпиады ЗКШ: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Пожалуйста, пишите в комментариях о найденных ошибках.UPD: я вспомнил, что забыл написать регулярные бонусные челленджи. Так что вот, пожалуйста.520A - ПанграммаИдея:EndagorionПодготовка:EndagorionЧтобы проверить, что все буквы присутствуют, заведем массив длины 26 и для каждой буквы поставим в соответствующую ячейку единичку. В конце надо проверить, что все 26 единичек на месте. Решение работает за O(n). Также надо не забыть перевести все буквы к нижнему регистру (или наоборот, все буквы к верхнему).Чтобы перевести буквы в нижний регистр, можно использовать встроенные функции, например, tolower в Python. Также можно пользоваться тем, что буквы от a до z идут подряд по их ASCII-номерам; ASCII-номер для символа можно получить при помощи ord(c) во многих языках. Теперь, чтобы получить номер буквы в алфавите, надо написать ord(c) - ord('a'), а на C++ или C просто c - 'a' (поскольку в C/C++ символ — это число, равное его ASCII-номеру). Также, например, чтобы проверить, что буква имеет нижний регистр, надо написать неравенство ord('a') <= ord(c) && ord(c) <= ord('z').Challenge: сколько существует различных панграмм длины n? Строки, отличающиеся капитализацией некоторых символов, считаются различными. Сможете ли вы придумать линейное по времени решение?520B - Две кнопкиИдея: EndagorionПодготовка: EndagorionСамое простое решение — просто запустить обход в ширину. Построим граф, в котором вершины — числа, а ребра ведут из одного числа в другое, если можно получить второе из первого за одну операцию. Можно заметить, что первое число никогда не выгодно делать больше, чем 2m, поэтому в графе будет не больше 2·104 вершин и 4·104 ребер, и BFS сработает очень быстро.Однако, есть решение гораздо быстрее. Развернем задачу: изначально у нас есть число m, и мы хотим получить число n, пользуясь операциями \"прибавить к числу 1\" и \"поделить число на 2, если оно четно\".Пускай мы в какой-то момент применили две операции типа 1, и потом операцию типа 2; но эти три операции можно заменить на две: сначала операция типа 2, а потом одна операция типа 1, и количество операций от этого уменьшится. Отсюда следует, что применять больше одной операции типа 1 имеет смысл только тогда, когда операций типа 2 больше не будет, то есть, когда n меньше m и осталось сделать несколько прибавлений, чтобы их сравнять. На самом деле, теперь существует ровно одна последовательность операций, удовлетворяющая таким требованиям: если n меньше m, прибавляем единички пока нужно, иначе если n четно, делим на 2, а если нечетно, прибавляем 1 и потом делим на 2. Количество операций в такой последовательности можно найти за время .Challenge: рассмотрим обобщенную задачу: мы хотим получить число n из числа m с помощью операций двух типов \"отнять a\" и \"умножить на b\". Обобщите решение исходной задачи и научитесь находить минимальное количество операций за время в случае, если a и b взаимно просты. Справитесь ли вы, если у a и b могут быть нетривиальные общие делители?520C - Выравнивание ДНК/521A - Выравнивание ДНКИдея: EndagorionПодготовка: EndagorionЧто это за функция — ρ(s, t)? Для каждого символа t и каждого символа s существует ровно один циклический сдвиг, который их совмещает (действительно, после 0, ..., n - 1 сдвигов символ t пробежит все возможные положения в строке, и ровно одно из них — это положение символа из s); поэтому, существует ровно n способов циклически сдвинуть s и t, при которых выбранные символы совместятся (поскольку ситуация симметрична для любого положения символа из s). Таким образом, вклад в ρ, который дает символ ti, равен n × (количество символов s, равных ti). Поэтому ρ(s, t) максимально, когда каждый символ t встречается в s наибольшее количество раз. Посчитаем для каждого символа количество вхождений в s; ответ равен Kn, где K — это количество типов символов, которые встречаются в s чаще всего. Решение за O(n).Challenge: мы знаем, что ρmax(s) = C(s)·n2, где C(s)--- максимальное количество вхождений какого-либо символа. Сколько существует строк s длины n над алфавитом размера k, таких что C(s) = m? Сможете придумать решение за время O(kn2)? За время ? За время ? Может быть, еще быстрее? (Подсказка: для быстрого решения необходим удачно подобранный простой модуль. =))520D - Кубики/521B - КубикиИдея: savinovПодготовка: savinov, sokian, zemenВ эквивалентной формулировке, первый игрок стремится максимизировать лексикографиский порядок последовательности кубиков, а второй игрок — минимизировать его. Поэтому, на каждом шагу первый игрок берет максимальный из доступных кубиков, а второй — минимальный.Сперва научимся проверять, можно ли в текущей ситуации взять некоторый кубик. Его нельзя взять только тогда, когда есть какой-то кубик, который на нем \"стоит\" (т.е. имеет координаты (x - 1, y + 1), (x, y + 1) или (x + 1, y + 1)), и наш кубик является единственным, на котором он стоит. Это условие можно явно проверить. Из-за больших координат это не получится сделать путем простых обращений к массиву, поэтому придется завести ассоциативный массив, например, в C++ можно воспользоваться set.Теперь надо научиться находить максимальный/минимальный кубик среди доступных. Просто линейный проход — это слишком долго, поэтому заведем еще одну структуру, в которой будем хранить номера доступных кубиков. Структура должна уметь добавлять, удалять, а также искать максимум/минимум, так что что-нибудь вроде set нам снова подойдет.После того, как ход сделан, какие-то кубики могли стать доступными или, наоборот, перестать быть доступными. Однако, после каждого хода состояние могло поменяться только для O(1) кубиков: кубики (x ± 1, y) и (x ± 2, y) могли стать недоступными, потому что какой-то из кубиков выше стал опасным (т.е., остался один кубик, на котором он держится), и еще какие-то из кубиков (x - 1, y - 1), (x, y - 1) и (x + 1, y - 1) могли сделаться доступными, потому что единственный опасный кубик, который на них стоял, был удален. В любом случае, для всех них надо просто заново сделать проверку, и про случаи можно особо не думать.Решение с подходящей структурой работает за .Challenge (по мотивам вопросов от jk_qq и RetiredAmrMahmoud): пусть теперь кубики выкладываются в ряд справа налево, т.е. от младших разрядов к старшим. Первый игрок все так же хочет максимизировать итоговое число, второй — минимизировать его. Если оставить правила убирания кубиков такими же, в общем случае задача не выглядит решаемой. Попробуйте решить новую задачу в случае, когда кубики выстроены в несколько независимых башен, т.е. кубик можно убрать, если он находится на вершине своей башни.520E - Сплошные плюсы/521C - Сплошные плюсыИдея: EndagorionПодготовка: gchebanov, DPR-pavlinРассмотрим какой-нибудь способ расставить плюсы, а также какую-то цифру di (цифры пронумеруем с нуля слева направо). Эта цифра дает вклад в сумму чисел, равный di·10l, где l — расстояние до ближайшего плюса справа или до конца строки, если справа нет плюсов. Если просуммировать эти значения по всем цифрам и по всем способам расставить плюсы, получим в точности ответ.Сколько существует способов расставить плюсы для выбранной цифры di и какого-то фиксированного l? Во-первых, рассмотрим случай, когда при разбиении по плюсам часть, содержащая цифру di, не является последней, т.е., i + l < n - 1. Всего существует n - 1 позиция, куда можно ставить плюсы; ограничение, связанное с цифрой di и расстоянием l, означает, что после цифр di, ..., di + l - 1 плюсов не стоит, а после цифры di + l плюс стоит. Иными словами, строка выглядит примерно так: На рисунке точка означает отсутствие плюса, а вопросик значит, что неважно, стоит там плюс или нет. Видно, что из n - 1 возможных позиций для плюсов состояния (l + 1)-ой позиции определены, и среди них использован только один плюс. Это значит, что в остальные (n - 1) - (l + 1) = n - l - 2 надо поставить k - 1 плюс любым из способов; значит, искомое количество способов равно . Рассуждая схожим образом, получим, что если цифра di входит в последнюю часть (т.е. i + l = n - 1), количество способов равно .В итоге получаем, что ответ равен Преобразуем: Чтобы посчитать такие суммы, нам надо предпосчитать все степени 10 до n-ой (по модулю 109 + 7), а также биномиальные коэффициенты. Чтобы их посчитать, вспомним, что , поэтому достаточно вычислить все k! для k вплоть до n, а также их обратные значения по модулю. Помимо этого, нам пригодится массив префиксных сумм для цифр di, т.е., значения . Осталось просто просуммировать произведения этих величин.В итоге получили решение за , поскольку стандартные алгоритмы для поиска обратных по модулю (а именно, малая теорема Ферма с бинарным возведением в степень и решение диофантова уравнения при помощи обобщенного алгоритма Евклида) имеют верхнюю оценку сложности . Однако, можно воспользоваться интересным трюком и вычислить все обратные элементы для первых n чисел за линейное время, после чего итоговоая сложность решения становится O(n); почитать про интересный трюк можно в комментарии от Kaban-5 (непонятно, почему он заминусован; может быть, кто-то вспомнит ссылку на более фундаментальный источник для этого метода?).Challenge: теперь мы хотим посчитать сумму всех выражений, в которых расставлено k плюсов для всех k от a до b; т.е. мы хотим просуммировать ответы для исходной задачи по всем k = a, ..., b. Числа a и b любые, такие что 0 ≤ a ≤ b ≤ n - 1. Решение за O(n2) очевидно: для каждого k посчитаем ответ отдельно. Сможете ли вы придумать решение за линейное время?521D - Магазин Идея: EndagorionПодготовка: gchebanovПусть у нас есть только умножения. Тогда нам даже не важно, в каком порядке их применять, надо просто брать несколько апгрейдов с максимальным bi.Теперь рассмотрим также прибавления, а про умножения временно забудем. Ясно, что для каждого скилла надо взять несколько максимальных прибавлений (возможно, ни одного). Для каждого скилла отсортируем прибавления по невозрастанию bi; теперь для каждого скилла надо взять несколько первых апгрейдов. Итак, теперь для выбранного скилла есть невозрастающая последовательность прибавлений b1, ..., bl, и начальное значение скилла равно какому-то a. Раз мы решили взять некоторый префикс массива b, это значит, что когда мы берем апгрейд bi, значение скилла увеличивается с a + b1 + ... + bi - 1 до a + b1 + ... + bi - 1 + bi. Иными словами, значение, на которое домножится значение скилла (а значит, и все произвдение значений скиллов), равно дроби . Теперь, когда это отношение однозначно определилось для каждого прибавления, мы можем считать любое прибавление умножением. =) Теперь посчитаем такие отношения для всех прибавлений (т.е., отсортируем b-шки для каждого скилла по отдельности и найдем значения всех дробей), и затем посортируем умножения и прибавления вместе по тому, во сколько раз они увеличивают итоговый ответ. Ясно, что все умножения надо использовать уже после того, как были сделаны все прибавления; иными словами, для определения того, какие апгрейды брать, мы сортируем их все вместе по их отношениям, но реальный порядок применения должен быть таким: сперва все прибавления, а потом все умножения.Наконец, разберемся с присваиваниями. Очевидно, что для каждого скилла имеет смысл делать не более одного присваивания, и использовать можно только максимальное присваивание для данного скилла. Кроме того, присваивание необходимо делать перед всеми прибавлениями и умножениями. Поэтому, для каждого скилла надо просто определиться, берем мы для него максимальное присваивание или нет. Однако есть проблема с тем, что когда мы сделали присваивание, отношения для прибавлений стали неправильными, поскольку стартовое значение a поменялось.Представим теперь, что мы уже выбрали, какие прибавления мы сделаем, и теперь решаем, брать присваивание или нет. Если мы берем присваивание, то итоговое значение скилла поменяется с a + b1 + ... + bk на b + b1 + ... + bk. Иными словами, присваивание работает примерно так же, как и прибавление значения b - a. Единственная разница в том, что присваивание необходимо ставить раньше всех прибавлений.Итак, переделаем все максимальные присваивания для каждого скилла в прибавления b - a и обработаем их вместе со всеми остальными присваиваниями (которые, как мы знаем, в итоге станут умножениями =)).В итоге, задача свелась к сортировке отношений для всех апгрейдов. Оценим, какие числа у нас будут стоять в дробях. Отношение для умножения — это целое число до 106; отношение для прибавления — это дробь, которая выглядит как . Поскольку k может быть порядка 105, а bi — порядка 106, числитель и знаменатель дроби могут быть порядка 1011. Когда мы сравниваем дроби и , мы сравниваем произведения ad и bc, которые по нашим оценкам могут быть порядка 1022. Это, к сожалению, приводит к переполнению встроенных целочисленных типов во многих языках. Чтобы разобраться с этой проблемой, вычтем из всех дробей единицу (очевидно, на порядок сортировки это не повлияет), и теперь отношения для прибавлений выглядят как . Теперь, числитель стал всего лишь порядка 106, произведения будут порядка 1017, что уже помещается в стандартный 64-битный тип в любом языке.Challenge: пускай нам надо сравнить две дроби и , где числа a, b, c, d могут быть порядка 1018. Каким способом вы бы это сделали? Сможете ли вы придумать простое решение, которое не использует длинную арифметику, вещественные числа или волшебные целочисленные типы, такие как __int128 и им подобные (однако, возможно, совершает неконстантное число операций)?521E - Cycling CityИдея: EndagorionПодготовка: EndagorionНам нужно найти в неориентированном графе две вершины, такие что их можно соединить тремя вершинно и реберно непересекающимися путями. Это легко решалось бы потоком, если бы не большие ограничения.Во-первых, заметим, что все пути между двумя выбранными вершинами должны проходить внутри одной двусвязной компоненты графа. Действительно, любой простой цикл должен целиком лежать внутри одной двусвязной компоненты, а набор из трех путей можно представить как объединение двух пересекающихся циклов. Поэтому, сперва выделим все двусвязные компоненты графа и попытаемся решить задачу независимо в каждой из них. Двусвязные компонентны можно найти за линейное время; хороший алгоритм, который это делает, можно найти в статье по ссылке выше.Теперь, у нас есть двусвязная компонента и та же самая задача. Во-первых, найдем любой цикл в этой компоненте обычным DFS'ом; единственный случай, когда цикл не найдется, — это когда компонента состоит из одного ребра, но это неинтересный случай. Теперь, предположим, что ни из какой вершины цикла не исходит ребра, которое бы не лежало в цикле; в этом случае цикл не связан ни с какой другой вершиной компоненты, поэтому компонента сама по себе является этим циклом; очевидно, что в этом случае решения также нет.В противном случае, возьмем вершину v, из которой исходит ребро e, не лежащее в выбранном цикле (обозначим цикл за c). Если мы сможем найти такой путь p, который начинался бы с ребра e и заканчивался в какой-то вершине из цикла u (отличной от v), мы сможем выделить три непересекающихся пути между u и v: один из них — это p, а два других — половинки исходного цикла. Чтобы найти путь p, запустим DFS, который начинается с ребра e и заканчивается, как только мы приходим в вершину цикла c, отличную от v, а потом восстанавливает все пути для ответа.Что же делать, если такого пути p не найдется? Обозначим за C компоненту, которую обошел этот DFS. У него не получилось найти пути между вершинами из множества C\\ {v} и множества c\\ {v}, поэтому любой путь между этими двумя множествами должен проходить через v. Но тогда оказывается, что если удалить v, компонента C\\ {v} оказывается отделена от вершин из множества c\\ {v}, что противоречит тому, что исходная компонента была двусвязной. Отсюда следует, что тот DFS, который мы запускали из e, всегда найдет подходящий путь p и получит ответ, если наша двусвязная компонента — не цикл и не отдельное ребро.В итоге мы пришли к тому, что ответа нет в единственном случае, когда все двусвязные компоненты — либо отдельные ребра, либо циклы; другими словами, когда граф является несвязным набором кактусов. В противном случае, за пару запусков DFS'ов мы сможем найти три непересекающихся пути. В итоге получилось решение за время O(n + m); для упрощения можно было бы где-нибудь накрутить парочку логарифмов.Challenge: сколько существует графов G, таких что в G можно выбрать две вершины, соединенные тремя непересекающимися путями? (Подсказка: мы знаем, что достаточно посчитать количество несвязных объединений кактусов.) Можете ли вы придумать какое-нибудь полиномиальное по времени решение? Решение за время O(n3)? Возможно, еще быстрее?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 520\\s*E"
          },
          "content_length": 16705
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 9",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 10",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 11",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 12",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 13",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n\n    ensuref((int)s.length() == n, \"Length of string s must be equal to n, but is %d instead\", (int)s.length());\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(isdigit(s[i]), \"All characters in s must be digits, but found '%c' at position %d\", s[i], i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n\n    ensuref((int)s.length() == n, \"Length of string s must be equal to n, but is %d instead\", (int)s.length());\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(isdigit(s[i]), \"All characters in s must be digits, but found '%c' at position %d\", s[i], i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n\n    ensuref((int)s.length() == n, \"Length of string s must be equal to n, but is %d instead\", (int)s.length());\n\n    for (int i = 0; i < n; ++i) {\n        ensuref(isdigit(s[i]), \"All characters in s must be digits, but found '%c' at position %d\", s[i], i + 1);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n    // Ensure constraints\n    assert(1 <= n && n <= 100000);\n    assert(0 <= k && k < n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(0,9) + '0';\n        }\n    } else if (type == \"all_zero\") {\n        s = string(n, '0');\n    } else if (type == \"all_nine\") {\n        s = string(n, '9');\n    } else if (type == \"alternate_zero_nine\") {\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0 ? '0' : '9');\n        }\n    } else if (type == \"leading_zero\") {\n        int num_leading_zeros = rnd.next(1, min(5, n-1));\n        s = string(num_leading_zeros, '0');\n        for (int i = num_leading_zeros; i < n; ++i) {\n            s += rnd.next(1,9) + '0';\n        }\n    } else if (type == \"palindrome\") {\n        string half;\n        int half_len = (n + 1) / 2;\n        for (int i = 0; i < half_len; ++i) {\n            half += rnd.next(0,9) + '0';\n        }\n        s = half;\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            s += half[i];\n        }\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i) {\n            s += (char)('0' + (i % 10));\n        }\n    } else if (type == \"descending\") {\n        for (int i = 0; i < n; ++i) {\n            s += (char)('0' + (9 - (i % 10)));\n        }\n    } else if (type == \"max_digit\") {\n        s = string(n, '9');\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(0,9) + '0';\n        }\n    }\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n    string s;\n    // Ensure constraints\n    assert(1 <= n && n <= 100000);\n    assert(0 <= k && k < n);\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(0,9) + '0';\n        }\n    } else if (type == \"all_zero\") {\n        s = string(n, '0');\n    } else if (type == \"all_nine\") {\n        s = string(n, '9');\n    } else if (type == \"alternate_zero_nine\") {\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0 ? '0' : '9');\n        }\n    } else if (type == \"leading_zero\") {\n        int num_leading_zeros = rnd.next(1, min(5, n-1));\n        s = string(num_leading_zeros, '0');\n        for (int i = num_leading_zeros; i < n; ++i) {\n            s += rnd.next(1,9) + '0';\n        }\n    } else if (type == \"palindrome\") {\n        string half;\n        int half_len = (n + 1) / 2;\n        for (int i = 0; i < half_len; ++i) {\n            half += rnd.next(0,9) + '0';\n        }\n        s = half;\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            s += half[i];\n        }\n    } else if (type == \"ascending\") {\n        for (int i = 0; i < n; ++i) {\n            s += (char)('0' + (i % 10));\n        }\n    } else if (type == \"descending\") {\n        for (int i = 0; i < n; ++i) {\n            s += (char)('0' + (9 - (i % 10)));\n        }\n    } else if (type == \"max_digit\") {\n        s = string(n, '9');\n    } else {\n        // default random\n        for (int i = 0; i < n; ++i) {\n            s += rnd.next(0,9) + '0';\n        }\n    }\n    printf(\"%d %d\\n\", n, k);\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -k 0 -type random\n./gen -n 3 -k 1 -type random\n./gen -n 3 -k 2 -type random\n\n./gen -n 5 -k 0 -type all_zero\n./gen -n 5 -k 4 -type all_zero\n\n./gen -n 10 -k 0 -type all_nine\n./gen -n 10 -k 9 -type all_nine\n\n./gen -n 10 -k 5 -type alternate_zero_nine\n\n./gen -n 50 -k 10 -type palindrome\n\n./gen -n 100 -k 0 -type leading_zero\n./gen -n 100 -k 50 -type leading_zero\n./gen -n 100 -k 99 -type leading_zero\n\n./gen -n 1000 -k 500 -type random\n\n./gen -n 10000 -k 0 -type ascending\n./gen -n 10000 -k 9999 -type ascending\n\n./gen -n 10000 -k 5000 -type descending\n\n./gen -n 99999 -k 99998 -type random\n\n./gen -n 100000 -k 0 -type all_zero\n./gen -n 100000 -k 99999 -type all_zero\n\n./gen -n 100000 -k 0 -type all_nine\n./gen -n 100000 -k 99999 -type all_nine\n\n./gen -n 100000 -k 50000 -type random\n\n./gen -n 100000 -k 0 -type leading_zero\n\n./gen -n 1000 -k 0 -type palindrome\n./gen -n 1000 -k 999 -type palindrome\n\n./gen -n 1 -k 0 -type random\n\n./gen -n 2 -k 0 -type random\n./gen -n 2 -k 1 -type random\n\n./gen -n 50000 -k 25000 -type max_digit\n\n./gen -n 100000 -k 0 -type max_digit\n./gen -n 100000 -k 99999 -type max_digit\n\n./gen -n 99999 -k 50000 -type random\n\n./gen -n 99999 -k 0 -type ascending\n./gen -n 100000 -k 99999 -type descending\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:06.728037",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "521/A",
      "title": "A. Выравнивание ДНК",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано одно целое число n (1 ≤ n ≤ 105).Во второй строке ввода записана одна строка длины n, состоящая из символов \"ACGT\".",
      "output_spec": "Выходные данныеВыведите одно число — ответ по модулю 109 + 7.",
      "sample_tests": "ПримерыВходные данныеСкопировать1CВыходные данныеСкопировать1Входные данныеСкопировать2AGВыходные данныеСкопировать4Входные данныеСкопировать3TTTВыходные данныеСкопировать1",
      "description": "A. Выравнивание ДНК\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано одно целое число n (1 ≤ n ≤ 105).Во второй строке ввода записана одна строка длины n, состоящая из символов \"ACGT\".\n\nВходные данные\n\nВыходные данныеВыведите одно число — ответ по модулю 109 + 7.\n\nВыходные данные\n\nВходные данныеСкопировать1CВыходные данныеСкопировать1Входные данныеСкопировать2AGВыходные данныеСкопировать4Входные данныеСкопировать3TTTВыходные данныеСкопировать1\n\nВходные данныеСкопировать1C\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2AG\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать3TTT\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеОбратите внимание, что если для двух различных строк t1 и t2 значения ρ(s, t1) и ρ(s, t2) являются максимальными среди всех возможных строк, то обе строки необходимо учесть в итоговом количестве даже в том случае, когда одну из них можно получить циклическим сдвигом из другой.В первом примере существует ρ(\"C\", \"C\") = 1, для остальных строк t длины 1 значение ρ(s, t) равно 0.Во втором примере ρ(\"AG\", \"AG\") = ρ(\"AG\", \"GA\") = ρ(\"AG\", \"AA\") = ρ(\"AG\", \"GG\") = 4.В третьем примере ρ(\"TTT\", \"TTT\") = 27.",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Привет, Codeforces!2 марта в 10:00 MSK состоится раунд #295 для участников из обоих дивизионов.Раунд состоится практически одновременно с олимпиадой Зимней Компьютерной Школы на схожем комплекте задач. Авторы задач — я (Endagorion) и Евгений Савинов (savinov). В подготовке задач принимали участие члены технического комитета Зимней Компьютерной школы: Георгий Чебанов (gchebanov), Филипп Рухович (DPR-pavlin), Александр Машрабов (map), Сергей Киян (sokian), Константин Семенов (zemen), Кинан Альсармини (Sarkin).Спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский язык, Михаилу Мирзаянову (MikeMirzayanov) за вклад в развитие программирования путем создания систем Codeforces и Polygon.Разбалловка в обоих дивизионах стандартная: 500-1000-1500-2000-2500.Обратите внимание, что поскольку олимпиада ЗКШ на похожих задачах заканчивается позже раунда Codeforces, мы просим вас не обсуждать в комментариях задачи и решения до 14:10 MSK сегодняшнего дня. Также до этого времени будет закрыт просмотр кода других участников. Разбор также появится после этого времени.UPD: все, можно обсуждать. =)UPD2: наконец появился разбор ( теперь и на русском!).Также поздравляем победителей в Div.1: Petr hos.lyric Syloviaely andrew.volchek xyz111 Отдельно поздравляем Petr и rng_58, решивших самую сложную задачу E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1370
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces",
          "content": "Мы хотели бы также поблагодарить тестеров задач этого раунда и олимпиады ЗКШ: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Пожалуйста, пишите в комментариях о найденных ошибках.UPD: я вспомнил, что забыл написать регулярные бонусные челленджи. Так что вот, пожалуйста.520A - ПанграммаИдея:EndagorionПодготовка:EndagorionЧтобы проверить, что все буквы присутствуют, заведем массив длины 26 и для каждой буквы поставим в соответствующую ячейку единичку. В конце надо проверить, что все 26 единичек на месте. Решение работает за O(n). Также надо не забыть перевести все буквы к нижнему регистру (или наоборот, все буквы к верхнему).Чтобы перевести буквы в нижний регистр, можно использовать встроенные функции, например, tolower в Python. Также можно пользоваться тем, что буквы от a до z идут подряд по их ASCII-номерам; ASCII-номер для символа можно получить при помощи ord(c) во многих языках. Теперь, чтобы получить номер буквы в алфавите, надо написать ord(c) - ord('a'), а на C++ или C просто c - 'a' (поскольку в C/C++ символ — это число, равное его ASCII-номеру). Также, например, чтобы проверить, что буква имеет нижний регистр, надо написать неравенство ord('a') <= ord(c) && ord(c) <= ord('z').Challenge: сколько существует различных панграмм длины n? Строки, отличающиеся капитализацией некоторых символов, считаются различными. Сможете ли вы придумать линейное по времени решение?520B - Две кнопкиИдея: EndagorionПодготовка: EndagorionСамое простое решение — просто запустить обход в ширину. Построим граф, в котором вершины — числа, а ребра ведут из одного числа в другое, если можно получить второе из первого за одну операцию. Можно заметить, что первое число никогда не выгодно делать больше, чем 2m, поэтому в графе будет не больше 2·104 вершин и 4·104 ребер, и BFS сработает очень быстро.Однако, есть решение гораздо быстрее. Развернем задачу: изначально у нас есть число m, и мы хотим получить число n, пользуясь операциями \"прибавить к числу 1\" и \"поделить число на 2, если оно четно\".Пускай мы в какой-то момент применили две операции типа 1, и потом операцию типа 2; но эти три операции можно заменить на две: сначала операция типа 2, а потом одна операция типа 1, и количество операций от этого уменьшится. Отсюда следует, что применять больше одной операции типа 1 имеет смысл только тогда, когда операций типа 2 больше не будет, то есть, когда n меньше m и осталось сделать несколько прибавлений, чтобы их сравнять. На самом деле, теперь существует ровно одна последовательность операций, удовлетворяющая таким требованиям: если n меньше m, прибавляем единички пока нужно, иначе если n четно, делим на 2, а если нечетно, прибавляем 1 и потом делим на 2. Количество операций в такой последовательности можно найти за время .Challenge: рассмотрим обобщенную задачу: мы хотим получить число n из числа m с помощью операций двух типов \"отнять a\" и \"умножить на b\". Обобщите решение исходной задачи и научитесь находить минимальное количество операций за время в случае, если a и b взаимно просты. Справитесь ли вы, если у a и b могут быть нетривиальные общие делители?520C - Выравнивание ДНК/521A - Выравнивание ДНКИдея: EndagorionПодготовка: EndagorionЧто это за функция — ρ(s, t)? Для каждого символа t и каждого символа s существует ровно один циклический сдвиг, который их совмещает (действительно, после 0, ..., n - 1 сдвигов символ t пробежит все возможные положения в строке, и ровно одно из них — это положение символа из s); поэтому, существует ровно n способов циклически сдвинуть s и t, при которых выбранные символы совместятся (поскольку ситуация симметрична для любого положения символа из s). Таким образом, вклад в ρ, который дает символ ti, равен n × (количество символов s, равных ti). Поэтому ρ(s, t) максимально, когда каждый символ t встречается в s наибольшее количество раз. Посчитаем для каждого символа количество вхождений в s; ответ равен Kn, где K — это количество типов символов, которые встречаются в s чаще всего. Решение за O(n).Challenge: мы знаем, что ρmax(s) = C(s)·n2, где C(s)--- максимальное количество вхождений какого-либо символа. Сколько существует строк s длины n над алфавитом размера k, таких что C(s) = m? Сможете придумать решение за время O(kn2)? За время ? За время ? Может быть, еще быстрее? (Подсказка: для быстрого решения необходим удачно подобранный простой модуль. =))520D - Кубики/521B - КубикиИдея: savinovПодготовка: savinov, sokian, zemenВ эквивалентной формулировке, первый игрок стремится максимизировать лексикографиский порядок последовательности кубиков, а второй игрок — минимизировать его. Поэтому, на каждом шагу первый игрок берет максимальный из доступных кубиков, а второй — минимальный.Сперва научимся проверять, можно ли в текущей ситуации взять некоторый кубик. Его нельзя взять только тогда, когда есть какой-то кубик, который на нем \"стоит\" (т.е. имеет координаты (x - 1, y + 1), (x, y + 1) или (x + 1, y + 1)), и наш кубик является единственным, на котором он стоит. Это условие можно явно проверить. Из-за больших координат это не получится сделать путем простых обращений к массиву, поэтому придется завести ассоциативный массив, например, в C++ можно воспользоваться set.Теперь надо научиться находить максимальный/минимальный кубик среди доступных. Просто линейный проход — это слишком долго, поэтому заведем еще одну структуру, в которой будем хранить номера доступных кубиков. Структура должна уметь добавлять, удалять, а также искать максимум/минимум, так что что-нибудь вроде set нам снова подойдет.После того, как ход сделан, какие-то кубики могли стать доступными или, наоборот, перестать быть доступными. Однако, после каждого хода состояние могло поменяться только для O(1) кубиков: кубики (x ± 1, y) и (x ± 2, y) могли стать недоступными, потому что какой-то из кубиков выше стал опасным (т.е., остался один кубик, на котором он держится), и еще какие-то из кубиков (x - 1, y - 1), (x, y - 1) и (x + 1, y - 1) могли сделаться доступными, потому что единственный опасный кубик, который на них стоял, был удален. В любом случае, для всех них надо просто заново сделать проверку, и про случаи можно особо не думать.Решение с подходящей структурой работает за .Challenge (по мотивам вопросов от jk_qq и RetiredAmrMahmoud): пусть теперь кубики выкладываются в ряд справа налево, т.е. от младших разрядов к старшим. Первый игрок все так же хочет максимизировать итоговое число, второй — минимизировать его. Если оставить правила убирания кубиков такими же, в общем случае задача не выглядит решаемой. Попробуйте решить новую задачу в случае, когда кубики выстроены в несколько независимых башен, т.е. кубик можно убрать, если он находится на вершине своей башни.520E - Сплошные плюсы/521C - Сплошные плюсыИдея: EndagorionПодготовка: gchebanov, DPR-pavlinРассмотрим какой-нибудь способ расставить плюсы, а также какую-то цифру di (цифры пронумеруем с нуля слева направо). Эта цифра дает вклад в сумму чисел, равный di·10l, где l — расстояние до ближайшего плюса справа или до конца строки, если справа нет плюсов. Если просуммировать эти значения по всем цифрам и по всем способам расставить плюсы, получим в точности ответ.Сколько существует способов расставить плюсы для выбранной цифры di и какого-то фиксированного l? Во-первых, рассмотрим случай, когда при разбиении по плюсам часть, содержащая цифру di, не является последней, т.е., i + l < n - 1. Всего существует n - 1 позиция, куда можно ставить плюсы; ограничение, связанное с цифрой di и расстоянием l, означает, что после цифр di, ..., di + l - 1 плюсов не стоит, а после цифры di + l плюс стоит. Иными словами, строка выглядит примерно так: На рисунке точка означает отсутствие плюса, а вопросик значит, что неважно, стоит там плюс или нет. Видно, что из n - 1 возможных позиций для плюсов состояния (l + 1)-ой позиции определены, и среди них использован только один плюс. Это значит, что в остальные (n - 1) - (l + 1) = n - l - 2 надо поставить k - 1 плюс любым из способов; значит, искомое количество способов равно . Рассуждая схожим образом, получим, что если цифра di входит в последнюю часть (т.е. i + l = n - 1), количество способов равно .В итоге получаем, что ответ равен Преобразуем: Чтобы посчитать такие суммы, нам надо предпосчитать все степени 10 до n-ой (по модулю 109 + 7), а также биномиальные коэффициенты. Чтобы их посчитать, вспомним, что , поэтому достаточно вычислить все k! для k вплоть до n, а также их обратные значения по модулю. Помимо этого, нам пригодится массив префиксных сумм для цифр di, т.е., значения . Осталось просто просуммировать произведения этих величин.В итоге получили решение за , поскольку стандартные алгоритмы для поиска обратных по модулю (а именно, малая теорема Ферма с бинарным возведением в степень и решение диофантова уравнения при помощи обобщенного алгоритма Евклида) имеют верхнюю оценку сложности . Однако, можно воспользоваться интересным трюком и вычислить все обратные элементы для первых n чисел за линейное время, после чего итоговоая сложность решения становится O(n); почитать про интересный трюк можно в комментарии от Kaban-5 (непонятно, почему он заминусован; может быть, кто-то вспомнит ссылку на более фундаментальный источник для этого метода?).Challenge: теперь мы хотим посчитать сумму всех выражений, в которых расставлено k плюсов для всех k от a до b; т.е. мы хотим просуммировать ответы для исходной задачи по всем k = a, ..., b. Числа a и b любые, такие что 0 ≤ a ≤ b ≤ n - 1. Решение за O(n2) очевидно: для каждого k посчитаем ответ отдельно. Сможете ли вы придумать решение за линейное время?521D - Магазин Идея: EndagorionПодготовка: gchebanovПусть у нас есть только умножения. Тогда нам даже не важно, в каком порядке их применять, надо просто брать несколько апгрейдов с максимальным bi.Теперь рассмотрим также прибавления, а про умножения временно забудем. Ясно, что для каждого скилла надо взять несколько максимальных прибавлений (возможно, ни одного). Для каждого скилла отсортируем прибавления по невозрастанию bi; теперь для каждого скилла надо взять несколько первых апгрейдов. Итак, теперь для выбранного скилла есть невозрастающая последовательность прибавлений b1, ..., bl, и начальное значение скилла равно какому-то a. Раз мы решили взять некоторый префикс массива b, это значит, что когда мы берем апгрейд bi, значение скилла увеличивается с a + b1 + ... + bi - 1 до a + b1 + ... + bi - 1 + bi. Иными словами, значение, на которое домножится значение скилла (а значит, и все произвдение значений скиллов), равно дроби . Теперь, когда это отношение однозначно определилось для каждого прибавления, мы можем считать любое прибавление умножением. =) Теперь посчитаем такие отношения для всех прибавлений (т.е., отсортируем b-шки для каждого скилла по отдельности и найдем значения всех дробей), и затем посортируем умножения и прибавления вместе по тому, во сколько раз они увеличивают итоговый ответ. Ясно, что все умножения надо использовать уже после того, как были сделаны все прибавления; иными словами, для определения того, какие апгрейды брать, мы сортируем их все вместе по их отношениям, но реальный порядок применения должен быть таким: сперва все прибавления, а потом все умножения.Наконец, разберемся с присваиваниями. Очевидно, что для каждого скилла имеет смысл делать не более одного присваивания, и использовать можно только максимальное присваивание для данного скилла. Кроме того, присваивание необходимо делать перед всеми прибавлениями и умножениями. Поэтому, для каждого скилла надо просто определиться, берем мы для него максимальное присваивание или нет. Однако есть проблема с тем, что когда мы сделали присваивание, отношения для прибавлений стали неправильными, поскольку стартовое значение a поменялось.Представим теперь, что мы уже выбрали, какие прибавления мы сделаем, и теперь решаем, брать присваивание или нет. Если мы берем присваивание, то итоговое значение скилла поменяется с a + b1 + ... + bk на b + b1 + ... + bk. Иными словами, присваивание работает примерно так же, как и прибавление значения b - a. Единственная разница в том, что присваивание необходимо ставить раньше всех прибавлений.Итак, переделаем все максимальные присваивания для каждого скилла в прибавления b - a и обработаем их вместе со всеми остальными присваиваниями (которые, как мы знаем, в итоге станут умножениями =)).В итоге, задача свелась к сортировке отношений для всех апгрейдов. Оценим, какие числа у нас будут стоять в дробях. Отношение для умножения — это целое число до 106; отношение для прибавления — это дробь, которая выглядит как . Поскольку k может быть порядка 105, а bi — порядка 106, числитель и знаменатель дроби могут быть порядка 1011. Когда мы сравниваем дроби и , мы сравниваем произведения ad и bc, которые по нашим оценкам могут быть порядка 1022. Это, к сожалению, приводит к переполнению встроенных целочисленных типов во многих языках. Чтобы разобраться с этой проблемой, вычтем из всех дробей единицу (очевидно, на порядок сортировки это не повлияет), и теперь отношения для прибавлений выглядят как . Теперь, числитель стал всего лишь порядка 106, произведения будут порядка 1017, что уже помещается в стандартный 64-битный тип в любом языке.Challenge: пускай нам надо сравнить две дроби и , где числа a, b, c, d могут быть порядка 1018. Каким способом вы бы это сделали? Сможете ли вы придумать простое решение, которое не использует длинную арифметику, вещественные числа или волшебные целочисленные типы, такие как __int128 и им подобные (однако, возможно, совершает неконстантное число операций)?521E - Cycling CityИдея: EndagorionПодготовка: EndagorionНам нужно найти в неориентированном графе две вершины, такие что их можно соединить тремя вершинно и реберно непересекающимися путями. Это легко решалось бы потоком, если бы не большие ограничения.Во-первых, заметим, что все пути между двумя выбранными вершинами должны проходить внутри одной двусвязной компоненты графа. Действительно, любой простой цикл должен целиком лежать внутри одной двусвязной компоненты, а набор из трех путей можно представить как объединение двух пересекающихся циклов. Поэтому, сперва выделим все двусвязные компоненты графа и попытаемся решить задачу независимо в каждой из них. Двусвязные компонентны можно найти за линейное время; хороший алгоритм, который это делает, можно найти в статье по ссылке выше.Теперь, у нас есть двусвязная компонента и та же самая задача. Во-первых, найдем любой цикл в этой компоненте обычным DFS'ом; единственный случай, когда цикл не найдется, — это когда компонента состоит из одного ребра, но это неинтересный случай. Теперь, предположим, что ни из какой вершины цикла не исходит ребра, которое бы не лежало в цикле; в этом случае цикл не связан ни с какой другой вершиной компоненты, поэтому компонента сама по себе является этим циклом; очевидно, что в этом случае решения также нет.В противном случае, возьмем вершину v, из которой исходит ребро e, не лежащее в выбранном цикле (обозначим цикл за c). Если мы сможем найти такой путь p, который начинался бы с ребра e и заканчивался в какой-то вершине из цикла u (отличной от v), мы сможем выделить три непересекающихся пути между u и v: один из них — это p, а два других — половинки исходного цикла. Чтобы найти путь p, запустим DFS, который начинается с ребра e и заканчивается, как только мы приходим в вершину цикла c, отличную от v, а потом восстанавливает все пути для ответа.Что же делать, если такого пути p не найдется? Обозначим за C компоненту, которую обошел этот DFS. У него не получилось найти пути между вершинами из множества C\\ {v} и множества c\\ {v}, поэтому любой путь между этими двумя множествами должен проходить через v. Но тогда оказывается, что если удалить v, компонента C\\ {v} оказывается отделена от вершин из множества c\\ {v}, что противоречит тому, что исходная компонента была двусвязной. Отсюда следует, что тот DFS, который мы запускали из e, всегда найдет подходящий путь p и получит ответ, если наша двусвязная компонента — не цикл и не отдельное ребро.В итоге мы пришли к тому, что ответа нет в единственном случае, когда все двусвязные компоненты — либо отдельные ребра, либо циклы; другими словами, когда граф является несвязным набором кактусов. В противном случае, за пару запусков DFS'ов мы сможем найти три непересекающихся пути. В итоге получилось решение за время O(n + m); для упрощения можно было бы где-нибудь накрутить парочку логарифмов.Challenge: сколько существует графов G, таких что в G можно выбрать две вершины, соединенные тремя непересекающимися путями? (Подсказка: мы знаем, что достаточно посчитать количество несвязных объединений кактусов.) Можете ли вы придумать какое-нибудь полиномиальное по времени решение? Решение за время O(n3)? Возможно, еще быстрее?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 521\\s*A"
          },
          "content_length": 16705
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "#define int long long",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "long point(long x, long y) {\n    return (x << 32) | (y);\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 9",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 10",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 11",
          "code": "return -Long.compare(v1 - v2, 0);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 12",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 13",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295: разбор (теперь с бонусами!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[ACGT]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[ACGT]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[ACGT]{\" + to_string(n) + \"}\";\n    string s = inf.readToken(pattern, \"s\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate random string\n        s.resize(n);\n        string letters = \"ACGT\";\n        for (int i = 0; i < n; ++i)\n            s[i] = letters[rnd.next(4)];\n    } else if (type == \"allA\") {\n        // All 'A's\n        s = string(n, 'A');\n    } else if (type == \"allC\") {\n        // All 'C's\n        s = string(n, 'C');\n    } else if (type == \"allG\") {\n        // All 'G's\n        s = string(n, 'G');\n    } else if (type == \"allT\") {\n        // All 'T's\n        s = string(n, 'T');\n    } else if (type == \"alternating2\") {\n        // \"ACACAC...\"\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? 'A' : 'C';\n        }\n    } else if (type == \"alternating4\") {\n        // \"ACGTACGT...\"\n        s.resize(n);\n        string letters = \"ACGT\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = letters[i % 4];\n        }\n    } else if (type == \"incremental\") {\n        // \"ACGT\" repeated\n        s.resize(n);\n        string letters = \"ACGT\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = letters[i % 4];\n        }\n    } else if (type == \"custom\") {\n        string t = opt<string>(\"t\");\n        if (int(t.length()) != n) {\n            cerr << \"Length of custom string does not match n\" << endl;\n            return 1;\n        }\n        s = t;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    cout << n << endl;\n\n    // Output s\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate random string\n        s.resize(n);\n        string letters = \"ACGT\";\n        for (int i = 0; i < n; ++i)\n            s[i] = letters[rnd.next(4)];\n    } else if (type == \"allA\") {\n        // All 'A's\n        s = string(n, 'A');\n    } else if (type == \"allC\") {\n        // All 'C's\n        s = string(n, 'C');\n    } else if (type == \"allG\") {\n        // All 'G's\n        s = string(n, 'G');\n    } else if (type == \"allT\") {\n        // All 'T's\n        s = string(n, 'T');\n    } else if (type == \"alternating2\") {\n        // \"ACACAC...\"\n        s.resize(n);\n        for (int i = 0; i < n; ++i) {\n            s[i] = (i % 2 == 0) ? 'A' : 'C';\n        }\n    } else if (type == \"alternating4\") {\n        // \"ACGTACGT...\"\n        s.resize(n);\n        string letters = \"ACGT\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = letters[i % 4];\n        }\n    } else if (type == \"incremental\") {\n        // \"ACGT\" repeated\n        s.resize(n);\n        string letters = \"ACGT\";\n        for (int i = 0; i < n; ++i) {\n            s[i] = letters[i % 4];\n        }\n    } else if (type == \"custom\") {\n        string t = opt<string>(\"t\");\n        if (int(t.length()) != n) {\n            cerr << \"Length of custom string does not match n\" << endl;\n            return 1;\n        }\n        s = t;\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output n\n    cout << n << endl;\n\n    // Output s\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type allA\n./gen -n 1 -type allC\n./gen -n 1 -type allG\n./gen -n 1 -type allT\n./gen -n 2 -type alternating2\n\n./gen -n 3 -type random\n./gen -n 3 -type allT\n./gen -n 4 -type alternating4\n\n./gen -n 10 -type random\n./gen -n 10 -type custom -t ACGTACGTAC\n./gen -n 10 -type custom -t ACGTGTGCAA\n\n./gen -n 100 -type random\n./gen -n 100 -type allA\n./gen -n 100 -type alternating2\n\n./gen -n 200 -type alternating4\n./gen -n 200 -type incremental\n\n./gen -n 1000 -type random\n./gen -n 1000 -type allC\n./gen -n 1000 -type alternating2\n\n./gen -n 5000 -type alternating4\n./gen -n 10000 -type random\n./gen -n 10000 -type allA\n./gen -n 10000 -type allC\n./gen -n 10000 -type allG\n./gen -n 10000 -type allT\n\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n./gen -n 100000 -type allG\n./gen -n 100000 -type alternating2\n./gen -n 100000 -type alternating4\n./gen -n 100000 -type incremental\n./gen -n 100000 -type allT\n./gen -n 100000 -type allA\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:08.627496",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "521/B",
      "title": "B. Cubes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains number m (2 ≤ m ≤ 105).The following m lines contain the coordinates of the cubes xi, yi ( - 109 ≤ xi ≤ 109, 0 ≤ yi ≤ 109) in ascending order of numbers written on them. It is guaranteed that the original figure is stable.No two cubes occupy the same place.",
      "output_spec": "OutputIn the only line print the answer to the problem.",
      "sample_tests": "ExamplesInputCopy32 11 00 1OutputCopy19InputCopy50 00 10 20 30 4OutputCopy2930",
      "description": "time limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains number m (2 ≤ m ≤ 105).The following m lines contain the coordinates of the cubes xi, yi ( - 109 ≤ xi ≤ 109, 0 ≤ yi ≤ 109) in ascending order of numbers written on them. It is guaranteed that the original figure is stable.No two cubes occupy the same place.\n\nOutputIn the only line print the answer to the problem.\n\nInputCopy32 11 00 1OutputCopy19InputCopy50 00 10 20 30 4OutputCopy2930\n\nInputCopy32 11 00 1\n\nOutputCopy19\n\nInputCopy50 00 10 20 30 4\n\nOutputCopy2930",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Hello, Codeforces!On March, 2nd at 10:00 MSK Codeforces Round #295 will be held in both divisions.The round will be held at the same time with Winter Computer Camp olympiad, the problemsets will be highly similar. The problems are by me (Endagorion) and Evgeny Savinov (savinov). The problems are prepared by members of the Winter Computer Camp technical committee: Georgy Chebanov (gchebanov), Filipp Rukhovich (DPR-pavlin), Alexander Mashrabov (map), Sergey Kiyan (sokian), Konstantin Semenov (zemen), Kinan Alsarmini (Sarkin).Big thanks to Max Akhmedov (Zlobober) for his help with preparing the problems, Maria Belova (Delinur) for translating the statements in English, and Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon systems.The scoring is standard for both divisions: 500-1000-1500-2000-2500.Please note that the Winter Computing Camp olympiad is scheduled to finish later than the Codeforces round. Thus, we ask you not to discuss the problems and solutions in the comments until 14:10 MSK. Also, viewing of other participants' solutions will be closed until that time. The editorial will also be published later.UPD: you are free to discuss the problems now.UPD2: the editorial is finally up! Sorry for the delay.Also, grats to our Div.1 winners: Petr hos.lyric Syloviaely andrew.volchek xyz111 Special respect goes to Petr and rng_58 for solving the hardest problem E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1403
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces",
          "content": "We would like to thank the testers of this round's and Winter Computer Camp olympiad's problems: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Make sure to comment if you find any mistakes.UPD: I've just remembered to put up the usual challenges for the problems. So, here they go.520A - PangramIdea: EndagorionPreparation: EndagorionTo check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE. In the end check that there are 26 TRUEs. That is an O(n) solution. Also don't forget to change all letters to lowercase (or all to uppercase). To make all the letters lowercase, one could use standard functions, like tolower in Python. Also, it is known that the letters from a to z have consecutive ASCII numbers, as well as A to Z; an ASCII number of symbol is ord(c) in most languages. So, to get the number of a lowercase letter in the alphabet one can use ord(c) - ord('a') in most languages, or simply c - 'a' in C++ or C (because a char in C/C++ can be treated as a number); to check if a letter is lowercase, the inequality ord('a') <= ord(c) && ord(c) <= ord('z') should be checked.Challenge: how many pangrams of length n are there? Strings that differ only in capitalization of some letters are considered distinct. Can you find the answer modulo some prime p in linear time?520B - Two ButtonsIdea: EndagorionPreparation: EndagorionThe simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2·104 vertices and 4·104 edges, and the BFS should work real fast.There is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".Suppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in .Challenge: suppose we have a generalized problem: we want to get n starting from m using two operations \"subtract a\" and \"multiply by b\". Generalize the solution to find the minimal number of moves to get from n to m in time if a and b are coprime. Can you do it if a and b may have common divisors greater than 1?520C - DNA Alignment/521A - DNA AlignmentIdea: EndagorionPreparation: EndagorionWhat is ρ(s, t) equal to? For every character of s and every character of t there is a unique cyclic shift of t that superposes these characters (indeed, after 0, ..., n - 1 shifts the character in t occupies different positions, and one of them matches the one of the character of s); therefore, there exist n cyclic shifts of s and t that superpose these characters (the situation is symmetrical for every position of the character of s). It follows that the input in ρ from a single character ti is equal to n × (the number of characters in s equal to ti). Therefore, ρ(s, t) is maximal when every character of t occurs the maximal possible number of times in s. Simply count the number of occurences for every type of characters; the answer is Kn, where K is the number of character types that occur in s most frequently. This is an O(n) solution.Challenge: we know that ρmax(s) = n2·C(s), where C(s) is the maximal number that any character occurs in s. How many strings s of length n with characters from an alphabet of size k have C(s) = m? Can you find an O(kn2) solution? An solution? An solution? Maybe even better? (Hint: the modulo should be an appropriately chosen prime number for a fast solution =)).520D - Cubes/521B - CubesIdea: savinovPreparation: savinov, sokian, zemenBasically, the first player should maximize the lexicographical order of numbers, and the second player should minimize it. Thus, at every move the first player should choose the largest available number, and the second should choose the minimal one.First of all, how do we check if the cube can be removed? It is impossible only if there is some cube \"supported\" by it (i.e., it has coordinates (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)) such that our cube is the only one supporting it. This can be checked explicitly. The large coordinates' limitations do not allow us to store a simply array for that, so we should use an associative array, like a set in C++.Now we should find the maximal/minimal number that can be removed. A simple linear search won't work fast enough, so we store another data structure containing all numbers available to remove; the structure should allow inserting, erasing and finding global minimum/maximum, so the set C++ structure fits again.When we've made our move, some cubes may have become available or unavailable to remove. However, there is an O(1) amount of cubes we have to recheck and possibly insert/erase from our structure: the cubes (x ± 1, y) and (x ± 2, y) may have become unavailable because some higher cube has become dangerous (that is, there is a single cube supporting it), and some of the cubes (x - 1, y - 1), (x, y - 1) and (x + 1, y - 1) may have become available because our cube was the only dangerous cube that it has been supporting. Anyway, a simple recheck for these cubes will handle all the cases.This solution is if using the appropriate data structure.Challenge (inspired by questions from jk_qq and RetiredAmrMahmoud): suppose that the players put the numbers from right to left, that is, from the least significant digit to the most significant. The first player still wants to maximize the resulting number, and the second wants to minimize it. If the original rules of taking cubes apply, finding the optimal strategy for the players seems intractable. Try to solve this problem in the case where all the cubes are stacked in several independent towers; that is, a cube may only be taken from the top of any tower.520E - Pluses everywhere/521C - Pluses everywhereIdea: EndagorionPreparation: gchebanov, DPR-pavlinConsider some way of placing all the pluses, and a single digit di (digits in the string are numbered starting from 0 from left to right). This digit gives input of di·10l to the total sum, where l is the distance to the nearest plus from the right, or to the end of string if there are no pluses there. If we sum up these quantities for all digits and all ways of placing the pluses, we will obtain the answer.For a given digit di and some fixed l, how many ways are there to place the pluses? First of all, consider the case when the part containing the digit di is not last, that is, i + l < n - 1. There are n - 1 gaps to place pluses in total; the constraint about di and the distance l means that after digits di, ..., di + l - 1 there are no pluses, while after the digit di + l there should be a plus. That is, the string should look as follows: Here a dot means a gap without a plus, and a question mark means that it's not important whether there is a plus or not. So, out of n - 1 possible gaps there are l + 1 gaps which states are defined, and there is one plus used in these gaps. That means that the other (n - 1) - (l + 1) = n - l - 2 gaps may contain k - 1 pluses in any possible way; that is, the number of such placements is . A similar reasoning implies that if the digit di is in the last part, that is, i + l = n - 1, the number of placements is .To sum up, the total answer is equal to Let us transform the sum: To compute these sums, we will need to know all powers of 10 up to n-th (modulo 109 + 7), along with the binomial coefficients. To compute the binomials, recall that , so it is enough to know all the numbers k! for k upto n, along with their modular inverses. Also we should use the prefix sums of di, that is, the array . The rest is simple evaluation of the above sums.The total complexity is , because the common algorithms for modular inverses (that is, Ferma's little theorem exponentiation or solving a diophantine equation using the Euclid's algorithm) have theoritcal worst-case complexity of . However, one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O(n); for the description of the method refer to this comment by Kaban-5 (not sure why it has a negative rating, I found this quite insightful; maybe anyone can give a proper source for this method?).Challenge: now we want to find the sum of all expressions that are made by placing k pluses with a ≤ k ≤ b; that is, we want to find the sum of the answers for the original problem with k = a, ..., b; here a and b can be any integers with 0 ≤ a ≤ b ≤ n - 1. There is an obvious O(n2) solution: just find the answers for all k separately. Can you find a linear solution?521D - ShopIdea: EndagorionPreparation: gchebanovSuppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.Now we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a + b1 + ... + bi - 1 to a + b1 + ... + bi - 1 + bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.Finally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.To deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a + b1 + ... + bk to b + b1 + ... + bk. That is, the assignment here behaves pretty much the same way as the addition of b - a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.That is, all largest assigments for each skill should be made into additions of b - a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)Finally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions and we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.Challenge: suppose that you have to compare two fractions and , where a, b, c, d may be up to 1018. What way would you use to do that? Can you find a simple solution that does not involve long arithmetics, floating-point number or magic built-in integer types tricks (but may perform a non-constant number of operations)?521E - Cycling CityIdea: EndagorionPreparation: EndagorionWe have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.First of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.Now, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.Otherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.What if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.Finally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n + m) solution; a few logarithmic factors for simplification here and there are also allowed.Challenge: how many graphs G on n labeled vertices exist such that there exist two vertices of G connected by three disjoint paths? (Hint: we have already shown that it suffices to count the number of disjoint unions of cacti.) Find the answer modulo 109 + 7. Can you come up with any polynomial-time solution? An O(n3) solution? Maybe even better?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 521\\s*B"
          },
          "content_length": 16554
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 100000);\n    inf.readEoln();\n    vector<int> xs(m), ys(m);\n    set<pair<int,int>> positions;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000);\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000000);\n        inf.readEoln();\n        xs[i] = xi;\n        ys[i] = yi;\n        pair<int,int> pos = {xi, yi};\n        if (!positions.insert(pos).second) {\n            quitf(_fail, \"Two cubes occupy the same position at (%d, %d)\", xi, yi);\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        if (ys[i] == 0) continue;\n        bool stable = false;\n        for (int dx = -1; dx <= 1; ++dx) {\n            int x_below = xs[i] + dx;\n            int y_below = ys[i] - 1;\n            if (positions.count({x_below, y_below})) {\n                stable = true;\n                break;\n            }\n        }\n        if (!stable) {\n            quitf(_fail, \"Cube at (%d, %d) is unstable\", xs[i], ys[i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 100000);\n    inf.readEoln();\n    vector<int> xs(m), ys(m);\n    set<pair<int,int>> positions;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000);\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000000);\n        inf.readEoln();\n        xs[i] = xi;\n        ys[i] = yi;\n        pair<int,int> pos = {xi, yi};\n        if (!positions.insert(pos).second) {\n            quitf(_fail, \"Two cubes occupy the same position at (%d, %d)\", xi, yi);\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        if (ys[i] == 0) continue;\n        bool stable = false;\n        for (int dx = -1; dx <= 1; ++dx) {\n            int x_below = xs[i] + dx;\n            int y_below = ys[i] - 1;\n            if (positions.count({x_below, y_below})) {\n                stable = true;\n                break;\n            }\n        }\n        if (!stable) {\n            quitf(_fail, \"Cube at (%d, %d) is unstable\", xs[i], ys[i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int m = inf.readInt(2, 100000);\n    inf.readEoln();\n    vector<int> xs(m), ys(m);\n    set<pair<int,int>> positions;\n    for (int i = 0; i < m; ++i) {\n        int xi = inf.readInt(-1000000000, 1000000000);\n        inf.readSpace();\n        int yi = inf.readInt(0, 1000000000);\n        inf.readEoln();\n        xs[i] = xi;\n        ys[i] = yi;\n        pair<int,int> pos = {xi, yi};\n        if (!positions.insert(pos).second) {\n            quitf(_fail, \"Two cubes occupy the same position at (%d, %d)\", xi, yi);\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        if (ys[i] == 0) continue;\n        bool stable = false;\n        for (int dx = -1; dx <= 1; ++dx) {\n            int x_below = xs[i] + dx;\n            int y_below = ys[i] - 1;\n            if (positions.count({x_below, y_below})) {\n                stable = true;\n                break;\n            }\n        }\n        if (!stable) {\n            quitf(_fail, \"Cube at (%d, %d) is unstable\", xs[i], ys[i]);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int64_t, int64_t>> positions(m);\n\n    set<pair<int64_t, int64_t>> occupied;\n\n    if (type == \"ground\") {\n        // All cubes on the ground\n        // yi = 0\n        // xi are random unique integers in range [-1e9, 1e9]\n        set<int64_t> xs;\n        for (int i = 0; i < m; ++i) {\n            int64_t xi;\n            do {\n                xi = rnd.next(-1000000000LL, 1000000000LL);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            positions[i] = make_pair(xi, 0);\n        }\n    } else if (type == \"stack\") {\n        // Stack of cubes at xi = 0, yi from 0 to m - 1\n        for (int i = 0; i < m; ++i) {\n            positions[i] = make_pair(0, i);\n        }\n    } else if (type == \"pyramid\") {\n        // Build a pyramid shape\n        int idx = 0;\n        int64_t level = 0;\n        while (idx < m) {\n            int64_t xi_start = -level;\n            int64_t xi_end = level;\n            for (int64_t xi = xi_start; xi <= xi_end; ++xi) {\n                if (idx >= m) break;\n                positions[idx++] = make_pair(xi, level);\n            }\n            ++level;\n        }\n    } else if (type == \"random\") {\n        // Random stable figure\n        map<int64_t, set<int64_t>> occupied_levels; // Map from yi to set of xi at that yi\n\n        // For the first cube, place it on the ground\n        int64_t xi;\n        do {\n            xi = rnd.next(-1000000000LL, 1000000000LL);\n        } while (occupied.count(make_pair(xi, 0)));\n\n        positions[0] = make_pair(xi, 0);\n        occupied.insert(positions[0]);\n        occupied_levels[0].insert(xi);\n\n        for (int i = 1; i < m; ++i) {\n            int choice = rnd.next(2); // 0 or 1\n            if (choice == 0) {\n                // Place cube on the ground\n                int64_t xi_new;\n                do {\n                    xi_new = rnd.next(-1000000000LL, 1000000000LL);\n                } while (occupied_levels[0].count(xi_new));\n                positions[i] = make_pair(xi_new, 0);\n                occupied.insert(positions[i]);\n                occupied_levels[0].insert(xi_new);\n            } else {\n                // Place cube above existing cube(s)\n                bool placed = false;\n                for (int attempt = 0; attempt < 100; ++attempt) {\n                    // Randomly pick a cube from current positions\n                    int idx_base = rnd.next(0, i - 1);\n                    int64_t xi_base = positions[idx_base].first;\n                    int64_t yi_base = positions[idx_base].second;\n                    int64_t yi_new = yi_base + 1;\n                    vector<int64_t> xi_candidates = {xi_base - 1, xi_base, xi_base + 1};\n                    shuffle(xi_candidates.begin(), xi_candidates.end());\n                    for (auto xi_new : xi_candidates) {\n                        if (abs(xi_new) > 1000000000LL) continue;\n                        if (occupied.count(make_pair(xi_new, yi_new))) continue;\n                        // Check that there's a cube under this position\n                        if (occupied.count(make_pair(xi_new - 1, yi_new - 1)) ||\n                            occupied.count(make_pair(xi_new, yi_new - 1)) ||\n                            occupied.count(make_pair(xi_new + 1, yi_new - 1))) {\n                            positions[i] = make_pair(xi_new, yi_new);\n                            occupied.insert(positions[i]);\n                            occupied_levels[yi_new].insert(xi_new);\n                            placed = true;\n                            break;\n                        }\n                    }\n                    if (placed) break;\n                }\n                if (!placed) {\n                    // Could not place above existing cubes, so place on ground\n                    int64_t xi_new;\n                    do {\n                        xi_new = rnd.next(-1000000000LL, 1000000000LL);\n                    } while (occupied_levels[0].count(xi_new));\n                    positions[i] = make_pair(xi_new, 0);\n                    occupied.insert(positions[i]);\n                    occupied_levels[0].insert(xi_new);\n                }\n            }\n        }\n    } else {\n        // If type is not recognized, output error message\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output the data\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld %lld\\n\", positions[i].first, positions[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int64_t, int64_t>> positions(m);\n\n    set<pair<int64_t, int64_t>> occupied;\n\n    if (type == \"ground\") {\n        // All cubes on the ground\n        // yi = 0\n        // xi are random unique integers in range [-1e9, 1e9]\n        set<int64_t> xs;\n        for (int i = 0; i < m; ++i) {\n            int64_t xi;\n            do {\n                xi = rnd.next(-1000000000LL, 1000000000LL);\n            } while (xs.count(xi));\n            xs.insert(xi);\n            positions[i] = make_pair(xi, 0);\n        }\n    } else if (type == \"stack\") {\n        // Stack of cubes at xi = 0, yi from 0 to m - 1\n        for (int i = 0; i < m; ++i) {\n            positions[i] = make_pair(0, i);\n        }\n    } else if (type == \"pyramid\") {\n        // Build a pyramid shape\n        int idx = 0;\n        int64_t level = 0;\n        while (idx < m) {\n            int64_t xi_start = -level;\n            int64_t xi_end = level;\n            for (int64_t xi = xi_start; xi <= xi_end; ++xi) {\n                if (idx >= m) break;\n                positions[idx++] = make_pair(xi, level);\n            }\n            ++level;\n        }\n    } else if (type == \"random\") {\n        // Random stable figure\n        map<int64_t, set<int64_t>> occupied_levels; // Map from yi to set of xi at that yi\n\n        // For the first cube, place it on the ground\n        int64_t xi;\n        do {\n            xi = rnd.next(-1000000000LL, 1000000000LL);\n        } while (occupied.count(make_pair(xi, 0)));\n\n        positions[0] = make_pair(xi, 0);\n        occupied.insert(positions[0]);\n        occupied_levels[0].insert(xi);\n\n        for (int i = 1; i < m; ++i) {\n            int choice = rnd.next(2); // 0 or 1\n            if (choice == 0) {\n                // Place cube on the ground\n                int64_t xi_new;\n                do {\n                    xi_new = rnd.next(-1000000000LL, 1000000000LL);\n                } while (occupied_levels[0].count(xi_new));\n                positions[i] = make_pair(xi_new, 0);\n                occupied.insert(positions[i]);\n                occupied_levels[0].insert(xi_new);\n            } else {\n                // Place cube above existing cube(s)\n                bool placed = false;\n                for (int attempt = 0; attempt < 100; ++attempt) {\n                    // Randomly pick a cube from current positions\n                    int idx_base = rnd.next(0, i - 1);\n                    int64_t xi_base = positions[idx_base].first;\n                    int64_t yi_base = positions[idx_base].second;\n                    int64_t yi_new = yi_base + 1;\n                    vector<int64_t> xi_candidates = {xi_base - 1, xi_base, xi_base + 1};\n                    shuffle(xi_candidates.begin(), xi_candidates.end());\n                    for (auto xi_new : xi_candidates) {\n                        if (abs(xi_new) > 1000000000LL) continue;\n                        if (occupied.count(make_pair(xi_new, yi_new))) continue;\n                        // Check that there's a cube under this position\n                        if (occupied.count(make_pair(xi_new - 1, yi_new - 1)) ||\n                            occupied.count(make_pair(xi_new, yi_new - 1)) ||\n                            occupied.count(make_pair(xi_new + 1, yi_new - 1))) {\n                            positions[i] = make_pair(xi_new, yi_new);\n                            occupied.insert(positions[i]);\n                            occupied_levels[yi_new].insert(xi_new);\n                            placed = true;\n                            break;\n                        }\n                    }\n                    if (placed) break;\n                }\n                if (!placed) {\n                    // Could not place above existing cubes, so place on ground\n                    int64_t xi_new;\n                    do {\n                        xi_new = rnd.next(-1000000000LL, 1000000000LL);\n                    } while (occupied_levels[0].count(xi_new));\n                    positions[i] = make_pair(xi_new, 0);\n                    occupied.insert(positions[i]);\n                    occupied_levels[0].insert(xi_new);\n                }\n            }\n        }\n    } else {\n        // If type is not recognized, output error message\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output the data\n    printf(\"%d\\n\", m);\n    for (int i = 0; i < m; ++i) {\n        printf(\"%lld %lld\\n\", positions[i].first, positions[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -m 2 -type ground\n./gen -m 2 -type stack\n./gen -m 2 -type pyramid\n./gen -m 2 -type random\n\n./gen -m 5 -type ground\n./gen -m 5 -type stack\n./gen -m 5 -type pyramid\n./gen -m 5 -type random\n\n./gen -m 10 -type ground\n./gen -m 10 -type stack\n./gen -m 10 -type pyramid\n./gen -m 10 -type random\n\n./gen -m 50 -type ground\n./gen -m 50 -type stack\n./gen -m 50 -type pyramid\n./gen -m 50 -type random\n\n./gen -m 100 -type ground\n./gen -m 100 -type stack\n./gen -m 100 -type pyramid\n./gen -m 100 -type random\n\n./gen -m 1000 -type ground\n./gen -m 1000 -type stack\n./gen -m 1000 -type pyramid\n./gen -m 1000 -type random\n\n./gen -m 5000 -type ground\n./gen -m 5000 -type stack\n./gen -m 5000 -type pyramid\n./gen -m 5000 -type random\n\n./gen -m 10000 -type ground\n./gen -m 10000 -type stack\n./gen -m 10000 -type pyramid\n./gen -m 10000 -type random\n\n./gen -m 50000 -type ground\n./gen -m 50000 -type stack\n./gen -m 50000 -type pyramid\n./gen -m 50000 -type random\n\n./gen -m 100000 -type ground\n./gen -m 100000 -type stack\n./gen -m 100000 -type pyramid\n./gen -m 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:10.349976",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "521/C",
      "title": "C. Pluses everywhere",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers, n and k (0 ≤ k < n ≤ 105).The second line contains a string consisting of n digits.",
      "output_spec": "OutputPrint the answer to the problem modulo 109 + 7.",
      "sample_tests": "ExamplesInputCopy3 1108OutputCopy27InputCopy3 2108OutputCopy9",
      "description": "C. Pluses everywhere\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains two integers, n and k (0 ≤ k < n ≤ 105).The second line contains a string consisting of n digits.\n\nOutputPrint the answer to the problem modulo 109 + 7.\n\nInputCopy3 1108OutputCopy27InputCopy3 2108OutputCopy9\n\nInputCopy3 1108\n\nOutputCopy27\n\nInputCopy3 2108\n\nOutputCopy9\n\nNoteIn the first sample the result equals (1 + 08) + (10 + 8) = 27.In the second sample the result equals 1 + 0 + 8 = 9.",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Hello, Codeforces!On March, 2nd at 10:00 MSK Codeforces Round #295 will be held in both divisions.The round will be held at the same time with Winter Computer Camp olympiad, the problemsets will be highly similar. The problems are by me (Endagorion) and Evgeny Savinov (savinov). The problems are prepared by members of the Winter Computer Camp technical committee: Georgy Chebanov (gchebanov), Filipp Rukhovich (DPR-pavlin), Alexander Mashrabov (map), Sergey Kiyan (sokian), Konstantin Semenov (zemen), Kinan Alsarmini (Sarkin).Big thanks to Max Akhmedov (Zlobober) for his help with preparing the problems, Maria Belova (Delinur) for translating the statements in English, and Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon systems.The scoring is standard for both divisions: 500-1000-1500-2000-2500.Please note that the Winter Computing Camp olympiad is scheduled to finish later than the Codeforces round. Thus, we ask you not to discuss the problems and solutions in the comments until 14:10 MSK. Also, viewing of other participants' solutions will be closed until that time. The editorial will also be published later.UPD: you are free to discuss the problems now.UPD2: the editorial is finally up! Sorry for the delay.Also, grats to our Div.1 winners: Petr hos.lyric Syloviaely andrew.volchek xyz111 Special respect goes to Petr and rng_58 for solving the hardest problem E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1403
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces",
          "content": "We would like to thank the testers of this round's and Winter Computer Camp olympiad's problems: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Make sure to comment if you find any mistakes.UPD: I've just remembered to put up the usual challenges for the problems. So, here they go.520A - PangramIdea: EndagorionPreparation: EndagorionTo check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE. In the end check that there are 26 TRUEs. That is an O(n) solution. Also don't forget to change all letters to lowercase (or all to uppercase). To make all the letters lowercase, one could use standard functions, like tolower in Python. Also, it is known that the letters from a to z have consecutive ASCII numbers, as well as A to Z; an ASCII number of symbol is ord(c) in most languages. So, to get the number of a lowercase letter in the alphabet one can use ord(c) - ord('a') in most languages, or simply c - 'a' in C++ or C (because a char in C/C++ can be treated as a number); to check if a letter is lowercase, the inequality ord('a') <= ord(c) && ord(c) <= ord('z') should be checked.Challenge: how many pangrams of length n are there? Strings that differ only in capitalization of some letters are considered distinct. Can you find the answer modulo some prime p in linear time?520B - Two ButtonsIdea: EndagorionPreparation: EndagorionThe simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2·104 vertices and 4·104 edges, and the BFS should work real fast.There is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".Suppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in .Challenge: suppose we have a generalized problem: we want to get n starting from m using two operations \"subtract a\" and \"multiply by b\". Generalize the solution to find the minimal number of moves to get from n to m in time if a and b are coprime. Can you do it if a and b may have common divisors greater than 1?520C - DNA Alignment/521A - DNA AlignmentIdea: EndagorionPreparation: EndagorionWhat is ρ(s, t) equal to? For every character of s and every character of t there is a unique cyclic shift of t that superposes these characters (indeed, after 0, ..., n - 1 shifts the character in t occupies different positions, and one of them matches the one of the character of s); therefore, there exist n cyclic shifts of s and t that superpose these characters (the situation is symmetrical for every position of the character of s). It follows that the input in ρ from a single character ti is equal to n × (the number of characters in s equal to ti). Therefore, ρ(s, t) is maximal when every character of t occurs the maximal possible number of times in s. Simply count the number of occurences for every type of characters; the answer is Kn, where K is the number of character types that occur in s most frequently. This is an O(n) solution.Challenge: we know that ρmax(s) = n2·C(s), where C(s) is the maximal number that any character occurs in s. How many strings s of length n with characters from an alphabet of size k have C(s) = m? Can you find an O(kn2) solution? An solution? An solution? Maybe even better? (Hint: the modulo should be an appropriately chosen prime number for a fast solution =)).520D - Cubes/521B - CubesIdea: savinovPreparation: savinov, sokian, zemenBasically, the first player should maximize the lexicographical order of numbers, and the second player should minimize it. Thus, at every move the first player should choose the largest available number, and the second should choose the minimal one.First of all, how do we check if the cube can be removed? It is impossible only if there is some cube \"supported\" by it (i.e., it has coordinates (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)) such that our cube is the only one supporting it. This can be checked explicitly. The large coordinates' limitations do not allow us to store a simply array for that, so we should use an associative array, like a set in C++.Now we should find the maximal/minimal number that can be removed. A simple linear search won't work fast enough, so we store another data structure containing all numbers available to remove; the structure should allow inserting, erasing and finding global minimum/maximum, so the set C++ structure fits again.When we've made our move, some cubes may have become available or unavailable to remove. However, there is an O(1) amount of cubes we have to recheck and possibly insert/erase from our structure: the cubes (x ± 1, y) and (x ± 2, y) may have become unavailable because some higher cube has become dangerous (that is, there is a single cube supporting it), and some of the cubes (x - 1, y - 1), (x, y - 1) and (x + 1, y - 1) may have become available because our cube was the only dangerous cube that it has been supporting. Anyway, a simple recheck for these cubes will handle all the cases.This solution is if using the appropriate data structure.Challenge (inspired by questions from jk_qq and RetiredAmrMahmoud): suppose that the players put the numbers from right to left, that is, from the least significant digit to the most significant. The first player still wants to maximize the resulting number, and the second wants to minimize it. If the original rules of taking cubes apply, finding the optimal strategy for the players seems intractable. Try to solve this problem in the case where all the cubes are stacked in several independent towers; that is, a cube may only be taken from the top of any tower.520E - Pluses everywhere/521C - Pluses everywhereIdea: EndagorionPreparation: gchebanov, DPR-pavlinConsider some way of placing all the pluses, and a single digit di (digits in the string are numbered starting from 0 from left to right). This digit gives input of di·10l to the total sum, where l is the distance to the nearest plus from the right, or to the end of string if there are no pluses there. If we sum up these quantities for all digits and all ways of placing the pluses, we will obtain the answer.For a given digit di and some fixed l, how many ways are there to place the pluses? First of all, consider the case when the part containing the digit di is not last, that is, i + l < n - 1. There are n - 1 gaps to place pluses in total; the constraint about di and the distance l means that after digits di, ..., di + l - 1 there are no pluses, while after the digit di + l there should be a plus. That is, the string should look as follows: Here a dot means a gap without a plus, and a question mark means that it's not important whether there is a plus or not. So, out of n - 1 possible gaps there are l + 1 gaps which states are defined, and there is one plus used in these gaps. That means that the other (n - 1) - (l + 1) = n - l - 2 gaps may contain k - 1 pluses in any possible way; that is, the number of such placements is . A similar reasoning implies that if the digit di is in the last part, that is, i + l = n - 1, the number of placements is .To sum up, the total answer is equal to Let us transform the sum: To compute these sums, we will need to know all powers of 10 up to n-th (modulo 109 + 7), along with the binomial coefficients. To compute the binomials, recall that , so it is enough to know all the numbers k! for k upto n, along with their modular inverses. Also we should use the prefix sums of di, that is, the array . The rest is simple evaluation of the above sums.The total complexity is , because the common algorithms for modular inverses (that is, Ferma's little theorem exponentiation or solving a diophantine equation using the Euclid's algorithm) have theoritcal worst-case complexity of . However, one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O(n); for the description of the method refer to this comment by Kaban-5 (not sure why it has a negative rating, I found this quite insightful; maybe anyone can give a proper source for this method?).Challenge: now we want to find the sum of all expressions that are made by placing k pluses with a ≤ k ≤ b; that is, we want to find the sum of the answers for the original problem with k = a, ..., b; here a and b can be any integers with 0 ≤ a ≤ b ≤ n - 1. There is an obvious O(n2) solution: just find the answers for all k separately. Can you find a linear solution?521D - ShopIdea: EndagorionPreparation: gchebanovSuppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.Now we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a + b1 + ... + bi - 1 to a + b1 + ... + bi - 1 + bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.Finally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.To deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a + b1 + ... + bk to b + b1 + ... + bk. That is, the assignment here behaves pretty much the same way as the addition of b - a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.That is, all largest assigments for each skill should be made into additions of b - a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)Finally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions and we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.Challenge: suppose that you have to compare two fractions and , where a, b, c, d may be up to 1018. What way would you use to do that? Can you find a simple solution that does not involve long arithmetics, floating-point number or magic built-in integer types tricks (but may perform a non-constant number of operations)?521E - Cycling CityIdea: EndagorionPreparation: EndagorionWe have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.First of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.Now, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.Otherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.What if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.Finally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n + m) solution; a few logarithmic factors for simplification here and there are also allowed.Challenge: how many graphs G on n labeled vertices exist such that there exist two vertices of G connected by three disjoint paths? (Hint: we have already shown that it suffices to count the number of disjoint unions of cacti.) Find the answer modulo 109 + 7. Can you come up with any polynomial-time solution? An O(n3) solution? Maybe even better?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 521\\s*C"
          },
          "content_length": 16554
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9]+\", \"s\");\n    ensuref((int)s.length() == n, \"Length of s must be n=%d, but it is %d\", n, (int)s.length());\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9]+\", \"s\");\n    ensuref((int)s.length() == n, \"Length of s must be n=%d, but it is %d\", n, (int)s.length());\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n - 1, \"k\");\n    inf.readEoln();\n\n    string s = inf.readToken(\"[0-9]+\", \"s\");\n    ensuref((int)s.length() == n, \"Length of s must be n=%d, but it is %d\", n, (int)s.length());\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt(\"type\", \"random\");\n\n    // Ensure that 0 ≤ k < n\n    ensure(0 <= k && k < n);\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of digits\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 9);\n            s += char('0' + digit);\n        }\n    } else if (type == \"zeros\") {\n        // String of zeros\n        s = string(n, '0');\n    } else if (type == \"ones\") {\n        s = string(n, '1');\n    } else if (type == \"leadingZeros\") {\n        // String that starts with multiple zeros\n        int numLeadingZeros = min(rnd.next(1, n - 1), n - 1);\n        s = string(numLeadingZeros, '0');\n        for (int i = numLeadingZeros; i < n; ++i) {\n            int digit = rnd.next(1, 9);\n            s += char('0' + digit);\n        }\n    } else if (type == \"maximumSum\") {\n        // Digits are 9 to get maximum sum\n        s = string(n, '9');\n    } else if (type == \"minimumSum\") {\n        // Digits are 0 or 1\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 1);\n            s += char('0' + digit);\n        }\n    } else if (type == \"alternatingZerosOnes\") {\n        for (int i = 0; i < n; ++i) {\n            int digit = i % 2; // alternates between 0 and 1\n            s += char('0' + digit);\n        }\n    } else if (type == \"allSameDigit\") {\n        int digit = rnd.next(0,9);\n        s = string(n, '0' + digit);\n    } else if (type == \"bigNumbers\") {\n        // Construct big numbers to test overflow\n        // Generate digits between 5 and 9\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(5, 9);\n            s += char('0' + digit);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 9);\n            s += char('0' + digit);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt(\"type\", \"random\");\n\n    // Ensure that 0 ≤ k < n\n    ensure(0 <= k && k < n);\n\n    string s;\n\n    if (type == \"random\") {\n        // Generate a random string of digits\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 9);\n            s += char('0' + digit);\n        }\n    } else if (type == \"zeros\") {\n        // String of zeros\n        s = string(n, '0');\n    } else if (type == \"ones\") {\n        s = string(n, '1');\n    } else if (type == \"leadingZeros\") {\n        // String that starts with multiple zeros\n        int numLeadingZeros = min(rnd.next(1, n - 1), n - 1);\n        s = string(numLeadingZeros, '0');\n        for (int i = numLeadingZeros; i < n; ++i) {\n            int digit = rnd.next(1, 9);\n            s += char('0' + digit);\n        }\n    } else if (type == \"maximumSum\") {\n        // Digits are 9 to get maximum sum\n        s = string(n, '9');\n    } else if (type == \"minimumSum\") {\n        // Digits are 0 or 1\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 1);\n            s += char('0' + digit);\n        }\n    } else if (type == \"alternatingZerosOnes\") {\n        for (int i = 0; i < n; ++i) {\n            int digit = i % 2; // alternates between 0 and 1\n            s += char('0' + digit);\n        }\n    } else if (type == \"allSameDigit\") {\n        int digit = rnd.next(0,9);\n        s = string(n, '0' + digit);\n    } else if (type == \"bigNumbers\") {\n        // Construct big numbers to test overflow\n        // Generate digits between 5 and 9\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(5, 9);\n            s += char('0' + digit);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            int digit = rnd.next(0, 9);\n            s += char('0' + digit);\n        }\n    }\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n    // Output the string s\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 0 -type random\n\n./gen -n 10 -k 0 -type random\n./gen -n 10 -k 1 -type random\n./gen -n 10 -k 5 -type random\n./gen -n 10 -k 9 -type random\n\n./gen -n 10 -k 0 -type zeros\n./gen -n 10 -k 5 -type zeros\n\n./gen -n 10 -k 0 -type ones\n./gen -n 10 -k 5 -type ones\n\n./gen -n 100 -k 0 -type leadingZeros\n./gen -n 100 -k 50 -type leadingZeros\n\n./gen -n 1000 -k 0 -type maximumSum\n./gen -n 1000 -k 500 -type maximumSum\n\n./gen -n 1000 -k 0 -type minimumSum\n./gen -n 1000 -k 500 -type minimumSum\n\n./gen -n 100000 -k 0 -type alternatingZerosOnes\n./gen -n 100000 -k 50000 -type alternatingZerosOnes\n\n./gen -n 100000 -k 0 -type bigNumbers\n./gen -n 100000 -k 1 -type bigNumbers\n\n./gen -n 100000 -k 0 -type allSameDigit\n./gen -n 100000 -k 99999 -type allSameDigit\n\n./gen -n 100000 -k 0 -type random\n./gen -n 100000 -k 50000 -type random\n./gen -n 100000 -k 99999 -type random\n\n./gen -n 99999 -k 0 -type leadingZeros\n./gen -n 99999 -k 99998 -type leadingZeros\n\n./gen -n 50000 -k 24999 -type zeros\n./gen -n 50000 -k 24999 -type ones\n\n./gen -n 100000 -k 50000 -type minimumSum\n./gen -n 100000 -k 50000 -type maximumSum\n\n./gen -n 100000 -k 0 -type bigNumbers\n./gen -n 100000 -k 99999 -type bigNumbers\n\n./gen -n 100000 -k 1 -type bigNumbers\n\n./gen -n 2 -k 1 -type random\n./gen -n 2 -k 0 -type zeros\n./gen -n 2 -k 0 -type ones\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:12.631329",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "521/D",
      "title": "D. Shop",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three numbers — k, n, m (1 ≤ k ≤ 105, 0 ≤ m ≤ n ≤ 105) — the number of skills, the number of improvements on sale and the number of them Vasya can afford.The second line contains k space-separated numbers ai (1 ≤ ai ≤ 106), the initial values of skills.Next n lines contain 3 space-separated numbers tj, ij, bj (1 ≤ tj ≤ 3, 1 ≤ ij ≤ k, 1 ≤ bj ≤ 106) — the type of the j-th improvement (1 for assigning, 2 for adding, 3 for multiplying), the skill to which it can be applied and the value of b for this improvement.",
      "output_spec": "OutputThe first line should contain a number l (0 ≤ l ≤ m) — the number of improvements you should use.The second line should contain l distinct space-separated numbers vi (1 ≤ vi ≤ n) — the indices of improvements in the order in which they should be applied. The improvements are numbered starting from 1, in the order in which they appear in the input.",
      "sample_tests": "ExamplesInputCopy2 4 313 201 1 141 2 302 1 63 2 2OutputCopy32 3 4",
      "description": "time limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three numbers — k, n, m (1 ≤ k ≤ 105, 0 ≤ m ≤ n ≤ 105) — the number of skills, the number of improvements on sale and the number of them Vasya can afford.The second line contains k space-separated numbers ai (1 ≤ ai ≤ 106), the initial values of skills.Next n lines contain 3 space-separated numbers tj, ij, bj (1 ≤ tj ≤ 3, 1 ≤ ij ≤ k, 1 ≤ bj ≤ 106) — the type of the j-th improvement (1 for assigning, 2 for adding, 3 for multiplying), the skill to which it can be applied and the value of b for this improvement.\n\nOutputThe first line should contain a number l (0 ≤ l ≤ m) — the number of improvements you should use.The second line should contain l distinct space-separated numbers vi (1 ≤ vi ≤ n) — the indices of improvements in the order in which they should be applied. The improvements are numbered starting from 1, in the order in which they appear in the input.\n\nInputCopy2 4 313 201 1 141 2 302 1 63 2 2OutputCopy32 3 4\n\nInputCopy2 4 313 201 1 141 2 302 1 63 2 2\n\nOutputCopy32 3 4",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Hello, Codeforces!On March, 2nd at 10:00 MSK Codeforces Round #295 will be held in both divisions.The round will be held at the same time with Winter Computer Camp olympiad, the problemsets will be highly similar. The problems are by me (Endagorion) and Evgeny Savinov (savinov). The problems are prepared by members of the Winter Computer Camp technical committee: Georgy Chebanov (gchebanov), Filipp Rukhovich (DPR-pavlin), Alexander Mashrabov (map), Sergey Kiyan (sokian), Konstantin Semenov (zemen), Kinan Alsarmini (Sarkin).Big thanks to Max Akhmedov (Zlobober) for his help with preparing the problems, Maria Belova (Delinur) for translating the statements in English, and Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon systems.The scoring is standard for both divisions: 500-1000-1500-2000-2500.Please note that the Winter Computing Camp olympiad is scheduled to finish later than the Codeforces round. Thus, we ask you not to discuss the problems and solutions in the comments until 14:10 MSK. Also, viewing of other participants' solutions will be closed until that time. The editorial will also be published later.UPD: you are free to discuss the problems now.UPD2: the editorial is finally up! Sorry for the delay.Also, grats to our Div.1 winners: Petr hos.lyric Syloviaely andrew.volchek xyz111 Special respect goes to Petr and rng_58 for solving the hardest problem E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1403
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces",
          "content": "We would like to thank the testers of this round's and Winter Computer Camp olympiad's problems: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Make sure to comment if you find any mistakes.UPD: I've just remembered to put up the usual challenges for the problems. So, here they go.520A - PangramIdea: EndagorionPreparation: EndagorionTo check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE. In the end check that there are 26 TRUEs. That is an O(n) solution. Also don't forget to change all letters to lowercase (or all to uppercase). To make all the letters lowercase, one could use standard functions, like tolower in Python. Also, it is known that the letters from a to z have consecutive ASCII numbers, as well as A to Z; an ASCII number of symbol is ord(c) in most languages. So, to get the number of a lowercase letter in the alphabet one can use ord(c) - ord('a') in most languages, or simply c - 'a' in C++ or C (because a char in C/C++ can be treated as a number); to check if a letter is lowercase, the inequality ord('a') <= ord(c) && ord(c) <= ord('z') should be checked.Challenge: how many pangrams of length n are there? Strings that differ only in capitalization of some letters are considered distinct. Can you find the answer modulo some prime p in linear time?520B - Two ButtonsIdea: EndagorionPreparation: EndagorionThe simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2·104 vertices and 4·104 edges, and the BFS should work real fast.There is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".Suppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in .Challenge: suppose we have a generalized problem: we want to get n starting from m using two operations \"subtract a\" and \"multiply by b\". Generalize the solution to find the minimal number of moves to get from n to m in time if a and b are coprime. Can you do it if a and b may have common divisors greater than 1?520C - DNA Alignment/521A - DNA AlignmentIdea: EndagorionPreparation: EndagorionWhat is ρ(s, t) equal to? For every character of s and every character of t there is a unique cyclic shift of t that superposes these characters (indeed, after 0, ..., n - 1 shifts the character in t occupies different positions, and one of them matches the one of the character of s); therefore, there exist n cyclic shifts of s and t that superpose these characters (the situation is symmetrical for every position of the character of s). It follows that the input in ρ from a single character ti is equal to n × (the number of characters in s equal to ti). Therefore, ρ(s, t) is maximal when every character of t occurs the maximal possible number of times in s. Simply count the number of occurences for every type of characters; the answer is Kn, where K is the number of character types that occur in s most frequently. This is an O(n) solution.Challenge: we know that ρmax(s) = n2·C(s), where C(s) is the maximal number that any character occurs in s. How many strings s of length n with characters from an alphabet of size k have C(s) = m? Can you find an O(kn2) solution? An solution? An solution? Maybe even better? (Hint: the modulo should be an appropriately chosen prime number for a fast solution =)).520D - Cubes/521B - CubesIdea: savinovPreparation: savinov, sokian, zemenBasically, the first player should maximize the lexicographical order of numbers, and the second player should minimize it. Thus, at every move the first player should choose the largest available number, and the second should choose the minimal one.First of all, how do we check if the cube can be removed? It is impossible only if there is some cube \"supported\" by it (i.e., it has coordinates (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)) such that our cube is the only one supporting it. This can be checked explicitly. The large coordinates' limitations do not allow us to store a simply array for that, so we should use an associative array, like a set in C++.Now we should find the maximal/minimal number that can be removed. A simple linear search won't work fast enough, so we store another data structure containing all numbers available to remove; the structure should allow inserting, erasing and finding global minimum/maximum, so the set C++ structure fits again.When we've made our move, some cubes may have become available or unavailable to remove. However, there is an O(1) amount of cubes we have to recheck and possibly insert/erase from our structure: the cubes (x ± 1, y) and (x ± 2, y) may have become unavailable because some higher cube has become dangerous (that is, there is a single cube supporting it), and some of the cubes (x - 1, y - 1), (x, y - 1) and (x + 1, y - 1) may have become available because our cube was the only dangerous cube that it has been supporting. Anyway, a simple recheck for these cubes will handle all the cases.This solution is if using the appropriate data structure.Challenge (inspired by questions from jk_qq and RetiredAmrMahmoud): suppose that the players put the numbers from right to left, that is, from the least significant digit to the most significant. The first player still wants to maximize the resulting number, and the second wants to minimize it. If the original rules of taking cubes apply, finding the optimal strategy for the players seems intractable. Try to solve this problem in the case where all the cubes are stacked in several independent towers; that is, a cube may only be taken from the top of any tower.520E - Pluses everywhere/521C - Pluses everywhereIdea: EndagorionPreparation: gchebanov, DPR-pavlinConsider some way of placing all the pluses, and a single digit di (digits in the string are numbered starting from 0 from left to right). This digit gives input of di·10l to the total sum, where l is the distance to the nearest plus from the right, or to the end of string if there are no pluses there. If we sum up these quantities for all digits and all ways of placing the pluses, we will obtain the answer.For a given digit di and some fixed l, how many ways are there to place the pluses? First of all, consider the case when the part containing the digit di is not last, that is, i + l < n - 1. There are n - 1 gaps to place pluses in total; the constraint about di and the distance l means that after digits di, ..., di + l - 1 there are no pluses, while after the digit di + l there should be a plus. That is, the string should look as follows: Here a dot means a gap without a plus, and a question mark means that it's not important whether there is a plus or not. So, out of n - 1 possible gaps there are l + 1 gaps which states are defined, and there is one plus used in these gaps. That means that the other (n - 1) - (l + 1) = n - l - 2 gaps may contain k - 1 pluses in any possible way; that is, the number of such placements is . A similar reasoning implies that if the digit di is in the last part, that is, i + l = n - 1, the number of placements is .To sum up, the total answer is equal to Let us transform the sum: To compute these sums, we will need to know all powers of 10 up to n-th (modulo 109 + 7), along with the binomial coefficients. To compute the binomials, recall that , so it is enough to know all the numbers k! for k upto n, along with their modular inverses. Also we should use the prefix sums of di, that is, the array . The rest is simple evaluation of the above sums.The total complexity is , because the common algorithms for modular inverses (that is, Ferma's little theorem exponentiation or solving a diophantine equation using the Euclid's algorithm) have theoritcal worst-case complexity of . However, one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O(n); for the description of the method refer to this comment by Kaban-5 (not sure why it has a negative rating, I found this quite insightful; maybe anyone can give a proper source for this method?).Challenge: now we want to find the sum of all expressions that are made by placing k pluses with a ≤ k ≤ b; that is, we want to find the sum of the answers for the original problem with k = a, ..., b; here a and b can be any integers with 0 ≤ a ≤ b ≤ n - 1. There is an obvious O(n2) solution: just find the answers for all k separately. Can you find a linear solution?521D - ShopIdea: EndagorionPreparation: gchebanovSuppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.Now we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a + b1 + ... + bi - 1 to a + b1 + ... + bi - 1 + bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.Finally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.To deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a + b1 + ... + bk to b + b1 + ... + bk. That is, the assignment here behaves pretty much the same way as the addition of b - a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.That is, all largest assigments for each skill should be made into additions of b - a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)Finally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions and we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.Challenge: suppose that you have to compare two fractions and , where a, b, c, d may be up to 1018. What way would you use to do that? Can you find a simple solution that does not involve long arithmetics, floating-point number or magic built-in integer types tricks (but may perform a non-constant number of operations)?521E - Cycling CityIdea: EndagorionPreparation: EndagorionWe have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.First of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.Now, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.Otherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.What if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.Finally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n + m) solution; a few logarithmic factors for simplification here and there are also allowed.Challenge: how many graphs G on n labeled vertices exist such that there exist two vertices of G connected by three disjoint paths? (Hint: we have already shown that it suffices to count the number of disjoint unions of cacti.) Find the answer modulo 109 + 7. Can you come up with any polynomial-time solution? An O(n3) solution? Maybe even better?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 521\\s*D"
          },
          "content_length": 16554
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(k, 1, 1000000, \"ai\");\n    inf.readEoln();\n    for (int j = 0; j < n; ++j) {\n        int tj = inf.readInt(1, 3, \"tj\");\n        inf.readSpace();\n        int ij = inf.readInt(1, k, \"ij\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 1000000, \"bj\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(k, 1, 1000000, \"ai\");\n    inf.readEoln();\n    for (int j = 0; j < n; ++j) {\n        int tj = inf.readInt(1, 3, \"tj\");\n        inf.readSpace();\n        int ij = inf.readInt(1, k, \"ij\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 1000000, \"bj\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int k = inf.readInt(1, 100000, \"k\");\n    inf.readSpace();\n    int n = inf.readInt(0, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(k, 1, 1000000, \"ai\");\n    inf.readEoln();\n    for (int j = 0; j < n; ++j) {\n        int tj = inf.readInt(1, 3, \"tj\");\n        inf.readSpace();\n        int ij = inf.readInt(1, k, \"ij\");\n        inf.readSpace();\n        int bj = inf.readInt(1, 1000000, \"bj\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n   Checker for a problem with:\n   - k skills, each initially a_i\n   - n possible improvements\n   - can choose at most m improvements\n   - improvements are of three types: assign, add, multiply\n   This checker does not compare against a \"jury\" solution. \n   It only verifies the contestant's output is well-formed and valid.\n*/\n\nstruct Improvement {\n    int t;       // 1=assign, 2=add, 3=multiply\n    int skill;   // which skill (1-based)\n    long long b; // parameter\n};\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // 1) Read the input file (\"inf\"):\n    int k = inf.readInt(1, 100000, \"k\"); // number of skills\n    int n = inf.readInt(0, 100000, \"n\"); // number of improvements\n    int m = inf.readInt(0, n,        \"m\"); // max improvements allowed\n\n    // Read the initial skill values in log form (to handle large multiplications).\n    vector<long double> skillLog(k);\n    for (int i = 0; i < k; i++) {\n        long long val = inf.readLong(1, 1000000, \"initial_skill\");\n        skillLog[i] = logl((long double) val);\n    }\n\n    // Read the list of n improvements\n    vector<Improvement> imp(n);\n    for (int j = 0; j < n; j++) {\n        int t  = inf.readInt(1, 3, \"improvement_type\");\n        int ix = inf.readInt(1, k, \"skill_index\");\n        long long b = inf.readLong(1, 1000000, \"b_parameter\");\n        imp[j] = {t, ix, b};\n    }\n\n    // 2) Read the contestant's output from \"ouf\":\n    //    A) l = how many improvements chosen, 0 <= l <= m\n    int l = ouf.readInt(0, m, \"l\");\n\n    //    B) read exactly l improvement indices in [1..n].\n    //       testlib handles possible newlines automatically.\n    vector<int> chosen = ouf.readInts(l, 1, n, \"improvement_indices\");\n\n    // After reading those l indices, if there's more data => Wrong Answer\n    if (!ouf.seekEof()) {\n        quitf(_wa, \"extra tokens found after reading %d improvement indices\", l);\n    }\n\n    // 3) Check that these l indices are distinct\n    unordered_set<int> used;\n    used.reserve(l);\n    for (int idx : chosen) {\n        if (!used.insert(idx).second) {\n            quitf(_wa, \"improvement index %d is used multiple times\", idx);\n        }\n    }\n\n    // 4) Apply each improvement in log form.\n    //    - type=1 => assign skill = b\n    //    - type=2 => skill = skill + b\n    //    - type=3 => skill = skill * b\n    for (int idx : chosen) {\n        const auto &im = imp[idx - 1]; // idx is 1-based\n        int sPos = im.skill - 1;       // make 0-based\n        if (im.t == 1) {\n            // assign\n            skillLog[sPos] = logl((long double)im.b);\n        }\n        else if (im.t == 2) {\n            // add\n            long double cur = expl(skillLog[sPos]); \n            cur += (long double)im.b;\n            if (cur <= 0.0L) {\n                quitf(_wa, \"skill %d became non-positive after an 'add'\", sPos + 1);\n            }\n            skillLog[sPos] = logl(cur);\n        }\n        else {\n            // multiply\n            skillLog[sPos] += logl((long double)im.b);\n        }\n    }\n\n    // If we get here, the output is valid\n    quitf(_ok, \"valid output\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string case_type = opt<string>(\"case\", \"random\");\n\n    vector<int> a(k);\n\n    if (case_type == \"min\") {\n        for (int i = 0; i < k; ++i)\n            a[i] = 1;\n    } else if (case_type == \"max\") {\n        for (int i = 0; i < k; ++i)\n            a[i] = 1000000;\n    } else if (case_type == \"ones\") {\n        for (int i = 0; i < k; ++i)\n            a[i] = 1;\n    } else if (case_type == \"max_product\") {\n        // Set initial skills to minimal values\n        for (int i = 0; i < k; ++i)\n            a[i] = 1;\n        // The improvements will be designed to maximize the product\n    } else {\n        // random case\n        for (int i = 0; i < k; ++i)\n            a[i] = rnd.next(1, 1000000);\n    }\n\n    // Output k, n, m\n    printf(\"%d %d %d\\n\", k, n, m);\n\n    // Output the initial skill values\n    for (int i = 0; i < k; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate the improvements\n    vector<tuple<int, int, int>> improvements;\n\n    if (case_type == \"min\") {\n        // Only minimal improvements\n        for (int j = 0; j < n; ++j) {\n            int t = 1;\n            int i = rnd.next(1, k);\n            int b = 1;\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"max\") {\n        for (int j = 0; j < n; ++j) {\n            int t = rnd.next(1, 3);\n            int i = rnd.next(1, k);\n            int b = 1000000;\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"single_skill\") {\n        int skill_index = rnd.next(1, k);\n        for (int j = 0; j < n; ++j) {\n            int t = rnd.next(1, 3);\n            int i = skill_index;\n            int b = rnd.next(1, 1000000);\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"single_type\") {\n        int t = rnd.next(1, 3);\n        for (int j = 0; j < n; ++j) {\n            int i = rnd.next(1, k);\n            int b = rnd.next(1, 1000000);\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"max_product\") {\n        // Try to generate improvements that will maximize the final product\n        // For initial skills set to 1, we can set multiplies to 1e6\n        for (int j = 0; j < n; ++j) {\n            int t = 3; // Multiply\n            int i = rnd.next(1, k);\n            int b = 1000000;\n            improvements.emplace_back(t, i, b);\n        }\n    } else {\n        // random case\n        for (int j = 0; j < n; ++j) {\n            int t = rnd.next(1, 3);\n            int i = rnd.next(1, k);\n            int b = rnd.next(1, 1000000);\n            improvements.emplace_back(t, i, b);\n        }\n    }\n\n    // Output the improvements\n    for (int j = 0; j < n; ++j) {\n        int t, i, b;\n        tie(t, i, b) = improvements[j];\n        printf(\"%d %d %d\\n\", t, i, b);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string case_type = opt<string>(\"case\", \"random\");\n\n    vector<int> a(k);\n\n    if (case_type == \"min\") {\n        for (int i = 0; i < k; ++i)\n            a[i] = 1;\n    } else if (case_type == \"max\") {\n        for (int i = 0; i < k; ++i)\n            a[i] = 1000000;\n    } else if (case_type == \"ones\") {\n        for (int i = 0; i < k; ++i)\n            a[i] = 1;\n    } else if (case_type == \"max_product\") {\n        // Set initial skills to minimal values\n        for (int i = 0; i < k; ++i)\n            a[i] = 1;\n        // The improvements will be designed to maximize the product\n    } else {\n        // random case\n        for (int i = 0; i < k; ++i)\n            a[i] = rnd.next(1, 1000000);\n    }\n\n    // Output k, n, m\n    printf(\"%d %d %d\\n\", k, n, m);\n\n    // Output the initial skill values\n    for (int i = 0; i < k; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", a[i]);\n    }\n    printf(\"\\n\");\n\n    // Generate the improvements\n    vector<tuple<int, int, int>> improvements;\n\n    if (case_type == \"min\") {\n        // Only minimal improvements\n        for (int j = 0; j < n; ++j) {\n            int t = 1;\n            int i = rnd.next(1, k);\n            int b = 1;\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"max\") {\n        for (int j = 0; j < n; ++j) {\n            int t = rnd.next(1, 3);\n            int i = rnd.next(1, k);\n            int b = 1000000;\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"single_skill\") {\n        int skill_index = rnd.next(1, k);\n        for (int j = 0; j < n; ++j) {\n            int t = rnd.next(1, 3);\n            int i = skill_index;\n            int b = rnd.next(1, 1000000);\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"single_type\") {\n        int t = rnd.next(1, 3);\n        for (int j = 0; j < n; ++j) {\n            int i = rnd.next(1, k);\n            int b = rnd.next(1, 1000000);\n            improvements.emplace_back(t, i, b);\n        }\n    } else if (case_type == \"max_product\") {\n        // Try to generate improvements that will maximize the final product\n        // For initial skills set to 1, we can set multiplies to 1e6\n        for (int j = 0; j < n; ++j) {\n            int t = 3; // Multiply\n            int i = rnd.next(1, k);\n            int b = 1000000;\n            improvements.emplace_back(t, i, b);\n        }\n    } else {\n        // random case\n        for (int j = 0; j < n; ++j) {\n            int t = rnd.next(1, 3);\n            int i = rnd.next(1, k);\n            int b = rnd.next(1, 1000000);\n            improvements.emplace_back(t, i, b);\n        }\n    }\n\n    // Output the improvements\n    for (int j = 0; j < n; ++j) {\n        int t, i, b;\n        tie(t, i, b) = improvements[j];\n        printf(\"%d %d %d\\n\", t, i, b);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimal case\n./gen -n 0 -m 0 -k 1 -case min\n\n# Small random case\n./gen -n 5 -m 3 -k 2 -case random\n\n# Medium random case\n./gen -n 1000 -m 500 -k 1000 -case random\n\n# Large random case\n./gen -n 100000 -m 100000 -k 100000 -case random\n\n# Maximal case\n./gen -n 100000 -m 100000 -k 100000 -case max\n\n# All improvements on a single skill\n./gen -n 100000 -m 50000 -k 1000 -case single_skill\n\n# All improvements of a single type\n./gen -n 100000 -m 50000 -k 1000 -case single_type\n\n# Maximize product case\n./gen -n 100000 -m 100000 -k 100000 -case max_product\n\n# Edge case where m = 0 (no improvements can be used)\n./gen -n 100000 -m 0 -k 100000 -case random\n\n# Edge case where m = n (all improvements can be used)\n./gen -n 100000 -m 100000 -k 100000 -case random\n\n# All initial skills are ones\n./gen -n 100000 -m 100000 -k 100000 -case ones\n\n# Small m, large n\n./gen -n 100000 -m 10 -k 100000 -case random\n\n# m = n / 2\n./gen -n 100000 -m 50000 -k 100000 -case random\n\n# All improvements of type 1\n# (Assuming you modify the generator to accept -t parameter)\n# For now, we use single_type case\n./gen -n 100000 -m 100000 -k 100000 -case single_type\n\n# All improvements of type 2\n# (Assuming you modify the generator to accept -t parameter)\n./gen -n 100000 -m 100000 -k 100000 -case single_type\n\n# All improvements of type 3\n# (Assuming you modify the generator to accept -t parameter)\n./gen -n 100000 -m 100000 -k 100000 -case single_type\n\n# Improvements with minimal bj\n./gen -n 100000 -m 50000 -k 100000 -case min\n\n# Random skill values, few improvements\n./gen -n 1000 -m 1000 -k 100000 -case random\n\n# Small k, large n\n./gen -n 100000 -m 50000 -k 10 -case random\n\n# Initial skills are maximal, improvements do not help much\n./gen -n 100000 -m 100000 -k 100000 -case max\n\n# All initial skills are random between 1 and 1e6\n./gen -n 50000 -m 25000 -k 50000 -case random\n\n# Random case with small k\n./gen -n 10000 -m 5000 -k 5 -case random\n\n# Random case with large m and small n\n./gen -n 5000 -m 5000 -k 100000 -case random\n\n# Edge case where m = n = 0\n./gen -n 0 -m 0 -k 100000 -case random\n\n# Maximize product with small k\n./gen -n 100000 -m 100000 -k 5 -case max_product\n\n# Single skill, minimal improvements\n./gen -n 100000 -m 100000 -k 1 -case min\n\n# Maximize product with all skills\n./gen -n 100000 -m 100000 -k 1000 -case max_product\n\n# Random case with m = 1\n./gen -n 100000 -m 1 -k 100000 -case random\n\n# All skills have the same initial value\n./gen -n 50000 -m 25000 -k 100000 -case ones\n\n# Single type of improvements, type 3\n./gen -n 100000 -m 100000 -k 1000 -case single_type\n\n# Random case with maximum bj\n./gen -n 100000 -m 50000 -k 100000 -case max\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:14.331000",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "521/E",
      "title": "E. Cycling City",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m (1 ≤ n, m ≤ 2·105) — the number of intersections and roads, respectively.The following m lines contain two integers — the numbers of the intersections connected by a road (the intersections are numbered starting with 1). It is guaranteed that each pair of intersections is connected by no more than one road, and no road connects the intersection to itself.Please note that it is not guaranteed that you can get from any junction to any other one by using the roads.",
      "output_spec": "OutputIf it is possible to create the routes, in the first line print \"YES\". In the next three lines print the descriptions of each of the three routes in the format \"l p1 ... pl\", where l is the number of intersections in the route, and p1, ..., pl are their numbers in the order they follow. The routes must meet all the requirements specified in the statement.If it is impossible to make the routes in accordance with the requirements, print NO.",
      "sample_tests": "ExamplesInputCopy4 41 22 33 44 1OutputCopyNOInputCopy5 61 21 31 42 53 54 5OutputCopyYES3 5 4 13 5 3 13 5 2 1",
      "description": "E. Cycling City\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m (1 ≤ n, m ≤ 2·105) — the number of intersections and roads, respectively.The following m lines contain two integers — the numbers of the intersections connected by a road (the intersections are numbered starting with 1). It is guaranteed that each pair of intersections is connected by no more than one road, and no road connects the intersection to itself.Please note that it is not guaranteed that you can get from any junction to any other one by using the roads.\n\nOutputIf it is possible to create the routes, in the first line print \"YES\". In the next three lines print the descriptions of each of the three routes in the format \"l p1 ... pl\", where l is the number of intersections in the route, and p1, ..., pl are their numbers in the order they follow. The routes must meet all the requirements specified in the statement.If it is impossible to make the routes in accordance with the requirements, print NO.\n\nInputCopy4 41 22 33 44 1OutputCopyNOInputCopy5 61 21 31 42 53 54 5OutputCopyYES3 5 4 13 5 3 13 5 2 1\n\nInputCopy4 41 22 33 44 1\n\nOutputCopyNO\n\nInputCopy5 61 21 31 42 53 54 5\n\nOutputCopyYES3 5 4 13 5 3 13 5 2 1",
      "solutions": [
        {
          "title": "Codeforces Round #295 - Codeforces",
          "content": "Hello, Codeforces!On March, 2nd at 10:00 MSK Codeforces Round #295 will be held in both divisions.The round will be held at the same time with Winter Computer Camp olympiad, the problemsets will be highly similar. The problems are by me (Endagorion) and Evgeny Savinov (savinov). The problems are prepared by members of the Winter Computer Camp technical committee: Georgy Chebanov (gchebanov), Filipp Rukhovich (DPR-pavlin), Alexander Mashrabov (map), Sergey Kiyan (sokian), Konstantin Semenov (zemen), Kinan Alsarmini (Sarkin).Big thanks to Max Akhmedov (Zlobober) for his help with preparing the problems, Maria Belova (Delinur) for translating the statements in English, and Mike Mirzayanov (MikeMirzayanov) for creating Codeforces and Polygon systems.The scoring is standard for both divisions: 500-1000-1500-2000-2500.Please note that the Winter Computing Camp olympiad is scheduled to finish later than the Codeforces round. Thus, we ask you not to discuss the problems and solutions in the comments until 14:10 MSK. Also, viewing of other participants' solutions will be closed until that time. The editorial will also be published later.UPD: you are free to discuss the problems now.UPD2: the editorial is finally up! Sorry for the delay.Also, grats to our Div.1 winners: Petr hos.lyric Syloviaely andrew.volchek xyz111 Special respect goes to Petr and rng_58 for solving the hardest problem E!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16707",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1403
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces",
          "content": "We would like to thank the testers of this round's and Winter Computer Camp olympiad's problems: alger95, thefacetakt, adamant, -imc-, riskingh, ASverdlov.Make sure to comment if you find any mistakes.UPD: I've just remembered to put up the usual challenges for the problems. So, here they go.520A - PangramIdea: EndagorionPreparation: EndagorionTo check that every letter is present in the string we can just make a boolean array of size 26 and for every letter set the corresponding variable to TRUE. In the end check that there are 26 TRUEs. That is an O(n) solution. Also don't forget to change all letters to lowercase (or all to uppercase). To make all the letters lowercase, one could use standard functions, like tolower in Python. Also, it is known that the letters from a to z have consecutive ASCII numbers, as well as A to Z; an ASCII number of symbol is ord(c) in most languages. So, to get the number of a lowercase letter in the alphabet one can use ord(c) - ord('a') in most languages, or simply c - 'a' in C++ or C (because a char in C/C++ can be treated as a number); to check if a letter is lowercase, the inequality ord('a') <= ord(c) && ord(c) <= ord('z') should be checked.Challenge: how many pangrams of length n are there? Strings that differ only in capitalization of some letters are considered distinct. Can you find the answer modulo some prime p in linear time?520B - Two ButtonsIdea: EndagorionPreparation: EndagorionThe simplest solution is simply doing a breadth-first search. Construct a graph with numbers as vertices and edges leading from one number to another if an operation can be made to change one number to the other. We may note that it is never reasonable to make the number larger than 2m, so under provided limitations the graph will contain at most 2·104 vertices and 4·104 edges, and the BFS should work real fast.There is, however, an even faster solution. The problem can be reversed as follows: we should get the number n starting from m using the operations \"add 1 to the number\" and \"divide the number by 2 if it is even\".Suppose that at some point we perform two operations of type 1 and then one operation of type 2; but in this case one operation of type 2 and one operation of type 1 would lead to the same result, and the sequence would contain less operations then before. That reasoning implies that in an optimal answer more than one consecutive operation of type 1 is possible only if no operations of type 2 follow, that is, the only situation where it makes sense is when n is smaller than m and we just need to make it large enough. Under this constraint, there is the only correct sequence of moves: if n is smaller than m, we just add 1 until they become equal; else we divide n by 2 if it is even, or add 1 and then divide by 2 if it is odd. The length of this sequence can be found in .Challenge: suppose we have a generalized problem: we want to get n starting from m using two operations \"subtract a\" and \"multiply by b\". Generalize the solution to find the minimal number of moves to get from n to m in time if a and b are coprime. Can you do it if a and b may have common divisors greater than 1?520C - DNA Alignment/521A - DNA AlignmentIdea: EndagorionPreparation: EndagorionWhat is ρ(s, t) equal to? For every character of s and every character of t there is a unique cyclic shift of t that superposes these characters (indeed, after 0, ..., n - 1 shifts the character in t occupies different positions, and one of them matches the one of the character of s); therefore, there exist n cyclic shifts of s and t that superpose these characters (the situation is symmetrical for every position of the character of s). It follows that the input in ρ from a single character ti is equal to n × (the number of characters in s equal to ti). Therefore, ρ(s, t) is maximal when every character of t occurs the maximal possible number of times in s. Simply count the number of occurences for every type of characters; the answer is Kn, where K is the number of character types that occur in s most frequently. This is an O(n) solution.Challenge: we know that ρmax(s) = n2·C(s), where C(s) is the maximal number that any character occurs in s. How many strings s of length n with characters from an alphabet of size k have C(s) = m? Can you find an O(kn2) solution? An solution? An solution? Maybe even better? (Hint: the modulo should be an appropriately chosen prime number for a fast solution =)).520D - Cubes/521B - CubesIdea: savinovPreparation: savinov, sokian, zemenBasically, the first player should maximize the lexicographical order of numbers, and the second player should minimize it. Thus, at every move the first player should choose the largest available number, and the second should choose the minimal one.First of all, how do we check if the cube can be removed? It is impossible only if there is some cube \"supported\" by it (i.e., it has coordinates (x - 1, y + 1), (x, y + 1), (x + 1, y + 1)) such that our cube is the only one supporting it. This can be checked explicitly. The large coordinates' limitations do not allow us to store a simply array for that, so we should use an associative array, like a set in C++.Now we should find the maximal/minimal number that can be removed. A simple linear search won't work fast enough, so we store another data structure containing all numbers available to remove; the structure should allow inserting, erasing and finding global minimum/maximum, so the set C++ structure fits again.When we've made our move, some cubes may have become available or unavailable to remove. However, there is an O(1) amount of cubes we have to recheck and possibly insert/erase from our structure: the cubes (x ± 1, y) and (x ± 2, y) may have become unavailable because some higher cube has become dangerous (that is, there is a single cube supporting it), and some of the cubes (x - 1, y - 1), (x, y - 1) and (x + 1, y - 1) may have become available because our cube was the only dangerous cube that it has been supporting. Anyway, a simple recheck for these cubes will handle all the cases.This solution is if using the appropriate data structure.Challenge (inspired by questions from jk_qq and RetiredAmrMahmoud): suppose that the players put the numbers from right to left, that is, from the least significant digit to the most significant. The first player still wants to maximize the resulting number, and the second wants to minimize it. If the original rules of taking cubes apply, finding the optimal strategy for the players seems intractable. Try to solve this problem in the case where all the cubes are stacked in several independent towers; that is, a cube may only be taken from the top of any tower.520E - Pluses everywhere/521C - Pluses everywhereIdea: EndagorionPreparation: gchebanov, DPR-pavlinConsider some way of placing all the pluses, and a single digit di (digits in the string are numbered starting from 0 from left to right). This digit gives input of di·10l to the total sum, where l is the distance to the nearest plus from the right, or to the end of string if there are no pluses there. If we sum up these quantities for all digits and all ways of placing the pluses, we will obtain the answer.For a given digit di and some fixed l, how many ways are there to place the pluses? First of all, consider the case when the part containing the digit di is not last, that is, i + l < n - 1. There are n - 1 gaps to place pluses in total; the constraint about di and the distance l means that after digits di, ..., di + l - 1 there are no pluses, while after the digit di + l there should be a plus. That is, the string should look as follows: Here a dot means a gap without a plus, and a question mark means that it's not important whether there is a plus or not. So, out of n - 1 possible gaps there are l + 1 gaps which states are defined, and there is one plus used in these gaps. That means that the other (n - 1) - (l + 1) = n - l - 2 gaps may contain k - 1 pluses in any possible way; that is, the number of such placements is . A similar reasoning implies that if the digit di is in the last part, that is, i + l = n - 1, the number of placements is .To sum up, the total answer is equal to Let us transform the sum: To compute these sums, we will need to know all powers of 10 up to n-th (modulo 109 + 7), along with the binomial coefficients. To compute the binomials, recall that , so it is enough to know all the numbers k! for k upto n, along with their modular inverses. Also we should use the prefix sums of di, that is, the array . The rest is simple evaluation of the above sums.The total complexity is , because the common algorithms for modular inverses (that is, Ferma's little theorem exponentiation or solving a diophantine equation using the Euclid's algorithm) have theoritcal worst-case complexity of . However, one can utilize a neat trick for finding modular inverses for first n consecutive numbers in linear time for a total complexity of O(n); for the description of the method refer to this comment by Kaban-5 (not sure why it has a negative rating, I found this quite insightful; maybe anyone can give a proper source for this method?).Challenge: now we want to find the sum of all expressions that are made by placing k pluses with a ≤ k ≤ b; that is, we want to find the sum of the answers for the original problem with k = a, ..., b; here a and b can be any integers with 0 ≤ a ≤ b ≤ n - 1. There is an obvious O(n2) solution: just find the answers for all k separately. Can you find a linear solution?521D - ShopIdea: EndagorionPreparation: gchebanovSuppose the only type of upgrades we have is multiplication. It doesn't even matter for the answer which particular skill we are going to multiply, so we just choose several upgrades with greatest values of bi.Now we have additions as well; set multiplications aside for a moment. It is clear that for every skill we should choose several largest additions (maybe none). Let us sort the additions for every skill by non-increasing; now we should choose several first upgrades for each type. Now, for some skill the (non-increasing) sorted row of b's is b1, ..., bl, and the initial value of the skill is a. Now, as we have decided to take some prefix of b's, we know that if we take the upgrade bi, the value changes from a + b1 + ... + bi - 1 to a + b1 + ... + bi - 1 + bi. That is, the ratio by which the value (and the whole product of values) is going to be multiplied by is the fraction . Now, with that ratio determined unambigiously for each addition upgrade, every addition has actually become a multiplication. =) So we have to compute the ratios for all additions (that is, we sort b's for each skill separately and find the fractions), and then sort the multiplications and additions altogether by the ratio they affect the whole product with. Clearly, all multiplications should be used after all the additions are done; that is, to choose which upgrades we use we should do the ratio sorting, but the order of actual using of upgrades is: first do all the additions, then do all the multiplications.Finally, let's deal with the assignment upgrades. Clearly, for each skill at most one assignment upgrade should be used, and if it used, it should the assignment upgrade with the largest b among all assignments for this skill. Also, if the assignment is used, it should be used before all the additions and multiplications for this skill. So, for each skill we should simply determine whether we use the largest assignment for this skill or not. However, if we use the assignment, the ratios for the additions of current skill become invalid as the starting value of a is altered.To deal with this problem, imagine that we have first chosen some addition upgrades, and now we have to choose whether we use the assignment upgrade or not. If we do, the value of the skill changes from a + b1 + ... + bk to b + b1 + ... + bk. That is, the assignment here behaves pretty much the same way as the addition of b - a. The only difference is that once we have chosen to use the assignment, we should put it before all the additions.That is, all largest assigments for each skill should be made into additions of b - a and processed along with all the other additions, which are, as we already know, going to become multiplications in the end. =)Finally, the problem is reduced to sorting the ratios for all upgrades. Let us estimate the numbers in the fractions. The ratio for a multiplication is an integer up to 106; the ratio for an addition is a fraction of general form . As k can be up to 105, and bi is up to 106, the numerator and denominator of such fraction can go up to 1011. To compare fractions and we should compare the products ad and bc, which can go up to 1022 by our estimates. That, unfortunately, overflows built-in integer types in most languages. However, this problem can be solved by subtracting 1 from all ratios (which clearly does not change the order of ratios), so that the additions' ratios will look like . Now, the numerator is up to 106, the products in the comparison are up to 1017, which fits in 64-bit integer type in any language.Challenge: suppose that you have to compare two fractions and , where a, b, c, d may be up to 1018. What way would you use to do that? Can you find a simple solution that does not involve long arithmetics, floating-point number or magic built-in integer types tricks (but may perform a non-constant number of operations)?521E - Cycling CityIdea: EndagorionPreparation: EndagorionWe have to find two vertices in an undirected graph such that there exist three vertex- and edge-independent paths between them. This could easily be a flow problem if not for the large constraints.First of all, we can notice that all the paths between vertices should lie in the same biconnected component of the graph. Indeed, for every simple cycle all of its edges should lie in the same biconnected component, and the three-paths system is a union of cycles. Thus, we can find all the biconnected components of the graph and try to solve the problem for each of them independently. The computing of biconnected components can be done in linear time; a neat algorithm for doing this is described in the Wikipedia article by the link above.Now, we have a biconnected component and the same problem as before. First of all, find any cycle in this component (with a simple DFS); the only case of a biconnected component that does not contain a cycle is a single edge, which is of no interest. Suppose that no vertex of this cycle has an adjacent edge that doesn't lie in the cycle; this means the cycle is not connected to anything else in the component, so the component is this cycle itself, in which case there is clearly no solution.Otherwise, find a vertex v with an adjacent edge e that doesn't lie in the cycle (denote it c). If we can find a path p starting with e that arrives at a cycle vertex u (different from v), then we can find three vertex-distinct paths between v and u: one path is p, and two others are halves of the initial cycle. To find p, start a DFS from the edge e that halts when it arrives to vertex of c (that is different from v) and recovers all the paths.What if we find that no appropriate path p exists? Denote C the component traversed by the latter DFS. The DFS did not find any path between vertices of C\\ {v} and c\\ {v}, therefore every such path should pass through v. That means that upon deletion of v, the component C\\ {v} becomes separated from all vertices of c\\ {v}, which contradicts with the assumption that the component was biconnected. That reasoning proves that the DFS starting from e will always find the path p and find the answer if only a biconnected component was not a cycle nor a single edge.Finally, we obtain that the only case when the answer is non-existent is when all the biconnected components are single edges or simple cycles, that is, the graph is a union of disconnected cactuses. Otherwise, a couple of DFS are sure to find three vertex-disjoint paths. This yields an O(n + m) solution; a few logarithmic factors for simplification here and there are also allowed.Challenge: how many graphs G on n labeled vertices exist such that there exist two vertices of G connected by three disjoint paths? (Hint: we have already shown that it suffices to count the number of disjoint unions of cacti.) Find the answer modulo 109 + 7. Can you come up with any polynomial-time solution? An O(n3) solution? Maybe even better?",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16736",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 521\\s*E"
          },
          "content_length": 16554
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #295 - Codeforces - Code 1",
          "code": "mod = (int)1e9+9;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 2",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 3",
          "code": "ModInt.h:\ntemplate <uInt64 _Key = 1000000007ull>\nclass ModInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 4",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS * n * n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 5",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 6",
          "code": "MAXIMUM_NUMBER_OF_ITERATIONS",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 7",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 - Codeforces - Code 8",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16707",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 1",
          "code": "ord(c) - ord('a')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 2",
          "code": "ord('a') <= ord(c) && ord(c) <= ord('z')",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 3",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 4",
          "code": "int calc(int n) {\n    if(n >= m) return n - m;\n    int &res = dp[n];\n    if(res != -1) return res;\n    res = inf;\n    for(int i = n; i * 2 > n; i--) {\n        res = min(res, n - i + 1 + calc(2 * i));\n    }\n    return res;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 5",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 6",
          "code": "int fun(int n,int m)\n{\n   if(n>=m)\n   {\n     return n-m;\n   }\n   else if(m%2==0)\n   {\n     return 1+fun(n,m/2);\n   }\n   else\n   {\n     return 2+fun(n,(m+1)/2);\n   }\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 7",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 8",
          "code": "// Let MOD = i * q + r\n    // i * q == -r\n    // i * q * r^{-1} * (-1) == 1\n    // i^{-1} == (-1) * q * r^{-1}\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++)\n        inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 9",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 10",
          "code": "while(n != m){\n        if(n > m)\n            n--;\n        else{\n            if(m % 2 == 0){\n                m /= 2;\n            }\n            else{\n                if((n-1)*2 >= m)\n                    n--;\n                else\n                    n *= 2;\n            }\n        }\n        sol++;\n    }",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 11",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 12",
          "code": "struct Frac {\n  int num, den;\n  bool operator<(const Frac& f) const {\n    int d1 = num / den, d2 = f.num / f.den;\n    if (d1 != d2) return d1 < d2;\n    return Frac{f.den, f.num - d2 * f.den} < Frac{den, num - d1 * den};\n  }\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 13",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 14",
          "code": "solve indx cnt =\n    if indx == n return (cnt == 26)\n    if cnt == 26 return 2 * 26 * (solve (indx+1) cnt)\n    return 2 * cnt * (solve (indx+1) cnt) +\n           2 * (26 - cnt) * (solve(indx+1) (cnt+1))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 15",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #295 Editorial (now with bonuses!) - Codeforces - Code 16",
          "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    int cnt = 0;\n    while (m > n)\n    {\n        cnt += (m & 1) + 1;\n        m = (m + 1) / 2;\n    }\n\n    cout << (cnt + n - m);\n    return 0;\n}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/16736",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loop detected at edge %d: (%d, %d)\", i+1, u, v);\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between intersections %d and %d\", a, b);\n        edges.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loop detected at edge %d: (%d, %d)\", i+1, u, v);\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between intersections %d and %d\", a, b);\n        edges.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    set<pair<int, int>> edges;\n\n    for (int i = 0; i < m; i++) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Self-loop detected at edge %d: (%d, %d)\", i+1, u, v);\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edges.count({a, b}) == 0, \"Multiple edges between intersections %d and %d\", a, b);\n        edges.insert({a, b});\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<set<int>> adj;\nset<pair<int, int>> edges;\n\nvoid checkRoutes(InStream& stream) {\n    const int routeCount = 3;\n    vector<vector<int>> routes(routeCount);\n    vector<set<int>> routeNodes(routeCount);\n    vector<set<pair<int, int>>> routeEdges(routeCount);\n    set<int> startFinishNodes;\n    // Read and check each route\n    for (int k = 0; k < routeCount; ++k) {\n        int l = stream.readInt(2, n, format(\"length of route %d\", k + 1).c_str());\n        vector<int> route;\n        set<int> visitedNodes;\n        set<pair<int, int>> usedEdges;\n        int u = stream.readInt(1, n, format(\"route %d node 1\", k + 1).c_str());\n        route.push_back(u);\n        visitedNodes.insert(u);\n        for (int i = 1; i < l; ++i) {\n            int v = stream.readInt(1, n, format(\"route %d node %d\", k + 1, i + 1).c_str());\n            route.push_back(v);\n            // Check that edge exists between u and v\n            if (adj[u].count(v) == 0) {\n                stream.quitf(_wa, \"No edge between %d and %d in route %d\", u, v, k + 1);\n            }\n            // Check that edge has not been used before in this route\n            int a = u, b = v;\n            if (a > b) swap(a, b);\n            pair<int, int> edge = make_pair(a, b);\n            if (usedEdges.count(edge)) {\n                stream.quitf(_wa, \"Edge between %d and %d used more than once in route %d\", u, v, k + 1);\n            }\n            usedEdges.insert(edge);\n            // Check that node has not been visited before in this route\n            if (visitedNodes.count(v)) {\n                stream.quitf(_wa, \"Node %d visited more than once in route %d\", v, k + 1);\n            }\n            visitedNodes.insert(v);\n            u = v;\n        }\n        // Store route information\n        routes[k] = route;\n        routeNodes[k] = visitedNodes;\n        routeEdges[k] = usedEdges;\n        startFinishNodes.insert(route.front());\n        startFinishNodes.insert(route.back());\n    }\n    // Check that all routes start and end at the same nodes, and start != finish\n    if (startFinishNodes.size() != 2) {\n        stream.quitf(_wa, \"Routes do not have the same start and finish nodes or start equals finish\");\n    }\n    int start = routes[0].front();\n    int finish = routes[0].back();\n    if (start == finish) {\n        stream.quitf(_wa, \"Start and finish nodes are the same: %d\", start);\n    }\n    for (int k = 1; k < routeCount; ++k) {\n        if (routes[k].front() != start) {\n            stream.quitf(_wa, \"Route %d does not start at node %d\", k + 1, start);\n        }\n        if (routes[k].back() != finish) {\n            stream.quitf(_wa, \"Route %d does not finish at node %d\", k + 1, finish);\n        }\n    }\n    // Check that no two routes share nodes (except start and finish) and edges\n    set<int> sharedNodes = {start, finish};\n    for (int i = 0; i < routeCount; ++i) {\n        for (int j = i + 1; j < routeCount; ++j) {\n            for (int node : routeNodes[i]) {\n                if (sharedNodes.count(node)) continue;\n                if (routeNodes[j].count(node)) {\n                    stream.quitf(_wa, \"Routes %d and %d share node %d\", i + 1, j + 1, node);\n                }\n            }\n            for (const auto& edge : routeEdges[i]) {\n                if (routeEdges[j].count(edge)) {\n                    stream.quitf(_wa, \"Routes %d and %d share edge between %d and %d\", i + 1, j + 1, edge.first, edge.second);\n                }\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input graph\n    n = inf.readInt(1, 200000, \"n\");\n    m = inf.readInt(0, 200000, \"m\");\n    adj.resize(n + 1);\n    edges.clear();\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        int v = inf.readInt(1, n, \"v\");\n        adj[u].insert(v);\n        adj[v].insert(u);\n        if (u > v) swap(u, v);\n        edges.insert(make_pair(u, v));\n    }\n\n    // Read jury's output\n    string jans = ans.readToken();\n    if (jans != \"YES\" && jans != \"NO\") {\n        quitf(_fail, \"Jury's answer is neither YES nor NO\");\n    }\n\n    // Read participant's output\n    string pans = ouf.readToken();\n    if (pans != \"YES\" && pans != \"NO\") {\n        quitf(_pe, \"Participant's answer is neither YES nor NO\");\n    }\n\n    if (jans == \"NO\") {\n        if (pans == \"NO\") {\n            // Correct: both outputs are NO\n            ouf.skipBlanks();\n            if (!ouf.eof()) {\n                quitf(_pe, \"Participant's output contains extra data after NO\");\n            }\n            quitf(_ok, \"Correctly output NO\");\n        } else {\n            // Participant's output YES, but correct answer is NO\n            quitf(_wa, \"Participant outputs YES, but correct answer is NO\");\n        }\n    } else {\n        // Jury's answer is YES\n        if (pans == \"NO\") {\n            // Participant's output NO, but correct answer is YES\n            quitf(_wa, \"Participant outputs NO, but correct answer is YES\");\n        } else {\n            // Both outputs are YES, check participant's routes\n            checkRoutes(ouf);\n            // Ensure participant's output does not contain extra data\n            ouf.skipBlanks();\n            if (!ouf.eof()) {\n                quitf(_pe, \"Participant's output contains extra data after routes\");\n            }\n            quitf(_ok, \"Correct\");\n        }\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default -1\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // chain: nodes connected in line\n        // n >= 2\n        assert(n >= 1);\n        m = max(0, n -1);\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n    }\n    else if (type == \"star\") {\n        // star: central node connected to all others\n        assert(n >=1);\n        int center = 1;\n        m = n -1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({center, i});\n        }\n    }\n    else if (type == \"tree\") {\n        // generate a random tree\n        assert(n >= 1);\n        m = n -1;\n        vector<int> p(n +1);\n        for(int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i -1);\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n    else if (type == \"complete\") {\n        // complete graph\n        m = n * (n -1) / 2;\n        assert(m <= 200000);\n        for(int i =1; i <= n; ++i)\n            for(int j = i+1; j <= n; ++j)\n                edges.push_back({i, j});\n        shuffle(edges.begin(), edges.end());\n    }\n    else if (type == \"cycle\") {\n        // cycle graph\n        assert(n >= 3);\n        m = n;\n        for(int i =1; i <= n; ++i) {\n            edges.push_back({i, i % n +1});\n        }\n    }\n    else if (type == \"random\") {\n        // generate m random edges\n        if (m == -1) {\n            m = n * (n -1) / 2;\n            if (m > 200000) m = 200000;\n        }\n        assert(m >=0 && m <= min(1LL * n * (n -1) / 2, 200000LL));\n\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            pair<int,int> e = {u,v};\n            if (edge_set.count(e)) continue;\n            edge_set.insert(e);\n        }\n        for (auto e : edge_set) {\n            edges.push_back(e);\n        }\n    }\n    else if (type == \"disconnected\") {\n        // create disconnected components\n        // For simplicity, split into two components\n        assert(n >= 2);\n        int n1 = n / 2;\n        int n2 = n - n1;\n        // First component: nodes 1..n1\n        // Second component: nodes n1+1 .. n\n        vector<int> component_nodes = {n1, n2};\n        m = 0;\n        for (int c =0; c < 2; ++c) {\n            int cn = component_nodes[c];\n            int node_offset = c ==0 ? 1 : n1+1;\n            vector<int> nodes;\n            for(int i =0; i < cn; ++i)\n                nodes.push_back(node_offset + i);\n            // Create a chain in this component\n            for(int i = 1; i < cn; ++i) {\n                edges.push_back({nodes[i-1], nodes[i]});\n                m++;\n            }\n        }\n    }\n    else {\n        // default to empty graph\n        m = 0;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", -1); // default -1\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // chain: nodes connected in line\n        // n >= 2\n        assert(n >= 1);\n        m = max(0, n -1);\n        for (int i = 1; i < n; i++) {\n            edges.push_back({i, i+1});\n        }\n    }\n    else if (type == \"star\") {\n        // star: central node connected to all others\n        assert(n >=1);\n        int center = 1;\n        m = n -1;\n        for (int i = 2; i <= n; i++) {\n            edges.push_back({center, i});\n        }\n    }\n    else if (type == \"tree\") {\n        // generate a random tree\n        assert(n >= 1);\n        m = n -1;\n        vector<int> p(n +1);\n        for(int i = 2; i <= n; ++i)\n            p[i] = rnd.next(1, i -1);\n        for(int i = 2; i <= n; ++i) {\n            edges.push_back({p[i], i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n    else if (type == \"complete\") {\n        // complete graph\n        m = n * (n -1) / 2;\n        assert(m <= 200000);\n        for(int i =1; i <= n; ++i)\n            for(int j = i+1; j <= n; ++j)\n                edges.push_back({i, j});\n        shuffle(edges.begin(), edges.end());\n    }\n    else if (type == \"cycle\") {\n        // cycle graph\n        assert(n >= 3);\n        m = n;\n        for(int i =1; i <= n; ++i) {\n            edges.push_back({i, i % n +1});\n        }\n    }\n    else if (type == \"random\") {\n        // generate m random edges\n        if (m == -1) {\n            m = n * (n -1) / 2;\n            if (m > 200000) m = 200000;\n        }\n        assert(m >=0 && m <= min(1LL * n * (n -1) / 2, 200000LL));\n\n        set<pair<int,int>> edge_set;\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u,v);\n            pair<int,int> e = {u,v};\n            if (edge_set.count(e)) continue;\n            edge_set.insert(e);\n        }\n        for (auto e : edge_set) {\n            edges.push_back(e);\n        }\n    }\n    else if (type == \"disconnected\") {\n        // create disconnected components\n        // For simplicity, split into two components\n        assert(n >= 2);\n        int n1 = n / 2;\n        int n2 = n - n1;\n        // First component: nodes 1..n1\n        // Second component: nodes n1+1 .. n\n        vector<int> component_nodes = {n1, n2};\n        m = 0;\n        for (int c =0; c < 2; ++c) {\n            int cn = component_nodes[c];\n            int node_offset = c ==0 ? 1 : n1+1;\n            vector<int> nodes;\n            for(int i =0; i < cn; ++i)\n                nodes.push_back(node_offset + i);\n            // Create a chain in this component\n            for(int i = 1; i < cn; ++i) {\n                edges.push_back({nodes[i-1], nodes[i]});\n                m++;\n            }\n        }\n    }\n    else {\n        // default to empty graph\n        m = 0;\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type chain\n./gen -n 5 -type star\n./gen -n 5 -type cycle\n./gen -n 5 -type tree\n./gen -n 5 -type complete\n./gen -n 5 -type random\n./gen -n 5 -type disconnected\n\n./gen -n 50 -type chain\n./gen -n 50 -type star\n./gen -n 50 -type cycle\n./gen -n 50 -type tree\n./gen -n 50 -type random -m 100\n./gen -n 50 -type random -m 1000\n./gen -n 50 -type disconnected\n\n./gen -n 632 -type complete\n./gen -n 600 -type complete\n./gen -n 300 -type complete\n\n./gen -n 100000 -type chain\n./gen -n 100000 -type star\n./gen -n 100000 -type cycle\n\n./gen -n 100000 -type tree\n./gen -n 100000 -type random -m 100000\n./gen -n 100000 -type random -m 200000\n\n./gen -n 200000 -type tree\n./gen -n 200000 -type random -m 100000\n./gen -n 200000 -type random -m 200000\n\n./gen -n 200000 -type disconnected\n\n./gen -n 1 -type chain\n./gen -n 1 -type star\n./gen -n 1 -type complete\n./gen -n 1 -type random -m 0\n\n./gen -n 3 -type cycle\n\n./gen -n 1000 -type random -m 0\n./gen -n 1000 -type disconnected\n\n./gen -n 10000 -type random -m 0\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:16.522174",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "522/C",
      "title": "C. Chicken or Fish?",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputEach test in this problem consists of one or more input sets. First goes a string that contains a single integer t (1 ≤ t ≤ 100 000) — the number of input data sets in the test. Then the sets follow, each set is preceded by an empty line.The first line of each set of the input contains integers m, k (2 ≤ m ≤ 100 000, 1 ≤ k ≤ 100 000) — the number of Polycarp's seat and the number of dishes, respectively.The second line contains a sequence of k integers a1, a2, ..., ak (1 ≤ ai ≤ 100 000), where ai is the initial number of portions of the i-th dish.Then m - 1 lines follow, each line contains the description of Polycarp's observations about giving food to a passenger sitting in front of him: the j-th line contains a pair of integers tj, rj (0 ≤ tj ≤ k, 0 ≤ rj ≤ 1), where tj is the number of the dish that was given to the j-th passenger (or 0, if Polycarp didn't notice what dish was given to the passenger), and rj — a 1 or a 0, depending on whether the j-th passenger was or wasn't disappointed, respectively.We know that sum ai equals at least m, that is,Polycarp will definitely get some dish, even if it is the last thing he wanted. It is guaranteed that the data is consistent.Sum m for all input sets doesn't exceed 100 000. Sum k for all input sets doesn't exceed 100 000.",
      "output_spec": "OutputFor each input set print the answer as a single line. Print a string of k letters \"Y\" or \"N\". Letter \"Y\" in position i should be printed if they could have run out of the i-th dish by the time the stewardess started serving Polycarp.",
      "sample_tests": "ExamplesInputCopy23 42 3 2 11 00 05 51 2 1 3 13 00 02 14 0OutputCopyYNNYYYYNY",
      "description": "C. Chicken or Fish?\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputEach test in this problem consists of one or more input sets. First goes a string that contains a single integer t (1 ≤ t ≤ 100 000) — the number of input data sets in the test. Then the sets follow, each set is preceded by an empty line.The first line of each set of the input contains integers m, k (2 ≤ m ≤ 100 000, 1 ≤ k ≤ 100 000) — the number of Polycarp's seat and the number of dishes, respectively.The second line contains a sequence of k integers a1, a2, ..., ak (1 ≤ ai ≤ 100 000), where ai is the initial number of portions of the i-th dish.Then m - 1 lines follow, each line contains the description of Polycarp's observations about giving food to a passenger sitting in front of him: the j-th line contains a pair of integers tj, rj (0 ≤ tj ≤ k, 0 ≤ rj ≤ 1), where tj is the number of the dish that was given to the j-th passenger (or 0, if Polycarp didn't notice what dish was given to the passenger), and rj — a 1 or a 0, depending on whether the j-th passenger was or wasn't disappointed, respectively.We know that sum ai equals at least m, that is,Polycarp will definitely get some dish, even if it is the last thing he wanted. It is guaranteed that the data is consistent.Sum m for all input sets doesn't exceed 100 000. Sum k for all input sets doesn't exceed 100 000.\n\nOutputFor each input set print the answer as a single line. Print a string of k letters \"Y\" or \"N\". Letter \"Y\" in position i should be printed if they could have run out of the i-th dish by the time the stewardess started serving Polycarp.\n\nInputCopy23 42 3 2 11 00 05 51 2 1 3 13 00 02 14 0OutputCopyYNNYYYYNY\n\nInputCopy23 42 3 2 11 00 05 51 2 1 3 13 00 02 14 0\n\nOutputCopyYNNYYYYNY\n\nNoteIn the first input set depending on the choice of the second passenger the situation could develop in different ways:  If he chose the first dish, then by the moment the stewardess reaches Polycarp, they will have run out of the first dish;  If he chose the fourth dish, then by the moment the stewardess reaches Polycarp, they will have run out of the fourth dish;  Otherwise, Polycarp will be able to choose from any of the four dishes. Thus, the answer is \"YNNY\".In the second input set there is, for example, the following possible scenario. First, the first passenger takes the only third dish, then the second passenger takes the second dish. Then, the third passenger asks for the third dish, but it is not available, so he makes disappointed muttering and ends up with the second dish. Then the fourth passenger takes the fourth dish, and Polycarp ends up with the choice between the first, fourth and fifth dish.Likewise, another possible scenario is when by the time the stewardess comes to Polycarp, they will have run out of either the first or the fifth dish (this can happen if one of these dishes is taken by the second passenger). It is easy to see that there is more than enough of the fourth dish, so Polycarp can always count on it. Thus, the answer is \"YYYNY\".",
      "solutions": [
        {
          "title": "VK Cup 2015 — Квалификация 1 - Codeforces",
          "content": "Всем привет!7 марта в 18:00 начнется первый квалификационный раунд чемпионата VK Cup 2015!Раунд продлится 24 часа, такая продолжительность выбрана для того, чтобы все нашли себе удобное время для участия. Квалификационный раунд, как и все предстоящие раунды, требует отдельной регистрации. Регистрация станет доступна 7 марта в 00:00, она будет открыта на протяжении всего раунда.При регистрации на любой из квалификационных раундов состав вашей команды фиксируется и не подлежит дальнейшей модификации. Вы не сможете в будущем добавить или удалить члена команды. Пожалуйста, перед регистрацией убедитесь, что у вас нет желания изменить состав. Состав команды не сможет быть изменен, даже если вы отмените регистрацию на квалификационный раунд.Если вы пока не уверены в текущем составе команды, то не регистрируйтесь на предстоящий раунд. Если вы не будете участвовать в первой квалификации или не пройдете по ее результатам в Раунд 1, то вы сможете попробовать свои силы во второй квалификации.Чтобы пройти в Раунд 1, вам надо принять участие хотя бы в одной из квалификаций. Из каждой квалификации в Раунд 1 проходят все команды с положительным числом баллов, которые набрали не меньше баллов, чем команда на 500-ом месте.Пользуясь случаем поздравляем всех девушек-участниц с праздником. Спасибо вам за весну!Во время квалификации задачи тестируются системой только на претестах, а системное тестирование состоится после окончания раунда. Обратите внимание, что претесты не покрывают все возможные случаи входных данных, поэтому тщательно тестируйте свои программы! Взломов, падения стоимости задач во время квалификации не будет. Время сдачи задач не будет учитываться, однако будут учитываться штрафные попытки.Категорически запрещается публиковать где-либо условия задач/решения/какие-либо мысли и соображения о них до окончания раунда. Запрещено обсуждать задачи с кем-либо кроме вашего сокомандника. Будьте честны, пусть в Раунд 1 пройдут сильнейшие!Результаты раунда не будут влиять на рейтинг, внеконкурсное участие в раунде не разрешается. Однако, после окончания раунд станет доступен всем для дорешивания, а его задачи попадут в архив в том числе и на английском языке.  Если вы впервые участвуете в соревнованиях подобного рода, ознакомьтесь с одной из задач 158A - Следующий раунд квалификационного раунда чемпионата VK Cup 2012, а также примерами ее решения на разных языках программирования: C++: 8130525 C#: 3794163 D: 2060057 Go: 7573616 Haskell: 1265143 Java: 4244817 JavaScript: 5743720 Ocaml: 2698642 Pascal: 5832593 Perl: 9483942 PHP: 4475965 Python: 2475538 Ruby: 7939472 Scala: 2456025 Желаем удачи и удовольствия от решения задач!UPD 1: Ура! Квалификация 1 закончена, все решения протестированы. В Раунд 1 квалифицированы все те команды, которые набрали 1500 баллов или больше. Таких команд оказалось 789, поздравляем их всех! Те из вас, кто не набрал 1500 баллов могут не расстраиваться, ведь 14 марта стартует Квалификация 2.UPD 2: Опубликован разбор задач.Пользуясь случаем поздравляем всех девушек-участниц. Спасибо вам за весну!",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/16812",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3058
        },
        {
          "title": "Разбор задач VK Cup 2015 — Квалификация 1 - Codeforces",
          "content": "522A - RepostsДля решения этой задачи надо было проитерироваться по записям о репостах и поддерживать для каждого пользователя длину цепочки, которая заканчивается в нем. Здесь удобно воспользоваться ассоциативным массивом из строки (имени пользователя) в целое число (длину цепочки). Например, для С++ такой структурой данных будет просто map<string,int>. Назовем такую структуру chainLengths, тогда при обработки строки вида <<a reposted b>> надо просто выполнить присвоение chainLengths[a] = chainLengths[b] + 1. В качестве ответа надо вывести максимальное из значений chainLengths, что можно подсчитывать на лету.Пара тонкостей: в начале надо занести chainLengths[\"polycarp\"] = 1;, а всюду при работе со строками приводить их к нижнему регистру (или верхнему), чтобы сделать сравнение строк нечувствительным к регистру букв.Пример такого решения: 10209456.522B - Photo to RememberВ этой задаче для каждого i фактически надо было найти: Wi, равное сумме всех заданных wj без wi, и Hi, равное максимуму всех hj без hi. Для подсчета первой величины достаточно найти сумму s всех значений wj, тогда Wi = s - wi.Для подсчета второй величины достаточно заметить, что либо искомое значение есть просто максимум по h, либо (если hi совпало с максимумом) это второй максимум (т.е. предпоследний элемент при сортировке по неубыванию). Второй максимум, как и максимум ищется за один проход по массиву.В таком случае, для нахождения как Wi, так и Hi требуется O(1) действий, то есть O(n) суммарно на всё решение.Пример решения: 10193758.522C - Chicken or Fish?Для решения задачи необходимо заметить, что при наличии недовольных пассажиров (т.е. тех, для кого ri = 1), существенную роль играет только первый из них, так как остальные вполне могут быть недовольными именно тем блюдом, которое не хватило первому из таковых.Пусть массив b — это массив максимальных возможных количеств порций каждого из блюда на момент старта обслуживания Поликарпа. То есть просто массив b надо заинициализировать массивом a, а каждый раз, когда ti отлично от 0, то делать b[ti] = b[ti] - 1 (уменьшать количество порций блюда). Кроме того, пусть unknown — это количество пассажиров, про которых неизвестно какие точно блюда им достались (то есть для них ti = 0). Пусть величина unknownBeforeUpset — это такое же количество, но до первого недовольного.Таким образом, есть два основных случая: недовольных пассажиров нет вообще, тогда блюдо i могло закончится тогда и только тогда, когда b[i] ≤ unknown (жадно отдаем это блюдо всем пассажирам, для кого их точное блюдо неизвестно), недовольный пассажир есть, этот случай разберем подробнее. Каким блюдом мог быть недоволен первый из таких пассажиров? Очевидно из списка кандидатов надо выкинуть все такие блюда, которые упоминаются не раньше него (значит, что они закончится до него не могли). Из оставшегося набора блюд достаточно перебрать все блюда и проверить могли ли они закончиться до этого пассажира. То есть блюдо i могло быть тем блюдом, что привело в недовольство первого недовольного, если одновременно верно: это блюдо i не упоминается на этом пассажире или позже, это блюдо i такое, что b[i] ≤ unknownBeforeUpset. Для всех таких блюд, очевидно, в ответе должно стоять Y (они могли закончится к Поликарпу). Кроме того, из всех таких блюд наибольшую степень свободы дает блюдо с наименьшим расходом (количеством порций b[i]). Выберем именно такое блюдо и в остаток пассажиров с неизвестным блюдом restUnknown = unknown - b[minFirstFinished] попробуем поместить все вхождения каждого из других блюд. То есть блюдо j могло закончится до Поликарпа тогда и только тогда, если для него b[j] ≤ restUnknown (то есть закончилось то блюдо, что расстроило первого из недовольных, а следом — j-е).Такое решение работает за O(m + k).Пример решения: 10212686.522D - Closest EqualsВоспользуемся тем, что задача задана в офлайн-формулировке, то есть все запросы можно считать до нахождения ответов на них.Пройдем слева направо по массиву и составим новый массив b, записав в b[j] расстояние до ближайшего слева парного j-му элементу значения, то есть a[j - b[j]] = a[j]. Если такового нет, то запишем в ячейку бесконечность.Эти значения соответствуют расстояниям между парными элементами и записаны они в позициях правых элементов в этих парах.При рассмотрении запроса на отрезке [l, r] нам не нужны вообще такие пары, что начинаются левее l, а минимум надо искать среди пар, что заканчиваются не правее r.Отсортируем все запросы по l слева направо. Тогда при прохождении по запросам можно поддерживать, что для запроса [l, r] в массиве b установлены бесконечности для всех пар, в которых левый элемент левее l. Для этого просто предподсчитаем для каждого элемента ближайший справа парный next[i] (то есть верно, что b[next[i]] = next[i] - i), и при покидании ячейки i будем записывать в b[next[i]] значение бесконечность.В таком случае, для ответа на запрос [l, r] надо просто найти минимум на префиксе до индекса r включительно по массиву b. Это можно делать быстро разными способами (дерево отрезков, дерево Фенвика).Асимптотическая временная сложность такого решения составляет .Пример решения: 10192075.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/16853",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 522\\s*C"
          },
          "content_length": 5126
        }
      ],
      "code_examples": [
        {
          "title": "Разбор задач VK Cup 2015 — Квалификация 1 - Codeforces - Code 1",
          "code": "chainLengths",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16853",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Разбор задач VK Cup 2015 — Квалификация 1 - Codeforces - Code 2",
          "code": "a reposted b",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16853",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Разбор задач VK Cup 2015 — Квалификация 1 - Codeforces - Code 3",
          "code": "chainLengths[a] = chainLengths[b] + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16853",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Разбор задач VK Cup 2015 — Квалификация 1 - Codeforces - Code 4",
          "code": "chainLengths",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16853",
          "author": "MikeMirzayanov"
        },
        {
          "title": "Разбор задач VK Cup 2015 — Квалификация 1 - Codeforces - Code 5",
          "code": "chainLengths[\"polycarp\"] = 1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16853",
          "author": "MikeMirzayanov"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long totalM = 0;  // Will track sum of m across all tests\n    long long totalK = 0;  // Will track sum of k across all tests\n\n    // Read the number of input sets (t)\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    // For each input set:\n    for(int i = 0; i < t; i++) {\n        // Each set is preceded by an empty line\n        inf.readEoln();\n\n        // Read m, k\n        int m = inf.readInt(2, 100000, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(1, 100000, \"k\");\n        inf.readEoln();\n\n        // Check global constraints for sum of m, k\n        totalM += m;\n        totalK += k;\n        ensuref(totalM <= 100000, \"sum of m across all tests must not exceed 100000\");\n        ensuref(totalK <= 100000, \"sum of k across all tests must not exceed 100000\");\n\n        // Read k integers a1, a2, ..., ak\n        // Each must be within [1, 100000]\n        vector<int> a = inf.readInts(k, 1, 100000, \"a\");\n        inf.readEoln();\n\n        // Check sum(ai) >= m\n        long long sumA = 0;\n        for(int x : a) sumA += x;\n        ensuref(sumA >= m, \"sum of a must be >= m\");\n\n        // Read m-1 lines describing each passenger in front of Polycarp\n        for(int j = 0; j < m - 1; j++) {\n            // 0 <= tj <= k, 0 <= rj <= 1\n            int tj = inf.readInt(0, k, \"tj\");\n            inf.readSpace();\n            int rj = inf.readInt(0, 1, \"rj\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long totalM = 0;  // Will track sum of m across all tests\n    long long totalK = 0;  // Will track sum of k across all tests\n\n    // Read the number of input sets (t)\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    // For each input set:\n    for(int i = 0; i < t; i++) {\n        // Each set is preceded by an empty line\n        inf.readEoln();\n\n        // Read m, k\n        int m = inf.readInt(2, 100000, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(1, 100000, \"k\");\n        inf.readEoln();\n\n        // Check global constraints for sum of m, k\n        totalM += m;\n        totalK += k;\n        ensuref(totalM <= 100000, \"sum of m across all tests must not exceed 100000\");\n        ensuref(totalK <= 100000, \"sum of k across all tests must not exceed 100000\");\n\n        // Read k integers a1, a2, ..., ak\n        // Each must be within [1, 100000]\n        vector<int> a = inf.readInts(k, 1, 100000, \"a\");\n        inf.readEoln();\n\n        // Check sum(ai) >= m\n        long long sumA = 0;\n        for(int x : a) sumA += x;\n        ensuref(sumA >= m, \"sum of a must be >= m\");\n\n        // Read m-1 lines describing each passenger in front of Polycarp\n        for(int j = 0; j < m - 1; j++) {\n            // 0 <= tj <= k, 0 <= rj <= 1\n            int tj = inf.readInt(0, k, \"tj\");\n            inf.readSpace();\n            int rj = inf.readInt(0, 1, \"rj\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    long long totalM = 0;  // Will track sum of m across all tests\n    long long totalK = 0;  // Will track sum of k across all tests\n\n    // Read the number of input sets (t)\n    int t = inf.readInt(1, 100000, \"t\");\n    inf.readEoln();\n\n    // For each input set:\n    for(int i = 0; i < t; i++) {\n        // Each set is preceded by an empty line\n        inf.readEoln();\n\n        // Read m, k\n        int m = inf.readInt(2, 100000, \"m\");\n        inf.readSpace();\n        int k = inf.readInt(1, 100000, \"k\");\n        inf.readEoln();\n\n        // Check global constraints for sum of m, k\n        totalM += m;\n        totalK += k;\n        ensuref(totalM <= 100000, \"sum of m across all tests must not exceed 100000\");\n        ensuref(totalK <= 100000, \"sum of k across all tests must not exceed 100000\");\n\n        // Read k integers a1, a2, ..., ak\n        // Each must be within [1, 100000]\n        vector<int> a = inf.readInts(k, 1, 100000, \"a\");\n        inf.readEoln();\n\n        // Check sum(ai) >= m\n        long long sumA = 0;\n        for(int x : a) sumA += x;\n        ensuref(sumA >= m, \"sum of a must be >= m\");\n\n        // Read m-1 lines describing each passenger in front of Polycarp\n        for(int j = 0; j < m - 1; j++) {\n            // 0 <= tj <= k, 0 <= rj <= 1\n            int tj = inf.readInt(0, k, \"tj\");\n            inf.readSpace();\n            int rj = inf.readInt(0, 1, \"rj\");\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single \"test file\" containing exactly one test\n  (t = 1). Each test file will have:\n\n      1) The integer t = 1 on the first line.\n      2) An empty line.\n      3) A test set consisting of:\n         - One line: m, k\n         - One line: k integers a1, a2, ..., ak\n         - (m - 1) lines: each line has two integers tj, rj\n\n  We satisfy:\n  - 2 <= m <= 100000\n  - 1 <= k <= 100000\n  - sum(a_i) >= m\n  - 0 <= tj <= k\n  - rj in {0, 1}\n  - The data is consistent (there exists some possible scenario in which the\n    observations could happen).\n\n  Usage examples:\n      ./gen -m 10 -k 3\n      ./gen -m 100 -k 5\n  etc.\n\n  The generator will be run multiple times with different parameters to produce\n  a suite of test files.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the command-line arguments: number of people (m) and number of dishes (k).\n    // Provide default values just in case they are not given.\n    int m = opt<int>(\"m\", 5);    // Default 5\n    int k = opt<int>(\"k\", 3);    // Default 3\n\n    // We will generate one test set, so t = 1.\n    cout << 1 << \"\\n\\n\";\n\n    // 1) Print \"m k\".\n    cout << m << \" \" << k << \"\\n\";\n\n    // 2) Generate the array a[0..k-1], ensuring sum(a) >= m.\n    //    We'll first pick random values for a[i], then if sum < m, we'll add\n    //    (m - sum) to one of the dishes.\n    vector<int> a(k);\n    long long totalSum = 0;\n    // Fill with random values in [0..m], just to keep them not too large.\n    // You could adjust ranges as desired.\n    for (int i = 0; i < k; i++) {\n        a[i] = rnd.next(0, m);  // random up to m\n        totalSum += a[i];\n    }\n    if (totalSum < m) {\n        int need = m - totalSum;\n        // Just add all of 'need' to dish 0\n        a[0] += need;\n        totalSum += need;\n    }\n\n    // Print the array a1..ak\n    for (int i = 0; i < k; i++) {\n        cout << a[i] << (i + 1 < k ? ' ' : '\\n');\n    }\n\n    // We'll now generate (m - 1) lines for passengers 1..(m-1).\n    // We'll track the \"hidden\" actual usage of dishes so that\n    // we never use more dishes than we have (making the data consistent).\n    long long leftTotal = totalSum; // total number of dishes left\n    // We'll keep track of how many portions remain for each dish\n    // in a local array. We'll update it as we assign known or unknown to passengers.\n    vector<int> remain = a;\n\n    for (int passenger = 1; passenger <= m - 1; passenger++) {\n        // We have four main scenarios:\n        //   1) (t_j != 0, r_j = 0) => known dish, not disappointed\n        //   2) (t_j = 0,   r_j = 0) => unknown dish, not disappointed\n        //   3) (t_j != 0, r_j = 1) => known dish, disappointed (the dish was out)\n        //   4) (t_j = 0,   r_j = 1) => unknown dish, disappointed\n\n        // We'll pick scenario randomly, but we must ensure consistency:\n        // \"Disappointed\" requires that the requested dish be out of stock.\n        // \"Not disappointed\" requires that the requested dish has stock.\n        // If t_j=0, we don't know which dish they ultimately took, but we still\n        // reduce 1 piece from remain in order to remain consistent overall.\n\n        // We'll try up to a few times to find a scenario that works. If we can't,\n        // we'll fallback to something simpler (e.g., unknown, not disappointed).\n\n        int scenarioAttempt = 0;\n        const int MAX_TRIES = 5;\n        int chosenScenario = -1;\n        int chosenT = 0; // 0 means we do not know\n        int chosenR = 0; // 0 or 1\n        int knownDishIndex = -1; // store dish index if known\n\n        while (scenarioAttempt < MAX_TRIES && chosenScenario < 0) {\n            int candidate = rnd.next(4); // 0..3\n            if (candidate == 0) {\n                // known dish, not disappointed => must pick one with remain > 0\n                // so that it's possible.\n                vector<int> canUse;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] > 0) {\n                        canUse.push_back(i);\n                    }\n                }\n                if (!canUse.empty()) {\n                    chosenScenario = candidate;\n                    knownDishIndex = canUse[rnd.next((int)canUse.size())];\n                    chosenT = knownDishIndex + 1;\n                    chosenR = 0;\n                }\n            } else if (candidate == 1) {\n                // unknown dish, not disappointed => we just need at least one dish with remain > 0\n                if (leftTotal > 0) {\n                    chosenScenario = candidate;\n                    chosenT = 0;\n                    chosenR = 0;\n                }\n            } else if (candidate == 2) {\n                // known dish, disappointed => must pick a dish with remain == 0\n                // Then the passenger ends up taking something else that is available.\n                // So we must ensure there's at least one dish with remain > 0 overall.\n                vector<int> outOfStock;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] == 0) {\n                        outOfStock.push_back(i);\n                    }\n                }\n                if (!outOfStock.empty() && leftTotal > 0) {\n                    // The passenger can still pick an available dish from the hidden side\n                    // That requires leftTotal > 0. Actually, we also need at least 1 dish with remain>0\n                    // for them to take. We'll check that:\n                    bool hasStock = false;\n                    for (int i = 0; i < k; i++) {\n                        if (remain[i] > 0) {\n                            hasStock = true;\n                            break;\n                        }\n                    }\n                    if (hasStock) {\n                        chosenScenario = candidate;\n                        knownDishIndex = outOfStock[rnd.next((int)outOfStock.size())];\n                        chosenT = knownDishIndex + 1;\n                        chosenR = 1;\n                    }\n                }\n            } else { // candidate == 3\n                // unknown dish, disappointed => must pick a dish with remain == 0, unknown to us\n                // but from the hidden perspective we also need at least one remain>0 to actually take.\n                // So effectively, we just need at least one remain==0 and leftTotal>0 plus at least\n                // one remain>0 for the \"actual dish\" the passenger ends up with.\n                bool outOfStockExists = false;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] == 0) {\n                        outOfStockExists = true;\n                        break;\n                    }\n                }\n                bool hasStock = false;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] > 0) {\n                        hasStock = true;\n                        break;\n                    }\n                }\n                if (outOfStockExists && hasStock) {\n                    chosenScenario = candidate;\n                    chosenT = 0;\n                    chosenR = 1;\n                }\n            }\n            scenarioAttempt++;\n        }\n\n        // If we couldn't find a scenario above, we fallback to \"unknown, not disappointed.\"\n        // That scenario is always possible as long as there's leftover total.\n        if (chosenScenario < 0) {\n            chosenScenario = 1; // unknown, not disappointed\n            chosenT = 0;\n            chosenR = 0;\n        }\n\n        // Now apply the scenario to adjust remain[] and leftTotal by 1,\n        // because every passenger definitely takes one dish in the end.\n        if (chosenR == 0) {\n            // not disappointed => we reduce from the dish t_j if t_j != 0\n            // or from a random available dish if t_j=0.\n            if (chosenT == 0) {\n                // unknown dish, not disappointed\n                // pick a random dish that has remain>0\n                vector<int> canUse;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] > 0) {\n                        canUse.push_back(i);\n                    }\n                }\n                // should not be empty because leftTotal > 0\n                int c = canUse[rnd.next((int)canUse.size())];\n                remain[c]--;\n                leftTotal--;\n            } else {\n                // known dish => t_j = chosenT\n                // reduce remain[ chosenT-1 ]\n                remain[chosenT - 1]--;\n                leftTotal--;\n            }\n        } else {\n            // disappointed => the dish t_j (if not zero) was out of stock, so we reduce\n            // some other dish that is in stock. If t_j=0, it means we didn't see\n            // which dish was out of stock, but we still reduce from a dish that is in stock.\n            // We just need to pick a dish with remain>0 to reduce by 1.\n            vector<int> canUse;\n            for (int i = 0; i < k; i++) {\n                if (remain[i] > 0) {\n                    canUse.push_back(i);\n                }\n            }\n            // canUse should not be empty in a consistent scenario\n            int c = canUse[rnd.next((int)canUse.size())];\n            remain[c]--;\n            leftTotal--;\n        }\n\n        // Finally, output the chosen line: (t_j, r_j)\n        cout << chosenT << \" \" << chosenR << \"\\n\";\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n  This generator produces a single \"test file\" containing exactly one test\n  (t = 1). Each test file will have:\n\n      1) The integer t = 1 on the first line.\n      2) An empty line.\n      3) A test set consisting of:\n         - One line: m, k\n         - One line: k integers a1, a2, ..., ak\n         - (m - 1) lines: each line has two integers tj, rj\n\n  We satisfy:\n  - 2 <= m <= 100000\n  - 1 <= k <= 100000\n  - sum(a_i) >= m\n  - 0 <= tj <= k\n  - rj in {0, 1}\n  - The data is consistent (there exists some possible scenario in which the\n    observations could happen).\n\n  Usage examples:\n      ./gen -m 10 -k 3\n      ./gen -m 100 -k 5\n  etc.\n\n  The generator will be run multiple times with different parameters to produce\n  a suite of test files.\n*/\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read the command-line arguments: number of people (m) and number of dishes (k).\n    // Provide default values just in case they are not given.\n    int m = opt<int>(\"m\", 5);    // Default 5\n    int k = opt<int>(\"k\", 3);    // Default 3\n\n    // We will generate one test set, so t = 1.\n    cout << 1 << \"\\n\\n\";\n\n    // 1) Print \"m k\".\n    cout << m << \" \" << k << \"\\n\";\n\n    // 2) Generate the array a[0..k-1], ensuring sum(a) >= m.\n    //    We'll first pick random values for a[i], then if sum < m, we'll add\n    //    (m - sum) to one of the dishes.\n    vector<int> a(k);\n    long long totalSum = 0;\n    // Fill with random values in [0..m], just to keep them not too large.\n    // You could adjust ranges as desired.\n    for (int i = 0; i < k; i++) {\n        a[i] = rnd.next(0, m);  // random up to m\n        totalSum += a[i];\n    }\n    if (totalSum < m) {\n        int need = m - totalSum;\n        // Just add all of 'need' to dish 0\n        a[0] += need;\n        totalSum += need;\n    }\n\n    // Print the array a1..ak\n    for (int i = 0; i < k; i++) {\n        cout << a[i] << (i + 1 < k ? ' ' : '\\n');\n    }\n\n    // We'll now generate (m - 1) lines for passengers 1..(m-1).\n    // We'll track the \"hidden\" actual usage of dishes so that\n    // we never use more dishes than we have (making the data consistent).\n    long long leftTotal = totalSum; // total number of dishes left\n    // We'll keep track of how many portions remain for each dish\n    // in a local array. We'll update it as we assign known or unknown to passengers.\n    vector<int> remain = a;\n\n    for (int passenger = 1; passenger <= m - 1; passenger++) {\n        // We have four main scenarios:\n        //   1) (t_j != 0, r_j = 0) => known dish, not disappointed\n        //   2) (t_j = 0,   r_j = 0) => unknown dish, not disappointed\n        //   3) (t_j != 0, r_j = 1) => known dish, disappointed (the dish was out)\n        //   4) (t_j = 0,   r_j = 1) => unknown dish, disappointed\n\n        // We'll pick scenario randomly, but we must ensure consistency:\n        // \"Disappointed\" requires that the requested dish be out of stock.\n        // \"Not disappointed\" requires that the requested dish has stock.\n        // If t_j=0, we don't know which dish they ultimately took, but we still\n        // reduce 1 piece from remain in order to remain consistent overall.\n\n        // We'll try up to a few times to find a scenario that works. If we can't,\n        // we'll fallback to something simpler (e.g., unknown, not disappointed).\n\n        int scenarioAttempt = 0;\n        const int MAX_TRIES = 5;\n        int chosenScenario = -1;\n        int chosenT = 0; // 0 means we do not know\n        int chosenR = 0; // 0 or 1\n        int knownDishIndex = -1; // store dish index if known\n\n        while (scenarioAttempt < MAX_TRIES && chosenScenario < 0) {\n            int candidate = rnd.next(4); // 0..3\n            if (candidate == 0) {\n                // known dish, not disappointed => must pick one with remain > 0\n                // so that it's possible.\n                vector<int> canUse;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] > 0) {\n                        canUse.push_back(i);\n                    }\n                }\n                if (!canUse.empty()) {\n                    chosenScenario = candidate;\n                    knownDishIndex = canUse[rnd.next((int)canUse.size())];\n                    chosenT = knownDishIndex + 1;\n                    chosenR = 0;\n                }\n            } else if (candidate == 1) {\n                // unknown dish, not disappointed => we just need at least one dish with remain > 0\n                if (leftTotal > 0) {\n                    chosenScenario = candidate;\n                    chosenT = 0;\n                    chosenR = 0;\n                }\n            } else if (candidate == 2) {\n                // known dish, disappointed => must pick a dish with remain == 0\n                // Then the passenger ends up taking something else that is available.\n                // So we must ensure there's at least one dish with remain > 0 overall.\n                vector<int> outOfStock;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] == 0) {\n                        outOfStock.push_back(i);\n                    }\n                }\n                if (!outOfStock.empty() && leftTotal > 0) {\n                    // The passenger can still pick an available dish from the hidden side\n                    // That requires leftTotal > 0. Actually, we also need at least 1 dish with remain>0\n                    // for them to take. We'll check that:\n                    bool hasStock = false;\n                    for (int i = 0; i < k; i++) {\n                        if (remain[i] > 0) {\n                            hasStock = true;\n                            break;\n                        }\n                    }\n                    if (hasStock) {\n                        chosenScenario = candidate;\n                        knownDishIndex = outOfStock[rnd.next((int)outOfStock.size())];\n                        chosenT = knownDishIndex + 1;\n                        chosenR = 1;\n                    }\n                }\n            } else { // candidate == 3\n                // unknown dish, disappointed => must pick a dish with remain == 0, unknown to us\n                // but from the hidden perspective we also need at least one remain>0 to actually take.\n                // So effectively, we just need at least one remain==0 and leftTotal>0 plus at least\n                // one remain>0 for the \"actual dish\" the passenger ends up with.\n                bool outOfStockExists = false;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] == 0) {\n                        outOfStockExists = true;\n                        break;\n                    }\n                }\n                bool hasStock = false;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] > 0) {\n                        hasStock = true;\n                        break;\n                    }\n                }\n                if (outOfStockExists && hasStock) {\n                    chosenScenario = candidate;\n                    chosenT = 0;\n                    chosenR = 1;\n                }\n            }\n            scenarioAttempt++;\n        }\n\n        // If we couldn't find a scenario above, we fallback to \"unknown, not disappointed.\"\n        // That scenario is always possible as long as there's leftover total.\n        if (chosenScenario < 0) {\n            chosenScenario = 1; // unknown, not disappointed\n            chosenT = 0;\n            chosenR = 0;\n        }\n\n        // Now apply the scenario to adjust remain[] and leftTotal by 1,\n        // because every passenger definitely takes one dish in the end.\n        if (chosenR == 0) {\n            // not disappointed => we reduce from the dish t_j if t_j != 0\n            // or from a random available dish if t_j=0.\n            if (chosenT == 0) {\n                // unknown dish, not disappointed\n                // pick a random dish that has remain>0\n                vector<int> canUse;\n                for (int i = 0; i < k; i++) {\n                    if (remain[i] > 0) {\n                        canUse.push_back(i);\n                    }\n                }\n                // should not be empty because leftTotal > 0\n                int c = canUse[rnd.next((int)canUse.size())];\n                remain[c]--;\n                leftTotal--;\n            } else {\n                // known dish => t_j = chosenT\n                // reduce remain[ chosenT-1 ]\n                remain[chosenT - 1]--;\n                leftTotal--;\n            }\n        } else {\n            // disappointed => the dish t_j (if not zero) was out of stock, so we reduce\n            // some other dish that is in stock. If t_j=0, it means we didn't see\n            // which dish was out of stock, but we still reduce from a dish that is in stock.\n            // We just need to pick a dish with remain>0 to reduce by 1.\n            vector<int> canUse;\n            for (int i = 0; i < k; i++) {\n                if (remain[i] > 0) {\n                    canUse.push_back(i);\n                }\n            }\n            // canUse should not be empty in a consistent scenario\n            int c = canUse[rnd.next((int)canUse.size())];\n            remain[c]--;\n            leftTotal--;\n        }\n\n        // Finally, output the chosen line: (t_j, r_j)\n        cout << chosenT << \" \" << chosenR << \"\\n\";\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Below are about 20 distinct commands demonstrating how to use the generator.\n# Each command will produce exactly ONE test file containing t=1 test set.\n# Varying the parameters helps generate a wide range of data for contestants to test against.\n\n./gen -m 2 -k 1\n./gen -m 2 -k 2\n./gen -m 3 -k 3\n./gen -m 5 -k 1\n./gen -m 5 -k 5\n./gen -m 10 -k 3\n./gen -m 10 -k 10\n./gen -m 15 -k 2\n./gen -m 20 -k 3\n./gen -m 25 -k 15\n./gen -m 30 -k 1\n./gen -m 30 -k 10\n./gen -m 50 -k 10\n./gen -m 50 -k 50\n./gen -m 99 -k 1\n./gen -m 100 -k 2\n./gen -m 100 -k 99\n./gen -m 999 -k 100\n./gen -m 1000 -k 100\n./gen -m 9999 -k 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:18.833829",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "524/C",
      "title": "C. The Art of Dealing with ATM",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n ≤ 5000, 1 ≤ k ≤ 20).The next line contains n space-separated integers ai (1 ≤ ai ≤ 107) — the denominations of the bills that are used in the country. Numbers ai follow in the strictly increasing order.The next line contains integer q (1 ≤ q ≤ 20) — the number of requests for cash withdrawal that you will make.The next q lines contain numbers xi (1 ≤ xi ≤ 2·108) — the sums of money in burles that you are going to withdraw from the ATM.",
      "output_spec": "OutputFor each request for cash withdrawal print on a single line the minimum number of bills it can be done, or print  - 1, if it is impossible to get the corresponding sum.",
      "sample_tests": "ExamplesInputCopy6 2010 50 100 500 1000 5000842001000009500096000990001010020159950OutputCopy6201920-13-1-1InputCopy5 21 2 3 5 8813579111315OutputCopy1112222-1",
      "description": "C. The Art of Dealing with ATM\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, k (1 ≤ n ≤ 5000, 1 ≤ k ≤ 20).The next line contains n space-separated integers ai (1 ≤ ai ≤ 107) — the denominations of the bills that are used in the country. Numbers ai follow in the strictly increasing order.The next line contains integer q (1 ≤ q ≤ 20) — the number of requests for cash withdrawal that you will make.The next q lines contain numbers xi (1 ≤ xi ≤ 2·108) — the sums of money in burles that you are going to withdraw from the ATM.\n\nOutputFor each request for cash withdrawal print on a single line the minimum number of bills it can be done, or print  - 1, if it is impossible to get the corresponding sum.\n\nInputCopy6 2010 50 100 500 1000 5000842001000009500096000990001010020159950OutputCopy6201920-13-1-1InputCopy5 21 2 3 5 8813579111315OutputCopy1112222-1\n\nInputCopy6 2010 50 100 500 1000 5000842001000009500096000990001010020159950\n\nOutputCopy6201920-13-1-1\n\nInputCopy5 21 2 3 5 8813579111315\n\nOutputCopy1112222-1",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 524\\s*C"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 20, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i] > a[i-1], \"Denominations must be strictly increasing: a[%d]=%d, a[%d]=%d\", i+1, a[i], i, a[i-1]);\n    }\n\n    int q = inf.readInt(1, 20, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x = inf.readInt(1, 200000000, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 20, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i] > a[i-1], \"Denominations must be strictly increasing: a[%d]=%d, a[%d]=%d\", i+1, a[i], i, a[i-1]);\n    }\n\n    int q = inf.readInt(1, 20, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x = inf.readInt(1, 200000000, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 20, \"k\");\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 10000000, \"a_i\");\n    inf.readEoln();\n\n    for (int i = 1; i < n; ++i) {\n        ensuref(a[i] > a[i-1], \"Denominations must be strictly increasing: a[%d]=%d, a[%d]=%d\", i+1, a[i], i, a[i-1]);\n    }\n\n    int q = inf.readInt(1, 20, \"q\");\n    inf.readEoln();\n\n    for (int i = 0; i < q; ++i) {\n        int x = inf.readInt(1, 200000000, \"x_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a strictly increasing sequence of n integers between min_ai and max_ai\nvector<int> generateIncreasingSequence(int n, int min_ai, int max_ai) {\n    set<int> numbers;\n    while ((int)numbers.size() < n) {\n        int ai = rnd.next(min_ai, max_ai);\n        numbers.insert(ai);\n    }\n    vector<int> a(numbers.begin(), numbers.end());\n    sort(a.begin(), a.end());\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int q = opt<int>(\"q\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a;\n    vector<int> x(q);\n\n    if (type == \"small\") {\n        // Small n, small k, random denominations and sums\n        n = min(n, 10);\n        k = min(k, 10);\n        q = min(q, 5);\n        a = generateIncreasingSequence(n, 1, 100);\n        for (int i = 0; i < q; ++i)\n            x[i] = rnd.next(1, 1000);\n    } else if (type == \"large\") {\n        // Large n, large k, random large denominations and sums\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n        a = generateIncreasingSequence(n, 1e7 - n + 1, 1e7);\n        for (int i = 0; i < q; ++i)\n            x[i] = rnd.next(1e8, 2e8);\n    } else if (type == \"k1\") {\n        // k = 1, test sums that can be formed with single bills\n        k = 1;\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i) {\n            x[i] = a[rnd.next(0, n - 1)];\n        }\n    } else if (type == \"impossible\") {\n        // Generate sums that cannot be formed under the constraints\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i) {\n            int ai = a[rnd.next(0, n - 1)];\n            x[i] = ai * (k + rnd.next(1, 5)); // Requires more than k bills\n        }\n    } else if (type == \"edge_ai\") {\n        // Denominations are consecutive integers starting from 1\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        for (int i = 0; i < q; ++i)\n            x[i] = a[rnd.next(0, n - 1)] * rnd.next(1, k);\n    } else if (type == \"special\") {\n        // Generate sums that require careful selection of denominations\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i) {\n            int ai = a[rnd.next(0, n - 1)];\n            int aj = a[rnd.next(0, n - 1)];\n            int ni = rnd.next(1, k - 1);\n            int nj = k - ni;\n            x[i] = ai * ni + aj * nj;\n        }\n    } else {\n        // Random denominations and sums\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i)\n            x[i] = rnd.next(1, (int)2e8);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i)\n        printf(\"%d\\n\", x[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate a strictly increasing sequence of n integers between min_ai and max_ai\nvector<int> generateIncreasingSequence(int n, int min_ai, int max_ai) {\n    set<int> numbers;\n    while ((int)numbers.size() < n) {\n        int ai = rnd.next(min_ai, max_ai);\n        numbers.insert(ai);\n    }\n    vector<int> a(numbers.begin(), numbers.end());\n    sort(a.begin(), a.end());\n    return a;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    int q = opt<int>(\"q\", 1);\n    string type = opt<string>(\"type\", \"random\");\n    vector<int> a;\n    vector<int> x(q);\n\n    if (type == \"small\") {\n        // Small n, small k, random denominations and sums\n        n = min(n, 10);\n        k = min(k, 10);\n        q = min(q, 5);\n        a = generateIncreasingSequence(n, 1, 100);\n        for (int i = 0; i < q; ++i)\n            x[i] = rnd.next(1, 1000);\n    } else if (type == \"large\") {\n        // Large n, large k, random large denominations and sums\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n        a = generateIncreasingSequence(n, 1e7 - n + 1, 1e7);\n        for (int i = 0; i < q; ++i)\n            x[i] = rnd.next(1e8, 2e8);\n    } else if (type == \"k1\") {\n        // k = 1, test sums that can be formed with single bills\n        k = 1;\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i) {\n            x[i] = a[rnd.next(0, n - 1)];\n        }\n    } else if (type == \"impossible\") {\n        // Generate sums that cannot be formed under the constraints\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i) {\n            int ai = a[rnd.next(0, n - 1)];\n            x[i] = ai * (k + rnd.next(1, 5)); // Requires more than k bills\n        }\n    } else if (type == \"edge_ai\") {\n        // Denominations are consecutive integers starting from 1\n        a.resize(n);\n        for (int i = 0; i < n; ++i)\n            a[i] = i + 1;\n        for (int i = 0; i < q; ++i)\n            x[i] = a[rnd.next(0, n - 1)] * rnd.next(1, k);\n    } else if (type == \"special\") {\n        // Generate sums that require careful selection of denominations\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i) {\n            int ai = a[rnd.next(0, n - 1)];\n            int aj = a[rnd.next(0, n - 1)];\n            int ni = rnd.next(1, k - 1);\n            int nj = k - ni;\n            x[i] = ai * ni + aj * nj;\n        }\n    } else {\n        // Random denominations and sums\n        a = generateIncreasingSequence(n, 1, (int)1e7);\n        for (int i = 0; i < q; ++i)\n            x[i] = rnd.next(1, (int)2e8);\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", a[i], i == n - 1 ? '\\n' : ' ');\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i)\n        printf(\"%d\\n\", x[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -q 1 -type small\n./gen -n 5 -k 3 -q 2 -type small\n./gen -n 10 -k 5 -q 5 -type small\n./gen -n 50 -k 10 -q 10 -type small\n./gen -n 100 -k 15 -q 5 -type small\n./gen -n 5000 -k 20 -q 20 -type large\n./gen -n 5000 -k 20 -q 20 -type random\n./gen -n 5000 -k 1 -q 20 -type k1\n./gen -n 5000 -k 1 -q 20 -type impossible\n./gen -n 5000 -k 20 -q 20 -type impossible\n./gen -n 5000 -k 20 -q 20 -type edge_ai\n./gen -n 5000 -k 20 -q 20 -type special\n./gen -n 1000 -k 10 -q 15 -type random\n./gen -n 2000 -k 15 -q 10 -type large\n./gen -n 2 -k 20 -q 10 -type special\n./gen -n 10 -k 1 -q 5 -type impossible\n./gen -n 1000 -k 20 -q 20 -type special\n./gen -n 1 -k 20 -q 5 -type edge_ai\n./gen -n 100 -k 20 -q 10 -type small\n./gen -n 500 -k 20 -q 20 -type impossible\n./gen -n 1000 -k 5 -q 15 -type special\n./gen -n 3000 -k 10 -q 5 -type random\n./gen -n 2000 -k 5 -q 15 -type special\n./gen -n 5000 -k 20 -q 20 -type random\n./gen -n 5000 -k 20 -q 20 -type large\n./gen -n 5000 -k 20 -q 20 -type edge_ai\n./gen -n 5000 -k 1 -q 20 -type k1\n./gen -n 5000 -k 20 -q 20 -type special\n./gen -n 2 -k 2 -q 2 -type small\n./gen -n 1000 -k 10 -q 10 -type edge_ai\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:20.902931",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "524/D",
      "title": "D. Social Network",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, M and T (1 ≤ n, M ≤ 20 000, 1 ≤ T ≤ 86400) — the number of queries, the record number of online users and the time when the user was online after a query was sent. Next n lines contain the times of the queries in the format \"hh:mm:ss\", where hh are hours, mm are minutes, ss are seconds. The times of the queries follow in the non-decreasing order, some of them can coincide. It is guaranteed that all the times and even all the segments of type [s, s + T - 1] are within one 24-hour range (from 00:00:00 to 23:59:59).",
      "output_spec": "OutputIn the first line print number R — the largest possible number of distinct users. The following n lines should contain the user IDs for requests in the same order in which the requests are given in the input. User IDs must be integers from 1 to R. The requests of the same user must correspond to the same identifiers, the requests of distinct users must correspond to distinct identifiers. If there are multiple solutions, print any of them. If there is no solution, print \"No solution\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy4 2 1017:05:5317:05:5817:06:0122:39:47OutputCopy31223InputCopy1 2 8640000:00:00OutputCopyNo solution",
      "description": "D. Social Network\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, M and T (1 ≤ n, M ≤ 20 000, 1 ≤ T ≤ 86400) — the number of queries, the record number of online users and the time when the user was online after a query was sent. Next n lines contain the times of the queries in the format \"hh:mm:ss\", where hh are hours, mm are minutes, ss are seconds. The times of the queries follow in the non-decreasing order, some of them can coincide. It is guaranteed that all the times and even all the segments of type [s, s + T - 1] are within one 24-hour range (from 00:00:00 to 23:59:59).\n\nOutputIn the first line print number R — the largest possible number of distinct users. The following n lines should contain the user IDs for requests in the same order in which the requests are given in the input. User IDs must be integers from 1 to R. The requests of the same user must correspond to the same identifiers, the requests of distinct users must correspond to distinct identifiers. If there are multiple solutions, print any of them. If there is no solution, print \"No solution\" (without the quotes).\n\nInputCopy4 2 1017:05:5317:05:5817:06:0122:39:47OutputCopy31223InputCopy1 2 8640000:00:00OutputCopyNo solution\n\nInputCopy4 2 1017:05:5317:05:5817:06:0122:39:47\n\nOutputCopy31223\n\nInputCopy1 2 8640000:00:00\n\nOutputCopyNo solution\n\nNoteConsider the first sample. The user who sent the first request was online from 17:05:53 to 17:06:02, the user who sent the second request was online from 17:05:58 to 17:06:07, the user who sent the third request, was online from 17:06:01 to 17:06:10. Thus, these IDs cannot belong to three distinct users, because in that case all these users would be online, for example, at 17:06:01. That is impossible, because M = 2. That means that some two of these queries belonged to the same user. One of the correct variants is given in the answer to the sample. For it user 1 was online from 17:05:53 to 17:06:02, user 2 — from 17:05:58 to 17:06:10 (he sent the second and third queries), user 3 — from 22:39:47 to 22:39:56.In the second sample there is only one query. So, only one user visited the network within the 24-hour period and there couldn't be two users online on the network simultaneously. (The time the user spent online is the union of time intervals for requests, so users who didn't send requests could not be online in the network.)",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 524\\s*D"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int M = inf.readInt(1, 20000, \"M\");\n    inf.readSpace();\n    int T = inf.readInt(1, 86400, \"T\");\n    inf.readEoln();\n    int prev_s = -1;\n    for (int i = 0; i < n; i++) {\n        string time_line = inf.readLine(\"[0-9]{2}:[0-9]{2}:[0-9]{2}\", \"time\");\n        int hh = stoi(time_line.substr(0,2));\n        int mm = stoi(time_line.substr(3,2));\n        int ss = stoi(time_line.substr(6,2));\n        ensuref(0 <= hh && hh <= 23, \"Invalid hour %d at line %d\", hh, i+2);\n        ensuref(0 <= mm && mm <= 59, \"Invalid minute %d at line %d\", mm, i+2);\n        ensuref(0 <= ss && ss <= 59, \"Invalid second %d at line %d\", ss, i+2);\n        int s = hh*3600 + mm*60 + ss;\n        ensuref(0 <= s && s <= 86399, \"Time value %d exceeds range at line %d\", s, i+2);\n        if (i > 0) {\n            ensuref(prev_s <= s, \"Times are not in non-decreasing order at line %d\", i+2);\n        }\n        ensuref(s + T - 1 <= 86399, \"Segment [s, s+T-1] exceeds 24-hour range at line %d\", i+2);\n        prev_s = s;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int M = inf.readInt(1, 20000, \"M\");\n    inf.readSpace();\n    int T = inf.readInt(1, 86400, \"T\");\n    inf.readEoln();\n    int prev_s = -1;\n    for (int i = 0; i < n; i++) {\n        string time_line = inf.readLine(\"[0-9]{2}:[0-9]{2}:[0-9]{2}\", \"time\");\n        int hh = stoi(time_line.substr(0,2));\n        int mm = stoi(time_line.substr(3,2));\n        int ss = stoi(time_line.substr(6,2));\n        ensuref(0 <= hh && hh <= 23, \"Invalid hour %d at line %d\", hh, i+2);\n        ensuref(0 <= mm && mm <= 59, \"Invalid minute %d at line %d\", mm, i+2);\n        ensuref(0 <= ss && ss <= 59, \"Invalid second %d at line %d\", ss, i+2);\n        int s = hh*3600 + mm*60 + ss;\n        ensuref(0 <= s && s <= 86399, \"Time value %d exceeds range at line %d\", s, i+2);\n        if (i > 0) {\n            ensuref(prev_s <= s, \"Times are not in non-decreasing order at line %d\", i+2);\n        }\n        ensuref(s + T - 1 <= 86399, \"Segment [s, s+T-1] exceeds 24-hour range at line %d\", i+2);\n        prev_s = s;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int M = inf.readInt(1, 20000, \"M\");\n    inf.readSpace();\n    int T = inf.readInt(1, 86400, \"T\");\n    inf.readEoln();\n    int prev_s = -1;\n    for (int i = 0; i < n; i++) {\n        string time_line = inf.readLine(\"[0-9]{2}:[0-9]{2}:[0-9]{2}\", \"time\");\n        int hh = stoi(time_line.substr(0,2));\n        int mm = stoi(time_line.substr(3,2));\n        int ss = stoi(time_line.substr(6,2));\n        ensuref(0 <= hh && hh <= 23, \"Invalid hour %d at line %d\", hh, i+2);\n        ensuref(0 <= mm && mm <= 59, \"Invalid minute %d at line %d\", mm, i+2);\n        ensuref(0 <= ss && ss <= 59, \"Invalid second %d at line %d\", ss, i+2);\n        int s = hh*3600 + mm*60 + ss;\n        ensuref(0 <= s && s <= 86399, \"Time value %d exceeds range at line %d\", s, i+2);\n        if (i > 0) {\n            ensuref(prev_s <= s, \"Times are not in non-decreasing order at line %d\", i+2);\n        }\n        ensuref(s + T - 1 <= 86399, \"Segment [s, s+T-1] exceeds 24-hour range at line %d\", i+2);\n        prev_s = s;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int SEC_PER_HOUR = 3600;\nstatic const int SEC_PER_MIN  = 60;\n\n// A structure to hold the parsed solution: either \"No solution\" or R plus an assignment of IDs\nstruct ParsedSolution {\n    bool noSolution;\n    int R;\n    vector<int> assignment; // of size n, if noSolution == false\n};\n\n// Convert \"hh:mm:ss\" into an integer number of seconds from 00:00:00\nint parseTime(const string &s) {\n    int hh = stoi(s.substr(0, 2));\n    int mm = stoi(s.substr(3, 2));\n    int ss = stoi(s.substr(6, 2));\n    return hh * SEC_PER_HOUR + mm * SEC_PER_MIN + ss;\n}\n\n// Reads the participant (or jury) output. Either\n//   1) \"No solution\", or\n//   2) An integer R followed by n integers (the user IDs).\n// 'streamName' is used in error messages. 'n' is the number of queries.\nParsedSolution readAnswer(InStream &stream, int n, const string &streamName) {\n    ParsedSolution sol;\n    \n    // We read just one token first. If it is \"No\", we expect the next token to be \"solution\".\n    // Otherwise, we interpret it as an integer R.\n    string firstToken = stream.readToken();\n    if (firstToken == \"No\") {\n        // We expect \"solution\" next\n        string secondToken = stream.readToken();\n        if (secondToken != \"solution\") {\n            stream.quitf(_wa, \"%s output 'No' but not followed by 'solution'\", streamName.c_str());\n        }\n        // Mark that it's \"No solution\"\n        sol.noSolution = true;\n        sol.R = 0;\n    } else {\n        // Otherwise, parse the first token as an integer R\n        int R;\n        // We can parse it via stoi and catch errors.\n        // If the token is not a valid integer or out of range, we quit with _wa.\n        try {\n            R = stoi(firstToken);\n        } catch (...) {\n            stream.quitf(_wa, \"%s output '%s' which is neither 'No' nor a valid integer R\",\n                         streamName.c_str(), firstToken.c_str());\n        }\n        \n        if (R < 1 || R > n) {\n            stream.quitf(_wa, \"%s output R=%d which is not in [1..%d]\", \n                         streamName.c_str(), R, n);\n        }\n        \n        vector<int> assignment(n);\n        for (int i = 0; i < n; i++) {\n            assignment[i] = stream.readInt(1, R, format(\"user ID for query %d\", i+1).c_str());\n        }\n        \n        sol.noSolution = false;\n        sol.R = R;\n        sol.assignment = assignment;\n    }\n    return sol;\n}\n\n// Check concurrency: merges intervals for each user and verifies maximum concurrency ≤ M\n// and that concurrency actually hits M at some moment.\nbool checkConcurrency(const vector<int> &times,\n                      const vector<int> &assignment,\n                      int R, int M, int T)\n{\n    int n = (int)times.size();\n    \n    // Check that each user from 1..R is used at least once\n    vector<bool> used(R+1, false);\n    for (int a : assignment) {\n        used[a] = true;\n    }\n    for (int u = 1; u <= R; u++) {\n        if (!used[u]) {\n            // If a user ID is never actually used, it means the solution claims R distinct\n            // users but doesn't utilize them all.\n            return false;\n        }\n    }\n    \n    // Build intervals for each user by merging the T-second windows starting at request times\n    vector<vector<int>> userReqs(R+1);\n    for (int i = 0; i < n; i++) {\n        userReqs[assignment[i]].push_back(times[i]);\n    }\n    \n    // We'll create a list of events (time, delta), then run a line-sweep\n    vector<pair<int,int>> events; \n    events.reserve(n * 2 + 10); // Just a safe reserve\n    \n    for (int u = 1; u <= R; u++) {\n        auto &req = userReqs[u];\n        if (req.empty()) continue;\n        \n        sort(req.begin(), req.end());\n        \n        // Merge intervals [start, end].\n        int start = req[0], end = req[0] + T - 1;\n        for (int i = 1; i < (int)req.size(); i++) {\n            int currS = req[i], currE = req[i] + T - 1;\n            if (currS <= end + 1) {\n                // Overlap => merge\n                end = max(end, currE);\n            } else {\n                // Close the old interval\n                events.push_back({start, +1});\n                events.push_back({end+1, -1});\n                // Start a new one\n                start = currS;\n                end   = currE;\n            }\n        }\n        // Close the last interval\n        events.push_back({start, +1});\n        events.push_back({end+1, -1});\n    }\n    \n    sort(events.begin(), events.end());\n    \n    long long curOnline = 0;\n    bool reachedM = false;\n    for (auto &e : events) {\n        curOnline += e.second;\n        if (curOnline > M) {\n            // concurrency exceeded M => invalid\n            return false;\n        }\n        if (curOnline == M) {\n            reachedM = true;\n        }\n    }\n    \n    // Must hit M at least once\n    if (!reachedM) return false;\n    \n    return true;\n}\n\nint main(int argc, char* argv[])\n{\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 20000, \"n\");\n    int M = inf.readInt(1, 20000, \"M\");\n    int T = inf.readInt(1, 86400, \"T\");\n    \n    vector<int> reqTimes(n);\n    for (int i = 0; i < n; i++) {\n        string st = inf.readToken(); // \"hh:mm:ss\"\n        reqTimes[i] = parseTime(st);\n    }\n\n    // Read jury's answer\n    ParsedSolution jurySol = readAnswer(ans, n, \"jury\");\n    bool juryValid = false;\n    if (jurySol.noSolution) {\n        // Jury claims no solution\n        juryValid = true;\n    } else {\n        // Check concurrency for jury's solution\n        if (checkConcurrency(reqTimes, jurySol.assignment, jurySol.R, M, T)) {\n            juryValid = true;\n        } else {\n            quitf(_fail, \"jury's solution is invalid\");\n        }\n    }\n\n    // Read participant's answer\n    ParsedSolution partSol = readAnswer(ouf, n, \"participant\");\n\n    // If jury's solution was invalid, we already quitf(_fail).\n    // So if we got here and juryValid == false, it's an unexpected scenario.\n    if (!juryValid) {\n        quitf(_fail, \"unexpected state: jury's solution was invalid.\");\n    }\n\n    // If jury says \"No solution\", then the only correct answer is also \"No solution\".\n    if (jurySol.noSolution) {\n        if (partSol.noSolution) {\n            // Both say no solution\n            quitf(_ok, \"both said no solution\");\n        } else {\n            // Jury says no solution but participant found one => WA\n            quitf(_wa, \"jury says no solution, but participant provided a solution\");\n        }\n    }\n\n    // If the jury has a valid solution with some R_jury\n    int R_jury = jurySol.R;\n    // If participant says \"No solution\", it's wrong\n    if (partSol.noSolution) {\n        quitf(_wa, \"jury has a valid solution, participant says no solution\");\n    }\n\n    // Compare R's\n    int R_part = partSol.R;\n    if (R_part < R_jury) {\n        quitf(_wa, \"participant's solution uses fewer distinct users (%d) than the jury's solution (%d)\", \n              R_part, R_jury);\n    }\n    if (R_part > R_jury) {\n        // That means participant found more users than the jury => we generally fail\n        quitf(_fail, \"participant's solution has more users (%d) than jury's official maximum (%d)\", \n              R_part, R_jury);\n    }\n\n    // So R_part == R_jury. Check concurrency constraints.\n    bool partValid = checkConcurrency(reqTimes, partSol.assignment, R_part, M, T);\n    if (!partValid) {\n        quitf(_wa, \"participant's solution concurrency check failed or never reached M\");\n    }\n\n    // Everything good\n    quitf(_ok, \"valid solution matching jury's number of distinct users\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int M = opt<int>(\"M\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // The maximum time in seconds (from 00:00:00 to 23:59:59)\n    int MAX_TIME = 24 * 60 * 60;\n    // Adjust the maximum starting time to ensure that s + T - 1 ≤ MAX_TIME - 1\n    int max_start_time = MAX_TIME - T;\n\n    vector<int> times(n);\n\n    if (type == \"random\") {\n        // Generate random times in [0, max_start_time]\n        for (int i = 0; i < n; ++i)\n            times[i] = rnd.next(0, max_start_time);\n        sort(times.begin(), times.end());\n    } else if (type == \"max_overlap\") {\n        // Generate times so that all intervals overlap as much as possible\n        int time = rnd.next(0, max_start_time);\n        for (int i = 0; i < n; ++i)\n            times[i] = time + rnd.next(0, T - 1);  // Slightly adjust times within the interval for non-decreasing order\n        sort(times.begin(), times.end());\n    } else if (type == \"min_overlap\") {\n        // Generate times so that intervals do not overlap\n        int time = 0;\n        for (int i = 0; i < n; ++i) {\n            times[i] = time;\n            time += T;\n            if (time > max_start_time) {\n                time = 0; // Wrap around if exceed\n            }\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"no_solution\") {\n        // Generate times where the number of overlapping intervals exceeds M\n        if (M >= n) {\n            // No solution is possible only if M < n\n            fprintf(stderr, \"Cannot generate no_solution test case when M >= n\\n\");\n            return 1;\n        }\n        int time = rnd.next(0, max_start_time);\n        for (int i = 0; i < n; ++i)\n            times[i] = time; // All times are the same, causing all intervals to overlap\n        sort(times.begin(), times.end());\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            times[i] = rnd.next(0, max_start_time);\n        sort(times.begin(), times.end());\n    }\n\n    // Output n, M, T\n    printf(\"%d %d %d\\n\", n, M, T);\n\n    // Output times in hh:mm:ss format\n    for (int i = 0; i < n; ++i) {\n        int total_seconds = times[i];\n        int h = total_seconds / 3600;\n        int m = (total_seconds % 3600) / 60;\n        int s = total_seconds % 60;\n        printf(\"%02d:%02d:%02d\\n\", h, m, s);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int M = opt<int>(\"M\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // The maximum time in seconds (from 00:00:00 to 23:59:59)\n    int MAX_TIME = 24 * 60 * 60;\n    // Adjust the maximum starting time to ensure that s + T - 1 ≤ MAX_TIME - 1\n    int max_start_time = MAX_TIME - T;\n\n    vector<int> times(n);\n\n    if (type == \"random\") {\n        // Generate random times in [0, max_start_time]\n        for (int i = 0; i < n; ++i)\n            times[i] = rnd.next(0, max_start_time);\n        sort(times.begin(), times.end());\n    } else if (type == \"max_overlap\") {\n        // Generate times so that all intervals overlap as much as possible\n        int time = rnd.next(0, max_start_time);\n        for (int i = 0; i < n; ++i)\n            times[i] = time + rnd.next(0, T - 1);  // Slightly adjust times within the interval for non-decreasing order\n        sort(times.begin(), times.end());\n    } else if (type == \"min_overlap\") {\n        // Generate times so that intervals do not overlap\n        int time = 0;\n        for (int i = 0; i < n; ++i) {\n            times[i] = time;\n            time += T;\n            if (time > max_start_time) {\n                time = 0; // Wrap around if exceed\n            }\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"no_solution\") {\n        // Generate times where the number of overlapping intervals exceeds M\n        if (M >= n) {\n            // No solution is possible only if M < n\n            fprintf(stderr, \"Cannot generate no_solution test case when M >= n\\n\");\n            return 1;\n        }\n        int time = rnd.next(0, max_start_time);\n        for (int i = 0; i < n; ++i)\n            times[i] = time; // All times are the same, causing all intervals to overlap\n        sort(times.begin(), times.end());\n    } else {\n        // Default to random if unknown type\n        for (int i = 0; i < n; ++i)\n            times[i] = rnd.next(0, max_start_time);\n        sort(times.begin(), times.end());\n    }\n\n    // Output n, M, T\n    printf(\"%d %d %d\\n\", n, M, T);\n\n    // Output times in hh:mm:ss format\n    for (int i = 0; i < n; ++i) {\n        int total_seconds = times[i];\n        int h = total_seconds / 3600;\n        int m = (total_seconds % 3600) / 60;\n        int s = total_seconds % 60;\n        printf(\"%02d:%02d:%02d\\n\", h, m, s);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -M 1 -T 1 -type random\n./gen -n 1 -M 1 -T 86400 -type random\n./gen -n 2 -M 1 -T 86400 -type max_overlap\n./gen -n 2 -M 1 -T 10 -type no_solution\n./gen -n 5 -M 2 -T 10 -type random\n./gen -n 1000 -M 10 -T 10000 -type random\n./gen -n 1000 -M 1 -T 10000 -type max_overlap\n./gen -n 1000 -M 1000 -T 1 -type min_overlap\n./gen -n 20000 -M 20000 -T 1 -type min_overlap\n./gen -n 20000 -M 1 -T 86400 -type max_overlap\n./gen -n 20000 -M 10000 -T 1000 -type random\n./gen -n 10000 -M 15000 -T 50000 -type random\n./gen -n 20000 -M 5000 -T 86400 -type no_solution\n./gen -n 5 -M 5 -T 86400 -type random\n./gen -n 3 -M 2 -T 10 -type no_solution\n./gen -n 20 -M 4 -T 3000 -type max_overlap\n./gen -n 20 -M 20 -T 1 -type min_overlap\n./gen -n 20000 -M 5000 -T 43200 -type random\n./gen -n 15000 -M 1000 -T 86400 -type max_overlap\n./gen -n 500 -M 1000 -T 10 -type random\n./gen -n 20000 -M 20000 -T 86400 -type random\n./gen -n 10000 -M 1 -T 86400 -type no_solution\n./gen -n 50 -M 25 -T 2 -type random\n./gen -n 20 -M 10 -T 86400 -type random\n./gen -n 20000 -M 10000 -T 86400 -type random\n./gen -n 5000 -M 5000 -T 86400 -type random\n./gen -n 2 -M 1 -T 86400 -type no_solution\n./gen -n 1 -M 1 -T 86400 -type random\n./gen -n 100 -M 50 -T 10 -type random\n./gen -n 1000 -M 1 -T 86400 -type no_solution\n./gen -n 10000 -M 10000 -T 1 -type min_overlap\n./gen -n 20000 -M 20000 -T 86400 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:22.873317",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "524/E",
      "title": "E. Rooks and Rectangles",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers n, m, k and q (1 ≤ n, m ≤ 100 000, 1 ≤ k, q ≤ 200 000) — the sizes of the board, the number of rooks and the number of strategically important sites. We will consider that the cells of the board are numbered by integers from 1 to n horizontally and from 1 to m vertically. Next k lines contain pairs of integers \"x y\", describing the positions of the rooks (1 ≤ x ≤ n, 1 ≤ y ≤ m). It is guaranteed that all the rooks are in distinct squares. Next q lines describe the strategically important areas as groups of four integers \"x1 y1 x2 y2\" (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ m). The corresponding rectangle area consists of cells (x, y), for which x1 ≤ x ≤ x2, y1 ≤ y ≤ y2. Strategically important areas can intersect of coincide.",
      "output_spec": "OutputPrint q lines. For each strategically important site print \"YES\" if it is well defended and \"NO\" otherwise.",
      "sample_tests": "ExamplesInputCopy4 3 3 31 13 22 32 3 2 32 1 3 31 2 2 3OutputCopyYESYESNO",
      "description": "E. Rooks and Rectangles\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers n, m, k and q (1 ≤ n, m ≤ 100 000, 1 ≤ k, q ≤ 200 000) — the sizes of the board, the number of rooks and the number of strategically important sites. We will consider that the cells of the board are numbered by integers from 1 to n horizontally and from 1 to m vertically. Next k lines contain pairs of integers \"x y\", describing the positions of the rooks (1 ≤ x ≤ n, 1 ≤ y ≤ m). It is guaranteed that all the rooks are in distinct squares. Next q lines describe the strategically important areas as groups of four integers \"x1 y1 x2 y2\" (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ m). The corresponding rectangle area consists of cells (x, y), for which x1 ≤ x ≤ x2, y1 ≤ y ≤ y2. Strategically important areas can intersect of coincide.\n\nOutputPrint q lines. For each strategically important site print \"YES\" if it is well defended and \"NO\" otherwise.\n\nInputCopy4 3 3 31 13 22 32 3 2 32 1 3 31 2 2 3OutputCopyYESYESNO\n\nInputCopy4 3 3 31 13 22 32 3 2 32 1 3 31 2 2 3\n\nOutputCopyYESYESNO\n\nNotePicture to the sample:  For the last area the answer is \"NO\", because cell (1, 2) cannot be hit by a rook.",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 524\\s*E"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> rook_positions;\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(x, y);\n        ensuref(rook_positions.insert(p).second, \"Duplicate rook position at (%d, %d)\", x, y);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1_i\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1_i\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, n, \"x2_i\"); // x2 >= x1\n        inf.readSpace();\n        int y2 = inf.readInt(y1, m, \"y2_i\"); // y2 >= y1\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> rook_positions;\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(x, y);\n        ensuref(rook_positions.insert(p).second, \"Duplicate rook position at (%d, %d)\", x, y);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1_i\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1_i\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, n, \"x2_i\"); // x2 >= x1\n        inf.readSpace();\n        int y2 = inf.readInt(y1, m, \"y2_i\"); // y2 >= y1\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> rook_positions;\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n\n        pair<int, int> p = make_pair(x, y);\n        ensuref(rook_positions.insert(p).second, \"Duplicate rook position at (%d, %d)\", x, y);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1_i\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1_i\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, n, \"x2_i\"); // x2 >= x1\n        inf.readSpace();\n        int y2 = inf.readInt(y1, m, \"y2_i\"); // y2 >= y1\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\"\n\n    // Adjust the k and q to ensure they are within the constraints (1 ≤ k, q ≤ 200 000).\n    k = min(k, 200000);\n    k = max(k, 1);\n    q = min(q, 200000);\n    q = max(q, 1);\n\n    // Similarly, adjust n and m to be within 1 ≤ n, m ≤ 100000.\n    n = min(n, 100000);\n    n = max(n, 1);\n    m = min(m, 100000);\n    m = max(m, 1);\n\n    if (type == \"random\") {\n        /* Random rooks and random areas */\n\n        set<pair<int,int>> rook_positions;\n        while ((int)rook_positions.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            rook_positions.insert(make_pair(x, y));\n        }\n        // Generate q random areas\n        vector<tuple<int,int,int,int>> areas;\n        for (int i = 0; i < q; i++) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n\n            areas.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1, y1, x2, y2;\n            tie(x1, y1, x2, y2) = area;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n\n    } else if (type == \"edge1\") {\n        // n = m = 1\n        n = m = 1;\n        k = min(k, 1); // There can be at most 1 rook\n        q = max(q, 1); // At least one area\n\n        set<pair<int,int>> rook_positions;\n        if (k == 1) rook_positions.insert(make_pair(1,1));\n\n        vector<tuple<int,int,int,int>> areas;\n        for (int i = 0; i < q; i++) {\n            areas.push_back(make_tuple(1,1,1,1));\n        }\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1, y1, x2, y2;\n            tie(x1, y1, x2, y2) = area;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n\n    } else if (type == \"rooks_outside\") {\n        // Place rooks outside the area that could attack into the area\n\n        // Ensure n and m are at least 10\n        n = max(n, 10);\n        m = max(m, 10);\n        // Let's set k = number of rooks outside the area\n        int area_k = 0;\n\n        int x1 = n / 3;\n        int x2 = 2 * n / 3;\n        int y1 = m / 3;\n        int y2 = 2 * m / 3;\n\n        set<pair<int,int>> rook_positions;\n\n        // Place a rook outside the area that can attack inside\n        int rook_x = x1 - 1;\n        if (rook_x < 1) rook_x = x2 + 1;\n        int rook_y = y1; // Same column as area\n        if (rook_x <= n && rook_y <= m) {\n            rook_positions.insert(make_pair(rook_x, rook_y));\n        }\n\n        // No rooks inside the area\n        k = rook_positions.size();\n\n        q = 1;\n        vector<tuple<int,int,int,int>> areas;\n        areas.push_back(make_tuple(x1, y1, x2, y2));\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1_out, y1_out, x2_out, y2_out;\n            tie(x1_out, y1_out, x2_out, y2_out) = area;\n            printf(\"%d %d %d %d\\n\", x1_out, y1_out, x2_out, y2_out);\n        }\n\n    } else if (type == \"blocked_rooks\") {\n        // Place rooks in the area such that they block each other\n\n        // Ensure n and m are at least 5\n        n = max(n, 5);\n        m = max(m, 5);\n\n        // Place rooks in a line in the area to block each other's attack\n        int x1 = 1;\n        int x2 = n;\n        int y1 = 1;\n        int y2 = m;\n\n        vector<int> xs = {x1 + 1, x1 + 2, x1 + 3}; // Three rooks in the same row\n        int y = y1 + 1; // Same column\n        set<pair<int,int>> rook_positions;\n        for (int xi : xs) {\n            rook_positions.insert(make_pair(xi, y));\n        }\n\n        // Now, some vacant squares in the same row but beyond the rooks, which are blocked\n        k = rook_positions.size();\n        q = 1;\n        vector<tuple<int,int,int,int>> areas;\n        areas.push_back(make_tuple(x1, y1, x2, y2));\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1_out, y1_out, x2_out, y2_out;\n            tie(x1_out, y1_out, x2_out, y2_out) = area;\n            printf(\"%d %d %d %d\\n\", x1_out, y1_out, x2_out, y2_out);\n        }\n\n    } else if (type == \"full_rooks\") {\n        // Area where every cell has a rook\n\n        int area_n = min(n, 500); // Limit area size to avoid too many positions\n        int area_m = min(m, 500);\n\n        int x1 = rnd.next(1, n - area_n + 1);\n        int y1 = rnd.next(1, m - area_m + 1);\n        int x2 = x1 + area_n - 1;\n        int y2 = y1 + area_m - 1;\n\n        // Place rooks in every cell of the area\n        set<pair<int,int>> rook_positions;\n        for (int x = x1; x <= x2; x++) {\n            for (int y = y1; y <= y2; y++) {\n                rook_positions.insert(make_pair(x, y));\n            }\n        }\n\n        // Optionally, place additional rooks outside the area\n        while ((int)rook_positions.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) continue; // Skip if inside area\n            rook_positions.insert(make_pair(x, y));\n        }\n\n        q = 1;\n        vector<tuple<int,int,int,int>> areas;\n        areas.push_back(make_tuple(x1, y1, x2, y2));\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1_out, y1_out, x2_out, y2_out;\n            tie(x1_out, y1_out, x2_out, y2_out) = area;\n            printf(\"%d %d %d %d\\n\", x1_out, y1_out, x2_out, y2_out);\n        }\n\n    } else {\n        // Default: random case\n        // Same as the first case\n        /* Random rooks and random areas */\n\n        set<pair<int,int>> rook_positions;\n        while ((int)rook_positions.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            rook_positions.insert(make_pair(x, y));\n        }\n        // Generate q random areas\n        vector<tuple<int,int,int,int>> areas;\n        for (int i = 0; i < q; i++) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n\n            areas.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1, y1, x2, y2;\n            tie(x1, y1, x2, y2) = area;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    int q = opt<int>(\"q\");\n    string type = opt<string>(\"type\", \"random\"); // default to \"random\"\n\n    // Adjust the k and q to ensure they are within the constraints (1 ≤ k, q ≤ 200 000).\n    k = min(k, 200000);\n    k = max(k, 1);\n    q = min(q, 200000);\n    q = max(q, 1);\n\n    // Similarly, adjust n and m to be within 1 ≤ n, m ≤ 100000.\n    n = min(n, 100000);\n    n = max(n, 1);\n    m = min(m, 100000);\n    m = max(m, 1);\n\n    if (type == \"random\") {\n        /* Random rooks and random areas */\n\n        set<pair<int,int>> rook_positions;\n        while ((int)rook_positions.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            rook_positions.insert(make_pair(x, y));\n        }\n        // Generate q random areas\n        vector<tuple<int,int,int,int>> areas;\n        for (int i = 0; i < q; i++) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n\n            areas.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1, y1, x2, y2;\n            tie(x1, y1, x2, y2) = area;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n\n    } else if (type == \"edge1\") {\n        // n = m = 1\n        n = m = 1;\n        k = min(k, 1); // There can be at most 1 rook\n        q = max(q, 1); // At least one area\n\n        set<pair<int,int>> rook_positions;\n        if (k == 1) rook_positions.insert(make_pair(1,1));\n\n        vector<tuple<int,int,int,int>> areas;\n        for (int i = 0; i < q; i++) {\n            areas.push_back(make_tuple(1,1,1,1));\n        }\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1, y1, x2, y2;\n            tie(x1, y1, x2, y2) = area;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n\n    } else if (type == \"rooks_outside\") {\n        // Place rooks outside the area that could attack into the area\n\n        // Ensure n and m are at least 10\n        n = max(n, 10);\n        m = max(m, 10);\n        // Let's set k = number of rooks outside the area\n        int area_k = 0;\n\n        int x1 = n / 3;\n        int x2 = 2 * n / 3;\n        int y1 = m / 3;\n        int y2 = 2 * m / 3;\n\n        set<pair<int,int>> rook_positions;\n\n        // Place a rook outside the area that can attack inside\n        int rook_x = x1 - 1;\n        if (rook_x < 1) rook_x = x2 + 1;\n        int rook_y = y1; // Same column as area\n        if (rook_x <= n && rook_y <= m) {\n            rook_positions.insert(make_pair(rook_x, rook_y));\n        }\n\n        // No rooks inside the area\n        k = rook_positions.size();\n\n        q = 1;\n        vector<tuple<int,int,int,int>> areas;\n        areas.push_back(make_tuple(x1, y1, x2, y2));\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1_out, y1_out, x2_out, y2_out;\n            tie(x1_out, y1_out, x2_out, y2_out) = area;\n            printf(\"%d %d %d %d\\n\", x1_out, y1_out, x2_out, y2_out);\n        }\n\n    } else if (type == \"blocked_rooks\") {\n        // Place rooks in the area such that they block each other\n\n        // Ensure n and m are at least 5\n        n = max(n, 5);\n        m = max(m, 5);\n\n        // Place rooks in a line in the area to block each other's attack\n        int x1 = 1;\n        int x2 = n;\n        int y1 = 1;\n        int y2 = m;\n\n        vector<int> xs = {x1 + 1, x1 + 2, x1 + 3}; // Three rooks in the same row\n        int y = y1 + 1; // Same column\n        set<pair<int,int>> rook_positions;\n        for (int xi : xs) {\n            rook_positions.insert(make_pair(xi, y));\n        }\n\n        // Now, some vacant squares in the same row but beyond the rooks, which are blocked\n        k = rook_positions.size();\n        q = 1;\n        vector<tuple<int,int,int,int>> areas;\n        areas.push_back(make_tuple(x1, y1, x2, y2));\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1_out, y1_out, x2_out, y2_out;\n            tie(x1_out, y1_out, x2_out, y2_out) = area;\n            printf(\"%d %d %d %d\\n\", x1_out, y1_out, x2_out, y2_out);\n        }\n\n    } else if (type == \"full_rooks\") {\n        // Area where every cell has a rook\n\n        int area_n = min(n, 500); // Limit area size to avoid too many positions\n        int area_m = min(m, 500);\n\n        int x1 = rnd.next(1, n - area_n + 1);\n        int y1 = rnd.next(1, m - area_m + 1);\n        int x2 = x1 + area_n - 1;\n        int y2 = y1 + area_m - 1;\n\n        // Place rooks in every cell of the area\n        set<pair<int,int>> rook_positions;\n        for (int x = x1; x <= x2; x++) {\n            for (int y = y1; y <= y2; y++) {\n                rook_positions.insert(make_pair(x, y));\n            }\n        }\n\n        // Optionally, place additional rooks outside the area\n        while ((int)rook_positions.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            if (x >= x1 && x <= x2 && y >= y1 && y <= y2) continue; // Skip if inside area\n            rook_positions.insert(make_pair(x, y));\n        }\n\n        q = 1;\n        vector<tuple<int,int,int,int>> areas;\n        areas.push_back(make_tuple(x1, y1, x2, y2));\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1_out, y1_out, x2_out, y2_out;\n            tie(x1_out, y1_out, x2_out, y2_out) = area;\n            printf(\"%d %d %d %d\\n\", x1_out, y1_out, x2_out, y2_out);\n        }\n\n    } else {\n        // Default: random case\n        // Same as the first case\n        /* Random rooks and random areas */\n\n        set<pair<int,int>> rook_positions;\n        while ((int)rook_positions.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            rook_positions.insert(make_pair(x, y));\n        }\n        // Generate q random areas\n        vector<tuple<int,int,int,int>> areas;\n        for (int i = 0; i < q; i++) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n\n            areas.push_back(make_tuple(x1, y1, x2, y2));\n        }\n\n        // Output n m k q\n        printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n        // Output rook positions\n        for (auto p : rook_positions) {\n            printf(\"%d %d\\n\", p.first, p.second);\n        }\n\n        // Output areas\n        for (auto area : areas) {\n            int x1, y1, x2, y2;\n            tie(x1, y1, x2, y2) = area;\n            printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 4 -m 3 -k 3 -q 3 -type random\n./gen -n 1 -m 1 -k 1 -q 1 -type edge1\n./gen -n 1 -m 100000 -k 1 -q 5 -type edge2\n./gen -n 100000 -m 1 -k 1 -q 5 -type edge2\n\n./gen -n 100000 -m 100000 -k 200000 -q 200000 -type random\n./gen -n 100000 -m 100000 -k 200000 -q 200000 -type max_case\n\n./gen -n 100 -m 100 -k 0 -q 10 -type no_rooks\n./gen -n 100 -m 100 -k 50 -q 10 -type no_rooks\n\n./gen -n 10000 -m 10000 -k 100000 -q 1 -type full_rooks\n./gen -n 100 -m 100 -k 5000 -q 1 -type full_area\n\n./gen -n 20 -m 20 -k 5 -q 2 -type rooks_outside\n./gen -n 20 -m 20 -k 5 -q 2 -type blocked_rooks\n\n./gen -n 100000 -m 100000 -k 100 -q 1000 -type single_cell_area\n./gen -n 100000 -m 100000 -k 100000 -q 1000 -type large_random\n\n./gen -n 50000 -m 50000 -k 100000 -q 200000 -type random\n./gen -n 100000 -m 100000 -k 1 -q 200000 -type random\n./gen -n 100000 -m 100000 -k 200000 -q 1 -type random\n\n./gen -n 100000 -m 100000 -k 0 -q 1 -type random\n./gen -n 100000 -m 100000 -k 0 -q 200000 -type random\n\n./gen -n 2 -m 2 -k 1 -q 2 -type edge_case\n./gen -n 99999 -m 99999 -k 1 -q 1 -type edge_case\n\n./gen -n 1000 -m 1000 -k 10000 -q 1000 -type random\n./gen -n 100000 -m 100000 -k 200000 -q 200000 -type random\n\n./gen -n 1 -m 1 -k 0 -q 1 -type edge1\n./gen -n 1 -m 1 -k 1 -q 1 -type edge1\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:24.617423",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "524/F",
      "title": "F. And Yet Another Bracket Sequence",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains Polycarpus's sequence consisting of characters \"(\" and \")\". The length of a line is from 1 to 1 000 000.",
      "output_spec": "OutputPrint a correct bracket sequence of the minimum length that Polycarpus can obtain by his operations. If there are multiple such sequences, print the lexicographically minimum one.",
      "sample_tests": "ExamplesInputCopy()(())OutputCopy(())()InputCopy()(OutputCopy(())",
      "description": "F. And Yet Another Bracket Sequence\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains Polycarpus's sequence consisting of characters \"(\" and \")\". The length of a line is from 1 to 1 000 000.\n\nOutputPrint a correct bracket sequence of the minimum length that Polycarpus can obtain by his operations. If there are multiple such sequences, print the lexicographically minimum one.\n\nInputCopy()(())OutputCopy(())()InputCopy()(OutputCopy(())\n\nInputCopy()(())\n\nOutputCopy(())()\n\nInputCopy()(\n\nOutputCopy(())\n\nNoteThe sequence in the first example is already correct, but to get the lexicographically minimum answer, you need to perform four cyclic shift operations. In the second example you need to add a closing parenthesis between the second and third brackets and make a cyclic shift. You can first make the shift, and then add the bracket at the end.",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 524\\s*F"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 1000000,\n        \"Length of the sequence must be between 1 and 1 000 000, but it is %d\", (int)s.length());\n    for (char c : s) {\n        ensuref(c == '(' || c == ')', \"Invalid character '%c' found in sequence\", c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 1000000,\n        \"Length of the sequence must be between 1 and 1 000 000, but it is %d\", (int)s.length());\n    for (char c : s) {\n        ensuref(c == '(' || c == ')', \"Invalid character '%c' found in sequence\", c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    ensuref(1 <= s.length() && s.length() <= 1000000,\n        \"Length of the sequence must be between 1 and 1 000 000, but it is %d\", (int)s.length());\n    for (char c : s) {\n        ensuref(c == '(' || c == ')', \"Invalid character '%c' found in sequence\", c);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    string s;\n\n    if (type == \"all_open\") {\n        // Generate a sequence of all '(' brackets\n        s = string(n, '(');\n    }\n    else if (type == \"all_close\") {\n        // Generate a sequence of all ')' brackets\n        s = string(n, ')');\n    }\n    else if (type == \"alternating\") {\n        // Generate an alternating sequence of '(' and ')'\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '(';\n            else\n                s += ')';\n        }\n    }\n    else if (type == \"balanced\") {\n        // Generate a balanced bracket sequence\n        if (n % 2 != 0) {\n            // Cannot generate a balanced sequence of odd length\n            cerr << \"Cannot generate balanced sequence of odd length\" << endl;\n            return 1;\n        }\n        int total_open = n / 2;\n        int open = 0;\n        for (int i = 0; i < n; ++i) {\n            if (open == 0) {\n                // Must add '('\n                s += '(';\n                ++open;\n                --total_open;\n            }\n            else if (total_open == 0) {\n                // Must add ')'\n                s += ')';\n                --open;\n            }\n            else {\n                if (rnd.next(2)) {\n                    s += '(';\n                    ++open;\n                    --total_open;\n                }\n                else {\n                    s += ')';\n                    --open;\n                }\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Generate a random bracket sequence\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n    }\n    else if (type == \"unbalanced\") {\n        // Generate an unbalanced bracket sequence\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n        // Ensure the sequence is unbalanced\n        int balance = 0;\n        bool is_balanced = true;\n        for (char c : s) {\n            if (c == '(')\n                ++balance;\n            else\n                --balance;\n            if (balance < 0) {\n                is_balanced = false;\n                break;\n            }\n        }\n        if (balance != 0)\n            is_balanced = false;\n        if (is_balanced) {\n            // Flip a random bracket to make it unbalanced\n            int idx = rnd.next(n);\n            s[idx] = (s[idx] == '(' ? ')' : '(');\n        }\n    }\n    else if (type == \"deep_nesting\") {\n        // Generate a sequence with maximum nesting depth\n        if (n % 2 != 0) {\n            // Cannot generate deep nesting with odd length\n            cerr << \"Cannot generate deep nesting sequence of odd length\" << endl;\n            return 1;\n        }\n        s = \"\";\n        for (int i = 0; i < n / 2; ++i) {\n            s += '(';\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            s += ')';\n        }\n    }\n    else if (type == \"shallow_nesting\") {\n        // Generate a sequence with minimal nesting depth\n        if (n % 2 != 0) {\n            // Cannot generate shallow nesting with odd length\n            cerr << \"Cannot generate shallow nesting sequence of odd length\" << endl;\n            return 1;\n        }\n        s = \"\";\n        int pairs = n / 2;\n        for (int i = 0; i < pairs; ++i) {\n            s += \"()\";\n        }\n    }\n    else {\n        cerr << \"Invalid type\" << endl;\n        return 1;\n    }\n\n    // Output the sequence\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n\n    string s;\n\n    if (type == \"all_open\") {\n        // Generate a sequence of all '(' brackets\n        s = string(n, '(');\n    }\n    else if (type == \"all_close\") {\n        // Generate a sequence of all ')' brackets\n        s = string(n, ')');\n    }\n    else if (type == \"alternating\") {\n        // Generate an alternating sequence of '(' and ')'\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0)\n                s += '(';\n            else\n                s += ')';\n        }\n    }\n    else if (type == \"balanced\") {\n        // Generate a balanced bracket sequence\n        if (n % 2 != 0) {\n            // Cannot generate a balanced sequence of odd length\n            cerr << \"Cannot generate balanced sequence of odd length\" << endl;\n            return 1;\n        }\n        int total_open = n / 2;\n        int open = 0;\n        for (int i = 0; i < n; ++i) {\n            if (open == 0) {\n                // Must add '('\n                s += '(';\n                ++open;\n                --total_open;\n            }\n            else if (total_open == 0) {\n                // Must add ')'\n                s += ')';\n                --open;\n            }\n            else {\n                if (rnd.next(2)) {\n                    s += '(';\n                    ++open;\n                    --total_open;\n                }\n                else {\n                    s += ')';\n                    --open;\n                }\n            }\n        }\n    }\n    else if (type == \"random\") {\n        // Generate a random bracket sequence\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n    }\n    else if (type == \"unbalanced\") {\n        // Generate an unbalanced bracket sequence\n        s = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n        // Ensure the sequence is unbalanced\n        int balance = 0;\n        bool is_balanced = true;\n        for (char c : s) {\n            if (c == '(')\n                ++balance;\n            else\n                --balance;\n            if (balance < 0) {\n                is_balanced = false;\n                break;\n            }\n        }\n        if (balance != 0)\n            is_balanced = false;\n        if (is_balanced) {\n            // Flip a random bracket to make it unbalanced\n            int idx = rnd.next(n);\n            s[idx] = (s[idx] == '(' ? ')' : '(');\n        }\n    }\n    else if (type == \"deep_nesting\") {\n        // Generate a sequence with maximum nesting depth\n        if (n % 2 != 0) {\n            // Cannot generate deep nesting with odd length\n            cerr << \"Cannot generate deep nesting sequence of odd length\" << endl;\n            return 1;\n        }\n        s = \"\";\n        for (int i = 0; i < n / 2; ++i) {\n            s += '(';\n        }\n        for (int i = 0; i < n / 2; ++i) {\n            s += ')';\n        }\n    }\n    else if (type == \"shallow_nesting\") {\n        // Generate a sequence with minimal nesting depth\n        if (n % 2 != 0) {\n            // Cannot generate shallow nesting with odd length\n            cerr << \"Cannot generate shallow nesting sequence of odd length\" << endl;\n            return 1;\n        }\n        s = \"\";\n        int pairs = n / 2;\n        for (int i = 0; i < pairs; ++i) {\n            s += \"()\";\n        }\n    }\n    else {\n        cerr << \"Invalid type\" << endl;\n        return 1;\n    }\n\n    // Output the sequence\n    printf(\"%s\\n\", s.c_str());\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all_open\n./gen -n 1 -type all_close\n./gen -n 2 -type balanced\n./gen -n 2 -type alternating\n./gen -n 2 -type deep_nesting\n./gen -n 3 -type unbalanced\n./gen -n 5 -type random\n./gen -n 5 -type unbalanced\n./gen -n 6 -type balanced\n./gen -n 6 -type shallow_nesting\n./gen -n 10 -type random\n./gen -n 10 -type unbalanced\n./gen -n 10 -type balanced\n./gen -n 20 -type deep_nesting\n./gen -n 20 -type shallow_nesting\n./gen -n 50 -type random\n./gen -n 100 -type unbalanced\n./gen -n 100 -type all_open\n./gen -n 100 -type all_close\n./gen -n 1000 -type random\n./gen -n 1000 -type balanced\n./gen -n 1000 -type unbalanced\n./gen -n 10000 -type random\n./gen -n 10000 -type balanced\n./gen -n 100000 -type random\n./gen -n 100000 -type balanced\n./gen -n 100000 -type unbalanced\n./gen -n 500000 -type deep_nesting\n./gen -n 500000 -type shallow_nesting\n./gen -n 999999 -type random\n./gen -n 1000000 -type all_open\n./gen -n 1000000 -type all_close\n./gen -n 1000000 -type alternating\n./gen -n 1000000 -type balanced\n./gen -n 1000000 -type unbalanced\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:26.476319",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "525/A",
      "title": "A. Vitaliy and Pie",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a positive integer n (2 ≤ n ≤ 105) — the number of rooms in the house.The second line of the input contains string s of length 2·n - 2. Let's number the elements of the string from left to right, starting from one. The odd positions in the given string s contain lowercase Latin letters — the types of the keys that lie in the corresponding rooms. Thus, each odd position i of the given string s contains a lowercase Latin letter — the type of the key that lies in room number (i + 1) / 2.The even positions in the given string contain uppercase Latin letters — the types of doors between the rooms. Thus, each even position i of the given string s contains an uppercase letter — the type of the door that leads from room i / 2 to room i / 2 + 1.",
      "output_spec": "OutputPrint the only integer — the minimum number of keys that Vitaly needs to buy to surely get from room one to room n.",
      "sample_tests": "ExamplesInputCopy3aAbBOutputCopy0InputCopy4aBaCaBOutputCopy3InputCopy5xYyXzZaZOutputCopy2",
      "description": "A. Vitaliy and Pie\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a positive integer n (2 ≤ n ≤ 105) — the number of rooms in the house.The second line of the input contains string s of length 2·n - 2. Let's number the elements of the string from left to right, starting from one. The odd positions in the given string s contain lowercase Latin letters — the types of the keys that lie in the corresponding rooms. Thus, each odd position i of the given string s contains a lowercase Latin letter — the type of the key that lies in room number (i + 1) / 2.The even positions in the given string contain uppercase Latin letters — the types of doors between the rooms. Thus, each even position i of the given string s contains an uppercase letter — the type of the door that leads from room i / 2 to room i / 2 + 1.\n\nOutputPrint the only integer — the minimum number of keys that Vitaly needs to buy to surely get from room one to room n.\n\nInputCopy3aAbBOutputCopy0InputCopy4aBaCaBOutputCopy3InputCopy5xYyXzZaZOutputCopy2\n\nInputCopy3aAbB\n\nOutputCopy0\n\nInputCopy4aBaCaB\n\nOutputCopy3\n\nInputCopy5xYyXzZaZ\n\nOutputCopy2",
      "solutions": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #297 (Div. 2). It'll be held on Thursday, March 26 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my old friends Pavel Kholkin (HolkinPV), Ilya Los (IlyaLos), Vitaliy Kudasov (kuviman) and Arthur Svechnikov (ikar) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring is smooth dynamic (with steps of 250 points). More information about this can be found here. Tasks will be arranged in order of ascending supposed difficulty.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! cikofte fcspartakm_2 stealife GITLER228 alpq654321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces",
          "content": "525A — Vitaliy and PattyTo solve this problem we need to use array cnt[]. In this array we will store number of keys of every type, which we already found in rooms, but didn't use. Answer will store in variable ans. Now, we iterate on string. If current element of string si is lowercase letter (key), we make cnt[si]++. Else if current element of string si uppercase letter (door) and cnt[tolower(si)] > 0, we make cnt[tolower(si)]--, else we make ans++. It remains only to print ans. Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.525B — Pasha and StringAt first we need to understand next fact — it doesn't matter in wich order make reverses, answer will be the same for all orders. Let's numerate elements of string from one. To solve given problem we need to count how many reverses will begin in every position of string. Then we need to count array sum[]. In sum[i] we need to store count of reverses of substrings, which begin in positions which not exceeding i. Now iterate for i from 1 to n / 2 and if sum[i] is odd swap si and sn - i + 1. After that it remains only to print string s. Asymptotic behavior of this solution — O(n + m), where n — length of string s, m — count of reverses.525C — Ilya and SticksThis problem can be solved with help of greedy. At first count array cnt[]. In cnt[i] will store how many sticks with length i we have. Now iterate for len from maximal length of sticks to minimal. If cnt[len] is odd and we have sticks with length len - 1 (that is cnt[len - 1] > 0), make cnt[len]-- and cnt[len - 1]++. If cnt[len] is odd and we have no sticks with length len - 1 (that is cnt[len - 1] = 0), make cnt[len]--. In this way we properly done all sawing which we need and guaranteed that all cnt[len] is even. After that iterate similary on length of sticks and greedily merge pairs from 2 sticks with the same length in fours. It will be length of sides of sought-for rectangles, left only summarize their squares in answer. In the end can left 2 sticks without pair, we must not consider them in answer. For example, if cnt[5] = 6, cnt[4] = 4, cnt[2] = 4, we need to merge this sticks in following way — (5, 5, 5, 5), (5, 5, 4, 4), (4, 4, 2, 2). Two sticks with length 2 are left, we must not count them. Asymptotic behavior of this solution — O(n + maxlen - minlen), where n — count of sticks, maxlen — maximal length of stick, minlen — minimal length of stick.525D — Arthur and WallsTo solve this problem we need to observe next fact. If in some square whith size 2 × 2 in given matrix there is exactly one asterisk, we must change it on dot. That is if in matrix from dots and asterisks is not square 2 × 2 in which exactly one asterisk and three dots, then all maximum size of the area from dots connected by sides represent rectangles. Now solve the problem with help of bfs and this fact. Iterate on all asterisks in given matrix and if only this asterisk contains in some 2 × 2 square, change this asterisk on dot and put this position in queue. Than we need to write standart bfs, in which we will change asterisks on dots in all come out 2 × 2 squares with exactly one asterisk. Asymptotic behavior of this solution — O(n * m), where n and m sizes of given matrix.525E — Anya and CubesTo solve this problem we need to use meet-in-the-middle. At first sort given array in increasing order and divide it in two parts. In first part must be first n / 2 elements, in second part — other. Iterate all submasks of all masks of elements from first part. That is iterate which cubes from first part we take and on which from them we paste exclamation marks. In this way we iterated all possible sums, which we can get with cubes from first part. Let for current submask we get sum sum_lf and use tlf exclamation marks. To store all such sums we use associative arrays map < long long > cnt[k + 1], where k — count of exclamation marks which we have in the beginning. After that similary iterate all submasks of all masks of elements from second part. Let for current submask sum is sumrg and number of used exclamation marks is trg. Then from first part we need to get sum (s - sumrg) and we can use only (k - trg) exclamation marks, where s — sum which we must get by condition of the problem. Then iterate how many exclamation marks we will use in first part (let it be variable cur) and increase answer on cnt[cur][s - sumrg]. To accelerate our programm we may increase answer only if cnt[cur].count(s - sumrg) = true. For submasks in iterate we can cut off iteration on current sum for submask (it must be less or equal to given s) and on current count of exclamation marks (it must be less or equal to given k). Also we should not paste exclamation marks on cubecs with numbers larger than 18, because 19! more than 1016 — maximal value of s. Asymptotic behavior of this solution — O(3((n + 1) / 2) * log(maxcnt) * k), where n — count of cubes, maxcnt — maximal size of associative array, k — count of exclamation marks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 525\\s*A"
          },
          "content_length": 4990
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 1",
          "code": "aaaaa... 100000 1 1 1 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 2",
          "code": "Test: #12, time: 717 ms., memory: 4404 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 3",
          "code": "expected: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**', found: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 1",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 2",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 3",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 4",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 5",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 6",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 7",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 8",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 9",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 10",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 11",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 12",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 13",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == 2 * n - 2, \"The length of s should be 2n - 2 = %d, but it is %d.\", 2 * n - 2, int(s.length()));\n\n    for (int i = 0; i < int(s.length()); ++i) {\n        if (i % 2 == 0) {\n            // Should be lowercase letter\n            ensuref('a' <= s[i] && s[i] <= 'z', \"At position %d, expected a lowercase letter, but found '%c'\", i + 1, s[i]);\n        } else {\n            // Should be uppercase letter\n            ensuref('A' <= s[i] && s[i] <= 'Z', \"At position %d, expected an uppercase letter, but found '%c'\", i + 1, s[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == 2 * n - 2, \"The length of s should be 2n - 2 = %d, but it is %d.\", 2 * n - 2, int(s.length()));\n\n    for (int i = 0; i < int(s.length()); ++i) {\n        if (i % 2 == 0) {\n            // Should be lowercase letter\n            ensuref('a' <= s[i] && s[i] <= 'z', \"At position %d, expected a lowercase letter, but found '%c'\", i + 1, s[i]);\n        } else {\n            // Should be uppercase letter\n            ensuref('A' <= s[i] && s[i] <= 'Z', \"At position %d, expected an uppercase letter, but found '%c'\", i + 1, s[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref(int(s.length()) == 2 * n - 2, \"The length of s should be 2n - 2 = %d, but it is %d.\", 2 * n - 2, int(s.length()));\n\n    for (int i = 0; i < int(s.length()); ++i) {\n        if (i % 2 == 0) {\n            // Should be lowercase letter\n            ensuref('a' <= s[i] && s[i] <= 'z', \"At position %d, expected a lowercase letter, but found '%c'\", i + 1, s[i]);\n        } else {\n            // Should be uppercase letter\n            ensuref('A' <= s[i] && s[i] <= 'Z', \"At position %d, expected an uppercase letter, but found '%c'\", i + 1, s[i]);\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(2 * n - 2, ' ');\n\n    if (type == \"random\") {\n\n        for (int i = 0; i < 2 * n - 2; ++i) {\n            if (i % 2 == 0) {\n                // Keys at odd positions (1-based indexing)\n                s[i] = 'a' + rnd.next(26);\n            } else {\n                // Doors at even positions\n                s[i] = 'A' + rnd.next(26);\n            }\n        }\n\n    } else if (type == \"all_can_pass\") {\n\n        vector<char> keys(n);\n        for (int i = 0; i < n; ++i) {\n            keys[i] = 'a' + rnd.next(26);\n        }\n\n        for (int i = 0; i < n - 1; ++i) {\n            // Door between room i and i+1\n            // Choose a key from keys[0..i] to ensure Vitaly has it\n            char door_key = toupper(keys[rnd.next(0, i)]);\n            // Build s\n            s[2 * i] = keys[i];       // Key in room i+1\n            s[2 * i + 1] = door_key;  // Door between room i+1 and room i+2\n        }\n\n        s[2 * n - 3] = keys[n - 1];  // Last key in room n\n\n    } else if (type == \"all_need_buy\") {\n\n        vector<char> keys(n);\n        // Generate keys\n        for (int i = 0; i < n; ++i) {\n            keys[i] = 'a' + rnd.next(26);\n        }\n\n        for (int i = 0; i < n - 1; ++i) {\n            // Door between room i and i+1\n            // Choose a key from keys[i + 1..n - 1] to ensure Vitaly doesn't have it yet\n            char door_key = toupper(keys[rnd.next(i + 1, n - 1)]);\n            // Build s\n            s[2 * i] = keys[i];        // Key in room i+1\n            s[2 * i + 1] = door_key;   // Door between room i+1 and room i+2\n        }\n\n        s[2 * n - 3] = keys[n - 1];    // Last key in room n\n\n    } else if (type == \"same_letter\") {\n\n        for (int i = 0; i < 2 * n - 2; ++i) {\n            if (i % 2 == 0) {\n                s[i] = 'a';  // All keys are 'a'\n            } else {\n                s[i] = 'A';  // All doors are 'A'\n            }\n        }\n\n    } else {\n        // Default is random\n        for (int i = 0; i < 2 * n - 2; ++i) {\n            if (i % 2 == 0) {\n                s[i] = 'a' + rnd.next(26);\n            } else {\n                s[i] = 'A' + rnd.next(26);\n            }\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output s\n    cout << s << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(2 * n - 2, ' ');\n\n    if (type == \"random\") {\n\n        for (int i = 0; i < 2 * n - 2; ++i) {\n            if (i % 2 == 0) {\n                // Keys at odd positions (1-based indexing)\n                s[i] = 'a' + rnd.next(26);\n            } else {\n                // Doors at even positions\n                s[i] = 'A' + rnd.next(26);\n            }\n        }\n\n    } else if (type == \"all_can_pass\") {\n\n        vector<char> keys(n);\n        for (int i = 0; i < n; ++i) {\n            keys[i] = 'a' + rnd.next(26);\n        }\n\n        for (int i = 0; i < n - 1; ++i) {\n            // Door between room i and i+1\n            // Choose a key from keys[0..i] to ensure Vitaly has it\n            char door_key = toupper(keys[rnd.next(0, i)]);\n            // Build s\n            s[2 * i] = keys[i];       // Key in room i+1\n            s[2 * i + 1] = door_key;  // Door between room i+1 and room i+2\n        }\n\n        s[2 * n - 3] = keys[n - 1];  // Last key in room n\n\n    } else if (type == \"all_need_buy\") {\n\n        vector<char> keys(n);\n        // Generate keys\n        for (int i = 0; i < n; ++i) {\n            keys[i] = 'a' + rnd.next(26);\n        }\n\n        for (int i = 0; i < n - 1; ++i) {\n            // Door between room i and i+1\n            // Choose a key from keys[i + 1..n - 1] to ensure Vitaly doesn't have it yet\n            char door_key = toupper(keys[rnd.next(i + 1, n - 1)]);\n            // Build s\n            s[2 * i] = keys[i];        // Key in room i+1\n            s[2 * i + 1] = door_key;   // Door between room i+1 and room i+2\n        }\n\n        s[2 * n - 3] = keys[n - 1];    // Last key in room n\n\n    } else if (type == \"same_letter\") {\n\n        for (int i = 0; i < 2 * n - 2; ++i) {\n            if (i % 2 == 0) {\n                s[i] = 'a';  // All keys are 'a'\n            } else {\n                s[i] = 'A';  // All doors are 'A'\n            }\n        }\n\n    } else {\n        // Default is random\n        for (int i = 0; i < 2 * n - 2; ++i) {\n            if (i % 2 == 0) {\n                s[i] = 'a' + rnd.next(26);\n            } else {\n                s[i] = 'A' + rnd.next(26);\n            }\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output s\n    cout << s << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -type random\n./gen -n 2 -type all_can_pass\n./gen -n 2 -type all_need_buy\n./gen -n 2 -type same_letter\n\n./gen -n 10 -type random\n./gen -n 10 -type all_can_pass\n./gen -n 10 -type all_need_buy\n./gen -n 10 -type same_letter\n\n./gen -n 100 -type random\n./gen -n 100 -type all_can_pass\n./gen -n 100 -type all_need_buy\n./gen -n 100 -type same_letter\n\n./gen -n 1000 -type random\n./gen -n 1000 -type all_can_pass\n./gen -n 1000 -type all_need_buy\n./gen -n 1000 -type same_letter\n\n./gen -n 10000 -type random\n./gen -n 10000 -type all_can_pass\n./gen -n 10000 -type all_need_buy\n./gen -n 10000 -type same_letter\n\n./gen -n 100000 -type random\n./gen -n 100000 -type all_can_pass\n./gen -n 100000 -type all_need_buy\n./gen -n 100000 -type same_letter\n\n# Edge cases\n./gen -n 99999 -type random\n./gen -n 100000 -type random\n./gen -n 100000 -type all_need_buy\n./gen -n 100000 -type all_can_pass\n\n# Different combinations\n./gen -n 50000 -type random\n./gen -n 50000 -type all_can_pass\n./gen -n 50000 -type all_need_buy\n./gen -n 50000 -type same_letter\n\n# Small n\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type same_letter\n\n# Cases with maximum letters\n./gen -n 26 -type same_letter\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:28.816034",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "525/B",
      "title": "B. Pasha and String",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains Pasha's string s of length from 2 to 2·105 characters, consisting of lowercase Latin letters.The second line contains a single integer m (1 ≤ m ≤ 105) —  the number of days when Pasha changed his string.The third line contains m space-separated elements ai (1 ≤ ai; 2·ai ≤ |s|) — the position from which Pasha started transforming the string on the i-th day.",
      "output_spec": "OutputIn the first line of the output print what Pasha's string s will look like after m days.",
      "sample_tests": "ExamplesInputCopyabcdef12OutputCopyaedcbfInputCopyvwxyz22 2OutputCopyvwxyzInputCopyabcdef31 2 3OutputCopyfbdcea",
      "description": "B. Pasha and String\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains Pasha's string s of length from 2 to 2·105 characters, consisting of lowercase Latin letters.The second line contains a single integer m (1 ≤ m ≤ 105) —  the number of days when Pasha changed his string.The third line contains m space-separated elements ai (1 ≤ ai; 2·ai ≤ |s|) — the position from which Pasha started transforming the string on the i-th day.\n\nOutputIn the first line of the output print what Pasha's string s will look like after m days.\n\nInputCopyabcdef12OutputCopyaedcbfInputCopyvwxyz22 2OutputCopyvwxyzInputCopyabcdef31 2 3OutputCopyfbdcea\n\nInputCopyabcdef12\n\nOutputCopyaedcbf\n\nInputCopyvwxyz22 2\n\nOutputCopyvwxyz\n\nInputCopyabcdef31 2 3\n\nOutputCopyfbdcea",
      "solutions": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #297 (Div. 2). It'll be held on Thursday, March 26 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my old friends Pavel Kholkin (HolkinPV), Ilya Los (IlyaLos), Vitaliy Kudasov (kuviman) and Arthur Svechnikov (ikar) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring is smooth dynamic (with steps of 250 points). More information about this can be found here. Tasks will be arranged in order of ascending supposed difficulty.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! cikofte fcspartakm_2 stealife GITLER228 alpq654321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces",
          "content": "525A — Vitaliy and PattyTo solve this problem we need to use array cnt[]. In this array we will store number of keys of every type, which we already found in rooms, but didn't use. Answer will store in variable ans. Now, we iterate on string. If current element of string si is lowercase letter (key), we make cnt[si]++. Else if current element of string si uppercase letter (door) and cnt[tolower(si)] > 0, we make cnt[tolower(si)]--, else we make ans++. It remains only to print ans. Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.525B — Pasha and StringAt first we need to understand next fact — it doesn't matter in wich order make reverses, answer will be the same for all orders. Let's numerate elements of string from one. To solve given problem we need to count how many reverses will begin in every position of string. Then we need to count array sum[]. In sum[i] we need to store count of reverses of substrings, which begin in positions which not exceeding i. Now iterate for i from 1 to n / 2 and if sum[i] is odd swap si and sn - i + 1. After that it remains only to print string s. Asymptotic behavior of this solution — O(n + m), where n — length of string s, m — count of reverses.525C — Ilya and SticksThis problem can be solved with help of greedy. At first count array cnt[]. In cnt[i] will store how many sticks with length i we have. Now iterate for len from maximal length of sticks to minimal. If cnt[len] is odd and we have sticks with length len - 1 (that is cnt[len - 1] > 0), make cnt[len]-- and cnt[len - 1]++. If cnt[len] is odd and we have no sticks with length len - 1 (that is cnt[len - 1] = 0), make cnt[len]--. In this way we properly done all sawing which we need and guaranteed that all cnt[len] is even. After that iterate similary on length of sticks and greedily merge pairs from 2 sticks with the same length in fours. It will be length of sides of sought-for rectangles, left only summarize their squares in answer. In the end can left 2 sticks without pair, we must not consider them in answer. For example, if cnt[5] = 6, cnt[4] = 4, cnt[2] = 4, we need to merge this sticks in following way — (5, 5, 5, 5), (5, 5, 4, 4), (4, 4, 2, 2). Two sticks with length 2 are left, we must not count them. Asymptotic behavior of this solution — O(n + maxlen - minlen), where n — count of sticks, maxlen — maximal length of stick, minlen — minimal length of stick.525D — Arthur and WallsTo solve this problem we need to observe next fact. If in some square whith size 2 × 2 in given matrix there is exactly one asterisk, we must change it on dot. That is if in matrix from dots and asterisks is not square 2 × 2 in which exactly one asterisk and three dots, then all maximum size of the area from dots connected by sides represent rectangles. Now solve the problem with help of bfs and this fact. Iterate on all asterisks in given matrix and if only this asterisk contains in some 2 × 2 square, change this asterisk on dot and put this position in queue. Than we need to write standart bfs, in which we will change asterisks on dots in all come out 2 × 2 squares with exactly one asterisk. Asymptotic behavior of this solution — O(n * m), where n and m sizes of given matrix.525E — Anya and CubesTo solve this problem we need to use meet-in-the-middle. At first sort given array in increasing order and divide it in two parts. In first part must be first n / 2 elements, in second part — other. Iterate all submasks of all masks of elements from first part. That is iterate which cubes from first part we take and on which from them we paste exclamation marks. In this way we iterated all possible sums, which we can get with cubes from first part. Let for current submask we get sum sum_lf and use tlf exclamation marks. To store all such sums we use associative arrays map < long long > cnt[k + 1], where k — count of exclamation marks which we have in the beginning. After that similary iterate all submasks of all masks of elements from second part. Let for current submask sum is sumrg and number of used exclamation marks is trg. Then from first part we need to get sum (s - sumrg) and we can use only (k - trg) exclamation marks, where s — sum which we must get by condition of the problem. Then iterate how many exclamation marks we will use in first part (let it be variable cur) and increase answer on cnt[cur][s - sumrg]. To accelerate our programm we may increase answer only if cnt[cur].count(s - sumrg) = true. For submasks in iterate we can cut off iteration on current sum for submask (it must be less or equal to given s) and on current count of exclamation marks (it must be less or equal to given k). Also we should not paste exclamation marks on cubecs with numbers larger than 18, because 19! more than 1016 — maximal value of s. Asymptotic behavior of this solution — O(3((n + 1) / 2) * log(maxcnt) * k), where n — count of cubes, maxcnt — maximal size of associative array, k — count of exclamation marks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 525\\s*B"
          },
          "content_length": 4990
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 1",
          "code": "aaaaa... 100000 1 1 1 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 2",
          "code": "Test: #12, time: 717 ms., memory: 4404 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 3",
          "code": "expected: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**', found: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 1",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 2",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 3",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 4",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 5",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 6",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 7",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 8",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 9",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 10",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 11",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 12",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 13",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    int L = s.length();\n    ensuref(2 <= L && L <= 200000, \"The length of s must be between 2 and 200000\");\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"The string s must consist of lowercase Latin letters\");\n    }\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(m, 1, L / 2, \"ai\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        ensuref(2 * ai[i] <= L, \"Each ai must satisfy 2 * ai <= |s|\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    int L = s.length();\n    ensuref(2 <= L && L <= 200000, \"The length of s must be between 2 and 200000\");\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"The string s must consist of lowercase Latin letters\");\n    }\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(m, 1, L / 2, \"ai\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        ensuref(2 * ai[i] <= L, \"Each ai must satisfy 2 * ai <= |s|\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine();\n    int L = s.length();\n    ensuref(2 <= L && L <= 200000, \"The length of s must be between 2 and 200000\");\n    for (char c : s) {\n        ensuref('a' <= c && c <= 'z', \"The string s must consist of lowercase Latin letters\");\n    }\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readEoln();\n    vector<int> ai = inf.readInts(m, 1, L / 2, \"ai\");\n    inf.readEoln();\n    for (int i = 0; i < m; ++i) {\n        ensuref(2 * ai[i] <= L, \"Each ai must satisfy 2 * ai <= |s|\");\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    int ai_value = opt<int>(\"ai_value\", -1);\n\n    if (n < 2 || n > 200000) {\n        fprintf(stderr, \"Error: n must satisfy 2 ≤ n ≤ 200000\\n\");\n        return 1;\n    }\n    if (m < 1 || m > 100000) {\n        fprintf(stderr, \"Error: m must satisfy 1 ≤ m ≤ 100000\\n\");\n        return 1;\n    }\n\n    // Generate string s according to s_type\n    string s;\n\n    if (s_type == \"random\") {\n        // Generate a random string of length n\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    } else if (s_type == \"same\") {\n        // All letters are the same\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (s_type == \"palindrome\") {\n        // Construct a palindrome\n        s.resize(n);\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(26);\n            s[i] = s[n - i - 1] = c;\n        }\n    } else if (s_type == \"alternating\") {\n        // Alternate between two letters\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        if (c2 == c1) c2 = 'a' + (c1 - 'a' + 1) % 26;\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? c1 : c2;\n    } else if (s_type == \"abcd\") {\n        // Repeating pattern of 'abcd'\n        string pattern = \"abcd\";\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = pattern[i % 4];\n    } else {\n        // Default to random\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    }\n\n    // Generate ai according to a_type\n    vector<int> a(m);\n    int max_ai = n / 2;\n    if (a_type == \"min\") {\n        // All ai = 1\n        fill(a.begin(), a.end(), 1);\n    } else if (a_type == \"max\") {\n        // All ai = floor(n / 2)\n        fill(a.begin(), a.end(), max_ai);\n    } else if (a_type == \"random\") {\n        // Random ai satisfying 1 ≤ ai; 2·ai ≤ n\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, max_ai);\n    } else if (a_type == \"increasing\") {\n        // ai increasing from minimal to maximal\n        if (m == 1) {\n            a[0] = 1;\n        } else {\n            for (int i = 0; i < m; ++i)\n                a[i] = 1 + (max_ai - 1) * i / (m - 1);\n        }\n    } else if (a_type == \"decreasing\") {\n        // ai decreasing from maximal to minimal\n        if (m == 1) {\n            a[0] = max_ai;\n        } else {\n            for (int i = 0; i < m; ++i)\n                a[i] = max_ai - (max_ai - 1) * i / (m - 1);\n        }\n    } else if (a_type == \"custom\") {\n        if (ai_value == -1 || ai_value < 1 || 2 * ai_value > n) {\n            fprintf(stderr, \"Error: ai_value must be specified and satisfy 1 ≤ ai and 2·ai ≤ n\\n\");\n            return 1;\n        }\n        fill(a.begin(), a.end(), ai_value);\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, max_ai);\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output ai\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", a[i], i == m -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string s_type = opt<string>(\"s_type\", \"random\");\n    string a_type = opt<string>(\"a_type\", \"random\");\n    int ai_value = opt<int>(\"ai_value\", -1);\n\n    if (n < 2 || n > 200000) {\n        fprintf(stderr, \"Error: n must satisfy 2 ≤ n ≤ 200000\\n\");\n        return 1;\n    }\n    if (m < 1 || m > 100000) {\n        fprintf(stderr, \"Error: m must satisfy 1 ≤ m ≤ 100000\\n\");\n        return 1;\n    }\n\n    // Generate string s according to s_type\n    string s;\n\n    if (s_type == \"random\") {\n        // Generate a random string of length n\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    } else if (s_type == \"same\") {\n        // All letters are the same\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (s_type == \"palindrome\") {\n        // Construct a palindrome\n        s.resize(n);\n        for (int i = 0; i < (n + 1) / 2; ++i) {\n            char c = 'a' + rnd.next(26);\n            s[i] = s[n - i - 1] = c;\n        }\n    } else if (s_type == \"alternating\") {\n        // Alternate between two letters\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        if (c2 == c1) c2 = 'a' + (c1 - 'a' + 1) % 26;\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = (i % 2 == 0) ? c1 : c2;\n    } else if (s_type == \"abcd\") {\n        // Repeating pattern of 'abcd'\n        string pattern = \"abcd\";\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = pattern[i % 4];\n    } else {\n        // Default to random\n        s.resize(n);\n        for (int i = 0; i < n; ++i)\n            s[i] = 'a' + rnd.next(26);\n    }\n\n    // Generate ai according to a_type\n    vector<int> a(m);\n    int max_ai = n / 2;\n    if (a_type == \"min\") {\n        // All ai = 1\n        fill(a.begin(), a.end(), 1);\n    } else if (a_type == \"max\") {\n        // All ai = floor(n / 2)\n        fill(a.begin(), a.end(), max_ai);\n    } else if (a_type == \"random\") {\n        // Random ai satisfying 1 ≤ ai; 2·ai ≤ n\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, max_ai);\n    } else if (a_type == \"increasing\") {\n        // ai increasing from minimal to maximal\n        if (m == 1) {\n            a[0] = 1;\n        } else {\n            for (int i = 0; i < m; ++i)\n                a[i] = 1 + (max_ai - 1) * i / (m - 1);\n        }\n    } else if (a_type == \"decreasing\") {\n        // ai decreasing from maximal to minimal\n        if (m == 1) {\n            a[0] = max_ai;\n        } else {\n            for (int i = 0; i < m; ++i)\n                a[i] = max_ai - (max_ai - 1) * i / (m - 1);\n        }\n    } else if (a_type == \"custom\") {\n        if (ai_value == -1 || ai_value < 1 || 2 * ai_value > n) {\n            fprintf(stderr, \"Error: ai_value must be specified and satisfy 1 ≤ ai and 2·ai ≤ n\\n\");\n            return 1;\n        }\n        fill(a.begin(), a.end(), ai_value);\n    } else {\n        // Default to random\n        for (int i = 0; i < m; ++i)\n            a[i] = rnd.next(1, max_ai);\n    }\n\n    // Output s\n    printf(\"%s\\n\", s.c_str());\n    // Output m\n    printf(\"%d\\n\", m);\n    // Output ai\n    for (int i = 0; i < m; ++i) {\n        printf(\"%d%c\", a[i], i == m -1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small test cases\n./gen -n 2 -m 1 -s_type random -a_type random\n./gen -n 2 -m 1 -s_type same -a_type min\n./gen -n 2 -m 1 -s_type palindrome -a_type max\n\n# Medium test cases\n./gen -n 10 -m 5 -s_type random -a_type random\n./gen -n 10 -m 5 -s_type alternating -a_type increasing\n./gen -n 10 -m 5 -s_type same -a_type decreasing\n\n# Larger test cases\n./gen -n 1000 -m 500 -s_type random -a_type random\n./gen -n 1000 -m 1000 -s_type alternating -a_type max\n./gen -n 1000 -m 1000 -s_type palindrome -a_type min\n\n# Edge cases with maximum sizes\n./gen -n 200000 -m 100000 -s_type random -a_type random\n./gen -n 200000 -m 100000 -s_type same -a_type max\n./gen -n 200000 -m 100000 -s_type palindrome -a_type min\n./gen -n 200000 -m 100000 -s_type alternating -a_type increasing\n\n# Edge cases with minimum sizes\n./gen -n 2 -m 1 -s_type random -a_type max\n./gen -n 200000 -m 1 -s_type random -a_type min\n./gen -n 2 -m 100000 -s_type random -a_type min\n\n# Maximize ai (all ai are maximum possible)\n./gen -n 200000 -m 100000 -s_type random -a_type max\n\n# Minimize ai (all ai are minimum possible)\n./gen -n 200000 -m 100000 -s_type random -a_type min\n\n# Random ai\n./gen -n 200000 -m 100000 -s_type random -a_type random\n\n# Increasing ai from 1 to n/2\n./gen -n 200000 -m 100000 -s_type random -a_type increasing\n\n# Decreasing ai from n/2 to 1\n./gen -n 200000 -m 100000 -s_type random -a_type decreasing\n\n# s consists of alternating characters\n./gen -n 200000 -m 100000 -s_type alternating -a_type random\n\n# s consists of a repeating pattern\n./gen -n 200000 -m 100000 -s_type abcd -a_type random\n\n# s is a palindrome\n./gen -n 200000 -m 100000 -s_type palindrome -a_type random\n\n# s is all the same character\n./gen -n 200000 -m 100000 -s_type same -a_type random\n\n# Custom ai value at minimum\n./gen -n 200000 -m 100000 -s_type random -a_type custom -ai_value 1\n\n# Custom ai value at maximum\n./gen -n 200000 -m 100000 -s_type random -a_type custom -ai_value 100000\n\n# Custom ai value in the middle\n./gen -n 200000 -m 100000 -s_type random -a_type custom -ai_value 50000\n\n# Max n and min m\n./gen -n 200000 -m 1 -s_type random -a_type random\n\n# Min n and max m\n./gen -n 2 -m 100000 -s_type random -a_type random\n\n# Maximize both n and m, s is random, ai are random\n./gen -n 200000 -m 100000 -s_type random -a_type random\n\n# Maximize both n and m, s is random, ai are max\n./gen -n 200000 -m 100000 -s_type random -a_type max\n\n# Maximize both n and m, s is random, ai are min\n./gen -n 200000 -m 100000 -s_type random -a_type min\n\n# All ai are the same and equal to half of n divided by 2\n./gen -n 200000 -m 100000 -s_type random -a_type custom -ai_value 100000\n\n# All ai are 1, s is palindrome\n./gen -n 200000 -m 100000 -s_type palindrome -a_type min\n\n# All ai are n/4, s is repeating pattern\n./gen -n 200000 -m 100000 -s_type abcd -a_type custom -ai_value 50000\n\n# Random s, random ai, m is maximum, n is maximum\n./gen -n 200000 -m 100000 -s_type random -a_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:31.135565",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "525/C",
      "title": "C. Ilya and Sticks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains a positive integer n (1 ≤ n ≤ 105) — the number of the available sticks.The second line of the input contains n positive integers li (2 ≤ li ≤ 106) — the lengths of the sticks.",
      "output_spec": "OutputThe first line of the output must contain a single non-negative integer — the maximum total area of the rectangles that Ilya can make from the available sticks.",
      "sample_tests": "ExamplesInputCopy42 4 4 2OutputCopy8InputCopy42 2 3 5OutputCopy0InputCopy4100003 100004 100005 100006OutputCopy10000800015",
      "description": "C. Ilya and Sticks\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains a positive integer n (1 ≤ n ≤ 105) — the number of the available sticks.The second line of the input contains n positive integers li (2 ≤ li ≤ 106) — the lengths of the sticks.\n\nOutputThe first line of the output must contain a single non-negative integer — the maximum total area of the rectangles that Ilya can make from the available sticks.\n\nInputCopy42 4 4 2OutputCopy8InputCopy42 2 3 5OutputCopy0InputCopy4100003 100004 100005 100006OutputCopy10000800015\n\nInputCopy42 4 4 2\n\nOutputCopy8\n\nInputCopy42 2 3 5\n\nOutputCopy0\n\nInputCopy4100003 100004 100005 100006\n\nOutputCopy10000800015",
      "solutions": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #297 (Div. 2). It'll be held on Thursday, March 26 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my old friends Pavel Kholkin (HolkinPV), Ilya Los (IlyaLos), Vitaliy Kudasov (kuviman) and Arthur Svechnikov (ikar) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring is smooth dynamic (with steps of 250 points). More information about this can be found here. Tasks will be arranged in order of ascending supposed difficulty.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! cikofte fcspartakm_2 stealife GITLER228 alpq654321",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces",
          "content": "525A — Vitaliy and PattyTo solve this problem we need to use array cnt[]. In this array we will store number of keys of every type, which we already found in rooms, but didn't use. Answer will store in variable ans. Now, we iterate on string. If current element of string si is lowercase letter (key), we make cnt[si]++. Else if current element of string si uppercase letter (door) and cnt[tolower(si)] > 0, we make cnt[tolower(si)]--, else we make ans++. It remains only to print ans. Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.525B — Pasha and StringAt first we need to understand next fact — it doesn't matter in wich order make reverses, answer will be the same for all orders. Let's numerate elements of string from one. To solve given problem we need to count how many reverses will begin in every position of string. Then we need to count array sum[]. In sum[i] we need to store count of reverses of substrings, which begin in positions which not exceeding i. Now iterate for i from 1 to n / 2 and if sum[i] is odd swap si and sn - i + 1. After that it remains only to print string s. Asymptotic behavior of this solution — O(n + m), where n — length of string s, m — count of reverses.525C — Ilya and SticksThis problem can be solved with help of greedy. At first count array cnt[]. In cnt[i] will store how many sticks with length i we have. Now iterate for len from maximal length of sticks to minimal. If cnt[len] is odd and we have sticks with length len - 1 (that is cnt[len - 1] > 0), make cnt[len]-- and cnt[len - 1]++. If cnt[len] is odd and we have no sticks with length len - 1 (that is cnt[len - 1] = 0), make cnt[len]--. In this way we properly done all sawing which we need and guaranteed that all cnt[len] is even. After that iterate similary on length of sticks and greedily merge pairs from 2 sticks with the same length in fours. It will be length of sides of sought-for rectangles, left only summarize their squares in answer. In the end can left 2 sticks without pair, we must not consider them in answer. For example, if cnt[5] = 6, cnt[4] = 4, cnt[2] = 4, we need to merge this sticks in following way — (5, 5, 5, 5), (5, 5, 4, 4), (4, 4, 2, 2). Two sticks with length 2 are left, we must not count them. Asymptotic behavior of this solution — O(n + maxlen - minlen), where n — count of sticks, maxlen — maximal length of stick, minlen — minimal length of stick.525D — Arthur and WallsTo solve this problem we need to observe next fact. If in some square whith size 2 × 2 in given matrix there is exactly one asterisk, we must change it on dot. That is if in matrix from dots and asterisks is not square 2 × 2 in which exactly one asterisk and three dots, then all maximum size of the area from dots connected by sides represent rectangles. Now solve the problem with help of bfs and this fact. Iterate on all asterisks in given matrix and if only this asterisk contains in some 2 × 2 square, change this asterisk on dot and put this position in queue. Than we need to write standart bfs, in which we will change asterisks on dots in all come out 2 × 2 squares with exactly one asterisk. Asymptotic behavior of this solution — O(n * m), where n and m sizes of given matrix.525E — Anya and CubesTo solve this problem we need to use meet-in-the-middle. At first sort given array in increasing order and divide it in two parts. In first part must be first n / 2 elements, in second part — other. Iterate all submasks of all masks of elements from first part. That is iterate which cubes from first part we take and on which from them we paste exclamation marks. In this way we iterated all possible sums, which we can get with cubes from first part. Let for current submask we get sum sum_lf and use tlf exclamation marks. To store all such sums we use associative arrays map < long long > cnt[k + 1], where k — count of exclamation marks which we have in the beginning. After that similary iterate all submasks of all masks of elements from second part. Let for current submask sum is sumrg and number of used exclamation marks is trg. Then from first part we need to get sum (s - sumrg) and we can use only (k - trg) exclamation marks, where s — sum which we must get by condition of the problem. Then iterate how many exclamation marks we will use in first part (let it be variable cur) and increase answer on cnt[cur][s - sumrg]. To accelerate our programm we may increase answer only if cnt[cur].count(s - sumrg) = true. For submasks in iterate we can cut off iteration on current sum for submask (it must be less or equal to given s) and on current count of exclamation marks (it must be less or equal to given k). Also we should not paste exclamation marks on cubecs with numbers larger than 18, because 19! more than 1016 — maximal value of s. Asymptotic behavior of this solution — O(3((n + 1) / 2) * log(maxcnt) * k), where n — count of cubes, maxcnt — maximal size of associative array, k — count of exclamation marks.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 525\\s*C"
          },
          "content_length": 4990
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 1",
          "code": "aaaaa... 100000 1 1 1 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 2",
          "code": "Test: #12, time: 717 ms., memory: 4404 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 3",
          "code": "expected: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**', found: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 1",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 2",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 3",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 4",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 5",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 6",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 7",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 8",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 9",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 10",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 11",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 12",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 13",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 2, 1000000, \"li\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 2, 1000000, \"li\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    vector<int> li = inf.readInts(n, 2, 1000000, \"li\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> sticks(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = rnd.next(2, 1000000);\n        }\n    } else if (type == \"same\") {\n        int len = opt<int>(\"len\", 1000000);\n        len = min(max(len, 2), 1000000);\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = len;\n        }\n    } else if (type == \"unique\") {\n        set<int> lengths;\n        while ((int)lengths.size() < n) {\n            int len = rnd.next(2, 1000000);\n            lengths.insert(len);\n        }\n        int idx = 0;\n        for (int len : lengths) {\n            sticks[idx++] = len;\n        }\n        shuffle(sticks.begin(), sticks.end());\n    } else if (type == \"needs_reduction\") {\n        int max_k = n / 4;\n        int k = opt<int>(\"k\", max_k);\n        k = min(k, max_k);\n        vector<int> lengths;\n        for (int i = 0; i < k; ++i) {\n            int L = rnd.next(2, 999999); // So that L+1 ≤ 1e6\n            lengths.push_back(L);\n            lengths.push_back(L);\n            lengths.push_back(L+1);\n            lengths.push_back(L+1);\n        }\n        while ((int)lengths.size() < n) {\n            lengths.push_back(rnd.next(2, 1000000));\n        }\n        shuffle(lengths.begin(), lengths.end());\n        sticks = lengths;\n    } else if (type == \"no_rectangles\") {\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = min(2 + i, 1000000);\n        }\n    } else if (type == \"maximal_area\") {\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = 1000000;\n        }\n    } else if (type == \"minimal_case\") {\n        n = min(n, 4);\n        sticks.resize(n);\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = rnd.next(2, 10);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = rnd.next(2, 1000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output sticks\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", sticks[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> sticks(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = rnd.next(2, 1000000);\n        }\n    } else if (type == \"same\") {\n        int len = opt<int>(\"len\", 1000000);\n        len = min(max(len, 2), 1000000);\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = len;\n        }\n    } else if (type == \"unique\") {\n        set<int> lengths;\n        while ((int)lengths.size() < n) {\n            int len = rnd.next(2, 1000000);\n            lengths.insert(len);\n        }\n        int idx = 0;\n        for (int len : lengths) {\n            sticks[idx++] = len;\n        }\n        shuffle(sticks.begin(), sticks.end());\n    } else if (type == \"needs_reduction\") {\n        int max_k = n / 4;\n        int k = opt<int>(\"k\", max_k);\n        k = min(k, max_k);\n        vector<int> lengths;\n        for (int i = 0; i < k; ++i) {\n            int L = rnd.next(2, 999999); // So that L+1 ≤ 1e6\n            lengths.push_back(L);\n            lengths.push_back(L);\n            lengths.push_back(L+1);\n            lengths.push_back(L+1);\n        }\n        while ((int)lengths.size() < n) {\n            lengths.push_back(rnd.next(2, 1000000));\n        }\n        shuffle(lengths.begin(), lengths.end());\n        sticks = lengths;\n    } else if (type == \"no_rectangles\") {\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = min(2 + i, 1000000);\n        }\n    } else if (type == \"maximal_area\") {\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = 1000000;\n        }\n    } else if (type == \"minimal_case\") {\n        n = min(n, 4);\n        sticks.resize(n);\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = rnd.next(2, 10);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            sticks[i] = rnd.next(2, 1000000);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output sticks\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", sticks[i]);\n        if (i + 1 < n)\n            printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type minimal_case\n./gen -n 2 -type minimal_case\n./gen -n 3 -type minimal_case\n./gen -n 4 -type minimal_case\n\n./gen -n 5 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n\n./gen -n 4 -type same -len 2\n./gen -n 4 -type same -len 1000000\n./gen -n 100000 -type same -len 1000000\n\n./gen -n 5 -type unique\n./gen -n 100 -type unique\n./gen -n 100000 -type unique\n\n./gen -n 20 -type needs_reduction\n./gen -n 100000 -type needs_reduction\n./gen -n 100000 -type needs_reduction -k 25000\n./gen -n 100000 -type needs_reduction -k 10000\n\n./gen -n 100000 -type maximal_area\n./gen -n 10000 -type maximal_area\n\n./gen -n 100 -type no_rectangles\n./gen -n 100000 -type no_rectangles\n\n./gen -n 4 -type same -len 999999\n./gen -n 1 -type random\n./gen -n 3 -type random\n\n./gen -n 7 -type needs_reduction -k 1\n./gen -n 100000 -type needs_reduction -k 0\n./gen -n 99999 -type random\n\n./gen -n 100000 -type same -len 2\n./gen -n 100000 -type same -len 1000000\n./gen -n 100000 -type no_rectangles\n./gen -n 100000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:33.367358",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "525/D",
      "title": "D. Arthur and Walls",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test512 megabytes",
      "input_spec": "InputThe first line of the input contains two integers n, m (1 ≤ n, m ≤ 2000) denoting the size of the Arthur apartments.Following n lines each contain m symbols — the plan of the apartment.If the cell is denoted by a symbol \"*\" then it contains a wall.If the cell is denoted by a symbol \".\" then it this cell is free from walls and also this cell is contained in some of the rooms.",
      "output_spec": "OutputOutput n rows each consisting of m symbols that show how the Arthur apartment plan should look like after deleting the minimum number of walls in order to make each room (maximum connected area free from walls) be a rectangle. If there are several possible answers, output any of them.",
      "sample_tests": "ExamplesInputCopy5 5.*.*.*****.*.*.*****.*.*.OutputCopy.*.*.*****.*.*.*****.*.*.InputCopy6 7***.*.*..*.*.**.*.*.**.*.*.*..*...********OutputCopy***...*..*...*..*...*..*...*..*...********InputCopy4 5............***..*..OutputCopy....................",
      "description": "D. Arthur and Walls\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test512 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers n, m (1 ≤ n, m ≤ 2000) denoting the size of the Arthur apartments.Following n lines each contain m symbols — the plan of the apartment.If the cell is denoted by a symbol \"*\" then it contains a wall.If the cell is denoted by a symbol \".\" then it this cell is free from walls and also this cell is contained in some of the rooms.\n\nOutputOutput n rows each consisting of m symbols that show how the Arthur apartment plan should look like after deleting the minimum number of walls in order to make each room (maximum connected area free from walls) be a rectangle. If there are several possible answers, output any of them.\n\nInputCopy5 5.*.*.*****.*.*.*****.*.*.OutputCopy.*.*.*****.*.*.*****.*.*.InputCopy6 7***.*.*..*.*.**.*.*.**.*.*.*..*...********OutputCopy***...*..*...*..*...*..*...*..*...********InputCopy4 5............***..*..OutputCopy....................\n\nInputCopy5 5.*.*.*****.*.*.*****.*.*.\n\nOutputCopy.*.*.*****.*.*.*****.*.*.\n\nInputCopy6 7***.*.*..*.*.**.*.*.**.*.*.*..*...********\n\nOutputCopy***...*..*...*..*...*..*...*..*...********\n\nInputCopy4 5............***..*..\n\nOutputCopy....................",
      "solutions": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #297 (Div. 2). It'll be held on Thursday, March 26 at 19:30 MSK and as usual Div. 1 participants can join out of competition.Great thanks to Maxim Akhmedov (Zlobober) for helping me preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Polygon platform and ideas of some problems and to my old friends Pavel Kholkin (HolkinPV), Ilya Los (IlyaLos), Vitaliy Kudasov (kuviman) and Arthur Svechnikov (ikar) for writing solutions.The scoring distribution will be announced later. Good luck everyone!UPD The scoring is smooth dynamic (with steps of 250 points). More information about this can be found here. Tasks will be arranged in order of ascending supposed difficulty.UPD2 Competition completed! Thank you all!UPD3 You can find editorial here.UPD4 Congratulations to the winners! cikofte fcspartakm_2 stealife GITLER228 alpq654321",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17113",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 981
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces",
          "content": "525A — Vitaliy and PattyTo solve this problem we need to use array cnt[]. In this array we will store number of keys of every type, which we already found in rooms, but didn't use. Answer will store in variable ans. Now, we iterate on string. If current element of string si is lowercase letter (key), we make cnt[si]++. Else if current element of string si uppercase letter (door) and cnt[tolower(si)] > 0, we make cnt[tolower(si)]--, else we make ans++. It remains only to print ans. Asymptotic behavior of this solution — O(|s|), where |s| — length of string s.525B — Pasha and StringAt first we need to understand next fact — it doesn't matter in wich order make reverses, answer will be the same for all orders. Let's numerate elements of string from one. To solve given problem we need to count how many reverses will begin in every position of string. Then we need to count array sum[]. In sum[i] we need to store count of reverses of substrings, which begin in positions which not exceeding i. Now iterate for i from 1 to n / 2 and if sum[i] is odd swap si and sn - i + 1. After that it remains only to print string s. Asymptotic behavior of this solution — O(n + m), where n — length of string s, m — count of reverses.525C — Ilya and SticksThis problem can be solved with help of greedy. At first count array cnt[]. In cnt[i] will store how many sticks with length i we have. Now iterate for len from maximal length of sticks to minimal. If cnt[len] is odd and we have sticks with length len - 1 (that is cnt[len - 1] > 0), make cnt[len]-- and cnt[len - 1]++. If cnt[len] is odd and we have no sticks with length len - 1 (that is cnt[len - 1] = 0), make cnt[len]--. In this way we properly done all sawing which we need and guaranteed that all cnt[len] is even. After that iterate similary on length of sticks and greedily merge pairs from 2 sticks with the same length in fours. It will be length of sides of sought-for rectangles, left only summarize their squares in answer. In the end can left 2 sticks without pair, we must not consider them in answer. For example, if cnt[5] = 6, cnt[4] = 4, cnt[2] = 4, we need to merge this sticks in following way — (5, 5, 5, 5), (5, 5, 4, 4), (4, 4, 2, 2). Two sticks with length 2 are left, we must not count them. Asymptotic behavior of this solution — O(n + maxlen - minlen), where n — count of sticks, maxlen — maximal length of stick, minlen — minimal length of stick.525D — Arthur and WallsTo solve this problem we need to observe next fact. If in some square whith size 2 × 2 in given matrix there is exactly one asterisk, we must change it on dot. That is if in matrix from dots and asterisks is not square 2 × 2 in which exactly one asterisk and three dots, then all maximum size of the area from dots connected by sides represent rectangles. Now solve the problem with help of bfs and this fact. Iterate on all asterisks in given matrix and if only this asterisk contains in some 2 × 2 square, change this asterisk on dot and put this position in queue. Than we need to write standart bfs, in which we will change asterisks on dots in all come out 2 × 2 squares with exactly one asterisk. Asymptotic behavior of this solution — O(n * m), where n and m sizes of given matrix.525E — Anya and CubesTo solve this problem we need to use meet-in-the-middle. At first sort given array in increasing order and divide it in two parts. In first part must be first n / 2 elements, in second part — other. Iterate all submasks of all masks of elements from first part. That is iterate which cubes from first part we take and on which from them we paste exclamation marks. In this way we iterated all possible sums, which we can get with cubes from first part. Let for current submask we get sum sum_lf and use tlf exclamation marks. To store all such sums we use associative arrays map < long long > cnt[k + 1], where k — count of exclamation marks which we have in the beginning. After that similary iterate all submasks of all masks of elements from second part. Let for current submask sum is sumrg and number of used exclamation marks is trg. Then from first part we need to get sum (s - sumrg) and we can use only (k - trg) exclamation marks, where s — sum which we must get by condition of the problem. Then iterate how many exclamation marks we will use in first part (let it be variable cur) and increase answer on cnt[cur][s - sumrg]. To accelerate our programm we may increase answer only if cnt[cur].count(s - sumrg) = true. For submasks in iterate we can cut off iteration on current sum for submask (it must be less or equal to given s) and on current count of exclamation marks (it must be less or equal to given k). Also we should not paste exclamation marks on cubecs with numbers larger than 18, because 19! more than 1016 — maximal value of s. Asymptotic behavior of this solution — O(3((n + 1) / 2) * log(maxcnt) * k), where n — count of cubes, maxcnt — maximal size of associative array, k — count of exclamation marks.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17119",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 525\\s*D"
          },
          "content_length": 4990
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 1",
          "code": "aaaaa... 100000 1 1 1 ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 2",
          "code": "Test: #12, time: 717 ms., memory: 4404 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div. 2) - Codeforces - Code 3",
          "code": "expected: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**', found: '***..*......*...****.*****.*.....**.*******.******.*..***.***.**'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17113",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 1",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 2",
          "code": "8\n5 3 3 3 3 4 4 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 3",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 4",
          "code": "*********\n*1*******\n*1*******\n*1***3***\n*111*****\n*1*******\n*1*22222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 5",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 6",
          "code": "*********\n*1112222*\n*1*1***2*\n*1*1*3*2*\n*111***2*\n*1*1***2*\n*1122222*\n*********",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 7",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 8",
          "code": "3 3\n*..\n...\n..*",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 9",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 10",
          "code": "*..\n...\n...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 11",
          "code": "unordered_map",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 12",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #297 (Div.2) Editorial - Codeforces - Code 13",
          "code": "6\n7 7 6 6 6 4",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17119",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d, but has length %d\", i + 1, m, (int)s.length());\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at position %d in line %d\", s[j], j + 1, i + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d, but has length %d\", i + 1, m, (int)s.length());\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at position %d in line %d\", s[j], j + 1, i + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 2000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 2000, \"m\");\n    inf.readEoln();\n    for (int i = 0; i < n; i++) {\n        string s = inf.readLine();\n        ensuref((int)s.length() == m, \"Line %d must have length %d, but has length %d\", i + 1, m, (int)s.length());\n        for (int j = 0; j < m; j++) {\n            ensuref(s[j] == '.' || s[j] == '*', \"Invalid character '%c' at position %d in line %d\", s[j], j + 1, i + 1);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nvector<string> initialPlan;\nvector<string> contestantPlan;\nvector<string> judgePlan;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    n = inf.readInt(1, 2000, \"n\");\n    m = inf.readInt(1, 2000, \"m\");\n\n    initialPlan.resize(n);\n    for (int i = 0; i < n; i++) {\n        initialPlan[i] = inf.readToken(\"[.*]{\"+to_string(m)+\"}\", format(\"initialPlan[%d]\", i+1).c_str());\n    }\n\n    // Read contestant's plan\n    contestantPlan.resize(n);\n    for (int i = 0; i < n; i++) {\n        contestantPlan[i] = ouf.readToken(\"[.*]{\"+to_string(m)+\"}\", format(\"contestantPlan[%d]\", i+1).c_str());\n    }\n\n    // Read judge's plan\n    judgePlan.resize(n);\n    for (int i = 0; i < n; i++) {\n        judgePlan[i] = ans.readToken(\"[.*]{\"+to_string(m)+\"}\", format(\"judgePlan[%d]\", i+1).c_str());\n    }\n\n    // Verify that contestant's plan has correct dimensions\n    if ((int)contestantPlan.size() != n)\n        quitf(_wa, \"Contestant's plan has wrong number of rows: expected %d, found %d\", n, (int)contestantPlan.size());\n\n    for (int i = 0; i < n; i++) {\n        if ((int)contestantPlan[i].size() != m)\n            quitf(_wa, \"Contestant's plan, row %d has wrong length: expected %d, found %d\", i+1, m, (int)contestantPlan[i].size());\n    }\n\n    // Verify that contestant's plan only contains '.' or '*'\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            char c = contestantPlan[i][j];\n            if (c != '.' && c != '*') {\n                quitf(_wa, \"Contestant's plan has invalid character '%c' at position (%d, %d)\", c, i+1, j+1);\n            }\n        }\n    }\n\n    // Verify that contestant's plan only changes walls '*' to '.' and not '.' to '*'\n    int contestantWallsRemoved = 0;\n    int initialWalls = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            char initial_c = initialPlan[i][j];\n            char contestant_c = contestantPlan[i][j];\n\n            if (initial_c == '*') {\n                initialWalls++;\n                if (contestant_c == '.')\n                    contestantWallsRemoved++;\n                else if (contestant_c != '*')\n                    quitf(_wa, \"Contestant's plan changed wall at (%d, %d) to invalid character '%c'\", i+1, j+1, contestant_c);\n            } else if (initial_c == '.') {\n                if (contestant_c != '.') {\n                    quitf(_wa, \"Contestant's plan changed free space at (%d, %d) to '%c'\", i+1, j+1, contestant_c);\n                }\n            } else {\n                quitf(_fail, \"Invalid character '%c' in initial plan at position (%d,%d)\", initial_c, i+1, j+1);\n            }\n        }\n    }\n\n    // Compute number of walls removed in judge's plan\n    int judgeWallsRemoved = 0;\n\n    for (int i = 0; i < n; i++) {\n        if ((int)judgePlan[i].size() != m) {\n            quitf(_fail, \"Judge's plan, row %d has wrong length: expected %d, found %d\", i+1, m, (int)judgePlan[i].size());\n        }\n        for (int j = 0; j < m; j++) {\n            char initial_c = initialPlan[i][j];\n            char judge_c = judgePlan[i][j];\n\n            if (initial_c == '*') {\n                if (judge_c == '.') {\n                    judgeWallsRemoved++;\n                } else if (judge_c != '*') {\n                    quitf(_fail, \"Judge's plan changed wall at (%d, %d) to invalid character '%c'\", i+1, j+1, judge_c);\n                }\n            } else if (initial_c == '.') {\n                if (judge_c != '.') {\n                    quitf(_fail, \"Judge's plan changed free space at (%d, %d) to '%c'\", judge_c, i+1, j+1);\n                }\n            } else {\n                quitf(_fail, \"Invalid character '%c' in initial plan at position (%d,%d)\", initial_c, i+1, j+1);\n            }\n        }\n    }\n\n    // Compare the number of walls removed\n    if (contestantWallsRemoved > judgeWallsRemoved) {\n        quitf(_wa, \"Contestant removed more walls than necessary: contestant removed %d walls, judge removed %d walls\", contestantWallsRemoved, judgeWallsRemoved);\n    } else if (contestantWallsRemoved < judgeWallsRemoved) {\n        quitf(_fail, \"Contestant removed fewer walls than required: contestant removed %d walls, judge removed %d walls\", contestantWallsRemoved, judgeWallsRemoved);\n    }\n\n    // Check that in contestant's plan, all rooms are rectangles\n    vector<vector<bool>> visited(n, vector<bool>(m, false));\n    int numRooms = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (!visited[i][j] && contestantPlan[i][j] == '.') {\n                numRooms++;\n                queue<pair<int, int>> q;\n                vector<pair<int, int>> roomCells;\n                int min_row = i, max_row = i;\n                int min_col = j, max_col = j;\n\n                q.push({i, j});\n                visited[i][j] = true;\n                roomCells.push_back({i, j});\n\n                while (!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n\n                    min_row = min(min_row, x);\n                    max_row = max(max_row, x);\n                    min_col = min(min_col, y);\n                    max_col = max(max_col, y);\n\n                    int dx[] = {-1, 1, 0, 0};\n                    int dy[] = {0, 0, -1, 1};\n\n                    for (int dir = 0; dir < 4; dir++) {\n                        int nx = x + dx[dir];\n                        int ny = y + dy[dir];\n\n                        if (nx >= 0 && nx < n && ny >= 0 && ny < m) {\n                            if (!visited[nx][ny] && contestantPlan[nx][ny] == '.') {\n                                visited[nx][ny] = true;\n                                q.push({nx, ny});\n                                roomCells.push_back({nx, ny});\n                            }\n                        }\n                    }\n                }\n\n                int area = (max_row - min_row + 1) * (max_col - min_col + 1);\n                if (area != (int)roomCells.size()) {\n                    quitf(_wa, \"Room %d is not a rectangle\", numRooms);\n                }\n\n                for (int x = min_row; x <= max_row; x++) {\n                    for (int y = min_col; y <= max_col; y++) {\n                        if (contestantPlan[x][y] != '.') {\n                            quitf(_wa, \"Room %d is not a rectangle\", numRooms);\n                        }\n                        visited[x][y] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // All checks passed\n    quitf(_ok, \"Correct plan with %d walls removed\", contestantWallsRemoved);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int p = opt<int>(\"p\", 50); // percentage probability of free cells (used for \"random\" type)\n\n    vector<string> grid(n, string(m, '*')); // Initialize grid with walls\n\n    if (type == \"empty\") {\n        // All cells are walls (do nothing)\n    } else if (type == \"full\") {\n        // All cells are free spaces\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '.');\n        }\n    } else if (type == \"random\") {\n        // Randomly assign free spaces and walls based on probability p\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(100) < p)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        // Alternate cells between free space and walls\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    } else if (type == \"one-room\") {\n        // Create a non-rectangular connected area (e.g., an L-shaped room)\n        // All cells are walls except for the first row and column\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = '.';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '.';\n        }\n    } else if (type == \"max-rooms\") {\n        // Each free cell is isolated by walls\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if (i % 2 == 0 && j % 2 == 0)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    } else {\n        // Default to random if an unknown type is provided\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(100) < p)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int p = opt<int>(\"p\", 50); // percentage probability of free cells (used for \"random\" type)\n\n    vector<string> grid(n, string(m, '*')); // Initialize grid with walls\n\n    if (type == \"empty\") {\n        // All cells are walls (do nothing)\n    } else if (type == \"full\") {\n        // All cells are free spaces\n        for (int i = 0; i < n; ++i) {\n            grid[i] = string(m, '.');\n        }\n    } else if (type == \"random\") {\n        // Randomly assign free spaces and walls based on probability p\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(100) < p)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    } else if (type == \"checkerboard\") {\n        // Alternate cells between free space and walls\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if ((i + j) % 2 == 0)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    } else if (type == \"one-room\") {\n        // Create a non-rectangular connected area (e.g., an L-shaped room)\n        // All cells are walls except for the first row and column\n        for (int i = 0; i < n; ++i) {\n            grid[i][0] = '.';\n        }\n        for (int j = 0; j < m; ++j) {\n            grid[0][j] = '.';\n        }\n    } else if (type == \"max-rooms\") {\n        // Each free cell is isolated by walls\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if (i % 2 == 0 && j % 2 == 0)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    } else {\n        // Default to random if an unknown type is provided\n        for (int i = 0; i < n; ++i) {\n            grid[i] = \"\";\n            for (int j = 0; j < m; ++j) {\n                if (rnd.next(100) < p)\n                    grid[i] += '.';\n                else\n                    grid[i] += '*';\n            }\n        }\n    }\n\n    // Output the grid\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", grid[i].c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum size grids\n./gen -n 1 -m 1 -type full\n./gen -n 1 -m 1 -type empty\n./gen -n 1 -m 1 -type random -p 100\n\n# Small grids with different patterns\n./gen -n 5 -m 5 -type checkerboard\n./gen -n 5 -m 5 -type one-room\n./gen -n 5 -m 5 -type max-rooms\n./gen -n 5 -m 5 -type random -p 70\n\n# Medium grids with varying probabilities of free cells\n./gen -n 10 -m 10 -type random -p 50\n./gen -n 10 -m 10 -type random -p 20\n./gen -n 10 -m 10 -type random -p 80\n\n# Larger grids with specific patterns\n./gen -n 50 -m 50 -type full\n./gen -n 50 -m 50 -type empty\n./gen -n 50 -m 50 -type checkerboard\n\n# Grids designed to test specific scenarios\n./gen -n 100 -m 100 -type max-rooms\n./gen -n 100 -m 100 -type one-room\n\n# Very large grids to test efficiency\n./gen -n 1000 -m 1000 -type full\n./gen -n 1000 -m 1000 -type empty\n./gen -n 1000 -m 1000 -type random -p 50\n\n# Maximum size grids with different patterns and probabilities\n./gen -n 2000 -m 2000 -type random -p 50\n./gen -n 2000 -m 2000 -type random -p 10\n./gen -n 2000 -m 2000 -type random -p 90\n./gen -n 2000 -m 2000 -type checkerboard\n./gen -n 2000 -m 2000 -type max-rooms\n./gen -n 2000 -m 2000 -type one-room\n\n# Maximum size grids with uniform patterns\n./gen -n 2000 -m 2000 -type full\n./gen -n 2000 -m 2000 -type empty\n\n# Grids with extreme dimensions\n./gen -n 1 -m 2000 -type random -p 50\n./gen -n 2000 -m 1 -type random -p 50\n\n# Edge cases with low and high probabilities of free cells\n./gen -n 2000 -m 2000 -type random -p 1\n./gen -n 2000 -m 2000 -type random -p 99\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:35.014995",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "525/E",
      "title": "Problem 525/E",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "",
      "memory_limit": "",
      "input_spec": "",
      "output_spec": "",
      "sample_tests": "",
      "description": "",
      "solutions": [],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readSpace();\n    long long S = inf.readLong(1LL, 10000000000000000LL, \"S\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readSpace();\n    long long S = inf.readLong(1LL, 10000000000000000LL, \"S\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 25, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(0, n, \"k\");\n    inf.readSpace();\n    long long S = inf.readLong(1LL, 10000000000000000LL, \"S\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long factorial[21];\n\nvoid init_factorials() {\n    factorial[0] = 1LL;\n    for (int i = 1; i <= 20; ++i) {\n        factorial[i] = factorial[i - 1] * i;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    init_factorials();\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long S = opt<long long>(\"S\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        int max_a = opt<int>(\"max_a\", 18); // Since 18! ~ 6e15\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"small\") {\n        // Generate small a_i in [1,5]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 5);\n        }\n    } else if (type == \"large\") {\n        // Generate large a_i in [15, 20]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(15, 20);\n        }\n    } else if (type == \"duplicate\") {\n        // Generate a_i with duplicates\n        int num_values = rnd.next(1, min(5, n));\n        vector<int> values;\n        for (int i = 0; i < num_values; ++i) {\n            values.push_back(rnd.next(1, 18));\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = values[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"k_zero\") {\n        // Generate with k = 0\n        k = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 18);\n        }\n    } else if (type == \"k_max\") {\n        // Generate with k = n\n        k = n;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 18);\n        }\n    } else if (type == \"ones\") {\n        // a_i = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"no_solution\") {\n        // Generate S that cannot be achieved\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 18);\n        }\n        if (S == -1) {\n            long long max_sum = 0;\n            for (int i = 0; i < n; ++i) {\n                long long val = a[i];\n                if (a[i] <= 20) {\n                    val = factorial[a[i]];\n                }\n                max_sum += max((long long)a[i], val);\n            }\n            S = max_sum + 1; // Make it impossible\n        }\n    } else {\n        // Default to random if unknown type\n        int max_a = opt<int>(\"max_a\", 18);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    if (S == -1) {\n        // Set S to sum of a_i without exclamation marks\n        S = 0;\n        for (int i = 0; i < n; ++i) {\n            S += a[i];\n        }\n    }\n\n    // Clamp k between 0 and n\n    k = max(0, min(k, n));\n\n    // Output n k S\n    printf(\"%d %d %lld\\n\", n, k, S);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nlong long factorial[21];\n\nvoid init_factorials() {\n    factorial[0] = 1LL;\n    for (int i = 1; i <= 20; ++i) {\n        factorial[i] = factorial[i - 1] * i;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    init_factorials();\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    long long S = opt<long long>(\"S\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"random\") {\n        int max_a = opt<int>(\"max_a\", 18); // Since 18! ~ 6e15\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    } else if (type == \"small\") {\n        // Generate small a_i in [1,5]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 5);\n        }\n    } else if (type == \"large\") {\n        // Generate large a_i in [15, 20]\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(15, 20);\n        }\n    } else if (type == \"duplicate\") {\n        // Generate a_i with duplicates\n        int num_values = rnd.next(1, min(5, n));\n        vector<int> values;\n        for (int i = 0; i < num_values; ++i) {\n            values.push_back(rnd.next(1, 18));\n        }\n        for (int i = 0; i < n; ++i) {\n            a[i] = values[rnd.next(0, num_values - 1)];\n        }\n    } else if (type == \"k_zero\") {\n        // Generate with k = 0\n        k = 0;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 18);\n        }\n    } else if (type == \"k_max\") {\n        // Generate with k = n\n        k = n;\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 18);\n        }\n    } else if (type == \"ones\") {\n        // a_i = 1\n        for (int i = 0; i < n; ++i) {\n            a[i] = 1;\n        }\n    } else if (type == \"no_solution\") {\n        // Generate S that cannot be achieved\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, 18);\n        }\n        if (S == -1) {\n            long long max_sum = 0;\n            for (int i = 0; i < n; ++i) {\n                long long val = a[i];\n                if (a[i] <= 20) {\n                    val = factorial[a[i]];\n                }\n                max_sum += max((long long)a[i], val);\n            }\n            S = max_sum + 1; // Make it impossible\n        }\n    } else {\n        // Default to random if unknown type\n        int max_a = opt<int>(\"max_a\", 18);\n        for (int i = 0; i < n; ++i) {\n            a[i] = rnd.next(1, max_a);\n        }\n    }\n\n    if (S == -1) {\n        // Set S to sum of a_i without exclamation marks\n        S = 0;\n        for (int i = 0; i < n; ++i) {\n            S += a[i];\n        }\n    }\n\n    // Clamp k between 0 and n\n    k = max(0, min(k, n));\n\n    // Output n k S\n    printf(\"%d %d %lld\\n\", n, k, S);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i != n - 1) {\n            printf(\" \");\n        } else {\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -k 2 -S 30\n./gen -n 2 -k 2 -S 7\n./gen -n 3 -k 1 -S 1\n\n./gen -n 5 -k 0 -S 10 -type k_zero\n./gen -n 5 -k 5 -S 1000000 -type k_max\n\n./gen -n 25 -k 5 -S 1000000 -type random\n./gen -n 25 -k 25 -S 9999999999999999 -type random\n\n./gen -n 20 -k 10 -S 5000000000 -type duplicate\n\n./gen -n 25 -k 0 -S 10000000000000000 -type no_solution\n\n./gen -n 25 -k 0 -S 10000000000000000 -type large\n\n./gen -n 1 -k 1 -S 1 -type ones\n\n./gen -n 25 -k 25 -S 25 -type ones\n\n./gen -n 25 -k 25 -S 25 -type small\n\n./gen -n 1 -k 1 -S 123456789 -type random\n\n./gen -n 10 -k 0 -S 45 -type ones\n\n./gen -n 10 -k 0 -S 10 -type small\n\n./gen -n 10 -k 10 -S 3628800 -type large\n\n./gen -n 20 -k 20 -S 10000000000000000 -type large\n\n./gen -n 25 -k 5 -S 100 -type duplicate\n\n./gen -n 10 -k 10 -S 3628800 -type k_max\n\n./gen -n 5 -k 0 -S 1 -type ones\n\n./gen -n 25 -k 0 -S 10000000000000000 -type random\n\n./gen -n 15 -k 7 -S 100000000 -type random\n\n./gen -n 25 -k 0 -S 10000000000000000 -type no_solution\n\n./gen -n 25 -k 25 -S 10000000000000000 -type random\n\n./gen -n 25 -k 25 -S 25 -type ones\n\n./gen -n 25 -k 0 -S 25 -type ones\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:36.681353",
        "total_tutorials": 0,
        "has_ai_judgment": false,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/A",
      "title": "A. King of Thieves",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100) — the number of segments on the level.Next line contains the scheme of the level represented as a string of n characters '*' and '.'.",
      "output_spec": "OutputIf the level is good, print the word \"yes\" (without the quotes), otherwise print the word \"no\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy16.**.*..*.***.**.OutputCopyyesInputCopy11.*.*...*.*.OutputCopyno",
      "description": "A. King of Thieves\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 100) — the number of segments on the level.Next line contains the scheme of the level represented as a string of n characters '*' and '.'.\n\nOutputIf the level is good, print the word \"yes\" (without the quotes), otherwise print the word \"no\" (without the quotes).\n\nInputCopy16.**.*..*.***.**.OutputCopyyesInputCopy11.*.*...*.*.OutputCopyno\n\nInputCopy16.**.*..*.***.**.\n\nOutputCopyyes\n\nInputCopy11.*.*...*.*.\n\nOutputCopyno\n\nNoteIn the first sample test you may perform a sequence of jumps through platforms 2, 5, 8, 11, 14.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Hello, Codeforces!The problems were suggested by users roosephu and Sunayuki. The great help in preparing was provided by Aksenov239, GlebsHP and Codeforces team. ZeptoLab Team did its best while working on statements.The round will use smoother dynamic problem scores with 250 points steps.In 2014 we hosted our first programming contest together with Codeforces, and we liked it!Let me shortly remind you how it was. The contest consisted of 6 problems, 2.5 hours were given to solve (you can have a look at the problems of the previous year and try to solve them here).Of course, even on a purely coding event we stayed true to ourselves, so all problems were designed based on our games, and, of course, we illustrated them with care: Zepto Code Rush 2014 broke the existing Codeforces record of round popularity. Also we were glad to read a positive feedback about problems. By the way, the first three places were taken by developers from Russia. Some of them even came to pick up the prizes at the office, where they had a mini-tour and the highlight of the program: of course, the game in a giant Cut The Rope and our standard corporate \"going green\" welcome kit at the entrance (we call \"going green\" a welcome kit, full of fun gizmos of our corporate green color). Somebody got even luckier: they stayed for more than just a tour and they still amaze us with their professional achievements. Here're some thoughts from one of them, Grisha WhiteCrow Nazarov: I first came for the candies (just kidding), but if I share experiences now — what's especially important is that I can be myself here to the end. Zeptolabians are tolerant of my oddities and appreciate me as a person. In addition, Zeptolab leaders set goals, taking into account the abilities of each developer, including me. And when the head is also \"into\" algorithms, I can realease my potential. In the end I became a sort of client-side back-end developer, which, in fact, I wanted in the first place. Yes, I know some of the data structures that are unlikely to come in handy in Zeptolab soon (they would be more useful, for example, in developing a search engine); I almost never use this part of my knowledge in my daily routine. But these skills are useful to me on the internal algorithmic contests :) What I can say about Working moments: my last task was to improve packaging of atlases in preparing of game resources – a well-known NP-hard problem. I managed to make significant progress: to improve the famous algorithms, the best in 2013 in a variety of metrics. As a result, the memory consumption in all our game projects decreased by megabytes. With the appetite of our artists, I think it's not for long :) Maybe we'll publish my work in one of the next conferences. Overall, sports programming skills are highly valued here, and this, in my experience, is what isn't appreciated enough in other companies. And this post is made to inform you, dear algorithm lovers, that: Zepto Code Rush 2015 starts on Saturday, April, 4, 16:30 (UTC).We are working on problems for the contest and ready, but we are ready to announce cool prizes! You cannot get a vest like that in other ways besides taking part in the contest. The vests are great! And as usual, the person who shows good results in the competition, will be able to get a job in our company by a simplified scheme. You can read about ZeptoLab on our official website. Want to apply to ZeptoLab? ZeptoLab Code Rush 2015 will use standard Codeforces rules, it will be a rated round for the both divisions.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3544
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[*.]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[*.]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    string pattern = \"[*.]{\" + to_string(n) + \"}\";\n    string s = inf.readLine(pattern, \"s\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '.'); // initialize with pits\n\n    if (type == \"all_platforms\") {\n        // All platforms\n        s.assign(n, '*');\n    } else if (type == \"all_pits\") {\n        // All pits\n        s.assign(n, '.');\n    } else if (type == \"alternate\") {\n        int interval = opt<int>(\"interval\", 2);\n        int start = opt<int>(\"start\", 0); // 0-based index\n        for (int i = start; i < n; i += interval) {\n            s[i] = '*';\n        }\n    } else if (type == \"specific_sequence\") {\n        int start = opt<int>(\"start\", 1);\n        int d = opt<int>(\"d\", 1);\n        // Set platforms at positions p_i = start + i*d, for i=0..4\n        for (int i = 0; i <= 4; ++i) {\n            int pos = start + i * d - 1; // Convert to 0-based index\n            if (pos >= n || pos < 0) {\n                // Do nothing, out of bounds\n            } else {\n                s[pos] = '*';\n            }\n        }\n    } else if (type == \"random\") {\n        int p = opt<int>(\"p\", 50); // platform probability percentage [0,100]\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(100) < p) {\n                s[i] = '*';\n            } // else keep '.'\n        }\n    } else {\n        // default is random\n        int p = 50;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(100) < p) {\n                s[i] = '*';\n            } // else keep '.'\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s(n, '.'); // initialize with pits\n\n    if (type == \"all_platforms\") {\n        // All platforms\n        s.assign(n, '*');\n    } else if (type == \"all_pits\") {\n        // All pits\n        s.assign(n, '.');\n    } else if (type == \"alternate\") {\n        int interval = opt<int>(\"interval\", 2);\n        int start = opt<int>(\"start\", 0); // 0-based index\n        for (int i = start; i < n; i += interval) {\n            s[i] = '*';\n        }\n    } else if (type == \"specific_sequence\") {\n        int start = opt<int>(\"start\", 1);\n        int d = opt<int>(\"d\", 1);\n        // Set platforms at positions p_i = start + i*d, for i=0..4\n        for (int i = 0; i <= 4; ++i) {\n            int pos = start + i * d - 1; // Convert to 0-based index\n            if (pos >= n || pos < 0) {\n                // Do nothing, out of bounds\n            } else {\n                s[pos] = '*';\n            }\n        }\n    } else if (type == \"random\") {\n        int p = opt<int>(\"p\", 50); // platform probability percentage [0,100]\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(100) < p) {\n                s[i] = '*';\n            } // else keep '.'\n        }\n    } else {\n        // default is random\n        int p = 50;\n        for (int i = 0; i < n; ++i) {\n            if (rnd.next(100) < p) {\n                s[i] = '*';\n            } // else keep '.'\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# All platforms, small n\n./gen -n 1 -type all_platforms\n./gen -n 5 -type all_platforms\n./gen -n 100 -type all_platforms\n\n# All pits, small n\n./gen -n 1 -type all_pits\n./gen -n 5 -type all_pits\n./gen -n 100 -type all_pits\n\n# Alternate platforms and pits\n./gen -n 10 -type alternate -interval 2 -start 0\n./gen -n 10 -type alternate -interval 2 -start 1\n./gen -n 15 -type alternate -interval 3 -start 0\n./gen -n 15 -type alternate -interval 3 -start 1\n\n# Specific sequence test cases\n./gen -n 5 -type specific_sequence -d 1 -start 1\n./gen -n 6 -type specific_sequence -d 1 -start 2\n./gen -n 9 -type specific_sequence -d 2 -start 1\n./gen -n 13 -type specific_sequence -d 3 -start 1\n./gen -n 100 -type specific_sequence -d 20 -start 1\n# Test with start positions that might exceed n\n./gen -n 5 -type specific_sequence -d 1 -start 5\n./gen -n 6 -type specific_sequence -d 1 -start 0\n./gen -n 10 -type specific_sequence -d 3 -start 8\n\n# Random platforms with varying probabilities and sizes\n./gen -n 20 -type random -p 50\n./gen -n 40 -type random -p 30\n./gen -n 30 -type random -p 70\n./gen -n 100 -type random -p 10\n./gen -n 100 -type random -p 90\n./gen -n 15 -type random -p 0\n./gen -n 15 -type random -p 100\n./gen -n 1 -type random -p 50\n./gen -n 100 -type random -p 50\n\n# Alternate with interval 1, should be same as all platforms\n./gen -n 100 -type alternate -interval 1 -start 0\n\n# Random test cases with default parameters\n./gen -n 20\n./gen -n 50\n\n# Edge cases with minimum and maximum n\n./gen -n 1 -type random -p 0\n./gen -n 100 -type random -p 0\n./gen -n 1 -type random -p 100\n./gen -n 100 -type random -p 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:38.516480",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/B",
      "title": "B. Om Nom and Dark Park",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 10) — the number of roads on the path from the entrance to any exit.The next line contains 2n + 1 - 2 numbers a2, a3, ... a2n + 1 - 1 — the initial numbers of street lights on each road of the park. Here ai is the number of street lights on the road between squares i and . All numbers ai are positive integers, not exceeding 100.",
      "output_spec": "OutputPrint the minimum number of street lights that we should add to the roads of the park to make Om Nom feel safe.",
      "sample_tests": "ExamplesInputCopy21 2 3 4 5 6OutputCopy5",
      "description": "B. Om Nom and Dark Park\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 10) — the number of roads on the path from the entrance to any exit.The next line contains 2n + 1 - 2 numbers a2, a3, ... a2n + 1 - 1 — the initial numbers of street lights on each road of the park. Here ai is the number of street lights on the road between squares i and . All numbers ai are positive integers, not exceeding 100.\n\nOutputPrint the minimum number of street lights that we should add to the roads of the park to make Om Nom feel safe.\n\nInputCopy21 2 3 4 5 6OutputCopy5\n\nInputCopy21 2 3 4 5 6\n\nOutputCopy5\n\nNotePicture for the sample test. Green color denotes the additional street lights.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Hello, Codeforces!The problems were suggested by users roosephu and Sunayuki. The great help in preparing was provided by Aksenov239, GlebsHP and Codeforces team. ZeptoLab Team did its best while working on statements.The round will use smoother dynamic problem scores with 250 points steps.In 2014 we hosted our first programming contest together with Codeforces, and we liked it!Let me shortly remind you how it was. The contest consisted of 6 problems, 2.5 hours were given to solve (you can have a look at the problems of the previous year and try to solve them here).Of course, even on a purely coding event we stayed true to ourselves, so all problems were designed based on our games, and, of course, we illustrated them with care: Zepto Code Rush 2014 broke the existing Codeforces record of round popularity. Also we were glad to read a positive feedback about problems. By the way, the first three places were taken by developers from Russia. Some of them even came to pick up the prizes at the office, where they had a mini-tour and the highlight of the program: of course, the game in a giant Cut The Rope and our standard corporate \"going green\" welcome kit at the entrance (we call \"going green\" a welcome kit, full of fun gizmos of our corporate green color). Somebody got even luckier: they stayed for more than just a tour and they still amaze us with their professional achievements. Here're some thoughts from one of them, Grisha WhiteCrow Nazarov: I first came for the candies (just kidding), but if I share experiences now — what's especially important is that I can be myself here to the end. Zeptolabians are tolerant of my oddities and appreciate me as a person. In addition, Zeptolab leaders set goals, taking into account the abilities of each developer, including me. And when the head is also \"into\" algorithms, I can realease my potential. In the end I became a sort of client-side back-end developer, which, in fact, I wanted in the first place. Yes, I know some of the data structures that are unlikely to come in handy in Zeptolab soon (they would be more useful, for example, in developing a search engine); I almost never use this part of my knowledge in my daily routine. But these skills are useful to me on the internal algorithmic contests :) What I can say about Working moments: my last task was to improve packaging of atlases in preparing of game resources – a well-known NP-hard problem. I managed to make significant progress: to improve the famous algorithms, the best in 2013 in a variety of metrics. As a result, the memory consumption in all our game projects decreased by megabytes. With the appetite of our artists, I think it's not for long :) Maybe we'll publish my work in one of the next conferences. Overall, sports programming skills are highly valued here, and this, in my experience, is what isn't appreciated enough in other companies. And this post is made to inform you, dear algorithm lovers, that: Zepto Code Rush 2015 starts on Saturday, April, 4, 16:30 (UTC).We are working on problems for the contest and ready, but we are ready to announce cool prizes! You cannot get a vest like that in other ways besides taking part in the contest. The vests are great! And as usual, the person who shows good results in the competition, will be able to get a job in our company by a simplified scheme. You can read about ZeptoLab on our official website. Want to apply to ZeptoLab? ZeptoLab Code Rush 2015 will use standard Codeforces rules, it will be a rated round for the both divisions.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3544
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n\n    int expected_size = (1 << (n + 1)) - 2;\n    vector<int> a = inf.readInts(expected_size, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n\n    int expected_size = (1 << (n + 1)) - 2;\n    vector<int> a = inf.readInts(expected_size, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10, \"n\");\n    inf.readEoln();\n\n    int expected_size = (1 << (n + 1)) - 2;\n    vector<int> a = inf.readInts(expected_size, 1, 100, \"a_i\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"c\", 1); // For constant type, default c = 1\n\n    int N = (1 << (n + 1)) - 1; // Total number of nodes\n    vector<int> ai(N + 1); // Indices from 0 to N\n\n    if (type == \"all1\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"all100\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 100;\n        }\n    } else if (type == \"constant\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = c;\n        }\n    } else if (type == \"random\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"equal_sum\") {\n        // Assign random ai and adjust to make all path sums equal\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n        int num_leaves = 1 << n;\n        vector<int> path_sums(num_leaves);\n        int max_sum = 0;\n        for (int leaf = num_leaves; leaf < (1 << (n + 1)); ++leaf) {\n            int node = leaf;\n            int sum = 0;\n            while (node > 1) {\n                sum += ai[node];\n                node /= 2;\n            }\n            path_sums[leaf - num_leaves] = sum;\n            max_sum = max(max_sum, sum);\n        }\n        // Adjust ai's to make all path sums equal to max_sum\n        for (int leaf = num_leaves; leaf < (1 << (n + 1)); ++leaf) {\n            int node = leaf;\n            int sum = 0;\n            vector<int> path_nodes;\n            while (node > 1) {\n                path_nodes.push_back(node);\n                sum += ai[node];\n                node /= 2;\n            }\n            int missing = max_sum - sum;\n            int per_edge_add = missing / path_nodes.size();\n            int rem = missing % path_nodes.size();\n            for (int idx = 0; idx < path_nodes.size(); ++idx) {\n                int node = path_nodes[idx];\n                int to_add = per_edge_add + (rem > 0 ? 1 : 0);\n                ai[node] += to_add;\n                if (rem > 0) rem--;\n            }\n        }\n    } else if (type == \"min_sum_path\") {\n        // Assign ai so that one leaf's path sum is minimal, others maximal\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 100;\n        }\n        int num_leaves = 1 << n;\n        int target_leaf = rnd.next(num_leaves, (1 << (n + 1)) - 1);\n        int node = target_leaf;\n        while (node > 1) {\n            ai[node] = 1;\n            node /= 2;\n        }\n    } else if (type == \"max_sum_path\") {\n        // Assign ai so that one leaf's path sum is maximal, others minimal\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 1;\n        }\n        int num_leaves = 1 << n;\n        int target_leaf = rnd.next(num_leaves, (1 << (n + 1)) - 1);\n        int node = target_leaf;\n        while (node > 1) {\n            ai[node] = 100;\n            node /= 2;\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output ai's from a2 to aN\n    for (int i = 2; i <= N; ++i) {\n        cout << ai[i];\n        if (i != N)\n            cout << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int c = opt<int>(\"c\", 1); // For constant type, default c = 1\n\n    int N = (1 << (n + 1)) - 1; // Total number of nodes\n    vector<int> ai(N + 1); // Indices from 0 to N\n\n    if (type == \"all1\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 1;\n        }\n    } else if (type == \"all100\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 100;\n        }\n    } else if (type == \"constant\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = c;\n        }\n    } else if (type == \"random\") {\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    } else if (type == \"equal_sum\") {\n        // Assign random ai and adjust to make all path sums equal\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n        int num_leaves = 1 << n;\n        vector<int> path_sums(num_leaves);\n        int max_sum = 0;\n        for (int leaf = num_leaves; leaf < (1 << (n + 1)); ++leaf) {\n            int node = leaf;\n            int sum = 0;\n            while (node > 1) {\n                sum += ai[node];\n                node /= 2;\n            }\n            path_sums[leaf - num_leaves] = sum;\n            max_sum = max(max_sum, sum);\n        }\n        // Adjust ai's to make all path sums equal to max_sum\n        for (int leaf = num_leaves; leaf < (1 << (n + 1)); ++leaf) {\n            int node = leaf;\n            int sum = 0;\n            vector<int> path_nodes;\n            while (node > 1) {\n                path_nodes.push_back(node);\n                sum += ai[node];\n                node /= 2;\n            }\n            int missing = max_sum - sum;\n            int per_edge_add = missing / path_nodes.size();\n            int rem = missing % path_nodes.size();\n            for (int idx = 0; idx < path_nodes.size(); ++idx) {\n                int node = path_nodes[idx];\n                int to_add = per_edge_add + (rem > 0 ? 1 : 0);\n                ai[node] += to_add;\n                if (rem > 0) rem--;\n            }\n        }\n    } else if (type == \"min_sum_path\") {\n        // Assign ai so that one leaf's path sum is minimal, others maximal\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 100;\n        }\n        int num_leaves = 1 << n;\n        int target_leaf = rnd.next(num_leaves, (1 << (n + 1)) - 1);\n        int node = target_leaf;\n        while (node > 1) {\n            ai[node] = 1;\n            node /= 2;\n        }\n    } else if (type == \"max_sum_path\") {\n        // Assign ai so that one leaf's path sum is maximal, others minimal\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = 1;\n        }\n        int num_leaves = 1 << n;\n        int target_leaf = rnd.next(num_leaves, (1 << (n + 1)) - 1);\n        int node = target_leaf;\n        while (node > 1) {\n            ai[node] = 100;\n            node /= 2;\n        }\n    } else {\n        // Default to random\n        for (int i = 2; i <= N; ++i) {\n            ai[i] = rnd.next(1, 100);\n        }\n    }\n\n    // Output n\n    cout << n << endl;\n    // Output ai's from a2 to aN\n    for (int i = 2; i <= N; ++i) {\n        cout << ai[i];\n        if (i != N)\n            cout << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type all1\n./gen -n 1 -type all100\n./gen -n 1 -type constant -c 50\n./gen -n 1 -type random\n./gen -n 1 -type equal_sum\n./gen -n 1 -type min_sum_path\n./gen -n 1 -type max_sum_path\n\n./gen -n 3 -type constant -c 10\n./gen -n 3 -type constant -c 20\n./gen -n 3 -type constant -c 30\n\n./gen -n 5 -type all1\n./gen -n 5 -type all100\n./gen -n 5 -type constant -c 75\n./gen -n 5 -type random\n./gen -n 5 -type equal_sum\n./gen -n 5 -type min_sum_path\n./gen -n 5 -type max_sum_path\n\n./gen -n 7 -type random\n./gen -n 8 -type random\n./gen -n 9 -type random\n\n./gen -n 10 -type all1\n./gen -n 10 -type all100\n./gen -n 10 -type constant -c 1\n./gen -n 10 -type constant -c 100\n./gen -n 10 -type random\n./gen -n 10 -type equal_sum\n./gen -n 10 -type min_sum_path\n./gen -n 10 -type max_sum_path\n\n./gen -n 1 -type equal_sum\n./gen -n 1 -type min_sum_path\n./gen -n 1 -type max_sum_path\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:40.797154",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/C",
      "title": "C. Ам Ням и леденцы",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ единственной строке заданы пять целых чисел C, Hr, Hb, Wr, Wb (1 ≤ C, Hr, Hb, Wr, Wb ≤ 109).",
      "output_spec": "Выходные данныеВыведите единственное целое число — максимальное количество единиц радости, которое может получить Ам Ням.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 3 5 2 3Выходные данныеСкопировать16",
      "description": "C. Ам Ням и леденцы\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ единственной строке заданы пять целых чисел C, Hr, Hb, Wr, Wb (1 ≤ C, Hr, Hb, Wr, Wb ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите единственное целое число — максимальное количество единиц радости, которое может получить Ам Ням.\n\nВыходные данные\n\nВходные данныеСкопировать10 3 5 2 3Выходные данныеСкопировать16\n\nВходные данныеСкопировать10 3 5 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия Ам Ням может съесть по два леденца каждого вида, и получить тем самым 16 единиц радости.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Привет, Codeforces!Задачи сегодняшнего раунда были предложены вам пользователями roosephu и Sunayuki. Большую помощь в подготовке задач оказали Aksenov239, GlebsHP и команда Codeforces. В составлении и оформлении условий участвовали сотрудники компании ZeptoLab. Вас ждет плавная динамическая стоимость задач (с шагом в 250 баллов). В 2014 году мы провели свой первый контест по спортивному программированию совместно с Codeforces, и нам понравилось!Контест состоял из 6 задач, на решение которых отводилось 2,5 часа (ознакомиться с задачами прошлого года и даже попробовать свои силы в их решении вы можете по ссылке).Конечно же, даже на сугубо программистском мероприятии мы остались верны себе, поэтому задачи были придуманы по мотивам наших игр, и, разумеется, мы их заботливо проиллюстрировали: Zepto Code Rush 2014 побил действующие рекорды Codeforces по популярности раундов, а задачи понравились участникам. К слову сказать, первые 3 места заняли разработчки из России, что не может не радовать. Кое-кто из них даже приехал забрать призы в офис, где их ждала мини-экскурсия и гвоздь программы: конечно же, игра в гигантский Cut The Rope и наше стандартное корпоративное \"озеленение\" на входе (озеленением мы называем вручение welcome-kit, полного забавных вещиц нашего корпоративно-зеленого цвета). А кое-кому повезло еще сильнее: они задержались у нас чуть дольше, чем просто на экскурсию, и по-прежнему радуют нас своими рабочими успехами. Ниже пара мыслей от одного из них, Гриши WhiteCrow Назарова: Изначально я пришел за леденцами (шутка), но сейчас, если делиться впечатлениями, — в первую очередь важно то, что я могу здесь быть собой до конца. Зептолабовцы толерантно относятся к моим странностям и ценят меня как человека. Кроме того, в Зептолаб руководители ставят задачи с учетом способностей каждого разработчика, в том числе передо мной. А когда руководитель тоже \"в теме\" алгоритмов, мне есть, где развернуться. Получилось, что я стал этаким client-side back-end разработчиком, чего, собственно, и хотелось. Да, я знаю некоторые структуры данных, которые в Зептолабе вряд ли скоро пригодятся (они бы больше пригодились, например, в разработке поисковика); к этой части своих знаний я практически не обращаюсь в ежедневной работе. Зато эти навыки мне полезны на внутренних алгоритмическиех контестах :) О рабочих моментах: моей последней задачей было улучшение упаковки атласов при подготовке игровых ресурсов – известная NP-трудная задача. Мне удалось добиться существенных успехов: улучшить известные и лучшие на 2013 год по разным метрикам алгоритмы. В результате потребление памяти во всех наших игровых проектах сократилось на мегабайты, и у сборок появился запас по memory-limit. С аппетитом наших художников, я думаю, это ненадолго :) Возможно, мою работу мы опубликуем на одной из ближайших конференций. В целом, навыки спортивного программирования здесь очень ценятся, а этому, по моему опыту, в других компаниях придают недостаточное значение. Ну а цель сего поста проинформировать вас, уважаемые участники, вот о чем: 4-го апреля (в субботу) в 19:30 состоится наш второй контест Zepto Code Rush 2015.Мы уже вовсю работаем над тем, чтобы снова удивить вас нетривиальными задачками и по результатам порадовать не менее крутыми призами, чем на прошлом контесте: Кстати, кроме как поучаствовав в контесте, такую жилетку больше никак не отхватить. Жилетки крутые. Ну и по-прежнему: у того, кто покажет неплохие результаты по конкурсу, будет возможность устроиться к нам по упрощенной схеме. Если вам интересно попробовать себя в команде ZeptoLab — поставьте соответствующую галочку при регистрации. О том, что такое работать у нас можно почитать тут: http://zeptoteam.ru/. Заинтересовались работой в ZeptoLab? Чемпионат будет проводиться в один раунд. Формат соревнования — по правилам Codeforces. Раунд будет рейтинговым и общим для обоих дивизионов.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 3878
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "for (int i = 0; i < n; ++i) {\n  for (int j = i + 1, d = j - i; j < n; ++j) { ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "for (int i = 0; i < n; ++i) {\n  for (int j = i + 1, d = j - i; j < n; ++j) { ...",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 15",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 16",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int C = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Hr = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Hb = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Wr = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Wb = inf.readInt(1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int C = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Hr = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Hb = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Wr = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Wb = inf.readInt(1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int C = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Hr = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Hb = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Wr = inf.readInt(1, 1000000000);\n    inf.readSpace();\n    int Wb = inf.readInt(1, 1000000000);\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    long long C_max = opt<long long>(\"C_max\", 1000000000LL); // default maximum capacity\n    int W_max = opt<int>(\"W_max\", 1000000000); // default maximum weight\n    int H_max = opt<int>(\"H_max\", 1000000000); // default maximum joy\n\n    long long C;\n    int Hr, Hb, Wr, Wb;\n\n    if (type == \"random_small\") {\n        // Generate random small values\n        C = rnd.next(1LL, min(C_max, 1000LL));\n        Hr = rnd.next(1, min(H_max, 1000));\n        Hb = rnd.next(1, min(H_max, 1000));\n        Wr = rnd.next(1, min(W_max, 1000));\n        Wb = rnd.next(1, min(W_max, 1000));\n    } else if (type == \"random_large\") {\n        // Generate random large values\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    } else if (type == \"equal_weights\") {\n        // Wr == Wb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = Wr;\n    } else if (type == \"equal_joys\") {\n        // Hr == Hb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = Hr;\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    } else if (type == \"equal_joy_per_weight\") {\n        // Hr/Wr == Hb/Wb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max / 1000);  // Small values to prevent overflow\n        Wr = rnd.next(1, W_max / 1000);\n        int k = rnd.next(1, 1000);\n        Hb = Hr * k;\n        Wb = Wr * k;\n        Hb = min(Hb, H_max);\n        Wb = min(Wb, W_max);\n    } else if (type == \"one_dominates\") {\n        // Ensure Hr/Wr > Hb/Wb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        do {\n            Hb = rnd.next(1, H_max);\n            Wb = rnd.next(1, W_max);\n        } while ( (long long)Hr * Wb <= (long long)Hb * Wr);\n    } else if (type == \"max_cap\") {\n        // C is maximal\n        C = C_max;\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n\n    } else if (type == \"min_cap\") {\n        // C is minimal\n        C = 1;\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    } else if (type == \"max_values\") {\n        // All values at max\n        C = C_max;\n        Hr = H_max;\n        Hb = H_max;\n        Wr = W_max;\n        Wb = W_max;\n    } else if (type == \"weights_coprime\") {\n        // Wr and Wb are coprime\n        C = rnd.next(1LL, C_max);\n        Wr = rnd.next(1, W_max);\n        do {\n            Wb = rnd.next(1, W_max);\n        } while(__gcd(Wr, Wb) != 1);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n\n    } else if (type == \"weights_multiples\") {\n        // Wr is a multiple of Wb\n        Wb = rnd.next(1, W_max / 10);  // To prevent overflow\n        int k = rnd.next(2, 10);\n        Wr = Wb * k;\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n    } else {\n        // default random_large\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    }\n\n    // Ensure all constraints are satisfied\n    assert(1 <= C && C <= 1000000000LL);\n    assert(1 <= Hr && Hr <= 1000000000);\n    assert(1 <= Hb && Hb <= 1000000000);\n    assert(1 <= Wr && Wr <= 1000000000);\n    assert(1 <= Wb && Wb <= 1000000000);\n\n    // Output the test case\n    printf(\"%lld %d %d %d %d\\n\", C, Hr, Hb, Wr, Wb);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\");\n    long long C_max = opt<long long>(\"C_max\", 1000000000LL); // default maximum capacity\n    int W_max = opt<int>(\"W_max\", 1000000000); // default maximum weight\n    int H_max = opt<int>(\"H_max\", 1000000000); // default maximum joy\n\n    long long C;\n    int Hr, Hb, Wr, Wb;\n\n    if (type == \"random_small\") {\n        // Generate random small values\n        C = rnd.next(1LL, min(C_max, 1000LL));\n        Hr = rnd.next(1, min(H_max, 1000));\n        Hb = rnd.next(1, min(H_max, 1000));\n        Wr = rnd.next(1, min(W_max, 1000));\n        Wb = rnd.next(1, min(W_max, 1000));\n    } else if (type == \"random_large\") {\n        // Generate random large values\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    } else if (type == \"equal_weights\") {\n        // Wr == Wb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = Wr;\n    } else if (type == \"equal_joys\") {\n        // Hr == Hb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = Hr;\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    } else if (type == \"equal_joy_per_weight\") {\n        // Hr/Wr == Hb/Wb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max / 1000);  // Small values to prevent overflow\n        Wr = rnd.next(1, W_max / 1000);\n        int k = rnd.next(1, 1000);\n        Hb = Hr * k;\n        Wb = Wr * k;\n        Hb = min(Hb, H_max);\n        Wb = min(Wb, W_max);\n    } else if (type == \"one_dominates\") {\n        // Ensure Hr/Wr > Hb/Wb\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        do {\n            Hb = rnd.next(1, H_max);\n            Wb = rnd.next(1, W_max);\n        } while ( (long long)Hr * Wb <= (long long)Hb * Wr);\n    } else if (type == \"max_cap\") {\n        // C is maximal\n        C = C_max;\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n\n    } else if (type == \"min_cap\") {\n        // C is minimal\n        C = 1;\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    } else if (type == \"max_values\") {\n        // All values at max\n        C = C_max;\n        Hr = H_max;\n        Hb = H_max;\n        Wr = W_max;\n        Wb = W_max;\n    } else if (type == \"weights_coprime\") {\n        // Wr and Wb are coprime\n        C = rnd.next(1LL, C_max);\n        Wr = rnd.next(1, W_max);\n        do {\n            Wb = rnd.next(1, W_max);\n        } while(__gcd(Wr, Wb) != 1);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n\n    } else if (type == \"weights_multiples\") {\n        // Wr is a multiple of Wb\n        Wb = rnd.next(1, W_max / 10);  // To prevent overflow\n        int k = rnd.next(2, 10);\n        Wr = Wb * k;\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n    } else {\n        // default random_large\n        C = rnd.next(1LL, C_max);\n        Hr = rnd.next(1, H_max);\n        Hb = rnd.next(1, H_max);\n        Wr = rnd.next(1, W_max);\n        Wb = rnd.next(1, W_max);\n    }\n\n    // Ensure all constraints are satisfied\n    assert(1 <= C && C <= 1000000000LL);\n    assert(1 <= Hr && Hr <= 1000000000);\n    assert(1 <= Hb && Hb <= 1000000000);\n    assert(1 <= Wr && Wr <= 1000000000);\n    assert(1 <= Wb && Wb <= 1000000000);\n\n    // Output the test case\n    printf(\"%lld %d %d %d %d\\n\", C, Hr, Hb, Wr, Wb);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random_small\n./gen -type random_large\n\n./gen -type equal_weights\n./gen -type equal_weights -W_max 1\n\n./gen -type equal_joys\n./gen -type equal_joys -H_max 1\n\n./gen -type equal_joy_per_weight\n./gen -type equal_joy_per_weight\n\n./gen -type one_dominates\n./gen -type one_dominates\n./gen -type one_dominates\n\n./gen -type max_cap\n./gen -type min_cap\n\n./gen -type max_values\n\n./gen -type weights_coprime\n./gen -type weights_multiples\n\n./gen -type weights_coprime -W_max 10\n./gen -type weights_multiples -W_max 100\n\n./gen -type random_large -C_max 1\n./gen -type random_large -C_max 1000000000\n./gen -type random_large -H_max 1\n./gen -type random_large -H_max 1000000000\n./gen -type random_large -W_max 1\n./gen -type random_large -W_max 1000000000\n\n./gen -type random_large\n./gen -type random_large\n./gen -type random_large\n\n./gen -type random_large -C_max 1000000000\n\n./gen -type random_large -C_max 1\n\n./gen -type random_large -C_max 500000000\n\n./gen -type random_large -W_max 10\n./gen -type random_large -W_max 100\n\n./gen -type random_large -H_max 10\n./gen -type random_large -H_max 100\n\n./gen -type random_large -W_max 100 -H_max 100\n\n./gen -type random_large -C_max 10 -W_max 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:43.276019",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/D",
      "title": "D. Om Nom and Necklace",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n, k ≤ 1 000 000) — the number of beads on the thread that Om Nom found and number k from the definition of the regular sequence above.The second line contains the sequence of n lowercase Latin letters that represent the colors of the beads. Each color corresponds to a single letter.",
      "output_spec": "OutputPrint a string consisting of n zeroes and ones. Position i (1 ≤ i ≤ n) must contain either number one if the first i beads on the thread form a regular sequence, or a zero otherwise.",
      "sample_tests": "ExamplesInputCopy7 2bcabcabOutputCopy0000011InputCopy21 2ababaababaababaababaaOutputCopy000110000111111000011",
      "description": "D. Om Nom and Necklace\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, k (1 ≤ n, k ≤ 1 000 000) — the number of beads on the thread that Om Nom found and number k from the definition of the regular sequence above.The second line contains the sequence of n lowercase Latin letters that represent the colors of the beads. Each color corresponds to a single letter.\n\nOutputPrint a string consisting of n zeroes and ones. Position i (1 ≤ i ≤ n) must contain either number one if the first i beads on the thread form a regular sequence, or a zero otherwise.\n\nInputCopy7 2bcabcabOutputCopy0000011InputCopy21 2ababaababaababaababaaOutputCopy000110000111111000011\n\nInputCopy7 2bcabcab\n\nOutputCopy0000011\n\nInputCopy21 2ababaababaababaababaa\n\nOutputCopy000110000111111000011\n\nNoteIn the first sample test a regular sequence is both a sequence of the first 6 beads (we can take A = \"\", B = \"bca\"), and a sequence of the first 7 beads (we can take A = \"b\", B = \"ca\").In the second sample test, for example, a sequence of the first 13 beads is regular, if we take A = \"aba\", B = \"ba\".",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Hello, Codeforces!The problems were suggested by users roosephu and Sunayuki. The great help in preparing was provided by Aksenov239, GlebsHP and Codeforces team. ZeptoLab Team did its best while working on statements.The round will use smoother dynamic problem scores with 250 points steps.In 2014 we hosted our first programming contest together with Codeforces, and we liked it!Let me shortly remind you how it was. The contest consisted of 6 problems, 2.5 hours were given to solve (you can have a look at the problems of the previous year and try to solve them here).Of course, even on a purely coding event we stayed true to ourselves, so all problems were designed based on our games, and, of course, we illustrated them with care: Zepto Code Rush 2014 broke the existing Codeforces record of round popularity. Also we were glad to read a positive feedback about problems. By the way, the first three places were taken by developers from Russia. Some of them even came to pick up the prizes at the office, where they had a mini-tour and the highlight of the program: of course, the game in a giant Cut The Rope and our standard corporate \"going green\" welcome kit at the entrance (we call \"going green\" a welcome kit, full of fun gizmos of our corporate green color). Somebody got even luckier: they stayed for more than just a tour and they still amaze us with their professional achievements. Here're some thoughts from one of them, Grisha WhiteCrow Nazarov: I first came for the candies (just kidding), but if I share experiences now — what's especially important is that I can be myself here to the end. Zeptolabians are tolerant of my oddities and appreciate me as a person. In addition, Zeptolab leaders set goals, taking into account the abilities of each developer, including me. And when the head is also \"into\" algorithms, I can realease my potential. In the end I became a sort of client-side back-end developer, which, in fact, I wanted in the first place. Yes, I know some of the data structures that are unlikely to come in handy in Zeptolab soon (they would be more useful, for example, in developing a search engine); I almost never use this part of my knowledge in my daily routine. But these skills are useful to me on the internal algorithmic contests :) What I can say about Working moments: my last task was to improve packaging of atlases in preparing of game resources – a well-known NP-hard problem. I managed to make significant progress: to improve the famous algorithms, the best in 2013 in a variety of metrics. As a result, the memory consumption in all our game projects decreased by megabytes. With the appetite of our artists, I think it's not for long :) Maybe we'll publish my work in one of the next conferences. Overall, sports programming skills are highly valued here, and this, in my experience, is what isn't appreciated enough in other companies. And this post is made to inform you, dear algorithm lovers, that: Zepto Code Rush 2015 starts on Saturday, April, 4, 16:30 (UTC).We are working on problems for the contest and ready, but we are ready to announce cool prizes! You cannot get a vest like that in other ways besides taking part in the contest. The vests are great! And as usual, the person who shows good results in the competition, will be able to get a job in our company by a simplified scheme. You can read about ZeptoLab on our official website. Want to apply to ZeptoLab? ZeptoLab Code Rush 2015 will use standard Codeforces rules, it will be a rated round for the both divisions.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3544
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref((int)s.length() == n, \"Expected length %d, but read length %d\", n, (int)s.length());\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref('a' <= c && c <= 'z', \"All characters must be lowercase letters, but s[%d]=%c\", i+1, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref((int)s.length() == n, \"Expected length %d, but read length %d\", n, (int)s.length());\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref('a' <= c && c <= 'z', \"All characters must be lowercase letters, but s[%d]=%c\", i+1, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 1000000, \"k\");\n    inf.readEoln();\n\n    string s = inf.readLine();\n    ensuref((int)s.length() == n, \"Expected length %d, but read length %d\", n, (int)s.length());\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        ensuref('a' <= c && c <= 'z', \"All characters must be lowercase letters, but s[%d]=%c\", i+1, c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate the bead sequence\nstring generate_sequence(int n, int k, string type) {\n    string s;\n    if (type == \"random\") {\n        // Generate a random string of length n\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"regular_emptyA\") {\n        // Generate a regular sequence with A empty\n        // S = A + B + A + B + ... + A + B + A, with A empty\n        if (k == 0) {\n            // Special case when k = 0\n            // S = A (empty), but need to generate a string of length n\n            // Generate a random string of length n\n            for (int i = 0; i < n; ++i) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n        } else {\n            // Generate B\n            int len_B = max(1, n / k);\n            string B;\n            for (int i = 0; i < len_B; ++i) {\n                char c = 'a' + rnd.next(26);\n                B += c;\n            }\n            // Build S = B repeated k times\n            for (int i = 0; i < k; ++i) {\n                s += B;\n            }\n            // Trim or extend s to length n\n            s = s.substr(0, n);\n            while ((int)s.length() < n) {\n                s += 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"regular_emptyB\") {\n        // Generate a regular sequence with B empty\n        // S = A + B + A + B + ... + A + B + A, with B empty\n        if (k == 0) {\n            // Special case when k = 0\n            // S = A, generate A of length n\n            string A;\n            for (int i = 0; i < n; ++i) {\n                char c = 'a' + rnd.next(26);\n                A += c;\n            }\n            s = A;\n        } else {\n            // Generate A\n            int len_A = max(1, n / (k + 1));\n            string A;\n            for (int i = 0; i < len_A; ++i) {\n                char c = 'a' + rnd.next(26);\n                A += c;\n            }\n            // Build S = A + A + ... + A (k+1 times)\n            for (int i = 0; i < k + 1; ++i) {\n                s += A;\n            }\n            // Trim or extend s to length n\n            s = s.substr(0, n);\n            while ((int)s.length() < n) {\n                s += 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"regular_non_empty\") {\n        // Generate a regular sequence with non-empty A and B\n        int total_summands = 2 * k + 1;\n        int len_part = max(1, n / total_summands);\n        string A, B;\n        // Generate A\n        for (int i = 0; i < len_part; ++i) {\n            char c = 'a' + rnd.next(26);\n            A += c;\n        }\n        // Generate B\n        for (int i = 0; i < len_part; ++i) {\n            char c = 'a' + rnd.next(26);\n            B += c;\n        }\n        // Build S\n        s += A;\n        for (int i = 0; i < k; ++i) {\n            s += B;\n            s += A;\n        }\n        // Trim or extend s to length n\n        s = s.substr(0, n);\n        while ((int)s.length() < n) {\n            s += 'a' + rnd.next(26);\n        }\n    } else if (type == \"irregular\") {\n        // Generate a random string that is unlikely to be regular\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"same_letter\") {\n        // Generate a string where all beads are the same letter\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"alternating_letters\") {\n        // Generate a string with alternating letters\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n    // Ensure s is of length n\n    s = s.substr(0, n);\n    while ((int)s.length() < n) {\n        s += 'a' + rnd.next(26);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Generate and output the bead sequence\n    string s = generate_sequence(n, k, type);\n    cout << s << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Function to generate the bead sequence\nstring generate_sequence(int n, int k, string type) {\n    string s;\n    if (type == \"random\") {\n        // Generate a random string of length n\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"regular_emptyA\") {\n        // Generate a regular sequence with A empty\n        // S = A + B + A + B + ... + A + B + A, with A empty\n        if (k == 0) {\n            // Special case when k = 0\n            // S = A (empty), but need to generate a string of length n\n            // Generate a random string of length n\n            for (int i = 0; i < n; ++i) {\n                char c = 'a' + rnd.next(26);\n                s += c;\n            }\n        } else {\n            // Generate B\n            int len_B = max(1, n / k);\n            string B;\n            for (int i = 0; i < len_B; ++i) {\n                char c = 'a' + rnd.next(26);\n                B += c;\n            }\n            // Build S = B repeated k times\n            for (int i = 0; i < k; ++i) {\n                s += B;\n            }\n            // Trim or extend s to length n\n            s = s.substr(0, n);\n            while ((int)s.length() < n) {\n                s += 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"regular_emptyB\") {\n        // Generate a regular sequence with B empty\n        // S = A + B + A + B + ... + A + B + A, with B empty\n        if (k == 0) {\n            // Special case when k = 0\n            // S = A, generate A of length n\n            string A;\n            for (int i = 0; i < n; ++i) {\n                char c = 'a' + rnd.next(26);\n                A += c;\n            }\n            s = A;\n        } else {\n            // Generate A\n            int len_A = max(1, n / (k + 1));\n            string A;\n            for (int i = 0; i < len_A; ++i) {\n                char c = 'a' + rnd.next(26);\n                A += c;\n            }\n            // Build S = A + A + ... + A (k+1 times)\n            for (int i = 0; i < k + 1; ++i) {\n                s += A;\n            }\n            // Trim or extend s to length n\n            s = s.substr(0, n);\n            while ((int)s.length() < n) {\n                s += 'a' + rnd.next(26);\n            }\n        }\n    } else if (type == \"regular_non_empty\") {\n        // Generate a regular sequence with non-empty A and B\n        int total_summands = 2 * k + 1;\n        int len_part = max(1, n / total_summands);\n        string A, B;\n        // Generate A\n        for (int i = 0; i < len_part; ++i) {\n            char c = 'a' + rnd.next(26);\n            A += c;\n        }\n        // Generate B\n        for (int i = 0; i < len_part; ++i) {\n            char c = 'a' + rnd.next(26);\n            B += c;\n        }\n        // Build S\n        s += A;\n        for (int i = 0; i < k; ++i) {\n            s += B;\n            s += A;\n        }\n        // Trim or extend s to length n\n        s = s.substr(0, n);\n        while ((int)s.length() < n) {\n            s += 'a' + rnd.next(26);\n        }\n    } else if (type == \"irregular\") {\n        // Generate a random string that is unlikely to be regular\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    } else if (type == \"same_letter\") {\n        // Generate a string where all beads are the same letter\n        char c = 'a' + rnd.next(26);\n        s = string(n, c);\n    } else if (type == \"alternating_letters\") {\n        // Generate a string with alternating letters\n        char c1 = 'a' + rnd.next(26);\n        char c2 = 'a' + rnd.next(26);\n        while (c2 == c1) {\n            c2 = 'a' + rnd.next(26);\n        }\n        for (int i = 0; i < n; ++i) {\n            s += (i % 2 == 0) ? c1 : c2;\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i) {\n            char c = 'a' + rnd.next(26);\n            s += c;\n        }\n    }\n    // Ensure s is of length n\n    s = s.substr(0, n);\n    while ((int)s.length() < n) {\n        s += 'a' + rnd.next(26);\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output n and k\n    printf(\"%d %d\\n\", n, k);\n\n    // Generate and output the bead sequence\n    string s = generate_sequence(n, k, type);\n    cout << s << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -type random\n./gen -n 1 -k 1 -type same_letter\n\n./gen -n 10 -k 0 -type regular_emptyA\n./gen -n 10 -k 0 -type regular_emptyB\n\n./gen -n 20 -k 1 -type alternating_letters\n./gen -n 20 -k 2 -type regular_non_empty\n\n./gen -n 50 -k 5 -type regular_emptyA\n./gen -n 50 -k 5 -type regular_emptyB\n./gen -n 50 -k 5 -type irregular\n\n./gen -n 1000 -k 100 -type regular_non_empty\n\n./gen -n 10000 -k 100 -type same_letter\n\n./gen -n 100000 -k 1000 -type regular_emptyA\n./gen -n 100000 -k 1000 -type regular_emptyB\n./gen -n 100000 -k 1000 -type irregular\n\n./gen -n 1000000 -k 100000 -type random\n./gen -n 1000000 -k 100000 -type regular_non_empty\n\n./gen -n 999999 -k 99999 -type regular_emptyA\n./gen -n 999999 -k 99999 -type regular_emptyB\n\n./gen -n 1000000 -k 500000 -type alternating_letters\n./gen -n 1000000 -k 1 -type regular_non_empty\n\n./gen -n 1000000 -k 0 -type same_letter\n\n./gen -n 1000000 -k 1000000 -type random\n\n./gen -n 1000 -k 500 -type irregular\n./gen -n 1000 -k 0 -type regular_emptyB\n\n./gen -n 123456 -k 789 -type random\n./gen -n 999999 -k 50000 -type regular_non_empty\n\n./gen -n 1000000 -k 333333 -type regular_emptyA\n./gen -n 1000000 -k 333333 -type regular_emptyB\n\n./gen -n 500000 -k 250000 -type regular_non_empty\n./gen -n 500000 -k 0 -type regular_emptyA\n\n./gen -n 2 -k 1 -type regular_non_empty\n\n./gen -n 2 -k 1 -type irregular\n\n./gen -n 3 -k 1 -type regular_non_empty\n\n./gen -n 100 -k 50 -type same_letter\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:44.907415",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/E",
      "title": "E. Transmitting Levels",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test3 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, q (2 ≤ n ≤ 106, 1 ≤ q ≤ 50) — the number of levels in the game universe and the number of distinct values of b that you need to process.The second line contains n integers ai (1 ≤ ai ≤ 109) — the sizes of the levels in bytes.The next q lines contain integers bj (), determining the values of constant b, for which you need to determine the answer.",
      "output_spec": "OutputFor each value of kj from the input print on a single line integer mj (1 ≤ mj ≤ n), determining the minimum number of groups to divide game levels into for transmission via network observing the given conditions.",
      "sample_tests": "ExamplesInputCopy6 32 4 2 1 3 2746OutputCopy243",
      "description": "E. Transmitting Levels\n\ntime limit per test3 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, q (2 ≤ n ≤ 106, 1 ≤ q ≤ 50) — the number of levels in the game universe and the number of distinct values of b that you need to process.The second line contains n integers ai (1 ≤ ai ≤ 109) — the sizes of the levels in bytes.The next q lines contain integers bj (), determining the values of constant b, for which you need to determine the answer.\n\nOutputFor each value of kj from the input print on a single line integer mj (1 ≤ mj ≤ n), determining the minimum number of groups to divide game levels into for transmission via network observing the given conditions.\n\nInputCopy6 32 4 2 1 3 2746OutputCopy243\n\nInputCopy6 32 4 2 1 3 2746\n\nOutputCopy243\n\nNoteIn the test from the statement you can do in the following manner.  at b = 7 you can divide into two segments: 2|421|32 (note that one of the segments contains the fifth, sixth and first levels);  at b = 4 you can divide into four segments: 2|4|21|3|2;  at b = 6 you can divide into three segments: 24|21|32|.",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Hello, Codeforces!The problems were suggested by users roosephu and Sunayuki. The great help in preparing was provided by Aksenov239, GlebsHP and Codeforces team. ZeptoLab Team did its best while working on statements.The round will use smoother dynamic problem scores with 250 points steps.In 2014 we hosted our first programming contest together with Codeforces, and we liked it!Let me shortly remind you how it was. The contest consisted of 6 problems, 2.5 hours were given to solve (you can have a look at the problems of the previous year and try to solve them here).Of course, even on a purely coding event we stayed true to ourselves, so all problems were designed based on our games, and, of course, we illustrated them with care: Zepto Code Rush 2014 broke the existing Codeforces record of round popularity. Also we were glad to read a positive feedback about problems. By the way, the first three places were taken by developers from Russia. Some of them even came to pick up the prizes at the office, where they had a mini-tour and the highlight of the program: of course, the game in a giant Cut The Rope and our standard corporate \"going green\" welcome kit at the entrance (we call \"going green\" a welcome kit, full of fun gizmos of our corporate green color). Somebody got even luckier: they stayed for more than just a tour and they still amaze us with their professional achievements. Here're some thoughts from one of them, Grisha WhiteCrow Nazarov: I first came for the candies (just kidding), but if I share experiences now — what's especially important is that I can be myself here to the end. Zeptolabians are tolerant of my oddities and appreciate me as a person. In addition, Zeptolab leaders set goals, taking into account the abilities of each developer, including me. And when the head is also \"into\" algorithms, I can realease my potential. In the end I became a sort of client-side back-end developer, which, in fact, I wanted in the first place. Yes, I know some of the data structures that are unlikely to come in handy in Zeptolab soon (they would be more useful, for example, in developing a search engine); I almost never use this part of my knowledge in my daily routine. But these skills are useful to me on the internal algorithmic contests :) What I can say about Working moments: my last task was to improve packaging of atlases in preparing of game resources – a well-known NP-hard problem. I managed to make significant progress: to improve the famous algorithms, the best in 2013 in a variety of metrics. As a result, the memory consumption in all our game projects decreased by megabytes. With the appetite of our artists, I think it's not for long :) Maybe we'll publish my work in one of the next conferences. Overall, sports programming skills are highly valued here, and this, in my experience, is what isn't appreciated enough in other companies. And this post is made to inform you, dear algorithm lovers, that: Zepto Code Rush 2015 starts on Saturday, April, 4, 16:30 (UTC).We are working on problems for the contest and ready, but we are ready to announce cool prizes! You cannot get a vest like that in other ways besides taking part in the contest. The vests are great! And as usual, the person who shows good results in the competition, will be able to get a job in our company by a simplified scheme. You can read about ZeptoLab on our official website. Want to apply to ZeptoLab? ZeptoLab Code Rush 2015 will use standard Codeforces rules, it will be a rated round for the both divisions.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3544
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 50, \"q\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        sum_ai += ai[i];\n    }\n\n    for (int i = 0; i < q; ++i) {\n        long long b = inf.readLong(1, sum_ai, \"b\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 50, \"q\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        sum_ai += ai[i];\n    }\n\n    for (int i = 0; i < q; ++i) {\n        long long b = inf.readLong(1, sum_ai, \"b\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(2, 1000000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 50, \"q\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 1, 1000000000, \"ai\");\n    inf.readEoln();\n\n    long long sum_ai = 0;\n    for (int i = 0; i < n; ++i) {\n        sum_ai += ai[i];\n    }\n\n    for (int i = 0; i < q; ++i) {\n        long long b = inf.readLong(1, sum_ai, \"b\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 1);\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n    // Other possible options\n\n    vector<int> a(n);\n\n    // Generate a_i according to a_type\n    if (a_type == \"min\") {\n        // All a_i = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (a_type == \"max\") {\n        // All a_i = 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = (int)1e9;\n    } else if (a_type == \"random\") {\n        // Random values between 1 and 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    } else if (a_type == \"random_large\") {\n        // Random values between 1e9/2 and 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next((int)1e9/2, (int)1e9);\n    } else if (a_type == \"random_small\") {\n        // Random values between 1 and 1000\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else if (a_type == \"alternating\") {\n        // Alternating 1 and 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : (int)1e9;\n    } else if (a_type == \"increasing\") {\n        // Increasing from 1 to 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = 1 + (int)((1e9 - 1) * i / (n - 1));\n    } else if (a_type == \"decreasing\") {\n        // Decreasing from 1e9 to 1\n        for (int i = 0; i < n; ++i)\n            a[i] = (int)1e9 - (int)((1e9 - 1) * i / (n - 1));\n    } else if (a_type == \"constant\") {\n        // All a_i equal to a specific value given as parameter\n        int avalue = opt<int>(\"avalue\");\n        for (int i = 0; i < n; ++i)\n            a[i] = avalue;\n    } else if (a_type == \"special_wrap\") {\n        // Build a_i that can expose wrapping around between n and 1\n        // For example, set the last element a[n-1] to a large value\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        a[n-1] = (int)1e9;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Now generate b_j values\n    vector<long long> b(q); // Use long long for safety\n\n    long long total_a = 0;\n    for (int i = 0; i < n; ++i) {\n        total_a += a[i];\n    }\n\n    int max_a_i = *max_element(a.begin(), a.end());\n\n    if (b_type == \"min\") {\n        // All b_j = max_a_i\n        for (int i = 0; i < q; ++i)\n            b[i] = max_a_i;\n    } else if (b_type == \"max\") {\n        // All b_j = total_a\n        for (int i = 0; i < q; ++i)\n            b[i] = total_a;\n    } else if (b_type == \"random\") {\n        // Random values between max_a_i and total_a\n        for (int i = 0; i < q; ++i)\n            b[i] = rnd.next((long long)max_a_i, total_a);\n    } else if (b_type == \"special\") {\n        // Include special cases\n        for (int i = 0; i < q; ++i) {\n            if (i % 5 == 0)\n                b[i] = max_a_i; // min possible b_j\n            else if (i % 5 == 1)\n                b[i] = total_a; // max possible b_j\n            else if (i % 5 == 2)\n                b[i] = max_a_i + 1; // Just above max_a_i\n            else if (i % 5 == 3)\n                b[i] = max_a_i + rnd.next(1LL, total_a - max_a_i);\n            else if (i % 5 == 4)\n                b[i] = total_a / n; // Average\n            // Ensure b[i] ≥ max_a_i\n            if (b[i] < max_a_i)\n                b[i] = max_a_i;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < q; ++i)\n            b[i] = rnd.next((long long)max_a_i, total_a);\n    }\n\n    // Output n q\n    printf(\"%d %d\\n\", n, q);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output b_j\n    for (int i = 0; i < q; ++i)\n        printf(\"%lld\\n\", b[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 1);\n    string a_type = opt<string>(\"a_type\", \"random\");\n    string b_type = opt<string>(\"b_type\", \"random\");\n    // Other possible options\n\n    vector<int> a(n);\n\n    // Generate a_i according to a_type\n    if (a_type == \"min\") {\n        // All a_i = 1\n        for (int i = 0; i < n; ++i)\n            a[i] = 1;\n    } else if (a_type == \"max\") {\n        // All a_i = 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = (int)1e9;\n    } else if (a_type == \"random\") {\n        // Random values between 1 and 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    } else if (a_type == \"random_large\") {\n        // Random values between 1e9/2 and 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next((int)1e9/2, (int)1e9);\n    } else if (a_type == \"random_small\") {\n        // Random values between 1 and 1000\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, 1000);\n    } else if (a_type == \"alternating\") {\n        // Alternating 1 and 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = (i % 2 == 0) ? 1 : (int)1e9;\n    } else if (a_type == \"increasing\") {\n        // Increasing from 1 to 1e9\n        for (int i = 0; i < n; ++i)\n            a[i] = 1 + (int)((1e9 - 1) * i / (n - 1));\n    } else if (a_type == \"decreasing\") {\n        // Decreasing from 1e9 to 1\n        for (int i = 0; i < n; ++i)\n            a[i] = (int)1e9 - (int)((1e9 - 1) * i / (n - 1));\n    } else if (a_type == \"constant\") {\n        // All a_i equal to a specific value given as parameter\n        int avalue = opt<int>(\"avalue\");\n        for (int i = 0; i < n; ++i)\n            a[i] = avalue;\n    } else if (a_type == \"special_wrap\") {\n        // Build a_i that can expose wrapping around between n and 1\n        // For example, set the last element a[n-1] to a large value\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n        a[n-1] = (int)1e9;\n    } else {\n        // Default to random\n        for (int i = 0; i < n; ++i)\n            a[i] = rnd.next(1, (int)1e9);\n    }\n\n    // Now generate b_j values\n    vector<long long> b(q); // Use long long for safety\n\n    long long total_a = 0;\n    for (int i = 0; i < n; ++i) {\n        total_a += a[i];\n    }\n\n    int max_a_i = *max_element(a.begin(), a.end());\n\n    if (b_type == \"min\") {\n        // All b_j = max_a_i\n        for (int i = 0; i < q; ++i)\n            b[i] = max_a_i;\n    } else if (b_type == \"max\") {\n        // All b_j = total_a\n        for (int i = 0; i < q; ++i)\n            b[i] = total_a;\n    } else if (b_type == \"random\") {\n        // Random values between max_a_i and total_a\n        for (int i = 0; i < q; ++i)\n            b[i] = rnd.next((long long)max_a_i, total_a);\n    } else if (b_type == \"special\") {\n        // Include special cases\n        for (int i = 0; i < q; ++i) {\n            if (i % 5 == 0)\n                b[i] = max_a_i; // min possible b_j\n            else if (i % 5 == 1)\n                b[i] = total_a; // max possible b_j\n            else if (i % 5 == 2)\n                b[i] = max_a_i + 1; // Just above max_a_i\n            else if (i % 5 == 3)\n                b[i] = max_a_i + rnd.next(1LL, total_a - max_a_i);\n            else if (i % 5 == 4)\n                b[i] = total_a / n; // Average\n            // Ensure b[i] ≥ max_a_i\n            if (b[i] < max_a_i)\n                b[i] = max_a_i;\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < q; ++i)\n            b[i] = rnd.next((long long)max_a_i, total_a);\n    }\n\n    // Output n q\n    printf(\"%d %d\\n\", n, q);\n    // Output a_i\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", a[i]);\n        if (i + 1 < n)\n            printf(\" \");\n        else\n            printf(\"\\n\");\n    }\n\n    // Output b_j\n    for (int i = 0; i < q; ++i)\n        printf(\"%lld\\n\", b[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -q 1 -a_type min -b_type min\n./gen -n 2 -q 1 -a_type max -b_type max\n./gen -n 5 -q 3 -a_type random -b_type random\n./gen -n 5 -q 3 -a_type alternating -b_type special\n./gen -n 100 -q 5 -a_type increasing -b_type random\n./gen -n 100 -q 5 -a_type decreasing -b_type random\n./gen -n 1000 -q 10 -a_type random -b_type min\n./gen -n 1000 -q 10 -a_type random -b_type max\n./gen -n 10000 -q 20 -a_type alternating -b_type special\n./gen -n 100000 -q 30 -a_type random -b_type random\n./gen -n 1000000 -q 50 -a_type min -b_type max\n./gen -n 100 -q 10 -a_type constant -avalue 123456789 -b_type special\n./gen -n 1000000 -q 50 -a_type constant -avalue 1 -b_type min\n./gen -n 1000000 -q 50 -a_type max -b_type max\n./gen -n 1000000 -q 50 -a_type min -b_type random\n./gen -n 1000000 -q 50 -a_type increasing -b_type random\n./gen -n 1000000 -q 50 -a_type decreasing -b_type random\n./gen -n 1000000 -q 1 -a_type random -b_type random\n./gen -n 1000000 -q 50 -a_type random -b_type special\n./gen -n 1000000 -q 50 -a_type alternating -b_type random\n./gen -n 2 -q 2 -a_type max -b_type random\n./gen -n 5 -q 50 -a_type random -b_type special\n./gen -n 1000000 -q 50 -a_type max -b_type special\n./gen -n 1000000 -q 50 -a_type random_large -b_type random\n./gen -n 1000000 -q 50 -a_type random_small -b_type random\n./gen -n 1000000 -q 50 -a_type special_wrap -b_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:46.760653",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/F",
      "title": "F. Pudding Monsters",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains a single integer n (1 ≤ n ≤ 3 × 105) — the size of the initial field.Next n lines contain the coordinates of the cells initially containing monsters. The i-th of the next lines contains two numbers ri, ci (1 ≤ ri, ci ≤ n) — the row number and the column number of the cell that initially contains the i-th monster.It is guaranteed that all ri are distinct numbers and all ci are distinct numbers.",
      "output_spec": "OutputPrint the number of distinct square fragments of the original field that can form a new map.",
      "sample_tests": "ExamplesInputCopy51 14 33 22 45 5OutputCopy10",
      "description": "F. Pudding Monsters\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains a single integer n (1 ≤ n ≤ 3 × 105) — the size of the initial field.Next n lines contain the coordinates of the cells initially containing monsters. The i-th of the next lines contains two numbers ri, ci (1 ≤ ri, ci ≤ n) — the row number and the column number of the cell that initially contains the i-th monster.It is guaranteed that all ri are distinct numbers and all ci are distinct numbers.\n\nOutputPrint the number of distinct square fragments of the original field that can form a new map.\n\nInputCopy51 14 33 22 45 5OutputCopy10\n\nInputCopy51 14 33 22 45 5\n\nOutputCopy10",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Hello, Codeforces!The problems were suggested by users roosephu and Sunayuki. The great help in preparing was provided by Aksenov239, GlebsHP and Codeforces team. ZeptoLab Team did its best while working on statements.The round will use smoother dynamic problem scores with 250 points steps.In 2014 we hosted our first programming contest together with Codeforces, and we liked it!Let me shortly remind you how it was. The contest consisted of 6 problems, 2.5 hours were given to solve (you can have a look at the problems of the previous year and try to solve them here).Of course, even on a purely coding event we stayed true to ourselves, so all problems were designed based on our games, and, of course, we illustrated them with care: Zepto Code Rush 2014 broke the existing Codeforces record of round popularity. Also we were glad to read a positive feedback about problems. By the way, the first three places were taken by developers from Russia. Some of them even came to pick up the prizes at the office, where they had a mini-tour and the highlight of the program: of course, the game in a giant Cut The Rope and our standard corporate \"going green\" welcome kit at the entrance (we call \"going green\" a welcome kit, full of fun gizmos of our corporate green color). Somebody got even luckier: they stayed for more than just a tour and they still amaze us with their professional achievements. Here're some thoughts from one of them, Grisha WhiteCrow Nazarov: I first came for the candies (just kidding), but if I share experiences now — what's especially important is that I can be myself here to the end. Zeptolabians are tolerant of my oddities and appreciate me as a person. In addition, Zeptolab leaders set goals, taking into account the abilities of each developer, including me. And when the head is also \"into\" algorithms, I can realease my potential. In the end I became a sort of client-side back-end developer, which, in fact, I wanted in the first place. Yes, I know some of the data structures that are unlikely to come in handy in Zeptolab soon (they would be more useful, for example, in developing a search engine); I almost never use this part of my knowledge in my daily routine. But these skills are useful to me on the internal algorithmic contests :) What I can say about Working moments: my last task was to improve packaging of atlases in preparing of game resources – a well-known NP-hard problem. I managed to make significant progress: to improve the famous algorithms, the best in 2013 in a variety of metrics. As a result, the memory consumption in all our game projects decreased by megabytes. With the appetite of our artists, I think it's not for long :) Maybe we'll publish my work in one of the next conferences. Overall, sports programming skills are highly valued here, and this, in my experience, is what isn't appreciated enough in other companies. And this post is made to inform you, dear algorithm lovers, that: Zepto Code Rush 2015 starts on Saturday, April, 4, 16:30 (UTC).We are working on problems for the contest and ready, but we are ready to announce cool prizes! You cannot get a vest like that in other ways besides taking part in the contest. The vests are great! And as usual, the person who shows good results in the competition, will be able to get a job in our company by a simplified scheme. You can read about ZeptoLab on our official website. Want to apply to ZeptoLab? ZeptoLab Code Rush 2015 will use standard Codeforces rules, it will be a rated round for the both divisions.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3544
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    unordered_set<int> used_r;\n    unordered_set<int> used_c;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(used_r.count(ri) == 0, \"Row number ri = %d is not unique\", ri);\n        used_r.insert(ri);\n\n        ensuref(used_c.count(ci) == 0, \"Column number ci = %d is not unique\", ci);\n        used_c.insert(ci);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    unordered_set<int> used_r;\n    unordered_set<int> used_c;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(used_r.count(ri) == 0, \"Row number ri = %d is not unique\", ri);\n        used_r.insert(ri);\n\n        ensuref(used_c.count(ci) == 0, \"Column number ci = %d is not unique\", ci);\n        used_c.insert(ci);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300000, \"n\");\n    inf.readEoln();\n\n    unordered_set<int> used_r;\n    unordered_set<int> used_c;\n\n    for (int i = 0; i < n; i++) {\n        int ri = inf.readInt(1, n, \"ri\");\n        inf.readSpace();\n        int ci = inf.readInt(1, n, \"ci\");\n        inf.readEoln();\n\n        ensuref(used_r.count(ri) == 0, \"Row number ri = %d is not unique\", ri);\n        used_r.insert(ri);\n\n        ensuref(used_c.count(ci) == 0, \"Column number ci = %d is not unique\", ci);\n        used_c.insert(ci);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> r(n);\n    vector<int> c(n);\n    for(int i = 0; i < n; ++i) {\n        r[i] = i + 1;\n        c[i] = i + 1;\n    }\n\n    if(type == \"identity\") {\n        // ri = i + 1; ci = i + 1 (already set)\n\n    } else if(type == \"reverse\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = n - i;\n        }\n    } else if(type == \"shift\") {\n        int shift = opt<int>(\"shift\", 0);\n        for(int i = 0; i < n; ++i) {\n            c[i] = (i + shift) % n + 1;\n        }\n    } else if(type == \"zigzag\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                c[i] = i + 1;\n            } else {\n                c[i] = n - i;\n            }\n        }\n    } else if(type == \"random\") {\n        shuffle(c.begin(), c.end());\n    } else {\n        // default to random\n        shuffle(c.begin(), c.end());\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", r[i], c[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> r(n);\n    vector<int> c(n);\n    for(int i = 0; i < n; ++i) {\n        r[i] = i + 1;\n        c[i] = i + 1;\n    }\n\n    if(type == \"identity\") {\n        // ri = i + 1; ci = i + 1 (already set)\n\n    } else if(type == \"reverse\") {\n        for(int i = 0; i < n; ++i) {\n            c[i] = n - i;\n        }\n    } else if(type == \"shift\") {\n        int shift = opt<int>(\"shift\", 0);\n        for(int i = 0; i < n; ++i) {\n            c[i] = (i + shift) % n + 1;\n        }\n    } else if(type == \"zigzag\") {\n        for(int i = 0; i < n; ++i) {\n            if (i % 2 == 0) {\n                c[i] = i + 1;\n            } else {\n                c[i] = n - i;\n            }\n        }\n    } else if(type == \"random\") {\n        shuffle(c.begin(), c.end());\n    } else {\n        // default to random\n        shuffle(c.begin(), c.end());\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", r[i], c[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type identity\n./gen -n 2 -type identity\n./gen -n 2 -type reverse\n./gen -n 5 -type identity\n./gen -n 5 -type reverse\n./gen -n 5 -type shift -shift 0\n./gen -n 5 -type shift -shift 1\n./gen -n 5 -type shift -shift 2\n./gen -n 5 -type zigzag\n./gen -n 5 -type random\n./gen -n 10 -type identity\n./gen -n 10 -type reverse\n./gen -n 10 -type shift -shift 3\n./gen -n 10 -type zigzag\n./gen -n 10 -type random\n./gen -n 50 -type identity\n./gen -n 50 -type reverse\n./gen -n 50 -type shift -shift 25\n./gen -n 50 -type zigzag\n./gen -n 50 -type random\n./gen -n 100 -type identity\n./gen -n 100 -type shift -shift 50\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 300000 -type random\n./gen -n 300000 -type reverse\n./gen -n 300000 -type zigzag\n./gen -n 299999 -type shift -shift 150000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:48.598310",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "526/G",
      "title": "G. Spiders Evil Plan",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains numbers n and q (1 ≤ n, q ≤ 105) — the number of nodes in the structure and the number of questions that the spiders want to ask you.The next n - 1 lines determine the rope structure. The i-th line contains three integers ui, vi, li (1 ≤ ui, vi ≤ n, ui ≠ vi, 1 ≤ li ≤ 1000), showing that there is a rope of length li between nodes ui and vi.Next q lines describe the spiders' questions. As they want you to answer their question online, they encoded their messages in a special manner.Each of the next q lines contains two numbers xi, yi. In the first question of the spiders x = x1, y = y1.To calculate values x and y in the spiders' i-th (2 ≤ i ≤ q) question, you need to use the following formulas:where Ansi - 1 is the total length of the ropes covered by a web in the answer for the (i - 1)-th question.The following inequality holds: 1 ≤ xi, yi ≤ n.",
      "output_spec": "OutputFor each question of the spiders print on a separate line a single integer Ansi — the total length of the ropes covered with web in the optimal plan.",
      "sample_tests": "ExamplesInputCopy6 31 2 22 3 23 4 24 6 13 5 103 12 51 1OutputCopy141317",
      "description": "G. Spiders Evil Plan\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains numbers n and q (1 ≤ n, q ≤ 105) — the number of nodes in the structure and the number of questions that the spiders want to ask you.The next n - 1 lines determine the rope structure. The i-th line contains three integers ui, vi, li (1 ≤ ui, vi ≤ n, ui ≠ vi, 1 ≤ li ≤ 1000), showing that there is a rope of length li between nodes ui and vi.Next q lines describe the spiders' questions. As they want you to answer their question online, they encoded their messages in a special manner.Each of the next q lines contains two numbers xi, yi. In the first question of the spiders x = x1, y = y1.To calculate values x and y in the spiders' i-th (2 ≤ i ≤ q) question, you need to use the following formulas:where Ansi - 1 is the total length of the ropes covered by a web in the answer for the (i - 1)-th question.The following inequality holds: 1 ≤ xi, yi ≤ n.\n\nOutputFor each question of the spiders print on a separate line a single integer Ansi — the total length of the ropes covered with web in the optimal plan.\n\nInputCopy6 31 2 22 3 23 4 24 6 13 5 103 12 51 1OutputCopy141317\n\nInputCopy6 31 2 22 3 23 4 24 6 13 5 103 12 51 1\n\nOutputCopy141317",
      "solutions": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces",
          "content": "Hello, Codeforces!The problems were suggested by users roosephu and Sunayuki. The great help in preparing was provided by Aksenov239, GlebsHP and Codeforces team. ZeptoLab Team did its best while working on statements.The round will use smoother dynamic problem scores with 250 points steps.In 2014 we hosted our first programming contest together with Codeforces, and we liked it!Let me shortly remind you how it was. The contest consisted of 6 problems, 2.5 hours were given to solve (you can have a look at the problems of the previous year and try to solve them here).Of course, even on a purely coding event we stayed true to ourselves, so all problems were designed based on our games, and, of course, we illustrated them with care: Zepto Code Rush 2014 broke the existing Codeforces record of round popularity. Also we were glad to read a positive feedback about problems. By the way, the first three places were taken by developers from Russia. Some of them even came to pick up the prizes at the office, where they had a mini-tour and the highlight of the program: of course, the game in a giant Cut The Rope and our standard corporate \"going green\" welcome kit at the entrance (we call \"going green\" a welcome kit, full of fun gizmos of our corporate green color). Somebody got even luckier: they stayed for more than just a tour and they still amaze us with their professional achievements. Here're some thoughts from one of them, Grisha WhiteCrow Nazarov: I first came for the candies (just kidding), but if I share experiences now — what's especially important is that I can be myself here to the end. Zeptolabians are tolerant of my oddities and appreciate me as a person. In addition, Zeptolab leaders set goals, taking into account the abilities of each developer, including me. And when the head is also \"into\" algorithms, I can realease my potential. In the end I became a sort of client-side back-end developer, which, in fact, I wanted in the first place. Yes, I know some of the data structures that are unlikely to come in handy in Zeptolab soon (they would be more useful, for example, in developing a search engine); I almost never use this part of my knowledge in my daily routine. But these skills are useful to me on the internal algorithmic contests :) What I can say about Working moments: my last task was to improve packaging of atlases in preparing of game resources – a well-known NP-hard problem. I managed to make significant progress: to improve the famous algorithms, the best in 2013 in a variety of metrics. As a result, the memory consumption in all our game projects decreased by megabytes. With the appetite of our artists, I think it's not for long :) Maybe we'll publish my work in one of the next conferences. Overall, sports programming skills are highly valued here, and this, in my experience, is what isn't appreciated enough in other companies. And this post is made to inform you, dear algorithm lovers, that: Zepto Code Rush 2015 starts on Saturday, April, 4, 16:30 (UTC).We are working on problems for the contest and ready, but we are ready to announce cool prizes! You cannot get a vest like that in other ways besides taking part in the contest. The vests are great! And as usual, the person who shows good results in the competition, will be able to get a job in our company by a simplified scheme. You can read about ZeptoLab on our official website. Want to apply to ZeptoLab? ZeptoLab Code Rush 2015 will use standard Codeforces rules, it will be a rated round for the both divisions.",
          "author": "viktork",
          "url": "https://codeforces.com/blog/entry/17154",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3544
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces",
          "content": "Hello everyone, I hope you can enjoy this special round for Zepto Lab. Here are the solutions of this round.A. King of ThievesThis task is easy for many of you. We can just iterate over all possible i1 and i2 - i1, then we can compute i3, ..., 5, and check whether this subsequence satisfies the condition mentioned in the task.B. Om Nom and Dark ParkWe use greedy and recursion to solve this task. For each tree rooted at v, we adjust its two subtrees at first, using recursion. Then we increase one edge from v's child to v.C. Om Nom and CandiesIf there is a kind of candy which weighs greater than , then we can iterate over the number of it to buy, which is less than .Otherwise, without loss of generality we suppose . If the number of the blue candies that Om Nom eats is more than Wr, he could eat Wb red candies instead of Wr blue candies, because Hb × Wr < Wb × Hr. It means the number of the blue candies will be less than , and we can iterate over this number.D. Om Nom and NecklaceThis task is to determine whether a string is in the form of ABABA... ABA for each prefixes of a given string SFor a prefix P, let's split it into some blocks, just like P = SSSS... SSSST, which T is a prefix of S. Obviously, if we use KMP algorithm, we can do it in linear time, and the length of S will be minimal. There are only two cases : T = S, T ≠ S. T = S. When T = S, P = SSS... S. Assume that S appears R times. Consider \"ABABAB....ABABA\", the last A must be a suffix of P, and it must be like SS... S, so A will be like SS... SS, and so will B. By greedy algorithm, the length of A will be minimal, so it will be SSS... S, where S appears times. And B will be SSS... S, where S appears times. So we just need to check whether . T ≠ S . When T ≠ S, the strategy is similar to T = S. A will be like \"SS...ST\", and its length will be minimal. At last we just need to check whether . The total time complexity is O(n).E. Transmitting LevelsOur task is to compute at least how many number of blocks are needed to partition a circular sequence into blocks whose sum is less than K. By monotonicity, it is easy to get the length of maximal blocks which starts from 1 to n in O(n). Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A. So, we can iterate over all the T numbers of A, making it the start of a block, and calculate the number of blocks. Notice that all the lengths of blocks is (non-strictly) greater than T, therefore the number of blocks we need is at most N / T + 1. We need to iterate T times, but each time we can get the answer in O(N / T), so finally we can check whether the answer is legal in T * O(N / T) = O(N).F. Pudding MonstersActually this problem is to compute how many segments in a permutation forms a permutation of successive integers. We use divide and conquer to solve this problem. If we want to compute the answer for an interval [1, n], we divide this interval into two smaller ones [1, m], [m + 1, n] where . We only care about the segments which crosses m. We call the first interval L and the latter one R. Considering the positiions of maximum numbers and minimum numbers in these valid segments, There are four possible cases: the maximum number is in L, the the minimum is also in L; the maximum number is in R, the the minimum is also in R; the maximum number is in L, the the minimum is in R; the maximum number is in R, the the minimum is in L; Let A be the given sequence and we define Lmaxp = maxp ≤ i ≤ mAi. Similarly we can define Rmaxp, Rminp, Lminp. For simplicity we only cares about case 1 and case 4. In Case 1, we iterate over the start position of the segment, so we know the maximum and minimum number so we can compute the length of the segment and check the corresponding segment using Rmin and Rmax. In Case 4, we iterate over the start position again, denoted as x. Suppose the right end is y, then we know that Lminx < Rminy, Lmaxx < Rmaxy so we can limit y into some range. Another constraint for y is that Rmaxy - Lminx = y - x, i.e. Rmaxy - y = Lminx - x. Note that when x varies, the valid range for y also varies, but the range is monotone, so we can maintain how many times a number appears in linear time. It's easy to show that this algorithm runs for , by Master Theorem. There are some other people using segment trees. You can see a nice implement hereG. Spiders Evil PlanIn this task, we are given a tree and many queries. In each query, we are supposed to calculate the maximum total length of y paths with the constraint that x must be covered. Consider S is the union of the paths (it contains nodes and edges).For each query (x, y), if  y > 1 , then there is always a method that S is connected.Further, we could get the following theorem: For an unrooted tree, if it has 2k leaves, then k paths can cover this tree completely. Proof for this theorem is that, if some edge u - v is not covered, we can interchange two paths, i.e. we change two paths a - b and c - d to a - c and b - d, for a - b in the subtree of u and c - d in the subtree of v. So a query (x, y) could be described as :Find 2y leaves in the tree, with node x in S, and maximize the total of weight of the edges in S.For a query (x, y), we can make x the root. Then this task is how to choose the leaves. Note that we could select leaves one by one, every time we select the leaf which makes answer larger without selecting the others, as follow :But if for every query we need to change the root, the time complexity cannot be accepted. Assuming the longest path in the tree is (a, b) , we could find that whatever the query is, S will contain either a or b certainly.So, we just need to make a and b the root in turn, and get the maximum answers. However, there is another problem : x may not be in S. Like this :But it doesn't matter. We just need to link x with the selected, and erase some leaf. Of course after erasing, the answer should be maximum. Thanks, for all of your excellent performance!",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17281",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 6044
        }
      ],
      "code_examples": [
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 1",
          "code": "<s>test</s>",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 2",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 3",
          "code": "We supposed that Hr/Wr > Hb/Wb, Hr*Wb > Hb*Wr",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 4",
          "code": "(blue candy)*(Wr)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 5",
          "code": "(red candy)*(Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 6",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 7",
          "code": "12 1\n10 13 14 8 15 11 8 1 7 14 10 11\n61",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 8",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 9",
          "code": "int check[100]={0};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 10",
          "code": "100 *****...******",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 11",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 12",
          "code": "for(int i=0;i<s.size();i++)\n{\n    if(s[i]=='*')\n        check[i+1]=1;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 13",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 - Codeforces - Code 14",
          "code": "for(int i = 0; i < ot.size(); i+=2){\n  out += ot[i]*ot[i+1];\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17154",
          "author": "viktork"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 1",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 2",
          "code": "I. QB*WB + QR*WR <= C",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 3",
          "code": "abaabaabaabaabaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 4",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 5",
          "code": "for (i = 0; i <= c / wb; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 6",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 7",
          "code": "// Assume that Wr < sqrt(C) and Wb < sqrt(C) and Hb * Wr <= Wb * Hr.\nfor (i = 0; i <= wr; i++) {\n    // Eat i blue candies and floor((c - i * wb) / wr) red candies.\n    long long cur = i * hb + (c - i * wb) / wr * hr;\n    if (cur > ans) ans = cur;\n}",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 8",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 9",
          "code": "lcm(Wr, Wh)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 10",
          "code": "lcm / Wr * Hr > lcm / Wb * Hb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 11",
          "code": "max(0, C % lcm + lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 12",
          "code": "C % lcm + lcm < 2 * lcm",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 13",
          "code": "max(Wr, Wb)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 14",
          "code": "max(C, 2 * lcm)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 15",
          "code": "min(C, 2*lcm)/Wmax",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 16",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 17",
          "code": "O(min(C/Wmax, Wmin))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 18",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 19",
          "code": "(1)   int64_t q = (int64_t)((long double)a * (long double)b / (long double)m);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 20",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 21",
          "code": "(2)   int64_t r = a * b - q * m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 22",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 23",
          "code": "(3)  return (r + 5 * m) % m;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 24",
          "code": "long double",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 25",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 26",
          "code": "idx = [0123456789X] (X is ten...)\nbeads = \"abcabcabcab\"\n  pre = [00012345678]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 27",
          "code": "beads[0..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 28",
          "code": "beads[0..5]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 29",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 30",
          "code": "beads[9..10]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 31",
          "code": "beads[0..1]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 32",
          "code": "beads[0..2]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 33",
          "code": "beads[0..idx - pre[idx]]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 34",
          "code": "beads[0..idx % (idx - pre[idx] + 1)]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 35",
          "code": "beads[0..i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 36",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        },
        {
          "title": "ZeptoLab Code Rush 2015 — Editorial - Codeforces - Code 37",
          "code": "Assume the block with minimal length is A and its length is T, it is obvious that whatever the blocks are, there must be a block that it starts in A.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17281",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and q\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAXN, \"q\");\n    inf.readEoln();\n\n    // Read n - 1 edges\n    typedef pair<int,int> pii;\n    set<pii> edge_set;\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < n -1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge cannot connect a node to itself\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000, \"l_i\");\n        inf.readEoln();\n\n        // Check for multiple edges\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edge_set.find(make_pair(a,b)) == edge_set.end(), \"Multiple edges between same pair of nodes\");\n        edge_set.insert(make_pair(a,b));\n\n        // Build adjacency list for connectivity check\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check that the graph is connected and acyclic\n    // We can use DFS\n    vector<bool> visited(n + 1, false);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        cnt++;\n        for (int v : adj[u]) {\n            if (!visited[v]) dfs(v);\n        }\n    };\n    dfs(1);\n    ensuref(cnt == n, \"The graph is not connected\");\n\n    // Read q queries\n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and q\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAXN, \"q\");\n    inf.readEoln();\n\n    // Read n - 1 edges\n    typedef pair<int,int> pii;\n    set<pii> edge_set;\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < n -1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge cannot connect a node to itself\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000, \"l_i\");\n        inf.readEoln();\n\n        // Check for multiple edges\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edge_set.find(make_pair(a,b)) == edge_set.end(), \"Multiple edges between same pair of nodes\");\n        edge_set.insert(make_pair(a,b));\n\n        // Build adjacency list for connectivity check\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check that the graph is connected and acyclic\n    // We can use DFS\n    vector<bool> visited(n + 1, false);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        cnt++;\n        for (int v : adj[u]) {\n            if (!visited[v]) dfs(v);\n        }\n    };\n    dfs(1);\n    ensuref(cnt == n, \"The graph is not connected\");\n\n    // Read q queries\n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    // Read n and q\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, MAXN, \"q\");\n    inf.readEoln();\n\n    // Read n - 1 edges\n    typedef pair<int,int> pii;\n    set<pii> edge_set;\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < n -1; ++i) {\n        int u = inf.readInt(1, n, \"u_i\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v_i\");\n        ensuref(u != v, \"Edge cannot connect a node to itself\");\n        inf.readSpace();\n        int li = inf.readInt(1, 1000, \"l_i\");\n        inf.readEoln();\n\n        // Check for multiple edges\n        int a = min(u, v);\n        int b = max(u, v);\n        ensuref(edge_set.find(make_pair(a,b)) == edge_set.end(), \"Multiple edges between same pair of nodes\");\n        edge_set.insert(make_pair(a,b));\n\n        // Build adjacency list for connectivity check\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check that the graph is connected and acyclic\n    // We can use DFS\n    vector<bool> visited(n + 1, false);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int u) {\n        visited[u] = true;\n        cnt++;\n        for (int v : adj[u]) {\n            if (!visited[v]) dfs(v);\n        }\n    };\n    dfs(1);\n    ensuref(cnt == n, \"The graph is not connected\");\n\n    // Read q queries\n    for (int i = 0; i < q; ++i) {\n        int xi = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int yi = inf.readInt(1, n, \"y_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 100000);\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    int max_length = opt<int>(\"max_length\", 1000);\n    int min_length = opt<int>(\"min_length\", 1);\n    string edge_length_type = opt<string>(\"edge_length_type\", \"random\");\n    int x_fixed = opt<int>(\"x_fixed\", 0);\n    int y_fixed = opt<int>(\"y_fixed\", 0);\n    bool x_equals_y = opt<bool>(\"x_equals_y\", false);\n\n    // Generate the tree according to tree_type\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree: connects each node to the previous node\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        // Shuffle the edges to create randomness\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Assign lengths to edges\n    vector<int> lengths;\n    for (int i = 0; i < n - 1; ++i) {\n        int len;\n        if (edge_length_type == \"min\") {\n            len = min_length;\n        } else if (edge_length_type == \"max\") {\n            len = max_length;\n        } else if (edge_length_type == \"alternate\") {\n            len = (i % 2 == 0) ? min_length : max_length;\n        } else {\n            len = rnd.next(min_length, max_length);\n        }\n        lengths.push_back(len);\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Shuffle the edge output order\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Output the edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u = perm[edges[i].first];\n        int v = perm[edges[i].second];\n        printf(\"%d %d %d\\n\", u, v, lengths[i]);\n    }\n\n    // Generate q queries\n    for (int i = 0; i < q; ++i) {\n        int x, y;\n        if (x_fixed) {\n            x = x_fixed;\n        } else {\n            x = rnd.next(1, n);\n        }\n        if (x_equals_y) {\n            y = x;\n        } else if (y_fixed) {\n            y = y_fixed;\n        } else {\n            y = rnd.next(1, n);\n        }\n        printf(\"%d %d\\n\", x, y);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int q = opt<int>(\"q\", 100000);\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    int max_length = opt<int>(\"max_length\", 1000);\n    int min_length = opt<int>(\"min_length\", 1);\n    string edge_length_type = opt<string>(\"edge_length_type\", \"random\");\n    int x_fixed = opt<int>(\"x_fixed\", 0);\n    int y_fixed = opt<int>(\"y_fixed\", 0);\n    bool x_equals_y = opt<bool>(\"x_equals_y\", false);\n\n    // Generate the tree according to tree_type\n    vector<pair<int, int>> edges;\n\n    if (tree_type == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (tree_type == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (tree_type == \"balanced\") {\n        // Build a balanced binary tree\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i / 2, i});\n        }\n    } else if (tree_type == \"skewed\") {\n        // Skewed tree: connects each node to the previous node\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n        // Shuffle the edges to create randomness\n        shuffle(edges.begin(), edges.end());\n    } else {\n        // Random tree\n        for (int i = 2; i <= n; ++i) {\n            int u = rnd.next(1, i - 1);\n            edges.push_back({u, i});\n        }\n        shuffle(edges.begin(), edges.end());\n    }\n\n    // Assign lengths to edges\n    vector<int> lengths;\n    for (int i = 0; i < n - 1; ++i) {\n        int len;\n        if (edge_length_type == \"min\") {\n            len = min_length;\n        } else if (edge_length_type == \"max\") {\n            len = max_length;\n        } else if (edge_length_type == \"alternate\") {\n            len = (i % 2 == 0) ? min_length : max_length;\n        } else {\n            len = rnd.next(min_length, max_length);\n        }\n        lengths.push_back(len);\n    }\n\n    // Output n and q\n    printf(\"%d %d\\n\", n, q);\n\n    // Shuffle the edge output order\n    vector<int> perm(n + 1);\n    for (int i = 1; i <= n; ++i) perm[i] = i;\n    shuffle(perm.begin() + 1, perm.end());\n\n    // Output the edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u = perm[edges[i].first];\n        int v = perm[edges[i].second];\n        printf(\"%d %d %d\\n\", u, v, lengths[i]);\n    }\n\n    // Generate q queries\n    for (int i = 0; i < q; ++i) {\n        int x, y;\n        if (x_fixed) {\n            x = x_fixed;\n        } else {\n            x = rnd.next(1, n);\n        }\n        if (x_equals_y) {\n            y = x;\n        } else if (y_fixed) {\n            y = y_fixed;\n        } else {\n            y = rnd.next(1, n);\n        }\n        printf(\"%d %d\\n\", x, y);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -q 5 -tree_type chain -edge_length_type min\n./gen -n 10 -q 5 -tree_type chain -edge_length_type max\n./gen -n 10 -q 5 -tree_type chain -edge_length_type alternate\n./gen -n 1000 -q 1000 -tree_type chain -edge_length_type random\n./gen -n 10 -q 5 -tree_type star -edge_length_type min\n./gen -n 10 -q 5 -tree_type star -edge_length_type max\n./gen -n 1000 -q 1000 -tree_type star -edge_length_type random\n./gen -n 5000 -q 5000 -tree_type balanced -edge_length_type random\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type random\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type min\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type max\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type alternate\n./gen -n 100000 -q 100000 -tree_type balanced -edge_length_type random\n./gen -n 100000 -q 100000 -tree_type balanced -edge_length_type max\n./gen -n 100000 -q 100000 -tree_type chain -edge_length_type random\n./gen -n 100000 -q 100000 -tree_type chain -edge_length_type min\n./gen -n 100000 -q 100000 -tree_type star -edge_length_type random\n./gen -n 100000 -q 100000 -tree_type star -edge_length_type min\n./gen -n 100000 -q 100000 -tree_type star -edge_length_type max\n./gen -n 100000 -q 100000 -tree_type skewed -edge_length_type random\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type random -x_equals_y\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type random -x_fixed 1 -y_fixed 1\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type random -x_fixed 1\n./gen -n 100000 -q 100000 -tree_type random -edge_length_type random -y_fixed 1\n./gen -n 1000 -q 1000 -tree_type chain -edge_length_type random -x_equals_y\n./gen -n 1000 -q 1000 -tree_type star -edge_length_type random -x_equals_y\n./gen -n 10 -q 5 -tree_type chain -edge_length_type random -x_equals_y\n./gen -n 10 -q 5 -tree_type star -edge_length_type random -x_equals_y\n./gen -n 2 -q 1 -tree_type chain -edge_length_type random\n./gen -n 3 -q 3 -tree_type chain -edge_length_type random\n./gen -n 1 -q 1 -tree_type chain -edge_length_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:50.544322",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "527/A",
      "title": "A. Playing with Paper",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of the input contains two integers a, b (1 ≤ b < a ≤ 1012) — the sizes of the original sheet of paper.",
      "output_spec": "OutputPrint a single integer — the number of ships that Vasya will make.",
      "sample_tests": "ExamplesInputCopy2 1OutputCopy2InputCopy10 7OutputCopy6InputCopy1000000000000 1OutputCopy1000000000000",
      "description": "A. Playing with Paper\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of the input contains two integers a, b (1 ≤ b < a ≤ 1012) — the sizes of the original sheet of paper.\n\nOutputPrint a single integer — the number of ships that Vasya will make.\n\nInputCopy2 1OutputCopy2InputCopy10 7OutputCopy6InputCopy1000000000000 1OutputCopy1000000000000\n\nInputCopy2 1\n\nOutputCopy2\n\nInputCopy10 7\n\nOutputCopy6\n\nInputCopy1000000000000 1\n\nOutputCopy1000000000000\n\nNotePictures to the first and second sample test.",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces",
          "content": "527A - Playing with PaperIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Error Correct SystemThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Glass CarvingObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Clique ProblemOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≥ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Data Center DramaProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Fuzzy SearchThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Triangles 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 527\\s*A"
          },
          "content_length": 8264
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(2LL, 1000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, a - 1, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(2LL, 1000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, a - 1, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    long long a = inf.readLong(2LL, 1000000000000LL, \"a\");\n    inf.readSpace();\n    long long b = inf.readLong(1LL, a - 1, \"b\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long maxa = opt<long long>(\"maxa\", 1000000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long a, b;\n    if (type == \"random\") {\n        a = rnd.next(2LL, maxa);\n        b = rnd.next(1LL, a - 1);\n    } else if (type == \"max_cases\") {\n        a = maxa;\n        b = a - 1;\n    } else if (type == \"min_cases\") {\n        a = 2;\n        b = 1;\n    } else if (type == \"equal_case\") {\n        if (maxa == 2) {\n            a = 2;\n            b = 1;\n        } else {\n            b = rnd.next(1LL, maxa - 1);\n            a = b + 1;\n        }\n    } else if (type == \"big_a_small_b\") {\n        a = maxa;\n        b = 1;\n    } else if (type == \"a_mod_b_zero\") {\n        bool found = false;\n        int attempts = 0;\n        while (!found && attempts < 10) {\n            b = rnd.next(1LL, maxa / 2); // Ensure that maxa / b ≥ 2\n            long long k_upper = maxa / b;\n            if (k_upper >= 2LL) {\n                long long k = rnd.next(2LL, k_upper);\n                a = b * k;\n                if (a <= maxa && a > b) {\n                    found = true;\n                    break;\n                }\n            }\n            attempts++;\n        }\n        if (!found) {\n            // Fallback to default values\n            a = 2;\n            b = 1;\n        }\n    } else if (type == \"fib_case\") {\n        // Generate two large Fibonacci numbers less than maxa\n        vector<long long> fibs = {1LL, 1LL};\n        while (true) {\n            long long next = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n            if (next > maxa) break;\n            fibs.push_back(next);\n        }\n        if (fibs.size() < 3) {\n            // Cannot generate fib_case, fallback to min_cases\n            a = 2;\n            b = 1;\n        } else {\n            int idx = rnd.next(2, (int)fibs.size() - 1);\n            a = fibs[idx];\n            b = fibs[idx - 1];\n        }\n    } else if (type == \"power_of_two\") {\n        long long max_power = 1;\n        while ((max_power << 1) <= maxa) max_power <<= 1;\n        if (max_power == 1) {\n            a = 2;\n            b = 1;\n        } else {\n            a = max_power;\n            b = a >> 1;\n        }\n    } else {\n        // default to random\n        a = rnd.next(2LL, maxa);\n        b = rnd.next(1LL, a - 1);\n    }\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    long long maxa = opt<long long>(\"maxa\", 1000000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n\n    long long a, b;\n    if (type == \"random\") {\n        a = rnd.next(2LL, maxa);\n        b = rnd.next(1LL, a - 1);\n    } else if (type == \"max_cases\") {\n        a = maxa;\n        b = a - 1;\n    } else if (type == \"min_cases\") {\n        a = 2;\n        b = 1;\n    } else if (type == \"equal_case\") {\n        if (maxa == 2) {\n            a = 2;\n            b = 1;\n        } else {\n            b = rnd.next(1LL, maxa - 1);\n            a = b + 1;\n        }\n    } else if (type == \"big_a_small_b\") {\n        a = maxa;\n        b = 1;\n    } else if (type == \"a_mod_b_zero\") {\n        bool found = false;\n        int attempts = 0;\n        while (!found && attempts < 10) {\n            b = rnd.next(1LL, maxa / 2); // Ensure that maxa / b ≥ 2\n            long long k_upper = maxa / b;\n            if (k_upper >= 2LL) {\n                long long k = rnd.next(2LL, k_upper);\n                a = b * k;\n                if (a <= maxa && a > b) {\n                    found = true;\n                    break;\n                }\n            }\n            attempts++;\n        }\n        if (!found) {\n            // Fallback to default values\n            a = 2;\n            b = 1;\n        }\n    } else if (type == \"fib_case\") {\n        // Generate two large Fibonacci numbers less than maxa\n        vector<long long> fibs = {1LL, 1LL};\n        while (true) {\n            long long next = fibs[fibs.size() - 1] + fibs[fibs.size() - 2];\n            if (next > maxa) break;\n            fibs.push_back(next);\n        }\n        if (fibs.size() < 3) {\n            // Cannot generate fib_case, fallback to min_cases\n            a = 2;\n            b = 1;\n        } else {\n            int idx = rnd.next(2, (int)fibs.size() - 1);\n            a = fibs[idx];\n            b = fibs[idx - 1];\n        }\n    } else if (type == \"power_of_two\") {\n        long long max_power = 1;\n        while ((max_power << 1) <= maxa) max_power <<= 1;\n        if (max_power == 1) {\n            a = 2;\n            b = 1;\n        } else {\n            a = max_power;\n            b = a >> 1;\n        }\n    } else {\n        // default to random\n        a = rnd.next(2LL, maxa);\n        b = rnd.next(1LL, a - 1);\n    }\n\n    printf(\"%lld %lld\\n\", a, b);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min_cases\n./gen -type max_cases\n./gen -type equal_case -maxa 10\n./gen -type equal_case -maxa 1000000000000\n./gen -type random -maxa 10\n./gen -type random -maxa 100\n./gen -type random -maxa 1000\n./gen -type random -maxa 10000\n./gen -type random -maxa 100000\n./gen -type random -maxa 1000000\n./gen -type random -maxa 1000000000\n./gen -type random -maxa 1000000000000\n./gen -type big_a_small_b -maxa 10\n./gen -type big_a_small_b -maxa 100\n./gen -type big_a_small_b -maxa 10000\n./gen -type big_a_small_b -maxa 100000\n./gen -type big_a_small_b -maxa 1000000000000\n./gen -type a_mod_b_zero -maxa 10\n./gen -type a_mod_b_zero -maxa 100\n./gen -type a_mod_b_zero -maxa 10000\n./gen -type a_mod_b_zero -maxa 100000\n./gen -type a_mod_b_zero -maxa 1000000000000\n./gen -type fib_case -maxa 10\n./gen -type fib_case -maxa 100\n./gen -type fib_case -maxa 10000\n./gen -type fib_case -maxa 100000\n./gen -type fib_case -maxa 1000000000000\n./gen -type power_of_two -maxa 10\n./gen -type power_of_two -maxa 100\n./gen -type power_of_two -maxa 10000\n./gen -type power_of_two -maxa 100000\n./gen -type power_of_two -maxa 1000000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:52.634844",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "527/B",
      "title": "B. Error Correct System",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.The second line contains string S.The third line contains string T.Each of the lines only contains lowercase Latin letters.",
      "output_spec": "OutputIn the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print \"-1 -1\", if it is not necessary to swap characters.If there are multiple possible answers, print any of them.",
      "sample_tests": "ExamplesInputCopy9pergamentpermanentOutputCopy14 6InputCopy6wookiecookieOutputCopy1-1 -1InputCopy4petregorOutputCopy21 2InputCopy6doublebundleOutputCopy24 1",
      "description": "B. Error Correct System\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 200 000) — the length of strings S and T.The second line contains string S.The third line contains string T.Each of the lines only contains lowercase Latin letters.\n\nOutputIn the first line, print number x — the minimum possible Hamming distance between strings S and T if you swap at most one pair of letters in S.In the second line, either print the indexes i and j (1 ≤ i, j ≤ n, i ≠ j), if reaching the minimum possible distance is possible by swapping letters on positions i and j, or print \"-1 -1\", if it is not necessary to swap characters.If there are multiple possible answers, print any of them.\n\nInputCopy9pergamentpermanentOutputCopy14 6InputCopy6wookiecookieOutputCopy1-1 -1InputCopy4petregorOutputCopy21 2InputCopy6doublebundleOutputCopy24 1\n\nInputCopy9pergamentpermanent\n\nOutputCopy14 6\n\nInputCopy6wookiecookie\n\nOutputCopy1-1 -1\n\nInputCopy4petregor\n\nOutputCopy21 2\n\nInputCopy6doublebundle\n\nOutputCopy24 1\n\nNoteIn the second test it is acceptable to print i = 2, j = 3.",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces",
          "content": "527A - Playing with PaperIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Error Correct SystemThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Glass CarvingObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Clique ProblemOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≥ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Data Center DramaProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Fuzzy SearchThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Triangles 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 527\\s*B"
          },
          "content_length": 8264
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    string S = inf.readLine(\"[a-z]+\", \"S\");\n    ensuref((int)S.length() == n, \"Length of S is %d, expected %d\", (int)S.length(), n);\n    string T = inf.readLine(\"[a-z]+\", \"T\");\n    ensuref((int)T.length() == n, \"Length of T is %d, expected %d\", (int)T.length(), n);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    string S = inf.readLine(\"[a-z]+\", \"S\");\n    ensuref((int)S.length() == n, \"Length of S is %d, expected %d\", (int)S.length(), n);\n    string T = inf.readLine(\"[a-z]+\", \"T\");\n    ensuref((int)T.length() == n, \"Length of T is %d, expected %d\", (int)T.length(), n);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    string S = inf.readLine(\"[a-z]+\", \"S\");\n    ensuref((int)S.length() == n, \"Length of S is %d, expected %d\", (int)S.length(), n);\n    string T = inf.readLine(\"[a-z]+\", \"T\");\n    ensuref((int)T.length() == n, \"Length of T is %d, expected %d\", (int)T.length(), n);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Read n from the input file\n    string S = inf.readToken(); // Read S from the input file\n    string T = inf.readToken(); // Read T from the input file\n\n    if (S.length() != n || T.length() != n)\n        quitf(_fail, \"Input strings have incorrect lengths.\");\n\n    int initial_hamming_distance = 0;\n    vector<int> mismatches;\n    for (int i = 0; i < n; ++i) {\n        if (S[i] != T[i]) {\n            initial_hamming_distance++;\n            mismatches.push_back(i);\n        }\n    }\n\n    int min_possible_distance = initial_hamming_distance;\n    int best_i = -1, best_j = -1;\n\n    // First, try to find a swap that reduces the Hamming distance by 2\n    bool found = false;\n    for (int idx = 0; idx < mismatches.size(); ++idx) {\n        int i = mismatches[idx];\n        for (int jdx = 0; jdx < mismatches.size(); ++jdx) {\n            if (idx == jdx)\n                continue;\n            int j = mismatches[jdx];\n            if (S[i] == T[j] && S[j] == T[i]) {\n                min_possible_distance = initial_hamming_distance - 2;\n                best_i = i + 1; // +1 to match problem's 1-based indexing\n                best_j = j + 1;\n                found = true;\n                break;\n            }\n        }\n        if (found)\n            break;\n    }\n\n    // If no such swap is found, try to find a swap that reduces the Hamming distance by 1\n    if (!found) {\n        map<char, vector<int>> char_positions;\n        for (int i = 0; i < n; ++i) {\n            char_positions[S[i]].push_back(i);\n        }\n\n        for (int idx = 0; idx < mismatches.size(); ++idx) {\n            int i = mismatches[idx];\n            char needed_char = T[i];\n            for (int j : char_positions[needed_char]) {\n                if (S[j] != T[j]) {\n                    min_possible_distance = initial_hamming_distance - 1;\n                    best_i = i + 1; // +1 to match problem's 1-based indexing\n                    best_j = j + 1;\n                    found = true;\n                    break;\n                }\n            }\n            if (found)\n                break;\n        }\n    }\n\n    int participant_x = ouf.readInt();\n    int participant_i = ouf.readInt();\n    int participant_j = ouf.readInt();\n\n    if (participant_i == -1 && participant_j == -1) {\n        // No swap performed\n        if (participant_x != initial_hamming_distance)\n            quitf(_wa, \"Reported distance %d does not match initial Hamming distance %d without swapping.\", participant_x, initial_hamming_distance);\n    } else {\n        // Swap performed\n        if (participant_i < 1 || participant_i > n || participant_j < 1 || participant_j > n || participant_i == participant_j)\n            quitf(_wa, \"Invalid swap positions: i = %d, j = %d.\", participant_i, participant_j);\n\n        // Adjust for 0-based indexing\n        participant_i--;\n        participant_j--;\n\n        // Swap the characters in S\n        swap(S[participant_i], S[participant_j]);\n\n        // Compute new Hamming distance\n        int new_hamming_distance = 0;\n        for (int i = 0; i < n; ++i) {\n            if (S[i] != T[i])\n                new_hamming_distance++;\n        }\n\n        if (participant_x != new_hamming_distance)\n            quitf(_wa, \"Reported distance %d does not match computed Hamming distance %d after swapping positions %d and %d.\", participant_x, new_hamming_distance, participant_i + 1, participant_j + 1);\n    }\n\n    if (participant_x != min_possible_distance)\n        quitf(_wa, \"Reported distance %d is not minimal, minimal possible distance is %d.\", participant_x, min_possible_distance);\n\n    quitf(_ok, \"Correct answer with minimal possible distance %d.\", min_possible_distance);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string S(n, 'a'), T(n, 'a');\n    if (type == \"random\") {\n        // Generate random S and T\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"identical\") {\n        // S and T are identical\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = S[i];\n        }\n    } else if (type == \"opposite\") {\n        // S and T are completely different\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            do {\n                T[i] = 'a' + rnd.next(26);\n            } while (T[i] == S[i]);\n        }\n    } else if (type == \"swap_improves\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = S[i];\n        }\n        if (n >= 2) {\n            int i = rnd.next(0, n - 1);\n            int j;\n            do {\n                j = rnd.next(0, n - 1);\n            } while (j == i);\n            // Ensure S[i] != S[j]\n            while (S[i] == S[j]) {\n                S[j] = 'a' + rnd.next(26);\n                T[j] = S[j];\n            }\n            swap(S[i], S[j]);\n            // Now S differs from T at positions i and j\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = 'a' + rnd.next(26);\n        }\n    }\n    // Output\n    cout << n << endl;\n    cout << S << endl;\n    cout << T << endl;\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string S(n, 'a'), T(n, 'a');\n    if (type == \"random\") {\n        // Generate random S and T\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = 'a' + rnd.next(26);\n        }\n    } else if (type == \"identical\") {\n        // S and T are identical\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = S[i];\n        }\n    } else if (type == \"opposite\") {\n        // S and T are completely different\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            do {\n                T[i] = 'a' + rnd.next(26);\n            } while (T[i] == S[i]);\n        }\n    } else if (type == \"swap_improves\") {\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = S[i];\n        }\n        if (n >= 2) {\n            int i = rnd.next(0, n - 1);\n            int j;\n            do {\n                j = rnd.next(0, n - 1);\n            } while (j == i);\n            // Ensure S[i] != S[j]\n            while (S[i] == S[j]) {\n                S[j] = 'a' + rnd.next(26);\n                T[j] = S[j];\n            }\n            swap(S[i], S[j]);\n            // Now S differs from T at positions i and j\n        }\n    } else {\n        // default to random\n        for (int i = 0; i < n; ++i) {\n            S[i] = 'a' + rnd.next(26);\n            T[i] = 'a' + rnd.next(26);\n        }\n    }\n    // Output\n    cout << n << endl;\n    cout << S << endl;\n    cout << T << endl;\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 1 -type identical\n./gen -n 2 -type identical\n./gen -n 10 -type identical\n./gen -n 1000 -type identical\n./gen -n 10000 -type identical\n./gen -n 100000 -type identical\n./gen -n 200000 -type identical\n\n./gen -n 1 -type opposite\n./gen -n 2 -type opposite\n./gen -n 10 -type opposite\n./gen -n 1000 -type opposite\n./gen -n 10000 -type opposite\n./gen -n 100000 -type opposite\n./gen -n 200000 -type opposite\n\n./gen -n 2 -type swap_improves\n./gen -n 10 -type swap_improves\n./gen -n 1000 -type swap_improves\n./gen -n 10000 -type swap_improves\n./gen -n 100000 -type swap_improves\n./gen -n 200000 -type swap_improves\n\n./gen -n 2 -type random\n./gen -n 3 -type random\n./gen -n 4 -type random\n./gen -n 5 -type random\n./gen -n 6 -type random\n./gen -n 7 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:54.569160",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "527/C",
      "title": "C. Glass Carving",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.",
      "output_spec": "OutputAfter each cut print on a single line the area of the maximum available glass fragment in mm2.",
      "sample_tests": "ExamplesInputCopy4 3 4H 2V 2V 3V 1OutputCopy8442InputCopy7 6 5H 4V 3V 5H 2V 1OutputCopy28161264",
      "description": "C. Glass Carving\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.\n\nOutputAfter each cut print on a single line the area of the maximum available glass fragment in mm2.\n\nInputCopy4 3 4H 2V 2V 3V 1OutputCopy8442InputCopy7 6 5H 4V 3V 5H 2V 1OutputCopy28161264\n\nInputCopy4 3 4H 2V 2V 3V 1\n\nOutputCopy8442\n\nInputCopy7 6 5H 4V 3V 5H 2V 1\n\nOutputCopy28161264\n\nNotePicture for the first sample test:    Picture for the second sample test:",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces",
          "content": "527A - Playing with PaperIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Error Correct SystemThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Glass CarvingObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Clique ProblemOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≥ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Data Center DramaProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Fuzzy SearchThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Triangles 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 527 和字母"
          },
          "content_length": 8264
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(2, 200000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 200000, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> horizontalCuts;\n    set<int> verticalCuts;\n\n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'H' || c == 'V', \"Expected 'H' or 'V', but got '%c'\", c);\n        inf.readSpace();\n        int pos;\n        if (c == 'H') {\n            pos = inf.readInt(1, h - 1, \"pos\");\n            ensuref(horizontalCuts.count(pos) == 0, \"Duplicate horizontal cut at %d\", pos);\n            horizontalCuts.insert(pos);\n        } else { // c == 'V'\n            pos = inf.readInt(1, w - 1, \"pos\");\n            ensuref(verticalCuts.count(pos) == 0, \"Duplicate vertical cut at %d\", pos);\n            verticalCuts.insert(pos);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(2, 200000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 200000, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> horizontalCuts;\n    set<int> verticalCuts;\n\n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'H' || c == 'V', \"Expected 'H' or 'V', but got '%c'\", c);\n        inf.readSpace();\n        int pos;\n        if (c == 'H') {\n            pos = inf.readInt(1, h - 1, \"pos\");\n            ensuref(horizontalCuts.count(pos) == 0, \"Duplicate horizontal cut at %d\", pos);\n            horizontalCuts.insert(pos);\n        } else { // c == 'V'\n            pos = inf.readInt(1, w - 1, \"pos\");\n            ensuref(verticalCuts.count(pos) == 0, \"Duplicate vertical cut at %d\", pos);\n            verticalCuts.insert(pos);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(2, 200000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 200000, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> horizontalCuts;\n    set<int> verticalCuts;\n\n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'H' || c == 'V', \"Expected 'H' or 'V', but got '%c'\", c);\n        inf.readSpace();\n        int pos;\n        if (c == 'H') {\n            pos = inf.readInt(1, h - 1, \"pos\");\n            ensuref(horizontalCuts.count(pos) == 0, \"Duplicate horizontal cut at %d\", pos);\n            horizontalCuts.insert(pos);\n        } else { // c == 'V'\n            pos = inf.readInt(1, w - 1, \"pos\");\n            ensuref(verticalCuts.count(pos) == 0, \"Duplicate vertical cut at %d\", pos);\n            verticalCuts.insert(pos);\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\");\n    int h = opt<int>(\"h\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output w, h, n\n    printf(\"%d %d %d\\n\", w, h, n);\n\n    vector<pair<char, int>> cuts;\n\n    set<int> v_cuts;\n    set<int> h_cuts;\n\n    if (type == \"random\") {\n        // Generate random cuts\n        while ((int)cuts.size() < n) {\n            int c = rnd.next(0, 1); // 0 for H, 1 for V\n            if (c == 0) {\n                // Horizontal cut\n                if ((int)h_cuts.size() >= h - 1) continue; // No more positions\n                int y = rnd.next(1, h - 1);\n                if (h_cuts.count(y)) continue;\n                h_cuts.insert(y);\n                cuts.push_back({'H', y});\n            } else {\n                // Vertical cut\n                if ((int)v_cuts.size() >= w - 1) continue;\n                int x = rnd.next(1, w - 1);\n                if (v_cuts.count(x)) continue;\n                v_cuts.insert(x);\n                cuts.push_back({'V', x});\n            }\n        }\n    } else if (type == \"vertical\") {\n        // All vertical cuts\n        if (w - 1 < n) {\n            fprintf(stderr, \"Cannot have %d vertical cuts with w = %d\\n\", n, w);\n            exit(1);\n        }\n        vector<int> positions;\n        for (int x = 1; x <= w - 1; x++) {\n            positions.push_back(x);\n        }\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; i++) {\n            int x = positions[i];\n            cuts.push_back({'V', x});\n        }\n    } else if (type == \"horizontal\") {\n        // All horizontal cuts\n        if (h - 1 < n) {\n            fprintf(stderr, \"Cannot have %d horizontal cuts with h = %d\\n\", n, h);\n            exit(1);\n        }\n        vector<int> positions;\n        for (int y = 1; y <= h - 1; y++) {\n            positions.push_back(y);\n        }\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; i++) {\n            int y = positions[i];\n            cuts.push_back({'H', y});\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between vertical and horizontal\n        int max_vcuts = w - 1;\n        int max_hcuts = h - 1;\n        int total_possible_cuts = max_vcuts + max_hcuts;\n        if (n > total_possible_cuts) {\n            fprintf(stderr, \"Cannot have %d cuts with w = %d and h = %d\\n\", n, w, h);\n            exit(1);\n        }\n\n        vector<int> v_positions;\n        for (int x = 1; x <= w - 1; x++) {\n            v_positions.push_back(x);\n        }\n        shuffle(v_positions.begin(), v_positions.end());\n\n        vector<int> h_positions;\n        for (int y = 1; y <= h - 1; y++) {\n            h_positions.push_back(y);\n        }\n        shuffle(h_positions.begin(), h_positions.end());\n\n        int vi = 0, hi = 0;\n        while ((int)cuts.size() < n) {\n            if ((int)cuts.size() % 2 == 0) {\n                // Vertical\n                if (vi < (int)v_positions.size()) {\n                    int x = v_positions[vi++];\n                    cuts.push_back({'V', x});\n                } else if (hi < (int)h_positions.size()) {\n                    int y = h_positions[hi++];\n                    cuts.push_back({'H', y});\n                } else {\n                    break;\n                }\n            } else {\n                // Horizontal\n                if (hi < (int)h_positions.size()) {\n                    int y = h_positions[hi++];\n                    cuts.push_back({'H', y});\n                } else if (vi < (int)v_positions.size()) {\n                    int x = v_positions[vi++];\n                    cuts.push_back({'V', x});\n                } else {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"worstcase\") {\n        // Cuts designed to split the largest fragment each time\n        // For simplicity, we can simulate making cuts at middle positions\n\n        // Since we need to have unique cuts, we need to manage positions\n        set<int> v_positions;\n        set<int> h_positions;\n        v_positions.insert(0);\n        v_positions.insert(w);\n        h_positions.insert(0);\n        h_positions.insert(h);\n\n        for (int i = 0; i < n; i++) {\n            // Decide whether to make vertical or horizontal cut\n            int c;\n            if (i % 2 == 0) c = 1; // Vertical\n            else c = 0; // Horizontal\n\n            if (c == 1) {\n                // Vertical cut\n                // Find the widest vertical segment\n                int max_gap = 0;\n                int pos = -1;\n                int prev = 0;\n                for (auto it = v_positions.begin(); it != v_positions.end(); ++it) {\n                    int curr = *it;\n                    if (curr - prev > max_gap) {\n                        max_gap = curr - prev;\n                        pos = prev + (curr - prev) / 2;\n                    }\n                    prev = curr;\n                }\n                if (pos <= 0 || pos >= w || v_cuts.count(pos)) {\n                    // No more cuts possible\n                    continue;\n                }\n                v_positions.insert(pos);\n                v_cuts.insert(pos);\n                cuts.push_back({'V', pos});\n            } else {\n                // Horizontal cut\n                // Find the highest horizontal segment\n                int max_gap = 0;\n                int pos = -1;\n                int prev = 0;\n                for (auto it = h_positions.begin(); it != h_positions.end(); ++it) {\n                    int curr = *it;\n                    if (curr - prev > max_gap) {\n                        max_gap = curr - prev;\n                        pos = prev + (curr - prev) / 2;\n                    }\n                    prev = curr;\n                }\n                if (pos <= 0 || pos >= h || h_cuts.count(pos)) {\n                    // No more cuts possible\n                    continue;\n                }\n                h_positions.insert(pos);\n                h_cuts.insert(pos);\n                cuts.push_back({'H', pos});\n            }\n        }\n    } else {\n        // Default: Random cuts\n        // So fall back to 'random' type\n        while ((int)cuts.size() < n) {\n            int c = rnd.next(0, 1); // 0 for H, 1 for V\n            if (c == 0) {\n                // Horizontal cut\n                if ((int)h_cuts.size() >= h - 1) continue; // No more positions\n                int y = rnd.next(1, h - 1);\n                if (h_cuts.count(y)) continue;\n                h_cuts.insert(y);\n                cuts.push_back({'H', y});\n            } else {\n                // Vertical cut\n                if ((int)v_cuts.size() >= w - 1) continue;\n                int x = rnd.next(1, w - 1);\n                if (v_cuts.count(x)) continue;\n                v_cuts.insert(x);\n                cuts.push_back({'V', x});\n            }\n        }\n    }\n\n    // Output the cuts\n\n    for (auto cut : cuts) {\n        printf(\"%c %d\\n\", cut.first, cut.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\");\n    int h = opt<int>(\"h\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output w, h, n\n    printf(\"%d %d %d\\n\", w, h, n);\n\n    vector<pair<char, int>> cuts;\n\n    set<int> v_cuts;\n    set<int> h_cuts;\n\n    if (type == \"random\") {\n        // Generate random cuts\n        while ((int)cuts.size() < n) {\n            int c = rnd.next(0, 1); // 0 for H, 1 for V\n            if (c == 0) {\n                // Horizontal cut\n                if ((int)h_cuts.size() >= h - 1) continue; // No more positions\n                int y = rnd.next(1, h - 1);\n                if (h_cuts.count(y)) continue;\n                h_cuts.insert(y);\n                cuts.push_back({'H', y});\n            } else {\n                // Vertical cut\n                if ((int)v_cuts.size() >= w - 1) continue;\n                int x = rnd.next(1, w - 1);\n                if (v_cuts.count(x)) continue;\n                v_cuts.insert(x);\n                cuts.push_back({'V', x});\n            }\n        }\n    } else if (type == \"vertical\") {\n        // All vertical cuts\n        if (w - 1 < n) {\n            fprintf(stderr, \"Cannot have %d vertical cuts with w = %d\\n\", n, w);\n            exit(1);\n        }\n        vector<int> positions;\n        for (int x = 1; x <= w - 1; x++) {\n            positions.push_back(x);\n        }\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; i++) {\n            int x = positions[i];\n            cuts.push_back({'V', x});\n        }\n    } else if (type == \"horizontal\") {\n        // All horizontal cuts\n        if (h - 1 < n) {\n            fprintf(stderr, \"Cannot have %d horizontal cuts with h = %d\\n\", n, h);\n            exit(1);\n        }\n        vector<int> positions;\n        for (int y = 1; y <= h - 1; y++) {\n            positions.push_back(y);\n        }\n        shuffle(positions.begin(), positions.end());\n        for (int i = 0; i < n; i++) {\n            int y = positions[i];\n            cuts.push_back({'H', y});\n        }\n    } else if (type == \"alternate\") {\n        // Alternate between vertical and horizontal\n        int max_vcuts = w - 1;\n        int max_hcuts = h - 1;\n        int total_possible_cuts = max_vcuts + max_hcuts;\n        if (n > total_possible_cuts) {\n            fprintf(stderr, \"Cannot have %d cuts with w = %d and h = %d\\n\", n, w, h);\n            exit(1);\n        }\n\n        vector<int> v_positions;\n        for (int x = 1; x <= w - 1; x++) {\n            v_positions.push_back(x);\n        }\n        shuffle(v_positions.begin(), v_positions.end());\n\n        vector<int> h_positions;\n        for (int y = 1; y <= h - 1; y++) {\n            h_positions.push_back(y);\n        }\n        shuffle(h_positions.begin(), h_positions.end());\n\n        int vi = 0, hi = 0;\n        while ((int)cuts.size() < n) {\n            if ((int)cuts.size() % 2 == 0) {\n                // Vertical\n                if (vi < (int)v_positions.size()) {\n                    int x = v_positions[vi++];\n                    cuts.push_back({'V', x});\n                } else if (hi < (int)h_positions.size()) {\n                    int y = h_positions[hi++];\n                    cuts.push_back({'H', y});\n                } else {\n                    break;\n                }\n            } else {\n                // Horizontal\n                if (hi < (int)h_positions.size()) {\n                    int y = h_positions[hi++];\n                    cuts.push_back({'H', y});\n                } else if (vi < (int)v_positions.size()) {\n                    int x = v_positions[vi++];\n                    cuts.push_back({'V', x});\n                } else {\n                    break;\n                }\n            }\n        }\n    } else if (type == \"worstcase\") {\n        // Cuts designed to split the largest fragment each time\n        // For simplicity, we can simulate making cuts at middle positions\n\n        // Since we need to have unique cuts, we need to manage positions\n        set<int> v_positions;\n        set<int> h_positions;\n        v_positions.insert(0);\n        v_positions.insert(w);\n        h_positions.insert(0);\n        h_positions.insert(h);\n\n        for (int i = 0; i < n; i++) {\n            // Decide whether to make vertical or horizontal cut\n            int c;\n            if (i % 2 == 0) c = 1; // Vertical\n            else c = 0; // Horizontal\n\n            if (c == 1) {\n                // Vertical cut\n                // Find the widest vertical segment\n                int max_gap = 0;\n                int pos = -1;\n                int prev = 0;\n                for (auto it = v_positions.begin(); it != v_positions.end(); ++it) {\n                    int curr = *it;\n                    if (curr - prev > max_gap) {\n                        max_gap = curr - prev;\n                        pos = prev + (curr - prev) / 2;\n                    }\n                    prev = curr;\n                }\n                if (pos <= 0 || pos >= w || v_cuts.count(pos)) {\n                    // No more cuts possible\n                    continue;\n                }\n                v_positions.insert(pos);\n                v_cuts.insert(pos);\n                cuts.push_back({'V', pos});\n            } else {\n                // Horizontal cut\n                // Find the highest horizontal segment\n                int max_gap = 0;\n                int pos = -1;\n                int prev = 0;\n                for (auto it = h_positions.begin(); it != h_positions.end(); ++it) {\n                    int curr = *it;\n                    if (curr - prev > max_gap) {\n                        max_gap = curr - prev;\n                        pos = prev + (curr - prev) / 2;\n                    }\n                    prev = curr;\n                }\n                if (pos <= 0 || pos >= h || h_cuts.count(pos)) {\n                    // No more cuts possible\n                    continue;\n                }\n                h_positions.insert(pos);\n                h_cuts.insert(pos);\n                cuts.push_back({'H', pos});\n            }\n        }\n    } else {\n        // Default: Random cuts\n        // So fall back to 'random' type\n        while ((int)cuts.size() < n) {\n            int c = rnd.next(0, 1); // 0 for H, 1 for V\n            if (c == 0) {\n                // Horizontal cut\n                if ((int)h_cuts.size() >= h - 1) continue; // No more positions\n                int y = rnd.next(1, h - 1);\n                if (h_cuts.count(y)) continue;\n                h_cuts.insert(y);\n                cuts.push_back({'H', y});\n            } else {\n                // Vertical cut\n                if ((int)v_cuts.size() >= w - 1) continue;\n                int x = rnd.next(1, w - 1);\n                if (v_cuts.count(x)) continue;\n                v_cuts.insert(x);\n                cuts.push_back({'V', x});\n            }\n        }\n    }\n\n    // Output the cuts\n\n    for (auto cut : cuts) {\n        printf(\"%c %d\\n\", cut.first, cut.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -w 10 -h 10 -n 5 -type random\n./gen -w 10 -h 10 -n 9 -type vertical\n./gen -w 10 -h 10 -n 9 -type horizontal\n./gen -w 10 -h 10 -n 9 -type alternate\n./gen -w 10 -h 10 -n 8 -type worstcase\n\n./gen -w 1000 -h 1000 -n 500 -type random\n./gen -w 1000 -h 1000 -n 999 -type vertical\n./gen -w 1000 -h 1000 -n 999 -type horizontal\n./gen -w 1000 -h 1000 -n 1000 -type alternate\n./gen -w 1000 -h 1000 -n 1000 -type worstcase\n\n./gen -w 200000 -h 200000 -n 200000 -type random\n./gen -w 200000 -h 200000 -n 199999 -type vertical\n./gen -w 200000 -h 200000 -n 199999 -type horizontal\n./gen -w 200000 -h 200000 -n 200000 -type alternate\n./gen -w 200000 -h 200000 -n 200000 -type worstcase\n\n./gen -w 2 -h 200000 -n 199999 -type horizontal\n./gen -w 200000 -h 2 -n 199999 -type vertical\n\n./gen -w 200000 -h 200000 -n 200000 -type horizontal\n./gen -w 200000 -h 200000 -n 200000 -type vertical\n\n./gen -w 200000 -h 200000 -n 200000 -type random\n\n./gen -w 200000 -h 200000 -n 200000 -type worstcase\n\n./gen -w 200000 -h 200000 -n 200000 -type random\n\n./gen -w 200000 -h 2 -n 200000 -type horizontal\n\n./gen -w 2 -h 200000 -n 200000 -type vertical\n\n./gen -w 10 -h 15 -n 20 -type random\n\n./gen -w 200000 -h 200000 -n 200000 -type alternate\n\n./gen -w 100000 -h 100000 -n 100000 -type random\n\n./gen -w 6 -h 3 -n 5 -type random\n\n./gen -w 2 -h 2 -n 1 -type random\n\n./gen -w 200000 -h 200000 -n 1 -type random\n\n./gen -w 200000 -h 200000 -n 200000 -type worstcase\n\n./gen -w 200000 -h 200000 -n 200000 -type alternate\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:56.243923",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "527/D",
      "title": "D. Задача о клике",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано число n (1 ≤ n ≤ 200 000) — количество точек.В каждой из последующих n строк следуют по два числа xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — координата и вес очередной точки. Все координаты xi различны.",
      "output_spec": "Выходные данныеВыведите одно число — количество вершин в максимальной клике образованного графа.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 33 16 10 2Выходные данныеСкопировать3",
      "description": "D. Задача о клике\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано число n (1 ≤ n ≤ 200 000) — количество точек.В каждой из последующих n строк следуют по два числа xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — координата и вес очередной точки. Все координаты xi различны.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество вершин в максимальной клике образованного графа.\n\nВыходные данные\n\nВходные данныеСкопировать42 33 16 10 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать42 33 16 10 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЕсли вы вдруг умеете решать эту задачу, не используя специфические свойства графа, представленного в условии задачи, то вам полагается приз в миллион доллларов!Изображение к тесту из условия:",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Всем привет! Сегодня вечером в обычное время состоится Codeforces Round #296 для обоих дивизионов, автором которого являюсь я.Готовить задачи мне помогали мои сокомандники, члены команды Moscow SU Trinity sankear и malcolm, а также множество ценных советов дал MikeMirzayanov, за что им всем большое спасибо. Переводом условий мы обязаны нашей бессменной переводчице Delinur.Как обычно, вам будет предложено пять задач на два часа. Разбалловка будет оглашена позднее. Приглашаю всех участвовать! Надеюсь, каждый участник найдёт себе что-нибудь по душе в предстоящем раунде.UPD: разбалловка — стандартная.UPD2: в связи с техническими трудностями раунд перенесён на 15 минут вперёд. Приносим извинения за непредвиденную задержку.UPD3: Приносим свои извинения за проблему с задачей Div1-D. Претест #16 не удовлетворял ограничениям n, m, k <= 200000. Системное тестирование для первого дивизиона будет отложено. Если вы считаете, что этот тест серьёзно повлиял на ваши результаты, вы можете написать мне сообщение, и мы сделаем раунд для вас нерейтинговым.Системное тестирование во втором дивизионе произойдёт в ближайшее время в обычном порядке.UPD4: Тестирование завершено. Поздравляем победителей!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: Был добавлен разбор на английском языке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1349
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces",
          "content": "527A - Игра с бумагойIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Система коррекции ошибокThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Разрезание стеклаObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Задача о кликеOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≤ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Страсти в дата-центреProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Нечёткий поискThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Треугольники 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 527 和字母"
          },
          "content_length": 8277
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "Гарантируется, что существует решение, в котором p не превосходит 500 000.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 11",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n    set<int> xset;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000000);\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000000);\n        inf.readEoln();\n        ensuref(xset.count(xi) == 0, \"All xi should be distinct, but xi=%d appears more than once.\", xi);\n        xset.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n    set<int> xset;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000000);\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000000);\n        inf.readEoln();\n        ensuref(xset.count(xi) == 0, \"All xi should be distinct, but xi=%d appears more than once.\", xi);\n        xset.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000);\n    inf.readEoln();\n    set<int> xset;\n    for (int i = 0; i < n; ++i) {\n        int xi = inf.readInt(0, 1000000000);\n        inf.readSpace();\n        int wi = inf.readInt(1, 1000000000);\n        inf.readEoln();\n        ensuref(xset.count(xi) == 0, \"All xi should be distinct, but xi=%d appears more than once.\", xi);\n        xset.insert(xi);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points(n); // pairs of x_i and w_i\n\n    if (type == \"random\") {\n        // Generate random x_i and w_i within the constraints.\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            xs.insert(rnd.next(0, int(1e9)));\n        }\n        vector<int> x(xs.begin(), xs.end());\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = rnd.next(1, int(1e9));\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"max_clique_size_1\") {\n        // Arrange x_i and w_i so that no edges exist\n        // Set w_i = 1e9, and x_i close together\n        vector<int> x(n);\n        for(int i = 0; i < n; ++i) {\n            x[i] = i; // x_i close together\n        }\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = int(1e9);\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"max_clique_size_n\") {\n        // Arrange x_i and w_i so that all edges exist\n        // Set w_i = 1, and x_i such that |x_i - x_j| ≥ 2\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 2; // positions 0, 2, 4, ...\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n        // Shuffle points to avoid any ordering dependencies\n        shuffle(points.begin(), points.end());\n    } else if (type == \"max_weights\") {\n        // All w_i = 1e9, x_i spread out so edges can exist\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 3000000; // Spaced out to satisfy distances\n            int wi = int(1e9);\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"min_weights\") {\n        // All w_i = 1, x_i random\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            xs.insert(rnd.next(0, int(1e9)));\n        }\n        vector<int> x(xs.begin(), xs.end());\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"equal_spacing\") {\n        // x_i equally spaced, w_i = 1\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 10000; // spacing of 10000\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"clustered\") {\n        // x_i within a narrow range\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            xs.insert(rnd.next(0, n * 2)); // x_i from 0 to 2*n\n        }\n        vector<int> x(xs.begin(), xs.end());\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = rnd.next(1, int(1e9));\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"big_weights_small_distances\") {\n        // w_i large, x_i close together\n        for(int i = 0; i < n; ++i) {\n            int xi = i; // x_i close together\n            int wi = int(1e9) - i;\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"small_weights_large_distances\") {\n        // w_i small, x_i far apart\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 10000000; // Large distances\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else {\n        // Default to random data if unknown type\n        for(int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, int(1e9));\n            int wi = rnd.next(1, int(1e9));\n            points[i] = make_pair(xi, wi);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> points(n); // pairs of x_i and w_i\n\n    if (type == \"random\") {\n        // Generate random x_i and w_i within the constraints.\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            xs.insert(rnd.next(0, int(1e9)));\n        }\n        vector<int> x(xs.begin(), xs.end());\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = rnd.next(1, int(1e9));\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"max_clique_size_1\") {\n        // Arrange x_i and w_i so that no edges exist\n        // Set w_i = 1e9, and x_i close together\n        vector<int> x(n);\n        for(int i = 0; i < n; ++i) {\n            x[i] = i; // x_i close together\n        }\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = int(1e9);\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"max_clique_size_n\") {\n        // Arrange x_i and w_i so that all edges exist\n        // Set w_i = 1, and x_i such that |x_i - x_j| ≥ 2\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 2; // positions 0, 2, 4, ...\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n        // Shuffle points to avoid any ordering dependencies\n        shuffle(points.begin(), points.end());\n    } else if (type == \"max_weights\") {\n        // All w_i = 1e9, x_i spread out so edges can exist\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 3000000; // Spaced out to satisfy distances\n            int wi = int(1e9);\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"min_weights\") {\n        // All w_i = 1, x_i random\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            xs.insert(rnd.next(0, int(1e9)));\n        }\n        vector<int> x(xs.begin(), xs.end());\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"equal_spacing\") {\n        // x_i equally spaced, w_i = 1\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 10000; // spacing of 10000\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"clustered\") {\n        // x_i within a narrow range\n        set<int> xs;\n        while ((int)xs.size() < n) {\n            xs.insert(rnd.next(0, n * 2)); // x_i from 0 to 2*n\n        }\n        vector<int> x(xs.begin(), xs.end());\n        shuffle(x.begin(), x.end());\n        for(int i = 0; i < n; ++i) {\n            int xi = x[i];\n            int wi = rnd.next(1, int(1e9));\n            points[i] = make_pair(xi, wi);\n        }\n    } else if (type == \"big_weights_small_distances\") {\n        // w_i large, x_i close together\n        for(int i = 0; i < n; ++i) {\n            int xi = i; // x_i close together\n            int wi = int(1e9) - i;\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else if (type == \"small_weights_large_distances\") {\n        // w_i small, x_i far apart\n        for(int i = 0; i < n; ++i) {\n            int xi = i * 10000000; // Large distances\n            int wi = 1;\n            points[i] = make_pair(xi, wi);\n        }\n        shuffle(points.begin(), points.end());\n    } else {\n        // Default to random data if unknown type\n        for(int i = 0; i < n; ++i) {\n            int xi = rnd.next(0, int(1e9));\n            int wi = rnd.next(1, int(1e9));\n            points[i] = make_pair(xi, wi);\n        }\n    }\n\n    // Output the test case\n    printf(\"%d\\n\", n);\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", points[i].first, points[i].second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 1 -type max_clique_size_1\n./gen -n 2 -type max_clique_size_1\n./gen -n 1000 -type max_clique_size_1\n./gen -n 200000 -type max_clique_size_1\n\n./gen -n 1 -type max_clique_size_n\n./gen -n 2 -type max_clique_size_n\n./gen -n 1000 -type max_clique_size_n\n./gen -n 200000 -type max_clique_size_n\n\n./gen -n 1 -type max_weights\n./gen -n 2 -type max_weights\n./gen -n 1000 -type max_weights\n./gen -n 200000 -type max_weights\n\n./gen -n 1 -type min_weights\n./gen -n 2 -type min_weights\n./gen -n 1000 -type min_weights\n./gen -n 200000 -type min_weights\n\n./gen -n 1000 -type equal_spacing\n./gen -n 200000 -type equal_spacing\n\n./gen -n 1000 -type clustered\n./gen -n 200000 -type clustered\n\n./gen -n 1000 -type big_weights_small_distances\n./gen -n 200000 -type big_weights_small_distances\n\n./gen -n 1000 -type small_weights_large_distances\n./gen -n 200000 -type small_weights_large_distances\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:43:58.173731",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "527/E",
      "title": "E. Data Center Drama",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers, n and m (1 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000) — the number of computers and the number of the already present cables, respectively.Each of the next lines contains two numbers ai, bi (1 ≤ ai, bi ≤ n) — the indices of the computers connected by the i-th cable. The data centers often have a very complex structure, so a pair of computers may have more than one pair of cables between them and some cables may connect a computer with itself.",
      "output_spec": "OutputIn the first line print a single number p (p ≥ m) — the minimum number of cables in the final scheme.In each of the next p lines print a pair of numbers ci, di (1 ≤ ci, di ≤ n), describing another cable. Such entry means that information will go along a certain cable in direction from ci to di.Among the cables you printed there should be all the cables presented in the original plan in some of two possible directions. It is guaranteed that there is a solution where p doesn't exceed 500 000.If there are several posible solutions with minimum possible value of p, print any of them.",
      "sample_tests": "ExamplesInputCopy4 61 22 33 44 11 31 3OutputCopy61 23 41 43 21 31 3InputCopy3 41 22 31 13 3OutputCopy62 12 31 13 33 11 1",
      "description": "E. Data Center Drama\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers, n and m (1 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000) — the number of computers and the number of the already present cables, respectively.Each of the next lines contains two numbers ai, bi (1 ≤ ai, bi ≤ n) — the indices of the computers connected by the i-th cable. The data centers often have a very complex structure, so a pair of computers may have more than one pair of cables between them and some cables may connect a computer with itself.\n\nOutputIn the first line print a single number p (p ≥ m) — the minimum number of cables in the final scheme.In each of the next p lines print a pair of numbers ci, di (1 ≤ ci, di ≤ n), describing another cable. Such entry means that information will go along a certain cable in direction from ci to di.Among the cables you printed there should be all the cables presented in the original plan in some of two possible directions. It is guaranteed that there is a solution where p doesn't exceed 500 000.If there are several posible solutions with minimum possible value of p, print any of them.\n\nInputCopy4 61 22 33 44 11 31 3OutputCopy61 23 41 43 21 31 3InputCopy3 41 22 31 13 3OutputCopy62 12 31 13 33 11 1\n\nInputCopy4 61 22 33 44 11 31 3\n\nOutputCopy61 23 41 43 21 31 3\n\nInputCopy3 41 22 31 13 3\n\nOutputCopy62 12 31 13 33 11 1\n\nNotePicture for the first sample test. The tied pairs of cables are shown going out from the same point.  Picture for the second test from the statement. The added cables are drawin in bold.  Alternative answer for the second sample test:",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces",
          "content": "527A - Playing with PaperIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Error Correct SystemThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Glass CarvingObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Clique ProblemOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≥ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Data Center DramaProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Fuzzy SearchThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Triangles 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 527 和字母"
          },
          "content_length": 8264
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    visited[1] = true;\n    q.push(1);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    visited[1] = true;\n    q.push(1);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    visited[1] = true;\n    q.push(1);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected, node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(); // Number of computers\n    int m = inf.readInt(); // Number of existing cables\n\n    // Read the existing undirected cables from the input\n    map<pair<int, int>, int> existingCables; // Count of cables between each pair\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt();\n        int b = inf.readInt();\n        if (a < 1 || a > n || b < 1 || b > n)\n            quitf(_fail, \"Invalid computer index in input: %d or %d\", a, b);\n        if (a > b) swap(a, b);\n        existingCables[make_pair(a, b)]++;\n    }\n\n    // Read the contestant's output\n    int p = ouf.readInt(); // Total number of cables in the final scheme\n    if (p < m)\n        quitf(_wa, \"p = %d is less than the number of existing cables m = %d\", p, m);\n    if (p > 500000)\n        quitf(_wa, \"p = %d exceeds the maximum allowed number of cables 500000\", p);\n\n    // Read the p cables and store the directed edges\n    map<pair<int, int>, int> allCables; // Count of cables between ci and di\n    vector<int> outDegree(n + 1, 0); // Out-degree of each computer (1-based indexing)\n    for (int i = 0; i < p; i++) {\n        int c = ouf.readInt(1, n, format(\"ci at line %d\", i + 2).c_str());\n        int d = ouf.readInt(1, n, format(\"di at line %d\", i + 2).c_str());\n        allCables[make_pair(c, d)]++;\n        outDegree[c]++;\n    }\n\n    // Check that all existing cables are included in the output in some direction\n    map<pair<int, int>, int> requiredCables = existingCables;\n    for (auto &entry : existingCables) {\n        int a = entry.first.first;\n        int b = entry.first.second;\n        int count = entry.second;\n        int found = min(allCables[make_pair(a, b)], count);\n        count -= found;\n        allCables[make_pair(a, b)] -= found;\n\n        found = min(allCables[make_pair(b, a)], count);\n        count -= found;\n        allCables[make_pair(b, a)] -= found;\n\n        if (count > 0)\n            quitf(_wa, \"Not all existing cables between computers %d and %d are included in the output\", a, b);\n    }\n\n    // Check that the out-degree of each computer is even\n    for (int i = 1; i <= n; i++) {\n        if (outDegree[i] % 2 != 0)\n            quitf(_wa, \"Out-degree of computer %d is odd (%d)\", i, outDegree[i]);\n    }\n\n    // If all checks passed\n    quitf(_ok, \"Accepted\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");          // Number of computers (nodes)\n    int m = opt<int>(\"m\");          // Number of cables (edges)\n    string degrees = opt<string>(\"degrees\", \"random\"); // \"even\", \"odd\", \"random\"\n    bool loops = opt<bool>(\"loops\", false);            // Whether to include loops\n    bool multiedge = opt<bool>(\"multiedge\", false);    // Whether to include multiple edges\n\n    // Ensure m is at least n - 1 (to form a connected graph)\n    m = max(m, n - 1);\n    // Ensure m does not exceed the maximum allowed value\n    m = min(m, 200000);\n\n    vector<pair<int, int>> edges;   // List of edges\n    vector<int> deg(n + 1, 0);      // Degree of each node\n\n    // Build a connected graph (tree)\n    for (int u = 2; u <= n; ++u) {\n        int v = rnd.next(1, u - 1);\n        edges.emplace_back(u, v);\n        deg[u]++;\n        deg[v]++;\n    }\n\n    // Adjust degrees according to the 'degrees' parameter\n    if (degrees == \"even\") {\n        vector<int> odd_nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (deg[i] % 2 != 0) {\n                odd_nodes.push_back(i);\n            }\n        }\n        // Pair up nodes with odd degrees\n        while (odd_nodes.size() >= 2) {\n            int u = odd_nodes.back(); odd_nodes.pop_back();\n            int v = odd_nodes.back(); odd_nodes.pop_back();\n            edges.emplace_back(u, v);\n            deg[u]++;\n            deg[v]++;\n        }\n        // If there's one odd node left and loops are allowed, add a loop\n        if (!odd_nodes.empty() && loops) {\n            int u = odd_nodes.back();\n            edges.emplace_back(u, u);\n            deg[u] += 2; // Loop increases degree by 2\n        }\n    } else if (degrees == \"odd\") {\n        vector<int> even_nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (deg[i] % 2 == 0) {\n                even_nodes.push_back(i);\n            }\n        }\n        // Pair up nodes with even degrees\n        while (even_nodes.size() >= 2) {\n            int u = even_nodes.back(); even_nodes.pop_back();\n            int v = even_nodes.back(); even_nodes.pop_back();\n            edges.emplace_back(u, v);\n            deg[u]++;\n            deg[v]++;\n        }\n        // If there's one even node left and loops are allowed, add a loop\n        if (!even_nodes.empty() && loops) {\n            int u = even_nodes.back();\n            edges.emplace_back(u, u);\n            deg[u] += 2; // Loop increases degree by 2\n        }\n    }\n\n    // Ensure we have at least m edges\n    // Prepare a set for edge checking if multiple edges are not allowed\n    set<pair<int, int>> edge_set;\n    if (!multiedge) {\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n    }\n\n    // Add random edges until we reach m edges\n    while ((int)edges.size() < m) {\n        int u = rnd.next(1, n);\n        int v;\n        if (loops && rnd.next(0, 1)) {\n            v = u; // Add a loop\n        } else {\n            v = rnd.next(1, n);\n            // Avoid self-loop if loops are not allowed\n            while (v == u && !loops) {\n                v = rnd.next(1, n);\n            }\n        }\n\n        if (!multiedge) {\n            int a = u, b = v;\n            if (a > b) swap(a, b);\n            if (edge_set.count({a, b}) == 0) {\n                edges.emplace_back(u, v);\n                deg[u]++;\n                deg[v]++;\n                edge_set.insert({a, b});\n            }\n        } else {\n            edges.emplace_back(u, v);\n            deg[u]++;\n            deg[v]++;\n        }\n    }\n\n    // Output the generated test case\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");          // Number of computers (nodes)\n    int m = opt<int>(\"m\");          // Number of cables (edges)\n    string degrees = opt<string>(\"degrees\", \"random\"); // \"even\", \"odd\", \"random\"\n    bool loops = opt<bool>(\"loops\", false);            // Whether to include loops\n    bool multiedge = opt<bool>(\"multiedge\", false);    // Whether to include multiple edges\n\n    // Ensure m is at least n - 1 (to form a connected graph)\n    m = max(m, n - 1);\n    // Ensure m does not exceed the maximum allowed value\n    m = min(m, 200000);\n\n    vector<pair<int, int>> edges;   // List of edges\n    vector<int> deg(n + 1, 0);      // Degree of each node\n\n    // Build a connected graph (tree)\n    for (int u = 2; u <= n; ++u) {\n        int v = rnd.next(1, u - 1);\n        edges.emplace_back(u, v);\n        deg[u]++;\n        deg[v]++;\n    }\n\n    // Adjust degrees according to the 'degrees' parameter\n    if (degrees == \"even\") {\n        vector<int> odd_nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (deg[i] % 2 != 0) {\n                odd_nodes.push_back(i);\n            }\n        }\n        // Pair up nodes with odd degrees\n        while (odd_nodes.size() >= 2) {\n            int u = odd_nodes.back(); odd_nodes.pop_back();\n            int v = odd_nodes.back(); odd_nodes.pop_back();\n            edges.emplace_back(u, v);\n            deg[u]++;\n            deg[v]++;\n        }\n        // If there's one odd node left and loops are allowed, add a loop\n        if (!odd_nodes.empty() && loops) {\n            int u = odd_nodes.back();\n            edges.emplace_back(u, u);\n            deg[u] += 2; // Loop increases degree by 2\n        }\n    } else if (degrees == \"odd\") {\n        vector<int> even_nodes;\n        for (int i = 1; i <= n; ++i) {\n            if (deg[i] % 2 == 0) {\n                even_nodes.push_back(i);\n            }\n        }\n        // Pair up nodes with even degrees\n        while (even_nodes.size() >= 2) {\n            int u = even_nodes.back(); even_nodes.pop_back();\n            int v = even_nodes.back(); even_nodes.pop_back();\n            edges.emplace_back(u, v);\n            deg[u]++;\n            deg[v]++;\n        }\n        // If there's one even node left and loops are allowed, add a loop\n        if (!even_nodes.empty() && loops) {\n            int u = even_nodes.back();\n            edges.emplace_back(u, u);\n            deg[u] += 2; // Loop increases degree by 2\n        }\n    }\n\n    // Ensure we have at least m edges\n    // Prepare a set for edge checking if multiple edges are not allowed\n    set<pair<int, int>> edge_set;\n    if (!multiedge) {\n        for (auto e : edges) {\n            int u = e.first;\n            int v = e.second;\n            if (u > v) swap(u, v);\n            edge_set.insert({u, v});\n        }\n    }\n\n    // Add random edges until we reach m edges\n    while ((int)edges.size() < m) {\n        int u = rnd.next(1, n);\n        int v;\n        if (loops && rnd.next(0, 1)) {\n            v = u; // Add a loop\n        } else {\n            v = rnd.next(1, n);\n            // Avoid self-loop if loops are not allowed\n            while (v == u && !loops) {\n                v = rnd.next(1, n);\n            }\n        }\n\n        if (!multiedge) {\n            int a = u, b = v;\n            if (a > b) swap(a, b);\n            if (edge_set.count({a, b}) == 0) {\n                edges.emplace_back(u, v);\n                deg[u]++;\n                deg[v]++;\n                edge_set.insert({a, b});\n            }\n        } else {\n            edges.emplace_back(u, v);\n            deg[u]++;\n            deg[v]++;\n        }\n    }\n\n    // Output the generated test case\n    printf(\"%d %d\\n\", n, (int)edges.size());\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small graphs with different degree configurations\n./gen -n 3 -m 3 -degrees even\n./gen -n 3 -m 3 -degrees odd\n./gen -n 3 -m 3 -degrees random\n\n# Medium-sized graphs without loops or multiple edges\n./gen -n 100 -m 150 -degrees even\n./gen -n 100 -m 150 -degrees odd\n./gen -n 100 -m 150 -degrees random\n\n# Medium-sized graphs with loops allowed\n./gen -n 100 -m 150 -degrees even -loops\n./gen -n 100 -m 150 -degrees odd -loops\n./gen -n 100 -m 150 -degrees random -loops\n\n# Medium-sized graphs with multiple edges allowed\n./gen -n 100 -m 150 -degrees even -multiedge\n./gen -n 100 -m 150 -degrees odd -multiedge\n./gen -n 100 -m 150 -degrees random -multiedge\n\n# Medium-sized graphs with both loops and multiple edges\n./gen -n 100 -m 150 -degrees even -loops -multiedge\n./gen -n 100 -m 150 -degrees odd -loops -multiedge\n./gen -n 100 -m 150 -degrees random -loops -multiedge\n\n# Large graphs to test performance limits\n./gen -n 100000 -m 200000 -degrees even\n./gen -n 100000 -m 200000 -degrees odd\n./gen -n 100000 -m 200000 -degrees random\n\n# Graphs where number of edges equals number of nodes (minimum edges)\n./gen -n 1000 -m 1000 -degrees even\n./gen -n 1000 -m 1000 -degrees odd\n./gen -n 1000 -m 1000 -degrees random\n\n# Graphs with a high number of edges (dense graphs)\n./gen -n 5000 -m 200000 -degrees even\n./gen -n 5000 -m 200000 -degrees odd\n./gen -n 5000 -m 200000 -degrees random\n\n# Small graphs with loops and multiple edges to test special cases\n./gen -n 10 -m 20 -degrees even -loops -multiedge\n./gen -n 10 -m 20 -degrees odd -loops -multiedge\n./gen -n 10 -m 20 -degrees random -loops -multiedge\n\n# Graphs with odd degrees and loops (loops allowed)\n./gen -n 1000 -m 1500 -degrees odd -loops\n\n# Graphs with even degrees without loops or multiple edges\n./gen -n 1000 -m 1500 -degrees even\n\n# Random graphs to test general correctness\n./gen -n 2000 -m 5000 -degrees random\n./gen -n 2000 -m 5000 -degrees random -loops\n./gen -n 2000 -m 5000 -degrees random -multiedge\n./gen -n 2000 -m 5000 -degrees random -loops -multiedge\n\n# Edge case with minimal nodes and edges\n./gen -n 1 -m 1 -degrees even\n./gen -n 1 -m 1 -degrees odd -loops\n\n# Edge case with maximum nodes and minimum edges\n./gen -n 100000 -m 99999 -degrees random\n\n# Complete graph (maximum number of edges for the given nodes)\n./gen -n 200 -m 200000 -degrees even -multiedge\n\n# Very sparse graph\n./gen -n 100000 -m 99999 -degrees even\n\n# Graph with all nodes connected to a central hub (star graph)\n./gen -n 1000 -m 999 -degrees even\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:00.672015",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "528/A",
      "title": "A. Glass Carving",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.",
      "output_spec": "OutputAfter each cut print on a single line the area of the maximum available glass fragment in mm2.",
      "sample_tests": "ExamplesInputCopy4 3 4H 2V 2V 3V 1OutputCopy8442InputCopy7 6 5H 4V 3V 5H 2V 1OutputCopy28161264",
      "description": "A. Glass Carving\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers w, h, n (2 ≤ w, h ≤ 200 000, 1 ≤ n ≤ 200 000).Next n lines contain the descriptions of the cuts. Each description has the form H y or V x. In the first case Leonid makes the horizontal cut at the distance y millimeters (1 ≤ y ≤ h - 1) from the lower edge of the original sheet of glass. In the second case Leonid makes a vertical cut at distance x (1 ≤ x ≤ w - 1) millimeters from the left edge of the original sheet of glass. It is guaranteed that Leonid won't make two identical cuts.\n\nOutputAfter each cut print on a single line the area of the maximum available glass fragment in mm2.\n\nInputCopy4 3 4H 2V 2V 3V 1OutputCopy8442InputCopy7 6 5H 4V 3V 5H 2V 1OutputCopy28161264\n\nInputCopy4 3 4H 2V 2V 3V 1\n\nOutputCopy8442\n\nInputCopy7 6 5H 4V 3V 5H 2V 1\n\nOutputCopy28161264\n\nNotePicture for the first sample test:    Picture for the second sample test:",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces",
          "content": "527A - Playing with PaperIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Error Correct SystemThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Glass CarvingObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Clique ProblemOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≥ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Data Center DramaProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Fuzzy SearchThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Triangles 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 528\\s*A"
          },
          "content_length": 8264
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(2, 200000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 200000, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<char, int>> cuts;\n\n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'H' || c == 'V', \"Invalid cut direction at line %d: expected 'H' or 'V', got '%c'\", i+2, c);\n        inf.readSpace();\n        int p;\n        if (c == 'H') {\n            p = inf.readInt(1, h - 1, \"y\");\n        } else { // c == 'V'\n            p = inf.readInt(1, w - 1, \"x\");\n        }\n        inf.readEoln();\n        pair<char, int> cut = make_pair(c, p);\n        ensuref(cuts.count(cut) == 0, \"Duplicate cut at position %d in direction %c\", p, c);\n        cuts.insert(cut);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(2, 200000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 200000, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<char, int>> cuts;\n\n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'H' || c == 'V', \"Invalid cut direction at line %d: expected 'H' or 'V', got '%c'\", i+2, c);\n        inf.readSpace();\n        int p;\n        if (c == 'H') {\n            p = inf.readInt(1, h - 1, \"y\");\n        } else { // c == 'V'\n            p = inf.readInt(1, w - 1, \"x\");\n        }\n        inf.readEoln();\n        pair<char, int> cut = make_pair(c, p);\n        ensuref(cuts.count(cut) == 0, \"Duplicate cut at position %d in direction %c\", p, c);\n        cuts.insert(cut);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int w = inf.readInt(2, 200000, \"w\");\n    inf.readSpace();\n    int h = inf.readInt(2, 200000, \"h\");\n    inf.readSpace();\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<pair<char, int>> cuts;\n\n    for (int i = 0; i < n; ++i) {\n        char c = inf.readChar();\n        ensuref(c == 'H' || c == 'V', \"Invalid cut direction at line %d: expected 'H' or 'V', got '%c'\", i+2, c);\n        inf.readSpace();\n        int p;\n        if (c == 'H') {\n            p = inf.readInt(1, h - 1, \"y\");\n        } else { // c == 'V'\n            p = inf.readInt(1, w - 1, \"x\");\n        }\n        inf.readEoln();\n        pair<char, int> cut = make_pair(c, p);\n        ensuref(cuts.count(cut) == 0, \"Duplicate cut at position %d in direction %c\", p, c);\n        cuts.insert(cut);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\");\n    int h = opt<int>(\"h\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output w h n\n    cout << w << \" \" << h << \" \" << n << endl;\n\n    if (type == \"random\") {\n        int max_cuts = (w - 1) + (h - 1);\n        ensure(n <= max_cuts);\n\n        vector<string> cuts;\n\n        // Add vertical cuts\n        for(int x = 1; x <= w - 1; ++x) {\n            cuts.push_back(\"V \" + to_string(x));\n        }\n\n        // Add horizontal cuts\n        for(int y = 1; y <= h - 1; ++y) {\n            cuts.push_back(\"H \" + to_string(y));\n        }\n\n        // Shuffle the cuts\n        shuffle(cuts.begin(), cuts.end());\n\n        // Output the first n cuts\n        for(int i = 0; i < n; ++i) {\n            cout << cuts[i] << endl;\n        }\n\n    } else if (type == \"vertical\") {\n        int max_cuts = w - 1;\n        ensure(n <= max_cuts);\n\n        // Possible positions from 1 to w - 1\n        vector<int> positions;\n        for(int x = 1; x <= w - 1; ++x) {\n            positions.push_back(x);\n        }\n        shuffle(positions.begin(), positions.end());\n        // Output first n cuts\n        for(int i = 0; i < n; ++i) {\n            cout << \"V \" << positions[i] << endl;\n        }\n\n    } else if (type == \"horizontal\") {\n        int max_cuts = h - 1;\n        ensure(n <= max_cuts);\n\n        // Possible positions from 1 to h - 1\n        vector<int> positions;\n        for(int y = 1; y <= h - 1; ++y) {\n            positions.push_back(y);\n        }\n        shuffle(positions.begin(), positions.end());\n        // Output first n cuts\n        for(int i = 0; i < n; ++i) {\n            cout << \"H \" << positions[i] << endl;\n        }\n\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int w = opt<int>(\"w\");\n    int h = opt<int>(\"h\");\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Output w h n\n    cout << w << \" \" << h << \" \" << n << endl;\n\n    if (type == \"random\") {\n        int max_cuts = (w - 1) + (h - 1);\n        ensure(n <= max_cuts);\n\n        vector<string> cuts;\n\n        // Add vertical cuts\n        for(int x = 1; x <= w - 1; ++x) {\n            cuts.push_back(\"V \" + to_string(x));\n        }\n\n        // Add horizontal cuts\n        for(int y = 1; y <= h - 1; ++y) {\n            cuts.push_back(\"H \" + to_string(y));\n        }\n\n        // Shuffle the cuts\n        shuffle(cuts.begin(), cuts.end());\n\n        // Output the first n cuts\n        for(int i = 0; i < n; ++i) {\n            cout << cuts[i] << endl;\n        }\n\n    } else if (type == \"vertical\") {\n        int max_cuts = w - 1;\n        ensure(n <= max_cuts);\n\n        // Possible positions from 1 to w - 1\n        vector<int> positions;\n        for(int x = 1; x <= w - 1; ++x) {\n            positions.push_back(x);\n        }\n        shuffle(positions.begin(), positions.end());\n        // Output first n cuts\n        for(int i = 0; i < n; ++i) {\n            cout << \"V \" << positions[i] << endl;\n        }\n\n    } else if (type == \"horizontal\") {\n        int max_cuts = h - 1;\n        ensure(n <= max_cuts);\n\n        // Possible positions from 1 to h - 1\n        vector<int> positions;\n        for(int y = 1; y <= h - 1; ++y) {\n            positions.push_back(y);\n        }\n        shuffle(positions.begin(), positions.end());\n        // Output first n cuts\n        for(int i = 0; i < n; ++i) {\n            cout << \"H \" << positions[i] << endl;\n        }\n\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small sizes\n./gen -w 10 -h 10 -n 5 -type random\n./gen -w 10 -h 10 -n 9 -type random\n./gen -w 10 -h 10 -n 9 -type vertical\n./gen -w 10 -h 10 -n 9 -type horizontal\n\n# Medium sizes\n./gen -w 1000 -h 1000 -n 1000 -type random\n./gen -w 1000 -h 1000 -n 999 -type vertical\n./gen -w 1000 -h 1000 -n 999 -type horizontal\n\n# Large sizes\n./gen -w 200000 -h 200000 -n 200000 -type random\n./gen -w 200000 -h 200000 -n 199999 -type vertical\n./gen -w 200000 -h 200000 -n 199999 -type horizontal\n\n# Edge cases\n./gen -w 200000 -h 200000 -n 199999 -type vertical\n./gen -w 200000 -h 200000 -n 199999 -type horizontal\n\n# Minimal w and h\n./gen -w 2 -h 200000 -n 1 -type vertical\n./gen -w 200000 -h 2 -n 1 -type horizontal\n\n# Mixed types with varying n\n./gen -w 50000 -h 150000 -n 100000 -type random\n./gen -w 150000 -h 50000 -n 100000 -type random\n\n# Small w, large h\n./gen -w 10 -h 200000 -n 200000 -type random\n./gen -w 10 -h 200000 -n 9 -type vertical\n./gen -w 10 -h 200000 -n 199999 -type horizontal\n\n# Large w, small h\n./gen -w 200000 -h 10 -n 200000 -type random\n./gen -w 200000 -h 10 -n 199999 -type vertical\n./gen -w 200000 -h 10 -n 9 -type horizontal\n\n# Small n\n./gen -w 200000 -h 200000 -n 1 -type random\n./gen -w 200000 -h 200000 -n 1 -type vertical\n./gen -w 200000 -h 200000 -n 1 -type horizontal\n\n# Maximal n for random cuts\n./gen -w 100000 -h 100000 -n 199998 -type random\n./gen -w 100000 -h 100000 -n 199998 -type random\n\n# All possible cuts used\n./gen -w 50000 -h 50000 -n 99998 -type random\n\n# Random sizes\n./gen -w 123456 -h 98765 -n 150000 -type random\n./gen -w 123456 -h 98765 -n 123455 -type vertical\n./gen -w 123456 -h 98765 -n 98764 -type horizontal\n\n# Corner cases\n./gen -w 2 -h 2 -n 2 -type random\n./gen -w 2 -h 2 -n 1 -type vertical\n./gen -w 2 -h 2 -n 1 -type horizontal\n\n# Medium sizes with uneven w and h\n./gen -w 1000 -h 500 -n 800 -type random\n./gen -w 500 -h 1000 -n 800 -type random\n\n# Random cuts with maximum n\n./gen -w 200000 -h 1 -n 199999 -type vertical\n./gen -w 1 -h 200000 -n 199999 -type horizontal\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:02.669456",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "528/B",
      "title": "B. Задача о клике",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке задано число n (1 ≤ n ≤ 200 000) — количество точек.В каждой из последующих n строк следуют по два числа xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — координата и вес очередной точки. Все координаты xi различны.",
      "output_spec": "Выходные данныеВыведите одно число — количество вершин в максимальной клике образованного графа.",
      "sample_tests": "ПримерыВходные данныеСкопировать42 33 16 10 2Выходные данныеСкопировать3",
      "description": "B. Задача о клике\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке задано число n (1 ≤ n ≤ 200 000) — количество точек.В каждой из последующих n строк следуют по два числа xi, wi (0 ≤ xi ≤ 109, 1 ≤ wi ≤ 109) — координата и вес очередной точки. Все координаты xi различны.\n\nВходные данные\n\nВыходные данныеВыведите одно число — количество вершин в максимальной клике образованного графа.\n\nВыходные данные\n\nВходные данныеСкопировать42 33 16 10 2Выходные данныеСкопировать3\n\nВходные данныеСкопировать42 33 16 10 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЕсли вы вдруг умеете решать эту задачу, не используя специфические свойства графа, представленного в условии задачи, то вам полагается приз в миллион доллларов!Изображение к тесту из условия:",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Всем привет! Сегодня вечером в обычное время состоится Codeforces Round #296 для обоих дивизионов, автором которого являюсь я.Готовить задачи мне помогали мои сокомандники, члены команды Moscow SU Trinity sankear и malcolm, а также множество ценных советов дал MikeMirzayanov, за что им всем большое спасибо. Переводом условий мы обязаны нашей бессменной переводчице Delinur.Как обычно, вам будет предложено пять задач на два часа. Разбалловка будет оглашена позднее. Приглашаю всех участвовать! Надеюсь, каждый участник найдёт себе что-нибудь по душе в предстоящем раунде.UPD: разбалловка — стандартная.UPD2: в связи с техническими трудностями раунд перенесён на 15 минут вперёд. Приносим извинения за непредвиденную задержку.UPD3: Приносим свои извинения за проблему с задачей Div1-D. Претест #16 не удовлетворял ограничениям n, m, k <= 200000. Системное тестирование для первого дивизиона будет отложено. Если вы считаете, что этот тест серьёзно повлиял на ваши результаты, вы можете написать мне сообщение, и мы сделаем раунд для вас нерейтинговым.Системное тестирование во втором дивизионе произойдёт в ближайшее время в обычном порядке.UPD4: Тестирование завершено. Поздравляем победителей!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: Был добавлен разбор на английском языке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1349
        },
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Всем привет! Сегодня вечером в обычное время состоится Codeforces Round #296 для обоих дивизионов, автором которого являюсь я.Готовить задачи мне помогали мои сокомандники, члены команды Moscow SU Trinity sankear и malcolm, а также множество ценных советов дал MikeMirzayanov, за что им всем большое спасибо. Переводом условий мы обязаны нашей бессменной переводчице Delinur.Как обычно, вам будет предложено пять задач на два часа. Разбалловка будет оглашена позднее. Приглашаю всех участвовать! Надеюсь, каждый участник найдёт себе что-нибудь по душе в предстоящем раунде.UPD: разбалловка — стандартная.UPD2: в связи с техническими трудностями раунд перенесён на 15 минут вперёд. Приносим извинения за непредвиденную задержку.UPD3: Приносим свои извинения за проблему с задачей Div1-D. Претест #16 не удовлетворял ограничениям n, m, k <= 200000. Системное тестирование для первого дивизиона будет отложено. Если вы считаете, что этот тест серьёзно повлиял на ваши результаты, вы можете написать мне сообщение, и мы сделаем раунд для вас нерейтинговым.Системное тестирование во втором дивизионе произойдёт в ближайшее время в обычном порядке.UPD4: Тестирование завершено. Поздравляем победителей!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: Был добавлен разбор на английском языке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1349
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces",
          "content": "527A - Игра с бумагойIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Система коррекции ошибокThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Разрезание стеклаObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Задача о кликеOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≤ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Страсти в дата-центреProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Нечёткий поискThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Треугольники 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 528\\s*B"
          },
          "content_length": 8277
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "Гарантируется, что существует решение, в котором p не превосходит 500 000.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 11",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "Гарантируется, что существует решение, в котором p не превосходит 500 000.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 11",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> x_set;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, \"w_i\");\n        inf.readEoln(); // Ensure we are at the end of line\n        ensuref(x_set.insert(x).second, \"All xi must be distinct\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> x_set;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, \"w_i\");\n        inf.readEoln(); // Ensure we are at the end of line\n        ensuref(x_set.insert(x).second, \"All xi must be distinct\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    set<int> x_set;\n\n    for (int i = 0; i < n; ++i) {\n        int x = inf.readInt(0, 1000000000, \"x_i\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, \"w_i\");\n        inf.readEoln(); // Ensure we are at the end of line\n        ensuref(x_set.insert(x).second, \"All xi must be distinct\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // Optional parameter for certain types\n\n    vector<long long> xi(n);\n    vector<long long> wi(n);\n\n    if (type == \"random\") {\n        // Generate random distinct xi in [0, 1e9], and wi in [1, 1e9]\n\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(1LL, 1000000000LL);\n        }\n\n    } else if (type == \"max_clique_n\") {\n        // Generate a graph where the maximum clique size is n\n        // Set wi = 1, xi spaced so that |xi - xj| >= wi + wj holds for all pairs\n        for (int i = 0; i < n; ++i) {\n            xi[i] = i * 2LL; // xi = 0, 2, 4, ...\n            wi[i] = 1;\n        }\n    } else if (type == \"max_clique_1\") {\n        // Generate a graph where the maximum clique size is 1\n        // Set wi = 1e9, xi close together so that |xi - xj| < wi + wj for all pairs\n        for (int i = 0; i < n; ++i) {\n            xi[i] = i;\n            wi[i] = 1000000000LL;\n        }\n    } else if (type == \"max_clique_k\") {\n        // Generate a graph where the maximum clique size is k\n        if (k == -1 || k > n) {\n            k = n / 2; // Default k\n        }\n\n        // First k nodes form a clique\n        for (int i = 0; i < k; ++i) {\n            xi[i] = i * 2LL;\n            wi[i] = 1;\n        }\n\n        // Remaining nodes do not connect to the first k nodes\n        long long x_base = xi[k - 1] + 2LL * 1000000000LL; // Ensure they are far enough\n        for (int i = k; i < n; ++i) {\n            xi[i] = x_base + (i - k) * 2LL;\n            wi[i] = 1;\n        }\n    } else if (type == \"min_weights\") {\n        // All wi = 1, random xi\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 1;\n        }\n    } else if (type == \"max_weights\") {\n        // All wi = 1e9, random xi\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 1000000000LL;\n        }\n    } else {\n        // Default to random\n        // Generate random distinct xi in [0, 1e9], and wi in [1, 1e9]\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", xi[i], wi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    int k = opt<int>(\"k\", -1); // Optional parameter for certain types\n\n    vector<long long> xi(n);\n    vector<long long> wi(n);\n\n    if (type == \"random\") {\n        // Generate random distinct xi in [0, 1e9], and wi in [1, 1e9]\n\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(1LL, 1000000000LL);\n        }\n\n    } else if (type == \"max_clique_n\") {\n        // Generate a graph where the maximum clique size is n\n        // Set wi = 1, xi spaced so that |xi - xj| >= wi + wj holds for all pairs\n        for (int i = 0; i < n; ++i) {\n            xi[i] = i * 2LL; // xi = 0, 2, 4, ...\n            wi[i] = 1;\n        }\n    } else if (type == \"max_clique_1\") {\n        // Generate a graph where the maximum clique size is 1\n        // Set wi = 1e9, xi close together so that |xi - xj| < wi + wj for all pairs\n        for (int i = 0; i < n; ++i) {\n            xi[i] = i;\n            wi[i] = 1000000000LL;\n        }\n    } else if (type == \"max_clique_k\") {\n        // Generate a graph where the maximum clique size is k\n        if (k == -1 || k > n) {\n            k = n / 2; // Default k\n        }\n\n        // First k nodes form a clique\n        for (int i = 0; i < k; ++i) {\n            xi[i] = i * 2LL;\n            wi[i] = 1;\n        }\n\n        // Remaining nodes do not connect to the first k nodes\n        long long x_base = xi[k - 1] + 2LL * 1000000000LL; // Ensure they are far enough\n        for (int i = k; i < n; ++i) {\n            xi[i] = x_base + (i - k) * 2LL;\n            wi[i] = 1;\n        }\n    } else if (type == \"min_weights\") {\n        // All wi = 1, random xi\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 1;\n        }\n    } else if (type == \"max_weights\") {\n        // All wi = 1e9, random xi\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = 1000000000LL;\n        }\n    } else {\n        // Default to random\n        // Generate random distinct xi in [0, 1e9], and wi in [1, 1e9]\n        set<long long> x_set;\n        while ((int)x_set.size() < n) {\n            long long x = rnd.next(0LL, 1000000000LL);\n            x_set.insert(x);\n        }\n        xi.assign(x_set.begin(), x_set.end());\n        shuffle(xi.begin(), xi.end());\n\n        for (int i = 0; i < n; ++i) {\n            wi[i] = rnd.next(1LL, 1000000000LL);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%lld %lld\\n\", xi[i], wi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 2 -type random\n./gen -n 10 -type random\n./gen -n 100 -type random\n./gen -n 1000 -type random\n./gen -n 10000 -type random\n./gen -n 100000 -type random\n./gen -n 200000 -type random\n\n./gen -n 1 -type max_clique_n\n./gen -n 2 -type max_clique_n\n./gen -n 10 -type max_clique_n\n./gen -n 100 -type max_clique_n\n./gen -n 1000 -type max_clique_n\n./gen -n 10000 -type max_clique_n\n./gen -n 100000 -type max_clique_n\n./gen -n 200000 -type max_clique_n\n\n./gen -n 1 -type max_clique_1\n./gen -n 2 -type max_clique_1\n./gen -n 10 -type max_clique_1\n./gen -n 100 -type max_clique_1\n./gen -n 1000 -type max_clique_1\n./gen -n 10000 -type max_clique_1\n./gen -n 100000 -type max_clique_1\n./gen -n 200000 -type max_clique_1\n\n./gen -n 10 -type max_clique_k -k 5\n./gen -n 100 -type max_clique_k -k 50\n./gen -n 1000 -type max_clique_k -k 500\n./gen -n 10000 -type max_clique_k -k 5000\n./gen -n 100000 -type max_clique_k -k 50000\n./gen -n 200000 -type max_clique_k -k 100000\n\n./gen -n 100000 -type min_weights\n./gen -n 100000 -type max_weights\n\n./gen -n 200000 -type min_weights\n./gen -n 200000 -type max_weights\n\n./gen -n 200000 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:04.337599",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "528/C",
      "title": "C. Data Center Drama",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two numbers, n and m (1 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000) — the number of computers and the number of the already present cables, respectively.Each of the next lines contains two numbers ai, bi (1 ≤ ai, bi ≤ n) — the indices of the computers connected by the i-th cable. The data centers often have a very complex structure, so a pair of computers may have more than one pair of cables between them and some cables may connect a computer with itself.",
      "output_spec": "OutputIn the first line print a single number p (p ≥ m) — the minimum number of cables in the final scheme.In each of the next p lines print a pair of numbers ci, di (1 ≤ ci, di ≤ n), describing another cable. Such entry means that information will go along a certain cable in direction from ci to di.Among the cables you printed there should be all the cables presented in the original plan in some of two possible directions. It is guaranteed that there is a solution where p doesn't exceed 500 000.If there are several posible solutions with minimum possible value of p, print any of them.",
      "sample_tests": "ExamplesInputCopy4 61 22 33 44 11 31 3OutputCopy61 23 41 43 21 31 3InputCopy3 41 22 31 13 3OutputCopy62 12 31 13 33 11 1",
      "description": "C. Data Center Drama\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two numbers, n and m (1 ≤ n ≤ 100 000, 1 ≤ m ≤ 200 000) — the number of computers and the number of the already present cables, respectively.Each of the next lines contains two numbers ai, bi (1 ≤ ai, bi ≤ n) — the indices of the computers connected by the i-th cable. The data centers often have a very complex structure, so a pair of computers may have more than one pair of cables between them and some cables may connect a computer with itself.\n\nOutputIn the first line print a single number p (p ≥ m) — the minimum number of cables in the final scheme.In each of the next p lines print a pair of numbers ci, di (1 ≤ ci, di ≤ n), describing another cable. Such entry means that information will go along a certain cable in direction from ci to di.Among the cables you printed there should be all the cables presented in the original plan in some of two possible directions. It is guaranteed that there is a solution where p doesn't exceed 500 000.If there are several posible solutions with minimum possible value of p, print any of them.\n\nInputCopy4 61 22 33 44 11 31 3OutputCopy61 23 41 43 21 31 3InputCopy3 41 22 31 13 3OutputCopy62 12 31 13 33 11 1\n\nInputCopy4 61 22 33 44 11 31 3\n\nOutputCopy61 23 41 43 21 31 3\n\nInputCopy3 41 22 31 13 3\n\nOutputCopy62 12 31 13 33 11 1\n\nNotePicture for the first sample test. The tied pairs of cables are shown going out from the same point.  Picture for the second test from the statement. The added cables are drawin in bold.  Alternative answer for the second sample test:",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Hi everybody! There will be a Codeforces Round for both divisions today at standard time set up by me.My teammates from ICPC team Moscow SU Trinity sankear and malcolm helped me a lot while preparing this round, also there were lots of useful tips and advices from MikeMirzayanov, applause for them. English translation was made by our veteran translator Delinur.As usual, there will be five tasks for two hours. The scoring will be announced later.See you on the round! I hope that each contestant will be able to find something nice in ongoing problems.UPD: Scoring is standard.UPD2: Due to technical issues the round is delayed by 15 minutes. We are sorry for an inconvenience.UPD3: We are sorry for an inconvenience with the task Div1-D. The pretest #16 wasn't satisfying the constraints n, m, k <= 200000. The system testing for the first division will be delayed. If you think that you were affected by this test, you may write me a message and we will make this round unrated for you. The system testing for the second division will happen shortly, as usual.UPD4: System testing is complete. Congratulations to the winners!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: the English editorial was added.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1275
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces",
          "content": "527A - Playing with PaperIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Error Correct SystemThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Glass CarvingObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Clique ProblemOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≥ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Data Center DramaProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Fuzzy SearchThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Triangles 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 528\\s*C"
          },
          "content_length": 8264
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 1\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        adj[ai].push_back(bi);\n        adj[bi].push_back(ai);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (size_t j = 0; j < adj[u].size(); j++) {\n            int v = adj[u][j];\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        adj[ai].push_back(bi);\n        adj[bi].push_back(ai);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (size_t j = 0; j < adj[u].size(); j++) {\n            int v = adj[u][j];\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 200000, \"m\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n + 1);\n    for (int i = 0; i < m; i++) {\n        int ai = inf.readInt(1, n, \"ai\");\n        inf.readSpace();\n        int bi = inf.readInt(1, n, \"bi\");\n        inf.readEoln();\n\n        adj[ai].push_back(bi);\n        adj[bi].push_back(ai);\n    }\n\n    vector<bool> visited(n + 1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (size_t j = 0; j < adj[u].size(); j++) {\n            int v = adj[u][j];\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    // Multiset to store existing edges with their multiplicities\n    multiset<pair<int, int>> existingEdges;\n    for (int i = 0; i < m; i++) {\n        int a = inf.readInt(1, n);\n        int b = inf.readInt(1, n);\n        existingEdges.insert(make_pair(min(a, b), max(a, b)));\n    }\n\n    // Read contestant's output\n    int p = ouf.readInt(m, 500000, \"p\"); // p >= m and p <= 500000\n    vector<pair<int, int>> outputEdges;\n    for (int i = 0; i < p; i++) {\n        int ci = ouf.readInt(1, n, \"ci\");\n        int di = ouf.readInt(1, n, \"di\");\n        outputEdges.push_back({ci, di});\n    }\n\n    // Multiset for matching existing edges\n    multiset<pair<int, int>> existingEdgesCopy = existingEdges;\n\n    // Map to count outdegrees for each node\n    vector<int> outdegree(n + 1, 0);\n\n    // Process contestant's output edges\n    for (auto edge : outputEdges) {\n        int ci = edge.first;\n        int di = edge.second;\n\n        // Update outdegree\n        outdegree[ci]++;\n\n        // Check if the edge is an existing edge\n        pair<int, int> edgePair = make_pair(min(ci, di), max(ci, di));\n        auto it = existingEdgesCopy.find(edgePair);\n        if (it != existingEdgesCopy.end()) {\n            // Existing edge used, remove one instance\n            existingEdgesCopy.erase(it);\n        }\n        // Else, it's a new edge (added edge), which is acceptable\n    }\n\n    // Check if all existing edges are used exactly once\n    if (!existingEdgesCopy.empty()) {\n        // There are existing edges not used\n        quitf(_wa, \"Not all existing cables are used in the output.\");\n    }\n\n    // Check that the outdegree of each computer is even\n    for (int u = 1; u <= n; u++) {\n        if (outdegree[u] % 2 != 0) {\n            quitf(_wa, \"The number of outgoing cables from computer %d is odd.\", u);\n        }\n    }\n\n    // If all checks passed\n    quitf(_ok, \"Correct solution. Number of cables: %d\", p);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        // Generate a random connected graph\n        // First generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({i, parent});\n        }\n\n        // Now add random edges until we reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain (path)\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Add random edges to reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"star\") {\n        // Generate a star shaped graph\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                edges.push_back({center, i});\n            }\n        }\n        // Add random edges to reach m\n        while ((int)edges.size() < m) {\n            int u = center;\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"self_loops\") {\n        // Generate edges with self-loops\n        // Create a connected graph first\n        for (int i = 2; i <= n && (int)edges.size() < m; ++i) {\n            edges.push_back({i, rnd.next(1, i - 1)});\n        }\n        // Add self-loops\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            edges.push_back({u, u});\n        }\n    } else if (type == \"multi_edges\") {\n        // Generate multiple edges between the same pairs\n        // Generate a connected graph first\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, rnd.next(1, i - 1)});\n        }\n        // Add random edges, possibly between same pairs\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"big_degree\") {\n        // One node has a very high degree\n        int hub = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i != hub) {\n                edges.push_back({hub, i});\n            }\n        }\n        // Add random edges to reach m\n        while ((int)edges.size() < m) {\n            int u = hub;\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"dense\") {\n        // Generate a dense graph\n        for (int u = 1; u <= n && (int)edges.size() < m; ++u) {\n            for (int v = 1; v <= n && (int)edges.size() < m; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"sparse\") {\n        // Generate a sparse connected graph\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, rnd.next(1, i - 1)});\n        }\n        // Add random edges if needed to reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else {\n        // Default to random connected graph\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({i, parent});\n        }\n\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Ensure we have exactly m edges\n    if ((int)edges.size() > m) {\n        edges.resize(m);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", n); // default m = n\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"random\") {\n        // Generate a random connected graph\n        // First generate a random tree\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({i, parent});\n        }\n\n        // Now add random edges until we reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"chain\") {\n        // Generate a chain (path)\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n        // Add random edges to reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"star\") {\n        // Generate a star shaped graph\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                edges.push_back({center, i});\n            }\n        }\n        // Add random edges to reach m\n        while ((int)edges.size() < m) {\n            int u = center;\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"self_loops\") {\n        // Generate edges with self-loops\n        // Create a connected graph first\n        for (int i = 2; i <= n && (int)edges.size() < m; ++i) {\n            edges.push_back({i, rnd.next(1, i - 1)});\n        }\n        // Add self-loops\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            edges.push_back({u, u});\n        }\n    } else if (type == \"multi_edges\") {\n        // Generate multiple edges between the same pairs\n        // Generate a connected graph first\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, rnd.next(1, i - 1)});\n        }\n        // Add random edges, possibly between same pairs\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"big_degree\") {\n        // One node has a very high degree\n        int hub = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i != hub) {\n                edges.push_back({hub, i});\n            }\n        }\n        // Add random edges to reach m\n        while ((int)edges.size() < m) {\n            int u = hub;\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else if (type == \"dense\") {\n        // Generate a dense graph\n        for (int u = 1; u <= n && (int)edges.size() < m; ++u) {\n            for (int v = 1; v <= n && (int)edges.size() < m; ++v) {\n                edges.push_back({u, v});\n            }\n        }\n    } else if (type == \"sparse\") {\n        // Generate a sparse connected graph\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i, rnd.next(1, i - 1)});\n        }\n        // Add random edges if needed to reach m\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    } else {\n        // Default to random connected graph\n        for (int i = 2; i <= n; ++i) {\n            int parent = rnd.next(1, i - 1);\n            edges.push_back({i, parent});\n        }\n\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back({u, v});\n        }\n    }\n\n    // Shuffle the edges\n    shuffle(edges.begin(), edges.end());\n\n    // Ensure we have exactly m edges\n    if ((int)edges.size() > m) {\n        edges.resize(m);\n    }\n\n    printf(\"%d %d\\n\", n, m);\n    for (auto edge : edges) {\n        printf(\"%d %d\\n\", edge.first, edge.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n\n./gen -n 10 -m 10 -type random\n./gen -n 10 -m 9 -type chain\n./gen -n 10 -m 15 -type multi_edges\n./gen -n 10 -m 20 -type self_loops\n./gen -n 10 -m 45 -type dense\n\n# Medium n\n./gen -n 1000 -m 1000 -type random\n./gen -n 1000 -m 999 -type chain\n./gen -n 1000 -m 2000 -type multi_edges\n./gen -n 1000 -m 3000 -type self_loops\n./gen -n 1000 -m 500000 -type dense\n\n# Large n\n./gen -n 100000 -m 100000 -type random\n./gen -n 100000 -m 99999 -type chain\n./gen -n 100000 -m 200000 -type multi_edges\n./gen -n 100000 -m 200000 -type self_loops\n./gen -n 100000 -m 200000 -type big_degree\n\n# Sparse graphs\n./gen -n 100000 -m 100000 -type sparse\n./gen -n 100000 -m 100000 -type chain\n\n# Star-shaped graphs\n./gen -n 100000 -m 100000 -type star\n\n# Edge cases\n./gen -n 1 -m 1 -type random\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 3 -type multi_edges\n\n# Complete graph (limited by m ≤ 200000)\n./gen -n 1000 -m 200000 -type dense\n\n# Heavy self-loops\n./gen -n 100000 -m 200000 -type self_loops\n\n# Random graphs with varying m\n./gen -n 50000 -m 100000 -type random\n./gen -n 50000 -m 200000 -type random\n\n# Random large graphs\n./gen -n 100000 -m 200000 -type random\n./gen -n 100000 -m 200000 -type multi_edges\n./gen -n 100000 -m 200000 -type self_loops\n\n# Minimum n and m\n./gen -n 1 -m 1 -type self_loops\n\n# Max m\n./gen -n 50000 -m 200000 -type random\n\n# Dense but not complete\n./gen -n 10000 -m 200000 -type random\n\n# Edge case with m = 2 * n\n./gen -n 100000 -m 200000 -type random\n\n# Chain with maximum m\n./gen -n 50000 -m 50000 -type chain\n\n# Random graphs with big degree nodes\n./gen -n 100000 -m 200000 -type big_degree\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:06.882097",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "528/D",
      "title": "D. Нечёткий поиск",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке следуют три целых числа |S|, |T|, k (1 ≤ |T| ≤ |S| ≤ 200 000, 0 ≤ k ≤ 200 000) — длины строк S и T и степень погрешности.Во второй строке записана строка S.В третьей строке записана строка T.Обе строки состоят только из прописных букв 'A', 'T', 'G' и 'C'.",
      "output_spec": "Выходные данныеВыведите единственное число — количество вхождений T в S со степенью погрешности k по данному определению.",
      "sample_tests": "ПримерыВходные данныеСкопировать10 4 1AGCAATTCATACATВыходные данныеСкопировать3",
      "description": "D. Нечёткий поиск\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке следуют три целых числа |S|, |T|, k (1 ≤ |T| ≤ |S| ≤ 200 000, 0 ≤ k ≤ 200 000) — длины строк S и T и степень погрешности.Во второй строке записана строка S.В третьей строке записана строка T.Обе строки состоят только из прописных букв 'A', 'T', 'G' и 'C'.\n\nВходные данные\n\nВыходные данныеВыведите единственное число — количество вхождений T в S со степенью погрешности k по данному определению.\n\nВыходные данные\n\nВходные данныеСкопировать10 4 1AGCAATTCATACATВыходные данныеСкопировать3\n\nВходные данныеСкопировать10 4 1AGCAATTCATACAT\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеЕсли вы вдруг разбираетесь в строении генома человека чуть лучше, чем автор задачи, и вы не прониклись оригинальным подходом Леонида, не воспринимайте всё описанное выше всерьёз.",
      "solutions": [
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Всем привет! Сегодня вечером в обычное время состоится Codeforces Round #296 для обоих дивизионов, автором которого являюсь я.Готовить задачи мне помогали мои сокомандники, члены команды Moscow SU Trinity sankear и malcolm, а также множество ценных советов дал MikeMirzayanov, за что им всем большое спасибо. Переводом условий мы обязаны нашей бессменной переводчице Delinur.Как обычно, вам будет предложено пять задач на два часа. Разбалловка будет оглашена позднее. Приглашаю всех участвовать! Надеюсь, каждый участник найдёт себе что-нибудь по душе в предстоящем раунде.UPD: разбалловка — стандартная.UPD2: в связи с техническими трудностями раунд перенесён на 15 минут вперёд. Приносим извинения за непредвиденную задержку.UPD3: Приносим свои извинения за проблему с задачей Div1-D. Претест #16 не удовлетворял ограничениям n, m, k <= 200000. Системное тестирование для первого дивизиона будет отложено. Если вы считаете, что этот тест серьёзно повлиял на ваши результаты, вы можете написать мне сообщение, и мы сделаем раунд для вас нерейтинговым.Системное тестирование во втором дивизионе произойдёт в ближайшее время в обычном порядке.UPD4: Тестирование завершено. Поздравляем победителей!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: Был добавлен разбор на английском языке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1349
        },
        {
          "title": "Codeforces Round #296 - Codeforces",
          "content": "Всем привет! Сегодня вечером в обычное время состоится Codeforces Round #296 для обоих дивизионов, автором которого являюсь я.Готовить задачи мне помогали мои сокомандники, члены команды Moscow SU Trinity sankear и malcolm, а также множество ценных советов дал MikeMirzayanov, за что им всем большое спасибо. Переводом условий мы обязаны нашей бессменной переводчице Delinur.Как обычно, вам будет предложено пять задач на два часа. Разбалловка будет оглашена позднее. Приглашаю всех участвовать! Надеюсь, каждый участник найдёт себе что-нибудь по душе в предстоящем раунде.UPD: разбалловка — стандартная.UPD2: в связи с техническими трудностями раунд перенесён на 15 минут вперёд. Приносим извинения за непредвиденную задержку.UPD3: Приносим свои извинения за проблему с задачей Div1-D. Претест #16 не удовлетворял ограничениям n, m, k <= 200000. Системное тестирование для первого дивизиона будет отложено. Если вы считаете, что этот тест серьёзно повлиял на ваши результаты, вы можете написать мне сообщение, и мы сделаем раунд для вас нерейтинговым.Системное тестирование во втором дивизионе произойдёт в ближайшее время в обычном порядке.UPD4: Тестирование завершено. Поздравляем победителей!Div1: piob PavelKunyavskiy dreamoon_love_AA mnbvmar aid Div2: happyBirthDayBeni ExfJoe _0029 tudort kill-z UPD5: Был добавлен разбор на английском языке.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/16996",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1349
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces",
          "content": "527A - Игра с бумагойIt’s easy to see that described process is equivalent to the following loop: while a > 0 and b > 0:\n if a ⩾ b:\n a = a - b\n else:\n b = b - a\n ans = ans + 1But such naive approach will obviously lead to verdict TLE, since it makes ~10, 2015 - 03 - 1912 operations even on the third sample test. The key idea is to replace repeating subtraction operations with integer division operations. This leads to the logarithmic-time solution that looks similar to the Euclid algorithm: while a > 0 and b > 0:\n if a ⩾ b:\n ans = ans + a div b\n a = a mod b\n else:\n ans = ans + b div a\n b = b mod a527B - Система коррекции ошибокThe first observation is that the new Hamming distance may not be less than the old one minus two, since we change only two characters. So the task is to actually determine, if we can attain decrease by two, one or can’t attain decrease at all.The decrease by two is possible if there are two positions with the same two letters in two strings but that appear in different order (like “double” <-> “bundle”).If there are no such positions, then we just need to check that we may decrease the distance. This can be done by just “fixing” the character that stands on the wrong position, like in “permanent” <-> “pergament” (here n stands in wrong pair with m, and there is also unmatched m, so we may fix this position).Otherwise, the answer is to keep everything as it is. Implementation can be done by keeping for each pair (x, y) of symbols position where such pair appears in S and T and then by carefully checking the conditions above.528A - Разрезание стеклаObviously the largest glass piece at any moment is the one that is product of the largest horizontal segment by the largest vertical segment. One of the possible solutions is to carefully implement what described in the statement and keep all horizontal segments and all vertical segments in priority queue or std::set, or some logarithmic data structure. This solution works in .But there is also a nice linear solution if we answer all queries in reverse order. Suppose segments are not cutting, but merging. In this case we may keep the horizontal and vertical cut lines in double-linked lists and track the current maximum (that can only increase and become equal to the newly-merged segment each time). This solution works in O(k + n + m).528B - Задача о кликеOne may think that this task is about graph theory, but it after some investigation and several equivalent changes in task statement it can be reduced to the well-known greedy problem. Initially you have that points may lie together in a set if they are not too close, i. e. |xi - xj| ≤ wi + wj. This is obviously equivalent to the following condition. Let’s consider interval of radius wi with center in point xi and call this interval to be the interval of point i. Then the statement actually says that no two such intervals should be intersecting.This task is well-known and can be solved greedily after sorting segments in ascending order of right endpoint: Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n last = i\n ans = ans + 1It’s easy to prove that this solution is correct. Among all ways to choose first k segments, the best way is the one that minimizes x-coordinate of the right endpoint of the last segment (since it restricts us in the least possible way). 528C - Страсти в дата-центреProblem legend asks you to add minimum number of edges to the given connected undirected graph (possibly, with loops and duplicating edges) and choose direction for its edges so that both the incoming and outgoing degrees of all vertices are even.First idea is that the resulting graph before we choose the direction (but after we added some edges) will contain Euler circuit, since all degrees are even. That’s almost what we need: if we have an Euler circuit that contains even number of edges, we may direct them like following: a <- b -> c <- d -> e … It’s easy to see that each vertex appearance in this cycle adds 2 to its ingoing or outgoing degree, so the resulting degrees will be even.But if the Euler circuit is odd (meaning that there is odd number of edges in the graph), we must add some extra edge to the graph before we continue, the easiest way is to add a loop from vertex 0 to itself, since it doesn’t affect the Euler tour, but now tour length is even, so everything is ok.Now we should think how to add edges optimally. It’s easy to see that the optimal way is to first fix all odd degrees of vertices (i. e. combine all odd vertices by pairs and put an edge in each pair), and then, possibly, add an extra loop as described above. The last part is to actually find an Euler circuit, and to print the answer.528D - Нечёткий поискThere were issues with this task. Intended constraints were actually n, m, k ≤ 500000, and the intended solution was using Fast Fourier Transformation, that leads to running time. But unfortunately the statement contained wrong constraints, so we reduced input size during the tour. Nevertheless, we will add the harder version of this task and you will be able to submit it shortly.Key idea is to reduce this task to a polynomial multiplication. Let’s solve the task in following manner. For each position i of the S for each character c from “ATGC” we will calculate match(c, i) that is equal to the number of c characters that have matching symbol in S if we put string T in position i. Then the criteria for us to have an occurrence at position i is that match(A, i) + match(T, i) + match(G, i) + match(C, i) == |T| (that means exactly that each character from T being put at position i has a corresponding character in S).Now let’s find out how to calculate match(c, i). Let’s keep only c characters and “not c” characters in both strings and denote them by 1 and 0 respectively. Let’s also spread each 1 in string S by the distance k to the left and to the right. For example, k = 1 for the sample string AGCAATTCAT and the character A corresponding bit vector will be 111110111, and for the character C it will be 0111001110. This bitvector can be calculated in O(n) by putting two events “+1” and “-1” in string S in positions x - k and x + k for each 1 in original string S and then sweeping from left to right over the string S and processing those events.Now our task is reduced to searching all positions where the bitvector T is the submask of the bitvector S. In constraints n, m, k ≤ 200000 this can be done by using bitsets in O(m(n - m) / 32). Nevertheless, this task can be seen as calculation of polynomials S and reversed(T) product. We will keep this as an exercise for those who decide to submit the harder version of this task.528E - Треугольники 3000Let’s draw a bounding box that contains all intersection points. Let’s fix a triangle and consider three angles shown on the picture. Calculate area of intersection of those area with the bounding box and call this area to be the “area of an angle”. Then it’s easy to see, that those three angles are complement to the triangle itself in the bounding box, i. e. triangle area is bounding box area minus three angle areas.This leads us to the idea how to solve this task by carefully calculating for each possible formed angle on the plane, how much times does it appear in total answer if we sum all values like (S - angle_area(a, b) - angle_area(b, c) - angle_area(c, a)) over all triples (a, b, c) of lines.Actually, the angle is considered as many times, as many lines there are that intersect both sides of its right adjacent angle. So, our task is reduced to calculate for each angle on plane how much lines intersect its sides (i. e. its rays).This can be done in by fixing the first side of the angle and then adding lines in ascending order of polar angle, and then by keeping the number of lines that intersect the base line to the left and that intersect the base line to the right. Key idea is that the exact of four angles formed by the pair of lines (a, b) that is crossed by some third line c, can be determined by two numbers: its polar angle alpha and its crossing with a coordinate x. Further details are shown on the picture below.There is also a nice short O(n2) solution from enot110 here.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17020",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 528\\s*D"
          },
          "content_length": 8277
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "Гарантируется, что существует решение, в котором p не превосходит 500 000.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 11",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 1",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 2",
          "code": "6 4\n1 2\n2 3\n4 5\n5 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 3",
          "code": "The cables are put so that each computer is connected with each one",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 4",
          "code": "perhaps through some other computers.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 5",
          "code": "Гарантируется, что существует решение, в котором p не превосходит 500 000.",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 6",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 7",
          "code": "4\ndbea\nbddb",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 8",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 9",
          "code": "4\nacbc\nbbaa",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 10",
          "code": "print i+1, j+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 - Codeforces - Code 11",
          "code": "print ind[i]+1, ind[j]+1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/16996",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 1",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 2",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n         a = a - b\n    else:\n         b = b - a\n    ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 3",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 4",
          "code": "while a > 0 and b > 0:\n    if a ⩾ b:\n        ans = ans + a div b\n        a = a mod b\n    else:\n        ans = ans + b div a\n        b = b mod a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 5",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 6",
          "code": "Sort segments S in ascending order of S.x + S.w\n\nlast = 0\nans = 0\nfor i = 1..n - 1:\n    if S[i].x - S[i].w ⩾ S[last].x + S[last].w:\n        last = i\n        ans = ans + 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 7",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 8",
          "code": "while (i+z[i] < n && s[z[i]] == s[i+z[i]])  ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 9",
          "code": "S[ i-k ... i , i+1 ... i+k ]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 10",
          "code": "S[i-k...i+k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 11",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 12",
          "code": "while ( i+z[i] < n && can[ i+z[i] ][ t[z[i]] ] ) ++z[i];",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 13",
          "code": "[l - k, r + k]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 14",
          "code": "auto med=setCut.find(num);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 15",
          "code": "auto med=( (cut == 'h')?(horiz.find(num)):(vert.find(num)) );",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 16",
          "code": "|xi - xj| ≥ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #296 Editorial (English only) - Codeforces - Code 17",
          "code": "|xi - xj| ≤ wi + wj",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17020",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int S_len = inf.readInt(1, 200000, \"|S|\");\n    inf.readSpace();\n    int T_len = inf.readInt(1, S_len, \"|T|\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200000, \"k\");\n    inf.readEoln();\n\n    string S = inf.readToken();\n    inf.readEoln();\n\n    string T = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(S.length()) == S_len, \"Length of S is %d but expected %d\", int(S.length()), S_len);\n    ensuref(int(T.length()) == T_len, \"Length of T is %d but expected %d\", int(T.length()), T_len);\n\n    for (char c : S) {\n        ensuref(c == 'A' || c == 'T' || c == 'G' || c == 'C', \"Invalid character in S: %c\", c);\n    }\n\n    for (char c : T) {\n        ensuref(c == 'A' || c == 'T' || c == 'G' || c == 'C', \"Invalid character in T: %c\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int S_len = inf.readInt(1, 200000, \"|S|\");\n    inf.readSpace();\n    int T_len = inf.readInt(1, S_len, \"|T|\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200000, \"k\");\n    inf.readEoln();\n\n    string S = inf.readToken();\n    inf.readEoln();\n\n    string T = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(S.length()) == S_len, \"Length of S is %d but expected %d\", int(S.length()), S_len);\n    ensuref(int(T.length()) == T_len, \"Length of T is %d but expected %d\", int(T.length()), T_len);\n\n    for (char c : S) {\n        ensuref(c == 'A' || c == 'T' || c == 'G' || c == 'C', \"Invalid character in S: %c\", c);\n    }\n\n    for (char c : T) {\n        ensuref(c == 'A' || c == 'T' || c == 'G' || c == 'C', \"Invalid character in T: %c\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int S_len = inf.readInt(1, 200000, \"|S|\");\n    inf.readSpace();\n    int T_len = inf.readInt(1, S_len, \"|T|\");\n    inf.readSpace();\n    int k = inf.readInt(0, 200000, \"k\");\n    inf.readEoln();\n\n    string S = inf.readToken();\n    inf.readEoln();\n\n    string T = inf.readToken();\n    inf.readEoln();\n\n    ensuref(int(S.length()) == S_len, \"Length of S is %d but expected %d\", int(S.length()), S_len);\n    ensuref(int(T.length()) == T_len, \"Length of T is %d but expected %d\", int(T.length()), T_len);\n\n    for (char c : S) {\n        ensuref(c == 'A' || c == 'T' || c == 'G' || c == 'C', \"Invalid character in S: %c\", c);\n    }\n\n    for (char c : T) {\n        ensuref(c == 'A' || c == 'T' || c == 'G' || c == 'C', \"Invalid character in T: %c\", c);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints: 1 ≤ |T| ≤ |S| ≤ 200,000\n    n = max(1, min(n, 200000));\n    m = max(1, min(m, n));\n    k = max(0, min(k, 200000));\n\n    string S, T;\n\n    if (type == \"random\") {\n        // Generate random S and T of lengths n and m\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"same_char\") {\n        // All characters are the same, randomly pick one letter\n        char c = \"ATGC\"[rnd.next(4)];\n        S = string(n, c);\n        T = string(m, c);\n    } else if (type == \"identical\") {\n        // S and T are identical strings\n        string letters = \"ATGC\";\n        for (int i = 0; i < m; ++i) {\n            char c = letters[rnd.next(4)];\n            S += c;\n            T += c;\n        }\n        for (int i = m; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n    } else if (type == \"max_matches\") {\n        // S is made up of repeated T with some overlapping\n        if (m == 0) m = 1;\n        if (n < m) n = m;\n        string letters = \"ATGC\";\n        for (int i = 0; i < m; ++i) {\n            char c = letters[rnd.next(4)];\n            T += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            S += T[i % m];\n        }\n    } else if (type == \"no_matches\") {\n        // S and T have completely different letters\n        string letters_S = \"AT\";\n        string letters_T = \"GC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters_S[rnd.next(2)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters_T[rnd.next(2)];\n        }\n    } else if (type == \"edge_n1\") {\n        n = 1;\n        string letters = \"ATGC\";\n        S = letters[rnd.next(4)];\n        m = max(1, min(m, n));\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"edge_m1\") {\n        m = 1;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        T = letters[rnd.next(4)];\n    } else if (type == \"edge_both1\") {\n        n = m = 1;\n        string letters = \"ATGC\";\n        S = letters[rnd.next(4)];\n        T = letters[rnd.next(4)];\n    } else if (type == \"max_size\") {\n        n = m = 200000;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        T = S.substr(0, m);\n    } else if (type == \"k_zero\") {\n        k = 0;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"k_max\") {\n        k = 200000;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"palindrome\") {\n        // Generate palindrome strings\n        string letters = \"ATGC\";\n        for (int i = 0; i < n / 2; ++i) {\n            char c = letters[rnd.next(4)];\n            S += c;\n        }\n        string rev_S = S;\n        reverse(rev_S.begin(), rev_S.end());\n        if (n % 2 == 1) {\n            S += letters[rnd.next(4)];\n        }\n        S += rev_S;\n        for (int i = 0; i < m / 2; ++i) {\n            char c = letters[rnd.next(4)];\n            T += c;\n        }\n        string rev_T = T;\n        reverse(rev_T.begin(), rev_T.end());\n        if (m % 2 == 1) {\n            T += letters[rnd.next(4)];\n        }\n        T += rev_T;\n    } else if (type == \"alternate\") {\n        string letters = \"ATGC\";\n        char c1 = letters[rnd.next(4)];\n        char c2 = letters[rnd.next(4)];\n        while (c2 == c1) {\n            c2 = letters[rnd.next(4)];\n        }\n        for (int i = 0; i < n; ++i) {\n            S += (i % 2 == 0) ? c1 : c2;\n        }\n        for (int i = 0; i < m; ++i) {\n            T += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"tricky\") {\n        // Specific tricky test case\n        S = string(n, 'A');\n        T = string(m, 'A');\n        if (m > 1) {\n            T[m / 2] = 'T';\n        }\n    } else {\n        // Default to random\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", (int)S.length(), (int)T.length(), k);\n    printf(\"%s\\n\", S.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure constraints: 1 ≤ |T| ≤ |S| ≤ 200,000\n    n = max(1, min(n, 200000));\n    m = max(1, min(m, n));\n    k = max(0, min(k, 200000));\n\n    string S, T;\n\n    if (type == \"random\") {\n        // Generate random S and T of lengths n and m\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"same_char\") {\n        // All characters are the same, randomly pick one letter\n        char c = \"ATGC\"[rnd.next(4)];\n        S = string(n, c);\n        T = string(m, c);\n    } else if (type == \"identical\") {\n        // S and T are identical strings\n        string letters = \"ATGC\";\n        for (int i = 0; i < m; ++i) {\n            char c = letters[rnd.next(4)];\n            S += c;\n            T += c;\n        }\n        for (int i = m; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n    } else if (type == \"max_matches\") {\n        // S is made up of repeated T with some overlapping\n        if (m == 0) m = 1;\n        if (n < m) n = m;\n        string letters = \"ATGC\";\n        for (int i = 0; i < m; ++i) {\n            char c = letters[rnd.next(4)];\n            T += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            S += T[i % m];\n        }\n    } else if (type == \"no_matches\") {\n        // S and T have completely different letters\n        string letters_S = \"AT\";\n        string letters_T = \"GC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters_S[rnd.next(2)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters_T[rnd.next(2)];\n        }\n    } else if (type == \"edge_n1\") {\n        n = 1;\n        string letters = \"ATGC\";\n        S = letters[rnd.next(4)];\n        m = max(1, min(m, n));\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"edge_m1\") {\n        m = 1;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        T = letters[rnd.next(4)];\n    } else if (type == \"edge_both1\") {\n        n = m = 1;\n        string letters = \"ATGC\";\n        S = letters[rnd.next(4)];\n        T = letters[rnd.next(4)];\n    } else if (type == \"max_size\") {\n        n = m = 200000;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        T = S.substr(0, m);\n    } else if (type == \"k_zero\") {\n        k = 0;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"k_max\") {\n        k = 200000;\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    } else if (type == \"palindrome\") {\n        // Generate palindrome strings\n        string letters = \"ATGC\";\n        for (int i = 0; i < n / 2; ++i) {\n            char c = letters[rnd.next(4)];\n            S += c;\n        }\n        string rev_S = S;\n        reverse(rev_S.begin(), rev_S.end());\n        if (n % 2 == 1) {\n            S += letters[rnd.next(4)];\n        }\n        S += rev_S;\n        for (int i = 0; i < m / 2; ++i) {\n            char c = letters[rnd.next(4)];\n            T += c;\n        }\n        string rev_T = T;\n        reverse(rev_T.begin(), rev_T.end());\n        if (m % 2 == 1) {\n            T += letters[rnd.next(4)];\n        }\n        T += rev_T;\n    } else if (type == \"alternate\") {\n        string letters = \"ATGC\";\n        char c1 = letters[rnd.next(4)];\n        char c2 = letters[rnd.next(4)];\n        while (c2 == c1) {\n            c2 = letters[rnd.next(4)];\n        }\n        for (int i = 0; i < n; ++i) {\n            S += (i % 2 == 0) ? c1 : c2;\n        }\n        for (int i = 0; i < m; ++i) {\n            T += (i % 2 == 0) ? c1 : c2;\n        }\n    } else if (type == \"tricky\") {\n        // Specific tricky test case\n        S = string(n, 'A');\n        T = string(m, 'A');\n        if (m > 1) {\n            T[m / 2] = 'T';\n        }\n    } else {\n        // Default to random\n        string letters = \"ATGC\";\n        for (int i = 0; i < n; ++i) {\n            S += letters[rnd.next(4)];\n        }\n        for (int i = 0; i < m; ++i) {\n            T += letters[rnd.next(4)];\n        }\n    }\n\n    // Output the test case\n    printf(\"%d %d %d\\n\", (int)S.length(), (int)T.length(), k);\n    printf(\"%s\\n\", S.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases\n./gen -n 10 -m 5 -k 2 -type random\n./gen -n 1000 -m 500 -k 100 -type random\n./gen -n 200000 -m 100000 -k 100000 -type random\n\n# Same_char test cases\n./gen -n 100 -m 50 -k 10 -type same_char\n./gen -n 200000 -m 100000 -k 200000 -type same_char\n\n# Identical strings\n./gen -n 100 -m 100 -k 0 -type identical\n./gen -n 200000 -m 200000 -k 200000 -type identical\n\n# Max matches\n./gen -n 100 -m 5 -k 2 -type max_matches\n./gen -n 200000 -m 1000 -k 1000 -type max_matches\n\n# No matches\n./gen -n 100 -m 50 -k 10 -type no_matches\n./gen -n 200000 -m 100000 -k 200000 -type no_matches\n\n# Edge cases\n./gen -n 1 -m 1 -k 0 -type edge_both1\n./gen -n 1 -m 200000 -k 0 -type edge_n1\n./gen -n 200000 -m 1 -k 0 -type edge_m1\n\n# k = 0 and k = max\n./gen -n 10000 -m 5000 -k 0 -type k_zero\n./gen -n 10000 -m 5000 -k 200000 -type k_max\n\n# Palindrome test cases\n./gen -n 1000 -m 500 -k 100 -type palindrome\n./gen -n 200000 -m 100000 -k 200000 -type palindrome\n\n# Alternate letters\n./gen -n 1000 -m 500 -k 100 -type alternate\n./gen -n 200000 -m 100000 -k 200000 -type alternate\n\n# Tricky test cases\n./gen -n 1000 -m 500 -k 100 -type tricky\n./gen -n 200000 -m 100000 -k 200000 -type tricky\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:09.070467",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "529/A",
      "title": "A. И снова правильная скобочная последовательность",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест5 секунд",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержится последовательность Поликарпа, состоящая из символов «(» и «)». Длина строки от 1 до 1 000 000.",
      "output_spec": "Выходные данныеВыведите правильную скобочную последовательность минимальной длины, которую Поликарп может получить при помощи своих операций. Если таких последовательностей несколько, выведите лексикографически наименьшую.",
      "sample_tests": "ПримерыВходные данныеСкопировать()(())Выходные данныеСкопировать(())()Входные данныеСкопировать()(Выходные данныеСкопировать(())",
      "description": "A. И снова правильная скобочная последовательность\n\nограничение по времени на тест5 секунд\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержится последовательность Поликарпа, состоящая из символов «(» и «)». Длина строки от 1 до 1 000 000.\n\nВходные данные\n\nВыходные данныеВыведите правильную скобочную последовательность минимальной длины, которую Поликарп может получить при помощи своих операций. Если таких последовательностей несколько, выведите лексикографически наименьшую.\n\nВыходные данные\n\nВходные данныеСкопировать()(())Выходные данныеСкопировать(())()Входные данныеСкопировать()(Выходные данныеСкопировать(())\n\nВходные данныеСкопировать()(())\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать(())()\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать()(\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать(())\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПоследовательность в первом примере уже является правильной, но чтобы получить лексикографически наименьший ответ, нужно выполнить четыре операции циклического сдвига. Во втором примере нужно добавить закрывающуюся скобку между второй и третьей скобками и совершить циклический сдвиг. Можно сначала совершить сдвиг, а потом добавить скобку в конце.",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces",
          "content": "Набор задач в онлайн-трансляции незначительно отличается от набора задач на основном раунде, задачи следуют в порядке, в котором они фигурируют в основном раунде.524A - Возможно, вы знаете этих людей?В задаче требовалось реализовать ровно то, что описано в условии. Фиксируем человека x, проходимся по всем остальным людям y, не дружащим с x, и считаем количество общих друзей x и y.Тонкий момент №1: несмотря на то, пар друзей во вводе не более 100, самих людей может быть до 200, и можно ошибиться в выставлении размеров массивов.Тонкий момент №2: нужно аккуратно сравнивать вещественные числа. Если написать нечто вроде common / degree >= k / 100.0, то в силу специфики вычислений с вещественными числами, результат такой проверки может быть недетерминирован (если в какую-то из частей внесётся незначительная погрешность). Поэтому, надо либо сравнивать с точностью до некоторого eps, либо выполнять проверку в целых числах: common * 100 >= degree * k.524B - Фото на память - 2 (round version)Переберём высоту итоговой фотографии. При фиксированной высоте нам требуется минимизировать суммарную ширину всех прямоугольников. Таким образом, для каждого прямоугольника нужно выбрать такое из двух его положений, которое, во-первых, подходит по высоте, а во-вторых, имеет меньшую возможную ширину.529B - Фото на память - 2 (online mirror version)В версии для онлайн-трансляции условие было незначительно изменено — разрешается, чтобы не более n / 2 людей лежали на фотографии. Это слегка усложняет решение. Введём терминологию: людей, у которых w ≤ h, будем называть высокими, а остальных людей — широкими. Зафиксируем итоговую высоту фотографии H. Далее, следует небольшой разбор случаев. Если высокий человек влезает под высоту H, то мы его оставляем именно в таком состоянии. Если высокий человек не влезает под высоту H, то мы обязаны его положить, увеличиваем счётчик таких людей на 1. Если широкий человек влезает под высоту H, но не влезает, будучи положенным, то ставим его. Если широкий человек влезает под высоту H обоими способами, то сначала ставим его, а в отдельный массив выписываем величину, на которую уменьшится ответ, если этого человека всё-таки положить: w - h. Если же кто-то не влезает ни одним из двух способов, то подобное значение H недопустимо. Теперь у нас есть какое-то количество людей, которые обязательно должны лечь (из второго пункта), причём, если их слишком много, а именно, больше, чем n / 2, то подобное значение H недопустимо. За вычетом людей из второго пункта у нас осталось некоторое количество вакантных лежачих мест — распределяем их по людям из четвёртого пункта в порядке уменьшения величины (w — h). Считаем площадь фотографии, выбираем минимум по всем H.524C - Искусство обращения с бакноматомПредполагаемое решение имеет сложность или . Для каждой возможной суммы денег x = t·ai (1 ≤ t ≤ k) выпишем пару (x, t) в массив, здесь t — количество купюр, которым такую сумму можно достичь. Отсортируем этот массив. Тогда чтобы ответить на один запрос, переберём первое слагаемое в сумме, а второе либо найдём бинарным поиском, либо воспользуемся методом двух указателей, чтобы найти парное слагаемое за амортизированное время O(1). Проверим, что получилось не более k купюр в сумме, улучшим ответ, если надо.524D - Социальная сетьБудем жадно действовать следующим образом. Идём по запросам в порядке поступления. Каждый очередной запрос пытаемся сопоставить новому человеку. Разумеется, это не всегда возможно сделать — если у нас уже есть M активных людей на сайте, то мы обязаны сопоставить очередной запрос кому-то из них. Возникает вопрос — кому именно?Можно показать, что выгоднее всего сопоставить этот запрос самому недавнему из активных людей. Действительно, подобное “критическое” (по количеству людей) состояние можно задать вектором из M чисел — временами с момента последнего запроса каждого из людей в убывающем порядке. Тогда если сейчас состояние — (a1, a2, ..., aM), то мы можем перейти в одно из M новых состояний (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0), в зависимости от того, к кому мы подцепим очередной запрос. Видно, что самый первый вектор покомпонентно больше, чем любой из оставшихся, а это значит, что он выгоднее всех остальных (т. к. чем больше число на определённой позиции в векторе, тем скорее может исчезнуть этот человек, и тем больше у нас остаётся свободы для последующих действий).Значит, нам требуется моделировать процесс, поддерживая в некоторой структуре данных множество активных людей с временами их активности. В качестве подобной структуры можно воспользоваться любой структурой, реализующей интерфейс очереди с приоритетом (priority_queue, set, дерево отрезков или что-либо ещё). Итоговая сложность решения — .524E - Ладьи и прямоугольникиПоймём, что означает тот факт, что какая-то клетка прямоугольника не побита ладьёй. Это значит, что существует строка прямоугольника, не содержащая ладью, и существует столбец прямоугольника, не содержащий ладью. Не очень ясно, как проверять это утверждение, поэтому проверим обратное к нему — мы только что показали, что прямоугольник является покрытым, если либо в каждой строке стоит ладья, либо в каждом столбце стоит ладья.Эти утверждения можно проверять по отдельности. Как проверить для набора прямоугольников, что в каждой строке находится отмеченная точка? Это можно сделать за один проход вертикальной сканирующей прямой. Пусть мы идём слева направо и прошли через правую границу прямоугольника, расположенного в строках с a-й по b-ю, левая граница которого находится в столбце x. Тогда если обозначить за last[i] позицию последней ладьи, встреченной в строке номер i, то критерий для прямоугольника выглядит следующим образом: . Это значит, что для хранения величины last можно воспользоваться деревом отрезков. Аналогично проверяем для столбцов. Выходит решение, отвечающее на все запросы off-line за время O((q + k)log(n + m)).524F - И снова правильная скобочная последовательностьОбщая идея заключается в том, что скобочные последовательности можно рассматривать как последовательности балансов префиксов, т. е. как последовательности чисел (ai), где ai + 1 = ai ± 1.Посчитаем количество открывающихся скобок A и закрывающихся скобок B в исходной строке. Заметим, что если A >  = B, то строку всегда можно исправить, дописав A - B закрывающихся скобок в конец, и циклически сдвинув строку в точку минимума баланса, а если A ≤ B, то строку аналогично можно исправить, дописав B - A открывающихся скобок в начало. Очевидно, что меньшим количеством скобок не обойтись. Таким образом, мы уже знаем величину ответа, теперь нужно понять, как он устроен.Будем считать, что мы сначала производим циклический сдвиг, а потом только добавляем скобки. Пусть, для определённости, мы дописываем x закрывающихся скобок. Сформулируем два несложных утверждения: Если путём дописывания в определённые x мест закрывающейся скобки, строку можно сделать правильной скобочной последовательностью, то её также можно сделать правильной дописывая x закрывающихся скобок просто в конец. Из всех строк, которые можно получить дописыванием в произвольные x мест закрывающейся скобки, минимальной является та, в которой скобки дописываются в конец. Каждое из этих утверждений несложно проверить, а в совокупности они нам дают тот факт, что в оптимальном ответе мы дописываем закрывающиеся скобки в конец строки. Значит, нам надо рассмотреть множество таких циклических сдвигов строки, что они превращаются в правильную скобочную последовательность при приписывании в конец x = A - B закрывающихся скобок (т. е. просто не имеют нигде отрицательного баланса), и выбрать из них лексикографически минимальный. Сравнение циклических сдвигов строки можно проводить либо при помощи суффиксного массива, либо же, так как нам требуется только найти минимальный сдвиг из определённого множества, можно сравнивать сдвиги между собой при помощи бинарного поиска и хеширования.Аналогично делается случай, когда A ≤ B, с единственным отличием, что открывающиеся скобки дописываются в начало.Таким образом, выходит решение за сложность .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 529 和字母"
          },
          "content_length": 8076
        }
      ],
      "code_examples": [
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 1",
          "code": "common / degree >= k / 100.0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 2",
          "code": "common * 100 >= degree * k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 3",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 4",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(s.length() >= 1 && s.length() <= 1000000, \"Length of s must be between 1 and 1000000 inclusive, but is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(s.length() >= 1 && s.length() <= 1000000, \"Length of s must be between 1 and 1000000 inclusive, but is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    string s = inf.readLine(\"[()]+\", \"s\");\n    ensuref(s.length() >= 1 && s.length() <= 1000000, \"Length of s must be between 1 and 1000000 inclusive, but is %d\", (int)s.length());\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            if (rnd.next(2))\n                s[i] = '(';\n            else\n                s[i] = ')';\n        }\n    } else if (type == \"all_open\") {\n        s = string(len, '(');\n    } else if (type == \"all_close\") {\n        s = string(len, ')');\n    } else if (type == \"balanced\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s = ')' + s;\n        }\n    } else if (type == \"max_nesting\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s = ')' + s;\n        }\n    } else if (type == \"alternating\") {\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (i % 2 == 0)\n                s += '(';\n            else\n                s += ')';\n        }\n    } else if (type == \"need_cyclic_shift\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n        int shift = rnd.next(1, len - 1);\n        s = s.substr(len - shift) + s.substr(0, len - shift);\n    } else if (type == \"need_insertion\") {\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n        // Ensure imbalance\n        if (count(s.begin(), s.end(), '(') == count(s.begin(), s.end(), ')')) {\n            s[0] = '(';\n            s[1] = '(';\n        }\n    } else if (type == \"length_one\") {\n        s = \"(\";\n        if (len != 1)\n            len = 1;\n        if (rnd.next(2))\n            s = \"(\";\n        else\n            s = \")\";\n    } else if (type == \"deep_unbalanced\") {\n        int opens = len * 2 / 3;\n        s = string(opens, '(') + string(len - opens, ')');\n    } else if (type == \"reverse_balanced\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s = '(' + s;\n            else\n                s = ')' + s;\n        }\n    } else {\n        // Default to random\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            if (rnd.next(2))\n                s[i] = '(';\n            else\n                s[i] = ')';\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int len = opt<int>(\"len\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string s;\n\n    if (type == \"random\") {\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            if (rnd.next(2))\n                s[i] = '(';\n            else\n                s[i] = ')';\n        }\n    } else if (type == \"all_open\") {\n        s = string(len, '(');\n    } else if (type == \"all_close\") {\n        s = string(len, ')');\n    } else if (type == \"balanced\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s = ')' + s;\n        }\n    } else if (type == \"max_nesting\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s = ')' + s;\n        }\n    } else if (type == \"alternating\") {\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (i % 2 == 0)\n                s += '(';\n            else\n                s += ')';\n        }\n    } else if (type == \"need_cyclic_shift\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n        int shift = rnd.next(1, len - 1);\n        s = s.substr(len - shift) + s.substr(0, len - shift);\n    } else if (type == \"need_insertion\") {\n        s = \"\";\n        for (int i = 0; i < len; ++i) {\n            if (rnd.next(2))\n                s += '(';\n            else\n                s += ')';\n        }\n        // Ensure imbalance\n        if (count(s.begin(), s.end(), '(') == count(s.begin(), s.end(), ')')) {\n            s[0] = '(';\n            s[1] = '(';\n        }\n    } else if (type == \"length_one\") {\n        s = \"(\";\n        if (len != 1)\n            len = 1;\n        if (rnd.next(2))\n            s = \"(\";\n        else\n            s = \")\";\n    } else if (type == \"deep_unbalanced\") {\n        int opens = len * 2 / 3;\n        s = string(opens, '(') + string(len - opens, ')');\n    } else if (type == \"reverse_balanced\") {\n        int n = len / 2;\n        s = \"\";\n        for (int i = 0; i < n; ++i)\n            s += ')';\n        for (int i = 0; i < n; ++i)\n            s += '(';\n        if (len % 2 == 1) {\n            if (rnd.next(2))\n                s = '(' + s;\n            else\n                s = ')' + s;\n        }\n    } else {\n        // Default to random\n        s.resize(len);\n        for (int i = 0; i < len; ++i) {\n            if (rnd.next(2))\n                s[i] = '(';\n            else\n                s[i] = ')';\n        }\n    }\n\n    printf(\"%s\\n\", s.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -len 1 -type length_one\n\n./gen -len 2 -type balanced\n\n./gen -len 2 -type need_insertion\n\n./gen -len 5 -type random\n\n./gen -len 5 -type balanced\n\n./gen -len 5 -type need_cyclic_shift\n\n./gen -len 5 -type all_open\n\n./gen -len 5 -type all_close\n\n./gen -len 5 -type alternating\n\n./gen -len 5 -type need_insertion\n\n./gen -len 10 -type balanced\n\n./gen -len 10 -type need_insertion\n\n./gen -len 10 -type need_cyclic_shift\n\n./gen -len 10 -type deep_unbalanced\n\n./gen -len 10 -type reverse_balanced\n\n./gen -len 1000 -type random\n\n./gen -len 1000 -type balanced\n\n./gen -len 1000 -type need_insertion\n\n./gen -len 1000 -type need_cyclic_shift\n\n./gen -len 1000 -type alternating\n\n./gen -len 1000 -type all_open\n\n./gen -len 1000 -type all_close\n\n./gen -len 100000 -type random\n\n./gen -len 100000 -type balanced\n\n./gen -len 100000 -type need_insertion\n\n./gen -len 100000 -type need_cyclic_shift\n\n./gen -len 100000 -type deep_unbalanced\n\n./gen -len 100000 -type all_open\n\n./gen -len 100000 -type all_close\n\n./gen -len 999999 -type random\n\n./gen -len 1000000 -type random\n\n./gen -len 1000000 -type balanced\n\n./gen -len 1000000 -type need_insertion\n\n./gen -len 1000000 -type need_cyclic_shift\n\n./gen -len 1000000 -type deep_unbalanced\n\n./gen -len 1000000 -type all_open\n\n./gen -len 1000000 -type all_close\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:11.133377",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "529/B",
      "title": "B. Group Photo 2 (online mirror version)",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 1000) — the number of friends.The next n lines have two integers wi, hi (1 ≤ wi, hi ≤ 1000) each, representing the size of the rectangle, corresponding to the i-th friend.",
      "output_spec": "OutputPrint a single integer equal to the minimum possible area of the photo containing all friends if no more than n / 2 of them can lie on the ground.",
      "sample_tests": "ExamplesInputCopy310 120 230 3OutputCopy180InputCopy33 12 24 3OutputCopy21InputCopy15 10OutputCopy50",
      "description": "B. Group Photo 2 (online mirror version)\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 1000) — the number of friends.The next n lines have two integers wi, hi (1 ≤ wi, hi ≤ 1000) each, representing the size of the rectangle, corresponding to the i-th friend.\n\nOutputPrint a single integer equal to the minimum possible area of the photo containing all friends if no more than n / 2 of them can lie on the ground.\n\nInputCopy310 120 230 3OutputCopy180InputCopy33 12 24 3OutputCopy21InputCopy15 10OutputCopy50\n\nInputCopy310 120 230 3\n\nOutputCopy180\n\nInputCopy33 12 24 3\n\nOutputCopy21\n\nInputCopy15 10\n\nOutputCopy50",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 529\\s*B"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int w_i = inf.readInt(1, 1000, \"w_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 1000, \"h_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int w_i = inf.readInt(1, 1000, \"w_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 1000, \"h_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int w_i = inf.readInt(1, 1000, \"w_i\");\n        inf.readSpace();\n        int h_i = inf.readInt(1, 1000, \"h_i\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> wi(n), hi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 1000);\n            hi[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_wh\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = 1000;\n            hi[i] = 1000;\n        }\n    } else if (type == \"min_wh\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = 1;\n            hi[i] = 1;\n        }\n    } else if (type == \"equal_wh\") {\n        int val = rnd.next(1, 1000);\n        for (int i = 0; i < n; i++) {\n            wi[i] = val;\n            hi[i] = val;\n        }\n    } else if (type == \"increasing_wh\") {\n        int start = rnd.next(1, 100);\n        for (int i = 0; i < n; i++) {\n            wi[i] = start + i;\n            hi[i] = start + i;\n            if (wi[i] > 1000) wi[i] = 1000;\n            if (hi[i] > 1000) hi[i] = 1000;\n        }\n    } else if (type == \"decreasing_wh\") {\n        int start = rnd.next(n, 1000);\n        for (int i = 0; i < n; i++) {\n            wi[i] = start - i;\n            hi[i] = start - i;\n            if (wi[i] < 1) wi[i] = 1;\n            if (hi[i] < 1) hi[i] = 1;\n        }\n    } else if (type == \"large_wi_small_hi\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(500, 1000);\n            hi[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"small_wi_large_hi\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 10);\n            hi[i] = rnd.next(500, 1000);\n        }\n    } else if (type == \"special_case_1\") {\n        // Friends with large width and small height, lying down reduces area\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(800, 1000);\n            hi[i] = rnd.next(1, 200);\n        }\n    } else if (type == \"special_case_2\") {\n        // Friends with small width and large height, lying down not beneficial\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 200);\n            hi[i] = rnd.next(800, 1000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 1000);\n            hi[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", wi[i], hi[i]);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> wi(n), hi(n);\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 1000);\n            hi[i] = rnd.next(1, 1000);\n        }\n    } else if (type == \"max_wh\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = 1000;\n            hi[i] = 1000;\n        }\n    } else if (type == \"min_wh\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = 1;\n            hi[i] = 1;\n        }\n    } else if (type == \"equal_wh\") {\n        int val = rnd.next(1, 1000);\n        for (int i = 0; i < n; i++) {\n            wi[i] = val;\n            hi[i] = val;\n        }\n    } else if (type == \"increasing_wh\") {\n        int start = rnd.next(1, 100);\n        for (int i = 0; i < n; i++) {\n            wi[i] = start + i;\n            hi[i] = start + i;\n            if (wi[i] > 1000) wi[i] = 1000;\n            if (hi[i] > 1000) hi[i] = 1000;\n        }\n    } else if (type == \"decreasing_wh\") {\n        int start = rnd.next(n, 1000);\n        for (int i = 0; i < n; i++) {\n            wi[i] = start - i;\n            hi[i] = start - i;\n            if (wi[i] < 1) wi[i] = 1;\n            if (hi[i] < 1) hi[i] = 1;\n        }\n    } else if (type == \"large_wi_small_hi\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(500, 1000);\n            hi[i] = rnd.next(1, 10);\n        }\n    } else if (type == \"small_wi_large_hi\") {\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 10);\n            hi[i] = rnd.next(500, 1000);\n        }\n    } else if (type == \"special_case_1\") {\n        // Friends with large width and small height, lying down reduces area\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(800, 1000);\n            hi[i] = rnd.next(1, 200);\n        }\n    } else if (type == \"special_case_2\") {\n        // Friends with small width and large height, lying down not beneficial\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 200);\n            hi[i] = rnd.next(800, 1000);\n        }\n    } else {\n        // Default to random\n        for (int i = 0; i < n; i++) {\n            wi[i] = rnd.next(1, 1000);\n            hi[i] = rnd.next(1, 1000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; i++) {\n        printf(\"%d %d\\n\", wi[i], hi[i]);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type min_wh\n./gen -n 1 -type max_wh\n./gen -n 1 -type equal_wh\n./gen -n 1 -type random\n\n./gen -n 2 -type min_wh\n./gen -n 2 -type max_wh\n./gen -n 2 -type equal_wh\n./gen -n 2 -type random\n\n./gen -n 3 -type small_wi_large_hi\n./gen -n 3 -type large_wi_small_hi\n./gen -n 3 -type equal_wh\n./gen -n 3 -type increasing_wh\n\n./gen -n 10 -type random\n./gen -n 10 -type special_case_1\n./gen -n 10 -type special_case_2\n\n./gen -n 50 -type random\n./gen -n 50 -type decreasing_wh\n./gen -n 50 -type increasing_wh\n\n./gen -n 100 -type random\n./gen -n 100 -type special_case_1\n./gen -n 100 -type special_case_2\n./gen -n 100 -type max_wh\n\n./gen -n 500 -type random\n./gen -n 500 -type special_case_1\n./gen -n 500 -type special_case_2\n\n./gen -n 1000 -type random\n./gen -n 1000 -type special_case_1\n./gen -n 1000 -type special_case_2\n./gen -n 1000 -type max_wh\n\n./gen -n 1000 -type min_wh\n./gen -n 1000 -type equal_wh\n./gen -n 1000 -type small_wi_large_hi\n\n./gen -n 999 -type special_case_1\n./gen -n 999 -type special_case_2\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:13.381529",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "529/C",
      "title": "C. Ладьи и прямоугольники",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке содержатся четыре целых числа n, m, k и q (1 ≤ n, m ≤ 100 000, 1 ≤ k, q ≤ 200 000) — размеры доски, количество ладей и количество стратегически важных участков. Будем считать, что клетки доски пронумерованы числами от 1 до n по горизонтали и от 1 до m по вертикали. Следующие k строк содержат пары целых чисел «x y», описывающие положение ладей (1 ≤ x ≤ n, 1 ≤ y ≤ m). Гарантируется, что все ладьи стоят в разных клетках. Следующие q строк описывают стратегически важные участки четверками чисел «x1 y1 x2 y2» (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ m). Соответствующий прямоугольный участок состоит из клеток (x, y), для которых x1 ≤ x ≤ x2, y1 ≤ y ≤ y2. Стратегически важные участки могут пересекаться или совпадать.",
      "output_spec": "Выходные данныеВыведите q строк. Для каждого стратегически важного участка выведите «YES», если он надежно защищен, и «NO» в противном случае.",
      "sample_tests": "ПримерыВходные данныеСкопировать4 3 3 31 13 22 32 3 2 32 1 3 31 2 2 3Выходные данныеСкопироватьYESYESNO",
      "description": "C. Ладьи и прямоугольники\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке содержатся четыре целых числа n, m, k и q (1 ≤ n, m ≤ 100 000, 1 ≤ k, q ≤ 200 000) — размеры доски, количество ладей и количество стратегически важных участков. Будем считать, что клетки доски пронумерованы числами от 1 до n по горизонтали и от 1 до m по вертикали. Следующие k строк содержат пары целых чисел «x y», описывающие положение ладей (1 ≤ x ≤ n, 1 ≤ y ≤ m). Гарантируется, что все ладьи стоят в разных клетках. Следующие q строк описывают стратегически важные участки четверками чисел «x1 y1 x2 y2» (1 ≤ x1 ≤ x2 ≤ n, 1 ≤ y1 ≤ y2 ≤ m). Соответствующий прямоугольный участок состоит из клеток (x, y), для которых x1 ≤ x ≤ x2, y1 ≤ y ≤ y2. Стратегически важные участки могут пересекаться или совпадать.\n\nВходные данные\n\nВыходные данныеВыведите q строк. Для каждого стратегически важного участка выведите «YES», если он надежно защищен, и «NO» в противном случае.\n\nВыходные данные\n\nВходные данныеСкопировать4 3 3 31 13 22 32 3 2 32 1 3 31 2 2 3Выходные данныеСкопироватьYESYESNO\n\nВходные данныеСкопировать4 3 3 31 13 22 32 3 2 32 1 3 31 2 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьYESYESNO\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеРисунок к примеру:  Для последнего участка ответ «NO», потому что клетка (1, 2) не бьется ладьей.",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces",
          "content": "Набор задач в онлайн-трансляции незначительно отличается от набора задач на основном раунде, задачи следуют в порядке, в котором они фигурируют в основном раунде.524A - Возможно, вы знаете этих людей?В задаче требовалось реализовать ровно то, что описано в условии. Фиксируем человека x, проходимся по всем остальным людям y, не дружащим с x, и считаем количество общих друзей x и y.Тонкий момент №1: несмотря на то, пар друзей во вводе не более 100, самих людей может быть до 200, и можно ошибиться в выставлении размеров массивов.Тонкий момент №2: нужно аккуратно сравнивать вещественные числа. Если написать нечто вроде common / degree >= k / 100.0, то в силу специфики вычислений с вещественными числами, результат такой проверки может быть недетерминирован (если в какую-то из частей внесётся незначительная погрешность). Поэтому, надо либо сравнивать с точностью до некоторого eps, либо выполнять проверку в целых числах: common * 100 >= degree * k.524B - Фото на память - 2 (round version)Переберём высоту итоговой фотографии. При фиксированной высоте нам требуется минимизировать суммарную ширину всех прямоугольников. Таким образом, для каждого прямоугольника нужно выбрать такое из двух его положений, которое, во-первых, подходит по высоте, а во-вторых, имеет меньшую возможную ширину.529B - Фото на память - 2 (online mirror version)В версии для онлайн-трансляции условие было незначительно изменено — разрешается, чтобы не более n / 2 людей лежали на фотографии. Это слегка усложняет решение. Введём терминологию: людей, у которых w ≤ h, будем называть высокими, а остальных людей — широкими. Зафиксируем итоговую высоту фотографии H. Далее, следует небольшой разбор случаев. Если высокий человек влезает под высоту H, то мы его оставляем именно в таком состоянии. Если высокий человек не влезает под высоту H, то мы обязаны его положить, увеличиваем счётчик таких людей на 1. Если широкий человек влезает под высоту H, но не влезает, будучи положенным, то ставим его. Если широкий человек влезает под высоту H обоими способами, то сначала ставим его, а в отдельный массив выписываем величину, на которую уменьшится ответ, если этого человека всё-таки положить: w - h. Если же кто-то не влезает ни одним из двух способов, то подобное значение H недопустимо. Теперь у нас есть какое-то количество людей, которые обязательно должны лечь (из второго пункта), причём, если их слишком много, а именно, больше, чем n / 2, то подобное значение H недопустимо. За вычетом людей из второго пункта у нас осталось некоторое количество вакантных лежачих мест — распределяем их по людям из четвёртого пункта в порядке уменьшения величины (w — h). Считаем площадь фотографии, выбираем минимум по всем H.524C - Искусство обращения с бакноматомПредполагаемое решение имеет сложность или . Для каждой возможной суммы денег x = t·ai (1 ≤ t ≤ k) выпишем пару (x, t) в массив, здесь t — количество купюр, которым такую сумму можно достичь. Отсортируем этот массив. Тогда чтобы ответить на один запрос, переберём первое слагаемое в сумме, а второе либо найдём бинарным поиском, либо воспользуемся методом двух указателей, чтобы найти парное слагаемое за амортизированное время O(1). Проверим, что получилось не более k купюр в сумме, улучшим ответ, если надо.524D - Социальная сетьБудем жадно действовать следующим образом. Идём по запросам в порядке поступления. Каждый очередной запрос пытаемся сопоставить новому человеку. Разумеется, это не всегда возможно сделать — если у нас уже есть M активных людей на сайте, то мы обязаны сопоставить очередной запрос кому-то из них. Возникает вопрос — кому именно?Можно показать, что выгоднее всего сопоставить этот запрос самому недавнему из активных людей. Действительно, подобное “критическое” (по количеству людей) состояние можно задать вектором из M чисел — временами с момента последнего запроса каждого из людей в убывающем порядке. Тогда если сейчас состояние — (a1, a2, ..., aM), то мы можем перейти в одно из M новых состояний (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0), в зависимости от того, к кому мы подцепим очередной запрос. Видно, что самый первый вектор покомпонентно больше, чем любой из оставшихся, а это значит, что он выгоднее всех остальных (т. к. чем больше число на определённой позиции в векторе, тем скорее может исчезнуть этот человек, и тем больше у нас остаётся свободы для последующих действий).Значит, нам требуется моделировать процесс, поддерживая в некоторой структуре данных множество активных людей с временами их активности. В качестве подобной структуры можно воспользоваться любой структурой, реализующей интерфейс очереди с приоритетом (priority_queue, set, дерево отрезков или что-либо ещё). Итоговая сложность решения — .524E - Ладьи и прямоугольникиПоймём, что означает тот факт, что какая-то клетка прямоугольника не побита ладьёй. Это значит, что существует строка прямоугольника, не содержащая ладью, и существует столбец прямоугольника, не содержащий ладью. Не очень ясно, как проверять это утверждение, поэтому проверим обратное к нему — мы только что показали, что прямоугольник является покрытым, если либо в каждой строке стоит ладья, либо в каждом столбце стоит ладья.Эти утверждения можно проверять по отдельности. Как проверить для набора прямоугольников, что в каждой строке находится отмеченная точка? Это можно сделать за один проход вертикальной сканирующей прямой. Пусть мы идём слева направо и прошли через правую границу прямоугольника, расположенного в строках с a-й по b-ю, левая граница которого находится в столбце x. Тогда если обозначить за last[i] позицию последней ладьи, встреченной в строке номер i, то критерий для прямоугольника выглядит следующим образом: . Это значит, что для хранения величины last можно воспользоваться деревом отрезков. Аналогично проверяем для столбцов. Выходит решение, отвечающее на все запросы off-line за время O((q + k)log(n + m)).524F - И снова правильная скобочная последовательностьОбщая идея заключается в том, что скобочные последовательности можно рассматривать как последовательности балансов префиксов, т. е. как последовательности чисел (ai), где ai + 1 = ai ± 1.Посчитаем количество открывающихся скобок A и закрывающихся скобок B в исходной строке. Заметим, что если A >  = B, то строку всегда можно исправить, дописав A - B закрывающихся скобок в конец, и циклически сдвинув строку в точку минимума баланса, а если A ≤ B, то строку аналогично можно исправить, дописав B - A открывающихся скобок в начало. Очевидно, что меньшим количеством скобок не обойтись. Таким образом, мы уже знаем величину ответа, теперь нужно понять, как он устроен.Будем считать, что мы сначала производим циклический сдвиг, а потом только добавляем скобки. Пусть, для определённости, мы дописываем x закрывающихся скобок. Сформулируем два несложных утверждения: Если путём дописывания в определённые x мест закрывающейся скобки, строку можно сделать правильной скобочной последовательностью, то её также можно сделать правильной дописывая x закрывающихся скобок просто в конец. Из всех строк, которые можно получить дописыванием в произвольные x мест закрывающейся скобки, минимальной является та, в которой скобки дописываются в конец. Каждое из этих утверждений несложно проверить, а в совокупности они нам дают тот факт, что в оптимальном ответе мы дописываем закрывающиеся скобки в конец строки. Значит, нам надо рассмотреть множество таких циклических сдвигов строки, что они превращаются в правильную скобочную последовательность при приписывании в конец x = A - B закрывающихся скобок (т. е. просто не имеют нигде отрицательного баланса), и выбрать из них лексикографически минимальный. Сравнение циклических сдвигов строки можно проводить либо при помощи суффиксного массива, либо же, так как нам требуется только найти минимальный сдвиг из определённого множества, можно сравнивать сдвиги между собой при помощи бинарного поиска и хеширования.Аналогично делается случай, когда A ≤ B, с единственным отличием, что открывающиеся скобки дописываются в начало.Таким образом, выходит решение за сложность .",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 529 和字母"
          },
          "content_length": 8076
        }
      ],
      "code_examples": [
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 1",
          "code": "common / degree >= k / 100.0",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 2",
          "code": "common * 100 >= degree * k",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 3",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        },
        {
          "title": "Разбор VK Cup Round 1 - Codeforces - Code 4",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> rook_positions;\n\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(x, y);\n        ensuref(rook_positions.count(pos) == 0, \"Duplicate rook position at line %d\", i + 2);\n        rook_positions.insert(pos);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1_i\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1_i\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, n, \"x2_i\");\n        inf.readSpace();\n        int y2 = inf.readInt(y1, m, \"y2_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> rook_positions;\n\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(x, y);\n        ensuref(rook_positions.count(pos) == 0, \"Duplicate rook position at line %d\", i + 2);\n        rook_positions.insert(pos);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1_i\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1_i\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, n, \"x2_i\");\n        inf.readSpace();\n        int y2 = inf.readInt(y1, m, \"y2_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 100000, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(1, 200000, \"k\");\n    inf.readSpace();\n    int q = inf.readInt(1, 200000, \"q\");\n    inf.readEoln();\n\n    set<pair<int, int>> rook_positions;\n\n    for (int i = 0; i < k; ++i) {\n        int x = inf.readInt(1, n, \"x_i\");\n        inf.readSpace();\n        int y = inf.readInt(1, m, \"y_i\");\n        inf.readEoln();\n\n        pair<int, int> pos = make_pair(x, y);\n        ensuref(rook_positions.count(pos) == 0, \"Duplicate rook position at line %d\", i + 2);\n        rook_positions.insert(pos);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int x1 = inf.readInt(1, n, \"x1_i\");\n        inf.readSpace();\n        int y1 = inf.readInt(1, m, \"y1_i\");\n        inf.readSpace();\n        int x2 = inf.readInt(x1, n, \"x2_i\");\n        inf.readSpace();\n        int y2 = inf.readInt(y1, m, \"y2_i\");\n        inf.readEoln();\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nconst string YES = \"YES\";\r\nconst string NO = \"NO\";\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"%s\", (\"multiple \" + YES + \"/\" + NO + \" (case insensitive)\").c_str());\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int index = 0, yesCount = 0, noCount = 0;\r\n    string pa;\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        index++;\r\n        string ja = upperCase(ans.readToken());\r\n        pa = upperCase(ouf.readToken());\r\n\r\n        if (ja != YES && ja != NO)\r\n            quitf(_fail, \"%s or %s expected in answer, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(ja).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (pa == YES)\r\n            yesCount++;\r\n        else if (pa == NO)\r\n            noCount++;\r\n        else\r\n            quitf(_pe, \"%s or %s expected, but %s found [%d%s token]\",\r\n                  YES.c_str(), NO.c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n\r\n        if (ja != pa)\r\n            quitf(_wa, \"expected %s, found %s [%d%s token]\",\r\n                  compress(ja).c_str(), compress(pa).c_str(), index, englishEnding(index).c_str());\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n    while (!ans.seekEof()) {\r\n        ans.readToken();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n    while (!ouf.seekEof()) {\r\n        ouf.readToken();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              index + extraInAnsCount, index);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              index + extraInOufCount, index);\r\n\r\n    if (index == 0)\r\n        quitf(_ok, \"Empty output\");\r\n    else if (index == 1)\r\n        quitf(_ok, \"%s\", pa.c_str());\r\n    else\r\n        quitf(_ok, \"%d token(s): yes count is %d, no count is %d\", index, yesCount, noCount);\r\n\r\n    quitf(_fail, \"Impossible case\");\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Pos {\n    int x, y;\n    Pos(int _x, int _y) : x(_x), y(_y) {}\n    bool operator<(const Pos& other) const {\n        if (x != other.x) return x < other.x;\n        return y < other.y;\n    }\n};\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    int k = opt<int>(\"k\", min(1000, n*m));\n    int q = opt<int>(\"q\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k and q are within constraints\n    k = min(k, min(n * m, 200000));\n    q = min(q, 200000);\n\n    vector<Pos> rooks;\n    vector<tuple<int,int,int,int>> rectangles;\n    set<Pos> positions;\n\n    if (type == \"random\") {\n        // Generate k distinct rook positions\n        while ((int)rooks.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        k = 0;\n        q = 1;\n        // No rooks\n        // Rectangle covering the only cell\n        rectangles.emplace_back(1, 1, 1, 1);\n    } else if (type == \"full_board\") {\n        // Place rooks on every square\n        k = min(n * m, 200000);\n        int total = k;\n        int x_limit = n;\n        int y_limit = m;\n        for (int x = 1; x <= x_limit && total > 0; ++x) {\n            for (int y = 1; y <= y_limit && total > 0; ++y) {\n                positions.insert(Pos(x, y));\n                rooks.push_back(Pos(x, y));\n                --total;\n            }\n        }\n        // Generate random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"no_rooks\") {\n        k = 0;\n        // No rooks\n        // Generate random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"single_row\") {\n        n = 1;\n        // m is given\n        k = min(k, m);\n        positions.clear();\n        while ((int)rooks.size() < k) {\n            int x = 1;\n            int y = rnd.next(1, m);\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = 1;\n            int x2 = 1;\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"single_column\") {\n        m = 1;\n        // n is given\n        k = min(k, n);\n        positions.clear();\n        while ((int)rooks.size() < k) {\n            int x = rnd.next(1, n);\n            int y = 1;\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n            int y1 = 1;\n            int y2 = 1;\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"blocked\") {\n        // Generate a rectangle with rooks blocking each other\n        k = q = 1;\n\n        // Fixed n, m\n        n = m = 3;\n\n        // Place rooks at (1,2) and (2,1), so they block each other from attacking (2,2)\n        rooks.push_back(Pos(1, 2));\n        rooks.push_back(Pos(2, 1));\n        k = 2;\n\n        // Rectangle is the entire board\n        rectangles.emplace_back(1, 1, n, m);\n        q = 1;\n    } else if (type == \"max_rooks\") {\n        k = min(n * m, 200000);\n        positions.clear();\n\n        int total = k;\n        for (int x = 1; x <= n && total > 0; ++x) {\n            for (int y = 1; y <= m && total > 0; ++y) {\n                positions.insert(Pos(x, y));\n                rooks.push_back(Pos(x, y));\n                --total;\n            }\n        }\n        // Generate random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else {\n        // Default to 'random'\n        // Same as 'random' type\n        // Generate k distinct rook positions\n        while ((int)rooks.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n    // Output rook positions\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", rooks[i].x, rooks[i].y);\n    }\n\n    // Output rectangle definitions\n    for (int i = 0; i < q; ++i) {\n        int x1, y1, x2, y2;\n        tie(x1, y1, x2, y2) = rectangles[i];\n        printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Pos {\n    int x, y;\n    Pos(int _x, int _y) : x(_x), y(_y) {}\n    bool operator<(const Pos& other) const {\n        if (x != other.x) return x < other.x;\n        return y < other.y;\n    }\n};\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int m = opt<int>(\"m\", 10);\n    int k = opt<int>(\"k\", min(1000, n*m));\n    int q = opt<int>(\"q\", 1000);\n    string type = opt<string>(\"type\", \"random\");\n\n    // Ensure k and q are within constraints\n    k = min(k, min(n * m, 200000));\n    q = min(q, 200000);\n\n    vector<Pos> rooks;\n    vector<tuple<int,int,int,int>> rectangles;\n    set<Pos> positions;\n\n    if (type == \"random\") {\n        // Generate k distinct rook positions\n        while ((int)rooks.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"minimal\") {\n        n = 1;\n        m = 1;\n        k = 0;\n        q = 1;\n        // No rooks\n        // Rectangle covering the only cell\n        rectangles.emplace_back(1, 1, 1, 1);\n    } else if (type == \"full_board\") {\n        // Place rooks on every square\n        k = min(n * m, 200000);\n        int total = k;\n        int x_limit = n;\n        int y_limit = m;\n        for (int x = 1; x <= x_limit && total > 0; ++x) {\n            for (int y = 1; y <= y_limit && total > 0; ++y) {\n                positions.insert(Pos(x, y));\n                rooks.push_back(Pos(x, y));\n                --total;\n            }\n        }\n        // Generate random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"no_rooks\") {\n        k = 0;\n        // No rooks\n        // Generate random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"single_row\") {\n        n = 1;\n        // m is given\n        k = min(k, m);\n        positions.clear();\n        while ((int)rooks.size() < k) {\n            int x = 1;\n            int y = rnd.next(1, m);\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = 1;\n            int x2 = 1;\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"single_column\") {\n        m = 1;\n        // n is given\n        k = min(k, n);\n        positions.clear();\n        while ((int)rooks.size() < k) {\n            int x = rnd.next(1, n);\n            int y = 1;\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n            int y1 = 1;\n            int y2 = 1;\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else if (type == \"blocked\") {\n        // Generate a rectangle with rooks blocking each other\n        k = q = 1;\n\n        // Fixed n, m\n        n = m = 3;\n\n        // Place rooks at (1,2) and (2,1), so they block each other from attacking (2,2)\n        rooks.push_back(Pos(1, 2));\n        rooks.push_back(Pos(2, 1));\n        k = 2;\n\n        // Rectangle is the entire board\n        rectangles.emplace_back(1, 1, n, m);\n        q = 1;\n    } else if (type == \"max_rooks\") {\n        k = min(n * m, 200000);\n        positions.clear();\n\n        int total = k;\n        for (int x = 1; x <= n && total > 0; ++x) {\n            for (int y = 1; y <= m && total > 0; ++y) {\n                positions.insert(Pos(x, y));\n                rooks.push_back(Pos(x, y));\n                --total;\n            }\n        }\n        // Generate random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(x1, n);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(y1, m);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    } else {\n        // Default to 'random'\n        // Same as 'random' type\n        // Generate k distinct rook positions\n        while ((int)rooks.size() < k) {\n            int x = rnd.next(1, n);\n            int y = rnd.next(1, m);\n            Pos p(x, y);\n            if (positions.count(p) == 0) {\n                positions.insert(p);\n                rooks.push_back(p);\n            }\n        }\n\n        // Generate q random rectangles\n        for (int i = 0; i < q; ++i) {\n            int x1 = rnd.next(1, n);\n            int x2 = rnd.next(1, n);\n            if (x1 > x2) swap(x1, x2);\n            int y1 = rnd.next(1, m);\n            int y2 = rnd.next(1, m);\n            if (y1 > y2) swap(y1, y2);\n            rectangles.emplace_back(x1, y1, x2, y2);\n        }\n    }\n\n    printf(\"%d %d %d %d\\n\", n, m, k, q);\n\n    // Output rook positions\n    for (int i = 0; i < k; ++i) {\n        printf(\"%d %d\\n\", rooks[i].x, rooks[i].y);\n    }\n\n    // Output rectangle definitions\n    for (int i = 0; i < q; ++i) {\n        int x1, y1, x2, y2;\n        tie(x1, y1, x2, y2) = rectangles[i];\n        printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type minimal\n\n./gen -n 1 -m 100000 -k 100000 -q 100 -type single_row\n\n./gen -n 100000 -m 1 -k 100000 -q 100 -type single_column\n\n./gen -n 1000 -m 1000 -k 1000 -q 1000 -type random\n\n./gen -n 1000 -m 1000 -k 0 -q 1000 -type no_rooks\n\n./gen -n 100000 -m 100000 -k 200000 -q 200000 -type max_rooks\n\n./gen -n 1000 -m 1000 -k 200000 -q 200000 -type full_board\n\n./gen -n 3 -m 3 -type blocked\n\n./gen -n 100000 -m 100000 -k 200000 -q 200000 -type random\n\n./gen -n 50000 -m 50000 -k 200000 -q 200000 -type random\n\n./gen -n 100000 -m 100000 -k 10 -q 200000 -type random\n\n./gen -n 100000 -m 100000 -k 0 -q 200000 -type no_rooks\n\n./gen -n 100000 -m 100000 -k 200000 -q 200000 -type full_board\n\n./gen -n 1 -m 100000 -k 1 -q 100000 -type single_row\n\n./gen -n 100000 -m 1 -k 1 -q 100000 -type single_column\n\n./gen -n 100000 -m 100000 -k 5 -q 5 -type random\n\n./gen -n 100000 -m 100000 -k 200000 -q 5 -type full_board\n\n./gen -n 100000 -m 100000 -k 200000 -q 100000 -type max_rooks\n\n./gen -n 1000 -m 100000 -k 100000 -q 200000 -type random\n\n./gen -n 100000 -m 1000 -k 100000 -q 200000 -type random\n\n./gen -n 50000 -m 50000 -k 50000 -q 50000 -type random\n\n./gen -n 50000 -m 50000 -k 200000 -q 200000 -type full_board\n\n./gen -n 2 -m 2 -type blocked\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:15.282426",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "529/D",
      "title": "D. Social Network",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, M and T (1 ≤ n, M ≤ 20 000, 1 ≤ T ≤ 86400) — the number of queries, the record number of online users and the time when the user was online after a query was sent. Next n lines contain the times of the queries in the format \"hh:mm:ss\", where hh are hours, mm are minutes, ss are seconds. The times of the queries follow in the non-decreasing order, some of them can coincide. It is guaranteed that all the times and even all the segments of type [s, s + T - 1] are within one 24-hour range (from 00:00:00 to 23:59:59).",
      "output_spec": "OutputIn the first line print number R — the largest possible number of distinct users. The following n lines should contain the user IDs for requests in the same order in which the requests are given in the input. User IDs must be integers from 1 to R. The requests of the same user must correspond to the same identifiers, the requests of distinct users must correspond to distinct identifiers. If there are multiple solutions, print any of them. If there is no solution, print \"No solution\" (without the quotes).",
      "sample_tests": "ExamplesInputCopy4 2 1017:05:5317:05:5817:06:0122:39:47OutputCopy31223InputCopy1 2 8640000:00:00OutputCopyNo solution",
      "description": "D. Social Network\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains three integers n, M and T (1 ≤ n, M ≤ 20 000, 1 ≤ T ≤ 86400) — the number of queries, the record number of online users and the time when the user was online after a query was sent. Next n lines contain the times of the queries in the format \"hh:mm:ss\", where hh are hours, mm are minutes, ss are seconds. The times of the queries follow in the non-decreasing order, some of them can coincide. It is guaranteed that all the times and even all the segments of type [s, s + T - 1] are within one 24-hour range (from 00:00:00 to 23:59:59).\n\nOutputIn the first line print number R — the largest possible number of distinct users. The following n lines should contain the user IDs for requests in the same order in which the requests are given in the input. User IDs must be integers from 1 to R. The requests of the same user must correspond to the same identifiers, the requests of distinct users must correspond to distinct identifiers. If there are multiple solutions, print any of them. If there is no solution, print \"No solution\" (without the quotes).\n\nInputCopy4 2 1017:05:5317:05:5817:06:0122:39:47OutputCopy31223InputCopy1 2 8640000:00:00OutputCopyNo solution\n\nInputCopy4 2 1017:05:5317:05:5817:06:0122:39:47\n\nOutputCopy31223\n\nInputCopy1 2 8640000:00:00\n\nOutputCopyNo solution\n\nNoteConsider the first sample. The user who sent the first request was online from 17:05:53 to 17:06:02, the user who sent the second request was online from 17:05:58 to 17:06:07, the user who sent the third request, was online from 17:06:01 to 17:06:10. Thus, these IDs cannot belong to three distinct users, because in that case all these users would be online, for example, at 17:06:01. That is impossible, because M = 2. That means that some two of these queries belonged to the same user. One of the correct variants is given in the answer to the sample. For it user 1 was online from 17:05:53 to 17:06:02, user 2 — from 17:05:58 to 17:06:10 (he sent the second and third queries), user 3 — from 22:39:47 to 22:39:56.In the second sample there is only one query. So, only one user visited the network within the 24-hour period and there couldn't be two users online on the network simultaneously. (The time the user spent online is the union of time intervals for requests, so users who didn't send requests could not be online in the network.)",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 529 和字母"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int M = inf.readInt(1, 20000, \"M\");\n    inf.readSpace();\n    int T = inf.readInt(1, 86400, \"T\");\n    inf.readEoln();\n\n    vector<long long> s(n);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(\"([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\");\n        int hh, mm, ss;\n        if (sscanf(line.c_str(), \"%d:%d:%d\", &hh, &mm, &ss) != 3) {\n            ensuref(false, \"Failed to parse time at line %d\", i + 1);\n        }\n        long long s_i = hh * 3600LL + mm * 60LL + ss;\n        ensuref(s_i >= 0 && s_i <= 86399LL, \"Time s_i must be in [0, 86399], but s_i = %lld\", s_i);\n        ensuref(s_i + T - 1 <= 86399LL, \"s_i + T -1 must be ≤ 86399, but s_i = %lld, T = %d\", s_i, T);\n        if (i > 0) {\n            ensuref(s_i >= s[i - 1], \"Times must be non-decreasing, but s_i = %lld < previous s_i = %lld\", s_i, s[i - 1]);\n        }\n        s[i] = s_i;\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int M = inf.readInt(1, 20000, \"M\");\n    inf.readSpace();\n    int T = inf.readInt(1, 86400, \"T\");\n    inf.readEoln();\n\n    vector<long long> s(n);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(\"([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\");\n        int hh, mm, ss;\n        if (sscanf(line.c_str(), \"%d:%d:%d\", &hh, &mm, &ss) != 3) {\n            ensuref(false, \"Failed to parse time at line %d\", i + 1);\n        }\n        long long s_i = hh * 3600LL + mm * 60LL + ss;\n        ensuref(s_i >= 0 && s_i <= 86399LL, \"Time s_i must be in [0, 86399], but s_i = %lld\", s_i);\n        ensuref(s_i + T - 1 <= 86399LL, \"s_i + T -1 must be ≤ 86399, but s_i = %lld, T = %d\", s_i, T);\n        if (i > 0) {\n            ensuref(s_i >= s[i - 1], \"Times must be non-decreasing, but s_i = %lld < previous s_i = %lld\", s_i, s[i - 1]);\n        }\n        s[i] = s_i;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 20000, \"n\");\n    inf.readSpace();\n    int M = inf.readInt(1, 20000, \"M\");\n    inf.readSpace();\n    int T = inf.readInt(1, 86400, \"T\");\n    inf.readEoln();\n\n    vector<long long> s(n);\n    for (int i = 0; i < n; ++i) {\n        string line = inf.readLine(\"([0-1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]\");\n        int hh, mm, ss;\n        if (sscanf(line.c_str(), \"%d:%d:%d\", &hh, &mm, &ss) != 3) {\n            ensuref(false, \"Failed to parse time at line %d\", i + 1);\n        }\n        long long s_i = hh * 3600LL + mm * 60LL + ss;\n        ensuref(s_i >= 0 && s_i <= 86399LL, \"Time s_i must be in [0, 86399], but s_i = %lld\", s_i);\n        ensuref(s_i + T - 1 <= 86399LL, \"s_i + T -1 must be ≤ 86399, but s_i = %lld, T = %d\", s_i, T);\n        if (i > 0) {\n            ensuref(s_i >= s[i - 1], \"Times must be non-decreasing, but s_i = %lld < previous s_i = %lld\", s_i, s[i - 1]);\n        }\n        s[i] = s_i;\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int NO_SOLUTION_CODE = -1;\n\n// Parse \"hh:mm:ss\" into an integer second of the day [0..86399].\nint parseTime(const string &ts) {\n    int hh = stoi(ts.substr(0, 2));\n    int mm = stoi(ts.substr(3, 2));\n    int ss = stoi(ts.substr(6, 2));\n    return hh * 3600 + mm * 60 + ss;\n}\n\nstruct Interval {\n    int start, end;\n};\n\nint n, M, T;\nvector<int> requestTimes; // in seconds from midnight\n\n// This function tries to read a solution (\"No solution\" or an integer R followed by n IDs)\n// from the given stream. If the solution is invalid, it quits with _wa (if stream == ouf)\n// or _fail (if stream == ans). If valid, returns the reported R. If \"No solution\", returns -1.\nint readSolution(InStream &stream) {\n    // We attempt to read either \"No solution\" or an integer R.\n    if (!stream.seekEof()) {\n        // read first token\n        string firstToken = stream.readToken();\n        if (firstToken == \"No\") {\n            // read next token to see if it's \"solution\"\n            string secondToken = stream.readToken();\n            if (secondToken == \"solution\") {\n                // It's indeed \"No solution\"\n                return NO_SOLUTION_CODE;\n            } else {\n                // The solution might actually be an integer, or the format is broken.\n                // We'll treat \"No <something else>\" as an integer parse attempt (which should fail if not integer).\n                // Convert firstToken=\"No\" to an integer and see if that fails.\n                // But \"No\" is definitely not an integer, so let's fail/WA.\n                stream.quitf(_wa, \"Expected either 'No solution' or a valid integer for R, got 'No %s' instead.\",\n                             secondToken.c_str());\n            }\n        }\n        // If we got here, firstToken should be an integer R.\n        // We can parse it as integer.\n        int R = 0;\n        try {\n            R = stoi(firstToken);\n        } catch(...) {\n            stream.quitf(_wa, \"Expected either 'No solution' or a valid integer for R, got '%s'.\",\n                         firstToken.c_str());\n        }\n\n        // Now read n user IDs\n        if (R < 1 || R > n) {\n            stream.quitf(_wa, \"Reported number of users R=%d is out of valid range [1..n].\", R);\n        }\n        vector<int> ids(n);\n        for (int i = 0; i < n; i++) {\n            ids[i] = stream.readInt(1, R, format(\"userID for request #%d\", i+1).c_str());\n        }\n\n        // Now we must check feasibility:\n        // 1) The number of distinct userIDs must be <= R. (Trivially true if all are in [1..R].)\n        // 2) At all times, the number of distinct users online does not exceed M.\n        // 3) There is at least one moment where exactly M users are online.\n        //    A user is online in [ requestTime, requestTime + T - 1 ] for each request by that user,\n        //    union of intervals if multiple requests.\n        // We'll do a line sweep to measure coverage.\n\n        // Group intervals by user\n        // intervals[user] = all intervals [start, end] for that user\n        vector<vector<Interval>> userIntervals(R+1);\n        for (int i = 0; i < n; i++) {\n            int u = ids[i];\n            int st = requestTimes[i];\n            int en = st + T - 1;\n            userIntervals[u].push_back({st, en});\n        }\n\n        // Merge intervals for each user\n        // Then collect them in a single list of events (start -> +1, end+1 -> -1)\n        vector<pair<int,int>> events; \n        // (time, +1or-1)\n        for (int u = 1; u <= R; u++) {\n            if (userIntervals[u].empty()) continue;\n            auto &iv = userIntervals[u];\n            // Sort by start\n            sort(iv.begin(), iv.end(), [](auto &a, auto &b){\n                return a.start < b.start;\n            });\n            // Merge\n            vector<Interval> merged;\n            merged.push_back(iv[0]);\n            for (int i = 1; i < (int)iv.size(); i++){\n                Interval &last = merged.back();\n                if (iv[i].start <= last.end+1) {\n                    // Overlap or contiguous => merge\n                    last.end = max(last.end, iv[i].end);\n                } else {\n                    // disjoint\n                    merged.push_back(iv[i]);\n                }\n            }\n            // Now create events\n            for (auto &miv: merged) {\n                events.push_back({miv.start, +1});\n                // end is inclusive, so the user goes offline at miv.end+1\n                if (miv.end+1 <= 86400) { \n                    // ensure we don't go past 24h, but problem states it's within a day\n                    events.push_back({miv.end+1, -1});\n                }\n            }\n        }\n        // Sort all events by time\n        sort(events.begin(), events.end(), [](auto &a, auto &b){\n            if (a.first != b.first) return a.first < b.first;\n            return a.second < b.second; // +1 before -1 at same time is fine either way\n        });\n        int currentCoverage = 0;\n        int maxCoverage = 0;\n        for (auto &e : events) {\n            currentCoverage += e.second;\n            maxCoverage = max(maxCoverage, currentCoverage);\n            if (currentCoverage > M) {\n                // not feasible\n                stream.quitf(_wa, \"Number of users online exceeded M (= %d).\", M);\n            }\n        }\n        if (maxCoverage < M) {\n            stream.quitf(_wa, \"Never reached M (= %d) simultaneous users online.\", M);\n        }\n\n        // If we reach here, it's feasible\n        return R;\n    }\n    // If we reached EOF unexpectedly, that's a format error\n    stream.quitf(_wa, \"Unexpected end of file while reading the solution.\");\n    // Unreachable\n    return NO_SOLUTION_CODE;\n}\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input from inf\n    n = inf.readInt();\n    M = inf.readInt();\n    T = inf.readInt();\n\n    requestTimes.resize(n);\n    for (int i = 0; i < n; i++){\n        string ts = inf.readToken(); // \"hh:mm:ss\"\n        requestTimes[i] = parseTime(ts);\n    }\n\n    // Read and check the jury's answer\n    int jurySolutionR = readSolution(ans);\n    // Read and check the participant's answer\n    int participantSolutionR = readSolution(ouf);\n\n    // Compare them\n    if (jurySolutionR == NO_SOLUTION_CODE) {\n        // Jury says there's no solution\n        if (participantSolutionR == NO_SOLUTION_CODE) {\n            // Both say no solution => OK\n            quitf(_ok, \"Both solutions say 'No solution'\");\n        } else {\n            // Participant found a solution => better than the jury => fail\n            quitf(_fail, \"Participant found a solution, but jury says 'No solution'.\");\n        }\n    } else {\n        // Jury found a solution with R = jurySolutionR\n        if (participantSolutionR == NO_SOLUTION_CODE) {\n            // Participant missed a valid solution\n            quitf(_wa, \"Participant says 'No solution' while jury has a valid solution.\");\n        } else {\n            // Both solutions are feasible. Compare R\n            if (participantSolutionR < jurySolutionR) {\n                quitf(_wa, \"Participant's solution has fewer distinct users (%d) than jury's (%d).\",\n                      participantSolutionR, jurySolutionR);\n            } else if (participantSolutionR == jurySolutionR) {\n                quitf(_ok, \"OK: correct solution with R = %d\", participantSolutionR);\n            } else {\n                // Participant's solution has strictly more users than jury's\n                quitf(_fail, \"Participant claims a strictly better R (%d) than jury's (%d) solution.\",\n                      participantSolutionR, jurySolutionR);\n            }\n        }\n    }\n    // Should never get here\n    return 0;\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring formatTime(int s) {\n    int h = s / 3600;\n    s %= 3600;\n    int m = s / 60;\n    s %= 60;\n    char buf[9];\n    sprintf(buf, \"%02d:%02d:%02d\", h, m, s);\n    return string(buf);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int M = opt<int>(\"M\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> times;\n\n    if (T < 1 || T > 86400) {\n        fprintf(stderr, \"Error: T should be between 1 and 86400\\n\");\n        return 1;\n    }\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            times.push_back(rnd.next(0, 86400 - T));\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"maxR\") {\n        // Generate times such that at any time, number of users online ≤ M\n        int K = (n + M - 1) / M; // Number of batches\n        if (K * T > 86400) {\n            // Adjust K to fit within 86400 seconds\n            K = 86400 / T;\n            n = K * M;\n        }\n        int idx = 0;\n        for (int i = 0; i < K && idx < n; ++i) {\n            int batchStartTime = i * (86400 - T) / K;\n            int batchSize = min(M, n - idx);\n            for (int j = 0; j < batchSize; ++j) {\n                times.push_back(batchStartTime);\n                ++idx;\n            }\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"minR\") {\n        // Generate overlapping times to force minimal R\n        times.assign(n, 0);\n    } else if (type == \"impossible\") {\n        // Generate overlapping times that cannot satisfy M\n        times.assign(n, 0);\n        M = max(1, n - 1);\n    } else if (type == \"overlap\") {\n        // Generate times that overlap at some point\n        int overlapTime = T / 2;\n        for (int i = 0; i < n; ++i) {\n            int startTime = rnd.next(0, 86400 - T - overlapTime);\n            times.push_back(startTime);\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"nooverlap\") {\n        // Generate non-overlapping intervals\n        int totalTimeNeeded = n * T;\n        if (totalTimeNeeded > 86400) {\n            fprintf(stderr, \"Error: Cannot fit non-overlapping intervals within 86400 seconds\\n\");\n            return 1;\n        }\n        int gap = (86400 - n * T) / n;\n        int curTime = 0;\n        for (int i = 0; i < n; ++i) {\n            times.push_back(curTime);\n            curTime += T + gap;\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure times are within limits\n    for (int i = 0; i < n; ++i) {\n        if (times[i] < 0 || times[i] > 86400 - T) {\n            fprintf(stderr, \"Error: Time %d is out of bounds\\n\", times[i]);\n            return 1;\n        }\n    }\n\n    // Output n, M, T\n    printf(\"%d %d %d\\n\", n, M, T);\n\n    // Output times in hh:mm:ss format\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", formatTime(times[i]).c_str());\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring formatTime(int s) {\n    int h = s / 3600;\n    s %= 3600;\n    int m = s / 60;\n    s %= 60;\n    char buf[9];\n    sprintf(buf, \"%02d:%02d:%02d\", h, m, s);\n    return string(buf);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int M = opt<int>(\"M\");\n    int T = opt<int>(\"T\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> times;\n\n    if (T < 1 || T > 86400) {\n        fprintf(stderr, \"Error: T should be between 1 and 86400\\n\");\n        return 1;\n    }\n\n    if (type == \"random\") {\n        for (int i = 0; i < n; ++i) {\n            times.push_back(rnd.next(0, 86400 - T));\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"maxR\") {\n        // Generate times such that at any time, number of users online ≤ M\n        int K = (n + M - 1) / M; // Number of batches\n        if (K * T > 86400) {\n            // Adjust K to fit within 86400 seconds\n            K = 86400 / T;\n            n = K * M;\n        }\n        int idx = 0;\n        for (int i = 0; i < K && idx < n; ++i) {\n            int batchStartTime = i * (86400 - T) / K;\n            int batchSize = min(M, n - idx);\n            for (int j = 0; j < batchSize; ++j) {\n                times.push_back(batchStartTime);\n                ++idx;\n            }\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"minR\") {\n        // Generate overlapping times to force minimal R\n        times.assign(n, 0);\n    } else if (type == \"impossible\") {\n        // Generate overlapping times that cannot satisfy M\n        times.assign(n, 0);\n        M = max(1, n - 1);\n    } else if (type == \"overlap\") {\n        // Generate times that overlap at some point\n        int overlapTime = T / 2;\n        for (int i = 0; i < n; ++i) {\n            int startTime = rnd.next(0, 86400 - T - overlapTime);\n            times.push_back(startTime);\n        }\n        sort(times.begin(), times.end());\n    } else if (type == \"nooverlap\") {\n        // Generate non-overlapping intervals\n        int totalTimeNeeded = n * T;\n        if (totalTimeNeeded > 86400) {\n            fprintf(stderr, \"Error: Cannot fit non-overlapping intervals within 86400 seconds\\n\");\n            return 1;\n        }\n        int gap = (86400 - n * T) / n;\n        int curTime = 0;\n        for (int i = 0; i < n; ++i) {\n            times.push_back(curTime);\n            curTime += T + gap;\n        }\n    } else {\n        fprintf(stderr, \"Error: Unknown type '%s'\\n\", type.c_str());\n        return 1;\n    }\n\n    // Ensure times are within limits\n    for (int i = 0; i < n; ++i) {\n        if (times[i] < 0 || times[i] > 86400 - T) {\n            fprintf(stderr, \"Error: Time %d is out of bounds\\n\", times[i]);\n            return 1;\n        }\n    }\n\n    // Output n, M, T\n    printf(\"%d %d %d\\n\", n, M, T);\n\n    // Output times in hh:mm:ss format\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s\\n\", formatTime(times[i]).c_str());\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small n and T\n./gen -n 5 -M 2 -T 1 -type random\n./gen -n 10 -M 5 -T 100 -type random\n\n# Random test cases with maximum n and small T\n./gen -n 20000 -M 10000 -T 1 -type random\n./gen -n 20000 -M 20000 -T 1 -type random\n\n# Test cases to maximize R (maximum distinct users)\n./gen -n 1000 -M 50 -T 10 -type maxR\n./gen -n 5000 -M 100 -T 20 -type maxR\n./gen -n 10000 -M 200 -T 5 -type maxR\n\n# Test cases to minimize R (minimal distinct users)\n./gen -n 1000 -M 1 -T 1000 -type minR\n./gen -n 5000 -M 10 -T 2000 -type minR\n./gen -n 10000 -M 50 -T 5000 -type minR\n\n# Impossible cases where no solution exists\n./gen -n 1 -M 0 -T 1 -type impossible\n./gen -n 5000 -M 1 -T 86400 -type impossible\n./gen -n 100000 -M 1 -T 1 -type impossible\n\n# Test cases with maximum overlap\n./gen -n 1000 -M 1000 -T 1000 -type overlap\n./gen -n 5000 -M 5000 -T 500 -type overlap\n./gen -n 10000 -M 10000 -T 100 -type overlap\n\n# Test cases with no overlap\n./gen -n 1000 -M 1000 -T 50 -type nooverlap\n./gen -n 5000 -M 5000 -T 10 -type nooverlap\n./gen -n 10000 -M 10000 -T 5 -type nooverlap\n\n# Edge cases for T\n./gen -n 10 -M 5 -T 86400 -type random\n./gen -n 10 -M 5 -T 1 -type random\n\n# Edge cases for M\n./gen -n 10 -M 1 -T 500 -type random\n./gen -n 10 -M 10 -T 500 -type random\n\n# Test cases with multiple queries at the same time\n./gen -n 10 -M 5 -T 1000 -type minR\n\n# Test cases where n is small, T is large\n./gen -n 2 -M 2 -T 86400 -type random\n./gen -n 1 -M 1 -T 86400 -type random\n\n# Test cases with maximum possible n, T, and M\n./gen -n 20000 -M 20000 -T 1 -type maxR\n\n# Test cases with diverse parameters\n./gen -n 15000 -M 5000 -T 1000 -type random\n./gen -n 20000 -M 1000 -T 2000 -type overlap\n./gen -n 5000 -M 20000 -T 100 -type maxR\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:17.531305",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "529/E",
      "title": "E. The Art of Dealing with ATM",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n, k (1 ≤ n ≤ 5000, 1 ≤ k ≤ 20).The next line contains n space-separated integers ai (1 ≤ ai ≤ 107) — the denominations of the bills that are used in the country. Numbers ai follow in the strictly increasing order.The next line contains integer q (1 ≤ q ≤ 20) — the number of requests for cash withdrawal that you will make.The next q lines contain numbers xi (1 ≤ xi ≤ 2·108) — the sums of money in burles that you are going to withdraw from the ATM.",
      "output_spec": "OutputFor each request for cash withdrawal print on a single line the minimum number of bills it can be done, or print  - 1, if it is impossible to get the corresponding sum.",
      "sample_tests": "ExamplesInputCopy6 2010 50 100 500 1000 5000842001000009500096000990001010020159950OutputCopy6201920-13-1-1InputCopy5 21 2 3 5 8813579111315OutputCopy1112222-1",
      "description": "E. The Art of Dealing with ATM\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n, k (1 ≤ n ≤ 5000, 1 ≤ k ≤ 20).The next line contains n space-separated integers ai (1 ≤ ai ≤ 107) — the denominations of the bills that are used in the country. Numbers ai follow in the strictly increasing order.The next line contains integer q (1 ≤ q ≤ 20) — the number of requests for cash withdrawal that you will make.The next q lines contain numbers xi (1 ≤ xi ≤ 2·108) — the sums of money in burles that you are going to withdraw from the ATM.\n\nOutputFor each request for cash withdrawal print on a single line the minimum number of bills it can be done, or print  - 1, if it is impossible to get the corresponding sum.\n\nInputCopy6 2010 50 100 500 1000 5000842001000009500096000990001010020159950OutputCopy6201920-13-1-1InputCopy5 21 2 3 5 8813579111315OutputCopy1112222-1\n\nInputCopy6 2010 50 100 500 1000 5000842001000009500096000990001010020159950\n\nOutputCopy6201920-13-1-1\n\nInputCopy5 21 2 3 5 8813579111315\n\nOutputCopy1112222-1",
      "solutions": [
        {
          "title": "VK Cup 2015 — Раунд 1 - Codeforces",
          "content": "В субботу, 21-го марта, в 17:00 будет дан старт Раунду 1 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять все те команды, которые прошли квалификацию. Напомним, что из первой квалификации допущены все те команды, что набрали не менее 1500 баллов. Таких оказалось 789. Вторую квалификацию прошли 504 команды, все те, что набрали не менее 1850 баллов. Таким образом, принять участие в Раунде 1 могут 1293 команды!Участников ждет соренование по правилам классических раундов Codeforces с некоторыми адаптациями: задачи будут исключительно на русском языке (в отличие от интернет-трансляции, где будут и на английском); в Раунде 1 будут участвовать команды по 1 или 2 человека, разрешается любая коммуникация внутри команды, но какое-либо общение с другими лицами по прежнему, конечно, запрещено; каждая команда может использовать один или более компьютеров по своему усмотрению (напомним, что в Финале команде будет дана возможность использовать только один компьютер); для членов команды рейтинг будет пересчитан одинаково, исходя из рейтинга команды (учитываются зарегистрированные на раунд члены команды), о подсчете рейтинга команды можно почитать здесь. Участников ждет обновленная динамическая стоимость задач (смотрите пост), теперь более плавная, с шагом в 250 баллов.Отметим, что сразу после окончания Раунда 1 будет проведена интернет-трансляция, поэтому просим участников воздержаться до ее окончания от публичных обсуждений, распространения информации о задачах, идеях и даже ходе соренования.Напомним, что в Раунд 2 пройдут все те команды, которые наберут положительный балл не меньший, чем у команды на 400-м месте.Желаем удачи и интересной борьбы!UPD.: Раунд закончен, спасибо за проявленный интерес. Раунд получился динамичным, жюри с интересом следили за ходом соревнования. Поздравляем победителей и напоминаем, что лучшие 400 команд (т.е. те, кто набрал не менее 796 баллов) получают приглашение в Раунд 2. Остальным еще рано расстраиваться, ведь через неделю вас ждет Вайлд-кард 1, по результатам которого будут разыграны еще 50 приглашений в Раунд 2.",
          "author": "MikeMirzayanov",
          "url": "https://codeforces.com/blog/entry/17038",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2193
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces",
          "content": "Problemsets slightly differ in main round and in an online mirror, in editorial problems follow in an order of the main round.524A - Возможно, вы знаете этих людей?This problem didn't appear in an online mirror. Its editorial will be left as an exercise in Russian language for those who are curious what it is about =)524B - Фото на память - 2 (round version)In an original version there was no constraint that no more than n / 2 friends should lie. This version can be solved pretty easy. Iterate over all possible values of H. For a fixed H we have to minimize total width of all rectangles on the photo. So, for each rectangle we need to choose in which orientation it fits into photo having the minimum possible width.529B - Group Photo 2 (online mirror version)In an online mirror version the problem was slightly harder. Let's call people with w ≤ h \\textit{high}, and remaining people \\textit{wide}. Let's fix photo height H. Let's consider several following cases: If a high person fits into height H, we leave him as is. If a high person doesn't fit into height H, the we have to ask him to lie down, increasing the counter of such people by 1. If a wide person fits into height H, but doesn't fit lying on the ground, then we leave him staying. If a wide person fits into height H in both ways, then we first ask him to stay and write into a separate array value of answer decrease if we ask him to lie on the ground: w - h. If somebody doesn't fit in both ways, then such value of H is impossible. Now we have several people that have to lie on the ground (from second case) and if there are too many of them (more than n / 2) then such value of H is impossible.After we put down people from second case there can still be some vacant ground positions, we distribute them to the people from fourth case with highest values of w - h. Then we calculate the total area of the photo and relax the answer.524C - The Art of Dealing with ATMIntended solution has the complexity or . For each possible value x that we can get write a pair (x, m) where m is number of bills to achieve this value. Sort this array in ascending order of x and leave only the best possible number of bills for each value of x. Then to answer a query we should iterate over the first summand in resulting sum and look for the remainder using binary search. The alternate way is the method of two pointers for looking in an array for a pair of numbers with a given sum that works in amortized O(1) time. Check that we used no more than k bills totally and relax the answer if needed.524D - Social NetworkLet's follow greedily in following way. Iterate over all requests in a chronological order. Let's try to associate each query to the new person. Of course we can't always do that: when there are already M active users on a site, we should associate this request with some existing person. Now we need to choose, who it will be.Let's show that the best way is to associate a request with the most recently active person. Indeed, such \"critical\" state can be represented as a vector consisting of M numbers that are times since the last request for each of the active people in descending order. If we are currently in the state (a1, a2, ..., aM), then we can move to the one of the M new states (a1, a2, ..., aM - 1, 0), (a1, a2, ..., aM - 2, aM, 0), ... , (a2, a3, ..., aM, 0) depending on who we will associate the new request with. We can see that the first vector is component-wise larger then other ones, so it is better than other states (since the largest number in some component of vector means that this person will probably disappear earlier giving us more freedom in further operations).So, all we have to do is to simulate the process keeping all active people in some data structure with times of their last activity. As a such structure one can use anything implementing the priority queue interface (priority_queue, set, segment tree or anything else). Complexity of such solution is .524E - Rooks and RectanglesLet's understand what does it mean that some cell isn't attacked by any rook. It means that there exists row and column of the rectangle without rooks on them. It's hard to check this condition, so it is a good idea to check the opposite for it. We just shown that the rectangle is good if on of the two conditions holds: there should be a rook in each row of it or there should be a rook in each column.We can check those conditions separately. How can we check that for a set of rectangles there is a point in each row? This can be done by sweeping vertical line from left to right. Suppose we are standing in the right side of a rectangle located in rows from a to b with the left side in a column y. Then if you denote as last[i] the position of the last rook appeared in a row number i, the criteria for a rectangle looks like . That means that we can keep the values last[i] in a segment tree and answer for all rectangles in logarithmic-time. Similarly for columns. This solution answers all queries in off-line in time O((q + k)log(n + m)).524F - And Yet Another Bracket SequenceThe main idea is that the bracket sequence can be seen as a sequence of prefix balances, i. e sequence (ai) such that ai + 1 = ai ± 1.Calculate the number of opening brackets A and closing brackets B in original string. It is true that if A >  = B then the string can be fixed by adding A - B closing brackets at the end and shifting the resulting string to the point of balance minimum, and if A ≤ B, then the string can be similarly fixed by adding B - A opening brackets to the beginning and then properly shifting the whole string. It's obvious that it is impossible to fix the string by using the less number of brackets. So we know the value of the answer, now we need to figure out how it looks like.Suppose that we first circularly shift and only then add brackets. Suppose that we add x closing brackets. Consider the following two facts: If it is possible to fix a string by adding closing bracket to some x positions then it is possible to fix it by adding x closing brackets to the end of the string. From all strings obtained from a give one by adding closing brackets to x positions, the minimum is one that obtained by putting x closing brackets to the end. Each of those statements is easy to prove. They give us the fact that in the optimal answer we put closing brackets at the end of the string (after rotating the initial string). So we have to consider the set of the original string circular shifts such that they transform to the correct bracket sequence by adding x = A - B closing brackets to the end and choose the lexicographically least among them. Comparing circular shifts of the string is the problem that can be solved by a suffix array. The other way is to find lexicographical minimum among them by using hashing and binary search to compare two circular shifts.The case when A ≤ B is similar except that opening brackets should be put into the beginning of the string.So, overall complexity is .",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 529 和字母"
          },
          "content_length": 7029
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 1",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        },
        {
          "title": "VK Cup Round 1 (+ online mirror) editorial - Codeforces - Code 2",
          "code": "\"shifting the resulting string to the point of balance minimum\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17065",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 20, \"k\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 10000000, \"ai\");\n    inf.readEoln();\n    for(int i = 1; i < n; ++i){\n        ensuref(a[i-1] < a[i], \"Denominations must be in strictly increasing order at position %d\", i);\n    }\n    \n    int q = inf.readInt(1, 20, \"q\");\n    inf.readEoln();\n    for(int i = 0; i < q; ++i){\n        int xi = inf.readInt(1, 200000000, \"xi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 20, \"k\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 10000000, \"ai\");\n    inf.readEoln();\n    for(int i = 1; i < n; ++i){\n        ensuref(a[i-1] < a[i], \"Denominations must be in strictly increasing order at position %d\", i);\n    }\n    \n    int q = inf.readInt(1, 20, \"q\");\n    inf.readEoln();\n    for(int i = 0; i < q; ++i){\n        int xi = inf.readInt(1, 200000000, \"xi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readSpace();\n    int k = inf.readInt(1, 20, \"k\");\n    inf.readEoln();\n    \n    vector<int> a = inf.readInts(n, 1, 10000000, \"ai\");\n    inf.readEoln();\n    for(int i = 1; i < n; ++i){\n        ensuref(a[i-1] < a[i], \"Denominations must be in strictly increasing order at position %d\", i);\n    }\n    \n    int q = inf.readInt(1, 20, \"q\");\n    inf.readEoln();\n    for(int i = 0; i < q; ++i){\n        int xi = inf.readInt(1, 200000000, \"xi\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", 10);\n    int q = opt<int>(\"q\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai;\n    vector<int> xi;\n\n    if (type == \"minimal\") {\n        n = 1; k = 1; q = 1;\n        ai.push_back(1);\n        xi.push_back(1);\n\n    } else if (type == \"maximal\") {\n        n = 5000; k = 20; q = 20;\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = 1;\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, 10000);\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = rnd.next(1, int(2e8));\n\n    } else if (type == \"random\") {\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = rnd.next(1, int(2e8));\n\n    } else if (type == \"impossible_k\") {\n        // Generate xi that cannot be obtained with k bills\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        // xi requires more than k bills even with smallest denomination\n        int min_denom = ai[0];\n        for (int i = 0; i < q; ++i)\n            xi[i] = min_denom * (k + rnd.next(1, k)); // Requires more than k bills\n\n    } else if (type == \"impossible_denoms\") {\n        // Generate xi that requires more than two denominations\n        n = max(n, 3); // At least 3 denominations\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = 1;\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + 1;\n\n        for (int i = 0; i < q; ++i) {\n            int d1 = ai[rnd.next(0, n / 3 - 1)];\n            int d2 = ai[rnd.next(n / 3, 2 * n / 3 - 1)];\n            int d3 = ai[rnd.next(2 * n / 3, n -1)];\n            xi[i] = d1 + d2 + d3;\n        }\n\n    } else if (type == \"possible_max_bills\") {\n        // xi that requires exactly k bills\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        int denom = ai[0];\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = denom * k;\n    } else if (type == \"possible_exact_denoms\") {\n        // xi that requires exactly two denominations\n        n = max(n, 2); // At least 2 denominations\n\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        for (int i = 0; i < q; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            while (idx2 == idx1) idx2 = rnd.next(0, n - 1);\n            int denom1 = ai[idx1];\n            int denom2 = ai[idx2];\n\n            int max_count = min(k, int(1e6)); // Avoid overflow\n            int c1 = rnd.next(1, max_count - 1);\n            int c2 = rnd.next(1, max_count - c1);\n            xi[i] = denom1 * c1 + denom2 * c2;\n            if (xi[i] > int(2e8)) xi[i] = xi[i] % int(2e8) + 1; // Ensure xi within constraints\n        }\n    } else {\n        // default to random\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7));\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = rnd.next(1, int(2e8));\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], (i + 1 == n) ? '\\n' : ' ');\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i)\n        printf(\"%d\\n\", xi[i]);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 10);\n    int k = opt<int>(\"k\", 10);\n    int q = opt<int>(\"q\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> ai;\n    vector<int> xi;\n\n    if (type == \"minimal\") {\n        n = 1; k = 1; q = 1;\n        ai.push_back(1);\n        xi.push_back(1);\n\n    } else if (type == \"maximal\") {\n        n = 5000; k = 20; q = 20;\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = 1;\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, 10000);\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = rnd.next(1, int(2e8));\n\n    } else if (type == \"random\") {\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = rnd.next(1, int(2e8));\n\n    } else if (type == \"impossible_k\") {\n        // Generate xi that cannot be obtained with k bills\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        // xi requires more than k bills even with smallest denomination\n        int min_denom = ai[0];\n        for (int i = 0; i < q; ++i)\n            xi[i] = min_denom * (k + rnd.next(1, k)); // Requires more than k bills\n\n    } else if (type == \"impossible_denoms\") {\n        // Generate xi that requires more than two denominations\n        n = max(n, 3); // At least 3 denominations\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = 1;\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + 1;\n\n        for (int i = 0; i < q; ++i) {\n            int d1 = ai[rnd.next(0, n / 3 - 1)];\n            int d2 = ai[rnd.next(n / 3, 2 * n / 3 - 1)];\n            int d3 = ai[rnd.next(2 * n / 3, n -1)];\n            xi[i] = d1 + d2 + d3;\n        }\n\n    } else if (type == \"possible_max_bills\") {\n        // xi that requires exactly k bills\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        int denom = ai[0];\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = denom * k;\n    } else if (type == \"possible_exact_denoms\") {\n        // xi that requires exactly two denominations\n        n = max(n, 2); // At least 2 denominations\n\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7 / n));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7 / n));\n\n        for (int i = 0; i < q; ++i) {\n            int idx1 = rnd.next(0, n - 1);\n            int idx2 = rnd.next(0, n - 1);\n            while (idx2 == idx1) idx2 = rnd.next(0, n - 1);\n            int denom1 = ai[idx1];\n            int denom2 = ai[idx2];\n\n            int max_count = min(k, int(1e6)); // Avoid overflow\n            int c1 = rnd.next(1, max_count - 1);\n            int c2 = rnd.next(1, max_count - c1);\n            xi[i] = denom1 * c1 + denom2 * c2;\n            if (xi[i] > int(2e8)) xi[i] = xi[i] % int(2e8) + 1; // Ensure xi within constraints\n        }\n    } else {\n        // default to random\n        n = min(n, 5000);\n        k = min(k, 20);\n        q = min(q, 20);\n\n        ai.resize(n);\n        xi.resize(q);\n\n        ai[0] = rnd.next(1, int(1e7));\n        for (int i = 1; i < n; ++i)\n            ai[i] = ai[i - 1] + rnd.next(1, int(1e7));\n\n        for (int i = 0; i < q; ++i)\n            xi[i] = rnd.next(1, int(2e8));\n    }\n\n    printf(\"%d %d\\n\", n, k);\n    for (int i = 0; i < n; ++i)\n        printf(\"%d%c\", ai[i], (i + 1 == n) ? '\\n' : ' ');\n\n    printf(\"%d\\n\", q);\n    for (int i = 0; i < q; ++i)\n        printf(\"%d\\n\", xi[i]);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minimal\n\n./gen -type maximal\n\n./gen -n 10 -k 5 -q 5 -type random\n./gen -n 100 -k 10 -q 10 -type random\n./gen -n 1000 -k 15 -q 15 -type random\n./gen -n 5000 -k 20 -q 20 -type random\n\n./gen -n 10 -k 5 -q 5 -type impossible_k\n./gen -n 100 -k 10 -q 10 -type impossible_k\n./gen -n 1000 -k 15 -q 15 -type impossible_k\n./gen -n 5000 -k 20 -q 20 -type impossible_k\n\n./gen -n 10 -k 5 -q 5 -type impossible_denoms\n./gen -n 100 -k 10 -q 10 -type impossible_denoms\n./gen -n 1000 -k 15 -q 15 -type impossible_denoms\n./gen -n 5000 -k 20 -q 20 -type impossible_denoms\n\n./gen -n 10 -k 5 -q 5 -type possible_max_bills\n./gen -n 100 -k 10 -q 10 -type possible_max_bills\n./gen -n 1000 -k 15 -q 15 -type possible_max_bills\n./gen -n 5000 -k 20 -q 20 -type possible_max_bills\n\n./gen -n 10 -k 5 -q 5 -type possible_exact_denoms\n./gen -n 100 -k 10 -q 10 -type possible_exact_denoms\n./gen -n 1000 -k 15 -q 15 -type possible_exact_denoms\n./gen -n 5000 -k 20 -q 20 -type possible_exact_denoms\n\n# Additional random cases to cover edge constraints\n./gen -n 5000 -k 5 -q 20 -type random\n./gen -n 5000 -k 1 -q 20 -type random\n./gen -n 5000 -k 20 -q 1 -type random\n\n# Edge cases\n./gen -n 1 -k 1 -q 20 -type possible_max_bills\n./gen -n 2 -k 20 -q 1 -type impossible_denoms\n./gen -n 5000 -k 20 -q 20 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:19.610567",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "53/A",
      "title": "A. Autocomplete",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains the s line which is the inputted part. The second line contains an integer n (1 ≤ n ≤ 100) which is the number of visited pages. Then follow n lines which are the visited pages, one on each line. All the lines have lengths of from 1 to 100 symbols inclusively and consist of lowercase Latin letters only.",
      "output_spec": "OutputIf s is not the beginning of any of n addresses of the visited pages, print s. Otherwise, print the lexicographically minimal address of one of the visited pages starting from s.The lexicographical order is the order of words in a dictionary. The lexicographical comparison of lines is realized by the '<' operator in the modern programming languages.",
      "sample_tests": "ExamplesInputCopynext2nextpermutationnextelementOutputCopynextelementInputCopyfind4findfindfirstoffinditfandOutputCopyfindInputCopyfind4fondfindfondfirstoffonditfandOutputCopyfind",
      "description": "A. Autocomplete\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains the s line which is the inputted part. The second line contains an integer n (1 ≤ n ≤ 100) which is the number of visited pages. Then follow n lines which are the visited pages, one on each line. All the lines have lengths of from 1 to 100 symbols inclusively and consist of lowercase Latin letters only.\n\nOutputIf s is not the beginning of any of n addresses of the visited pages, print s. Otherwise, print the lexicographically minimal address of one of the visited pages starting from s.The lexicographical order is the order of words in a dictionary. The lexicographical comparison of lines is realized by the '<' operator in the modern programming languages.\n\nInputCopynext2nextpermutationnextelementOutputCopynextelementInputCopyfind4findfindfirstoffinditfandOutputCopyfindInputCopyfind4fondfindfondfirstoffonditfandOutputCopyfind\n\nInputCopynext2nextpermutationnextelement\n\nOutputCopynextelement\n\nInputCopyfind4findfindfirstoffinditfand\n\nOutputCopyfind\n\nInputCopyfind4fondfindfondfirstoffonditfand\n\nOutputCopyfind",
      "solutions": [
        {
          "title": "Codeforces Beta Round #49 (Div. 2) - Codeforces",
          "content": "Hi everyone! The recent testing round went well. It is expected that everything will run faster. Today's round was prepared by: Mike Mirzayanov, Nickolay Kuznetsov, Ivan Fefer and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: JKeeJ1e30",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1058",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 269
        },
        {
          "title": "Tutorial for problems of Codeforces Beta Round #49 (Div.2). All problems now. - Codeforces",
          "content": "Let's go.A. AutocompleteIn this problem you should read the statement and solve in any way. One of the most simple solutions is read string and last visited pages, sort (even bubble source - 1003 isn't a lot, 3rd power because we need 100 operations to compare two strings), and rundown pages. When we find good string, we should write it and exit.If there are no such one, write source string. 'Goodness' of string is checking with one if (to check lengths and avoid RTE) and for. C. Froggy (Little Frog)IMHO it's the second difficulty problem. If you cannot see solution just after you saw the statement, you can write brute-force solution (rundown all permutation and check), run it for n=10 and see beautiful answer.Answer is 1 n 2 (n-1) 3 (n-2) 4 (n-3) ... Let's define two pointers - l and r. In the beginning, the first one will point to 1, and the second one - to n. On odd positions write down l (and increase it), on even - r (and decrease it). Do it while l <= r.Proof is rather easy: every jump is shorter than the previous one.D. Physical educationThis problem is also very easy. The first thing we should learn is moving element from position x to position y (y < x). Let's move x to position x - 1 with one oblivious swap. Then to position x -2. And so on.Now we want to make a1=b1. Find in b element, that equals a1 and move it to the first position. Similarly we can make a2=b2. So, we have n steps and at every step we do n - 1 swaps at the most. n<=300, so n(n-1)<=89700<106.B. Blog photoDue to bug in GCC I've lost 25 minutes solving this problem. In the end I've used MSVC++.But it was digression, now let's think.The first thing we need to do is fix one side (which are power of two). Because there are two sides and copy-paste is great place for bugs it'll be better to make one more for from 1 to 2 and on the 2nd step swap w and h. It decreases amount of code.Now we know that h=2x. We need to find such w, that 0.8 <= h/w <= 1.25. Solve inequalities for w: h/1.25 <= w <= h/0.8. Because w is integer, it can take any value from ceil(h/1.25) to floor(h/0.8) inclusive. We need to maximize square and h is fixed, so our target is maximize w. We need to let w=floor(h/0.8) and check that it fit borders. If so - relax the answer.It's O(log2 h) solution.Possible bugs are:You calculate square in 32-bit type or like this: int w = ..., h = ...; long long s = w * h; In this case compiler calculate w * h in 32-bit type first, and then convert it to long long. Solution is long long s = (long long)w * hfloor(0.9999999999)=0. The floor function does not correspond with inaccuracy of floating point types. It can be solved either with adding something eps to number before calling floor, or with additional check that difference between floor's result and source value is not greater than 1 - eps.p.s. The floor function is up to 8-9 times slower that conversion to int.E. Dead endsThe first thing you should notice - - n <= 10. It means, that we have exponential solution and we can rundown some subsets.Solution is dynamic programming d[m][subm] - number of ways to make connected tree from subgraph m (it's a bit mask) with dead ends subm (it's also a bit mask). Answer is sum of d[2n-1][x], where |x|=k (size of x as a subset is k).Recalculating isn't really hard. For empty subset and subset of two vertexes (either 0 or 1) answer is oblivious. Also you should know that there is no tree with exactly one dead end (it's easy to prove). Now for greater subsets: rundown i from subm - one of dead ends. Cut it off from tree along some edge to b (b shouldn't be a dead end, otherwise we got unconnected graph). Now we have tree with lower count of vertexes and either decreased 1 number of dead ends or with changed i to b (if b had exactly two neighbors). Answer for this tree we know already. In the end of summarizing we should divide answer by k - each tree has been taken as many times, as it has dead ends (k).p.s. I'll be glad if you tell me my mistakes in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3994
        },
        {
          "title": "Разбор задач Codeforces Beta Round #49(Div. 2) - Codeforces",
          "content": "Задача А. Автодополнение В задаче не было особой сложности в реализации и алгоритме решения, так-как ограничения позволяли  написать решение со квадратичной сложностью. Просто делаем все как и требовалось в условии. Задача B. Фотография в блогВ этой задаче так-же нужно было переборное решение.Сначала перебираем первую сторону как степень двойки(пускай это будет S) , когда мы знаем это число пытаемся определить максимальную 2ю сторону(пускай это будет L) которую мы можем получить(возможно ее мы не можем получить): первый вариант S*0.8>m ,тогда L=0 (мы ее не можем получить можно поставить 0, и произведение будет 0), второй вариант S*1.25<m , тогда L равно максимальному целому числу меньше равному S*1.25, иначе S*0.8<=m<=S*1.25 L=m. Посчитав их проверяем на оптимальность. Аналогично делаем и для второй стороны. Единственно что нужно помнить в случае равности ответа приоритет отдается тому, когда высота больше. Задача С. ЛягушонокОтветом будет последовательность: 1 ,N  ,2 ,N-1, 3 ,N-2 ...Доказать это можно очень просто, так-как разница между числами всегда будет уменьшаться на единичку. Задача D. ФизкультураАлгоритм задачи такой: идем слева на право и берем для каждого человека из первого множества самого ближнего из второго , который стоит не левее его самого , ну то есть если мы рассматриваем человека номер i, то нам надо найти минимальное j, что i<=j и A[i]=B[j]. И сделать нужные переходы. Так-как ограничение всего-лишь 300, то такое решение будет работать. Так-же это решение будет выдавать самый оптимальный ответ. Для больших ограничений эта задача решается сортировкой слиянием. Ну то есть сначала нужно сделать некоторые преобразования, а именно для каждой ячейки определить где она должна будет стоять, дальше выходит довольно не сложный алгоритм.Задача Е. ТупикиЗададим динамику Ans[tree,dl] (tree,dl - битмаски) где будем хранить ответ: 1). мы составили дерево из вершин tree.2). тупиками у нас вершины dl.Очевидным есть ответ для двух бит, если между вершинами есть ребро то 1 , иначе 0. Если кол-во бит больше(пускай єто будет состояние (m1,m2)) то ответ считаем так: зафиксируем некоторую вершину i которая есть тупиком и некоторую вершину j которая не есть тупиком и есть ребро между i и j. Мы будем убирать вершину i из дерева, тогда возможны два перехода , тупик i исчезает и получаем состояние (m1 xor (1 shl i),m2 xor (1 shl i)) , тупик i исчезает и j стает тупиком (m1 xor (1 shl i),m2 xor (1 shl i) xor (1 shl j)). Когда посчитали ответ для состояние(Ans[m1,m2] ),тогда разделим его на кол-во бит в m2.Ответом будет сумма Ans[(1 shl n)-1,dl] , причем кол-во бит в dl = K.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1064",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2612
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string page = inf.readLine(\"[a-z]{1,100}\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string page = inf.readLine(\"[a-z]{1,100}\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    string s = inf.readLine(\"[a-z]{1,100}\", \"s\");\n\n    int n = inf.readInt(1, 100, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; i++) {\n        string page = inf.readLine(\"[a-z]{1,100}\");\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s;\n    for (int i = 0; i < len; i++) {\n        s += char('a' + rnd.next(26));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100) {\n        cerr << \"Invalid n: n should be between 1 and 100 inclusive.\" << endl;\n        return 1;\n    }\n\n    string s;\n    vector<string> addresses(n);\n\n    if (type == \"random\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            int addr_len = rnd.next(1, 100);\n            addresses[i] = randomString(addr_len);\n        }\n\n    } else if (type == \"no_prefix\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            int addr_len = rnd.next(1, 100);\n            if (addr_len < s_len) {\n                addresses[i] = randomString(addr_len);\n            } else {\n                char first_char;\n                do {\n                    first_char = 'a' + rnd.next(26);\n                } while (first_char == s[0]);\n                string addr = \"\";\n                addr += first_char;\n                for (int j = 1; j < addr_len; j++) {\n                    addr += char('a' + rnd.next(26));\n                }\n                addresses[i] = addr;\n            }\n        }\n\n    } else if (type == \"all_prefix\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            int addr_len = rnd.next(s_len, 100);\n            string addr = s + randomString(addr_len - s_len);\n            addresses[i] = addr;\n        }\n\n    } else if (type == \"s_equals_address\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        int pos = rnd.next(0, n - 1); // position where s will be placed\n\n        for (int i = 0; i < n; i++) {\n            if (i == pos) {\n                addresses[i] = s;\n            } else {\n                int addr_len = rnd.next(1, 100);\n                addresses[i] = randomString(addr_len);\n            }\n        }\n\n    } else if (type == \"lex_min_last\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n - 1; i++) {\n            int addr_len = rnd.next(s_len + 1, 100);\n            string addr = s;\n            addr += char('a' + rnd.next(1, 25)); // character greater than 'a'\n            addr += randomString(addr_len - s_len - 1);\n            addresses[i] = addr;\n        }\n        addresses[n - 1] = s; // lex smallest, placed last\n\n    } else if (type == \"lex_min_first\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        addresses[0] = s; // lex smallest, placed first\n        for (int i = 1; i < n; i++) {\n            int addr_len = rnd.next(s_len + 1, 100);\n            string addr = s;\n            addr += char('a' + rnd.next(1, 25)); // character greater than 'a'\n            addr += randomString(addr_len - s_len - 1);\n            addresses[i] = addr;\n        }\n\n    } else if (type == \"max_size\") {\n        int s_len = 100;\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            addresses[i] = randomString(100);\n        }\n\n    } else if (type == \"min_size\") {\n        int s_len = 1;\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            addresses[i] = randomString(1);\n        }\n\n    } else if (type == \"addresses_are_prefixes\") {\n        int s_len = rnd.next(1, 20);\n        s = randomString(s_len);\n\n        string base = s;\n        for (int i = 0; i < n; i++) {\n            if (base.size() < 100) {\n                base += char('a' + rnd.next(26));\n            }\n            addresses[i] = base.substr(0, min(100, (int)base.size()));\n        }\n\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    cout << s << endl;\n    cout << n << endl;\n    for (int i = 0; i < n; i++) {\n        cout << addresses[i] << endl;\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring randomString(int len) {\n    string s;\n    for (int i = 0; i < len; i++) {\n        s += char('a' + rnd.next(26));\n    }\n    return s;\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    if (n < 1 || n > 100) {\n        cerr << \"Invalid n: n should be between 1 and 100 inclusive.\" << endl;\n        return 1;\n    }\n\n    string s;\n    vector<string> addresses(n);\n\n    if (type == \"random\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            int addr_len = rnd.next(1, 100);\n            addresses[i] = randomString(addr_len);\n        }\n\n    } else if (type == \"no_prefix\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            int addr_len = rnd.next(1, 100);\n            if (addr_len < s_len) {\n                addresses[i] = randomString(addr_len);\n            } else {\n                char first_char;\n                do {\n                    first_char = 'a' + rnd.next(26);\n                } while (first_char == s[0]);\n                string addr = \"\";\n                addr += first_char;\n                for (int j = 1; j < addr_len; j++) {\n                    addr += char('a' + rnd.next(26));\n                }\n                addresses[i] = addr;\n            }\n        }\n\n    } else if (type == \"all_prefix\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            int addr_len = rnd.next(s_len, 100);\n            string addr = s + randomString(addr_len - s_len);\n            addresses[i] = addr;\n        }\n\n    } else if (type == \"s_equals_address\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        int pos = rnd.next(0, n - 1); // position where s will be placed\n\n        for (int i = 0; i < n; i++) {\n            if (i == pos) {\n                addresses[i] = s;\n            } else {\n                int addr_len = rnd.next(1, 100);\n                addresses[i] = randomString(addr_len);\n            }\n        }\n\n    } else if (type == \"lex_min_last\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        for (int i = 0; i < n - 1; i++) {\n            int addr_len = rnd.next(s_len + 1, 100);\n            string addr = s;\n            addr += char('a' + rnd.next(1, 25)); // character greater than 'a'\n            addr += randomString(addr_len - s_len - 1);\n            addresses[i] = addr;\n        }\n        addresses[n - 1] = s; // lex smallest, placed last\n\n    } else if (type == \"lex_min_first\") {\n        int s_len = rnd.next(1, 100);\n        s = randomString(s_len);\n\n        addresses[0] = s; // lex smallest, placed first\n        for (int i = 1; i < n; i++) {\n            int addr_len = rnd.next(s_len + 1, 100);\n            string addr = s;\n            addr += char('a' + rnd.next(1, 25)); // character greater than 'a'\n            addr += randomString(addr_len - s_len - 1);\n            addresses[i] = addr;\n        }\n\n    } else if (type == \"max_size\") {\n        int s_len = 100;\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            addresses[i] = randomString(100);\n        }\n\n    } else if (type == \"min_size\") {\n        int s_len = 1;\n        s = randomString(s_len);\n\n        for (int i = 0; i < n; i++) {\n            addresses[i] = randomString(1);\n        }\n\n    } else if (type == \"addresses_are_prefixes\") {\n        int s_len = rnd.next(1, 20);\n        s = randomString(s_len);\n\n        string base = s;\n        for (int i = 0; i < n; i++) {\n            if (base.size() < 100) {\n                base += char('a' + rnd.next(26));\n            }\n            addresses[i] = base.substr(0, min(100, (int)base.size()));\n        }\n\n    } else {\n        cerr << \"Unknown type: \" << type << endl;\n        return 1;\n    }\n\n    // Output\n    cout << s << endl;\n    cout << n << endl;\n    for (int i = 0; i < n; i++) {\n        cout << addresses[i] << endl;\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 100 -type random\n\n./gen -n 10 -type no_prefix\n./gen -n 100 -type no_prefix\n\n./gen -n 1 -type no_prefix\n\n./gen -n 10 -type all_prefix\n./gen -n 50 -type all_prefix\n./gen -n 100 -type all_prefix\n\n./gen -n 1 -type all_prefix\n\n./gen -n 5 -type s_equals_address\n./gen -n 50 -type s_equals_address\n./gen -n 100 -type s_equals_address\n\n./gen -n 1 -type s_equals_address\n\n./gen -n 10 -type lex_min_last\n./gen -n 20 -type lex_min_last\n\n./gen -n 1 -type lex_min_last\n\n./gen -n 10 -type lex_min_first\n./gen -n 20 -type lex_min_first\n\n./gen -n 1 -type lex_min_first\n\n./gen -n 5 -type max_size\n./gen -n 10 -type max_size\n./gen -n 100 -type max_size\n\n./gen -n 1 -type max_size\n\n./gen -n 5 -type min_size\n./gen -n 10 -type min_size\n./gen -n 100 -type min_size\n\n./gen -n 1 -type min_size\n\n./gen -n 10 -type addresses_are_prefixes\n./gen -n 100 -type addresses_are_prefixes\n\n./gen -n 1 -type addresses_are_prefixes\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:21.540135",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "53/B",
      "title": "B. Фотография в блог",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 seconds",
      "memory_limit": "ограничение по памяти на тест256 megabytes",
      "input_spec": "Входные данныеВ первой строке записана пара целых чисел h и w (1 ≤ h, w ≤ 109) — высота и ширина закачанного фото в пикселях.",
      "output_spec": "Выходные данныеВыведите два целых числа — высоту и ширину вырезаемой части.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1Выходные данныеСкопировать1 1Входные данныеСкопировать2 2Выходные данныеСкопировать2 2Входные данныеСкопировать5 5Выходные данныеСкопировать5 4",
      "description": "B. Фотография в блог\n\nограничение по времени на тест2 seconds\n\nограничение по времени на тест\n\nограничение по памяти на тест256 megabytes\n\nограничение по памяти на тест\n\nвыводstdout\n\nВходные данныеВ первой строке записана пара целых чисел h и w (1 ≤ h, w ≤ 109) — высота и ширина закачанного фото в пикселях.\n\nВходные данные\n\nВыходные данныеВыведите два целых числа — высоту и ширину вырезаемой части.\n\nВыходные данные\n\nВходные данныеСкопировать2 1Выходные данныеСкопировать1 1Входные данныеСкопировать2 2Выходные данныеСкопировать2 2Входные данныеСкопировать5 5Выходные данныеСкопировать5 4\n\nВходные данныеСкопировать2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2 2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 5\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать5 4\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Beta Round #49 (Div. 2) - Codeforces",
          "content": "Всем привет! Недавний тестовый раунд прошел хорошо. Ожидается, что теперь все будет работать быстрее. В подготовке задач сегодняшнего раунда принимали участие: Михаил Мирзаянов, Николай Кузнецов, Иван Фефер и Мария Белова. Удачи! Артем Рахов и команда CodeforcesЗадачиРезультатыПобедитель: JKeeJ1e30",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1058",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 299
        },
        {
          "title": "Разбор задач Codeforces Beta Round #49 (Div.2) - Codeforces",
          "content": "Поехали.A. АвтодополнениеВ это задаче требовалось прочитать условие и решить как угодно. Одно из самых простых решение - считать строчку, считать последние страницы, отсортировать (хоть пузырьком - 1003 прекрасно укладывается, куб потому что надо еще сравнивать), а затем бежать с начала до конца и выводить первую строку, у которой префикс совпадает с нашей. Это проверяется if'ом на длину (чтобы не было RTE) и одним for'ом. Нашли строку - вывели и завершились. Они отсортированы, поэтому выведем то, что надо. Если не нашли - вывели исходную строку. C. ЛягушонокВторая, как мне кажется, по сложности задача. Если вам сразу было неочевидно решение, можно было написать полный перебор всех перестановок с проверкой, запустить его для n=10 и увидить красивый ответ. Ответ такой: 1 n 2 (n-1) 3 (n-2) 4 (n-3) ... Как выводить: заведём два указателя - l и r. Первый вначале указывает на 1, второй - на n. На нечётных позициях выводим l, и увеличиваем его на 1, на нечётных - r, уменьшая его на 1. Всё это до тех пор, пока l <= r.Доказать корректность тоже очень просто: каждый следующий прыжок строго короче, чем предыдущий.D. ФизкультураЗадача, опять же - \"бревно\". Сначала научимся двигать элемент с номером x на место y (y < x). Как это сделать? Давайте сначала подвинем x на место x - 1 одной очевидной заменой. Еще одной заменой - на место x - 2. И так далее.Теперь добъёмся a1=b1. Как это сделать? Очевидно, найти в b элемент, равный a1, и, как мы умеем, передвинуть его на первое место. Далее точно так же добъёмся a2=b2. Таким образом, у нас будет n шагов и в каждом мы делаем не более n-1 перестановки. Т.к. n<=300, то n(n-1)<=89700<106.B. Фотография в блогИз-за бага в GCC на этой задаче я потерял минут 25. В конце концов сдал решение на MSVC++.Но это было отступление, теперь к делу.Для начала давайте переберём одну сторону (ту, которая является степенью двойки). Так как сторон две, а писать два раза кусок кода не хочется, давайте сделаем внешний for от 1 до 2, и в релаксации ответа и проверке границ на втором шаге будем менять w и h местами. Это избавит нас от лишнего куска кода.Итак, перебрали, положим, h=2x. Теперь надо найти такое w, что 0.8 <= h/w <= 1.25. Решим относительно w и получим, что h/1.25 <= w <= h/0.8. Т.к. w - целое, то оно может лежать в диапазоне от ceil(h/1.25) до floor(h/0.8) включительно. Т.к. надо максимизоровать площадь и h фиксированно, надо максимизировать w. Надо взять w=floor(h/0.8) и проверить, что оно подходит. Если да - прорелаксировать ответ.Итого решение разботает за O(log2 h), что безповоротно вкладывается в TL.Возможные косяки были:Считаете площадь либо в 32-битном типе, либо как: int w = ..., h = ...; long long s = w * h; В этом случае компилятор сначала посчитает w * h в 32-битном типе, а потом приведёт к long long. Лечилось так: s = (long long)w * h;floor(0.9999999999)=0. Функция floor не учитывает погрешность. Лечилось дополнительной проверкой, что разница между результатом floor и изначальным значением не превосходит 1 - eps.p.s. Функция floor работает до 8-9 раз дольше преобразования к int'у.E. ТупикиПервое, что надо было заметить - n <= 10. Это значит, что решение экспоненцеальное, и можно перебирать какие-нибудь подмножества. Так и сделаем.Давайте посчитаем динамику по подмножествам: d[m][subm] - количество способов сделать связанное дерево из подграфа m с тупиковыми вершинами subm. Ответ будет суммой по d[2n-1][x], где кол-во единичных бит в x = k.Как пересчитывать: для пустого множества и множества из двух вершин (либо 0, либо 1) - очевидно. Одного тупика в дереве не бывает вообще. Теперь для большего: переберём i из subm - какой-нибудь тупик. Отрежем его от дерева по некоторому ребру в b (причём b не должно быть тупиком, иначе получится несвязный граф). Получаем дерево на меньшем множестве вершин и с либо уменьшенным на 1 множеством тупиков, либо с изменённым i на b (если у b было ровно два соседа) Добавляем к текущему ответу уже посчитанную динамику. В конце надо разделить на k - каждое дерево мы учли столько раз, сколько в нём тупиков (k).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 4039
        },
        {
          "title": "Разбор задач Codeforces Beta Round #49(Div. 2) - Codeforces",
          "content": "Задача А. Автодополнение В задаче не было особой сложности в реализации и алгоритме решения, так-как ограничения позволяли  написать решение со квадратичной сложностью. Просто делаем все как и требовалось в условии. Задача B. Фотография в блогВ этой задаче так-же нужно было переборное решение.Сначала перебираем первую сторону как степень двойки(пускай это будет S) , когда мы знаем это число пытаемся определить максимальную 2ю сторону(пускай это будет L) которую мы можем получить(возможно ее мы не можем получить): первый вариант S*0.8>m ,тогда L=0 (мы ее не можем получить можно поставить 0, и произведение будет 0), второй вариант S*1.25<m , тогда L равно максимальному целому числу меньше равному S*1.25, иначе S*0.8<=m<=S*1.25 L=m. Посчитав их проверяем на оптимальность. Аналогично делаем и для второй стороны. Единственно что нужно помнить в случае равности ответа приоритет отдается тому, когда высота больше. Задача С. ЛягушонокОтветом будет последовательность: 1 ,N  ,2 ,N-1, 3 ,N-2 ...Доказать это можно очень просто, так-как разница между числами всегда будет уменьшаться на единичку. Задача D. ФизкультураАлгоритм задачи такой: идем слева на право и берем для каждого человека из первого множества самого ближнего из второго , который стоит не левее его самого , ну то есть если мы рассматриваем человека номер i, то нам надо найти минимальное j, что i<=j и A[i]=B[j]. И сделать нужные переходы. Так-как ограничение всего-лишь 300, то такое решение будет работать. Так-же это решение будет выдавать самый оптимальный ответ. Для больших ограничений эта задача решается сортировкой слиянием. Ну то есть сначала нужно сделать некоторые преобразования, а именно для каждой ячейки определить где она должна будет стоять, дальше выходит довольно не сложный алгоритм.Задача Е. ТупикиЗададим динамику Ans[tree,dl] (tree,dl - битмаски) где будем хранить ответ: 1). мы составили дерево из вершин tree.2). тупиками у нас вершины dl.Очевидным есть ответ для двух бит, если между вершинами есть ребро то 1 , иначе 0. Если кол-во бит больше(пускай єто будет состояние (m1,m2)) то ответ считаем так: зафиксируем некоторую вершину i которая есть тупиком и некоторую вершину j которая не есть тупиком и есть ребро между i и j. Мы будем убирать вершину i из дерева, тогда возможны два перехода , тупик i исчезает и получаем состояние (m1 xor (1 shl i),m2 xor (1 shl i)) , тупик i исчезает и j стает тупиком (m1 xor (1 shl i),m2 xor (1 shl i) xor (1 shl j)). Когда посчитали ответ для состояние(Ans[m1,m2] ),тогда разделим его на кол-во бит в m2.Ответом будет сумма Ans[(1 shl n)-1,dl] , причем кол-во бит в dl = K.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1064",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2612
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 1000000000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 1000000000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int h = inf.readInt(1, 1000000000, \"h\");\n    inf.readSpace();\n    int w = inf.readInt(1, 1000000000, \"w\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long max_h = opt<long long>(\"max_h\", 1000000000LL);\n    long long max_w = opt<long long>(\"max_w\", 1000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n    max_h = min(max_h, 1000000000LL);\n    max_w = min(max_w, 1000000000LL);\n\n    long long h = 1;\n    long long w = 1;\n\n    if (type == \"min_size\") {\n        h = 1;\n        w = 1;\n    } else if (type == \"max_size\") {\n        h = max_h;\n        w = max_w;\n    } else if (type == \"power_of_2_h\") {\n        // h is a power of 2\n        int max_exp = 30; // since 2^30 is about 1e9\n        int exp = rnd.next(0, max_exp);\n        h = 1LL << exp;\n        w = rnd.next(1LL, max_w);\n    } else if (type == \"power_of_2_w\") {\n        int max_exp = 30;\n        int exp = rnd.next(0, max_exp);\n        w = 1LL << exp;\n        h = rnd.next(1LL, max_h);\n    } else if (type == \"both_power_of_2\") {\n        int max_exp = 30;\n        int exp_h = rnd.next(0, max_exp);\n        int exp_w = rnd.next(0, max_exp);\n        h = 1LL << exp_h;\n        w = 1LL << exp_w;\n    } else if (type == \"near_power_of_2_h\") {\n        int max_exp = 30;\n        int exp = rnd.next(1, max_exp);\n        h = (1LL << exp) - 1;\n        w = rnd.next(1LL, max_w);\n    } else if (type == \"near_power_of_2_w\") {\n        int max_exp = 30;\n        int exp = rnd.next(1, max_exp);\n        w = (1LL << exp) - 1;\n        h = rnd.next(1LL, max_h);\n    } else if (type == \"edge_ratio_low\") {\n        // h/w just below 0.8\n        w = rnd.next(1LL, max_w);\n        h = max(1LL, (long long)(0.8 * w) - 1);\n    } else if (type == \"edge_ratio_high\") {\n        // h/w just above 1.25\n        w = rnd.next(1LL, max_w);\n        h = min(max_h, (long long)(1.25 * w) + 1);\n    } else if (type == \"random_large\") {\n        h = rnd.next(100000000LL, max_h);\n        w = rnd.next(100000000LL, max_w);\n    } else if (type == \"random_small\") {\n        h = rnd.next(1LL, min(max_h, 1000LL));\n        w = rnd.next(1LL, min(max_w, 1000LL));\n    } else if (type == \"special\") {\n        // Specific values to test edge cases\n        h = 1048576; // 2^20\n        w = 1048575; // Just below 2^20\n    } else { // default to random\n        h = rnd.next(1LL, max_h);\n        w = rnd.next(1LL, max_w);\n    }\n\n    // Ensure h and w are within bounds\n    h = max(1LL, min(h, max_h));\n    w = max(1LL, min(w, max_w));\n\n    printf(\"%lld %lld\\n\", h, w);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    long long max_h = opt<long long>(\"max_h\", 1000000000LL);\n    long long max_w = opt<long long>(\"max_w\", 1000000000LL);\n    string type = opt<string>(\"type\", \"random\");\n    max_h = min(max_h, 1000000000LL);\n    max_w = min(max_w, 1000000000LL);\n\n    long long h = 1;\n    long long w = 1;\n\n    if (type == \"min_size\") {\n        h = 1;\n        w = 1;\n    } else if (type == \"max_size\") {\n        h = max_h;\n        w = max_w;\n    } else if (type == \"power_of_2_h\") {\n        // h is a power of 2\n        int max_exp = 30; // since 2^30 is about 1e9\n        int exp = rnd.next(0, max_exp);\n        h = 1LL << exp;\n        w = rnd.next(1LL, max_w);\n    } else if (type == \"power_of_2_w\") {\n        int max_exp = 30;\n        int exp = rnd.next(0, max_exp);\n        w = 1LL << exp;\n        h = rnd.next(1LL, max_h);\n    } else if (type == \"both_power_of_2\") {\n        int max_exp = 30;\n        int exp_h = rnd.next(0, max_exp);\n        int exp_w = rnd.next(0, max_exp);\n        h = 1LL << exp_h;\n        w = 1LL << exp_w;\n    } else if (type == \"near_power_of_2_h\") {\n        int max_exp = 30;\n        int exp = rnd.next(1, max_exp);\n        h = (1LL << exp) - 1;\n        w = rnd.next(1LL, max_w);\n    } else if (type == \"near_power_of_2_w\") {\n        int max_exp = 30;\n        int exp = rnd.next(1, max_exp);\n        w = (1LL << exp) - 1;\n        h = rnd.next(1LL, max_h);\n    } else if (type == \"edge_ratio_low\") {\n        // h/w just below 0.8\n        w = rnd.next(1LL, max_w);\n        h = max(1LL, (long long)(0.8 * w) - 1);\n    } else if (type == \"edge_ratio_high\") {\n        // h/w just above 1.25\n        w = rnd.next(1LL, max_w);\n        h = min(max_h, (long long)(1.25 * w) + 1);\n    } else if (type == \"random_large\") {\n        h = rnd.next(100000000LL, max_h);\n        w = rnd.next(100000000LL, max_w);\n    } else if (type == \"random_small\") {\n        h = rnd.next(1LL, min(max_h, 1000LL));\n        w = rnd.next(1LL, min(max_w, 1000LL));\n    } else if (type == \"special\") {\n        // Specific values to test edge cases\n        h = 1048576; // 2^20\n        w = 1048575; // Just below 2^20\n    } else { // default to random\n        h = rnd.next(1LL, max_h);\n        w = rnd.next(1LL, max_w);\n    }\n\n    // Ensure h and w are within bounds\n    h = max(1LL, min(h, max_h));\n    w = max(1LL, min(w, max_w));\n\n    printf(\"%lld %lld\\n\", h, w);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -max_h 10 -max_w 10 -type min_size\n./gen -max_h 1000000000 -max_w 1000000000 -type max_size\n./gen -max_h 1000000 -max_w 1000000 -type power_of_2_h\n./gen -max_h 1000000 -max_w 1000000 -type power_of_2_w\n./gen -max_h 1000000 -max_w 1000000 -type both_power_of_2\n./gen -max_h 1000000 -max_w 1000000 -type near_power_of_2_h\n./gen -max_h 1000000 -max_w 1000000 -type near_power_of_2_w\n./gen -max_h 1000000000 -max_w 1000000000 -type edge_ratio_low\n./gen -max_h 1000000000 -max_w 1000000000 -type edge_ratio_high\n./gen -max_h 1000000000 -max_w 1000000000 -type random_large\n./gen -max_h 1000000000 -max_w 1000000000 -type random_small\n./gen -max_h 1000000000 -max_w 1000000000 -type special\n./gen -max_h 1000000000 -max_w 1000000000 -type random\n./gen -max_h 1000 -max_w 1000 -type random\n./gen -max_h 1 -max_w 10 -type random_small\n./gen -max_h 10 -max_w 1 -type random_small\n./gen -max_h 999999999 -max_w 999999999 -type random_large\n./gen -max_h 1000000000 -max_w 1 -type max_size\n./gen -max_h 1 -max_w 1000000000 -type max_size\n./gen -max_h 1000000 -max_w 1000000 -type random_small\n./gen -max_h 1000000000 -max_w 1000000000 -type edge_ratio_low\n./gen -max_h 1000000000 -max_w 1000000000 -type edge_ratio_high\n./gen -max_h 1000000000 -max_w 1000000000 -type power_of_2_h\n./gen -max_h 1000000000 -max_w 1000000000 -type power_of_2_w\n./gen -max_h 1000000000 -max_w 1000000000 -type both_power_of_2\n./gen -max_h 999999999 -max_w 1000000000 -type near_power_of_2_h\n./gen -max_h 1000000000 -max_w 999999999 -type near_power_of_2_w\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:23.567690",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "53/C",
      "title": "C. Little Frog",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe single line contains a number n (1 ≤ n ≤ 104) which is the number of mounds.",
      "output_spec": "OutputPrint n integers pi (1 ≤ pi ≤ n) which are the frog's route plan.   All the pi's should be mutually different.  All the |pi–pi + 1|'s should be mutually different (1 ≤ i ≤ n - 1). If there are several solutions, output any.",
      "sample_tests": "ExamplesInputCopy2OutputCopy1 2 InputCopy3OutputCopy1 3 2",
      "description": "C. Little Frog\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe single line contains a number n (1 ≤ n ≤ 104) which is the number of mounds.\n\nOutputPrint n integers pi (1 ≤ pi ≤ n) which are the frog's route plan.   All the pi's should be mutually different.  All the |pi–pi + 1|'s should be mutually different (1 ≤ i ≤ n - 1). If there are several solutions, output any.\n\nInputCopy2OutputCopy1 2 InputCopy3OutputCopy1 3 2\n\nOutputCopy1 2\n\nOutputCopy1 3 2",
      "solutions": [
        {
          "title": "Codeforces Beta Round #49 (Div. 2) - Codeforces",
          "content": "Hi everyone! The recent testing round went well. It is expected that everything will run faster. Today's round was prepared by: Mike Mirzayanov, Nickolay Kuznetsov, Ivan Fefer and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: JKeeJ1e30",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1058",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 269
        },
        {
          "title": "Tutorial for problems of Codeforces Beta Round #49 (Div.2). All problems now. - Codeforces",
          "content": "Let's go.A. AutocompleteIn this problem you should read the statement and solve in any way. One of the most simple solutions is read string and last visited pages, sort (even bubble source - 1003 isn't a lot, 3rd power because we need 100 operations to compare two strings), and rundown pages. When we find good string, we should write it and exit.If there are no such one, write source string. 'Goodness' of string is checking with one if (to check lengths and avoid RTE) and for. C. Froggy (Little Frog)IMHO it's the second difficulty problem. If you cannot see solution just after you saw the statement, you can write brute-force solution (rundown all permutation and check), run it for n=10 and see beautiful answer.Answer is 1 n 2 (n-1) 3 (n-2) 4 (n-3) ... Let's define two pointers - l and r. In the beginning, the first one will point to 1, and the second one - to n. On odd positions write down l (and increase it), on even - r (and decrease it). Do it while l <= r.Proof is rather easy: every jump is shorter than the previous one.D. Physical educationThis problem is also very easy. The first thing we should learn is moving element from position x to position y (y < x). Let's move x to position x - 1 with one oblivious swap. Then to position x -2. And so on.Now we want to make a1=b1. Find in b element, that equals a1 and move it to the first position. Similarly we can make a2=b2. So, we have n steps and at every step we do n - 1 swaps at the most. n<=300, so n(n-1)<=89700<106.B. Blog photoDue to bug in GCC I've lost 25 minutes solving this problem. In the end I've used MSVC++.But it was digression, now let's think.The first thing we need to do is fix one side (which are power of two). Because there are two sides and copy-paste is great place for bugs it'll be better to make one more for from 1 to 2 and on the 2nd step swap w and h. It decreases amount of code.Now we know that h=2x. We need to find such w, that 0.8 <= h/w <= 1.25. Solve inequalities for w: h/1.25 <= w <= h/0.8. Because w is integer, it can take any value from ceil(h/1.25) to floor(h/0.8) inclusive. We need to maximize square and h is fixed, so our target is maximize w. We need to let w=floor(h/0.8) and check that it fit borders. If so - relax the answer.It's O(log2 h) solution.Possible bugs are:You calculate square in 32-bit type or like this: int w = ..., h = ...; long long s = w * h; In this case compiler calculate w * h in 32-bit type first, and then convert it to long long. Solution is long long s = (long long)w * hfloor(0.9999999999)=0. The floor function does not correspond with inaccuracy of floating point types. It can be solved either with adding something eps to number before calling floor, or with additional check that difference between floor's result and source value is not greater than 1 - eps.p.s. The floor function is up to 8-9 times slower that conversion to int.E. Dead endsThe first thing you should notice - - n <= 10. It means, that we have exponential solution and we can rundown some subsets.Solution is dynamic programming d[m][subm] - number of ways to make connected tree from subgraph m (it's a bit mask) with dead ends subm (it's also a bit mask). Answer is sum of d[2n-1][x], where |x|=k (size of x as a subset is k).Recalculating isn't really hard. For empty subset and subset of two vertexes (either 0 or 1) answer is oblivious. Also you should know that there is no tree with exactly one dead end (it's easy to prove). Now for greater subsets: rundown i from subm - one of dead ends. Cut it off from tree along some edge to b (b shouldn't be a dead end, otherwise we got unconnected graph). Now we have tree with lower count of vertexes and either decreased 1 number of dead ends or with changed i to b (if b had exactly two neighbors). Answer for this tree we know already. In the end of summarizing we should divide answer by k - each tree has been taken as many times, as it has dead ends (k).p.s. I'll be glad if you tell me my mistakes in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3994
        },
        {
          "title": "Разбор задач Codeforces Beta Round #49(Div. 2) - Codeforces",
          "content": "Задача А. Автодополнение В задаче не было особой сложности в реализации и алгоритме решения, так-как ограничения позволяли  написать решение со квадратичной сложностью. Просто делаем все как и требовалось в условии. Задача B. Фотография в блогВ этой задаче так-же нужно было переборное решение.Сначала перебираем первую сторону как степень двойки(пускай это будет S) , когда мы знаем это число пытаемся определить максимальную 2ю сторону(пускай это будет L) которую мы можем получить(возможно ее мы не можем получить): первый вариант S*0.8>m ,тогда L=0 (мы ее не можем получить можно поставить 0, и произведение будет 0), второй вариант S*1.25<m , тогда L равно максимальному целому числу меньше равному S*1.25, иначе S*0.8<=m<=S*1.25 L=m. Посчитав их проверяем на оптимальность. Аналогично делаем и для второй стороны. Единственно что нужно помнить в случае равности ответа приоритет отдается тому, когда высота больше. Задача С. ЛягушонокОтветом будет последовательность: 1 ,N  ,2 ,N-1, 3 ,N-2 ...Доказать это можно очень просто, так-как разница между числами всегда будет уменьшаться на единичку. Задача D. ФизкультураАлгоритм задачи такой: идем слева на право и берем для каждого человека из первого множества самого ближнего из второго , который стоит не левее его самого , ну то есть если мы рассматриваем человека номер i, то нам надо найти минимальное j, что i<=j и A[i]=B[j]. И сделать нужные переходы. Так-как ограничение всего-лишь 300, то такое решение будет работать. Так-же это решение будет выдавать самый оптимальный ответ. Для больших ограничений эта задача решается сортировкой слиянием. Ну то есть сначала нужно сделать некоторые преобразования, а именно для каждой ячейки определить где она должна будет стоять, дальше выходит довольно не сложный алгоритм.Задача Е. ТупикиЗададим динамику Ans[tree,dl] (tree,dl - битмаски) где будем хранить ответ: 1). мы составили дерево из вершин tree.2). тупиками у нас вершины dl.Очевидным есть ответ для двух бит, если между вершинами есть ребро то 1 , иначе 0. Если кол-во бит больше(пускай єто будет состояние (m1,m2)) то ответ считаем так: зафиксируем некоторую вершину i которая есть тупиком и некоторую вершину j которая не есть тупиком и есть ребро между i и j. Мы будем убирать вершину i из дерева, тогда возможны два перехода , тупик i исчезает и получаем состояние (m1 xor (1 shl i),m2 xor (1 shl i)) , тупик i исчезает и j стает тупиком (m1 xor (1 shl i),m2 xor (1 shl i) xor (1 shl j)). Когда посчитали ответ для состояние(Ans[m1,m2] ),тогда разделим его на кол-во бит в m2.Ответом будет сумма Ans[(1 shl n)-1,dl] , причем кол-во бит в dl = K.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1064",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2612
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 10000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt(1, 10000, \"n\");\n    vector<int> pi = ouf.readInts(n, 1, n, \"pi\");\n\n    set<int> s_pi;\n    for (int i = 0; i < n; i++) {\n        if (s_pi.count(pi[i])) {\n            quitf(_wa, \"pi[%d] = %d is duplicated\", i + 1, pi[i]);\n        }\n        s_pi.insert(pi[i]);\n    }\n\n    set<int> diffs;\n    for (int i = 0; i < n - 1; i++) {\n        int diff = abs(pi[i + 1] - pi[i]);\n        if (diff == 0) {\n            quitf(_wa, \"Zero jump length between positions %d and %d\", i + 1, i + 2);\n        }\n        if (diffs.count(diff)) {\n            quitf(_wa, \"Jump length %d between positions %d and %d is duplicated\", diff, i + 1, i + 2);\n        }\n        diffs.insert(diff);\n    }\n\n    quitf(_ok, \"Correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    // Output the single integer n\n    cout << n << endl;\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n\n    // Output the single integer n\n    cout << n << endl;\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 10\n./gen -n 50\n./gen -n 100\n./gen -n 500\n./gen -n 1000\n./gen -n 5000\n./gen -n 9999\n./gen -n 10000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:25.268417",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "53/D",
      "title": "D. Physical Education",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains an integer n (1 ≤ n ≤ 300) which is the number of students. The second line contains n space-separated integers ai (1 ≤ ai ≤ 109) which represent the height of the student occupying the i-th place must possess. The third line contains n space-separated integers bi (1 ≤ bi ≤ 109) which represent the height of the student occupying the i-th place in the initial arrangement. It is possible that some students possess similar heights. It is guaranteed that it is possible to arrange the children in the required order, i.e. a and b coincide as multisets.",
      "output_spec": "OutputIn the first line print an integer k (0 ≤ k ≤ 106) which is the number of moves. It is not required to minimize k but it must not exceed 106. Then print k lines each containing two space-separated integers. Line pi, pi + 1 (1 ≤ pi ≤ n - 1) means that Vasya should swap students occupying places pi and pi + 1.",
      "sample_tests": "ExamplesInputCopy41 2 3 23 2 1 2OutputCopy42 31 23 42 3InputCopy21 1005001 100500OutputCopy0",
      "description": "D. Physical Education\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains an integer n (1 ≤ n ≤ 300) which is the number of students. The second line contains n space-separated integers ai (1 ≤ ai ≤ 109) which represent the height of the student occupying the i-th place must possess. The third line contains n space-separated integers bi (1 ≤ bi ≤ 109) which represent the height of the student occupying the i-th place in the initial arrangement. It is possible that some students possess similar heights. It is guaranteed that it is possible to arrange the children in the required order, i.e. a and b coincide as multisets.\n\nOutputIn the first line print an integer k (0 ≤ k ≤ 106) which is the number of moves. It is not required to minimize k but it must not exceed 106. Then print k lines each containing two space-separated integers. Line pi, pi + 1 (1 ≤ pi ≤ n - 1) means that Vasya should swap students occupying places pi and pi + 1.\n\nInputCopy41 2 3 23 2 1 2OutputCopy42 31 23 42 3InputCopy21 1005001 100500OutputCopy0\n\nInputCopy41 2 3 23 2 1 2\n\nOutputCopy42 31 23 42 3\n\nInputCopy21 1005001 100500\n\nOutputCopy0",
      "solutions": [
        {
          "title": "Codeforces Beta Round #49 (Div. 2) - Codeforces",
          "content": "Hi everyone! The recent testing round went well. It is expected that everything will run faster. Today's round was prepared by: Mike Mirzayanov, Nickolay Kuznetsov, Ivan Fefer and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: JKeeJ1e30",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1058",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 269
        },
        {
          "title": "Tutorial for problems of Codeforces Beta Round #49 (Div.2). All problems now. - Codeforces",
          "content": "Let's go.A. AutocompleteIn this problem you should read the statement and solve in any way. One of the most simple solutions is read string and last visited pages, sort (even bubble source - 1003 isn't a lot, 3rd power because we need 100 operations to compare two strings), and rundown pages. When we find good string, we should write it and exit.If there are no such one, write source string. 'Goodness' of string is checking with one if (to check lengths and avoid RTE) and for. C. Froggy (Little Frog)IMHO it's the second difficulty problem. If you cannot see solution just after you saw the statement, you can write brute-force solution (rundown all permutation and check), run it for n=10 and see beautiful answer.Answer is 1 n 2 (n-1) 3 (n-2) 4 (n-3) ... Let's define two pointers - l and r. In the beginning, the first one will point to 1, and the second one - to n. On odd positions write down l (and increase it), on even - r (and decrease it). Do it while l <= r.Proof is rather easy: every jump is shorter than the previous one.D. Physical educationThis problem is also very easy. The first thing we should learn is moving element from position x to position y (y < x). Let's move x to position x - 1 with one oblivious swap. Then to position x -2. And so on.Now we want to make a1=b1. Find in b element, that equals a1 and move it to the first position. Similarly we can make a2=b2. So, we have n steps and at every step we do n - 1 swaps at the most. n<=300, so n(n-1)<=89700<106.B. Blog photoDue to bug in GCC I've lost 25 minutes solving this problem. In the end I've used MSVC++.But it was digression, now let's think.The first thing we need to do is fix one side (which are power of two). Because there are two sides and copy-paste is great place for bugs it'll be better to make one more for from 1 to 2 and on the 2nd step swap w and h. It decreases amount of code.Now we know that h=2x. We need to find such w, that 0.8 <= h/w <= 1.25. Solve inequalities for w: h/1.25 <= w <= h/0.8. Because w is integer, it can take any value from ceil(h/1.25) to floor(h/0.8) inclusive. We need to maximize square and h is fixed, so our target is maximize w. We need to let w=floor(h/0.8) and check that it fit borders. If so - relax the answer.It's O(log2 h) solution.Possible bugs are:You calculate square in 32-bit type or like this: int w = ..., h = ...; long long s = w * h; In this case compiler calculate w * h in 32-bit type first, and then convert it to long long. Solution is long long s = (long long)w * hfloor(0.9999999999)=0. The floor function does not correspond with inaccuracy of floating point types. It can be solved either with adding something eps to number before calling floor, or with additional check that difference between floor's result and source value is not greater than 1 - eps.p.s. The floor function is up to 8-9 times slower that conversion to int.E. Dead endsThe first thing you should notice - - n <= 10. It means, that we have exponential solution and we can rundown some subsets.Solution is dynamic programming d[m][subm] - number of ways to make connected tree from subgraph m (it's a bit mask) with dead ends subm (it's also a bit mask). Answer is sum of d[2n-1][x], where |x|=k (size of x as a subset is k).Recalculating isn't really hard. For empty subset and subset of two vertexes (either 0 or 1) answer is oblivious. Also you should know that there is no tree with exactly one dead end (it's easy to prove). Now for greater subsets: rundown i from subm - one of dead ends. Cut it off from tree along some edge to b (b shouldn't be a dead end, otherwise we got unconnected graph). Now we have tree with lower count of vertexes and either decreased 1 number of dead ends or with changed i to b (if b had exactly two neighbors). Answer for this tree we know already. In the end of summarizing we should divide answer by k - each tree has been taken as many times, as it has dead ends (k).p.s. I'll be glad if you tell me my mistakes in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3994
        },
        {
          "title": "Разбор задач Codeforces Beta Round #49(Div. 2) - Codeforces",
          "content": "Задача А. Автодополнение В задаче не было особой сложности в реализации и алгоритме решения, так-как ограничения позволяли  написать решение со квадратичной сложностью. Просто делаем все как и требовалось в условии. Задача B. Фотография в блогВ этой задаче так-же нужно было переборное решение.Сначала перебираем первую сторону как степень двойки(пускай это будет S) , когда мы знаем это число пытаемся определить максимальную 2ю сторону(пускай это будет L) которую мы можем получить(возможно ее мы не можем получить): первый вариант S*0.8>m ,тогда L=0 (мы ее не можем получить можно поставить 0, и произведение будет 0), второй вариант S*1.25<m , тогда L равно максимальному целому числу меньше равному S*1.25, иначе S*0.8<=m<=S*1.25 L=m. Посчитав их проверяем на оптимальность. Аналогично делаем и для второй стороны. Единственно что нужно помнить в случае равности ответа приоритет отдается тому, когда высота больше. Задача С. ЛягушонокОтветом будет последовательность: 1 ,N  ,2 ,N-1, 3 ,N-2 ...Доказать это можно очень просто, так-как разница между числами всегда будет уменьшаться на единичку. Задача D. ФизкультураАлгоритм задачи такой: идем слева на право и берем для каждого человека из первого множества самого ближнего из второго , который стоит не левее его самого , ну то есть если мы рассматриваем человека номер i, то нам надо найти минимальное j, что i<=j и A[i]=B[j]. И сделать нужные переходы. Так-как ограничение всего-лишь 300, то такое решение будет работать. Так-же это решение будет выдавать самый оптимальный ответ. Для больших ограничений эта задача решается сортировкой слиянием. Ну то есть сначала нужно сделать некоторые преобразования, а именно для каждой ячейки определить где она должна будет стоять, дальше выходит довольно не сложный алгоритм.Задача Е. ТупикиЗададим динамику Ans[tree,dl] (tree,dl - битмаски) где будем хранить ответ: 1). мы составили дерево из вершин tree.2). тупиками у нас вершины dl.Очевидным есть ответ для двух бит, если между вершинами есть ребро то 1 , иначе 0. Если кол-во бит больше(пускай єто будет состояние (m1,m2)) то ответ считаем так: зафиксируем некоторую вершину i которая есть тупиком и некоторую вершину j которая не есть тупиком и есть ребро между i и j. Мы будем убирать вершину i из дерева, тогда возможны два перехода , тупик i исчезает и получаем состояние (m1 xor (1 shl i),m2 xor (1 shl i)) , тупик i исчезает и j стает тупиком (m1 xor (1 shl i),m2 xor (1 shl i) xor (1 shl j)). Когда посчитали ответ для состояние(Ans[m1,m2] ),тогда разделим его на кол-во бит в m2.Ответом будет сумма Ans[(1 shl n)-1,dl] , причем кол-во бит в dl = K.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1064",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2612
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    ensuref(a == b, \"Sequences a and b must be the same as multisets\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    ensuref(a == b, \"Sequences a and b must be the same as multisets\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 300);\n    inf.readEoln();\n\n    vector<int> a = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    vector<int> b = inf.readInts(n, 1, 1000000000);\n    inf.readEoln();\n\n    sort(a.begin(), a.end());\n    sort(b.begin(), b.end());\n    ensuref(a == b, \"Sequences a and b must be the same as multisets\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // Read input data from the test file (inf).\n    int n = inf.readInt(1, 300, \"n\");\n    vector<long long> a(n), b(n);\n    for(int i = 0; i < n; i++) {\n        a[i] = inf.readLong(1LL, 1000000000LL, \"a_i\");\n    }\n    for(int i = 0; i < n; i++) {\n        b[i] = inf.readLong(1LL, 1000000000LL, \"b_i\");\n    }\n\n    // Read the contestant's output from ouf.\n    // 0 <= k <= 1e6\n    int k = ouf.readInt(0, 1000000, \"k\");\n\n    // Apply each swap in order to transform b.\n    // Each move must swap adjacent students.\n    for(int i = 0; i < k; i++) {\n        // Each move line must contain two integers: p, p+1\n        int p = ouf.readInt(1, n-1, \"p\");\n        int q = ouf.readInt(p + 1, p + 1, \"q\");\n        // Perform the swap (using 0-based indexing in code).\n        swap(b[p - 1], b[q - 1]);\n    }\n\n    // After applying all swaps, b must match a.\n    if(b == a) {\n        quitf(_ok, \"Correct final arrangement with %d swaps\", k);\n    } else {\n        quitf(_wa, \"Incorrect final arrangement after %d swaps\", k);\n    }\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    int hmin = opt<int>(\"hmin\", 1);\n    int hmax = opt<int>(\"hmax\", 1000000000);\n    int swaps = opt<int>(\"swaps\", 0);\n\n    vector<int> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"already_sorted\") {\n        // Generate ai - random heights between hmin and hmax\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(hmin, hmax);\n        }\n        bi = ai;\n    } else if (type == \"reverse\") {\n        // Make sure hmax - hmin +1 >= n\n        if (hmax - hmin + 1 < n) {\n            hmax = hmin + n - 1;\n        }\n        // Generate ai sorted ascending unique heights\n        for (int i = 0; i < n; ++i) {\n            ai[i] = hmin + i;\n        }\n        // bi is reverse of ai\n        bi = ai;\n        reverse(bi.begin(), bi.end());\n    } else if (type == \"random\") {\n        // Generate ai random heights between hmin and hmax\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(hmin, hmax);\n        }\n        // bi is random permutation of ai\n        bi = ai;\n        shuffle(bi.begin(), bi.end());\n    } else if (type == \"duplicates\") {\n        // Generate ai with duplicates\n        int num_heights = opt<int>(\"num_heights\", max(1, n / 2));\n        vector<int> heights;\n\n        // Ensure that hmax - hmin +1 >= num_heights\n        if (hmax - hmin + 1 < num_heights) {\n            hmax = hmin + num_heights - 1;\n        }\n        for (int i = 0; i < num_heights; ++i) {\n            heights.push_back(hmin + i);\n        }\n        // Fill ai with these heights\n        for (int i = 0; i < n; ++i) {\n            ai[i] = heights[rnd.next(0, num_heights - 1)];\n        }\n        // bi is random permutation of ai\n        bi = ai;\n        shuffle(bi.begin(), bi.end());\n    } else if (type == \"same\") {\n        // All heights are the same\n        int h = rnd.next(hmin, hmax);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = h;\n        }\n        // bi is random permutation (but since all heights are same, bi == ai)\n        bi = ai;\n    } else if (type == \"almost_sorted\") {\n        // Make sure hmax - hmin +1 >= n\n        if (hmax - hmin + 1 < n) {\n            hmax = hmin + n - 1;\n        }\n        // Generate ai sorted ascending unique heights\n        for (int i = 0; i < n; ++i) {\n            ai[i] = hmin + i;\n        }\n        // Copy ai to bi\n        bi = ai;\n        // Apply the required number of swaps\n        int num_swaps = min(swaps, n - 1);\n        for (int i = 0; i < num_swaps; ++i) {\n            int pos = rnd.next(0, n - 2);\n            swap(bi[pos], bi[pos + 1]);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\");\n    int hmin = opt<int>(\"hmin\", 1);\n    int hmax = opt<int>(\"hmax\", 1000000000);\n    int swaps = opt<int>(\"swaps\", 0);\n\n    vector<int> ai(n);\n    vector<int> bi(n);\n\n    if (type == \"already_sorted\") {\n        // Generate ai - random heights between hmin and hmax\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(hmin, hmax);\n        }\n        bi = ai;\n    } else if (type == \"reverse\") {\n        // Make sure hmax - hmin +1 >= n\n        if (hmax - hmin + 1 < n) {\n            hmax = hmin + n - 1;\n        }\n        // Generate ai sorted ascending unique heights\n        for (int i = 0; i < n; ++i) {\n            ai[i] = hmin + i;\n        }\n        // bi is reverse of ai\n        bi = ai;\n        reverse(bi.begin(), bi.end());\n    } else if (type == \"random\") {\n        // Generate ai random heights between hmin and hmax\n        for (int i = 0; i < n; ++i) {\n            ai[i] = rnd.next(hmin, hmax);\n        }\n        // bi is random permutation of ai\n        bi = ai;\n        shuffle(bi.begin(), bi.end());\n    } else if (type == \"duplicates\") {\n        // Generate ai with duplicates\n        int num_heights = opt<int>(\"num_heights\", max(1, n / 2));\n        vector<int> heights;\n\n        // Ensure that hmax - hmin +1 >= num_heights\n        if (hmax - hmin + 1 < num_heights) {\n            hmax = hmin + num_heights - 1;\n        }\n        for (int i = 0; i < num_heights; ++i) {\n            heights.push_back(hmin + i);\n        }\n        // Fill ai with these heights\n        for (int i = 0; i < n; ++i) {\n            ai[i] = heights[rnd.next(0, num_heights - 1)];\n        }\n        // bi is random permutation of ai\n        bi = ai;\n        shuffle(bi.begin(), bi.end());\n    } else if (type == \"same\") {\n        // All heights are the same\n        int h = rnd.next(hmin, hmax);\n        for (int i = 0; i < n; ++i) {\n            ai[i] = h;\n        }\n        // bi is random permutation (but since all heights are same, bi == ai)\n        bi = ai;\n    } else if (type == \"almost_sorted\") {\n        // Make sure hmax - hmin +1 >= n\n        if (hmax - hmin + 1 < n) {\n            hmax = hmin + n - 1;\n        }\n        // Generate ai sorted ascending unique heights\n        for (int i = 0; i < n; ++i) {\n            ai[i] = hmin + i;\n        }\n        // Copy ai to bi\n        bi = ai;\n        // Apply the required number of swaps\n        int num_swaps = min(swaps, n - 1);\n        for (int i = 0; i < num_swaps; ++i) {\n            int pos = rnd.next(0, n - 2);\n            swap(bi[pos], bi[pos + 1]);\n        }\n    } else {\n        fprintf(stderr, \"Unknown type: %s\\n\", type.c_str());\n        exit(1);\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", ai[i], i == n - 1 ? '\\n' : ' ');\n    }\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", bi[i], i == n - 1 ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type same\n./gen -n 1 -type already_sorted\n./gen -n 2 -type reverse\n./gen -n 3 -type almost_sorted -swaps 2\n./gen -n 4 -type duplicates -num_heights 2\n./gen -n 10 -type random\n./gen -n 10 -type reverse\n./gen -n 10 -type almost_sorted -swaps 5\n./gen -n 100 -type random\n./gen -n 100 -type almost_sorted -swaps 20\n./gen -n 100 -type duplicates -num_heights 10\n./gen -n 150 -type duplicates -num_heights 75\n./gen -n 300 -type same -hmin 10000000 -hmax 10000000\n./gen -n 300 -type random -hmin 100000 -hmax 1000000\n./gen -n 300 -type reverse\n./gen -n 300 -type duplicates -num_heights 2\n./gen -n 300 -type duplicates -num_heights 150\n./gen -n 299 -type reverse\n./gen -n 300 -type almost_sorted -swaps 0\n./gen -n 300 -type almost_sorted -swaps 1\n./gen -n 300 -type almost_sorted -swaps 100\n./gen -n 300 -type almost_sorted -swaps 299\n./gen -n 300 -type already_sorted -hmin 900000000 -hmax 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:27.695427",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "53/E",
      "title": "E. Dead Ends",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test5 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains three integers n, m and k (3 ≤ n ≤ 10, n - 1 ≤ m ≤ n·(n - 1) / 2, 2 ≤ k ≤ n - 1) which represent the number of junctions, roads and dead ends correspondingly. Then follow m lines each containing two different integers v1 and v2 (1 ≤ v1, v2 ≤ n, v1 ≠ v2) which represent the number of junctions connected by another road. There can be no more than one road between every pair of junctions. The junctions are numbered with integers from 1 to n. It is guaranteed that it is possible to get from each junction to any other one along the original roads.",
      "output_spec": "OutputPrint a single number — the required number of ways.",
      "sample_tests": "ExamplesInputCopy3 3 21 22 31 3OutputCopy3InputCopy4 6 21 22 33 44 11 32 4OutputCopy12InputCopy4 6 31 22 33 44 11 32 4OutputCopy4",
      "description": "E. Dead Ends\n\ntime limit per test5 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\noutputstdout\n\nInputThe first line contains three integers n, m and k (3 ≤ n ≤ 10, n - 1 ≤ m ≤ n·(n - 1) / 2, 2 ≤ k ≤ n - 1) which represent the number of junctions, roads and dead ends correspondingly. Then follow m lines each containing two different integers v1 and v2 (1 ≤ v1, v2 ≤ n, v1 ≠ v2) which represent the number of junctions connected by another road. There can be no more than one road between every pair of junctions. The junctions are numbered with integers from 1 to n. It is guaranteed that it is possible to get from each junction to any other one along the original roads.\n\nOutputPrint a single number — the required number of ways.\n\nInputCopy3 3 21 22 31 3OutputCopy3InputCopy4 6 21 22 33 44 11 32 4OutputCopy12InputCopy4 6 31 22 33 44 11 32 4OutputCopy4\n\nInputCopy3 3 21 22 31 3\n\nOutputCopy3\n\nInputCopy4 6 21 22 33 44 11 32 4\n\nOutputCopy12\n\nInputCopy4 6 31 22 33 44 11 32 4\n\nOutputCopy4",
      "solutions": [
        {
          "title": "Codeforces Beta Round #49 (Div. 2) - Codeforces",
          "content": "Hi everyone! The recent testing round went well. It is expected that everything will run faster. Today's round was prepared by: Mike Mirzayanov, Nickolay Kuznetsov, Ivan Fefer and Maria Belova.Good luck!Artem Rakhov and Codeforces teamProblemsStandingsWinner: JKeeJ1e30",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1058",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 269
        },
        {
          "title": "Tutorial for problems of Codeforces Beta Round #49 (Div.2). All problems now. - Codeforces",
          "content": "Let's go.A. AutocompleteIn this problem you should read the statement and solve in any way. One of the most simple solutions is read string and last visited pages, sort (even bubble source - 1003 isn't a lot, 3rd power because we need 100 operations to compare two strings), and rundown pages. When we find good string, we should write it and exit.If there are no such one, write source string. 'Goodness' of string is checking with one if (to check lengths and avoid RTE) and for. C. Froggy (Little Frog)IMHO it's the second difficulty problem. If you cannot see solution just after you saw the statement, you can write brute-force solution (rundown all permutation and check), run it for n=10 and see beautiful answer.Answer is 1 n 2 (n-1) 3 (n-2) 4 (n-3) ... Let's define two pointers - l and r. In the beginning, the first one will point to 1, and the second one - to n. On odd positions write down l (and increase it), on even - r (and decrease it). Do it while l <= r.Proof is rather easy: every jump is shorter than the previous one.D. Physical educationThis problem is also very easy. The first thing we should learn is moving element from position x to position y (y < x). Let's move x to position x - 1 with one oblivious swap. Then to position x -2. And so on.Now we want to make a1=b1. Find in b element, that equals a1 and move it to the first position. Similarly we can make a2=b2. So, we have n steps and at every step we do n - 1 swaps at the most. n<=300, so n(n-1)<=89700<106.B. Blog photoDue to bug in GCC I've lost 25 minutes solving this problem. In the end I've used MSVC++.But it was digression, now let's think.The first thing we need to do is fix one side (which are power of two). Because there are two sides and copy-paste is great place for bugs it'll be better to make one more for from 1 to 2 and on the 2nd step swap w and h. It decreases amount of code.Now we know that h=2x. We need to find such w, that 0.8 <= h/w <= 1.25. Solve inequalities for w: h/1.25 <= w <= h/0.8. Because w is integer, it can take any value from ceil(h/1.25) to floor(h/0.8) inclusive. We need to maximize square and h is fixed, so our target is maximize w. We need to let w=floor(h/0.8) and check that it fit borders. If so - relax the answer.It's O(log2 h) solution.Possible bugs are:You calculate square in 32-bit type or like this: int w = ..., h = ...; long long s = w * h; In this case compiler calculate w * h in 32-bit type first, and then convert it to long long. Solution is long long s = (long long)w * hfloor(0.9999999999)=0. The floor function does not correspond with inaccuracy of floating point types. It can be solved either with adding something eps to number before calling floor, or with additional check that difference between floor's result and source value is not greater than 1 - eps.p.s. The floor function is up to 8-9 times slower that conversion to int.E. Dead endsThe first thing you should notice - - n <= 10. It means, that we have exponential solution and we can rundown some subsets.Solution is dynamic programming d[m][subm] - number of ways to make connected tree from subgraph m (it's a bit mask) with dead ends subm (it's also a bit mask). Answer is sum of d[2n-1][x], where |x|=k (size of x as a subset is k).Recalculating isn't really hard. For empty subset and subset of two vertexes (either 0 or 1) answer is oblivious. Also you should know that there is no tree with exactly one dead end (it's easy to prove). Now for greater subsets: rundown i from subm - one of dead ends. Cut it off from tree along some edge to b (b shouldn't be a dead end, otherwise we got unconnected graph). Now we have tree with lower count of vertexes and either decreased 1 number of dead ends or with changed i to b (if b had exactly two neighbors). Answer for this tree we know already. In the end of summarizing we should divide answer by k - each tree has been taken as many times, as it has dead ends (k).p.s. I'll be glad if you tell me my mistakes in English.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1065",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 3994
        },
        {
          "title": "Разбор задач Codeforces Beta Round #49(Div. 2) - Codeforces",
          "content": "Задача А. Автодополнение В задаче не было особой сложности в реализации и алгоритме решения, так-как ограничения позволяли  написать решение со квадратичной сложностью. Просто делаем все как и требовалось в условии. Задача B. Фотография в блогВ этой задаче так-же нужно было переборное решение.Сначала перебираем первую сторону как степень двойки(пускай это будет S) , когда мы знаем это число пытаемся определить максимальную 2ю сторону(пускай это будет L) которую мы можем получить(возможно ее мы не можем получить): первый вариант S*0.8>m ,тогда L=0 (мы ее не можем получить можно поставить 0, и произведение будет 0), второй вариант S*1.25<m , тогда L равно максимальному целому числу меньше равному S*1.25, иначе S*0.8<=m<=S*1.25 L=m. Посчитав их проверяем на оптимальность. Аналогично делаем и для второй стороны. Единственно что нужно помнить в случае равности ответа приоритет отдается тому, когда высота больше. Задача С. ЛягушонокОтветом будет последовательность: 1 ,N  ,2 ,N-1, 3 ,N-2 ...Доказать это можно очень просто, так-как разница между числами всегда будет уменьшаться на единичку. Задача D. ФизкультураАлгоритм задачи такой: идем слева на право и берем для каждого человека из первого множества самого ближнего из второго , который стоит не левее его самого , ну то есть если мы рассматриваем человека номер i, то нам надо найти минимальное j, что i<=j и A[i]=B[j]. И сделать нужные переходы. Так-как ограничение всего-лишь 300, то такое решение будет работать. Так-же это решение будет выдавать самый оптимальный ответ. Для больших ограничений эта задача решается сортировкой слиянием. Ну то есть сначала нужно сделать некоторые преобразования, а именно для каждой ячейки определить где она должна будет стоять, дальше выходит довольно не сложный алгоритм.Задача Е. ТупикиЗададим динамику Ans[tree,dl] (tree,dl - битмаски) где будем хранить ответ: 1). мы составили дерево из вершин tree.2). тупиками у нас вершины dl.Очевидным есть ответ для двух бит, если между вершинами есть ребро то 1 , иначе 0. Если кол-во бит больше(пускай єто будет состояние (m1,m2)) то ответ считаем так: зафиксируем некоторую вершину i которая есть тупиком и некоторую вершину j которая не есть тупиком и есть ребро между i и j. Мы будем убирать вершину i из дерева, тогда возможны два перехода , тупик i исчезает и получаем состояние (m1 xor (1 shl i),m2 xor (1 shl i)) , тупик i исчезает и j стает тупиком (m1 xor (1 shl i),m2 xor (1 shl i) xor (1 shl j)). Когда посчитали ответ для состояние(Ans[m1,m2] ),тогда разделим его на кол-во бит в m2.Ответом будет сумма Ans[(1 shl n)-1,dl] , причем кол-во бит в dl = K.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/1064",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 2612
        }
      ],
      "code_examples": [],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n -1, n*(n -1)/2, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n -1, \"k\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n+1);\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge endpoints must be different, but found (%d, %d)\", u, v);\n\n        auto p = make_pair(min(u,v), max(u,v));\n        ensuref(edges.count(p) == 0, \"Multiple edges between the same pair of nodes %d and %d\", u, v);\n\n        edges.insert(p);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check that the graph is connected\n    vector<bool> visited(n+1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int curr = q.front(); q.pop();\n        for (int neighbor : adj[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor]=true;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n -1, n*(n -1)/2, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n -1, \"k\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n+1);\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge endpoints must be different, but found (%d, %d)\", u, v);\n\n        auto p = make_pair(min(u,v), max(u,v));\n        ensuref(edges.count(p) == 0, \"Multiple edges between the same pair of nodes %d and %d\", u, v);\n\n        edges.insert(p);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check that the graph is connected\n    vector<bool> visited(n+1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int curr = q.front(); q.pop();\n        for (int neighbor : adj[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor]=true;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(3, 10, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(n -1, n*(n -1)/2, \"m\");\n    inf.readSpace();\n    int k = inf.readInt(2, n -1, \"k\");\n    inf.readEoln();\n\n    vector<vector<int>> adj(n+1);\n    set<pair<int,int>> edges;\n\n    for (int i = 0; i < m; ++i) {\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int v = inf.readInt(1, n, \"v\");\n        inf.readEoln();\n\n        ensuref(u != v, \"Edge endpoints must be different, but found (%d, %d)\", u, v);\n\n        auto p = make_pair(min(u,v), max(u,v));\n        ensuref(edges.count(p) == 0, \"Multiple edges between the same pair of nodes %d and %d\", u, v);\n\n        edges.insert(p);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    // Now check that the graph is connected\n    vector<bool> visited(n+1, false);\n    queue<int> q;\n    q.push(1);\n    visited[1] = true;\n    while (!q.empty()) {\n        int curr = q.front(); q.pop();\n        for (int neighbor : adj[curr]) {\n            if (!visited[neighbor]) {\n                visited[neighbor]=true;\n                q.push(neighbor);\n            }\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        ensuref(visited[i], \"Graph is not connected: node %d is not reachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(3 <= n && n <= 10);\n    ensure(n - 1 <= m && m <= n * (n - 1) / 2);\n    ensure(2 <= k && k <= n - 1);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Create a chain (path)\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Create a star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        // Create a complete graph\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                edges.push_back({i, j});\n    } else if (type == \"random\") {\n        // Generate a random connected graph\n        vector<int> p(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            int pi = rnd.next(1, i - 1);\n            edges.push_back({pi, i});\n        }\n        // Add extra edges\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else {\n        cerr << \"Unknown graph type: \" << type << endl;\n        return 1;\n    }\n\n    // Adjust edges if necessary\n    if ((int)edges.size() < m) {\n        // Add edges\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if ((int)edges.size() > m) {\n        // Remove edges\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n    }\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    int k = opt<int>(\"k\");\n    string type = opt<string>(\"type\", \"random\");\n\n    ensure(3 <= n && n <= 10);\n    ensure(n - 1 <= m && m <= n * (n - 1) / 2);\n    ensure(2 <= k && k <= n - 1);\n\n    vector<pair<int, int>> edges;\n\n    if (type == \"chain\") {\n        // Create a chain (path)\n        for (int i = 1; i < n; ++i) {\n            edges.push_back({i, i + 1});\n        }\n    } else if (type == \"star\") {\n        // Create a star\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (type == \"complete\") {\n        // Create a complete graph\n        for (int i = 1; i <= n; ++i)\n            for (int j = i + 1; j <= n; ++j)\n                edges.push_back({i, j});\n    } else if (type == \"random\") {\n        // Generate a random connected graph\n        vector<int> p(n + 1);\n        for (int i = 2; i <= n; ++i) {\n            int pi = rnd.next(1, i - 1);\n            edges.push_back({pi, i});\n        }\n        // Add extra edges\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else {\n        cerr << \"Unknown graph type: \" << type << endl;\n        return 1;\n    }\n\n    // Adjust edges if necessary\n    if ((int)edges.size() < m) {\n        // Add edges\n        set<pair<int, int>> edge_set(edges.begin(), edges.end());\n        while ((int)edge_set.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            if (u == v) continue;\n            if (u > v) swap(u, v);\n            if (edge_set.count({u, v})) continue;\n            edge_set.insert({u, v});\n        }\n        edges.assign(edge_set.begin(), edge_set.end());\n    } else if ((int)edges.size() > m) {\n        // Remove edges\n        shuffle(edges.begin(), edges.end());\n        edges.resize(m);\n    }\n\n    printf(\"%d %d %d\\n\", n, m, k);\n    for (auto e : edges) {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 3 -m 3 -k 2 -type chain\n./gen -n 4 -m 6 -k 2 -type complete\n./gen -n 5 -m 5 -k 2 -type star\n./gen -n 6 -m 10 -k 3 -type random\n./gen -n 7 -m 10 -k 2 -type chain\n./gen -n 8 -m 28 -k 7 -type complete\n./gen -n 9 -m 8 -k 4 -type star\n./gen -n 10 -m 15 -k 5 -type random\n./gen -n 3 -m 2 -k 2 -type chain\n./gen -n 4 -m 4 -k 3 -type star\n./gen -n 5 -m 10 -k 2 -type complete\n./gen -n 6 -m 9 -k 2 -type random\n./gen -n 7 -m 6 -k 4 -type chain\n./gen -n 8 -m 9 -k 5 -type random\n./gen -n 9 -m 15 -k 2 -type star\n./gen -n 10 -m 45 -k 9 -type complete\n./gen -n 5 -m 4 -k 3 -type chain\n./gen -n 6 -m 8 -k 4 -type random\n./gen -n 7 -m 21 -k 2 -type star\n./gen -n 8 -m 7 -k 6 -type chain\n./gen -n 9 -m 12 -k 5 -type random\n./gen -n 10 -m 40 -k 2 -type star\n./gen -n 3 -m 3 -k 2 -type random\n./gen -n 4 -m 5 -k 2 -type random\n./gen -n 5 -m 7 -k 2 -type random\n./gen -n 6 -m 10 -k 2 -type random\n./gen -n 7 -m 15 -k 3 -type random\n./gen -n 8 -m 20 -k 4 -type random\n./gen -n 9 -m 25 -k 5 -type random\n./gen -n 10 -m 30 -k 6 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:29.736779",
        "total_tutorials": 3,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "533/A",
      "title": "A. Шахтёры Берляндии",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке следует целое число n (1 ≤ n ≤ 5·105) — количество пещер в шахте.Далее следует строка, в которой находятся n целых чисел h1, h2, ..., hn (1 ≤ hi ≤ 109), где hi — высота потолка в i-й пещере.В последующих n - 1 строках находится описание переходов между пещерами. Каждая строка имеет вид ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), где ai и bi — номера пещер, соединённых переходом.В следующей строке находится целое число k (1 ≤ k ≤ n).В последней строке находятся k целых чисел s1, s2, ..., sk (1 ≤ sj ≤ 109), где sj — рост j-го шахтёра.",
      "output_spec": "Выходные данныеВ единственной строке выведите минимальное количество метров, на которое нужно увеличить высоту потолка в какой-то из пещер так, чтобы шахтёров можно было распределить по пещерам, и они бы остались довольны условиями труда. Если это сделать невозможно, выведите  - 1. Если это возможно сделать исходно, и поднимать потолок не требуется, то выведите 0.",
      "sample_tests": "ПримерыВходные данныеСкопировать65 8 4 6 3 121 21 34 22 56 367 4 2 5 3 11Выходные данныеСкопировать6Входные данныеСкопировать710 14 7 12 4 50 11 22 32 45 16 51 767 3 4 8 8 10Выходные данныеСкопировать0Входные данныеСкопировать34 2 81 21 3217 15Выходные данныеСкопировать-1",
      "description": "A. Шахтёры Берляндии\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке следует целое число n (1 ≤ n ≤ 5·105) — количество пещер в шахте.Далее следует строка, в которой находятся n целых чисел h1, h2, ..., hn (1 ≤ hi ≤ 109), где hi — высота потолка в i-й пещере.В последующих n - 1 строках находится описание переходов между пещерами. Каждая строка имеет вид ai, bi (1 ≤ ai, bi ≤ n, ai ≠ bi), где ai и bi — номера пещер, соединённых переходом.В следующей строке находится целое число k (1 ≤ k ≤ n).В последней строке находятся k целых чисел s1, s2, ..., sk (1 ≤ sj ≤ 109), где sj — рост j-го шахтёра.\n\nВходные данные\n\nВыходные данныеВ единственной строке выведите минимальное количество метров, на которое нужно увеличить высоту потолка в какой-то из пещер так, чтобы шахтёров можно было распределить по пещерам, и они бы остались довольны условиями труда. Если это сделать невозможно, выведите  - 1. Если это возможно сделать исходно, и поднимать потолок не требуется, то выведите 0.\n\nВыходные данные\n\nВходные данныеСкопировать65 8 4 6 3 121 21 34 22 56 367 4 2 5 3 11Выходные данныеСкопировать6Входные данныеСкопировать710 14 7 12 4 50 11 22 32 45 16 51 767 3 4 8 8 10Выходные данныеСкопировать0Входные данныеСкопировать34 2 81 21 3217 15Выходные данныеСкопировать-1\n\nВходные данныеСкопировать65 8 4 6 3 121 21 34 22 56 367 4 2 5 3 11\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать710 14 7 12 4 50 11 22 32 45 16 51 767 3 4 8 8 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать34 2 81 21 3217 15\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом тесте из условия нужно увеличить высоту потолка в первой пещере с 5 до 11. После этого можно распределить шахтёров по пещерам следующим образом (сначала указан номер шахтёра, а потом номер пещеры): .Во втором тесте из условия никаких действий не требуется, потому что шахтёров изначально можно распределить следующим образом: .В третьем тесте из условия добиться требуемого невозможно.",
      "solutions": [
        {
          "title": "VK Cup Round 2 + неофициальная интернет-трансляция - Codeforces",
          "content": "В пятницу, 17-го апреля, в 19:00 начнётся Раунд 2 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять участие все те команды, которые отобрались в Раунде 1 или в Уайлд-кард раунде 1. Напомним, что из первого раунда допущены все те команды, что набрали не менее 796 баллов. В уайлд-кард раунде было достаточно решить не менее шести задач, либо решить пять задач со штрафным временем не более 415 минут. Таким образом, принять участие в Раунде 2 могут 400 + 50 = 450 команд!Участников ждет соревнование по правилам классических раундов Codeforces. По сравнению с Раундом 1 вас ждут некоторые изменения. Во-первых, одновременно с основным раундом будет проведена интернет-трансляция, которая представляет из себя обычный рейтинговый div1-раунд по правилам Codeforces. В трансляции может участвовать любой div1-участник, не зарегистрированный на основной раунд в составе отобравшейся команды.Во-вторых, вас, как и ранее, ждёт плавная динамическая система оценки задач, но сами задачи будут расположены в случайном порядке. Участникам будет предложено 6 задач.Раунд подготовлен силами команды Codeforces, команды VK и пользователя Errichto, который предложил свою неоценимую помощь в рамках кампании \"5 лет Codeforces\". Большую помощь в тестировании задач оказал winger.Напомним, что в Раунд 3 пройдут все те команды, которые наберут положительный балл, не меньший, чем у команды на 100-м месте. Также обращаем ваше внимание, что все команды, проходящие в Раунд 3, получат фирменную футболку Чемпионата. Помимо этого, фирменной футболкой будут награждены топ-50 участников интернет-трансляции Раунда 3.Желаем удачи и интересной борьбы!UPD: Благодарим всех за участие! Появился разбор задач. Ждём вас на Уайлд-кард раунде 2 и Раунде 3!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1851
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces",
          "content": "532A - Шахтёры БерляндииДоступна только английская версия разбора в английской версии поста.532B - Рабочая группаЭту задачу можно решить с помощью динамического программирования по поддеревьям иерархии сотрудников. Обозначим за D[v][e] максимальную эффективность, которую можно получить, взяв некоторое количество сотрудников из поддерева человека v, таким образом, чтобы их количество имело чётность e, и условие задачи выполнялось для всех взятых людей. Тогда нетрудно пересчитать D[v][e] через детей вершины v с помощью подсчёта промежуточной величины T[i][e] — максимальной эффективности, которой можно достичь, пройдя первые i поддеревьев вершины v, если чётность количества взятых людей — e.Важно не забыть, что бывает два случая: когда мы добавляем самого v, и когда мы этого не делаем. В первом случае обязательно во всех поддеревьях суммарно должно быть чётное число людей по условию, во втором же подобного не требуется.532C - Игра на доскеРассмотрим три случая.1) xp  +  yp ≤  max(xv,  yv). В этом случае Поликарп может оказаться в (0,  0) через xp  +  yp ходов и Василий всегда будет \"позади\". Для Поликарпа достаточно делать любой возможный ход, и это приведёт его к победе. Нетрудно это объяснить тем, что условие xp  +  yp ≤  max(xv,  yv) будет выполнено и после любых возможных ходов Поликарпа и Василия. Иными словами, Василий просто не может победить.2) xp ≤ xv, $y_p \\leq y_v$. В этом случае Поликарп должен некоторым образом блокировать Василия. Он должен совершать такой ход, чтобы после любого возможного хода Василия неравенство было снова выполнено. Если xp  =  xv  >  0, нужно пойти в (xp  -  1,  yp). Если yp  =  yv  >  0, нужно пойти в (xp,  yp  -  1). В противном случае можно совершить любой допустимый ход. Действуя по такой стратегии, мы снова не даём Василию возможности выиграть.3) В противном случае рассмотрим любой кратчайший путь для Василия до точки (0,  0). Любая клетка этого пути ближе к Василию, чем к Поликарпу, поэтому Поликарп никак не может помешать Василию на этом пути. А значит, Василий дойдёт до финиша первым. Альтернативное объяснение заключается в том, что Василий всегда может сходить таким образом, чтобы ни одно из условий 1) и 2) не оказалось выполненным.532D - КолонныПервое наблюдение: колонна рушится только если расстояние между её соседями больше, чем 2di, поэтому для неё не имеет значения, где именно она находится на отрезке между своими соседками. Важно только расстояние между ними.Для каждой колонны C давайте определим, существует ли набор колонн слева такой, что слева от C всё устойчиво. Если ответ да, то тогда давайте определим, как близко может находиться ближайшая к C слева в этом наборе колонна. Зная это, мы узнаем, как далеко справа может находиться следующая за C колонна. Воспользуемся динамическим программированием.Медленный подход: для каждой предыдущей колонны проверим, может ли она быть соседом C. Ближайшая колонна, которая может, является будет тем самым левым соседом C.Более быстрый подход: давайте обозначим за far[i] наибольшую возможную координату, где может находиться правый сосед колонны i. В нашей динамике заведём стек с возможными кандидатами на то, чтобы быть левым соседом каждой колонны. В этом стеке колонны будем поддерживать в порядке возрастания индекса (а, значит, и координаты) и одновременно в порядке убывания far[i] (действительно, нам незачем хранить в стеке колонну, если её мажорирует и по координате, и по far[i] какая-то другая колонна).Теперь для каждой новой колонн мы должны удалить с вершины стека некоторое количество колонн со слишком малым значением far[i]. Последняя оставшаяся колонна на стеке будет той самой, через которую мы пересчитаем значение нашей динамики. Эта часть занимает O(n) времени.Если существует колонна с far[i] не меньше координаты правой несущей колонны, то ответ--- 0, так как конструкция исходно устойчива.Теперь посчитаем ту же самую величину справа налево. Теперь некоторые колонны связаны с левой несущей, некоторые — с правой. Мы хотим поставить новую так, чтобы попасть в пределы far[i] как для левой колонны, так и для правой. Это можно сделать, используя технику двух указателей по двум образованным стекам.Описанное решение работает за O(n) времени и памяти.532E - Исправление ошибокПредположим для определённости, что S получается из W удалением более раннего символа, чем T. Тогда W  =  A  +  x  +  B  +  y  +  C, S  =  A  +  x  +  B  +  C, T  =  A  +  B  +  y  +  C, где x и y — удаляемые символы, а A, B и C — какие-то (возможно, пустые) строки.Определим A как наибольший общий префикс S и T, а C — как наибольший общий суффикс. Удалим их из обоих строк. Теперь мы знаем буквы x и y — это соответственно первая буква строки S и последняя буква строки T. Удалим и их тоже. Остаётся лишь проверить, равны ли оставшиеся части строк.Проделаем так для S и T, а также для T и S.532F - КодированиеУ этой задачи возможно два направления решения.Зафиксируем пару букв x и y. Заменим в строке S все буквы x на единицы, а все остальные буквы на нули. В строке T заменим все буквы y на единицы, а все остальные буквы на нули. С помощью алгоритма КМП или Z-функции определим все позиции, в которых строку T можно приложить к строке S так, что они совпадут. Если такое условие выполнено как для пары букв (x, y), так и для пары букв (y, x), то это значит, что в данной позиции можно приложить T к S с заменой x <-> y и возможно ещё какими-то заменами.Теперь для каждой позиции надо проверить, разбиваются ли буквы на пары в соответствии с известной нам информацией. Это можно сделать за O(sigma), где sigma  =  26 — размер алфавита. Таким образом, решение работает за O(n  *  sigma2  +  n  *  sigma)  =  O(n  *  sigma2). Это решение при должной аккуратности реализации проходит по времени.Другой способ — произвести замену, которая позволит нам сравнивать строки с точностью до переименовывания букв. Заменим каждую букву на расстояние до предыдущей такой же в обоих строках. Теперь для совпадения с точностью до переименования достаточно проверить, что строка T совпадает с подстрокой строки S во всех позициях кроме, возможно первых вхождений каждой буквы в T. Это можно сделать с помощью модифицированной префикс-функции или хеширования.Пусть мы теперь знаем, что в некоторой позиции строка T совпадает со строкой S с точностью до переименовывания. Нетрудно определить, какая перестановка букв соответствует этому переименовыванию (достаточно посмотреть на первую букву каждого вида в T, чему она соответствует в S). Проверим, что эта перестановка — это набор транспозиций за O(sigma). Таким образом, получим решение за O(n  *  sigma).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6584
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 2 + неофициальная интернет-трансляция - Codeforces - Code 1",
          "code": "(h1 << 32) | h2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 2 + неофициальная интернет-трансляция - Codeforces - Code 2",
          "code": "s[i+1]==t[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 1",
          "code": "11 5\nabacabadaba\nacaba",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 2",
          "code": "11 5\nabacabadaba\nacaba",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 3",
          "code": "s:  a b a  c  a b a  d  a  b   a\nvs: 2 2 2 inf 2 4 2 inf 2 inf inf\n---------------------------------\nt:  a  c  a  b   a\nvt: 2 inf 2 inf inf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 4",
          "code": "s:  a b a  c  a b a  d  a  b   a\nvs: 2 2 2 inf 2 4 2 inf 2 inf inf\n---------------------------------\nt:  a  c  a  b   a\nvt: 2 inf 2 inf inf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 5",
          "code": "a c a b a ! a b a c a b a d a b a\n            5 0 5 0 5 0 5 0 2 0 0\n            a c a b a\n                a c a b a\n                    a c a b a\n                        a c a b a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 6",
          "code": "a c a b a ! a b a c a b a d a b a\n            5 0 5 0 5 0 5 0 2 0 0\n            a c a b a\n                a c a b a\n                    a c a b a\n                        a c a b a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000;\nconst int MAXH = 1000000000;\nconst int MAXS = 1000000000;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, MAXH, \"h_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop is not allowed at edge %d: a = %d, b = %d\", i +1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between %d and %d detected at edge %d\", u, v, i+1);\n        edgeSet.insert(edge);\n\n        int pu = find(a);\n        int pv = find(b);\n\n        ensuref(pu != pv, \"Cycle detected when processing edge %d between %d and %d\", i+1, a, b);\n\n        parent[pu] = pv;\n    }\n\n    // Check connectedness\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not connected to node 1\", i);\n    }\n\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(k, 1, MAXS, \"s_j\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000;\nconst int MAXH = 1000000000;\nconst int MAXS = 1000000000;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, MAXH, \"h_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop is not allowed at edge %d: a = %d, b = %d\", i +1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between %d and %d detected at edge %d\", u, v, i+1);\n        edgeSet.insert(edge);\n\n        int pu = find(a);\n        int pv = find(b);\n\n        ensuref(pu != pv, \"Cycle detected when processing edge %d between %d and %d\", i+1, a, b);\n\n        parent[pu] = pv;\n    }\n\n    // Check connectedness\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not connected to node 1\", i);\n    }\n\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(k, 1, MAXS, \"s_j\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 500000;\nconst int MAXH = 1000000000;\nconst int MAXS = 1000000000;\n\nvector<int> parent;\n\nint find(int u) {\n    if (parent[u] != u) parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, MAXN, \"n\");\n    inf.readEoln();\n\n    vector<int> h = inf.readInts(n, 1, MAXH, \"h_i\");\n    inf.readEoln();\n\n    set<pair<int, int>> edgeSet;\n\n    parent.resize(n + 1);\n    for (int i = 1; i <= n; ++i) parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int a = inf.readInt(1, n, \"a_i\");\n        inf.readSpace();\n        int b = inf.readInt(1, n, \"b_i\");\n        inf.readEoln();\n\n        ensuref(a != b, \"Self-loop is not allowed at edge %d: a = %d, b = %d\", i +1, a, b);\n\n        int u = min(a, b);\n        int v = max(a, b);\n\n        pair<int, int> edge = make_pair(u, v);\n        ensuref(edgeSet.count(edge) == 0, \"Multiple edges between %d and %d detected at edge %d\", u, v, i+1);\n        edgeSet.insert(edge);\n\n        int pu = find(a);\n        int pv = find(b);\n\n        ensuref(pu != pv, \"Cycle detected when processing edge %d between %d and %d\", i+1, a, b);\n\n        parent[pu] = pv;\n    }\n\n    // Check connectedness\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not connected to node 1\", i);\n    }\n\n    int k = inf.readInt(1, n, \"k\");\n    inf.readEoln();\n\n    vector<int> s = inf.readInts(k, 1, MAXS, \"s_j\");\n    inf.readEoln();\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<pair<int,int>> random_tree(int n)\n{\n    vector<int> p(n);\n    for(int i=1;i<n;++i)\n    {\n        p[i] = rnd.next(i); // parent of i is some node before i\n    }\n    vector<pair<int,int>> edges;\n    for(int i=1;i<n;++i)\n    {\n        edges.emplace_back(i+1, p[i]+1);\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\nvector<pair<int,int>> chain_tree(int n)\n{\n    vector<pair<int,int>> edges;\n    for(int i=1;i<n;++i)\n    {\n        edges.emplace_back(i, i+1);\n    }\n    return edges;\n}\n\nvector<pair<int,int>> star_tree(int n)\n{\n    vector<pair<int,int>> edges;\n    for(int i=2;i<=n;++i)\n    {\n        edges.emplace_back(1, i);\n    }\n    return edges;\n}\n\nvector<pair<int,int>> balanced_tree(int n)\n{\n    vector<pair<int,int>> edges;\n    queue<int> q;\n    int node = 1;\n    q.push(node++);\n    while(node <= n)\n    {\n        int cur = q.front(); q.pop();\n        if(node <= n)\n        {\n            edges.emplace_back(cur, node);\n            q.push(node++);\n        }\n        if(node <= n)\n        {\n            edges.emplace_back(cur, node);\n            q.push(node++);\n        }\n    }\n    return edges;\n}\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string h_type = opt<string>(\"h\", \"random\");\n    string s_type = opt<string>(\"s\", \"random\");\n\n    int hmin = opt<int>(\"hmin\", 1);\n    int hmax = opt<int>(\"hmax\", 1000000000);\n\n    int smin = opt<int>(\"smin\", 1);\n    int smax = opt<int>(\"smax\", 1000000000);\n\n    int h0 = opt<int>(\"h0\", hmin);\n    int s0 = opt<int>(\"s0\", smin);\n\n    vector<pair<int,int>> edges;\n\n    if(tree_type == \"random\")\n        edges = random_tree(n);\n    else if(tree_type == \"chain\")\n        edges = chain_tree(n);\n    else if(tree_type == \"star\")\n        edges = star_tree(n);\n    else if(tree_type == \"balanced\")\n        edges = balanced_tree(n);\n    else\n    {\n        // default to random tree\n        edges = random_tree(n);\n    }\n\n    // Generate h_i\n    vector<int> h(n+1);\n\n    if(h_type == \"constant\")\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = h0;\n    }\n    else if(h_type == \"random\")\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = rnd.next(hmin, hmax);\n    }\n    else if(h_type == \"increasing\")\n    {\n        int delta = (hmax - hmin) / n + 1;\n        h[1] = hmin;\n        for(int i=2;i<=n;++i)\n            h[i] = h[i-1] + delta;\n    }\n    else if(h_type == \"decreasing\")\n    {\n        int delta = (hmax - hmin) / n + 1;\n        h[n] = hmin;\n        for(int i=n-1;i>=1;--i)\n            h[i] = h[i+1] + delta;\n    }\n    else if(h_type == \"minmax\")\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = (i%2 == 0) ? hmin : hmax;\n    }\n    else\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = rnd.next(hmin, hmax);\n    }\n\n    // Generate s_j\n    vector<int> s(k);\n    if(s_type == \"constant\")\n    {\n        for(int i=0;i<k;++i)\n            s[i] = s0;\n    }\n    else if(s_type == \"random\")\n    {\n        for(int i=0;i<k;++i)\n            s[i] = rnd.next(smin, smax);\n    }\n    else if(s_type == \"increasing\")\n    {\n        int delta = (smax - smin) / k + 1;\n        s[0] = smin;\n        for(int i=1;i<k;++i)\n            s[i] = s[i-1] + delta;\n    }\n    else if(s_type == \"decreasing\")\n    {\n        int delta = (smax - smin) / k + 1;\n        s[k-1] = smin;\n        for(int i=k-2;i>=0;--i)\n            s[i] = s[i+1] + delta;\n    }\n    else if(s_type == \"minmax\")\n    {\n        for(int i=0;i<k;++i)\n            s[i] = (i%2 == 0) ? smin : smax;\n    }\n    else\n    {\n        for(int i=0;i<k;++i)\n            s[i] = rnd.next(smin, smax);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h_i\n    for(int i=1;i<=n;++i)\n    {\n        printf(\"%d%c\", h[i], i==n?'\\n':' ');\n    }\n    // Output edges\n    for(auto &e : edges)\n    {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output k\n    printf(\"%d\\n\", k);\n    // Output s_j\n    for(int i=0;i<k;++i)\n    {\n        printf(\"%d%c\", s[i], i==k-1?'\\n':' ');\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector<pair<int,int>> random_tree(int n)\n{\n    vector<int> p(n);\n    for(int i=1;i<n;++i)\n    {\n        p[i] = rnd.next(i); // parent of i is some node before i\n    }\n    vector<pair<int,int>> edges;\n    for(int i=1;i<n;++i)\n    {\n        edges.emplace_back(i+1, p[i]+1);\n    }\n    shuffle(edges.begin(), edges.end());\n    return edges;\n}\n\nvector<pair<int,int>> chain_tree(int n)\n{\n    vector<pair<int,int>> edges;\n    for(int i=1;i<n;++i)\n    {\n        edges.emplace_back(i, i+1);\n    }\n    return edges;\n}\n\nvector<pair<int,int>> star_tree(int n)\n{\n    vector<pair<int,int>> edges;\n    for(int i=2;i<=n;++i)\n    {\n        edges.emplace_back(1, i);\n    }\n    return edges;\n}\n\nvector<pair<int,int>> balanced_tree(int n)\n{\n    vector<pair<int,int>> edges;\n    queue<int> q;\n    int node = 1;\n    q.push(node++);\n    while(node <= n)\n    {\n        int cur = q.front(); q.pop();\n        if(node <= n)\n        {\n            edges.emplace_back(cur, node);\n            q.push(node++);\n        }\n        if(node <= n)\n        {\n            edges.emplace_back(cur, node);\n            q.push(node++);\n        }\n    }\n    return edges;\n}\n\nint main(int argc, char* argv[]) \n{\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\");\n    int k = opt<int>(\"k\");\n    string tree_type = opt<string>(\"tree\", \"random\");\n    string h_type = opt<string>(\"h\", \"random\");\n    string s_type = opt<string>(\"s\", \"random\");\n\n    int hmin = opt<int>(\"hmin\", 1);\n    int hmax = opt<int>(\"hmax\", 1000000000);\n\n    int smin = opt<int>(\"smin\", 1);\n    int smax = opt<int>(\"smax\", 1000000000);\n\n    int h0 = opt<int>(\"h0\", hmin);\n    int s0 = opt<int>(\"s0\", smin);\n\n    vector<pair<int,int>> edges;\n\n    if(tree_type == \"random\")\n        edges = random_tree(n);\n    else if(tree_type == \"chain\")\n        edges = chain_tree(n);\n    else if(tree_type == \"star\")\n        edges = star_tree(n);\n    else if(tree_type == \"balanced\")\n        edges = balanced_tree(n);\n    else\n    {\n        // default to random tree\n        edges = random_tree(n);\n    }\n\n    // Generate h_i\n    vector<int> h(n+1);\n\n    if(h_type == \"constant\")\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = h0;\n    }\n    else if(h_type == \"random\")\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = rnd.next(hmin, hmax);\n    }\n    else if(h_type == \"increasing\")\n    {\n        int delta = (hmax - hmin) / n + 1;\n        h[1] = hmin;\n        for(int i=2;i<=n;++i)\n            h[i] = h[i-1] + delta;\n    }\n    else if(h_type == \"decreasing\")\n    {\n        int delta = (hmax - hmin) / n + 1;\n        h[n] = hmin;\n        for(int i=n-1;i>=1;--i)\n            h[i] = h[i+1] + delta;\n    }\n    else if(h_type == \"minmax\")\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = (i%2 == 0) ? hmin : hmax;\n    }\n    else\n    {\n        for(int i=1;i<=n;++i)\n            h[i] = rnd.next(hmin, hmax);\n    }\n\n    // Generate s_j\n    vector<int> s(k);\n    if(s_type == \"constant\")\n    {\n        for(int i=0;i<k;++i)\n            s[i] = s0;\n    }\n    else if(s_type == \"random\")\n    {\n        for(int i=0;i<k;++i)\n            s[i] = rnd.next(smin, smax);\n    }\n    else if(s_type == \"increasing\")\n    {\n        int delta = (smax - smin) / k + 1;\n        s[0] = smin;\n        for(int i=1;i<k;++i)\n            s[i] = s[i-1] + delta;\n    }\n    else if(s_type == \"decreasing\")\n    {\n        int delta = (smax - smin) / k + 1;\n        s[k-1] = smin;\n        for(int i=k-2;i>=0;--i)\n            s[i] = s[i+1] + delta;\n    }\n    else if(s_type == \"minmax\")\n    {\n        for(int i=0;i<k;++i)\n            s[i] = (i%2 == 0) ? smin : smax;\n    }\n    else\n    {\n        for(int i=0;i<k;++i)\n            s[i] = rnd.next(smin, smax);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output h_i\n    for(int i=1;i<=n;++i)\n    {\n        printf(\"%d%c\", h[i], i==n?'\\n':' ');\n    }\n    // Output edges\n    for(auto &e : edges)\n    {\n        printf(\"%d %d\\n\", e.first, e.second);\n    }\n    // Output k\n    printf(\"%d\\n\", k);\n    // Output s_j\n    for(int i=0;i<k;++i)\n    {\n        printf(\"%d%c\", s[i], i==k-1?'\\n':' ');\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -k 1 -tree random -h constant -h0 5 -s constant -s0 5\n./gen -n 10 -k 5 -tree chain -h increasing -hmin 1 -hmax 10 -s increasing -smin 1 -smax 10\n./gen -n 100 -k 50 -tree star -h decreasing -hmin 1 -hmax 1000 -s decreasing -smin 1 -smax 1000\n./gen -n 1000 -k 1000 -tree random -h random -hmin 1 -hmax 1000000000 -s random -smin 1 -smax 1000000000\n./gen -n 100000 -k 50000 -tree balanced -h constant -h0 1000000000 -s constant -s0 1000000000\n./gen -n 500000 -k 1 -tree chain -h constant -h0 1 -s constant -s0 1000000000\n./gen -n 500000 -k 500000 -tree random -h minmax -hmin 1 -hmax 1000000000 -s minmax -smin 1 -smax 1000000000\n./gen -n 500000 -k 500000 -tree star -h minmax -hmin 1 -hmax 1000000000 -s minmax -smin 1 -smax 1000000000\n./gen -n 10 -k 0 -tree random -h random -hmin 1 -hmax 100 -s random -smin 1 -smax 100\n./gen -n 500000 -k 500000 -tree random -h random -hmin 1 -hmax 10 -s random -smin 1 -smax 10\n./gen -n 50000 -k 50000 -tree balanced -h decreasing -hmin 1 -hmax 1000000000 -s decreasing -smin 1 -smax 1000000000\n./gen -n 17 -k 13 -tree chain -h random -hmin 1 -hmax 100 -s random -smin 1 -smax 100\n./gen -n 1000 -k 1 -tree balanced -h constant -h0 1000000000 -s constant -s0 1\n./gen -n 100000 -k 1 -tree chain -h constant -h0 1 -s constant -s0 1000000000\n./gen -n 500000 -k 1 -tree random -h constant -h0 1 -s constant -s0 1000000000\n./gen -n 500000 -k 500000 -tree star -h constant -h0 1000000000 -s constant -s0 1000000000\n./gen -n 500000 -k 500000 -tree star -h constant -h0 1 -s constant -s0 1\n./gen -n 500000 -k 500000 -tree balanced -h minmax -hmin 1 -hmax 1000000000 -s minmax -smin 1 -smax 1000000000\n./gen -n 500000 -k 500000 -tree random -h constant -h0 1 -s constant -s0 1000000000\n./gen -n 3 -k 2 -tree chain -h constant -h0 4 -s constant -s0 17\n./gen -n 6 -k 6 -tree random -h random -hmin 3 -hmax 12 -s random -smin 2 -smax 11\n./gen -n 7 -k 6 -tree random -h random -hmin 1 -hmax 50 -s random -smin 3 -smax 10\n./gen -n 3 -k 2 -tree chain -h constant -h0 4 -s constant -s0 17\n./gen -n 500000 -k 500000 -tree random -h constant -h0 1 -s constant -s0 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:31.864293",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "533/B",
      "title": "B. Work Group",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of workers of the Big Software Company. Then n lines follow, describing the company employees. The i-th line contains two integers pi, ai (1 ≤ ai ≤ 105) — the number of the person who is the i-th employee's immediate superior and i-th employee's efficiency. For the director p1 =  - 1, for all other people the condition 1 ≤ pi < i is fulfilled.",
      "output_spec": "OutputPrint a single integer — the maximum possible efficiency of the workgroup.",
      "sample_tests": "ExamplesInputCopy7-1 31 21 11 44 54 35 2OutputCopy17",
      "description": "B. Work Group\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of workers of the Big Software Company. Then n lines follow, describing the company employees. The i-th line contains two integers pi, ai (1 ≤ ai ≤ 105) — the number of the person who is the i-th employee's immediate superior and i-th employee's efficiency. For the director p1 =  - 1, for all other people the condition 1 ≤ pi < i is fulfilled.\n\nOutputPrint a single integer — the maximum possible efficiency of the workgroup.\n\nInputCopy7-1 31 21 11 44 54 35 2OutputCopy17\n\nInputCopy7-1 31 21 11 44 54 35 2\n\nOutputCopy17\n\nNoteIn the sample test the most effective way is to make a workgroup from employees number 1, 2, 4, 5, 6.",
      "solutions": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces",
          "content": "This Friday, April 17th, 19:00 there will be Round 2 of VK Cup 2015! For all unofficial participants there will be an online mirror that is a usual rated div1-round. Any div1 contestant that does not participate in official Round 2 is able to compete in this mirror.Round consists of 6 problems that are shuffled randomly. There will be a smooth dynamic scoring system.Round is brought to you by Codeforces team, VK team and user Errichto, that offered his important help as a part of his donation for \"Codeforces 5 years campaign\". Significant testing effort was made by user winger.Good luck and have fun!UPD: Thanks everybody for participating! Editorial has just appeared. See you on Wild-card Round 2 and mirror of Round 3!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 728
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces",
          "content": "532A - Berland MinersWe can add n - k miners with height 0 and it won't affect answer. So we can assume that numbers of miners and caves are the same.For every cave let's define ti as maximal possible height of miner working in cave i if we wouldn't change any cave. We can calculate it from root to leaves with line ti = min(tfather, hi).Let's say we don't change anything. We will try to assign all workers if it's possible or to do the best possible assignment otherwise — the one where there are few free (not occupied) caves and they are high (value ti is big). I will say later why we want them to be high. Formal definition (you don't have to read the next paragraph):For every assignment let's sort free caves by ti. In the best assignment number of free caves is minimal possible. And for every position in such a list free cave in the best assignment has value ti not lower than in any other assignment. It can be proven that best possible assignment exists (it's not so obvious though).How to find the best possible assignment? Let's sort caves ascending by ti and for every cave let's assign the tallest free miner who can work here. It will give us the best possibble assignment. Why? Let's say we've just made first bad decision (different than in the best assignment). It doesn't make sense to leave a cave empty if we can assign here someone. So we put a worker somewhere and we won't be able to do assignment now (we assumed that we've just made bad decision). From definition \"we put here tallest possible miner\" we know that we couldn't assign here taller guy. Maybe we want to assign here shorter miner and this \"highest possible\" goes somewhere else? But we can swap them and everything will be ok. So there remains last option: we don't want to put anyone here. But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here. To sum up, it's ok to assign highest possible free worker with iterating over caves sorted by ti. Almost the same sentences are the proof for other lemma:If we want to have few free (not assigned) miners and we want them to be short it's optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave. It works for every order of iterating over caves. And every order gives us the same set of free miners (but not necessarily the same set of free caves).Why did we want free caves to be high? Because to assign everyone we must change height of cave not higher than the lowest free cave. Why? In short: otherwise that lowest free cave will remain free after running our assignment-algo (described above) on new tree. But we managed to find maximal possible height of lowest free cave. Let's call this value as LIM. And we know minimal set of free miners.Changing height of cave i from a to something bigger does something only when ti = a ≤ LIM. And then in set of ti some changes happen. There were caves blocked before by cave i so they had t equal to a. These caves will have bigger t so in set of values t we have change e.g. from {5, 5, 5} to {7, 10, 8} (a was equal to 5). Let's throw out miners from caves with changed tc (maybe some of these caves were empty anyway). If we can't assign free miners (we found them before) to new caves then assigning everything isn't possible. Otherwise it is — we assign them in these caves with changed t and there are some threw out miners. But all of them were in caves with t = a ≤ LIM so they are not higher than LIM. And we know that every free cave has tfree ≥ LIM because LIM is height of lowest free cave. So we can put them there.Solution is to find result with binary search and to answer question: can we assign miners to caves with changing one cave by at most D? With our assignment-algo we calculate optimal lowest free cave and set of free miners. Then for every cave we try to increase its height by D if it had t not higher than LIM. It's also important that checking change of every cave has amortized linear complexity. If increasing height of cave A affects t of cave B below then later changing height of B does nothing — B is blocked by A anyway.532B - Work GroupThis problem can be solved by using dynamic programming over subtrees of company hierarchy. Denote as D[v][e] maximum possible efficiency that can be obtained by taking several people from subtree of v so that pairity of their number is e in order condition from statement is fullfilled for all already taken people. Then it is easy to calculate D[v][e] from values of children of v by considering intermediate value T[i][e] — maximum possible efficiency that we can obtain by using first i subtrees of v with overall pairity e.It's important to not to forget that there are two cases: we may take v itself or we may decide to not take it. In first case it is important that all subtrees have overall even number of taken people. In the second case there is no such restriction.532C - Board GameWe will consider three cases:1) xp + yp ≤ max(xv, yv). In this case Polycarp can be in (0, 0) after xp + yp moves and Vasiliy will always be ,,behind''. It's enough for Polycarp to make any move and he is always able to do it. It makes Polycarp closer to (0, 0) and after Vasiliy's move we again have xp + yp ≤ max(xv, yv) condition fulfilled and in some moment Polycarp will reach (0, 0). It's impossible that Vasiliy wins because our condition would be unfulfilled.2) xp ≤ xv, yp ≤ yv. In this scenario Polycarp must block Vasiliy somehow. He must make such a move that after any Vasiliy's response condition will be fulfilled again. If xp = xv > 0 he goes to (xp - 1, yp). If yp = yv > 0 he goes to (xp, yp - 1). Otherwise he makes any move. With this strategy Vasiliy is unable to get out of our new condition.3) Otherwise we can consider any shortest path to (0, 0) for Vasiliy. Lenght of it is max(xv, yv). For any cell on this path Polycarp has greater distance than Vasiliy to it so he can't be there before Vasiliy and he can't block him. Vasiliy wins. Alternative explanation: after any possible Polycarp move Vasiliy can make a move that none of conditions (1) and (2) aren't fulfilled.532D - LandmarksFirst observation: column crashes only if distance between its neighbours is greater than 2di so it doesn't matter where exactly is this column. The only important thing is how far are left and right neighbour of it.For every column C let's calculate does there exist subset of columns on the left that everything is stable between C and leftmost bearing column. If answer is yes then how close can be left neighbour of C? Then we will know how far the right neighbour can be. We will use dynamic programming.Slow approach: For every previous column let's check if it can be neighbours with C. The closest column fulfilling this condition is best left neighbour of C.Faster approach: Let's denote far[i] as the biggest possible coordinate where right neighbour of column i can be. In our dp we need an extra stack with possible candidates for being left neighbour of new column. In this stack columns are sorted in ascending order by index (and coordinate) and in descending order by far[i]. For every new column we must remove from the top of stack columns which have too low far[i]. Then last column on stack is the best left neighbour and we can calculate value far for current column. It is O(n) algorithm.Some columns can't be connected with leftmost bearing column and for them we have far[i] = 0. If there exists column with far[i] not less than coordinate of rightmost bearing column then we don't have to add new column and answer is 0.Ok. Now let's run the same dp from right to the left. Some columns are connected with leftmost bearing column, some other columns with righmost one. And we will want to place new column somewhere between them. Brute force solution is to check every pair of columns and to say: we want these two columns to be neighbours of added column. With values far[i] calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns.How to make this last part faster? We must create two stacks with best candidates for neighbours of new column. One stack with columns connected to the leftmost column, one with the ones connected to the rightmost one. On these stacks we can find answer with two pointers technique.Whole solution is linear in time and memory.532E - Correcting MistakesSuppose that S is obtained from W by deleteing the earlier symbol than T. Then it is true that W = A + x + B + y + C, S = A + x + B + C, T = A + B + y + C, where x and y are deleted symbols and A, B и C are some (possibly, empty) strings.Let's calculate A as a longest common prefix of S and T and C as a longest common suffix. Remove both of them from strings. Now we now that x and y are respectively the first letter of string S and last letter of string T. Remove them too. The only thing left is to check if remaining parts of strings are equal.Perform such operation for S and T and for T and S.532F - EncodingThere are two possible ideas for solving this task.Fix pair of letters x and y. Replace all letters x in S with 1s and all remaining letters with 0s. Do the same for y with string T. By using KMP algorithm or Z-function determine all positions where string T can be attached to string S so there is a match. If such condition is fullfilled for pair (x, y), and for pair (y, x) then this position is a possible match position if we use pair (x, y) and possibly some other pairs.Now for each suitable position we need to check if letters can be distributed in pairs according to the information we know. This can be done in O(sigma) where sigma = 26 — the size of the alphabet. So, this solution works in O(n * sigma2 + n * sigma) = O(n * sigma2). It fits in time limit if implementation is efficient enough.Another way is to perform such transformation with both strings that allows us to compare them up to letters renaming. Let's replace each letter with distance from it to the closes letter to the left from it that is the same (or with -inf if there is no such letter). Now for strings to be equal we just need to check that string T matches the substring of S in all positions except, possibly, first occurence of each letter in T. This can be done by modified prefix-function or by hashing.Now suppose we know that in some position string T is the same as string S up to renaming letters. It's not hard to determine the letter permutation for this renaming (by just checking what matches in S with first occurence of each letter in string T). Let's check that this permutation is a set of transpositions in O(sigma). So, we have a solution in O(n * sigma).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10741
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces - Code 1",
          "code": "s[i+1]==t[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int64_t n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int64_t i = 1; i <= n; ++i) {\n        int64_t pi = inf.readInt();\n        inf.readSpace();\n        int64_t ai = inf.readInt(1, 100000, \"ai\");\n        inf.readEoln();\n        if (i == 1) {\n            ensuref(pi == -1, \"For first employee, pi must be -1 but read %lld\", pi);\n        } else {\n            ensuref(pi >= 1 && pi < i, \"For employee %lld, pi must be between 1 and %lld, but read %lld\", i, i - 1, pi);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int64_t n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int64_t i = 1; i <= n; ++i) {\n        int64_t pi = inf.readInt();\n        inf.readSpace();\n        int64_t ai = inf.readInt(1, 100000, \"ai\");\n        inf.readEoln();\n        if (i == 1) {\n            ensuref(pi == -1, \"For first employee, pi must be -1 but read %lld\", pi);\n        } else {\n            ensuref(pi >= 1 && pi < i, \"For employee %lld, pi must be between 1 and %lld, but read %lld\", i, i - 1, pi);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int64_t n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int64_t i = 1; i <= n; ++i) {\n        int64_t pi = inf.readInt();\n        inf.readSpace();\n        int64_t ai = inf.readInt(1, 100000, \"ai\");\n        inf.readEoln();\n        if (i == 1) {\n            ensuref(pi == -1, \"For first employee, pi must be -1 but read %lld\", pi);\n        } else {\n            ensuref(pi >= 1 && pi < i, \"For employee %lld, pi must be between 1 and %lld, but read %lld\", i, i - 1, pi);\n        }\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string efficiency_type = opt<string>(\"efficiency_type\", \"random\");\n    int efficiency_value = opt<int>(\"efficiency_value\", 1); // default value if needed\n\n    vector<int> parent(n + 1); \n    vector<int> efficiency(n + 1);\n\n    // Generate tree according to tree_type\n    if (tree_type == \"chain\") {\n        // Chain tree: each node (after the root) has parent i - 1\n        parent[1] = -1; // Director\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree: all nodes are direct subordinates of the director\n        parent[1] = -1;\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (tree_type == \"binary\") {\n        // Balanced binary tree\n        parent[1] = -1;\n        queue<int> q;\n        q.push(1);\n        int idx = 2;\n        while (idx <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            // Left child\n            if (idx <= n) {\n                parent[idx] = u;\n                q.push(idx);\n                idx++;\n            }\n            // Right child\n            if (idx <= n) {\n                parent[idx] = u;\n                q.push(idx);\n                idx++;\n            }\n        }\n    } else {\n        // Random tree\n        parent[1] = -1;\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Generate efficiencies according to efficiency_type\n    if (efficiency_type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = rnd.next(1, 100000);\n        }\n    } else if (efficiency_type == \"constant\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = efficiency_value;\n        }\n    } else if (efficiency_type == \"increasing\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = i;\n        }\n    } else if (efficiency_type == \"decreasing\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = n - i + 1;\n        }\n    } else if (efficiency_type == \"max\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = 100000;\n        }\n    } else if (efficiency_type == \"min\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        if (parent[i] == -1) {\n            printf(\"-1 %d\\n\", efficiency[i]);\n        } else {\n            printf(\"%d %d\\n\", parent[i], efficiency[i]);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string tree_type = opt<string>(\"tree_type\", \"random\");\n    string efficiency_type = opt<string>(\"efficiency_type\", \"random\");\n    int efficiency_value = opt<int>(\"efficiency_value\", 1); // default value if needed\n\n    vector<int> parent(n + 1); \n    vector<int> efficiency(n + 1);\n\n    // Generate tree according to tree_type\n    if (tree_type == \"chain\") {\n        // Chain tree: each node (after the root) has parent i - 1\n        parent[1] = -1; // Director\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = i - 1;\n        }\n    } else if (tree_type == \"star\") {\n        // Star tree: all nodes are direct subordinates of the director\n        parent[1] = -1;\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = 1;\n        }\n    } else if (tree_type == \"binary\") {\n        // Balanced binary tree\n        parent[1] = -1;\n        queue<int> q;\n        q.push(1);\n        int idx = 2;\n        while (idx <= n && !q.empty()) {\n            int u = q.front(); q.pop();\n            // Left child\n            if (idx <= n) {\n                parent[idx] = u;\n                q.push(idx);\n                idx++;\n            }\n            // Right child\n            if (idx <= n) {\n                parent[idx] = u;\n                q.push(idx);\n                idx++;\n            }\n        }\n    } else {\n        // Random tree\n        parent[1] = -1;\n        for (int i = 2; i <= n; ++i) {\n            parent[i] = rnd.next(1, i - 1);\n        }\n    }\n\n    // Generate efficiencies according to efficiency_type\n    if (efficiency_type == \"random\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = rnd.next(1, 100000);\n        }\n    } else if (efficiency_type == \"constant\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = efficiency_value;\n        }\n    } else if (efficiency_type == \"increasing\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = i;\n        }\n    } else if (efficiency_type == \"decreasing\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = n - i + 1;\n        }\n    } else if (efficiency_type == \"max\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = 100000;\n        }\n    } else if (efficiency_type == \"min\") {\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = 1;\n        }\n    } else {\n        // Default to random\n        for (int i = 1; i <= n; ++i) {\n            efficiency[i] = rnd.next(1, 100000);\n        }\n    }\n\n    // Output\n    printf(\"%d\\n\", n);\n    for (int i = 1; i <= n; ++i) {\n        if (parent[i] == -1) {\n            printf(\"-1 %d\\n\", efficiency[i]);\n        } else {\n            printf(\"%d %d\\n\", parent[i], efficiency[i]);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -tree_type random -efficiency_type random\n./gen -n 2 -tree_type chain -efficiency_type constant -efficiency_value 1\n./gen -n 2 -tree_type star -efficiency_type constant -efficiency_value 100000\n./gen -n 10 -tree_type chain -efficiency_type increasing\n./gen -n 10 -tree_type chain -efficiency_type decreasing\n./gen -n 10 -tree_type star -efficiency_type random\n./gen -n 10 -tree_type random -efficiency_type random\n./gen -n 10 -tree_type binary -efficiency_type increasing\n./gen -n 10 -tree_type binary -efficiency_type decreasing\n\n./gen -n 100 -tree_type chain -efficiency_type constant -efficiency_value 1\n./gen -n 100 -tree_type chain -efficiency_type constant -efficiency_value 100000\n./gen -n 100 -tree_type star -efficiency_type random\n./gen -n 100 -tree_type random -efficiency_type random\n./gen -n 100 -tree_type binary -efficiency_type random\n\n./gen -n 1000 -tree_type chain -efficiency_type random\n./gen -n 1000 -tree_type star -efficiency_type random\n./gen -n 1000 -tree_type random -efficiency_type increasing\n./gen -n 1000 -tree_type random -efficiency_type decreasing\n./gen -n 1000 -tree_type binary -efficiency_type random\n\n./gen -n 10000 -tree_type random -efficiency_type random\n./gen -n 10000 -tree_type chain -efficiency_type random\n./gen -n 10000 -tree_type star -efficiency_type random\n./gen -n 10000 -tree_type binary -efficiency_type random\n\n./gen -n 100000 -tree_type random -efficiency_type random\n./gen -n 100000 -tree_type chain -efficiency_type random\n./gen -n 100000 -tree_type star -efficiency_type random\n./gen -n 100000 -tree_type binary -efficiency_type random\n\n./gen -n 200000 -tree_type random -efficiency_type random\n./gen -n 200000 -tree_type chain -efficiency_type random\n./gen -n 200000 -tree_type star -efficiency_type random\n./gen -n 200000 -tree_type binary -efficiency_type random\n\n./gen -n 200000 -tree_type random -efficiency_type max\n./gen -n 200000 -tree_type random -efficiency_type min\n./gen -n 200000 -tree_type random -efficiency_type increasing\n./gen -n 200000 -tree_type random -efficiency_type decreasing\n\n# Edge cases\n./gen -n 1 -tree_type chain -efficiency_type random\n./gen -n 1 -tree_type star -efficiency_type random\n./gen -n 2 -tree_type random -efficiency_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:33.711172",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "533/C",
      "title": "C. Board Game",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains four integers: xp, yp, xv, yv (0 ≤ xp, yp, xv, yv ≤ 105) — Polycarp's and Vasiliy's starting coordinates.It is guaranteed that in the beginning the pawns are in different cells and none of them is in the cell (0, 0).",
      "output_spec": "OutputOutput the name of the winner: \"Polycarp\" or \"Vasiliy\".",
      "sample_tests": "ExamplesInputCopy2 1 2 2OutputCopyPolycarpInputCopy4 7 7 4OutputCopyVasiliy",
      "description": "C. Board Game\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains four integers: xp, yp, xv, yv (0 ≤ xp, yp, xv, yv ≤ 105) — Polycarp's and Vasiliy's starting coordinates.It is guaranteed that in the beginning the pawns are in different cells and none of them is in the cell (0, 0).\n\nOutputOutput the name of the winner: \"Polycarp\" or \"Vasiliy\".\n\nInputCopy2 1 2 2OutputCopyPolycarpInputCopy4 7 7 4OutputCopyVasiliy\n\nInputCopy2 1 2 2\n\nOutputCopyPolycarp\n\nInputCopy4 7 7 4\n\nOutputCopyVasiliy\n\nNoteIn the first sample test Polycarp starts in (2, 1) and will move to (1, 1) in the first turn. No matter what his opponent is doing, in the second turn Polycarp can move to (1, 0) and finally to (0, 0) in the third turn.",
      "solutions": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces",
          "content": "This Friday, April 17th, 19:00 there will be Round 2 of VK Cup 2015! For all unofficial participants there will be an online mirror that is a usual rated div1-round. Any div1 contestant that does not participate in official Round 2 is able to compete in this mirror.Round consists of 6 problems that are shuffled randomly. There will be a smooth dynamic scoring system.Round is brought to you by Codeforces team, VK team and user Errichto, that offered his important help as a part of his donation for \"Codeforces 5 years campaign\". Significant testing effort was made by user winger.Good luck and have fun!UPD: Thanks everybody for participating! Editorial has just appeared. See you on Wild-card Round 2 and mirror of Round 3!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 728
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces",
          "content": "532A - Berland MinersWe can add n - k miners with height 0 and it won't affect answer. So we can assume that numbers of miners and caves are the same.For every cave let's define ti as maximal possible height of miner working in cave i if we wouldn't change any cave. We can calculate it from root to leaves with line ti = min(tfather, hi).Let's say we don't change anything. We will try to assign all workers if it's possible or to do the best possible assignment otherwise — the one where there are few free (not occupied) caves and they are high (value ti is big). I will say later why we want them to be high. Formal definition (you don't have to read the next paragraph):For every assignment let's sort free caves by ti. In the best assignment number of free caves is minimal possible. And for every position in such a list free cave in the best assignment has value ti not lower than in any other assignment. It can be proven that best possible assignment exists (it's not so obvious though).How to find the best possible assignment? Let's sort caves ascending by ti and for every cave let's assign the tallest free miner who can work here. It will give us the best possibble assignment. Why? Let's say we've just made first bad decision (different than in the best assignment). It doesn't make sense to leave a cave empty if we can assign here someone. So we put a worker somewhere and we won't be able to do assignment now (we assumed that we've just made bad decision). From definition \"we put here tallest possible miner\" we know that we couldn't assign here taller guy. Maybe we want to assign here shorter miner and this \"highest possible\" goes somewhere else? But we can swap them and everything will be ok. So there remains last option: we don't want to put anyone here. But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here. To sum up, it's ok to assign highest possible free worker with iterating over caves sorted by ti. Almost the same sentences are the proof for other lemma:If we want to have few free (not assigned) miners and we want them to be short it's optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave. It works for every order of iterating over caves. And every order gives us the same set of free miners (but not necessarily the same set of free caves).Why did we want free caves to be high? Because to assign everyone we must change height of cave not higher than the lowest free cave. Why? In short: otherwise that lowest free cave will remain free after running our assignment-algo (described above) on new tree. But we managed to find maximal possible height of lowest free cave. Let's call this value as LIM. And we know minimal set of free miners.Changing height of cave i from a to something bigger does something only when ti = a ≤ LIM. And then in set of ti some changes happen. There were caves blocked before by cave i so they had t equal to a. These caves will have bigger t so in set of values t we have change e.g. from {5, 5, 5} to {7, 10, 8} (a was equal to 5). Let's throw out miners from caves with changed tc (maybe some of these caves were empty anyway). If we can't assign free miners (we found them before) to new caves then assigning everything isn't possible. Otherwise it is — we assign them in these caves with changed t and there are some threw out miners. But all of them were in caves with t = a ≤ LIM so they are not higher than LIM. And we know that every free cave has tfree ≥ LIM because LIM is height of lowest free cave. So we can put them there.Solution is to find result with binary search and to answer question: can we assign miners to caves with changing one cave by at most D? With our assignment-algo we calculate optimal lowest free cave and set of free miners. Then for every cave we try to increase its height by D if it had t not higher than LIM. It's also important that checking change of every cave has amortized linear complexity. If increasing height of cave A affects t of cave B below then later changing height of B does nothing — B is blocked by A anyway.532B - Work GroupThis problem can be solved by using dynamic programming over subtrees of company hierarchy. Denote as D[v][e] maximum possible efficiency that can be obtained by taking several people from subtree of v so that pairity of their number is e in order condition from statement is fullfilled for all already taken people. Then it is easy to calculate D[v][e] from values of children of v by considering intermediate value T[i][e] — maximum possible efficiency that we can obtain by using first i subtrees of v with overall pairity e.It's important to not to forget that there are two cases: we may take v itself or we may decide to not take it. In first case it is important that all subtrees have overall even number of taken people. In the second case there is no such restriction.532C - Board GameWe will consider three cases:1) xp + yp ≤ max(xv, yv). In this case Polycarp can be in (0, 0) after xp + yp moves and Vasiliy will always be ,,behind''. It's enough for Polycarp to make any move and he is always able to do it. It makes Polycarp closer to (0, 0) and after Vasiliy's move we again have xp + yp ≤ max(xv, yv) condition fulfilled and in some moment Polycarp will reach (0, 0). It's impossible that Vasiliy wins because our condition would be unfulfilled.2) xp ≤ xv, yp ≤ yv. In this scenario Polycarp must block Vasiliy somehow. He must make such a move that after any Vasiliy's response condition will be fulfilled again. If xp = xv > 0 he goes to (xp - 1, yp). If yp = yv > 0 he goes to (xp, yp - 1). Otherwise he makes any move. With this strategy Vasiliy is unable to get out of our new condition.3) Otherwise we can consider any shortest path to (0, 0) for Vasiliy. Lenght of it is max(xv, yv). For any cell on this path Polycarp has greater distance than Vasiliy to it so he can't be there before Vasiliy and he can't block him. Vasiliy wins. Alternative explanation: after any possible Polycarp move Vasiliy can make a move that none of conditions (1) and (2) aren't fulfilled.532D - LandmarksFirst observation: column crashes only if distance between its neighbours is greater than 2di so it doesn't matter where exactly is this column. The only important thing is how far are left and right neighbour of it.For every column C let's calculate does there exist subset of columns on the left that everything is stable between C and leftmost bearing column. If answer is yes then how close can be left neighbour of C? Then we will know how far the right neighbour can be. We will use dynamic programming.Slow approach: For every previous column let's check if it can be neighbours with C. The closest column fulfilling this condition is best left neighbour of C.Faster approach: Let's denote far[i] as the biggest possible coordinate where right neighbour of column i can be. In our dp we need an extra stack with possible candidates for being left neighbour of new column. In this stack columns are sorted in ascending order by index (and coordinate) and in descending order by far[i]. For every new column we must remove from the top of stack columns which have too low far[i]. Then last column on stack is the best left neighbour and we can calculate value far for current column. It is O(n) algorithm.Some columns can't be connected with leftmost bearing column and for them we have far[i] = 0. If there exists column with far[i] not less than coordinate of rightmost bearing column then we don't have to add new column and answer is 0.Ok. Now let's run the same dp from right to the left. Some columns are connected with leftmost bearing column, some other columns with righmost one. And we will want to place new column somewhere between them. Brute force solution is to check every pair of columns and to say: we want these two columns to be neighbours of added column. With values far[i] calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns.How to make this last part faster? We must create two stacks with best candidates for neighbours of new column. One stack with columns connected to the leftmost column, one with the ones connected to the rightmost one. On these stacks we can find answer with two pointers technique.Whole solution is linear in time and memory.532E - Correcting MistakesSuppose that S is obtained from W by deleteing the earlier symbol than T. Then it is true that W = A + x + B + y + C, S = A + x + B + C, T = A + B + y + C, where x and y are deleted symbols and A, B и C are some (possibly, empty) strings.Let's calculate A as a longest common prefix of S and T and C as a longest common suffix. Remove both of them from strings. Now we now that x and y are respectively the first letter of string S and last letter of string T. Remove them too. The only thing left is to check if remaining parts of strings are equal.Perform such operation for S and T and for T and S.532F - EncodingThere are two possible ideas for solving this task.Fix pair of letters x and y. Replace all letters x in S with 1s and all remaining letters with 0s. Do the same for y with string T. By using KMP algorithm or Z-function determine all positions where string T can be attached to string S so there is a match. If such condition is fullfilled for pair (x, y), and for pair (y, x) then this position is a possible match position if we use pair (x, y) and possibly some other pairs.Now for each suitable position we need to check if letters can be distributed in pairs according to the information we know. This can be done in O(sigma) where sigma = 26 — the size of the alphabet. So, this solution works in O(n * sigma2 + n * sigma) = O(n * sigma2). It fits in time limit if implementation is efficient enough.Another way is to perform such transformation with both strings that allows us to compare them up to letters renaming. Let's replace each letter with distance from it to the closes letter to the left from it that is the same (or with -inf if there is no such letter). Now for strings to be equal we just need to check that string T matches the substring of S in all positions except, possibly, first occurence of each letter in T. This can be done by modified prefix-function or by hashing.Now suppose we know that in some position string T is the same as string S up to renaming letters. It's not hard to determine the letter permutation for this renaming (by just checking what matches in S with first occurence of each letter in string T). Let's check that this permutation is a set of transpositions in O(sigma). So, we have a solution in O(n * sigma).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10741
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces - Code 1",
          "code": "s[i+1]==t[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> values = inf.readInts(4, 0, 100000, \"coordinates\");\n    inf.readEoln();\n    inf.readEof();\n\n    int xp = values[0];\n    int yp = values[1];\n    int xv = values[2];\n    int yv = values[3];\n\n    ensuref(!(xp == xv && yp == yv), \"Starting positions must be different\");\n    ensuref(!(xp == 0 && yp == 0), \"Polycarp's pawn cannot start at (0,0)\");\n    ensuref(!(xv == 0 && yv == 0), \"Vasiliy's pawn cannot start at (0,0)\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> values = inf.readInts(4, 0, 100000, \"coordinates\");\n    inf.readEoln();\n    inf.readEof();\n\n    int xp = values[0];\n    int yp = values[1];\n    int xv = values[2];\n    int yv = values[3];\n\n    ensuref(!(xp == xv && yp == yv), \"Starting positions must be different\");\n    ensuref(!(xp == 0 && yp == 0), \"Polycarp's pawn cannot start at (0,0)\");\n    ensuref(!(xv == 0 && yv == 0), \"Vasiliy's pawn cannot start at (0,0)\");\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    vector<int> values = inf.readInts(4, 0, 100000, \"coordinates\");\n    inf.readEoln();\n    inf.readEof();\n\n    int xp = values[0];\n    int yp = values[1];\n    int xv = values[2];\n    int yv = values[3];\n\n    ensuref(!(xp == xv && yp == yv), \"Starting positions must be different\");\n    ensuref(!(xp == 0 && yp == 0), \"Polycarp's pawn cannot start at (0,0)\");\n    ensuref(!(xv == 0 && yv == 0), \"Vasiliy's pawn cannot start at (0,0)\");\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_n = opt<int>(\"max_n\"); // maximum coordinate value\n    string type = opt<string>(\"type\", \"random\");\n\n    int xp, yp, xv, yv;\n\n    if (type == \"polycarp_wins\") {\n        // Generate positions such that max(xp, yp) ≤ min(xv, yv)\n        do {\n            xp = rnd.next(1, max_n); // avoid (0,0)\n            yp = rnd.next(0, xp); // so max(xp, yp) = xp\n            xv = rnd.next(xp, max_n);\n            yv = rnd.next(xp, max_n); // min(xv, yv) ≥ xp\n            // Ensure starting positions are different and none at (0,0)\n        } while ( (max(xp, yp) > min(xv, yv)) || (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else if (type == \"vasiliy_wins\") {\n        // Generate positions such that max(xp, yp) > min(xv, yv)\n        do {\n            xp = rnd.next(0, max_n);\n            yp = rnd.next(0, max_n);\n            xv = rnd.next(0, max_n);\n            yv = rnd.next(0, max_n);\n            // Ensure positions satisfy the condition and constraints\n        } while ( !(max(xp, yp) > min(xv, yv)) || (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else if (type == \"close_to_zero\") {\n        // Generate positions close to (0, 0)\n        do {\n            xp = rnd.next(1, 10); // avoid (0,0)\n            yp = rnd.next(1, 10);\n            xv = rnd.next(1, 10);\n            yv = rnd.next(1, 10);\n            // Ensure starting positions are different\n        } while ( (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else if (type == \"max_coordinates\") {\n        // Generate positions at maximum coordinates\n        do {\n            xp = rnd.next(max_n - 10, max_n);\n            yp = rnd.next(max_n - 10, max_n);\n            xv = rnd.next(max_n - 10, max_n);\n            yv = rnd.next(max_n - 10, max_n);\n            // Ensure starting positions are different\n        } while ( (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else {\n        // Default random positions\n        do {\n            xp = rnd.next(0, max_n);\n            yp = rnd.next(0, max_n);\n            xv = rnd.next(0, max_n);\n            yv = rnd.next(0, max_n);\n            // Ensure starting positions are different and none at (0,0)\n        } while ( (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    }\n\n    printf(\"%d %d %d %d\\n\", xp, yp, xv, yv);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int max_n = opt<int>(\"max_n\"); // maximum coordinate value\n    string type = opt<string>(\"type\", \"random\");\n\n    int xp, yp, xv, yv;\n\n    if (type == \"polycarp_wins\") {\n        // Generate positions such that max(xp, yp) ≤ min(xv, yv)\n        do {\n            xp = rnd.next(1, max_n); // avoid (0,0)\n            yp = rnd.next(0, xp); // so max(xp, yp) = xp\n            xv = rnd.next(xp, max_n);\n            yv = rnd.next(xp, max_n); // min(xv, yv) ≥ xp\n            // Ensure starting positions are different and none at (0,0)\n        } while ( (max(xp, yp) > min(xv, yv)) || (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else if (type == \"vasiliy_wins\") {\n        // Generate positions such that max(xp, yp) > min(xv, yv)\n        do {\n            xp = rnd.next(0, max_n);\n            yp = rnd.next(0, max_n);\n            xv = rnd.next(0, max_n);\n            yv = rnd.next(0, max_n);\n            // Ensure positions satisfy the condition and constraints\n        } while ( !(max(xp, yp) > min(xv, yv)) || (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else if (type == \"close_to_zero\") {\n        // Generate positions close to (0, 0)\n        do {\n            xp = rnd.next(1, 10); // avoid (0,0)\n            yp = rnd.next(1, 10);\n            xv = rnd.next(1, 10);\n            yv = rnd.next(1, 10);\n            // Ensure starting positions are different\n        } while ( (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else if (type == \"max_coordinates\") {\n        // Generate positions at maximum coordinates\n        do {\n            xp = rnd.next(max_n - 10, max_n);\n            yp = rnd.next(max_n - 10, max_n);\n            xv = rnd.next(max_n - 10, max_n);\n            yv = rnd.next(max_n - 10, max_n);\n            // Ensure starting positions are different\n        } while ( (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    } else {\n        // Default random positions\n        do {\n            xp = rnd.next(0, max_n);\n            yp = rnd.next(0, max_n);\n            xv = rnd.next(0, max_n);\n            yv = rnd.next(0, max_n);\n            // Ensure starting positions are different and none at (0,0)\n        } while ( (xp == xv && yp == yv) || (xp == 0 && yp == 0) || (xv == 0 && yv == 0) );\n    }\n\n    printf(\"%d %d %d %d\\n\", xp, yp, xv, yv);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -max_n 10 -type polycarp_wins\n./gen -max_n 10 -type vasiliy_wins\n./gen -max_n 10 -type random\n\n./gen -max_n 100 -type polycarp_wins\n./gen -max_n 100 -type vasiliy_wins\n./gen -max_n 100 -type random\n\n./gen -max_n 1000 -type polycarp_wins\n./gen -max_n 1000 -type vasiliy_wins\n./gen -max_n 1000 -type random\n\n./gen -max_n 10000 -type polycarp_wins\n./gen -max_n 10000 -type vasiliy_wins\n./gen -max_n 10000 -type random\n\n./gen -max_n 100000 -type polycarp_wins\n./gen -max_n 100000 -type vasiliy_wins\n./gen -max_n 100000 -type random\n\n./gen -max_n 10 -type close_to_zero\n./gen -max_n 100000 -type max_coordinates\n\n./gen -max_n 50000 -type polycarp_wins\n./gen -max_n 50000 -type vasiliy_wins\n./gen -max_n 50000 -type random\n\n./gen -max_n 100000 -type close_to_zero\n\n./gen -max_n 100 -type max_coordinates\n./gen -max_n 1 -type random\n\n./gen -max_n 5000 -type polycarp_wins\n./gen -max_n 5000 -type vasiliy_wins\n./gen -max_n 5000 -type random\n\n./gen -max_n 12345 -type polycarp_wins\n./gen -max_n 12345 -type vasiliy_wins\n./gen -max_n 12345 -type random\n\n./gen -max_n 99999 -type polycarp_wins\n./gen -max_n 99999 -type vasiliy_wins\n./gen -max_n 99999 -type random\n\n./gen -max_n 100000\n\n./gen -max_n 0 -type close_to_zero\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:35.327117",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "533/D",
      "title": "D. Landmarks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 105) — the number of ordinary columns.The second line contains n + 2 integers x0, x1, ..., xn, xn + 1 (x0 = 0, xi < xi + 1 for 0 ≤ i ≤ n, xn + 1 ≤ 109) — the coordinates of the columns.The third line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 109).",
      "output_spec": "OutputPrint a single number — the minimum possible durability of the column that you need to add in order to make the building stay. If you do not have to add the column, please print 0. Your answer will be checked with the relative or absolute error 10 - 4.",
      "sample_tests": "ExamplesInputCopy20 20 40 10015 40OutputCopy10InputCopy30 4 10 28 309 13 5OutputCopy0",
      "description": "D. Landmarks\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 105) — the number of ordinary columns.The second line contains n + 2 integers x0, x1, ..., xn, xn + 1 (x0 = 0, xi < xi + 1 for 0 ≤ i ≤ n, xn + 1 ≤ 109) — the coordinates of the columns.The third line contains n integers d1, d2, ..., dn (1 ≤ di ≤ 109).\n\nOutputPrint a single number — the minimum possible durability of the column that you need to add in order to make the building stay. If you do not have to add the column, please print 0. Your answer will be checked with the relative or absolute error 10 - 4.\n\nInputCopy20 20 40 10015 40OutputCopy10InputCopy30 4 10 28 309 13 5OutputCopy0\n\nInputCopy20 20 40 10015 40\n\nOutputCopy10\n\nInputCopy30 4 10 28 309 13 5\n\nOutputCopy0",
      "solutions": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces",
          "content": "This Friday, April 17th, 19:00 there will be Round 2 of VK Cup 2015! For all unofficial participants there will be an online mirror that is a usual rated div1-round. Any div1 contestant that does not participate in official Round 2 is able to compete in this mirror.Round consists of 6 problems that are shuffled randomly. There will be a smooth dynamic scoring system.Round is brought to you by Codeforces team, VK team and user Errichto, that offered his important help as a part of his donation for \"Codeforces 5 years campaign\". Significant testing effort was made by user winger.Good luck and have fun!UPD: Thanks everybody for participating! Editorial has just appeared. See you on Wild-card Round 2 and mirror of Round 3!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 728
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces",
          "content": "532A - Berland MinersWe can add n - k miners with height 0 and it won't affect answer. So we can assume that numbers of miners and caves are the same.For every cave let's define ti as maximal possible height of miner working in cave i if we wouldn't change any cave. We can calculate it from root to leaves with line ti = min(tfather, hi).Let's say we don't change anything. We will try to assign all workers if it's possible or to do the best possible assignment otherwise — the one where there are few free (not occupied) caves and they are high (value ti is big). I will say later why we want them to be high. Formal definition (you don't have to read the next paragraph):For every assignment let's sort free caves by ti. In the best assignment number of free caves is minimal possible. And for every position in such a list free cave in the best assignment has value ti not lower than in any other assignment. It can be proven that best possible assignment exists (it's not so obvious though).How to find the best possible assignment? Let's sort caves ascending by ti and for every cave let's assign the tallest free miner who can work here. It will give us the best possibble assignment. Why? Let's say we've just made first bad decision (different than in the best assignment). It doesn't make sense to leave a cave empty if we can assign here someone. So we put a worker somewhere and we won't be able to do assignment now (we assumed that we've just made bad decision). From definition \"we put here tallest possible miner\" we know that we couldn't assign here taller guy. Maybe we want to assign here shorter miner and this \"highest possible\" goes somewhere else? But we can swap them and everything will be ok. So there remains last option: we don't want to put anyone here. But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here. To sum up, it's ok to assign highest possible free worker with iterating over caves sorted by ti. Almost the same sentences are the proof for other lemma:If we want to have few free (not assigned) miners and we want them to be short it's optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave. It works for every order of iterating over caves. And every order gives us the same set of free miners (but not necessarily the same set of free caves).Why did we want free caves to be high? Because to assign everyone we must change height of cave not higher than the lowest free cave. Why? In short: otherwise that lowest free cave will remain free after running our assignment-algo (described above) on new tree. But we managed to find maximal possible height of lowest free cave. Let's call this value as LIM. And we know minimal set of free miners.Changing height of cave i from a to something bigger does something only when ti = a ≤ LIM. And then in set of ti some changes happen. There were caves blocked before by cave i so they had t equal to a. These caves will have bigger t so in set of values t we have change e.g. from {5, 5, 5} to {7, 10, 8} (a was equal to 5). Let's throw out miners from caves with changed tc (maybe some of these caves were empty anyway). If we can't assign free miners (we found them before) to new caves then assigning everything isn't possible. Otherwise it is — we assign them in these caves with changed t and there are some threw out miners. But all of them were in caves with t = a ≤ LIM so they are not higher than LIM. And we know that every free cave has tfree ≥ LIM because LIM is height of lowest free cave. So we can put them there.Solution is to find result with binary search and to answer question: can we assign miners to caves with changing one cave by at most D? With our assignment-algo we calculate optimal lowest free cave and set of free miners. Then for every cave we try to increase its height by D if it had t not higher than LIM. It's also important that checking change of every cave has amortized linear complexity. If increasing height of cave A affects t of cave B below then later changing height of B does nothing — B is blocked by A anyway.532B - Work GroupThis problem can be solved by using dynamic programming over subtrees of company hierarchy. Denote as D[v][e] maximum possible efficiency that can be obtained by taking several people from subtree of v so that pairity of their number is e in order condition from statement is fullfilled for all already taken people. Then it is easy to calculate D[v][e] from values of children of v by considering intermediate value T[i][e] — maximum possible efficiency that we can obtain by using first i subtrees of v with overall pairity e.It's important to not to forget that there are two cases: we may take v itself or we may decide to not take it. In first case it is important that all subtrees have overall even number of taken people. In the second case there is no such restriction.532C - Board GameWe will consider three cases:1) xp + yp ≤ max(xv, yv). In this case Polycarp can be in (0, 0) after xp + yp moves and Vasiliy will always be ,,behind''. It's enough for Polycarp to make any move and he is always able to do it. It makes Polycarp closer to (0, 0) and after Vasiliy's move we again have xp + yp ≤ max(xv, yv) condition fulfilled and in some moment Polycarp will reach (0, 0). It's impossible that Vasiliy wins because our condition would be unfulfilled.2) xp ≤ xv, yp ≤ yv. In this scenario Polycarp must block Vasiliy somehow. He must make such a move that after any Vasiliy's response condition will be fulfilled again. If xp = xv > 0 he goes to (xp - 1, yp). If yp = yv > 0 he goes to (xp, yp - 1). Otherwise he makes any move. With this strategy Vasiliy is unable to get out of our new condition.3) Otherwise we can consider any shortest path to (0, 0) for Vasiliy. Lenght of it is max(xv, yv). For any cell on this path Polycarp has greater distance than Vasiliy to it so he can't be there before Vasiliy and he can't block him. Vasiliy wins. Alternative explanation: after any possible Polycarp move Vasiliy can make a move that none of conditions (1) and (2) aren't fulfilled.532D - LandmarksFirst observation: column crashes only if distance between its neighbours is greater than 2di so it doesn't matter where exactly is this column. The only important thing is how far are left and right neighbour of it.For every column C let's calculate does there exist subset of columns on the left that everything is stable between C and leftmost bearing column. If answer is yes then how close can be left neighbour of C? Then we will know how far the right neighbour can be. We will use dynamic programming.Slow approach: For every previous column let's check if it can be neighbours with C. The closest column fulfilling this condition is best left neighbour of C.Faster approach: Let's denote far[i] as the biggest possible coordinate where right neighbour of column i can be. In our dp we need an extra stack with possible candidates for being left neighbour of new column. In this stack columns are sorted in ascending order by index (and coordinate) and in descending order by far[i]. For every new column we must remove from the top of stack columns which have too low far[i]. Then last column on stack is the best left neighbour and we can calculate value far for current column. It is O(n) algorithm.Some columns can't be connected with leftmost bearing column and for them we have far[i] = 0. If there exists column with far[i] not less than coordinate of rightmost bearing column then we don't have to add new column and answer is 0.Ok. Now let's run the same dp from right to the left. Some columns are connected with leftmost bearing column, some other columns with righmost one. And we will want to place new column somewhere between them. Brute force solution is to check every pair of columns and to say: we want these two columns to be neighbours of added column. With values far[i] calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns.How to make this last part faster? We must create two stacks with best candidates for neighbours of new column. One stack with columns connected to the leftmost column, one with the ones connected to the rightmost one. On these stacks we can find answer with two pointers technique.Whole solution is linear in time and memory.532E - Correcting MistakesSuppose that S is obtained from W by deleteing the earlier symbol than T. Then it is true that W = A + x + B + y + C, S = A + x + B + C, T = A + B + y + C, where x and y are deleted symbols and A, B и C are some (possibly, empty) strings.Let's calculate A as a longest common prefix of S and T and C as a longest common suffix. Remove both of them from strings. Now we now that x and y are respectively the first letter of string S and last letter of string T. Remove them too. The only thing left is to check if remaining parts of strings are equal.Perform such operation for S and T and for T and S.532F - EncodingThere are two possible ideas for solving this task.Fix pair of letters x and y. Replace all letters x in S with 1s and all remaining letters with 0s. Do the same for y with string T. By using KMP algorithm or Z-function determine all positions where string T can be attached to string S so there is a match. If such condition is fullfilled for pair (x, y), and for pair (y, x) then this position is a possible match position if we use pair (x, y) and possibly some other pairs.Now for each suitable position we need to check if letters can be distributed in pairs according to the information we know. This can be done in O(sigma) where sigma = 26 — the size of the alphabet. So, this solution works in O(n * sigma2 + n * sigma) = O(n * sigma2). It fits in time limit if implementation is efficient enough.Another way is to perform such transformation with both strings that allows us to compare them up to letters renaming. Let's replace each letter with distance from it to the closes letter to the left from it that is the same (or with -inf if there is no such letter). Now for strings to be equal we just need to check that string T matches the substring of S in all positions except, possibly, first occurence of each letter in T. This can be done by modified prefix-function or by hashing.Now suppose we know that in some position string T is the same as string S up to renaming letters. It's not hard to determine the letter permutation for this renaming (by just checking what matches in S with first occurence of each letter in string T). Let's check that this permutation is a set of transpositions in O(sigma). So, we have a solution in O(n * sigma).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10741
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces - Code 1",
          "code": "s[i+1]==t[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int total_x = n + 2;\n    vector<int> x = inf.readInts(total_x, 0, 1000000000, \"x\");\n    inf.readEoln();\n\n    ensuref(x[0] == 0, \"x0 must be 0\");\n\n    for (int i = 0; i < total_x - 1; ++i) {\n        ensuref(x[i] < x[i + 1], \"xi must satisfy xi < xi+1\");\n    }\n\n    ensuref(x.back() <= 1000000000, \"xn+1 must be <= 1e9\");\n\n    vector<int> d = inf.readInts(n, 1, 1000000000, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int total_x = n + 2;\n    vector<int> x = inf.readInts(total_x, 0, 1000000000, \"x\");\n    inf.readEoln();\n\n    ensuref(x[0] == 0, \"x0 must be 0\");\n\n    for (int i = 0; i < total_x - 1; ++i) {\n        ensuref(x[i] < x[i + 1], \"xi must satisfy xi < xi+1\");\n    }\n\n    ensuref(x.back() <= 1000000000, \"xn+1 must be <= 1e9\");\n\n    vector<int> d = inf.readInts(n, 1, 1000000000, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    int total_x = n + 2;\n    vector<int> x = inf.readInts(total_x, 0, 1000000000, \"x\");\n    inf.readEoln();\n\n    ensuref(x[0] == 0, \"x0 must be 0\");\n\n    for (int i = 0; i < total_x - 1; ++i) {\n        ensuref(x[i] < x[i + 1], \"xi must satisfy xi < xi+1\");\n    }\n\n    ensuref(x.back() <= 1000000000, \"xn+1 must be <= 1e9\");\n\n    vector<int> d = inf.readInts(n, 1, 1000000000, \"d\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nconst double EPS = 1E-4;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare two sequences of doubles, max absolute or relative error = %.5f\", EPS);\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    double j = 0, p = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        n++;\r\n        j = ans.readDouble();\r\n        p = ouf.readDouble();\r\n        if (!doubleCompare(j, p, EPS)) {\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%.5f', found: '%.5f', error = '%.5f'\",\r\n                  n, englishEnding(n).c_str(), j, p, doubleDelta(j, p));\r\n        }\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"found '%.5f', expected '%.5f', error '%.5f'\", p, j, doubleDelta(j, p));\r\n\r\n    quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string x_dist = opt<string>(\"x_dist\", \"random\");\n    string d_dist = opt<string>(\"d_dist\", \"random\");\n    string cluster = opt<string>(\"cluster\", \"start\"); // For clustered x_dist\n\n    vector<int> xi(n + 2);\n    vector<int> di(n);\n\n    xi[0] = 0;\n\n    if (type == \"random\") {\n        if (x_dist == \"random\") {\n            for (int i = 1; i <= n + 1; ++i) {\n                xi[i] = rnd.next(1, (int)1e9);\n            }\n            sort(xi.begin() + 1, xi.end());\n        } else if (x_dist == \"equally_spaced\") {\n            int xmax = (int)1e9;\n            int step = xmax / (n + 1);\n            for (int i = 1; i <= n + 1; ++i) {\n                xi[i] = xi[i - 1] + step;\n            }\n        } else if (x_dist == \"clustered\") {\n            if (cluster == \"start\") {\n                for (int i = 1; i <= n + 1; ++i) {\n                    xi[i] = xi[i - 1] + rnd.next(1, 10);\n                }\n            } else if (cluster == \"end\") {\n                xi[n + 1] = (int)1e9;\n                for (int i = n; i >= 1; --i) {\n                    xi[i] = xi[i + 1] - rnd.next(1, 10);\n                }\n                // Ensure xi[0] = 0 and xi[0] < xi[1]\n                if (xi[1] <= xi[0]) {\n                    xi[1] = xi[0] + 1;\n                }\n            }\n        } else {\n            // Default to random\n            for (int i = 1; i <= n + 1; ++i) {\n                xi[i] = rnd.next(1, (int)1e9);\n            }\n            sort(xi.begin() + 1, xi.end());\n        }\n\n        // Ensure xi[i-1] < xi[i]\n        for (int i = 1; i <= n + 1; ++i) {\n            if (xi[i] <= xi[i - 1]) {\n                xi[i] = xi[i - 1] + 1;\n                if (xi[i] > (int)1e9) xi[i] = (int)1e9;\n            }\n        }\n\n        if (d_dist == \"random\") {\n            for (int i = 0; i < n; ++i) {\n                di[i] = rnd.next(1, (int)1e9);\n            }\n        } else if (d_dist == \"min\") {\n            for (int i = 0; i < n; ++i) {\n                di[i] = 1;\n            }\n        } else if (d_dist == \"max\") {\n            for (int i = 0; i < n; ++i) {\n                di[i] = (int)1e9;\n            }\n        } else if (d_dist == \"same\") {\n            int d_value = opt<int>(\"d_value\", 1);\n            for (int i = 0; i < n; ++i) {\n                di[i] = d_value;\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < n; ++i) {\n                di[i] = rnd.next(1, (int)1e9);\n            }\n        }\n    }\n    else if (type == \"no_column_needed\") {\n        // The building doesn't crash without adding a column\n        xi[0] = 0;\n        for (int i = 1; i <= n + 1; ++i) {\n            xi[i] = xi[i - 1] + rnd.next(1, 10);\n        }\n        for (int i = 0; i < n; ++i) {\n            di[i] = xi[i + 2] - xi[i];\n        }\n    }\n    else if (type == \"max_required_durability\") {\n        // The added column needs maximal durability\n        xi[0] = 0;\n        xi[1] = 1;\n        xi[n] = (int)1e9 - 1;\n        xi[n + 1] = (int)1e9;\n        for (int i = 2; i < n; ++i) {\n            xi[i] = xi[i - 1] + ((xi[n] - xi[1]) / (n - 2));\n        }\n        // Set di to minimal values\n        for (int i = 0; i < n; ++i) {\n            di[i] = 1;\n        }\n    }\n    else if (type == \"rounding_test\") {\n        // Minimal required durability causes rounding errors\n        xi[0] = 0;\n        for (int i = 1; i <= n + 1; ++i) {\n            xi[i] = xi[i - 1] + rnd.next(1, 10);\n        }\n        for (int i = 0; i < n; ++i) {\n            di[i] = rnd.next(1, 10);\n        }\n    }\n    else {\n        // Default to random\n        xi[0] = 0;\n        for (int i = 1; i <= n + 1; ++i) {\n            xi[i] = rnd.next(1, (int)1e9);\n        }\n        sort(xi.begin() + 1, xi.end());\n        // Ensure xi[i-1] < xi[i]\n        for (int i = 1; i <= n + 1; ++i) {\n            if (xi[i] <= xi[i - 1]) {\n                xi[i] = xi[i - 1] + 1;\n                if (xi[i] > (int)1e9) xi[i] = (int)1e9;\n            }\n        }\n        // Generate di randomly\n        for (int i = 0; i < n; ++i) {\n            di[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi[0..n+1]\n    for (int i = 0; i <= n + 1; ++i) {\n        printf(\"%d%c\", xi[i], (i == n + 1) ? '\\n' : ' ');\n    }\n    // Output di[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n    string x_dist = opt<string>(\"x_dist\", \"random\");\n    string d_dist = opt<string>(\"d_dist\", \"random\");\n    string cluster = opt<string>(\"cluster\", \"start\"); // For clustered x_dist\n\n    vector<int> xi(n + 2);\n    vector<int> di(n);\n\n    xi[0] = 0;\n\n    if (type == \"random\") {\n        if (x_dist == \"random\") {\n            for (int i = 1; i <= n + 1; ++i) {\n                xi[i] = rnd.next(1, (int)1e9);\n            }\n            sort(xi.begin() + 1, xi.end());\n        } else if (x_dist == \"equally_spaced\") {\n            int xmax = (int)1e9;\n            int step = xmax / (n + 1);\n            for (int i = 1; i <= n + 1; ++i) {\n                xi[i] = xi[i - 1] + step;\n            }\n        } else if (x_dist == \"clustered\") {\n            if (cluster == \"start\") {\n                for (int i = 1; i <= n + 1; ++i) {\n                    xi[i] = xi[i - 1] + rnd.next(1, 10);\n                }\n            } else if (cluster == \"end\") {\n                xi[n + 1] = (int)1e9;\n                for (int i = n; i >= 1; --i) {\n                    xi[i] = xi[i + 1] - rnd.next(1, 10);\n                }\n                // Ensure xi[0] = 0 and xi[0] < xi[1]\n                if (xi[1] <= xi[0]) {\n                    xi[1] = xi[0] + 1;\n                }\n            }\n        } else {\n            // Default to random\n            for (int i = 1; i <= n + 1; ++i) {\n                xi[i] = rnd.next(1, (int)1e9);\n            }\n            sort(xi.begin() + 1, xi.end());\n        }\n\n        // Ensure xi[i-1] < xi[i]\n        for (int i = 1; i <= n + 1; ++i) {\n            if (xi[i] <= xi[i - 1]) {\n                xi[i] = xi[i - 1] + 1;\n                if (xi[i] > (int)1e9) xi[i] = (int)1e9;\n            }\n        }\n\n        if (d_dist == \"random\") {\n            for (int i = 0; i < n; ++i) {\n                di[i] = rnd.next(1, (int)1e9);\n            }\n        } else if (d_dist == \"min\") {\n            for (int i = 0; i < n; ++i) {\n                di[i] = 1;\n            }\n        } else if (d_dist == \"max\") {\n            for (int i = 0; i < n; ++i) {\n                di[i] = (int)1e9;\n            }\n        } else if (d_dist == \"same\") {\n            int d_value = opt<int>(\"d_value\", 1);\n            for (int i = 0; i < n; ++i) {\n                di[i] = d_value;\n            }\n        } else {\n            // Default to random\n            for (int i = 0; i < n; ++i) {\n                di[i] = rnd.next(1, (int)1e9);\n            }\n        }\n    }\n    else if (type == \"no_column_needed\") {\n        // The building doesn't crash without adding a column\n        xi[0] = 0;\n        for (int i = 1; i <= n + 1; ++i) {\n            xi[i] = xi[i - 1] + rnd.next(1, 10);\n        }\n        for (int i = 0; i < n; ++i) {\n            di[i] = xi[i + 2] - xi[i];\n        }\n    }\n    else if (type == \"max_required_durability\") {\n        // The added column needs maximal durability\n        xi[0] = 0;\n        xi[1] = 1;\n        xi[n] = (int)1e9 - 1;\n        xi[n + 1] = (int)1e9;\n        for (int i = 2; i < n; ++i) {\n            xi[i] = xi[i - 1] + ((xi[n] - xi[1]) / (n - 2));\n        }\n        // Set di to minimal values\n        for (int i = 0; i < n; ++i) {\n            di[i] = 1;\n        }\n    }\n    else if (type == \"rounding_test\") {\n        // Minimal required durability causes rounding errors\n        xi[0] = 0;\n        for (int i = 1; i <= n + 1; ++i) {\n            xi[i] = xi[i - 1] + rnd.next(1, 10);\n        }\n        for (int i = 0; i < n; ++i) {\n            di[i] = rnd.next(1, 10);\n        }\n    }\n    else {\n        // Default to random\n        xi[0] = 0;\n        for (int i = 1; i <= n + 1; ++i) {\n            xi[i] = rnd.next(1, (int)1e9);\n        }\n        sort(xi.begin() + 1, xi.end());\n        // Ensure xi[i-1] < xi[i]\n        for (int i = 1; i <= n + 1; ++i) {\n            if (xi[i] <= xi[i - 1]) {\n                xi[i] = xi[i - 1] + 1;\n                if (xi[i] > (int)1e9) xi[i] = (int)1e9;\n            }\n        }\n        // Generate di randomly\n        for (int i = 0; i < n; ++i) {\n            di[i] = rnd.next(1, (int)1e9);\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output xi[0..n+1]\n    for (int i = 0; i <= n + 1; ++i) {\n        printf(\"%d%c\", xi[i], (i == n + 1) ? '\\n' : ' ');\n    }\n    // Output di[0..n-1]\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", di[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type no_column_needed\n./gen -n 1 -type max_required_durability\n./gen -n 1 -type rounding_test\n\n./gen -n 2 -type random\n./gen -n 2 -type no_column_needed\n./gen -n 2 -type max_required_durability\n./gen -n 2 -type rounding_test\n\n./gen -n 10 -type random\n./gen -n 10 -type no_column_needed\n./gen -n 10 -type max_required_durability\n./gen -n 10 -type rounding_test\n\n./gen -n 100 -type random\n./gen -n 100 -type no_column_needed\n./gen -n 100 -type max_required_durability\n./gen -n 100 -type rounding_test\n\n./gen -n 1000 -type random\n./gen -n 1000 -type no_column_needed\n./gen -n 1000 -type max_required_durability\n./gen -n 1000 -type rounding_test\n\n./gen -n 10000 -type random\n./gen -n 10000 -type no_column_needed\n./gen -n 10000 -type max_required_durability\n./gen -n 10000 -type rounding_test\n\n./gen -n 100000 -type random\n./gen -n 100000 -type no_column_needed\n./gen -n 100000 -type max_required_durability\n./gen -n 100000 -type rounding_test\n\n# Additional special cases\n./gen -n 1 -type random -x_dist equally_spaced -d_dist max\n./gen -n 1 -type random -x_dist clustered -cluster start -d_dist min\n\n./gen -n 100000 -type random -x_dist equally_spaced -d_dist min\n./gen -n 100000 -type random -x_dist clustered -cluster end -d_dist max\n\n./gen -n 99999 -type random\n./gen -n 50000 -type no_column_needed\n\n./gen -n 100000 -type random -x_dist random -d_dist min\n./gen -n 100000 -type random -x_dist random -d_dist max\n\n./gen -n 1 -type random -x_dist random -d_dist min\n./gen -n 1 -type random -x_dist random -d_dist max\n\n./gen -n 1000 -type random -x_dist equally_spaced -d_dist random\n./gen -n 1000 -type random -x_dist clustered -cluster start -d_dist random\n\n./gen -n 1000 -type random -x_dist clustered -cluster end -d_dist random\n./gen -n 100000 -type random -x_dist equally_spaced -d_dist same -d_value 100000\n\n./gen -n 50000 -type random -x_dist random -d_dist same -d_value 1\n./gen -n 50000 -type random -x_dist random -d_dist same -d_value 1000000000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:37.871297",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "533/E",
      "title": "E. Correcting Mistakes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 100 000) — the length of words S and T.The second line contains word S.The third line contains word T.Words S and T consist of lowercase English letters. It is guaranteed that S and T are distinct words.",
      "output_spec": "OutputPrint a single integer — the number of distinct words W that can be transformed to S and T due to a typo.",
      "sample_tests": "ExamplesInputCopy7readingtradingOutputCopy1InputCopy5sweetsheepOutputCopy0InputCopy3toytryOutputCopy2",
      "description": "E. Correcting Mistakes\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 100 000) — the length of words S and T.The second line contains word S.The third line contains word T.Words S and T consist of lowercase English letters. It is guaranteed that S and T are distinct words.\n\nOutputPrint a single integer — the number of distinct words W that can be transformed to S and T due to a typo.\n\nInputCopy7readingtradingOutputCopy1InputCopy5sweetsheepOutputCopy0InputCopy3toytryOutputCopy2\n\nInputCopy7readingtrading\n\nOutputCopy1\n\nInputCopy5sweetsheep\n\nOutputCopy0\n\nInputCopy3toytry\n\nOutputCopy2\n\nNoteIn the first sample test the two given words could be obtained only from word \"treading\" (the deleted letters are marked in bold).In the second sample test the two given words couldn't be obtained from the same word by removing one letter.In the third sample test the two given words could be obtained from either word \"tory\" or word \"troy\".",
      "solutions": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces",
          "content": "This Friday, April 17th, 19:00 there will be Round 2 of VK Cup 2015! For all unofficial participants there will be an online mirror that is a usual rated div1-round. Any div1 contestant that does not participate in official Round 2 is able to compete in this mirror.Round consists of 6 problems that are shuffled randomly. There will be a smooth dynamic scoring system.Round is brought to you by Codeforces team, VK team and user Errichto, that offered his important help as a part of his donation for \"Codeforces 5 years campaign\". Significant testing effort was made by user winger.Good luck and have fun!UPD: Thanks everybody for participating! Editorial has just appeared. See you on Wild-card Round 2 and mirror of Round 3!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 728
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces",
          "content": "532A - Berland MinersWe can add n - k miners with height 0 and it won't affect answer. So we can assume that numbers of miners and caves are the same.For every cave let's define ti as maximal possible height of miner working in cave i if we wouldn't change any cave. We can calculate it from root to leaves with line ti = min(tfather, hi).Let's say we don't change anything. We will try to assign all workers if it's possible or to do the best possible assignment otherwise — the one where there are few free (not occupied) caves and they are high (value ti is big). I will say later why we want them to be high. Formal definition (you don't have to read the next paragraph):For every assignment let's sort free caves by ti. In the best assignment number of free caves is minimal possible. And for every position in such a list free cave in the best assignment has value ti not lower than in any other assignment. It can be proven that best possible assignment exists (it's not so obvious though).How to find the best possible assignment? Let's sort caves ascending by ti and for every cave let's assign the tallest free miner who can work here. It will give us the best possibble assignment. Why? Let's say we've just made first bad decision (different than in the best assignment). It doesn't make sense to leave a cave empty if we can assign here someone. So we put a worker somewhere and we won't be able to do assignment now (we assumed that we've just made bad decision). From definition \"we put here tallest possible miner\" we know that we couldn't assign here taller guy. Maybe we want to assign here shorter miner and this \"highest possible\" goes somewhere else? But we can swap them and everything will be ok. So there remains last option: we don't want to put anyone here. But we will have to assign our guy to some higher cave so we can leave his destiny cave empty and put him here. To sum up, it's ok to assign highest possible free worker with iterating over caves sorted by ti. Almost the same sentences are the proof for other lemma:If we want to have few free (not assigned) miners and we want them to be short it's optimal to iterate somehow over caves and to assign the tallest possible free miner in every cave. It works for every order of iterating over caves. And every order gives us the same set of free miners (but not necessarily the same set of free caves).Why did we want free caves to be high? Because to assign everyone we must change height of cave not higher than the lowest free cave. Why? In short: otherwise that lowest free cave will remain free after running our assignment-algo (described above) on new tree. But we managed to find maximal possible height of lowest free cave. Let's call this value as LIM. And we know minimal set of free miners.Changing height of cave i from a to something bigger does something only when ti = a ≤ LIM. And then in set of ti some changes happen. There were caves blocked before by cave i so they had t equal to a. These caves will have bigger t so in set of values t we have change e.g. from {5, 5, 5} to {7, 10, 8} (a was equal to 5). Let's throw out miners from caves with changed tc (maybe some of these caves were empty anyway). If we can't assign free miners (we found them before) to new caves then assigning everything isn't possible. Otherwise it is — we assign them in these caves with changed t and there are some threw out miners. But all of them were in caves with t = a ≤ LIM so they are not higher than LIM. And we know that every free cave has tfree ≥ LIM because LIM is height of lowest free cave. So we can put them there.Solution is to find result with binary search and to answer question: can we assign miners to caves with changing one cave by at most D? With our assignment-algo we calculate optimal lowest free cave and set of free miners. Then for every cave we try to increase its height by D if it had t not higher than LIM. It's also important that checking change of every cave has amortized linear complexity. If increasing height of cave A affects t of cave B below then later changing height of B does nothing — B is blocked by A anyway.532B - Work GroupThis problem can be solved by using dynamic programming over subtrees of company hierarchy. Denote as D[v][e] maximum possible efficiency that can be obtained by taking several people from subtree of v so that pairity of their number is e in order condition from statement is fullfilled for all already taken people. Then it is easy to calculate D[v][e] from values of children of v by considering intermediate value T[i][e] — maximum possible efficiency that we can obtain by using first i subtrees of v with overall pairity e.It's important to not to forget that there are two cases: we may take v itself or we may decide to not take it. In first case it is important that all subtrees have overall even number of taken people. In the second case there is no such restriction.532C - Board GameWe will consider three cases:1) xp + yp ≤ max(xv, yv). In this case Polycarp can be in (0, 0) after xp + yp moves and Vasiliy will always be ,,behind''. It's enough for Polycarp to make any move and he is always able to do it. It makes Polycarp closer to (0, 0) and after Vasiliy's move we again have xp + yp ≤ max(xv, yv) condition fulfilled and in some moment Polycarp will reach (0, 0). It's impossible that Vasiliy wins because our condition would be unfulfilled.2) xp ≤ xv, yp ≤ yv. In this scenario Polycarp must block Vasiliy somehow. He must make such a move that after any Vasiliy's response condition will be fulfilled again. If xp = xv > 0 he goes to (xp - 1, yp). If yp = yv > 0 he goes to (xp, yp - 1). Otherwise he makes any move. With this strategy Vasiliy is unable to get out of our new condition.3) Otherwise we can consider any shortest path to (0, 0) for Vasiliy. Lenght of it is max(xv, yv). For any cell on this path Polycarp has greater distance than Vasiliy to it so he can't be there before Vasiliy and he can't block him. Vasiliy wins. Alternative explanation: after any possible Polycarp move Vasiliy can make a move that none of conditions (1) and (2) aren't fulfilled.532D - LandmarksFirst observation: column crashes only if distance between its neighbours is greater than 2di so it doesn't matter where exactly is this column. The only important thing is how far are left and right neighbour of it.For every column C let's calculate does there exist subset of columns on the left that everything is stable between C and leftmost bearing column. If answer is yes then how close can be left neighbour of C? Then we will know how far the right neighbour can be. We will use dynamic programming.Slow approach: For every previous column let's check if it can be neighbours with C. The closest column fulfilling this condition is best left neighbour of C.Faster approach: Let's denote far[i] as the biggest possible coordinate where right neighbour of column i can be. In our dp we need an extra stack with possible candidates for being left neighbour of new column. In this stack columns are sorted in ascending order by index (and coordinate) and in descending order by far[i]. For every new column we must remove from the top of stack columns which have too low far[i]. Then last column on stack is the best left neighbour and we can calculate value far for current column. It is O(n) algorithm.Some columns can't be connected with leftmost bearing column and for them we have far[i] = 0. If there exists column with far[i] not less than coordinate of rightmost bearing column then we don't have to add new column and answer is 0.Ok. Now let's run the same dp from right to the left. Some columns are connected with leftmost bearing column, some other columns with righmost one. And we will want to place new column somewhere between them. Brute force solution is to check every pair of columns and to say: we want these two columns to be neighbours of added column. With values far[i] calculated in dp we check if we can have such a situation and we eventually consider result to be half of a distance between these two columns.How to make this last part faster? We must create two stacks with best candidates for neighbours of new column. One stack with columns connected to the leftmost column, one with the ones connected to the rightmost one. On these stacks we can find answer with two pointers technique.Whole solution is linear in time and memory.532E - Correcting MistakesSuppose that S is obtained from W by deleteing the earlier symbol than T. Then it is true that W = A + x + B + y + C, S = A + x + B + C, T = A + B + y + C, where x and y are deleted symbols and A, B и C are some (possibly, empty) strings.Let's calculate A as a longest common prefix of S and T and C as a longest common suffix. Remove both of them from strings. Now we now that x and y are respectively the first letter of string S and last letter of string T. Remove them too. The only thing left is to check if remaining parts of strings are equal.Perform such operation for S and T and for T and S.532F - EncodingThere are two possible ideas for solving this task.Fix pair of letters x and y. Replace all letters x in S with 1s and all remaining letters with 0s. Do the same for y with string T. By using KMP algorithm or Z-function determine all positions where string T can be attached to string S so there is a match. If such condition is fullfilled for pair (x, y), and for pair (y, x) then this position is a possible match position if we use pair (x, y) and possibly some other pairs.Now for each suitable position we need to check if letters can be distributed in pairs according to the information we know. This can be done in O(sigma) where sigma = 26 — the size of the alphabet. So, this solution works in O(n * sigma2 + n * sigma) = O(n * sigma2). It fits in time limit if implementation is efficient enough.Another way is to perform such transformation with both strings that allows us to compare them up to letters renaming. Let's replace each letter with distance from it to the closes letter to the left from it that is the same (or with -inf if there is no such letter). Now for strings to be equal we just need to check that string T matches the substring of S in all positions except, possibly, first occurence of each letter in T. This can be done by modified prefix-function or by hashing.Now suppose we know that in some position string T is the same as string S up to renaming letters. It's not hard to determine the letter permutation for this renaming (by just checking what matches in S with first occurence of each letter in string T). Let's check that this permutation is a set of transpositions in O(sigma). So, we have a solution in O(n * sigma).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 10741
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 2 online mirror - Codeforces - Code 1",
          "code": "s[i+1]==t[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string S = inf.readLine(\"[a-z]+\", \"S\");\n    ensuref(int(S.length()) == n, \"Length of S is %d, expected %d\", int(S.length()), n);\n\n    string T = inf.readLine(\"[a-z]+\", \"T\");\n    ensuref(int(T.length()) == n, \"Length of T is %d, expected %d\", int(T.length()), n);\n\n    ensuref(S != T, \"S and T should be different words\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string S = inf.readLine(\"[a-z]+\", \"S\");\n    ensuref(int(S.length()) == n, \"Length of S is %d, expected %d\", int(S.length()), n);\n\n    string T = inf.readLine(\"[a-z]+\", \"T\");\n    ensuref(int(T.length()) == n, \"Length of T is %d, expected %d\", int(T.length()), n);\n\n    ensuref(S != T, \"S and T should be different words\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    \n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n\n    string S = inf.readLine(\"[a-z]+\", \"S\");\n    ensuref(int(S.length()) == n, \"Length of S is %d, expected %d\", int(S.length()), n);\n\n    string T = inf.readLine(\"[a-z]+\", \"T\");\n    ensuref(int(T.length()) == n, \"Length of T is %d, expected %d\", int(T.length()), n);\n\n    ensuref(S != T, \"S and T should be different words\");\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S, T;\n\n    if (type == \"random\") {\n        // Generate random strings S and T of length n, S != T\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += 'a' + rnd.next(26);\n        }\n        do {\n            T = \"\";\n            for (int i = 0; i < n; ++i) {\n                T += 'a' + rnd.next(26);\n            }\n        } while (S == T);\n    } else if (type == \"common_w1\") {\n        // Generate W of length n+1\n        string W = \"\";\n        for (int i = 0; i < n + 1; ++i) {\n            W += 'a' + rnd.next(26);\n        }\n        // Randomly delete different positions to get S and T\n        int pos_s = rnd.next(0, n);\n        int pos_t = rnd.next(0, n);\n        while (pos_t == pos_s)\n            pos_t = rnd.next(0, n);\n        S = W.substr(0, pos_s) + W.substr(pos_s + 1);\n        T = W.substr(0, pos_t) + W.substr(pos_t + 1);\n        // Ensure S != T\n        if (S == T) {\n            // Try again\n            for (int attempts = 0; attempts < 10 && S == T; ++attempts) {\n                W = \"\";\n                for (int i = 0; i < n + 1; ++i) {\n                    W += 'a' + rnd.next(26);\n                }\n                pos_s = rnd.next(0, n);\n                pos_t = rnd.next(0, n);\n                while (pos_t == pos_s)\n                    pos_t = rnd.next(0, n);\n                S = W.substr(0, pos_s) + W.substr(pos_s + 1);\n                T = W.substr(0, pos_t) + W.substr(pos_t + 1);\n            }\n            if (S == T) {\n                S = \"\";\n                for (int i = 0; i < n; ++i) {\n                    S += 'a' + rnd.next(26);\n                }\n                do {\n                    T = \"\";\n                    for (int i = 0; i < n; ++i) {\n                        T += 'a' + rnd.next(26);\n                    }\n                } while (S == T);\n            }\n        }\n\n    } else if (type == \"no_common_w\") {\n        // Generate S and T such that there is no W satisfying the condition\n        if (n <= 26) {\n            S = \"\";\n            T = \"\";\n            for (int i = 0; i < n; ++i) {\n                S += 'a' + i;\n                T += 'z' - i;\n            }\n        } else {\n            S = string(n, 'a');\n            T = string(n, 'b');\n        }\n\n    } else if (type == \"differ_by_one_letter\") {\n        // Generate S and T that differ by only one letter\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += 'a' + rnd.next(26);\n        }\n        T = S;\n        int pos = rnd.next(0, n - 1);\n        char c = S[pos];\n        char new_c;\n        do {\n            new_c = 'a' + rnd.next(26);\n        } while (new_c == c);\n        T[pos] = new_c;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output S and T\n    printf(\"%s\\n\", S.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S, T;\n\n    if (type == \"random\") {\n        // Generate random strings S and T of length n, S != T\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += 'a' + rnd.next(26);\n        }\n        do {\n            T = \"\";\n            for (int i = 0; i < n; ++i) {\n                T += 'a' + rnd.next(26);\n            }\n        } while (S == T);\n    } else if (type == \"common_w1\") {\n        // Generate W of length n+1\n        string W = \"\";\n        for (int i = 0; i < n + 1; ++i) {\n            W += 'a' + rnd.next(26);\n        }\n        // Randomly delete different positions to get S and T\n        int pos_s = rnd.next(0, n);\n        int pos_t = rnd.next(0, n);\n        while (pos_t == pos_s)\n            pos_t = rnd.next(0, n);\n        S = W.substr(0, pos_s) + W.substr(pos_s + 1);\n        T = W.substr(0, pos_t) + W.substr(pos_t + 1);\n        // Ensure S != T\n        if (S == T) {\n            // Try again\n            for (int attempts = 0; attempts < 10 && S == T; ++attempts) {\n                W = \"\";\n                for (int i = 0; i < n + 1; ++i) {\n                    W += 'a' + rnd.next(26);\n                }\n                pos_s = rnd.next(0, n);\n                pos_t = rnd.next(0, n);\n                while (pos_t == pos_s)\n                    pos_t = rnd.next(0, n);\n                S = W.substr(0, pos_s) + W.substr(pos_s + 1);\n                T = W.substr(0, pos_t) + W.substr(pos_t + 1);\n            }\n            if (S == T) {\n                S = \"\";\n                for (int i = 0; i < n; ++i) {\n                    S += 'a' + rnd.next(26);\n                }\n                do {\n                    T = \"\";\n                    for (int i = 0; i < n; ++i) {\n                        T += 'a' + rnd.next(26);\n                    }\n                } while (S == T);\n            }\n        }\n\n    } else if (type == \"no_common_w\") {\n        // Generate S and T such that there is no W satisfying the condition\n        if (n <= 26) {\n            S = \"\";\n            T = \"\";\n            for (int i = 0; i < n; ++i) {\n                S += 'a' + i;\n                T += 'z' - i;\n            }\n        } else {\n            S = string(n, 'a');\n            T = string(n, 'b');\n        }\n\n    } else if (type == \"differ_by_one_letter\") {\n        // Generate S and T that differ by only one letter\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += 'a' + rnd.next(26);\n        }\n        T = S;\n        int pos = rnd.next(0, n - 1);\n        char c = S[pos];\n        char new_c;\n        do {\n            new_c = 'a' + rnd.next(26);\n        } while (new_c == c);\n        T[pos] = new_c;\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output S and T\n    printf(\"%s\\n\", S.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type random\n./gen -n 1 -type common_w1\n./gen -n 1 -type no_common_w\n./gen -n 1 -type differ_by_one_letter\n\n./gen -n 2 -type random\n./gen -n 2 -type common_w1\n./gen -n 2 -type no_common_w\n./gen -n 2 -type differ_by_one_letter\n\n./gen -n 10 -type random\n./gen -n 10 -type common_w1\n./gen -n 10 -type no_common_w\n./gen -n 10 -type differ_by_one_letter\n\n./gen -n 100 -type random\n./gen -n 100 -type common_w1\n./gen -n 100 -type no_common_w\n./gen -n 100 -type differ_by_one_letter\n\n./gen -n 1000 -type random\n./gen -n 1000 -type common_w1\n./gen -n 1000 -type no_common_w\n./gen -n 1000 -type differ_by_one_letter\n\n./gen -n 10000 -type random\n./gen -n 10000 -type common_w1\n./gen -n 10000 -type no_common_w\n./gen -n 10000 -type differ_by_one_letter\n\n./gen -n 100000 -type random\n./gen -n 100000 -type common_w1\n./gen -n 100000 -type no_common_w\n./gen -n 100000 -type differ_by_one_letter\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:39.767127",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "533/F",
      "title": "F. Кодирование",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входных данных следуют два целых числа |S| и |T| (1 ≤ |T| ≤ |S| ≤ 2·105) — длины строки S и строки T соответственно.Во второй и третьей строке входных данных находятся соответственно строки S и T. Обе строки состоят только из строчных букв английского алфавита.",
      "output_spec": "Выходные данныеВыведите число k — количество подходящих позиций в строке S.В следующей строке выведите k целых чисел m1, m2, ..., mk — номера подходящих позиций в возрастающем порядке.",
      "sample_tests": "ПримерыВходные данныеСкопировать11 5abacabadabaacabaВыходные данныеСкопировать31 3 7Входные данныеСкопировать21 13paraparallelogramgramqolorreraglomВыходные данныеСкопировать15",
      "description": "F. Кодирование\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входных данных следуют два целых числа |S| и |T| (1 ≤ |T| ≤ |S| ≤ 2·105) — длины строки S и строки T соответственно.Во второй и третьей строке входных данных находятся соответственно строки S и T. Обе строки состоят только из строчных букв английского алфавита.\n\nВходные данные\n\nВыходные данныеВыведите число k — количество подходящих позиций в строке S.В следующей строке выведите k целых чисел m1, m2, ..., mk — номера подходящих позиций в возрастающем порядке.\n\nВыходные данные\n\nВходные данныеСкопировать11 5abacabadabaacabaВыходные данныеСкопировать31 3 7Входные данныеСкопировать21 13paraparallelogramgramqolorreraglomВыходные данныеСкопировать15\n\nВходные данныеСкопировать11 5abacabadabaacaba\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать31 3 7\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать21 13paraparallelogramgramqolorreraglom\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать15\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "VK Cup Round 2 + неофициальная интернет-трансляция - Codeforces",
          "content": "В пятницу, 17-го апреля, в 19:00 начнётся Раунд 2 чемпионата по программированию VK Cup 2015! Не забудьте зарегистрировать вашу команду на раунд, регистрация закроется за пять минут до его старта.В этом раунде могут принять участие все те команды, которые отобрались в Раунде 1 или в Уайлд-кард раунде 1. Напомним, что из первого раунда допущены все те команды, что набрали не менее 796 баллов. В уайлд-кард раунде было достаточно решить не менее шести задач, либо решить пять задач со штрафным временем не более 415 минут. Таким образом, принять участие в Раунде 2 могут 400 + 50 = 450 команд!Участников ждет соревнование по правилам классических раундов Codeforces. По сравнению с Раундом 1 вас ждут некоторые изменения. Во-первых, одновременно с основным раундом будет проведена интернет-трансляция, которая представляет из себя обычный рейтинговый div1-раунд по правилам Codeforces. В трансляции может участвовать любой div1-участник, не зарегистрированный на основной раунд в составе отобравшейся команды.Во-вторых, вас, как и ранее, ждёт плавная динамическая система оценки задач, но сами задачи будут расположены в случайном порядке. Участникам будет предложено 6 задач.Раунд подготовлен силами команды Codeforces, команды VK и пользователя Errichto, который предложил свою неоценимую помощь в рамках кампании \"5 лет Codeforces\". Большую помощь в тестировании задач оказал winger.Напомним, что в Раунд 3 пройдут все те команды, которые наберут положительный балл, не меньший, чем у команды на 100-м месте. Также обращаем ваше внимание, что все команды, проходящие в Раунд 3, получат фирменную футболку Чемпионата. Помимо этого, фирменной футболкой будут награждены топ-50 участников интернет-трансляции Раунда 3.Желаем удачи и интересной борьбы!UPD: Благодарим всех за участие! Появился разбор задач. Ждём вас на Уайлд-кард раунде 2 и Раунде 3!",
          "author": "Zlobober",
          "url": "https://codeforces.com/blog/entry/17446",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 1851
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces",
          "content": "532A - Шахтёры БерляндииДоступна только английская версия разбора в английской версии поста.532B - Рабочая группаЭту задачу можно решить с помощью динамического программирования по поддеревьям иерархии сотрудников. Обозначим за D[v][e] максимальную эффективность, которую можно получить, взяв некоторое количество сотрудников из поддерева человека v, таким образом, чтобы их количество имело чётность e, и условие задачи выполнялось для всех взятых людей. Тогда нетрудно пересчитать D[v][e] через детей вершины v с помощью подсчёта промежуточной величины T[i][e] — максимальной эффективности, которой можно достичь, пройдя первые i поддеревьев вершины v, если чётность количества взятых людей — e.Важно не забыть, что бывает два случая: когда мы добавляем самого v, и когда мы этого не делаем. В первом случае обязательно во всех поддеревьях суммарно должно быть чётное число людей по условию, во втором же подобного не требуется.532C - Игра на доскеРассмотрим три случая.1) xp  +  yp ≤  max(xv,  yv). В этом случае Поликарп может оказаться в (0,  0) через xp  +  yp ходов и Василий всегда будет \"позади\". Для Поликарпа достаточно делать любой возможный ход, и это приведёт его к победе. Нетрудно это объяснить тем, что условие xp  +  yp ≤  max(xv,  yv) будет выполнено и после любых возможных ходов Поликарпа и Василия. Иными словами, Василий просто не может победить.2) xp ≤ xv, $y_p \\leq y_v$. В этом случае Поликарп должен некоторым образом блокировать Василия. Он должен совершать такой ход, чтобы после любого возможного хода Василия неравенство было снова выполнено. Если xp  =  xv  >  0, нужно пойти в (xp  -  1,  yp). Если yp  =  yv  >  0, нужно пойти в (xp,  yp  -  1). В противном случае можно совершить любой допустимый ход. Действуя по такой стратегии, мы снова не даём Василию возможности выиграть.3) В противном случае рассмотрим любой кратчайший путь для Василия до точки (0,  0). Любая клетка этого пути ближе к Василию, чем к Поликарпу, поэтому Поликарп никак не может помешать Василию на этом пути. А значит, Василий дойдёт до финиша первым. Альтернативное объяснение заключается в том, что Василий всегда может сходить таким образом, чтобы ни одно из условий 1) и 2) не оказалось выполненным.532D - КолонныПервое наблюдение: колонна рушится только если расстояние между её соседями больше, чем 2di, поэтому для неё не имеет значения, где именно она находится на отрезке между своими соседками. Важно только расстояние между ними.Для каждой колонны C давайте определим, существует ли набор колонн слева такой, что слева от C всё устойчиво. Если ответ да, то тогда давайте определим, как близко может находиться ближайшая к C слева в этом наборе колонна. Зная это, мы узнаем, как далеко справа может находиться следующая за C колонна. Воспользуемся динамическим программированием.Медленный подход: для каждой предыдущей колонны проверим, может ли она быть соседом C. Ближайшая колонна, которая может, является будет тем самым левым соседом C.Более быстрый подход: давайте обозначим за far[i] наибольшую возможную координату, где может находиться правый сосед колонны i. В нашей динамике заведём стек с возможными кандидатами на то, чтобы быть левым соседом каждой колонны. В этом стеке колонны будем поддерживать в порядке возрастания индекса (а, значит, и координаты) и одновременно в порядке убывания far[i] (действительно, нам незачем хранить в стеке колонну, если её мажорирует и по координате, и по far[i] какая-то другая колонна).Теперь для каждой новой колонн мы должны удалить с вершины стека некоторое количество колонн со слишком малым значением far[i]. Последняя оставшаяся колонна на стеке будет той самой, через которую мы пересчитаем значение нашей динамики. Эта часть занимает O(n) времени.Если существует колонна с far[i] не меньше координаты правой несущей колонны, то ответ--- 0, так как конструкция исходно устойчива.Теперь посчитаем ту же самую величину справа налево. Теперь некоторые колонны связаны с левой несущей, некоторые — с правой. Мы хотим поставить новую так, чтобы попасть в пределы far[i] как для левой колонны, так и для правой. Это можно сделать, используя технику двух указателей по двум образованным стекам.Описанное решение работает за O(n) времени и памяти.532E - Исправление ошибокПредположим для определённости, что S получается из W удалением более раннего символа, чем T. Тогда W  =  A  +  x  +  B  +  y  +  C, S  =  A  +  x  +  B  +  C, T  =  A  +  B  +  y  +  C, где x и y — удаляемые символы, а A, B и C — какие-то (возможно, пустые) строки.Определим A как наибольший общий префикс S и T, а C — как наибольший общий суффикс. Удалим их из обоих строк. Теперь мы знаем буквы x и y — это соответственно первая буква строки S и последняя буква строки T. Удалим и их тоже. Остаётся лишь проверить, равны ли оставшиеся части строк.Проделаем так для S и T, а также для T и S.532F - КодированиеУ этой задачи возможно два направления решения.Зафиксируем пару букв x и y. Заменим в строке S все буквы x на единицы, а все остальные буквы на нули. В строке T заменим все буквы y на единицы, а все остальные буквы на нули. С помощью алгоритма КМП или Z-функции определим все позиции, в которых строку T можно приложить к строке S так, что они совпадут. Если такое условие выполнено как для пары букв (x, y), так и для пары букв (y, x), то это значит, что в данной позиции можно приложить T к S с заменой x <-> y и возможно ещё какими-то заменами.Теперь для каждой позиции надо проверить, разбиваются ли буквы на пары в соответствии с известной нам информацией. Это можно сделать за O(sigma), где sigma  =  26 — размер алфавита. Таким образом, решение работает за O(n  *  sigma2  +  n  *  sigma)  =  O(n  *  sigma2). Это решение при должной аккуратности реализации проходит по времени.Другой способ — произвести замену, которая позволит нам сравнивать строки с точностью до переименовывания букв. Заменим каждую букву на расстояние до предыдущей такой же в обоих строках. Теперь для совпадения с точностью до переименования достаточно проверить, что строка T совпадает с подстрокой строки S во всех позициях кроме, возможно первых вхождений каждой буквы в T. Это можно сделать с помощью модифицированной префикс-функции или хеширования.Пусть мы теперь знаем, что в некоторой позиции строка T совпадает со строкой S с точностью до переименовывания. Нетрудно определить, какая перестановка букв соответствует этому переименовыванию (достаточно посмотреть на первую букву каждого вида в T, чему она соответствует в S). Проверим, что эта перестановка — это набор транспозиций за O(sigma). Таким образом, получим решение за O(n  *  sigma).",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17458",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 6584
        }
      ],
      "code_examples": [
        {
          "title": "VK Cup Round 2 + неофициальная интернет-трансляция - Codeforces - Code 1",
          "code": "(h1 << 32) | h2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        },
        {
          "title": "VK Cup Round 2 + неофициальная интернет-трансляция - Codeforces - Code 2",
          "code": "s[i+1]==t[i]",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17446",
          "author": "Zlobober"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 1",
          "code": "11 5\nabacabadaba\nacaba",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 2",
          "code": "11 5\nabacabadaba\nacaba",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 3",
          "code": "s:  a b a  c  a b a  d  a  b   a\nvs: 2 2 2 inf 2 4 2 inf 2 inf inf\n---------------------------------\nt:  a  c  a  b   a\nvt: 2 inf 2 inf inf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 4",
          "code": "s:  a b a  c  a b a  d  a  b   a\nvs: 2 2 2 inf 2 4 2 inf 2 inf inf\n---------------------------------\nt:  a  c  a  b   a\nvt: 2 inf 2 inf inf",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 5",
          "code": "a c a b a ! a b a c a b a d a b a\n            5 0 5 0 5 0 5 0 2 0 0\n            a c a b a\n                a c a b a\n                    a c a b a\n                        a c a b a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        },
        {
          "title": "Разбор VK Cup Round 2 - Codeforces - Code 6",
          "code": "a c a b a ! a b a c a b a d a b a\n            5 0 5 0 5 0 5 0 2 0 0\n            a c a b a\n                a c a b a\n                    a c a b a\n                        a c a b a",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17458",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s_len = inf.readInt(1, 200000, \"|S|\");\n    inf.readSpace();\n    int t_len = inf.readInt(1, s_len, \"|T|\");\n    inf.readEoln();\n\n    string s_regex = \"[a-z]{\" + to_string(s_len) + \"}\";\n    string S = inf.readLine(s_regex, \"S\");\n\n    string t_regex = \"[a-z]{\" + to_string(t_len) + \"}\";\n    string T = inf.readLine(t_regex, \"T\");\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s_len = inf.readInt(1, 200000, \"|S|\");\n    inf.readSpace();\n    int t_len = inf.readInt(1, s_len, \"|T|\");\n    inf.readEoln();\n\n    string s_regex = \"[a-z]{\" + to_string(s_len) + \"}\";\n    string S = inf.readLine(s_regex, \"S\");\n\n    string t_regex = \"[a-z]{\" + to_string(t_len) + \"}\";\n    string T = inf.readLine(t_regex, \"T\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int s_len = inf.readInt(1, 200000, \"|S|\");\n    inf.readSpace();\n    int t_len = inf.readInt(1, s_len, \"|T|\");\n    inf.readEoln();\n\n    string s_regex = \"[a-z]{\" + to_string(s_len) + \"}\";\n    string S = inf.readLine(s_regex, \"S\");\n\n    string t_regex = \"[a-z]{\" + to_string(t_len) + \"}\";\n    string T = inf.readLine(t_regex, \"T\");\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S, T;\n\n    if (type == \"random\") {\n        // Generate random S and T\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"repetitive\") {\n        // S and T are made of the same letter\n        char c = (char)('a' + rnd.next(26));\n        S = string(n, c);\n        T = string(m, c);\n    } else if (type == \"single_match\") {\n        // There is exactly one position where T can be matched\n        // Generate S with letters from 'a' to 'm' (13 letters)\n        vector<char> s_letters;\n        for (char c = 'a'; c <= 'm'; ++c) s_letters.push_back(c);\n        // Generate letters for position mi from 'n' to 'z' (13 letters)\n        vector<char> t_letters;\n        for (char c = 'n'; c <= 'z'; ++c) t_letters.push_back(c);\n\n        // Generate S\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += s_letters[rnd.next(13)];\n        }\n\n        // Choose mi\n        int mi = rnd.next(0, n - m);\n        // Replace S[mi..mi+m-1] with letters from t_letters\n        for (int i = 0; i < m; ++i) {\n            S[mi + i] = t_letters[rnd.next(13)];\n        }\n\n        // Generate T such that T can be obtained from S[mi..mi+m-1] via mapping\n        // Let's map S[mi..mi+m-1] letters to letters from 'a' to 'm'\n        // So T will be letters from 'a' to 'm'\n\n        T = \"\";\n        map<char, char> mapping;\n        for (int i = 0; i < m; ++i) {\n            char s_char = S[mi + i];\n            if (mapping.count(s_char) == 0) {\n                char t_char = s_letters[rnd.next(13)];\n                mapping[s_char] = t_char;\n            }\n            T += mapping[s_char];\n        }\n\n        // Now T can only be mapped from S[mi..mi+m-1] via mapping\n\n    } else if (type == \"no_match\") {\n        // Generate S and T such that there is no possible mapping between any substring of S and T\n        // Use disjoint sets of letters\n\n        // First, pick letters for S and T\n        vector<char> s_letters, t_letters;\n        // Let's reserve 13 letters for S and 13 letters for T\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        s_letters.assign(letters.begin(), letters.begin() + 13);\n        t_letters.assign(letters.begin() + 13, letters.end());\n\n        // Generate S using letters from s_letters\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += s_letters[rnd.next(13)];\n        }\n        // Generate T using letters from t_letters\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += t_letters[rnd.next(13)];\n        }\n    } else if (type == \"all_match\") {\n        // Generate S and T such that every position in S is a valid mi\n\n        // Let's set S and T to be the same, so letters map to themselves\n\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = S.substr(0, m);\n    } else if (type == \"max_case\") {\n        // n and m are maximum, generate random letters\n        n = 200000;\n        m = 200000;\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"edge_case\") {\n        // Edge case with minimal sizes\n        n = 1;\n        m = 1;\n        S = (char)('a' + rnd.next(26));\n        T = (char)('a' + rnd.next(26));\n    } else {\n        // Default case: random\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", S.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    string S, T;\n\n    if (type == \"random\") {\n        // Generate random S and T\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"repetitive\") {\n        // S and T are made of the same letter\n        char c = (char)('a' + rnd.next(26));\n        S = string(n, c);\n        T = string(m, c);\n    } else if (type == \"single_match\") {\n        // There is exactly one position where T can be matched\n        // Generate S with letters from 'a' to 'm' (13 letters)\n        vector<char> s_letters;\n        for (char c = 'a'; c <= 'm'; ++c) s_letters.push_back(c);\n        // Generate letters for position mi from 'n' to 'z' (13 letters)\n        vector<char> t_letters;\n        for (char c = 'n'; c <= 'z'; ++c) t_letters.push_back(c);\n\n        // Generate S\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += s_letters[rnd.next(13)];\n        }\n\n        // Choose mi\n        int mi = rnd.next(0, n - m);\n        // Replace S[mi..mi+m-1] with letters from t_letters\n        for (int i = 0; i < m; ++i) {\n            S[mi + i] = t_letters[rnd.next(13)];\n        }\n\n        // Generate T such that T can be obtained from S[mi..mi+m-1] via mapping\n        // Let's map S[mi..mi+m-1] letters to letters from 'a' to 'm'\n        // So T will be letters from 'a' to 'm'\n\n        T = \"\";\n        map<char, char> mapping;\n        for (int i = 0; i < m; ++i) {\n            char s_char = S[mi + i];\n            if (mapping.count(s_char) == 0) {\n                char t_char = s_letters[rnd.next(13)];\n                mapping[s_char] = t_char;\n            }\n            T += mapping[s_char];\n        }\n\n        // Now T can only be mapped from S[mi..mi+m-1] via mapping\n\n    } else if (type == \"no_match\") {\n        // Generate S and T such that there is no possible mapping between any substring of S and T\n        // Use disjoint sets of letters\n\n        // First, pick letters for S and T\n        vector<char> s_letters, t_letters;\n        // Let's reserve 13 letters for S and 13 letters for T\n        vector<char> letters(26);\n        for (int i = 0; i < 26; ++i) letters[i] = 'a' + i;\n        shuffle(letters.begin(), letters.end());\n        s_letters.assign(letters.begin(), letters.begin() + 13);\n        t_letters.assign(letters.begin() + 13, letters.end());\n\n        // Generate S using letters from s_letters\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += s_letters[rnd.next(13)];\n        }\n        // Generate T using letters from t_letters\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += t_letters[rnd.next(13)];\n        }\n    } else if (type == \"all_match\") {\n        // Generate S and T such that every position in S is a valid mi\n\n        // Let's set S and T to be the same, so letters map to themselves\n\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = S.substr(0, m);\n    } else if (type == \"max_case\") {\n        // n and m are maximum, generate random letters\n        n = 200000;\n        m = 200000;\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += (char)('a' + rnd.next(26));\n        }\n    } else if (type == \"edge_case\") {\n        // Edge case with minimal sizes\n        n = 1;\n        m = 1;\n        S = (char)('a' + rnd.next(26));\n        T = (char)('a' + rnd.next(26));\n    } else {\n        // Default case: random\n        S = \"\";\n        for (int i = 0; i < n; ++i) {\n            S += (char)('a' + rnd.next(26));\n        }\n        T = \"\";\n        for (int i = 0; i < m; ++i) {\n            T += (char)('a' + rnd.next(26));\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", S.c_str());\n    printf(\"%s\\n\", T.c_str());\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 10 -m 5 -type random\n./gen -n 100 -m 50 -type random\n./gen -n 1000 -m 500 -type random\n./gen -n 10000 -m 5000 -type random\n./gen -n 100000 -m 50000 -type random\n./gen -n 200000 -m 100000 -type random\n\n./gen -n 200000 -m 200000 -type max_case\n\n./gen -n 5 -m 3 -type repetitive\n./gen -n 500 -m 250 -type repetitive\n./gen -n 5000 -m 2500 -type repetitive\n./gen -n 50000 -m 25000 -type repetitive\n\n./gen -n 200000 -m 1 -type no_match\n./gen -n 200000 -m 2 -type no_match\n./gen -n 200000 -m 3 -type no_match\n\n./gen -n 200000 -m 200000 -type all_match\n\n./gen -n 200000 -m 100000 -type single_match\n./gen -n 100000 -m 50000 -type single_match\n./gen -n 50000 -m 25000 -type single_match\n\n./gen -n 1 -m 1 -type edge_case\n\n./gen -n 2 -m 1 -type random\n./gen -n 2 -m 2 -type random\n./gen -n 10 -m 10 -type random\n./gen -n 20 -m 10 -type random\n\n./gen -n 200000 -m 1 -type all_match\n./gen -n 200000 -m 1 -type repetitive\n./gen -n 200000 -m 1 -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:42.219036",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "534/A",
      "title": "A. Exam",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputA single line contains integer n (1 ≤ n ≤ 5000) — the number of students at an exam.",
      "output_spec": "OutputIn the first line print integer k — the maximum number of students who can be seated so that no two students with adjacent numbers sit next to each other.In the second line print k distinct integers a1, a2, ..., ak (1 ≤ ai ≤ n), where ai is the number of the student on the i-th position. The students on adjacent positions mustn't have adjacent numbers. Formally, the following should be true: |ai - ai + 1| ≠ 1 for all i from 1 to k - 1.If there are several possible answers, output any of them.",
      "sample_tests": "ExamplesInputCopy6OutputCopy61 5 3 6 2 4InputCopy3OutputCopy21 3",
      "description": "time limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputA single line contains integer n (1 ≤ n ≤ 5000) — the number of students at an exam.\n\nOutputIn the first line print integer k — the maximum number of students who can be seated so that no two students with adjacent numbers sit next to each other.In the second line print k distinct integers a1, a2, ..., ak (1 ≤ ai ≤ n), where ai is the number of the student on the i-th position. The students on adjacent positions mustn't have adjacent numbers. Formally, the following should be true: |ai - ai + 1| ≠ 1 for all i from 1 to k - 1.If there are several possible answers, output any of them.\n\nInputCopy6OutputCopy61 5 3 6 2 4InputCopy3OutputCopy21 3\n\nOutputCopy61 5 3 6 2 4\n\nOutputCopy21 3",
      "solutions": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #298 (Div. 2). It will be held on Sunday, April 12 at 19:00 MSK and Div. 1 participants are invited to join out of competition. Problems have been prepared by Maxim Mescheryakov (Neon) and Danil Sagunov (danilka.pro). We hope you'll find them interesting.Great thanks to Maxim Akhmedov (Zlobober) for helping us preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Codeforces and Polygon systems and ideas of some problems. Also thanks Vitaliy Aksenov (Aksenov239) for writing solutions.You will be given six problems and two and the half hours to solve them.UPD: Scoring system 500-1000-1500-2000-2500-3000UPD2: Competition completed! Thank you all!UPD3: Congratulations to the winners! xuanhien070594 misis Mikagura_Seisa plem 11111111 UPD4: Editorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17366",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 910
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 1",
          "code": "print(sum(min(v1 + d * i, v2 + d * (t - i - 1)) for i in range(t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 2",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 3",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 4",
          "code": "s.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 5",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 6",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 7",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 8",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 9",
          "code": "Scanner.nextInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 10",
          "code": "Scanner.nextLong()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 11",
          "code": "Integer.parseInt(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 12",
          "code": "Long.parseLong(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5000, \"n\");\n    inf.readEoln();\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n    \n    // Read n from the input file\n    int n = inf.readInt();\n\n    // Compute the correct maximum k\n    int correctK;\n    if (n == 1)\n        correctK = 1;\n    else if (n == 2 || n == 3)\n        correctK = n - 1;\n    else\n        correctK = n;\n\n    // Read k from the contestant output\n    int k = ouf.readInt(1, n, \"k\");\n\n    // Check if k matches the correct maximum k\n    if (k != correctK) {\n        quitf(_wa, \"Incorrect k: expected %d, found %d\", correctK, k);\n    }\n\n    // Read the sequence of student numbers\n    vector<int> ai = ouf.readInts(k, 1, n, \"ai\");\n\n    // Check for duplicate student numbers\n    set<int> s(ai.begin(), ai.end());\n    if ((int)s.size() != k) {\n        quitf(_wa, \"Duplicate student numbers found in the sequence\");\n    }\n\n    // Check that adjacent student numbers do not differ by 1\n    for (int i = 0; i < k - 1; i++) {\n        if (abs(ai[i] - ai[i +1]) == 1 ) {\n            quitf(_wa, \"Adjacent student numbers %d and %d at positions %d and %d differ by 1\", ai[i], ai[i+1], i+1, i+2);\n        }\n    }\n\n    // If all checks pass, accept the output\n    quitf(_ok, \"Correct output with k = %d\", k);\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"small\") {\n        // Generate small n between 1 and 10\n        n = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        // Generate maximum n\n        n = 5000;\n    } else if (type == \"odd\") {\n        // Generate an odd n between 1 and 5000\n        n = rnd.next(1, 5000);\n        if (n % 2 == 0) n--;\n        n = max(n, 1);\n    } else if (type == \"even\") {\n        // Generate an even n between 1 and 5000\n        n = rnd.next(1, 5000);\n        if (n % 2 == 1) n--;\n        n = max(n, 2);\n    } else if (type == \"special\") {\n        // Generate special n values that are potential corner cases\n        vector<int> special_n = {1, 2, 3, 4, 5, 4999, 5000};\n        n = rnd.any(special_n);\n    } else if (type == \"random\") {\n        // Generate random n between 1 and 5000\n        n = rnd.next(1, 5000);\n    } else {\n        // Use provided n, ensure it's within bounds\n        n = min(max(n, 1), 5000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 0);\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"small\") {\n        // Generate small n between 1 and 10\n        n = rnd.next(1, 10);\n    } else if (type == \"large\") {\n        // Generate maximum n\n        n = 5000;\n    } else if (type == \"odd\") {\n        // Generate an odd n between 1 and 5000\n        n = rnd.next(1, 5000);\n        if (n % 2 == 0) n--;\n        n = max(n, 1);\n    } else if (type == \"even\") {\n        // Generate an even n between 1 and 5000\n        n = rnd.next(1, 5000);\n        if (n % 2 == 1) n--;\n        n = max(n, 2);\n    } else if (type == \"special\") {\n        // Generate special n values that are potential corner cases\n        vector<int> special_n = {1, 2, 3, 4, 5, 4999, 5000};\n        n = rnd.any(special_n);\n    } else if (type == \"random\") {\n        // Generate random n between 1 and 5000\n        n = rnd.next(1, 5000);\n    } else {\n        // Use provided n, ensure it's within bounds\n        n = min(max(n, 1), 5000);\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small n values\n./gen -type small\n./gen -type small\n./gen -type small\n\n# Large n values\n./gen -type large\n./gen -type large\n\n# Random n values\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Odd n values\n./gen -type odd\n./gen -type odd\n./gen -type odd\n\n# Even n values\n./gen -type even\n./gen -type even\n./gen -type even\n\n# Special n cases\n./gen -type special\n./gen -type special\n./gen -type special\n\n# Specific n values to test corner cases\n./gen -n 1\n./gen -n 2\n./gen -n 3\n./gen -n 4\n./gen -n 5\n./gen -n 2500\n./gen -n 4999\n./gen -n 5000\n\n# Additional random n values for thorough testing\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:44.297095",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "534/B",
      "title": "B. Covered Path",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers v1 and v2 (1 ≤ v1, v2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds.It is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v1,  the speed in the last second equals v2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d.",
      "output_spec": "OutputPrint the maximum possible length of the path segment in meters.",
      "sample_tests": "ExamplesInputCopy5 64 2OutputCopy26InputCopy10 1010 0OutputCopy100",
      "description": "B. Covered Path\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers v1 and v2 (1 ≤ v1, v2 ≤ 100) — the speeds in meters per second at the beginning of the segment and at the end of the segment, respectively.The second line contains two integers t (2 ≤ t ≤ 100) — the time when the car moves along the segment in seconds, d (0 ≤ d ≤ 10) — the maximum value of the speed change between adjacent seconds.It is guaranteed that there is a way to complete the segment so that:  the speed in the first second equals v1,  the speed in the last second equals v2,  the absolute value of difference of speeds between any two adjacent seconds doesn't exceed d.\n\nOutputPrint the maximum possible length of the path segment in meters.\n\nInputCopy5 64 2OutputCopy26InputCopy10 1010 0OutputCopy100\n\nInputCopy5 64 2\n\nOutputCopy26\n\nInputCopy10 1010 0\n\nOutputCopy100\n\nNoteIn the first sample the sequence of speeds of Polycarpus' car can look as follows: 5, 7, 8, 6. Thus, the total path is 5 + 7 + 8 + 6 = 26 meters.In the second sample, as d = 0, the car covers the whole segment at constant speed v = 10. In t = 10 seconds it covers the distance of 100 meters.",
      "solutions": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #298 (Div. 2). It will be held on Sunday, April 12 at 19:00 MSK and Div. 1 participants are invited to join out of competition. Problems have been prepared by Maxim Mescheryakov (Neon) and Danil Sagunov (danilka.pro). We hope you'll find them interesting.Great thanks to Maxim Akhmedov (Zlobober) for helping us preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Codeforces and Polygon systems and ideas of some problems. Also thanks Vitaliy Aksenov (Aksenov239) for writing solutions.You will be given six problems and two and the half hours to solve them.UPD: Scoring system 500-1000-1500-2000-2500-3000UPD2: Competition completed! Thank you all!UPD3: Congratulations to the winners! xuanhien070594 misis Mikagura_Seisa plem 11111111 UPD4: Editorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17366",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 910
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 1",
          "code": "print(sum(min(v1 + d * i, v2 + d * (t - i - 1)) for i in range(t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 2",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 3",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 4",
          "code": "s.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 5",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 6",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 7",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 8",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 9",
          "code": "Scanner.nextInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 10",
          "code": "Scanner.nextLong()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 11",
          "code": "Integer.parseInt(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 12",
          "code": "Long.parseLong(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int v1 = inf.readInt(1, 100, \"v1\");\n    inf.readSpace();\n    int v2 = inf.readInt(1, 100, \"v2\");\n    inf.readEoln();\n    int t = inf.readInt(2, 100, \"t\");\n    inf.readSpace();\n    int d = inf.readInt(0, 10, \"d\");\n    inf.readEoln();\n    ensuref(abs(v1 - v2) <= (t - 1) * d, \"|v1 - v2| = %d > (t-1)*d = %d\", abs(v1 - v2), (t - 1) * d);\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int v1 = inf.readInt(1, 100, \"v1\");\n    inf.readSpace();\n    int v2 = inf.readInt(1, 100, \"v2\");\n    inf.readEoln();\n    int t = inf.readInt(2, 100, \"t\");\n    inf.readSpace();\n    int d = inf.readInt(0, 10, \"d\");\n    inf.readEoln();\n    ensuref(abs(v1 - v2) <= (t - 1) * d, \"|v1 - v2| = %d > (t-1)*d = %d\", abs(v1 - v2), (t - 1) * d);\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int v1 = inf.readInt(1, 100, \"v1\");\n    inf.readSpace();\n    int v2 = inf.readInt(1, 100, \"v2\");\n    inf.readEoln();\n    int t = inf.readInt(2, 100, \"t\");\n    inf.readSpace();\n    int d = inf.readInt(0, 10, \"d\");\n    inf.readEoln();\n    ensuref(abs(v1 - v2) <= (t - 1) * d, \"|v1 - v2| = %d > (t-1)*d = %d\", abs(v1 - v2), (t - 1) * d);\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int minv = opt<int>(\"minv\", 1);\n    int maxv = opt<int>(\"maxv\", 100);\n    int mint = opt<int>(\"mint\", 2);\n    int maxt = opt<int>(\"maxt\", 100);\n    int mind = opt<int>(\"mind\", 0);\n    int maxd = opt<int>(\"maxd\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    int v1 = opt<int>(\"v1\", -1);\n    int v2 = opt<int>(\"v2\", -1);\n    int t = opt<int>(\"t\", -1);\n    int d = opt<int>(\"d\", -1);\n\n    // Generate v1 and v2 if not provided\n    if (v1 == -1) {\n        if (type == \"minv\") {\n            v1 = minv;\n        } else if (type == \"maxv\") {\n            v1 = maxv;\n        } else {\n            v1 = rnd.next(minv, maxv);\n        }\n    }\n    if (v2 == -1) {\n        if (type == \"minv\") {\n            v2 = minv;\n        } else if (type == \"maxv\") {\n            v2 = maxv;\n        } else if (type == \"v1_eq_v2\") {\n            v2 = v1;\n        } else if (type == \"v1_gt_v2\") {\n            v2 = rnd.next(minv, v1 - 1);\n        } else if (type == \"v1_lt_v2\") {\n            v2 = rnd.next(v1 + 1, maxv);\n        } else {\n            v2 = rnd.next(minv, maxv);\n        }\n    }\n\n    // Generate t if not provided\n    if (t == -1) {\n        if (type == \"t_min\") {\n            t = mint;\n        } else if (type == \"t_max\") {\n            t = maxt;\n        } else {\n            t = rnd.next(mint, maxt);\n        }\n    }\n\n    // Ensure v1, v2, t are within constraints\n    v1 = max(minv, min(maxv, v1));\n    v2 = max(minv, min(maxv, v2));\n    t = max(mint, min(maxt, t));\n\n    // Compute minimal required d\n    int numerator = abs(v1 - v2);\n    int denominator = t - 1;\n    int min_d_needed = (numerator + denominator - 1) / denominator; // Ceil division\n\n    // Adjust d if not provided\n    if (d == -1) {\n        if (type == \"d_zero\") {\n            d = 0;\n        } else if (type == \"d_ten\") {\n            d = 10;\n        } else {\n            if (min_d_needed <= 10) {\n                d = rnd.next(max(mind, min_d_needed), min(maxd, 10));\n            } else {\n                // Adjust t or v1, v2 to make min_d_needed <= 10\n                while (min_d_needed > 10 && t < maxt) {\n                    t++;\n                    denominator = t - 1;\n                    min_d_needed = (numerator + denominator - 1) / denominator;\n                }\n                if (min_d_needed <= 10) {\n                    d = rnd.next(max(mind, min_d_needed), min(maxd, 10));\n                } else {\n                    // Impossible to satisfy constraints, adjust v1 or v2\n                    if (v1 > v2) {\n                        v1 = v2 + (t - 1) * 10;\n                        v1 = max(minv, min(maxv, v1));\n                    } else {\n                        v2 = v1 + (t - 1) * 10;\n                        v2 = max(minv, min(maxv, v2));\n                    }\n                    numerator = abs(v1 - v2);\n                    denominator = t - 1;\n                    min_d_needed = (numerator + denominator - 1) / denominator;\n                    if (min_d_needed <= 10) {\n                        d = rnd.next(max(mind, min_d_needed), min(maxd, 10));\n                    } else {\n                        // Set d to maximum allowed\n                        d = 10;\n                    }\n                }\n            }\n        }\n    }\n\n    // Ensure d is within constraints\n    d = max(mind, min(maxd, d));\n\n    // Check for impossible case when d = 0 and v1 != v2\n    if (d == 0 && v1 != v2) {\n        // Adjust v2 to be equal to v1\n        v2 = v1;\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", v1, v2);\n    printf(\"%d %d\\n\", t, d);\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int minv = opt<int>(\"minv\", 1);\n    int maxv = opt<int>(\"maxv\", 100);\n    int mint = opt<int>(\"mint\", 2);\n    int maxt = opt<int>(\"maxt\", 100);\n    int mind = opt<int>(\"mind\", 0);\n    int maxd = opt<int>(\"maxd\", 10);\n    string type = opt<string>(\"type\", \"random\");\n\n    int v1 = opt<int>(\"v1\", -1);\n    int v2 = opt<int>(\"v2\", -1);\n    int t = opt<int>(\"t\", -1);\n    int d = opt<int>(\"d\", -1);\n\n    // Generate v1 and v2 if not provided\n    if (v1 == -1) {\n        if (type == \"minv\") {\n            v1 = minv;\n        } else if (type == \"maxv\") {\n            v1 = maxv;\n        } else {\n            v1 = rnd.next(minv, maxv);\n        }\n    }\n    if (v2 == -1) {\n        if (type == \"minv\") {\n            v2 = minv;\n        } else if (type == \"maxv\") {\n            v2 = maxv;\n        } else if (type == \"v1_eq_v2\") {\n            v2 = v1;\n        } else if (type == \"v1_gt_v2\") {\n            v2 = rnd.next(minv, v1 - 1);\n        } else if (type == \"v1_lt_v2\") {\n            v2 = rnd.next(v1 + 1, maxv);\n        } else {\n            v2 = rnd.next(minv, maxv);\n        }\n    }\n\n    // Generate t if not provided\n    if (t == -1) {\n        if (type == \"t_min\") {\n            t = mint;\n        } else if (type == \"t_max\") {\n            t = maxt;\n        } else {\n            t = rnd.next(mint, maxt);\n        }\n    }\n\n    // Ensure v1, v2, t are within constraints\n    v1 = max(minv, min(maxv, v1));\n    v2 = max(minv, min(maxv, v2));\n    t = max(mint, min(maxt, t));\n\n    // Compute minimal required d\n    int numerator = abs(v1 - v2);\n    int denominator = t - 1;\n    int min_d_needed = (numerator + denominator - 1) / denominator; // Ceil division\n\n    // Adjust d if not provided\n    if (d == -1) {\n        if (type == \"d_zero\") {\n            d = 0;\n        } else if (type == \"d_ten\") {\n            d = 10;\n        } else {\n            if (min_d_needed <= 10) {\n                d = rnd.next(max(mind, min_d_needed), min(maxd, 10));\n            } else {\n                // Adjust t or v1, v2 to make min_d_needed <= 10\n                while (min_d_needed > 10 && t < maxt) {\n                    t++;\n                    denominator = t - 1;\n                    min_d_needed = (numerator + denominator - 1) / denominator;\n                }\n                if (min_d_needed <= 10) {\n                    d = rnd.next(max(mind, min_d_needed), min(maxd, 10));\n                } else {\n                    // Impossible to satisfy constraints, adjust v1 or v2\n                    if (v1 > v2) {\n                        v1 = v2 + (t - 1) * 10;\n                        v1 = max(minv, min(maxv, v1));\n                    } else {\n                        v2 = v1 + (t - 1) * 10;\n                        v2 = max(minv, min(maxv, v2));\n                    }\n                    numerator = abs(v1 - v2);\n                    denominator = t - 1;\n                    min_d_needed = (numerator + denominator - 1) / denominator;\n                    if (min_d_needed <= 10) {\n                        d = rnd.next(max(mind, min_d_needed), min(maxd, 10));\n                    } else {\n                        // Set d to maximum allowed\n                        d = 10;\n                    }\n                }\n            }\n        }\n    }\n\n    // Ensure d is within constraints\n    d = max(mind, min(maxd, d));\n\n    // Check for impossible case when d = 0 and v1 != v2\n    if (d == 0 && v1 != v2) {\n        // Adjust v2 to be equal to v1\n        v2 = v1;\n    }\n\n    // Output the test case\n    printf(\"%d %d\\n\", v1, v2);\n    printf(\"%d %d\\n\", t, d);\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type minv\n./gen -type maxv\n./gen -type v1_eq_v2\n./gen -type v1_gt_v2\n./gen -type v1_lt_v2\n./gen -type random\n\n./gen -type t_min\n./gen -type t_max\n\n./gen -type d_zero\n./gen -type d_ten\n./gen -type random\n\n./gen -v1 1 -v2 100 -t 2 -type hard\n./gen -v1 100 -v2 1 -t 2 -type hard\n\n./gen -v1 100 -v2 1 -t 100 -type v1_gt_v2\n./gen -v1 1 -v2 100 -t 100 -type v1_lt_v2\n\n./gen -v1 50 -v2 50 -t 100 -type v1_eq_v2\n\n./gen -v1 50 -v2 50 -t 2 -type v1_eq_v2\n\n./gen -v1 1 -v2 1 -t 2 -type mind\n\n./gen -v1 100 -v2 100 -t 2 -type maxv\n\n./gen -v1 50 -v2 51 -t 2 -type small_diff\n\n./gen -v1 1 -v2 1 -t 100 -type minv\n\n./gen -v1 100 -v2 100 -t 100 -type maxv\n\n./gen -t 2 -v1 50 -v2 60 -type edge_case\n\n./gen -t 2 -v1 100 -v2 100 -type maxv\n\n./gen -t 100 -v1 1 -v2 100 -type random\n\n./gen -t 100 -v1 100 -v2 1 -type random\n\n./gen -t 100 -v1 50 -v2 50 -type random\n\n./gen\n\n./gen -type random\n\n./gen -minv 1 -maxv 100 -mint 2 -maxt 100 -mind 0 -maxd 10 -type random\n\n./gen -v1 10 -v2 10 -t 10 -d 0\n\n./gen -v1 5 -v2 95 -t 10\n\n./gen -v1 95 -v2 5 -t 10\n\n./gen -v1 1 -v2 100 -t 99\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:46.417636",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "534/C",
      "title": "C. Кости Поликарпа",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке заданы два целых числа n, A (1 ≤ n ≤ 2·105, n ≤ A ≤ s) — количество игральных костей и сумма выпавших значений, где s = d1 + d2 + ... + dn.Вторая строка содержит n целых чисел d1, d2, ..., dn (1 ≤ di ≤ 106), где di — максимальное значение, которое может выпасть на i-й кости.",
      "output_spec": "Выходные данныеВыведите n целых чисел b1, b2, ..., bn, где bi — количество тех значений, которые гарантированно не могли выпасть на i-й кости.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 84 4Выходные данныеСкопировать3 3 Входные данныеСкопировать1 35Выходные данныеСкопировать4 Входные данныеСкопировать2 32 3Выходные данныеСкопировать0 1",
      "description": "C. Кости Поликарпа\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке заданы два целых числа n, A (1 ≤ n ≤ 2·105, n ≤ A ≤ s) — количество игральных костей и сумма выпавших значений, где s = d1 + d2 + ... + dn.Вторая строка содержит n целых чисел d1, d2, ..., dn (1 ≤ di ≤ 106), где di — максимальное значение, которое может выпасть на i-й кости.\n\nВходные данные\n\nВыходные данныеВыведите n целых чисел b1, b2, ..., bn, где bi — количество тех значений, которые гарантированно не могли выпасть на i-й кости.\n\nВыходные данные\n\nВходные данныеСкопировать2 84 4Выходные данныеСкопировать3 3 Входные данныеСкопировать1 35Выходные данныеСкопировать4 Входные данныеСкопировать2 32 3Выходные данныеСкопировать0 1\n\nВходные данныеСкопировать2 84 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 35\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 32 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать0 1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеВ первом примере из условия A равное 8 могло выпасть только в одном случае, когда на первой и второй кости выпало по 4. Соответственно на обеих костях не могли выпасть значения 1, 2 или 3.Во втором примере из условия A равное 3 могло выпасть, когда на единственной кости выпало 3. Соответственно на ней не могли выпасть значения 1, 2, 4 или 5.В третьем примере из условия A равное 3 могло выпасть в случаях, когда на одной кости выпало 1, а на другой 2. Поэтому на первой кости нет значений, которые гарантированно не выпали, а на второй кости не могло выпасть 3.",
      "solutions": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!12 апреля 2015 года в 19:00 MSK состоится очередной раунд Codeforces Round #298, для участников из второго дивизиона. Участники первого дивизиона приглашаются поучаствовать вне конкурса. Задачи для раунда подготовили Максим Мещеряков (Neon) и Данил Сагунов (danilka.pro). Надеемся, задачи покажутся вам интересными.Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon и за идеи некоторых задач. Так же выражаем благодарность Виталию Аксёнову (Aksenov239) за прорешивание задач.Участникам будет предложено шесть задач и два с половиной часа на их решение. UPD: Распределение баллов 500-1000-1500-2000-2500-3000UPD2: Соревнование завершено! Спасибо всем кто участвовал!UPD3: Поздравляем победителей! xuanhien070594 misis Mikagura_Seisa plem 11111111 UPD4: Добавлен разбор",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17366",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 949
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 1",
          "code": "print(sum(min(v1 + d * i, v2 + d * (t - i - 1)) for i in range(t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 2",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 3",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 4",
          "code": "s.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 5",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 6",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 7",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 8",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 9",
          "code": "Scanner.nextInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 10",
          "code": "Scanner.nextLong()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 11",
          "code": "Integer.parseInt(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 12",
          "code": "Long.parseLong(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 13",
          "code": "5 20\n10 10 10 10 10\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 14",
          "code": "5 20\n10 10 10 10 10\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 15",
          "code": "'волшебные'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 16",
          "code": "'волшебных'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    long long A = inf.readLong(n, (long long)n * 1000000LL, \"A\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n, 1, 1000000, \"d_i\");\n    inf.readEoln();\n\n    long long s = 0;\n    for (int i = 0; i < n; ++i) {\n        s += d[i];\n    }\n\n    ensuref(A <= s, \"A (%lld) must be less than or equal to sum of d_i (%lld)\", A, s);\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    long long A = inf.readLong(n, (long long)n * 1000000LL, \"A\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n, 1, 1000000, \"d_i\");\n    inf.readEoln();\n\n    long long s = 0;\n    for (int i = 0; i < n; ++i) {\n        s += d[i];\n    }\n\n    ensuref(A <= s, \"A (%lld) must be less than or equal to sum of d_i (%lld)\", A, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readSpace();\n    long long A = inf.readLong(n, (long long)n * 1000000LL, \"A\");\n    inf.readEoln();\n\n    vector<int> d = inf.readInts(n, 1, 1000000, \"d_i\");\n    inf.readEoln();\n\n    long long s = 0;\n    for (int i = 0; i < n; ++i) {\n        s += d[i];\n    }\n\n    ensuref(A <= s, \"A (%lld) must be less than or equal to sum of d_i (%lld)\", A, s);\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string d_type = opt<string>(\"d_type\", \"random\");\n    string A_type = opt<string>(\"A_type\", \"randomA\");\n\n    vector<int> d(n);\n\n    if (d_type == \"min_dice\") {\n        for (int i = 0; i < n; ++i)\n            d[i] = 1;\n    } else if (d_type == \"max_dice\") {\n        for (int i = 0; i < n; ++i)\n            d[i] = 1000000;\n    } else if (d_type == \"ascending\") {\n        int min_d = 1;\n        int max_d = min(1000000, n);\n        for (int i = 0; i < n; ++i)\n            d[i] = min_d + i % (max_d - min_d + 1);\n    } else if (d_type == \"descending\") {\n        int min_d = 1;\n        int max_d = min(1000000, n);\n        for (int i = 0; i < n; ++i)\n            d[i] = max_d - i % (max_d - min_d + 1);\n    } else if (d_type == \"same\") {\n        int val = opt<int>(\"d_val\", 6); // default value 6\n        for (int i = 0; i < n; ++i)\n            d[i] = val;\n    } else if (d_type == \"random\") {\n        int min_d = opt<int>(\"min_d\", 1);\n        int max_d = opt<int>(\"max_d\", 1000000);\n        for (int i = 0; i < n; ++i)\n            d[i] = rnd.next(min_d, max_d);\n    } else {\n        fprintf(stderr, \"Unknown d_type: %s\\n\", d_type.c_str());\n        return 1;\n    }\n\n    long long s = accumulate(d.begin(), d.end(), 0LL);\n    long long A;\n\n    if (A_type == \"minA\") {\n        A = n;\n    } else if (A_type == \"maxA\") {\n        A = s;\n    } else if (A_type == \"randomA\") {\n        A = rnd.next((long long)n, s);\n    } else if (A_type == \"smallA\") {\n        A = n + rnd.next(0LL, min(s - n, 1000LL));\n    } else if (A_type == \"largeA\") {\n        A = s - rnd.next(0LL, min(s - n, 1000LL));\n    } else {\n        fprintf(stderr, \"Unknown A_type: %s\\n\", A_type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %lld\\n\", n, A);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", d[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string d_type = opt<string>(\"d_type\", \"random\");\n    string A_type = opt<string>(\"A_type\", \"randomA\");\n\n    vector<int> d(n);\n\n    if (d_type == \"min_dice\") {\n        for (int i = 0; i < n; ++i)\n            d[i] = 1;\n    } else if (d_type == \"max_dice\") {\n        for (int i = 0; i < n; ++i)\n            d[i] = 1000000;\n    } else if (d_type == \"ascending\") {\n        int min_d = 1;\n        int max_d = min(1000000, n);\n        for (int i = 0; i < n; ++i)\n            d[i] = min_d + i % (max_d - min_d + 1);\n    } else if (d_type == \"descending\") {\n        int min_d = 1;\n        int max_d = min(1000000, n);\n        for (int i = 0; i < n; ++i)\n            d[i] = max_d - i % (max_d - min_d + 1);\n    } else if (d_type == \"same\") {\n        int val = opt<int>(\"d_val\", 6); // default value 6\n        for (int i = 0; i < n; ++i)\n            d[i] = val;\n    } else if (d_type == \"random\") {\n        int min_d = opt<int>(\"min_d\", 1);\n        int max_d = opt<int>(\"max_d\", 1000000);\n        for (int i = 0; i < n; ++i)\n            d[i] = rnd.next(min_d, max_d);\n    } else {\n        fprintf(stderr, \"Unknown d_type: %s\\n\", d_type.c_str());\n        return 1;\n    }\n\n    long long s = accumulate(d.begin(), d.end(), 0LL);\n    long long A;\n\n    if (A_type == \"minA\") {\n        A = n;\n    } else if (A_type == \"maxA\") {\n        A = s;\n    } else if (A_type == \"randomA\") {\n        A = rnd.next((long long)n, s);\n    } else if (A_type == \"smallA\") {\n        A = n + rnd.next(0LL, min(s - n, 1000LL));\n    } else if (A_type == \"largeA\") {\n        A = s - rnd.next(0LL, min(s - n, 1000LL));\n    } else {\n        fprintf(stderr, \"Unknown A_type: %s\\n\", A_type.c_str());\n        return 1;\n    }\n\n    printf(\"%d %lld\\n\", n, A);\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d\", d[i]);\n        if (i + 1 < n) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -d_type min_dice -A_type minA\n./gen -n 1 -d_type max_dice -A_type maxA\n./gen -n 1 -d_type same -d_val 6 -A_type randomA\n\n./gen -n 2 -d_type ascending -A_type minA\n./gen -n 2 -d_type descending -A_type maxA\n\n./gen -n 10 -d_type random -min_d 1 -max_d 10 -A_type randomA\n./gen -n 10 -d_type same -d_val 1 -A_type minA\n\n./gen -n 100 -d_type random -min_d 1 -max_d 1000 -A_type randomA\n./gen -n 100 -d_type same -d_val 1000000 -A_type randomA\n\n./gen -n 1000 -d_type min_dice -A_type minA\n./gen -n 1000 -d_type min_dice -A_type maxA\n\n./gen -n 1000 -d_type max_dice -A_type minA\n./gen -n 1000 -d_type max_dice -A_type maxA\n\n./gen -n 200000 -d_type random -min_d 1 -max_d 1000000 -A_type randomA\n./gen -n 200000 -d_type random -min_d 1 -max_d 1000000 -A_type minA\n./gen -n 200000 -d_type random -min_d 1 -max_d 1000000 -A_type maxA\n./gen -n 200000 -d_type same -d_val 1000000 -A_type randomA\n\n./gen -n 200000 -d_type ascending -A_type smallA\n./gen -n 200000 -d_type descending -A_type largeA\n\n./gen -n 1 -d_type random -min_d 1000000 -max_d 1000000 -A_type maxA\n./gen -n 2 -d_type same -d_val 1 -A_type smallA\n\n./gen -n 1 -d_type same -d_val 1 -A_type minA\n./gen -n 200000 -d_type same -d_val 1 -A_type minA\n\n./gen -n 200000 -d_type same -d_val 1 -A_type maxA\n\n./gen -n 200000 -d_type max_dice -A_type smallA\n./gen -n 200000 -d_type max_dice -A_type largeA\n\n./gen -n 200000 -d_type random -min_d 1000000 -max_d 1000000 -A_type randomA\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:48.660565",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "534/D",
      "title": "D. Handshakes",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of students who came to CTOP. The next line contains n integers a1, a2, ..., an (0 ≤ ai < n), where ai is the number of students with who the i-th student shook hands.",
      "output_spec": "OutputIf the sought order of students exists, print in the first line \"Possible\" and in the second line print the permutation of the students' numbers defining the order in which the students entered the center. Number i that stands to the left of number j in this permutation means that the i-th student came earlier than the j-th student. If there are multiple answers, print any of them.If the sought order of students doesn't exist, in a single line print \"Impossible\".",
      "sample_tests": "ExamplesInputCopy52 1 3 0 1OutputCopyPossible4 5 1 3 2 InputCopy90 2 3 4 1 1 0 2 2OutputCopyPossible7 5 2 1 6 8 3 4 9InputCopy40 2 1 1OutputCopyImpossible",
      "description": "D. Handshakes\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains integer n (1 ≤ n ≤ 2·105) — the number of students who came to CTOP. The next line contains n integers a1, a2, ..., an (0 ≤ ai < n), where ai is the number of students with who the i-th student shook hands.\n\nOutputIf the sought order of students exists, print in the first line \"Possible\" and in the second line print the permutation of the students' numbers defining the order in which the students entered the center. Number i that stands to the left of number j in this permutation means that the i-th student came earlier than the j-th student. If there are multiple answers, print any of them.If the sought order of students doesn't exist, in a single line print \"Impossible\".\n\nInputCopy52 1 3 0 1OutputCopyPossible4 5 1 3 2 InputCopy90 2 3 4 1 1 0 2 2OutputCopyPossible7 5 2 1 6 8 3 4 9InputCopy40 2 1 1OutputCopyImpossible\n\nInputCopy52 1 3 0 1\n\nOutputCopyPossible4 5 1 3 2\n\nInputCopy90 2 3 4 1 1 0 2 2\n\nOutputCopyPossible7 5 2 1 6 8 3 4 9\n\nInputCopy40 2 1 1\n\nOutputCopyImpossible\n\nNoteIn the first sample from the statement the order of events could be as follows:   student 4 comes in (a4 = 0), he has no one to greet;  student 5 comes in (a5 = 1), he shakes hands with student 4;  student 1 comes in (a1 = 2), he shakes hands with two students (students 4, 5);  student 3 comes in (a3 = 3), he shakes hands with three students (students 4, 5, 1);  students 4, 5, 3 form a team and start writing a contest;  student 2 comes in (a2 = 1), he shakes hands with one student (number 1). In the second sample from the statement the order of events could be as follows:   student 7 comes in (a7 = 0), he has nobody to greet;  student 5 comes in (a5 = 1), he shakes hands with student 7;  student 2 comes in (a2 = 2), he shakes hands with two students (students 7, 5);  students 7, 5, 2 form a team and start writing a contest;  student 1 comes in(a1 = 0), he has no one to greet (everyone is busy with the contest);  student 6 comes in (a6 = 1), he shakes hands with student 1;  student 8 comes in (a8 = 2), he shakes hands with two students (students 1, 6);  student 3 comes in (a3 = 3), he shakes hands with three students (students 1, 6, 8);  student 4 comes in (a4 = 4), he shakes hands with four students (students 1, 6, 8, 3);  students 8, 3, 4 form a team and start writing a contest;  student 9 comes in (a9 = 2), he shakes hands with two students (students 1, 6). In the third sample from the statement the order of events is restored unambiguously:   student 1 comes in (a1 = 0), he has no one to greet;  student 3 comes in (or student 4) (a3 = a4 = 1), he shakes hands with student 1;  student 2 comes in (a2 = 2), he shakes hands with two students (students 1, 3 (or 4));  the remaining student 4 (or student 3), must shake one student's hand (a3 = a4 = 1) but it is impossible as there are only two scenarios: either a team formed and he doesn't greet anyone, or he greets all the three present people who work individually.",
      "solutions": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #298 (Div. 2). It will be held on Sunday, April 12 at 19:00 MSK and Div. 1 participants are invited to join out of competition. Problems have been prepared by Maxim Mescheryakov (Neon) and Danil Sagunov (danilka.pro). We hope you'll find them interesting.Great thanks to Maxim Akhmedov (Zlobober) for helping us preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Codeforces and Polygon systems and ideas of some problems. Also thanks Vitaliy Aksenov (Aksenov239) for writing solutions.You will be given six problems and two and the half hours to solve them.UPD: Scoring system 500-1000-1500-2000-2500-3000UPD2: Competition completed! Thank you all!UPD3: Congratulations to the winners! xuanhien070594 misis Mikagura_Seisa plem 11111111 UPD4: Editorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17366",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 910
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 1",
          "code": "print(sum(min(v1 + d * i, v2 + d * (t - i - 1)) for i in range(t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 2",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 3",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 4",
          "code": "s.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 5",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 6",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 7",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 8",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 9",
          "code": "Scanner.nextInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 10",
          "code": "Scanner.nextLong()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 11",
          "code": "Integer.parseInt(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 12",
          "code": "Long.parseLong(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(0, n - 1, \"a_i\");\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(0, n - 1, \"a_i\");\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 1; i <= n; ++i) {\n        int ai = inf.readInt(0, n - 1, \"a_i\");\n        if (i < n) {\n            inf.readSpace();\n        } else {\n            inf.readEoln();\n        }\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char **argv) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"no_team\") {\n        // No teams formed\n        // All students remain active throughout\n        for (int i = 0; i < n; ++i) {\n            a[i] = i;\n        }\n    } else if (type == \"full_team\") {\n        // Form teams as soon as possible\n        // After every three arrivals, form a team\n        vector<int> active_students;\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (active_students.size() == 3) {\n                // Form a team\n                active_students.clear();\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly decide whether to form teams\n        vector<int> active_students;\n        int p = opt<int>(\"p\", 5); // Probability parameter\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (active_students.size() >= 3 && rnd.next(0, p - 1) == 0) {\n                // Form a team\n                shuffle(active_students.begin(), active_students.end());\n                vector<int> team_members(active_students.begin(), active_students.begin() + 3);\n                // Remove team members from active_students\n                for (int t : team_members) {\n                    active_students.erase(std::remove(active_students.begin(), active_students.end(), t), active_students.end());\n                }\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate impossible data\n        a[0] = 1; // Impossible since the first student cannot have greeted anyone\n        for (int i = 1; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"single_team\") {\n        // Form a single team of 3 students at some point\n        vector<int> active_students;\n        bool team_formed = false;\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (!team_formed && active_students.size() >= 3) {\n                // Form a team\n                active_students.erase(active_students.begin(), active_students.begin() + 3);\n                team_formed = true;\n            }\n        }\n    } else if (type == \"late_team\") {\n        // Form teams late in the process\n        vector<int> active_students;\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (i > n - 10 && active_students.size() >= 3) {\n                while (active_students.size() >= 3) {\n                    // Form a team\n                    active_students.erase(active_students.begin(), active_students.begin() + 3);\n                }\n            }\n        }\n    } else {\n        // Default to 'no_team'\n        for (int i = 0; i < n; ++i) {\n            a[i] = i;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char **argv) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a(n);\n\n    if (type == \"no_team\") {\n        // No teams formed\n        // All students remain active throughout\n        for (int i = 0; i < n; ++i) {\n            a[i] = i;\n        }\n    } else if (type == \"full_team\") {\n        // Form teams as soon as possible\n        // After every three arrivals, form a team\n        vector<int> active_students;\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (active_students.size() == 3) {\n                // Form a team\n                active_students.clear();\n            }\n        }\n    } else if (type == \"random\") {\n        // Randomly decide whether to form teams\n        vector<int> active_students;\n        int p = opt<int>(\"p\", 5); // Probability parameter\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (active_students.size() >= 3 && rnd.next(0, p - 1) == 0) {\n                // Form a team\n                shuffle(active_students.begin(), active_students.end());\n                vector<int> team_members(active_students.begin(), active_students.begin() + 3);\n                // Remove team members from active_students\n                for (int t : team_members) {\n                    active_students.erase(std::remove(active_students.begin(), active_students.end(), t), active_students.end());\n                }\n            }\n        }\n    } else if (type == \"impossible\") {\n        // Generate impossible data\n        a[0] = 1; // Impossible since the first student cannot have greeted anyone\n        for (int i = 1; i < n; ++i) {\n            a[i] = 0;\n        }\n    } else if (type == \"single_team\") {\n        // Form a single team of 3 students at some point\n        vector<int> active_students;\n        bool team_formed = false;\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (!team_formed && active_students.size() >= 3) {\n                // Form a team\n                active_students.erase(active_students.begin(), active_students.begin() + 3);\n                team_formed = true;\n            }\n        }\n    } else if (type == \"late_team\") {\n        // Form teams late in the process\n        vector<int> active_students;\n        for (int i = 0; i < n; ++i) {\n            a[i] = active_students.size();\n            active_students.push_back(i);\n            if (i > n - 10 && active_students.size() >= 3) {\n                while (active_students.size() >= 3) {\n                    // Form a team\n                    active_students.erase(active_students.begin(), active_students.begin() + 3);\n                }\n            }\n        }\n    } else {\n        // Default to 'no_team'\n        for (int i = 0; i < n; ++i) {\n            a[i] = i;\n        }\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n    // Output ai\n    for (int i = 0; i < n; ++i) {\n        printf(\"%d%c\", a[i], (i == n - 1 ? '\\n' : ' '));\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -type no_team\n./gen -n 2 -type no_team\n./gen -n 3 -type no_team\n./gen -n 5 -type no_team\n./gen -n 10 -type no_team\n\n./gen -n 3 -type full_team\n./gen -n 6 -type full_team\n./gen -n 9 -type full_team\n./gen -n 12 -type full_team\n./gen -n 15 -type full_team\n\n./gen -n 7 -type random -p 2\n./gen -n 20 -type random -p 3\n./gen -n 50 -type random -p 5\n./gen -n 100 -type random -p 2\n./gen -n 1000 -type random -p 5\n\n./gen -n 10000 -type random -p 5\n./gen -n 50000 -type random -p 10\n./gen -n 100000 -type random -p 20\n./gen -n 200000 -type random -p 50\n\n./gen -n 100000 -type no_team\n./gen -n 200000 -type no_team\n\n./gen -n 100000 -type full_team\n./gen -n 200000 -type full_team\n\n./gen -n 3 -type impossible\n./gen -n 4 -type impossible\n./gen -n 5 -type impossible\n./gen -n 1000 -type impossible\n\n./gen -n 10 -type late_team\n./gen -n 100 -type late_team\n./gen -n 1000 -type late_team\n./gen -n 10000 -type late_team\n./gen -n 200000 -type late_team\n\n./gen -n 5 -type single_team\n./gen -n 50 -type single_team\n./gen -n 500 -type single_team\n./gen -n 5000 -type single_team\n./gen -n 50000 -type single_team\n\n./gen -n 200000 -type random -p 100\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:50.896945",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "534/E",
      "title": "E. Берляндская система локального позиционирования",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке записано целое число n (2 ≤ n ≤ 2·105) — количество остановок.Вторая строка содержит n целых чисел (1 ≤ ai ≤ 109) — расстояние i-й остановки от центральной площади. Числа во второй строке идут в порядке возрастания.В третьей строке записано целое число m (1 ≤ m ≤ 4·105) — количество остановок, которые проехал автобус на некотором участке пути.Четвертая строка содержит m целых чисел (1 ≤ bi ≤ n) — номера остановок, которые проехал автобус на участке пути, в отсортированном порядке. Номер остановки встречается такое количество раз, сколько раз ее проехал автобус.Гарантируется, что запрос соответствует некоторому участку пути.",
      "output_spec": "Выходные данныеВ единственную строку необходимо вывести расстояние, которое проехал автобус. Если это невозможно однозначно определить, необходимо вывести  - 1.",
      "sample_tests": "ПримерыВходные данныеСкопировать62 3 5 7 11 1353 4 5 5 6Выходные данныеСкопировать10Входные данныеСкопировать62 3 5 7 11 1391 2 2 3 3 4 5 5 6Выходные данныеСкопировать16Входные данныеСкопировать310 200 30041 2 2 3Выходные данныеСкопировать-1Входные данныеСкопировать31 2 341 2 2 3Выходные данныеСкопировать3",
      "description": "E. Берляндская система локального позиционирования\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке записано целое число n (2 ≤ n ≤ 2·105) — количество остановок.Вторая строка содержит n целых чисел (1 ≤ ai ≤ 109) — расстояние i-й остановки от центральной площади. Числа во второй строке идут в порядке возрастания.В третьей строке записано целое число m (1 ≤ m ≤ 4·105) — количество остановок, которые проехал автобус на некотором участке пути.Четвертая строка содержит m целых чисел (1 ≤ bi ≤ n) — номера остановок, которые проехал автобус на участке пути, в отсортированном порядке. Номер остановки встречается такое количество раз, сколько раз ее проехал автобус.Гарантируется, что запрос соответствует некоторому участку пути.\n\nВходные данные\n\nВыходные данныеВ единственную строку необходимо вывести расстояние, которое проехал автобус. Если это невозможно однозначно определить, необходимо вывести  - 1.\n\nВыходные данные\n\nВходные данныеСкопировать62 3 5 7 11 1353 4 5 5 6Выходные данныеСкопировать10Входные данныеСкопировать62 3 5 7 11 1391 2 2 3 3 4 5 5 6Выходные данныеСкопировать16Входные данныеСкопировать310 200 30041 2 2 3Выходные данныеСкопировать-1Входные данныеСкопировать31 2 341 2 2 3Выходные данныеСкопировать3\n\nВходные данныеСкопировать62 3 5 7 11 1353 4 5 5 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать62 3 5 7 11 1391 2 2 3 3 4 5 5 6\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать16\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать310 200 30041 2 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 2 341 2 2 3\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nПримечаниеПервый тест из условия демонстрирует первый, разобранный в условии задачи пример.Второй тест из условия демонстрирует второй, разобранный в условии задачи пример.В третьем примере возможны два разных маршрута, которые имеют разные длины, следовательно, искомая длина участка не определена однозначно.В четвертом примере, несмотря на то, что запросу соответствуют два разных маршрута, они имеют одинаковые длины, следовательно, искомая длина участка определена однозначно.",
      "solutions": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces",
          "content": "Привет, Codeforces!12 апреля 2015 года в 19:00 MSK состоится очередной раунд Codeforces Round #298, для участников из второго дивизиона. Участники первого дивизиона приглашаются поучаствовать вне конкурса. Задачи для раунда подготовили Максим Мещеряков (Neon) и Данил Сагунов (danilka.pro). Надеемся, задачи покажутся вам интересными.Большое спасибо Максиму Ахмедову (Zlobober) за помощь в подготовке задач, Марии Беловой (Delinur) за перевод условий на английский, Михаилу Мирзаянову (MikeMirzayanov) за замечательные системы Codeforces и Polygon и за идеи некоторых задач. Так же выражаем благодарность Виталию Аксёнову (Aksenov239) за прорешивание задач.Участникам будет предложено шесть задач и два с половиной часа на их решение. UPD: Распределение баллов 500-1000-1500-2000-2500-3000UPD2: Соревнование завершено! Спасибо всем кто участвовал!UPD3: Поздравляем победителей! xuanhien070594 misis Mikagura_Seisa plem 11111111 UPD4: Добавлен разбор",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17366",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": false,
            "is_solution": false,
            "confidence": 0.0,
            "reason": "规则匹配未找到相关标题"
          },
          "content_length": 949
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 1",
          "code": "print(sum(min(v1 + d * i, v2 + d * (t - i - 1)) for i in range(t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 2",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 3",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 4",
          "code": "s.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 5",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 6",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 7",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 8",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 9",
          "code": "Scanner.nextInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 10",
          "code": "Scanner.nextLong()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 11",
          "code": "Integer.parseInt(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 12",
          "code": "Long.parseLong(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 13",
          "code": "5 20\n10 10 10 10 10\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 14",
          "code": "5 20\n10 10 10 10 10\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 15",
          "code": "'волшебные'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 16",
          "code": "'волшебных'",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i's are strictly increasing\n    for (int i = 0; i < n -1; ++i) {\n        ensuref(a[i] < a[i +1], \"a[%d] (=%d) is not less than a[%d] (=%d)\", i+1, a[i], i+2, a[i+1]);\n    }\n\n    // Read m\n    int m = inf.readInt(1, 400000, \"m\");\n    inf.readEoln();\n\n    // Read b_i\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Check that b_i's are in non-decreasing order\n    for (int i = 0; i < m -1; ++i) {\n        ensuref(b[i] <= b[i +1], \"b[%d] (=%d) is greater than b[%d] (=%d)\", i+1, b[i], i+2, b[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i's are strictly increasing\n    for (int i = 0; i < n -1; ++i) {\n        ensuref(a[i] < a[i +1], \"a[%d] (=%d) is not less than a[%d] (=%d)\", i+1, a[i], i+2, a[i+1]);\n    }\n\n    // Read m\n    int m = inf.readInt(1, 400000, \"m\");\n    inf.readEoln();\n\n    // Read b_i\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Check that b_i's are in non-decreasing order\n    for (int i = 0; i < m -1; ++i) {\n        ensuref(b[i] <= b[i +1], \"b[%d] (=%d) is greater than b[%d] (=%d)\", i+1, b[i], i+2, b[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    // Read n\n    int n = inf.readInt(2, 200000, \"n\");\n    inf.readEoln();\n\n    // Read a_i\n    vector<int> a = inf.readInts(n, 1, 1000000000, \"a_i\");\n    inf.readEoln();\n\n    // Check that a_i's are strictly increasing\n    for (int i = 0; i < n -1; ++i) {\n        ensuref(a[i] < a[i +1], \"a[%d] (=%d) is not less than a[%d] (=%d)\", i+1, a[i], i+2, a[i+1]);\n    }\n\n    // Read m\n    int m = inf.readInt(1, 400000, \"m\");\n    inf.readEoln();\n\n    // Read b_i\n    vector<int> b = inf.readInts(m, 1, n, \"b_i\");\n    inf.readEoln();\n\n    // Check that b_i's are in non-decreasing order\n    for (int i = 0; i < m -1; ++i) {\n        ensuref(b[i] <= b[i +1], \"b[%d] (=%d) is greater than b[%d] (=%d)\", i+1, b[i], i+2, b[i+1]);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a; // Positions of the stops\n    vector<int> b; // Observed stops in the query\n\n    // Based on the type, set up n and m and generate a and b accordingly\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = rnd.next(1, 400000);\n\n        // Generate n distinct positions between 1 and 1e9\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, (int)1e9 - n + 1));\n        }\n        a.assign(positions.begin(), positions.end());\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n\n    } else if (type == \"maxN\") {\n        n = 200000;\n        m = 400000;\n\n        // Generate n positions\n        a.resize(n);\n        int start = rnd.next(1, (int)1e9 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n\n        // Generate bus route path back and forth to cover up to m\n        vector<int> path;\n        for (int i = 1; i <= n; i++) path.push_back(i);\n        for (int i = n - 1; i >= 1; i--) path.push_back(i);\n\n        // Repeat the path as needed\n        while ((int)b.size() < m) {\n            b.insert(b.end(), path.begin(), path.end());\n        }\n        b.resize(m);\n        sort(b.begin(), b.end());\n\n    } else if (type == \"minN\") {\n        n = 2;\n        m = 1;\n        a = {1, 2};\n        b = {1};\n\n    } else if (type == \"ambiguous\") {\n        // Use sample Input 3\n        n = 3;\n        m = 4;\n        a = {10, 200, 300};\n        b = {1, 2, 2, 3};\n\n    } else if (type == \"unique\") {\n        // Use sample Input 4\n        n = 3;\n        m = 4;\n        a = {1, 2, 3};\n        b = {1, 2, 2, 3};\n\n    } else if (type == \"largeDistances\") {\n        if (n == -1) n = rnd.next(199900, 200000);\n        if (m == -1) m = rnd.next(399900, 400000);\n\n        a.resize(n);\n        int start = 1e9 - n * 1000;\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i * 1000;\n        }\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n\n    } else if (type == \"smallDistances\") {\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = rnd.next(1, 400000);\n\n        a.resize(n);\n        int start = rnd.next(1, 100);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n    } else if (type == \"repeats\") {\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = 400000;\n\n        a.resize(n);\n        int start = rnd.next(1, (int)1e9 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n\n        // Build path as the bus moves back and forth\n        vector<int> path;\n        for (int i = 1; i <= n; i++) path.push_back(i);\n        for (int i = n - 1; i >= 1; i--) path.push_back(i);\n\n        // Ensure we have repeats\n        while ((int)b.size() < m) {\n            b.insert(b.end(), path.begin(), path.end());\n        }\n        b.resize(m);\n        sort(b.begin(), b.end());\n\n    } else {\n        // Default to random\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = rnd.next(1, 400000);\n\n        // Generate n distinct positions between 1 and 1e9\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, (int)1e9 - n + 1));\n        }\n        a.assign(positions.begin(), positions.end());\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a_i's\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Output m\n    printf(\"%d\\n\", (int)b.size());\n\n    // Output b_i's\n    for (int i = 0; i < (int)b.size(); i++) {\n        printf(\"%d%c\", b[i], (i == (int)b.size() - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    // Read parameters\n    int n = opt<int>(\"n\", -1);\n    int m = opt<int>(\"m\", -1);\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<int> a; // Positions of the stops\n    vector<int> b; // Observed stops in the query\n\n    // Based on the type, set up n and m and generate a and b accordingly\n    if (type == \"random\") {\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = rnd.next(1, 400000);\n\n        // Generate n distinct positions between 1 and 1e9\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, (int)1e9 - n + 1));\n        }\n        a.assign(positions.begin(), positions.end());\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n\n    } else if (type == \"maxN\") {\n        n = 200000;\n        m = 400000;\n\n        // Generate n positions\n        a.resize(n);\n        int start = rnd.next(1, (int)1e9 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n\n        // Generate bus route path back and forth to cover up to m\n        vector<int> path;\n        for (int i = 1; i <= n; i++) path.push_back(i);\n        for (int i = n - 1; i >= 1; i--) path.push_back(i);\n\n        // Repeat the path as needed\n        while ((int)b.size() < m) {\n            b.insert(b.end(), path.begin(), path.end());\n        }\n        b.resize(m);\n        sort(b.begin(), b.end());\n\n    } else if (type == \"minN\") {\n        n = 2;\n        m = 1;\n        a = {1, 2};\n        b = {1};\n\n    } else if (type == \"ambiguous\") {\n        // Use sample Input 3\n        n = 3;\n        m = 4;\n        a = {10, 200, 300};\n        b = {1, 2, 2, 3};\n\n    } else if (type == \"unique\") {\n        // Use sample Input 4\n        n = 3;\n        m = 4;\n        a = {1, 2, 3};\n        b = {1, 2, 2, 3};\n\n    } else if (type == \"largeDistances\") {\n        if (n == -1) n = rnd.next(199900, 200000);\n        if (m == -1) m = rnd.next(399900, 400000);\n\n        a.resize(n);\n        int start = 1e9 - n * 1000;\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i * 1000;\n        }\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n\n    } else if (type == \"smallDistances\") {\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = rnd.next(1, 400000);\n\n        a.resize(n);\n        int start = rnd.next(1, 100);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n    } else if (type == \"repeats\") {\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = 400000;\n\n        a.resize(n);\n        int start = rnd.next(1, (int)1e9 - n + 1);\n        for (int i = 0; i < n; i++) {\n            a[i] = start + i;\n        }\n\n        // Build path as the bus moves back and forth\n        vector<int> path;\n        for (int i = 1; i <= n; i++) path.push_back(i);\n        for (int i = n - 1; i >= 1; i--) path.push_back(i);\n\n        // Ensure we have repeats\n        while ((int)b.size() < m) {\n            b.insert(b.end(), path.begin(), path.end());\n        }\n        b.resize(m);\n        sort(b.begin(), b.end());\n\n    } else {\n        // Default to random\n        if (n == -1) n = rnd.next(2, 200000);\n        if (m == -1) m = rnd.next(1, 400000);\n\n        // Generate n distinct positions between 1 and 1e9\n        set<int> positions;\n        while ((int)positions.size() < n) {\n            positions.insert(rnd.next(1, (int)1e9 - n + 1));\n        }\n        a.assign(positions.begin(), positions.end());\n\n        // Generate m random stop numbers between 1 and n\n        b.resize(m);\n        for (int i = 0; i < m; i++) {\n            b[i] = rnd.next(1, n);\n        }\n        sort(b.begin(), b.end());\n    }\n\n    // Output n\n    printf(\"%d\\n\", n);\n\n    // Output a_i's\n    for (int i = 0; i < n; i++) {\n        printf(\"%d%c\", a[i], (i == n - 1) ? '\\n' : ' ');\n    }\n\n    // Output m\n    printf(\"%d\\n\", (int)b.size());\n\n    // Output b_i's\n    for (int i = 0; i < (int)b.size(); i++) {\n        printf(\"%d%c\", b[i], (i == (int)b.size() - 1) ? '\\n' : ' ');\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type random -n 10 -m 20\n./gen -type random -n 100 -m 200\n./gen -type random -n 1000 -m 2000\n./gen -type random -n 10000 -m 20000\n./gen -type maxN\n./gen -type minN\n./gen -type ambiguous\n./gen -type unique\n./gen -type largeDistances\n./gen -type smallDistances\n./gen -type repeats -n 1000 -m 10000\n./gen -type repeats -n 200000 -m 400000\n./gen -type random -n 200000 -m 400000\n./gen -type largeDistances -n 200000 -m 400000\n./gen -type smallDistances -n 200000 -m 400000\n./gen -type repeats -n 200000 -m 400000\n./gen -type random -n 2 -m 1\n./gen -type random -n 2 -m 4\n./gen -type random -n 3 -m 4\n./gen -type random -n 3 -m 5\n./gen -type random -n 10 -m 100\n./gen -type random -n 50000 -m 100000\n./gen -type random -n 100000 -m 200000\n./gen -type random -n 150000 -m 300000\n./gen -type ambiguous\n./gen -type unique\n./gen -type repeats -n 100000 -m 200000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:52.591271",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "534/F",
      "title": "F. Simplified Nonogram",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputIn the first line there follow two integers n, m (1 ≤ n ≤ 5, 1 ≤ m ≤ 20) — number of rows and number of columns respectively.Second line contains n integers a1, a2, ..., an where ai is the number of contiguous black segments in i-th row of the field. Similarly, third line contains m integers b1, b2, ..., bm where bi is the number of contiguous black segments in the i-th column of the field.It is guaranteed that there exists at least one solution.",
      "output_spec": "OutputOutput any possible solution. Output should consist of n lines each containing m characters. Denote white cell as \".\" and black cell as \"*\".",
      "sample_tests": "ExamplesInputCopy3 52 3 21 0 1 2 1OutputCopy*.**.*.*.**..**InputCopy3 32 1 22 1 2OutputCopy*.*.*.*.*InputCopy3 31 0 12 2 2OutputCopy***...***",
      "description": "F. Simplified Nonogram\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputIn the first line there follow two integers n, m (1 ≤ n ≤ 5, 1 ≤ m ≤ 20) — number of rows and number of columns respectively.Second line contains n integers a1, a2, ..., an where ai is the number of contiguous black segments in i-th row of the field. Similarly, third line contains m integers b1, b2, ..., bm where bi is the number of contiguous black segments in the i-th column of the field.It is guaranteed that there exists at least one solution.\n\nOutputOutput any possible solution. Output should consist of n lines each containing m characters. Denote white cell as \".\" and black cell as \"*\".\n\nInputCopy3 52 3 21 0 1 2 1OutputCopy*.**.*.*.**..**InputCopy3 32 1 22 1 2OutputCopy*.*.*.*.*InputCopy3 31 0 12 2 2OutputCopy***...***\n\nInputCopy3 52 3 21 0 1 2 1\n\nOutputCopy*.**.*.*.**..**\n\nInputCopy3 32 1 22 1 2\n\nOutputCopy*.*.*.*.*\n\nInputCopy3 31 0 12 2 2\n\nOutputCopy***...***",
      "solutions": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces",
          "content": "Hello, Codeforces!I'd like to invite you to Codeforces Round #298 (Div. 2). It will be held on Sunday, April 12 at 19:00 MSK and Div. 1 participants are invited to join out of competition. Problems have been prepared by Maxim Mescheryakov (Neon) and Danil Sagunov (danilka.pro). We hope you'll find them interesting.Great thanks to Maxim Akhmedov (Zlobober) for helping us preparing the contest, to Maria Belova (Delinur) for translating the statements into English, to Mike Mirzayanov (MikeMirzayanov) for the great Codeforces and Polygon systems and ideas of some problems. Also thanks Vitaliy Aksenov (Aksenov239) for writing solutions.You will be given six problems and two and the half hours to solve them.UPD: Scoring system 500-1000-1500-2000-2500-3000UPD2: Competition completed! Thank you all!UPD3: Congratulations to the winners! xuanhien070594 misis Mikagura_Seisa plem 11111111 UPD4: Editorial here",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17366",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 910
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 1",
          "code": "print(sum(min(v1 + d * i, v2 + d * (t - i - 1)) for i in range(t)))",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 2",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 3",
          "code": "while(t--){\n    ans+=v1;\n    v1=min(v1+d,v2+((t-1)*d));\n}\ncout << ans << endl;\nreturn 0;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 4",
          "code": "s.lower_bound(x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 5",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 6",
          "code": "lower_bound(s.begin(), s.end(), x)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 7",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 8",
          "code": "lower_bound()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 9",
          "code": "Scanner.nextInt",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 10",
          "code": "Scanner.nextLong()",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 11",
          "code": "Integer.parseInt(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #298 (Div. 2) - Codeforces - Code 12",
          "code": "Long.parseLong(sc.next())",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17366",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, m, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(m, 0, n, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, m, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(m, 0, n, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 5, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(1, 20, \"m\");\n    inf.readEoln();\n\n    vector<int> ai = inf.readInts(n, 0, m, \"ai\");\n    inf.readEoln();\n\n    vector<int> bi = inf.readInts(m, 0, n, \"bi\");\n    inf.readEoln();\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = inf.readInt();\n    int m = inf.readInt();\n\n    vector<int> row_seg_counts = inf.readInts(n, 0, m);\n    vector<int> col_seg_counts = inf.readInts(m, 0, n);\n\n    vector<string> grid(n);\n    for (int i = 0; i < n; ++i) {\n        string line = ouf.readLine();\n        if (int(line.length()) != m) {\n            quitf(_wa, \"Line %d has length %d, expected %d\", i + 1, int(line.length()), m);\n        }\n        for (int j = 0; j < m; ++j) {\n            char c = line[j];\n            if (c != '.' && c != '*') {\n                quitf(_wa, \"Invalid character '%c' at line %d, column %d\", c, i + 1, j + 1);\n            }\n        }\n        grid[i] = line;\n    }\n\n    // Check rows\n    for (int i = 0; i < n; ++i) {\n        int segs = 0;\n        bool inSegment = false;\n        for (int j = 0; j < m; ++j) {\n            char c = grid[i][j];\n            if (c == '*') {\n                if (!inSegment) {\n                    inSegment = true;\n                    segs++;\n                }\n            } else {\n                inSegment = false;\n            }\n        }\n        if (segs != row_seg_counts[i]) {\n            quitf(_wa, \"Row %d has %d segments, expected %d\", i + 1, segs, row_seg_counts[i]);\n        }\n    }\n\n    // Check columns\n    for (int j = 0; j < m; ++j) {\n        int segs = 0;\n        bool inSegment = false;\n        for (int i = 0; i < n; ++i) {\n            char c = grid[i][j];\n            if (c == '*') {\n                if (!inSegment) {\n                    inSegment = true;\n                    segs++;\n                }\n            } else {\n                inSegment = false;\n            }\n        }\n        if (segs != col_seg_counts[j]) {\n            quitf(_wa, \"Column %d has %d segments, expected %d\", j + 1, segs, col_seg_counts[j]);\n        }\n    }\n\n    quitf(_ok, \"Solution is correct\");\n}\n",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // All white cells\n        // grid is already initialized with '.'\n    } else if (type == \"full\") {\n        // All black cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n    } else if (type == \"checkerboard\") {\n        // Alternating pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? '*' : '.';\n    } else if (type == \"single_black_cell\") {\n        // Only one black cell\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '*';\n    } else if (type == \"random\") {\n        // Random grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (rnd.next(0, 1) ? '*' : '.');\n    } else if (type == \"long_segments\") {\n        // Each row has one long black segment\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, m);\n            int start = rnd.next(0, m - len);\n            for (int j = start; j < start + len; ++j)\n                grid[i][j] = '*';\n        }\n    }\n\n    // Compute ai and bi\n    vector<int> ai(n); // number of contiguous black segments in each row\n    vector<int> bi(m); // number of contiguous black segments in each column\n\n    for (int i = 0; i < n; ++i) {\n        int cnt = 0;\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '*') {\n                if (j == 0 || grid[i][j - 1] != '*')\n                    ++cnt;\n            }\n        }\n        ai[i] = cnt;\n    }\n\n    for (int j = 0; j < m; ++j) {\n        int cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            if (grid[i][j] == '*') {\n                if (i == 0 || grid[i - 1][j] != '*')\n                    ++cnt;\n            }\n        }\n        bi[j] = cnt;\n    }\n\n    // Output the input data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n    for (int j = 0; j < m; ++j) {\n        if (j > 0) printf(\" \");\n        printf(\"%d\", bi[j]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n\n    vector<string> grid(n, string(m, '.'));\n\n    if (type == \"empty\") {\n        // All white cells\n        // grid is already initialized with '.'\n    } else if (type == \"full\") {\n        // All black cells\n        for (int i = 0; i < n; ++i)\n            grid[i] = string(m, '*');\n    } else if (type == \"checkerboard\") {\n        // Alternating pattern\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = ((i + j) % 2 == 0) ? '*' : '.';\n    } else if (type == \"single_black_cell\") {\n        // Only one black cell\n        int x = rnd.next(0, n - 1);\n        int y = rnd.next(0, m - 1);\n        grid[x][y] = '*';\n    } else if (type == \"random\") {\n        // Random grid\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                grid[i][j] = (rnd.next(0, 1) ? '*' : '.');\n    } else if (type == \"long_segments\") {\n        // Each row has one long black segment\n        for (int i = 0; i < n; ++i) {\n            int len = rnd.next(1, m);\n            int start = rnd.next(0, m - len);\n            for (int j = start; j < start + len; ++j)\n                grid[i][j] = '*';\n        }\n    }\n\n    // Compute ai and bi\n    vector<int> ai(n); // number of contiguous black segments in each row\n    vector<int> bi(m); // number of contiguous black segments in each column\n\n    for (int i = 0; i < n; ++i) {\n        int cnt = 0;\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == '*') {\n                if (j == 0 || grid[i][j - 1] != '*')\n                    ++cnt;\n            }\n        }\n        ai[i] = cnt;\n    }\n\n    for (int j = 0; j < m; ++j) {\n        int cnt = 0;\n        for (int i = 0; i < n; ++i) {\n            if (grid[i][j] == '*') {\n                if (i == 0 || grid[i - 1][j] != '*')\n                    ++cnt;\n            }\n        }\n        bi[j] = cnt;\n    }\n\n    // Output the input data\n    printf(\"%d %d\\n\", n, m);\n    for (int i = 0; i < n; ++i) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", ai[i]);\n    }\n    printf(\"\\n\");\n    for (int j = 0; j < m; ++j) {\n        if (j > 0) printf(\" \");\n        printf(\"%d\", bi[j]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -m 1 -type empty\n./gen -n 1 -m 1 -type full\n./gen -n 1 -m 1 -type single_black_cell\n\n./gen -n 1 -m 20 -type empty\n./gen -n 1 -m 20 -type full\n./gen -n 1 -m 20 -type random\n\n./gen -n 5 -m 1 -type empty\n./gen -n 5 -m 1 -type full\n./gen -n 5 -m 1 -type random\n\n./gen -n 5 -m 20 -type empty\n./gen -n 5 -m 20 -type full\n./gen -n 5 -m 20 -type random\n\n./gen -n 2 -m 2 -type checkerboard\n./gen -n 3 -m 3 -type checkerboard\n./gen -n 4 -m 4 -type checkerboard\n./gen -n 5 -m 5 -type checkerboard\n\n./gen -n 3 -m 5 -type long_segments\n./gen -n 5 -m 10 -type long_segments\n\n./gen -n 3 -m 5 -type random\n./gen -n 3 -m 5 -type random\n./gen -n 3 -m 5 -type random\n\n./gen -n 5 -m 20 -type random\n./gen -n 5 -m 20 -type random\n./gen -n 5 -m 20 -type random\n\n./gen -n 5 -m 20 -type single_black_cell\n./gen -n 5 -m 20 -type single_black_cell\n./gen -n 5 -m 20 -type single_black_cell\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:54.741407",
        "total_tutorials": 1,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "535/A",
      "title": "A. Tavas and Nafas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first and only line of input contains an integer s (0 ≤ s ≤ 99), Tavas's score.",
      "output_spec": "OutputIn the first and only line of output, print a single string consisting only from English lowercase letters and hyphens ('-'). Do not use spaces.",
      "sample_tests": "ExamplesInputCopy6OutputCopysixInputCopy99OutputCopyninety-nineInputCopy20OutputCopytwenty",
      "description": "A. Tavas and Nafas\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first and only line of input contains an integer s (0 ≤ s ≤ 99), Tavas's score.\n\nOutputIn the first and only line of output, print a single string consisting only from English lowercase letters and hyphens ('-'). Do not use spaces.\n\nInputCopy6OutputCopysixInputCopy99OutputCopyninety-nineInputCopy20OutputCopytwenty\n\nOutputCopysix\n\nInputCopy99\n\nOutputCopyninety-nine\n\nInputCopy20\n\nOutputCopytwenty\n\nNoteYou can find all you need to know about English numerals in http://en.wikipedia.org/wiki/English_numerals .",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 535\\s*A"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int s = inf.readInt(0, 99, \"s\");\n    string rest = inf.readLine();\n    ensuref(rest.empty(), \"Extra characters after integer s\");\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int s = inf.readInt(0, 99, \"s\");\n    string rest = inf.readLine();\n    ensuref(rest.empty(), \"Extra characters after integer s\");\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int s = inf.readInt(0, 99, \"s\");\n    string rest = inf.readLine();\n    ensuref(rest.empty(), \"Extra characters after integer s\");\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare files as sequence of lines\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    std::string strAnswer;\r\n\r\n    int n = 0;\r\n    while (!ans.eof()) {\r\n        std::string j = ans.readString();\r\n\r\n        if (j.empty() && ans.eof())\r\n            break;\r\n\r\n        strAnswer = j;\r\n        std::string p = ouf.readString();\r\n\r\n        n++;\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s lines differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (n == 1)\r\n        quitf(_ok, \"single line: '%s'\", compress(strAnswer).c_str());\r\n\r\n    quitf(_ok, \"%d lines\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    if (s == -1) {\n        // s not specified, generate s according to type\n        if (type == \"zero\") {\n            s = 0;\n        } else if (type == \"single\") {\n            s = rnd.next(1, 9);\n        } else if (type == \"teen\") {\n            s = rnd.next(10, 19);\n        } else if (type == \"tens\") {\n            int tens[] = {20,30,40,50,60,70,80,90};\n            s = tens[rnd.next(0,7)];\n        } else if (type == \"composite\") {\n            s = rnd.next(21,99);\n            while (s % 10 == 0) {\n                s = rnd.next(21,99);\n            }\n        } else if (type == \"min\") {\n            s = 0;\n        } else if (type == \"max\") {\n            s = 99;\n        } else if (type == \"random\") {\n            s = rnd.next(0,99);\n        } else {\n            s = rnd.next(0,99);\n        }\n    }\n    // Ensure s is within 0 to 99\n    s = max(0, min(s, 99));\n    printf(\"%d\\n\", s);\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int s = opt<int>(\"s\", -1);\n    string type = opt<string>(\"type\", \"random\");\n    if (s == -1) {\n        // s not specified, generate s according to type\n        if (type == \"zero\") {\n            s = 0;\n        } else if (type == \"single\") {\n            s = rnd.next(1, 9);\n        } else if (type == \"teen\") {\n            s = rnd.next(10, 19);\n        } else if (type == \"tens\") {\n            int tens[] = {20,30,40,50,60,70,80,90};\n            s = tens[rnd.next(0,7)];\n        } else if (type == \"composite\") {\n            s = rnd.next(21,99);\n            while (s % 10 == 0) {\n                s = rnd.next(21,99);\n            }\n        } else if (type == \"min\") {\n            s = 0;\n        } else if (type == \"max\") {\n            s = 99;\n        } else if (type == \"random\") {\n            s = rnd.next(0,99);\n        } else {\n            s = rnd.next(0,99);\n        }\n    }\n    // Ensure s is within 0 to 99\n    s = max(0, min(s, 99));\n    printf(\"%d\\n\", s);\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Edge cases\n./gen -s 0\n./gen -s 99\n\n# Single digits (1 to 9)\n./gen -s 1\n./gen -s 5\n./gen -s 9\n\n# Teens (10 to 19)\n./gen -s 10\n./gen -s 13\n./gen -s 19\n\n# Tens (multiples of 10)\n./gen -s 20\n./gen -s 30\n./gen -s 40\n./gen -s 50\n./gen -s 60\n./gen -s 70\n./gen -s 80\n./gen -s 90\n\n# Composite numbers (tens + units)\n./gen -s 21\n./gen -s 34\n./gen -s 45\n./gen -s 56\n./gen -s 67\n./gen -s 78\n./gen -s 89\n./gen -s 98\n\n# Random numbers\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n./gen -type random\n\n# Test min and max via type parameter\n./gen -type min\n./gen -type max\n\n# Test zero and single via type parameter\n./gen -type zero\n./gen -type single\n\n# Test teens via type parameter\n./gen -type teen\n\n# Test tens via type parameter\n./gen -type tens\n\n# Test composite via type parameter\n./gen -type composite\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:56.877331",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "535/B",
      "title": "B. Тавас и СаДДас",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой и единственной строке следует счастливое число n (1 ≤ n ≤ 109).",
      "output_spec": "Выходные данныеВыведите позицию, на которой n находится среди всех счастливых чисел.",
      "sample_tests": "ПримерыВходные данныеСкопировать4Выходные данныеСкопировать1Входные данныеСкопировать7Выходные данныеСкопировать2Входные данныеСкопировать77Выходные данныеСкопировать6",
      "description": "B. Тавас и СаДДас\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой и единственной строке следует счастливое число n (1 ≤ n ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите позицию, на которой n находится среди всех счастливых чисел.\n\nВыходные данные\n\nВходные данныеСкопировать4Выходные данныеСкопировать1Входные данныеСкопировать7Выходные данныеСкопировать2Входные данныеСкопировать77Выходные данныеСкопировать6\n\nВходные данныеСкопировать4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать7\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать2\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать77\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать6\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 535\\s*B"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n\n    string s = to_string(n);\n    for (char c : s) {\n        ensuref(c == '4' || c == '7', \"All digits of n must be '4' or '7'\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n\n    string s = to_string(n);\n    for (char c : s) {\n        ensuref(c == '4' || c == '7', \"All digits of n must be '4' or '7'\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000000, \"n\");\n    inf.readEoln();\n\n    string s = to_string(n);\n    for (char c : s) {\n        ensuref(c == '4' || c == '7', \"All digits of n must be '4' or '7'\");\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> lucky_numbers;\n\n// Precompute all lucky numbers up to 1e9\nvoid generate_lucky_numbers(long long current_number = 0) {\n    if (current_number > 1e9) return;\n    if (current_number > 0) lucky_numbers.push_back(current_number);\n    generate_lucky_numbers(current_number * 10 + 4);\n    generate_lucky_numbers(current_number * 10 + 7);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int length = opt<int>(\"length\", 0); // 0 means any length\n    bool only4 = opt<bool>(\"only4\", false);\n    bool only7 = opt<bool>(\"only7\", false);\n    bool mix47 = opt<bool>(\"mix47\", false);\n\n    generate_lucky_numbers();\n    sort(lucky_numbers.begin(), lucky_numbers.end());\n\n    vector<long long> candidates;\n\n    // Filter lucky_numbers based on parameters\n    for (auto num : lucky_numbers) {\n        string s = to_string(num);\n        if (length != 0 && (int)s.length() != length)\n            continue;\n        if (only4 && s.find('7') != string::npos)\n            continue;\n        if (only7 && s.find('4') != string::npos)\n            continue;\n        if (mix47 && (s.find('4') == string::npos || s.find('7') == string::npos))\n            continue;\n        candidates.push_back(num);\n    }\n\n    // Ensure that there are candidates\n    if (candidates.empty()) {\n        fprintf(stderr, \"No candidates with given parameters.\\n\");\n        exit(1);\n    }\n\n    // Output depending on type\n    if (type == \"min\") {\n        printf(\"%lld\\n\", candidates.front());\n    } else if (type == \"max\") {\n        printf(\"%lld\\n\", candidates.back());\n    } else if (type == \"random\") {\n        long long num = candidates[rnd.next(0, (int)candidates.size()-1)];\n        printf(\"%lld\\n\", num);\n    } else {\n        // Default case, output a random lucky number\n        long long num = lucky_numbers[rnd.next(0, (int)lucky_numbers.size()-1)];\n        printf(\"%lld\\n\", num);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nvector<long long> lucky_numbers;\n\n// Precompute all lucky numbers up to 1e9\nvoid generate_lucky_numbers(long long current_number = 0) {\n    if (current_number > 1e9) return;\n    if (current_number > 0) lucky_numbers.push_back(current_number);\n    generate_lucky_numbers(current_number * 10 + 4);\n    generate_lucky_numbers(current_number * 10 + 7);\n}\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    string type = opt<string>(\"type\", \"random\");\n    int length = opt<int>(\"length\", 0); // 0 means any length\n    bool only4 = opt<bool>(\"only4\", false);\n    bool only7 = opt<bool>(\"only7\", false);\n    bool mix47 = opt<bool>(\"mix47\", false);\n\n    generate_lucky_numbers();\n    sort(lucky_numbers.begin(), lucky_numbers.end());\n\n    vector<long long> candidates;\n\n    // Filter lucky_numbers based on parameters\n    for (auto num : lucky_numbers) {\n        string s = to_string(num);\n        if (length != 0 && (int)s.length() != length)\n            continue;\n        if (only4 && s.find('7') != string::npos)\n            continue;\n        if (only7 && s.find('4') != string::npos)\n            continue;\n        if (mix47 && (s.find('4') == string::npos || s.find('7') == string::npos))\n            continue;\n        candidates.push_back(num);\n    }\n\n    // Ensure that there are candidates\n    if (candidates.empty()) {\n        fprintf(stderr, \"No candidates with given parameters.\\n\");\n        exit(1);\n    }\n\n    // Output depending on type\n    if (type == \"min\") {\n        printf(\"%lld\\n\", candidates.front());\n    } else if (type == \"max\") {\n        printf(\"%lld\\n\", candidates.back());\n    } else if (type == \"random\") {\n        long long num = candidates[rnd.next(0, (int)candidates.size()-1)];\n        printf(\"%lld\\n\", num);\n    } else {\n        // Default case, output a random lucky number\n        long long num = lucky_numbers[rnd.next(0, (int)lucky_numbers.size()-1)];\n        printf(\"%lld\\n\", num);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -type min\n./gen -type max\n\n./gen -length 1 -type min\n./gen -length 1 -type max\n./gen -length 1 -type random\n\n./gen -length 2 -type min\n./gen -length 2 -type max\n./gen -length 2 -type random\n\n./gen -only4 -type min\n./gen -only4 -type max\n./gen -only4 -type random\n\n./gen -only7 -type min\n./gen -only7 -type max\n./gen -only7 -type random\n\n./gen -mix47 -type min\n./gen -mix47 -type max\n./gen -mix47 -type random\n\n./gen -length 9 -type max\n./gen -length 9 -type random\n\n./gen -length 3 -only4 -type random\n./gen -length 3 -only7 -type random\n./gen -length 3 -mix47 -type random\n\n./gen -length 5 -type random\n./gen -length 7 -mix47 -type random\n\n./gen -length 9 -type random\n./gen -only4 -length 9 -type random\n./gen -only7 -length 9 -type random\n\n./gen -type random\n./gen -type random\n\n./gen -length 8 -type random\n./gen -length 4 -only4 -type max\n./gen -length 4 -only7 -type min\n\n./gen -type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:44:59.008263",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "535/C",
      "title": "C. Tavas and Karafs",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains three integers A, B and n (1 ≤ A, B ≤ 106, 1 ≤ n ≤ 105).Next n lines contain information about queries. i-th line contains integers l, t, m (1 ≤ l, t, m ≤ 106) for i-th query.",
      "output_spec": "OutputFor each query, print its answer in a single line.",
      "sample_tests": "ExamplesInputCopy2 1 41 5 33 3 107 10 26 4 8OutputCopy4-18-1InputCopy1 5 21 5 102 7 4OutputCopy12",
      "description": "C. Tavas and Karafs\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains three integers A, B and n (1 ≤ A, B ≤ 106, 1 ≤ n ≤ 105).Next n lines contain information about queries. i-th line contains integers l, t, m (1 ≤ l, t, m ≤ 106) for i-th query.\n\nOutputFor each query, print its answer in a single line.\n\nInputCopy2 1 41 5 33 3 107 10 26 4 8OutputCopy4-18-1InputCopy1 5 21 5 102 7 4OutputCopy12\n\nInputCopy2 1 41 5 33 3 107 10 26 4 8\n\nOutputCopy4-18-1\n\nInputCopy1 5 21 5 102 7 4\n\nOutputCopy12",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 535 和字母"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int B = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for(int i=0;i<n;++i){\n        int l = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int t = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int B = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for(int i=0;i<n;++i){\n        int l = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int t = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int B = inf.readInt(1, 1000000);\n    inf.readSpace();\n    int n = inf.readInt(1, 100000);\n    inf.readEoln();\n\n    for(int i=0;i<n;++i){\n        int l = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int t = inf.readInt(1, 1000000);\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000);\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000); // Default n = 1000\n    string type = opt<string>(\"type\", \"random\");\n\n    int A = opt<int>(\"A\", -1);   // Default A = random\n    int B = opt<int>(\"B\", -1);   // Default B = random\n\n    // Generate A and B according to the type or use provided values\n    if (A == -1) {\n        if (type == \"max_values\") {\n            A = 1000000;\n        } else if (type == \"min_values\") {\n            A = 1;\n        } else {\n            A = rnd.next(1, 1000000);\n        }\n    }\n    if (B == -1) {\n        if (type == \"max_values\") {\n            B = 1000000;\n        } else if (type == \"min_values\") {\n            B = 1;\n        } else {\n            B = rnd.next(1, 1000000);\n        }\n    }\n\n    // Adjust n according to the type if necessary\n    if (type == \"random_small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"random_large\" || type == \"max_values\") {\n        n = 100000;\n    }\n\n    vector<tuple<int, int, int>> queries;\n\n    // Generate queries according to the type\n    if (type == \"random_small\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 100);\n            int t = rnd.next(1, 100);\n            int m = rnd.next(1, 100);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"random_large\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            int l = 1000000;\n            int t = 1000000;\n            int m = 1000000;\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"t_small\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            long long s_l = (long long)A + (long long)(l - 1) * B;\n            int t = max(1, (int)min((long long)1000000, s_l - rnd.next(0, 10)));\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"t_large\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = 1000000;\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"m_small\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = 1;\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"m_large\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = 1000000;\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"edge_l\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1000000 - 1000, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"edge_l1\") {\n        for (int i = 0; i < n; ++i) {\n            int l = 1;\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else {\n        // Default random type\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    }\n\n    // Output A, B, and n\n    printf(\"%d %d %d\\n\", A, B, n);\n\n    // Output the queries\n    for (auto& q : queries) {\n        int l, t, m;\n        tie(l, t, m) = q;\n        printf(\"%d %d %d\\n\", l, t, m);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\", 1000); // Default n = 1000\n    string type = opt<string>(\"type\", \"random\");\n\n    int A = opt<int>(\"A\", -1);   // Default A = random\n    int B = opt<int>(\"B\", -1);   // Default B = random\n\n    // Generate A and B according to the type or use provided values\n    if (A == -1) {\n        if (type == \"max_values\") {\n            A = 1000000;\n        } else if (type == \"min_values\") {\n            A = 1;\n        } else {\n            A = rnd.next(1, 1000000);\n        }\n    }\n    if (B == -1) {\n        if (type == \"max_values\") {\n            B = 1000000;\n        } else if (type == \"min_values\") {\n            B = 1;\n        } else {\n            B = rnd.next(1, 1000000);\n        }\n    }\n\n    // Adjust n according to the type if necessary\n    if (type == \"random_small\") {\n        n = rnd.next(1, 10);\n    } else if (type == \"random_large\" || type == \"max_values\") {\n        n = 100000;\n    }\n\n    vector<tuple<int, int, int>> queries;\n\n    // Generate queries according to the type\n    if (type == \"random_small\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 100);\n            int t = rnd.next(1, 100);\n            int m = rnd.next(1, 100);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"random_large\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"max_values\") {\n        for (int i = 0; i < n; ++i) {\n            int l = 1000000;\n            int t = 1000000;\n            int m = 1000000;\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"t_small\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            long long s_l = (long long)A + (long long)(l - 1) * B;\n            int t = max(1, (int)min((long long)1000000, s_l - rnd.next(0, 10)));\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"t_large\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = 1000000;\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"m_small\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = 1;\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"m_large\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = 1000000;\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"edge_l\") {\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1000000 - 1000, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else if (type == \"edge_l1\") {\n        for (int i = 0; i < n; ++i) {\n            int l = 1;\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    } else {\n        // Default random type\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            queries.push_back(make_tuple(l, t, m));\n        }\n    }\n\n    // Output A, B, and n\n    printf(\"%d %d %d\\n\", A, B, n);\n\n    // Output the queries\n    for (auto& q : queries) {\n        int l, t, m;\n        tie(l, t, m) = q;\n        printf(\"%d %d %d\\n\", l, t, m);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random_small\n./gen -n 10 -type random_small\n\n./gen -n 100000 -type random_large\n\n./gen -n 100000 -type max_values\n\n./gen -n 1000 -type t_small\n\n./gen -n 1000 -type t_large\n\n./gen -n 1000 -type m_small\n\n./gen -n 1000 -type m_large\n\n./gen -n 1000 -type edge_l\n\n./gen -n 1000 -type edge_l1\n\n./gen -n 100000 -type random\n\n./gen -n 1000 -type min_values\n\n./gen -n 1000 -type random -A 1000000\n\n./gen -n 1000 -type random -B 1000000\n\n./gen -n 1000 -type random -A 1 -B 1\n\n./gen -n 1000 -type random -A 100 -B 100\n\n./gen -n 1000 -type random -A 1000000 -B 1\n\n./gen -n 1000 -type random -A 1 -B 1000000\n\n./gen -n 100000 -type random -A 1000000 -B 1000000\n\n./gen -n 50000 -type t_small -A 1000000 -B 1000000\n\n./gen -n 50000 -type m_small -A 1000000 -B 1000000\n\n./gen -n 100000 -type edge_l -A 1000000 -B 1\n\n./gen -n 100000 -type edge_l1 -A 1 -B 1000000\n\n./gen -n 100000 -type random_small -A 1 -B 1\n\n./gen -n 100000 -type random_large\n\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:01.349746",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "535/D",
      "title": "D. Tavas and Malekas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m, the length of s and the length of the subsequence Malekas wrote down (1 ≤ n ≤ 106 and 0 ≤ m ≤ n - |p| + 1).The second line contains string p (1 ≤ |p| ≤ n).The next line contains m space separated integers y1, y2, ..., ym, Malekas' subsequence (1 ≤ y1 < y2 < ... < ym ≤ n - |p| + 1).",
      "output_spec": "OutputIn a single line print the answer modulo 1000 000 007.",
      "sample_tests": "ExamplesInputCopy6 2ioi1 3OutputCopy26InputCopy5 2ioi1 2OutputCopy0",
      "description": "D. Tavas and Malekas\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m, the length of s and the length of the subsequence Malekas wrote down (1 ≤ n ≤ 106 and 0 ≤ m ≤ n - |p| + 1).The second line contains string p (1 ≤ |p| ≤ n).The next line contains m space separated integers y1, y2, ..., ym, Malekas' subsequence (1 ≤ y1 < y2 < ... < ym ≤ n - |p| + 1).\n\nOutputIn a single line print the answer modulo 1000 000 007.\n\nInputCopy6 2ioi1 3OutputCopy26InputCopy5 2ioi1 2OutputCopy0\n\nInputCopy6 2ioi1 3\n\nOutputCopy26\n\nInputCopy5 2ioi1 2\n\nOutputCopy0\n\nNoteIn the first sample test all strings of form \"ioioi?\" where the question mark replaces arbitrary English letter satisfy.Here |x| denotes the length of string x.Please note that it's possible that there is no such string (answer is 0).",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 535 和字母"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n\n    string p = inf.readToken(\"[a-z]+\", \"p\");\n    int p_len = p.length();\n    ensuref(p_len >= 1 && p_len <= n, \"Length of p must be between 1 and n\");\n    inf.readEoln();\n\n    int L = n - p_len + 1;\n    ensuref(m >= 0 && m <= L, \"m must be between 0 and n - |p| +1\");\n\n    if (m > 0) {\n        vector<int> y = inf.readInts(m, 1, L, \"y_i\");\n        for (int i = 1; i < m; i++) {\n            ensuref(y[i-1] < y[i], \"Positions y_i must be strictly increasing\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n\n    string p = inf.readToken(\"[a-z]+\", \"p\");\n    int p_len = p.length();\n    ensuref(p_len >= 1 && p_len <= n, \"Length of p must be between 1 and n\");\n    inf.readEoln();\n\n    int L = n - p_len + 1;\n    ensuref(m >= 0 && m <= L, \"m must be between 0 and n - |p| +1\");\n\n    if (m > 0) {\n        vector<int> y = inf.readInts(m, 1, L, \"y_i\");\n        for (int i = 1; i < m; i++) {\n            ensuref(y[i-1] < y[i], \"Positions y_i must be strictly increasing\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n\n    string p = inf.readToken(\"[a-z]+\", \"p\");\n    int p_len = p.length();\n    ensuref(p_len >= 1 && p_len <= n, \"Length of p must be between 1 and n\");\n    inf.readEoln();\n\n    int L = n - p_len + 1;\n    ensuref(m >= 0 && m <= L, \"m must be between 0 and n - |p| +1\");\n\n    if (m > 0) {\n        vector<int> y = inf.readInts(m, 1, L, \"y_i\");\n        for (int i = 1; i < m; i++) {\n            ensuref(y[i-1] < y[i], \"Positions y_i must be strictly increasing\");\n        }\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p_len = opt<int>(\"p_len\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    int m = opt<int>(\"m\");\n    string m_type = opt<string>(\"m_type\", \"random\");\n\n    // Adjust p_len if p_type is 'max_length'\n    if (p_type == \"max_length\") {\n        p_len = n;\n    }\n\n    // Ensure p_len is within bounds\n    p_len = min(p_len, n);\n    p_len = max(p_len, 1);\n\n    // Generate string p based on p_type\n    string p;\n    if (p_type == \"single_char\") {\n        char c = 'a' + rnd.next(26); // Random lowercase letter\n        p = string(p_len, c);\n    } else { // 'random' or 'max_length'\n        for (int i = 0; i < p_len; ++i) {\n            char c = 'a' + rnd.next(26);\n            p += c;\n        }\n    }\n\n    int max_pos = n - p_len + 1;\n    // Ensure m is within valid range\n    m = min(m, max(0, max_pos));\n\n    vector<int> positions;\n\n    if (m_type == \"random\") {\n        // Select m random positions without repetition\n        for (int i = 1; i <= max_pos; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(m);\n        sort(positions.begin(), positions.end());\n    } else if (m_type == \"overlapping\") {\n        // Start positions that are consecutive to cause overlap\n        int start_pos = 1;\n        for (int i = 0; i < m && start_pos <= max_pos; ++i, ++start_pos) {\n            positions.push_back(start_pos);\n        }\n    } else if (m_type == \"impossible\") {\n        // Create positions that make the problem impossible\n        // For overlapping positions with conflicting characters\n        if (p_len < 2 || max_pos < 2) {\n            // Not enough length to create impossible case\n            positions.clear();\n            m = 0;\n        } else {\n            // Ensure p[0] != p[1] to create conflict\n            char c1 = 'a' + rnd.next(26);\n            char c2;\n            do {\n                c2 = 'a' + rnd.next(26);\n            } while (c2 == c1);\n            p[0] = c1;\n            p[1] = c2;\n            positions.push_back(1);\n            positions.push_back(2);\n            m = 2;\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output p\n    printf(\"%s\\n\", p.c_str());\n    // Output positions if m > 0\n    if (m > 0) {\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) putchar(' ');\n            printf(\"%d\", positions[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int p_len = opt<int>(\"p_len\");\n    string p_type = opt<string>(\"p_type\", \"random\");\n    int m = opt<int>(\"m\");\n    string m_type = opt<string>(\"m_type\", \"random\");\n\n    // Adjust p_len if p_type is 'max_length'\n    if (p_type == \"max_length\") {\n        p_len = n;\n    }\n\n    // Ensure p_len is within bounds\n    p_len = min(p_len, n);\n    p_len = max(p_len, 1);\n\n    // Generate string p based on p_type\n    string p;\n    if (p_type == \"single_char\") {\n        char c = 'a' + rnd.next(26); // Random lowercase letter\n        p = string(p_len, c);\n    } else { // 'random' or 'max_length'\n        for (int i = 0; i < p_len; ++i) {\n            char c = 'a' + rnd.next(26);\n            p += c;\n        }\n    }\n\n    int max_pos = n - p_len + 1;\n    // Ensure m is within valid range\n    m = min(m, max(0, max_pos));\n\n    vector<int> positions;\n\n    if (m_type == \"random\") {\n        // Select m random positions without repetition\n        for (int i = 1; i <= max_pos; ++i) {\n            positions.push_back(i);\n        }\n        shuffle(positions.begin(), positions.end());\n        positions.resize(m);\n        sort(positions.begin(), positions.end());\n    } else if (m_type == \"overlapping\") {\n        // Start positions that are consecutive to cause overlap\n        int start_pos = 1;\n        for (int i = 0; i < m && start_pos <= max_pos; ++i, ++start_pos) {\n            positions.push_back(start_pos);\n        }\n    } else if (m_type == \"impossible\") {\n        // Create positions that make the problem impossible\n        // For overlapping positions with conflicting characters\n        if (p_len < 2 || max_pos < 2) {\n            // Not enough length to create impossible case\n            positions.clear();\n            m = 0;\n        } else {\n            // Ensure p[0] != p[1] to create conflict\n            char c1 = 'a' + rnd.next(26);\n            char c2;\n            do {\n                c2 = 'a' + rnd.next(26);\n            } while (c2 == c1);\n            p[0] = c1;\n            p[1] = c2;\n            positions.push_back(1);\n            positions.push_back(2);\n            m = 2;\n        }\n    }\n\n    // Output n and m\n    printf(\"%d %d\\n\", n, m);\n    // Output p\n    printf(\"%s\\n\", p.c_str());\n    // Output positions if m > 0\n    if (m > 0) {\n        for (int i = 0; i < m; ++i) {\n            if (i > 0) putchar(' ');\n            printf(\"%d\", positions[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 1 -p_len 1 -p_type random -m 0 -m_type random\n./gen -n 1 -p_len 1 -p_type single_char -m 0 -m_type random\n./gen -n 10 -p_len 3 -p_type random -m 0 -m_type random\n./gen -n 10 -p_len 3 -p_type single_char -m 2 -m_type overlapping\n./gen -n 100 -p_len 2 -p_type random -m 2 -m_type impossible\n./gen -n 1000 -p_len 1 -p_type random -m 0 -m_type random\n./gen -n 1000 -p_len 1 -p_type random -m 1000 -m_type random\n./gen -n 1000 -p_len 1 -p_type single_char -m 999 -m_type random\n./gen -n 1000 -p_len 500 -p_type max_length -m 1 -m_type random\n./gen -n 1000 -p_len 1000 -p_type max_length -m 1 -m_type random\n./gen -n 10000 -p_len 5000 -p_type random -m 10 -m_type random\n./gen -n 10000 -p_len 2 -p_type single_char -m 9999 -m_type overlapping\n./gen -n 100000 -p_len 2 -p_type random -m 2 -m_type impossible\n./gen -n 100000 -p_len 3 -p_type random -m 10000 -m_type random\n./gen -n 100000 -p_len 100000 -p_type max_length -m 1 -m_type random\n./gen -n 1000000 -p_len 1 -p_type random -m 0 -m_type random\n./gen -n 1000000 -p_len 1 -p_type single_char -m 1000000 -m_type random\n./gen -n 1000000 -p_len 2 -p_type single_char -m 999999 -m_type overlapping\n./gen -n 1000000 -p_len 2 -p_type random -m 2 -m_type impossible\n./gen -n 1000000 -p_len 1000 -p_type random -m 1000 -m_type random\n./gen -n 1000000 -p_len 999999 -p_type random -m 1 -m_type random\n./gen -n 1 -p_len 1 -p_type random -m 1 -m_type random\n./gen -n 500000 -p_len 250000 -p_type single_char -m 1000 -m_type random\n./gen -n 10 -p_len 5 -p_type random -m 6 -m_type random\n./gen -n 10 -p_len 5 -p_type random -m 0 -m_type random\n./gen -n 20 -p_len 7 -p_type random -m 5 -m_type overlapping\n./gen -n 15 -p_len 5 -p_type random -m 3 -m_type impossible\n./gen -n 100 -p_len 1 -p_type random -m 50 -m_type random\n./gen -n 1000000 -p_len 1000000 -p_type max_length -m 0 -m_type random\n./gen -n 1000000 -p_len 1 -p_type random -m 0 -m_type random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:03.271653",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "535/E",
      "title": "E. Tavas and Pashmaks",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test1 second",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line of input contains a single integer n (1 ≤ n ≤ 2 × 105).The next n lines contain the details of competitors. i-th line contains two integers si and ri (1 ≤ si, ri ≤ 104).",
      "output_spec": "OutputIn the first and the only line of output, print a sequence of numbers of possible winners in increasing order.",
      "sample_tests": "ExamplesInputCopy31 32 23 1OutputCopy1 2 3 InputCopy31 21 12 1OutputCopy1 3",
      "description": "E. Tavas and Pashmaks\n\ntime limit per test1 second\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line of input contains a single integer n (1 ≤ n ≤ 2 × 105).The next n lines contain the details of competitors. i-th line contains two integers si and ri (1 ≤ si, ri ≤ 104).\n\nOutputIn the first and the only line of output, print a sequence of numbers of possible winners in increasing order.\n\nInputCopy31 32 23 1OutputCopy1 2 3 InputCopy31 21 12 1OutputCopy1 3\n\nInputCopy31 32 23 1\n\nOutputCopy1 2 3\n\nInputCopy31 21 12 1\n\nOutputCopy1 3",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.6,
            "reason": "宽松匹配: 包含题目编号 535 和字母"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int si = inf.readInt(1, 10000, \"s\" + to_string(i + 1));\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"r\" + to_string(i + 1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int si = inf.readInt(1, 10000, \"s\" + to_string(i + 1));\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"r\" + to_string(i + 1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n\n    for (int i = 0; i < n; ++i) {\n        int si = inf.readInt(1, 10000, \"s\" + to_string(i + 1));\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"r\" + to_string(i + 1));\n        inf.readEoln();\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Random s_i and r_i\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, 10000);\n            int r = rnd.next(1, 10000);\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"max_speed\") {\n        // All s_i and r_i are maximum values\n        for (int i = 0; i < n; ++i) {\n            printf(\"10000 10000\\n\");\n        }\n    } \n    else if (type == \"min_speed\") {\n        // All s_i and r_i are minimum values\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } \n    else if (type == \"same_speeds\") {\n        // All s_i's are the same, r_i's are random\n        int s = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(1, 10000);\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"equal_speeds\") {\n        // All s_i's and r_i's are the same\n        int s = rnd.next(1, 10000);\n        int r = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"close_speeds\") {\n        // s_i's and r_i's are close to each other\n        int s_base = rnd.next(1, 10000);\n        int r_base = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            int s_delta = rnd.next(-1, 1);\n            int r_delta = rnd.next(-1, 1);\n            int s_i = max(1, min(10000, s_base + s_delta));\n            int r_i = max(1, min(10000, r_base + r_delta));\n            printf(\"%d %d\\n\", s_i, r_i);\n        }\n    } \n    else if (type == \"extremes\") {\n        // Speeds are either minimum or maximum values\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(0, 1) ? 1 : 10000;\n            int r = rnd.next(0, 1) ? 1 : 10000;\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"alternating\") {\n        // Speeds alternate between high and low values\n        for (int i = 0; i < n; ++i) {\n            int s = (i % 2 == 0) ? 1 : 10000;\n            int r = (i % 2 == 0) ? 10000 : 1;\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"worst_case\") {\n        // Construct a case where the feasible range of S/R is narrow\n        int s0 = 5001;\n        int r0 = 5001;\n        for (int i = 0; i < n; ++i) {\n            int s = s0 + i % 2;\n            int r = r0 - i % 2;\n            s = max(1, min(10000, s));\n            r = max(1, min(10000, r));\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, 10000);\n            int r = rnd.next(1, 10000);\n            printf(\"%d %d\\n\", s, r);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\");\n\n    printf(\"%d\\n\", n);\n\n    if (type == \"random\") {\n        // Random s_i and r_i\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, 10000);\n            int r = rnd.next(1, 10000);\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"max_speed\") {\n        // All s_i and r_i are maximum values\n        for (int i = 0; i < n; ++i) {\n            printf(\"10000 10000\\n\");\n        }\n    } \n    else if (type == \"min_speed\") {\n        // All s_i and r_i are minimum values\n        for (int i = 0; i < n; ++i) {\n            printf(\"1 1\\n\");\n        }\n    } \n    else if (type == \"same_speeds\") {\n        // All s_i's are the same, r_i's are random\n        int s = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            int r = rnd.next(1, 10000);\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"equal_speeds\") {\n        // All s_i's and r_i's are the same\n        int s = rnd.next(1, 10000);\n        int r = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"close_speeds\") {\n        // s_i's and r_i's are close to each other\n        int s_base = rnd.next(1, 10000);\n        int r_base = rnd.next(1, 10000);\n        for (int i = 0; i < n; ++i) {\n            int s_delta = rnd.next(-1, 1);\n            int r_delta = rnd.next(-1, 1);\n            int s_i = max(1, min(10000, s_base + s_delta));\n            int r_i = max(1, min(10000, r_base + r_delta));\n            printf(\"%d %d\\n\", s_i, r_i);\n        }\n    } \n    else if (type == \"extremes\") {\n        // Speeds are either minimum or maximum values\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(0, 1) ? 1 : 10000;\n            int r = rnd.next(0, 1) ? 1 : 10000;\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"alternating\") {\n        // Speeds alternate between high and low values\n        for (int i = 0; i < n; ++i) {\n            int s = (i % 2 == 0) ? 1 : 10000;\n            int r = (i % 2 == 0) ? 10000 : 1;\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else if (type == \"worst_case\") {\n        // Construct a case where the feasible range of S/R is narrow\n        int s0 = 5001;\n        int r0 = 5001;\n        for (int i = 0; i < n; ++i) {\n            int s = s0 + i % 2;\n            int r = r0 - i % 2;\n            s = max(1, min(10000, s));\n            r = max(1, min(10000, r));\n            printf(\"%d %d\\n\", s, r);\n        }\n    } \n    else {\n        // Default: random\n        for (int i = 0; i < n; ++i) {\n            int s = rnd.next(1, 10000);\n            int r = rnd.next(1, 10000);\n            printf(\"%d %d\\n\", s, r);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 5 -type random\n./gen -n 5 -type same_speeds\n./gen -n 5 -type max_speed\n./gen -n 5 -type min_speed\n./gen -n 10 -type same_speeds\n./gen -n 10 -type equal_speeds\n./gen -n 10 -type close_speeds\n./gen -n 100 -type random\n./gen -n 100 -type extremes\n./gen -n 100 -type alternating\n./gen -n 500 -type random\n./gen -n 500 -type close_speeds\n./gen -n 1000 -type random\n./gen -n 1000 -type max_speed\n./gen -n 10000 -type random\n./gen -n 10000 -type min_speed\n./gen -n 10000 -type worst_case\n./gen -n 50000 -type random\n./gen -n 50000 -type close_speeds\n./gen -n 100000 -type random\n./gen -n 100000 -type same_speeds\n./gen -n 100000 -type max_speed\n./gen -n 200000 -type random\n./gen -n 200000 -type extremes\n./gen -n 200000 -type alternating\n./gen -n 200000 -type worst_case\n./gen -n 200000 -type equal_speeds\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:05.194751",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "536/A",
      "title": "A. Тавас и Карафс",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке входного файла записано три целых числа A, B и n (1 ≤ A, B ≤ 106, 1 ≤ n ≤ 105).В следующих n строках записана информация о запросах. В i-й строке записаны целые числа l, t, m (1 ≤ l, t, m ≤ 106), обозначающие i-й запрос.",
      "output_spec": "Выходные данныеДля каждого запроса выведите ответ на него в отдельной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 1 41 5 33 3 107 10 26 4 8Выходные данныеСкопировать4-18-1Входные данныеСкопировать1 5 21 5 102 7 4Выходные данныеСкопировать12",
      "description": "A. Тавас и Карафс\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входного файла записано три целых числа A, B и n (1 ≤ A, B ≤ 106, 1 ≤ n ≤ 105).В следующих n строках записана информация о запросах. В i-й строке записаны целые числа l, t, m (1 ≤ l, t, m ≤ 106), обозначающие i-й запрос.\n\nВходные данные\n\nВыходные данныеДля каждого запроса выведите ответ на него в отдельной строке.\n\nВыходные данные\n\nВходные данныеСкопировать2 1 41 5 33 3 107 10 26 4 8Выходные данныеСкопировать4-18-1Входные данныеСкопировать1 5 21 5 102 7 4Выходные данныеСкопировать12\n\nВходные данныеСкопировать2 1 41 5 33 3 107 10 26 4 8\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать4-18-1\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать1 5 21 5 102 7 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать12\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 536\\s*A"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 1000000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 1000000, \"B\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        int l = inf.readInt(1, 1000000, \"l\");\n        inf.readSpace();\n        int t = inf.readInt(1, 1000000, \"t\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 1000000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 1000000, \"B\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        int l = inf.readInt(1, 1000000, \"l\");\n        inf.readSpace();\n        int t = inf.readInt(1, 1000000, \"t\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int A = inf.readInt(1, 1000000, \"A\");\n    inf.readSpace();\n    int B = inf.readInt(1, 1000000, \"B\");\n    inf.readSpace();\n    int n = inf.readInt(1, 100000, \"n\");\n    inf.readEoln();\n    \n    for (int i = 0; i < n; ++i) {\n        int l = inf.readInt(1, 1000000, \"l\");\n        inf.readSpace();\n        int t = inf.readInt(1, 1000000, \"t\");\n        inf.readSpace();\n        int m = inf.readInt(1, 1000000, \"m\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ll A = opt<ll>(\"A\", rnd.next(1, 1000000));\n    ll B = opt<ll>(\"B\", rnd.next(1, 1000000));\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        A = 1000000;\n        B = 1000000;\n    } else if (type == \"overflow\") {\n        A = 1000000;\n        B = 1000000;\n    }\n\n    printf(\"%lld %lld %d\\n\", A, B, n);\n\n    if (type == \"max\") {\n        // Generate queries with maximum values\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = 1000000;\n            int m = 1000000;\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else if (type == \"edge\") {\n        // Generate edge test cases\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            ll s_l = A + (ll)(l - 1) * B;\n            int t;\n            if (rnd.next(2)) {\n                // s_l = t\n                t = s_l <= 1000000 ? s_l : rnd.next(1, 1000000);\n            } else {\n                // s_l = t + 1\n                t = s_l - 1 <= 1000000 ? s_l - 1 : rnd.next(1, 1000000);\n            }\n            if (t < 1) t = 1;\n            int m = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else if (type == \"overflow\") {\n        // Generate queries that may cause overflow\n        for (int i = 0; i < n; ++i) {\n            int l = 1;\n            int t = 1000000;\n            int m = 1000000;\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else if (type == \"random\") {\n        // Random test cases\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else {\n        // Default to random if unspecified type\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    ll A = opt<ll>(\"A\", rnd.next(1, 1000000));\n    ll B = opt<ll>(\"B\", rnd.next(1, 1000000));\n    string type = opt<string>(\"type\", \"random\");\n\n    if (type == \"max\") {\n        A = 1000000;\n        B = 1000000;\n    } else if (type == \"overflow\") {\n        A = 1000000;\n        B = 1000000;\n    }\n\n    printf(\"%lld %lld %d\\n\", A, B, n);\n\n    if (type == \"max\") {\n        // Generate queries with maximum values\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = 1000000;\n            int m = 1000000;\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else if (type == \"edge\") {\n        // Generate edge test cases\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            ll s_l = A + (ll)(l - 1) * B;\n            int t;\n            if (rnd.next(2)) {\n                // s_l = t\n                t = s_l <= 1000000 ? s_l : rnd.next(1, 1000000);\n            } else {\n                // s_l = t + 1\n                t = s_l - 1 <= 1000000 ? s_l - 1 : rnd.next(1, 1000000);\n            }\n            if (t < 1) t = 1;\n            int m = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else if (type == \"overflow\") {\n        // Generate queries that may cause overflow\n        for (int i = 0; i < n; ++i) {\n            int l = 1;\n            int t = 1000000;\n            int m = 1000000;\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else if (type == \"random\") {\n        // Random test cases\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    } else {\n        // Default to random if unspecified type\n        for (int i = 0; i < n; ++i) {\n            int l = rnd.next(1, 1000000);\n            int t = rnd.next(1, 1000000);\n            int m = rnd.next(1, 1000000);\n            printf(\"%d %d %d\\n\", l, t, m);\n        }\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Random test cases with small n\n./gen -n 10 -type random\n\n# Random test cases with moderate n\n./gen -n 1000 -type random\n\n# Random test cases with large n\n./gen -n 100000 -type random\n\n# Edge test cases with small n\n./gen -n 10 -type edge\n\n# Edge test cases with moderate n\n./gen -n 1000 -type edge\n\n# Edge test cases with large n\n./gen -n 100000 -type edge\n\n# Maximum value test cases with small n\n./gen -n 10 -type max\n\n# Maximum value test cases with moderate n\n./gen -n 1000 -type max\n\n# Maximum value test cases with large n\n./gen -n 100000 -type max\n\n# Overflow test cases with small n\n./gen -n 10 -type overflow\n\n# Overflow test cases with moderate n\n./gen -n 1000 -type overflow\n\n# Overflow test cases with large n\n./gen -n 100000 -type overflow\n\n# Random test cases with specified A and B\n./gen -n 1000 -A 1 -B 1 -type random\n\n./gen -n 1000 -A 1000000 -B 1 -type random\n\n./gen -n 1000 -A 1 -B 1000000 -type random\n\n# Edge test cases where s_i just equals t\n./gen -n 1000 -A 10 -B 0 -type edge\n\n# Edge test cases where s_i just exceeds t\n./gen -n 1000 -A 1 -B 1 -type edge\n\n# Edge test cases with minimum values\n./gen -n 1000 -A 1 -B 1 -type edge\n\n# Test cases to cause sum overflows\n./gen -n 100000 -A 1000000 -B 1000000 -type overflow\n\n# Random test cases with l = 1\n./gen -n 1000 -A 1000 -B 1000 -type random\n\n# Random test cases with l = maximum value\n./gen -n 1000 -A 1000 -B 1000 -type random\n\n# Edge test cases with m = 1\n./gen -n 1000 -A 1000 -B 1000 -type edge\n\n# Edge test cases with t = 1\n./gen -n 1000 -A 1000 -B 1000 -type edge\n\n# Random test cases with m and t at extremes\n./gen -n 1000 -A 1000000 -B 1000000 -type random\n\n# Edge test cases to test off-by-one errors\n./gen -n 1000 -A 999999 -B 1 -type edge\n\n# Random test cases with n = 1\n./gen -n 1 -type random\n\n# Maximum value test cases with n = 1\n./gen -n 1 -type max\n\n# Overflow test cases with n = 1\n./gen -n 1 -type overflow\n\n# Edge test cases with n = 1\n./gen -n 1 -type edge\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:07.120946",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "536/B",
      "title": "B. Tavas and Malekas",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "time limit per test2 seconds",
      "memory_limit": "memory limit per test256 megabytes",
      "input_spec": "InputThe first line contains two integers n and m, the length of s and the length of the subsequence Malekas wrote down (1 ≤ n ≤ 106 and 0 ≤ m ≤ n - |p| + 1).The second line contains string p (1 ≤ |p| ≤ n).The next line contains m space separated integers y1, y2, ..., ym, Malekas' subsequence (1 ≤ y1 < y2 < ... < ym ≤ n - |p| + 1).",
      "output_spec": "OutputIn a single line print the answer modulo 1000 000 007.",
      "sample_tests": "ExamplesInputCopy6 2ioi1 3OutputCopy26InputCopy5 2ioi1 2OutputCopy0",
      "description": "B. Tavas and Malekas\n\ntime limit per test2 seconds\n\ntime limit per test\n\nmemory limit per test256 megabytes\n\nmemory limit per test\n\ninputstandard input\n\noutputstandard output\n\nInputThe first line contains two integers n and m, the length of s and the length of the subsequence Malekas wrote down (1 ≤ n ≤ 106 and 0 ≤ m ≤ n - |p| + 1).The second line contains string p (1 ≤ |p| ≤ n).The next line contains m space separated integers y1, y2, ..., ym, Malekas' subsequence (1 ≤ y1 < y2 < ... < ym ≤ n - |p| + 1).\n\nOutputIn a single line print the answer modulo 1000 000 007.\n\nInputCopy6 2ioi1 3OutputCopy26InputCopy5 2ioi1 2OutputCopy0\n\nInputCopy6 2ioi1 3\n\nOutputCopy26\n\nInputCopy5 2ioi1 2\n\nOutputCopy0\n\nNoteIn the first sample test all strings of form \"ioioi?\" where the question mark replaces arbitrary English letter satisfy.Here |x| denotes the length of string x.Please note that it's possible that there is no such string (answer is 0).",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 536\\s*B"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    string pattern = \"[a-z]{1,\" + to_string(n) + \"}\";\n    string p = inf.readToken(pattern, \"p\");\n    inf.readEoln();\n    int max_m = n - (int)p.size() + 1;\n    ensuref(m <= max_m, \"m (%d) cannot be greater than n - |p| +1 (%d - %d +1 = %d)\", m, n, (int)p.size(), max_m);\n    if (m == 0) {\n        inf.readEof();\n        return 0;\n    }\n    vector<int> y = inf.readInts(m, 1, max_m, \"y_i\");\n    inf.readEoln();\n    for (int i = 0; i < m - 1; ++i) {\n        ensuref(y[i] < y[i + 1], \"Positions y_i must be strictly increasing, but y[%d]=%d, y[%d]=%d\", i + 1, y[i], i + 2, y[i + 1]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    string pattern = \"[a-z]{1,\" + to_string(n) + \"}\";\n    string p = inf.readToken(pattern, \"p\");\n    inf.readEoln();\n    int max_m = n - (int)p.size() + 1;\n    ensuref(m <= max_m, \"m (%d) cannot be greater than n - |p| +1 (%d - %d +1 = %d)\", m, n, (int)p.size(), max_m);\n    if (m == 0) {\n        inf.readEof();\n        return 0;\n    }\n    vector<int> y = inf.readInts(m, 1, max_m, \"y_i\");\n    inf.readEoln();\n    for (int i = 0; i < m - 1; ++i) {\n        ensuref(y[i] < y[i + 1], \"Positions y_i must be strictly increasing, but y[%d]=%d, y[%d]=%d\", i + 1, y[i], i + 2, y[i + 1]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 1000000, \"n\");\n    inf.readSpace();\n    int m = inf.readInt(0, n, \"m\");\n    inf.readEoln();\n    string pattern = \"[a-z]{1,\" + to_string(n) + \"}\";\n    string p = inf.readToken(pattern, \"p\");\n    inf.readEoln();\n    int max_m = n - (int)p.size() + 1;\n    ensuref(m <= max_m, \"m (%d) cannot be greater than n - |p| +1 (%d - %d +1 = %d)\", m, n, (int)p.size(), max_m);\n    if (m == 0) {\n        inf.readEof();\n        return 0;\n    }\n    vector<int> y = inf.readInts(m, 1, max_m, \"y_i\");\n    inf.readEoln();\n    for (int i = 0; i < m - 1; ++i) {\n        ensuref(y[i] < y[i + 1], \"Positions y_i must be strictly increasing, but y[%d]=%d, y[%d]=%d\", i + 1, y[i], i + 2, y[i + 1]);\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    int p_len = opt<int>(\"p_len\", 1);\n    string test_type = opt<string>(\"type\", \"random\");\n\n    if (p_len > n) p_len = n; // Ensure p_len ≤ n\n\n    string p;\n\n    if (test_type == \"random\") {\n        // Generate random p of length p_len\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    } else if (test_type == \"same_char_p\") {\n        // p is a string of the same character\n        char c = rnd.next('a', 'z');\n        p = string(p_len, c);\n    } else if (test_type == \"max_m\") {\n        // m is maximum possible\n        m = n - p_len + 1;\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    } else if (test_type == \"m0\") {\n        // m is 0\n        m = 0;\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    } else if (test_type == \"no_possible_s\") {\n        // Generate a test case where the answer is 0\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n        // Set m greater than possible positions\n        int max_positions = n - p_len + 1;\n        m = max_positions + 1;\n    } else {\n        // Other test types can be added here\n        // For now, just generate random p\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    }\n\n    // Generate Malekas' subsequence positions y1..ym\n\n    vector<int> positions;\n\n    if (test_type == \"no_possible_s\") {\n        // Generate invalid positions\n        positions.resize(m);\n        for (int i = 0; i < m; ++i) {\n            // At least one position outside valid range\n            positions[i] = rnd.next(1, n - p_len + 2);\n        }\n        sort(positions.begin(), positions.end());\n    } else {\n        int max_positions = n - p_len + 1;\n\n        // Build list of possible positions xi\n        vector<int> xi;\n        for (int i = 1; i <= max_positions; ++i) {\n            xi.push_back(i);\n        }\n\n        shuffle(xi.begin(), xi.end());\n\n        if (test_type == \"max_m\") {\n            // m = maximum possible\n            m = xi.size();\n        }\n\n        if (m > (int)xi.size()) m = xi.size();\n\n        sort(xi.begin(), xi.end());\n\n        // Now, select a subsequence of xi of length m\n        vector<int> yi;\n\n        if (m > 0) {\n            // Randomly select m positions from xi\n            vector<int> subseq_indices;\n            for (int i = 0; i < (int)xi.size(); ++i) {\n                subseq_indices.push_back(i);\n            }\n            shuffle(subseq_indices.begin(), subseq_indices.end());\n            subseq_indices.resize(m);\n            sort(subseq_indices.begin(), subseq_indices.end());\n            for (int idx : subseq_indices) {\n                yi.push_back(xi[idx]);\n            }\n            sort(yi.begin(), yi.end());\n            positions = yi;\n        } else {\n            positions.clear();\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", p.c_str());\n\n    for (int i = 0; i < (int)positions.size(); ++i) {\n        printf(\"%d\", positions[i]);\n        if (i + 1 < (int)positions.size()) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\", 0);\n    int p_len = opt<int>(\"p_len\", 1);\n    string test_type = opt<string>(\"type\", \"random\");\n\n    if (p_len > n) p_len = n; // Ensure p_len ≤ n\n\n    string p;\n\n    if (test_type == \"random\") {\n        // Generate random p of length p_len\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    } else if (test_type == \"same_char_p\") {\n        // p is a string of the same character\n        char c = rnd.next('a', 'z');\n        p = string(p_len, c);\n    } else if (test_type == \"max_m\") {\n        // m is maximum possible\n        m = n - p_len + 1;\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    } else if (test_type == \"m0\") {\n        // m is 0\n        m = 0;\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    } else if (test_type == \"no_possible_s\") {\n        // Generate a test case where the answer is 0\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n        // Set m greater than possible positions\n        int max_positions = n - p_len + 1;\n        m = max_positions + 1;\n    } else {\n        // Other test types can be added here\n        // For now, just generate random p\n        p = \"\";\n        for (int i = 0; i < p_len; ++i) {\n            p += rnd.next('a', 'z');\n        }\n    }\n\n    // Generate Malekas' subsequence positions y1..ym\n\n    vector<int> positions;\n\n    if (test_type == \"no_possible_s\") {\n        // Generate invalid positions\n        positions.resize(m);\n        for (int i = 0; i < m; ++i) {\n            // At least one position outside valid range\n            positions[i] = rnd.next(1, n - p_len + 2);\n        }\n        sort(positions.begin(), positions.end());\n    } else {\n        int max_positions = n - p_len + 1;\n\n        // Build list of possible positions xi\n        vector<int> xi;\n        for (int i = 1; i <= max_positions; ++i) {\n            xi.push_back(i);\n        }\n\n        shuffle(xi.begin(), xi.end());\n\n        if (test_type == \"max_m\") {\n            // m = maximum possible\n            m = xi.size();\n        }\n\n        if (m > (int)xi.size()) m = xi.size();\n\n        sort(xi.begin(), xi.end());\n\n        // Now, select a subsequence of xi of length m\n        vector<int> yi;\n\n        if (m > 0) {\n            // Randomly select m positions from xi\n            vector<int> subseq_indices;\n            for (int i = 0; i < (int)xi.size(); ++i) {\n                subseq_indices.push_back(i);\n            }\n            shuffle(subseq_indices.begin(), subseq_indices.end());\n            subseq_indices.resize(m);\n            sort(subseq_indices.begin(), subseq_indices.end());\n            for (int idx : subseq_indices) {\n                yi.push_back(xi[idx]);\n            }\n            sort(yi.begin(), yi.end());\n            positions = yi;\n        } else {\n            positions.clear();\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%s\\n\", p.c_str());\n\n    for (int i = 0; i < (int)positions.size(); ++i) {\n        printf(\"%d\", positions[i]);\n        if (i + 1 < (int)positions.size()) printf(\" \");\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small random test cases\n./gen -n 5 -m 0 -p_len 3 -type m0\n./gen -n 5 -m 2 -p_len 3 -type random\n./gen -n 6 -m 2 -p_len 3 -type random\n./gen -n 6 -m 2 -p_len 3 -type same_char_p\n\n# Maximal m\n./gen -n 10 -m 8 -p_len 3 -type max_m\n./gen -n 100 -m 98 -p_len 3 -type max_m\n./gen -n 1000 -m 998 -p_len 3 -type max_m\n./gen -n 1000000 -m 999998 -p_len 3 -type max_m\n\n# Edge cases for m = 0\n./gen -n 1000 -m 0 -p_len 1 -type m0\n./gen -n 1000000 -m 0 -p_len 1 -type m0\n\n# Test cases where answer is zero\n./gen -n 5 -m 6 -p_len 3 -type no_possible_s\n./gen -n 10 -m 12 -p_len 5 -type no_possible_s\n./gen -n 100 -m 101 -p_len 1 -type no_possible_s\n\n# Random test cases with varying n and m\n./gen -n 1000 -m 100 -p_len 10 -type random\n./gen -n 1000 -m 500 -p_len 50 -type random\n./gen -n 10000 -m 9000 -p_len 100 -type random\n./gen -n 100000 -m 50000 -p_len 500 -type random\n\n# Test cases with p of length n\n./gen -n 1000 -m 1 -p_len 1000 -type random\n./gen -n 10000 -m 1 -p_len 10000 -type random\n\n# Test cases with p of length 1\n./gen -n 1000 -m 500 -p_len 1 -type random\n./gen -n 1000000 -m 999999 -p_len 1 -type max_m\n\n# Test cases with p consisting of the same character\n./gen -n 1000 -m 10 -p_len 100 -type same_char_p\n./gen -n 100000 -m 1000 -p_len 10000 -type same_char_p\n\n# Edge test cases\n./gen -n 1 -m 0 -p_len 1 -type m0\n./gen -n 1 -m 1 -p_len 1 -type max_m\n./gen -n 1000000 -m 0 -p_len 1000000 -type m0\n\n# Large n with small p_len\n./gen -n 1000000 -m 100000 -p_len 2 -type random\n./gen -n 1000000 -m 500000 -p_len 3 -type random\n\n# Test cases with overlapping p positions\n./gen -n 1000 -m 500 -p_len 2 -type random\n./gen -n 1000 -m 900 -p_len 2 -type random\n\n# Test cases with minimal possible values\n./gen -n 1 -m 0 -p_len 1 -type random\n./gen -n 2 -m 1 -p_len 1 -type random\n\n# Test cases aiming to create maximum overlapping in positions\n./gen -n 1000 -m 999 -p_len 1 -type max_m\n./gen -n 1000 -m 998 -p_len 2 -type max_m\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:09.135289",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "536/C",
      "title": "C. Тавас и Пашмакс",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест1 секунда",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записано единственное целое число n (1 ≤ n ≤ 2 × 105).В следующих n строках записаны сведения о соревнующихся. В i-й строке записаны два целых числа, si и ri (1 ≤ si, ri ≤ 104).",
      "output_spec": "Выходные данныеВ первой и единственной строке выведите последовательность номеров возможных победителей в порядке возрастания.",
      "sample_tests": "ПримерыВходные данныеСкопировать31 32 23 1Выходные данныеСкопировать1 2 3 Входные данныеСкопировать31 21 12 1Выходные данныеСкопировать1 3",
      "description": "C. Тавас и Пашмакс\n\nограничение по времени на тест1 секунда\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записано единственное целое число n (1 ≤ n ≤ 2 × 105).В следующих n строках записаны сведения о соревнующихся. В i-й строке записаны два целых числа, si и ri (1 ≤ si, ri ≤ 104).\n\nВходные данные\n\nВыходные данныеВ первой и единственной строке выведите последовательность номеров возможных победителей в порядке возрастания.\n\nВыходные данные\n\nВходные данныеСкопировать31 32 23 1Выходные данныеСкопировать1 2 3 Входные данныеСкопировать31 21 12 1Выходные данныеСкопировать1 3\n\nВходные данныеСкопировать31 32 23 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 2 3\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать31 21 12 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать1 3\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "Qingyu",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 536\\s*C"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "Qingyu"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int si = inf.readInt(1, 10000, \"si\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int si = inf.readInt(1, 10000, \"si\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n    int n = inf.readInt(1, 200000, \"n\");\n    inf.readEoln();\n    for (int i = 0; i < n; ++i) {\n        int si = inf.readInt(1, 10000, \"si\");\n        inf.readSpace();\n        int ri = inf.readInt(1, 10000, \"ri\");\n        inf.readEoln();\n    }\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_S_R = 10000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default type is \"random\"\n\n    printf(\"%d\\n\", n);\n    vector<pair<int, int>> competitors(n);\n    \n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int s = rnd.next(1, MAX_S_R);\n            int r = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"max_s_min_r\") {\n        int s = MAX_S_R;\n        int r = 1;\n        for(int i = 0; i < n; ++i) {\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"min_s_max_r\") {\n        int s = 1;\n        int r = MAX_S_R;\n        for(int i = 0; i < n; ++i) {\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"equal_s\") {\n        int s = rnd.next(1, MAX_S_R);\n        for(int i = 0; i < n; ++i) {\n            int r = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"equal_r\") {\n        int r = rnd.next(1, MAX_S_R);\n        for(int i = 0; i < n; ++i) {\n            int s = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"equal_s_and_r\") {\n        int s = rnd.next(1, MAX_S_R);\n        int r = s;\n        for(int i = 0; i < n; ++i) {\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"increasing_s_decreasing_r\") {\n        for(int i = 0; i < n; ++i) {\n            int s = 1 + i % MAX_S_R;\n            int r = MAX_S_R - i % MAX_S_R;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"decreasing_s_increasing_r\") {\n        for(int i = 0; i < n; ++i) {\n            int s = MAX_S_R - i % MAX_S_R;\n            int r = 1 + i % MAX_S_R;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"min_values\") {\n        for(int i = 0; i < n; ++i) {\n            int s = 1;\n            int r = 1;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"max_values\") {\n        for(int i = 0; i < n; ++i) {\n            int s = MAX_S_R;\n            int r = MAX_S_R;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            int s = (i%2 == 0) ? 1 : MAX_S_R;\n            int r = (i%2 == 0) ? MAX_S_R : 1;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"special_case1\") {\n        // Construct a case where one competitor cannot be a winner\n        if(n < 2)\n            n = 2; // need at least 2 competitors\n        printf(\"%d\\n\", n);\n        competitors[0] = {MAX_S_R, MAX_S_R};\n        for(int i = 1; i < n; ++i) {\n            competitors[i] = {1, 1};\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            int s = rnd.next(1, MAX_S_R);\n            int r = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    }\n\n    // Output the competitors\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", competitors[i].first, competitors[i].second);\n    }\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_S_R = 10000;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    int n = opt<int>(\"n\");\n    string type = opt<string>(\"type\", \"random\"); // default type is \"random\"\n\n    printf(\"%d\\n\", n);\n    vector<pair<int, int>> competitors(n);\n    \n    if(type == \"random\") {\n        for(int i = 0; i < n; ++i) {\n            int s = rnd.next(1, MAX_S_R);\n            int r = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"max_s_min_r\") {\n        int s = MAX_S_R;\n        int r = 1;\n        for(int i = 0; i < n; ++i) {\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"min_s_max_r\") {\n        int s = 1;\n        int r = MAX_S_R;\n        for(int i = 0; i < n; ++i) {\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"equal_s\") {\n        int s = rnd.next(1, MAX_S_R);\n        for(int i = 0; i < n; ++i) {\n            int r = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"equal_r\") {\n        int r = rnd.next(1, MAX_S_R);\n        for(int i = 0; i < n; ++i) {\n            int s = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"equal_s_and_r\") {\n        int s = rnd.next(1, MAX_S_R);\n        int r = s;\n        for(int i = 0; i < n; ++i) {\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"increasing_s_decreasing_r\") {\n        for(int i = 0; i < n; ++i) {\n            int s = 1 + i % MAX_S_R;\n            int r = MAX_S_R - i % MAX_S_R;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"decreasing_s_increasing_r\") {\n        for(int i = 0; i < n; ++i) {\n            int s = MAX_S_R - i % MAX_S_R;\n            int r = 1 + i % MAX_S_R;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"min_values\") {\n        for(int i = 0; i < n; ++i) {\n            int s = 1;\n            int r = 1;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"max_values\") {\n        for(int i = 0; i < n; ++i) {\n            int s = MAX_S_R;\n            int r = MAX_S_R;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"alternating\") {\n        for(int i = 0; i < n; ++i) {\n            int s = (i%2 == 0) ? 1 : MAX_S_R;\n            int r = (i%2 == 0) ? MAX_S_R : 1;\n            competitors[i] = {s, r};\n        }\n    } else if(type == \"special_case1\") {\n        // Construct a case where one competitor cannot be a winner\n        if(n < 2)\n            n = 2; // need at least 2 competitors\n        printf(\"%d\\n\", n);\n        competitors[0] = {MAX_S_R, MAX_S_R};\n        for(int i = 1; i < n; ++i) {\n            competitors[i] = {1, 1};\n        }\n    } else {\n        // default to random\n        for(int i = 0; i < n; ++i) {\n            int s = rnd.next(1, MAX_S_R);\n            int r = rnd.next(1, MAX_S_R);\n            competitors[i] = {s, r};\n        }\n    }\n\n    // Output the competitors\n    for(int i = 0; i < n; ++i) {\n        printf(\"%d %d\\n\", competitors[i].first, competitors[i].second);\n    }\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Minimum n\n./gen -n 1 -type min_values\n./gen -n 1 -type max_values\n\n# Small n\n./gen -n 2 -type special_case1\n./gen -n 10 -type random\n./gen -n 10 -type equal_s_and_r\n\n# Medium n\n./gen -n 100 -type random\n./gen -n 1000 -type increasing_s_decreasing_r\n./gen -n 1000 -type decreasing_s_increasing_r\n\n# Large n\n./gen -n 10000 -type equal_s\n./gen -n 10000 -type equal_r\n./gen -n 20000 -type equal_s_and_r\n\n# Very large n\n./gen -n 50000 -type alternating\n./gen -n 100000 -type max_s_min_r\n./gen -n 100000 -type min_s_max_r\n./gen -n 200000 -type max_values\n./gen -n 200000 -type min_values\n\n# Special cases\n./gen -n 200000 -type special_case1\n\n# Random large n\n./gen -n 200000 -type random\n./gen -n 199999 -type decreasing_s_increasing_r\n./gen -n 123456 -type random\n./gen -n 134567 -type random\n./gen -n 175432 -type random\n\n# Random small n\n./gen -n 1234 -type random\n./gen -n 5678 -type random\n\n# Edge n\n./gen -n 200000 -type equal_s\n./gen -n 200000 -type equal_r\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:11.162987",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "536/D",
      "title": "D. Тавас в Канзасе",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест2 секунды",
      "memory_limit": "ограничение по памяти на тест512 мегабайт",
      "input_spec": "Входные данныеВ первой строке входа записано два целых числа n и m (2 ≤ n ≤ 2000, n - 1 ≤ m ≤ 105).Во второй строке входа записано два целых числа s и t (1 ≤ s, t ≤ n, s ≠ t).В следующей строке записано n целых чисел p1, p2, ..., pn, разделенных пробелами (|pi| ≤ 109).В следующих m строках записаны дороги. В каждой строке записано три целых числа v, u, w, это означает, что есть дорога длины w между городами v и u (1 ≤ u, v ≤ n и 0 ≤ w ≤ 109). Дорога может вести из города в него же, между двумя городами может быть несколько дорог.",
      "output_spec": "Выходные данныеЕсли победит Тавас, выведите \"Break a heart\". Если победит Нафас, выведите \"Cry\", а если никто не победит (то есть, если игра закончится ничьей), выведите \"Flowers\".",
      "sample_tests": "ПримерыВходные данныеСкопировать4 41 23 2 5 -111 4 23 4 23 1 53 2 1Выходные данныеСкопироватьCryВходные данныеСкопировать5 41 22 2 -5 -4 61 2 42 3 52 4 24 5 2Выходные данныеСкопироватьBreak a heartВходные данныеСкопировать2 11 2-5 -51 2 10Выходные данныеСкопироватьFlowers",
      "description": "D. Тавас в Канзасе\n\nограничение по времени на тест2 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест512 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке входа записано два целых числа n и m (2 ≤ n ≤ 2000, n - 1 ≤ m ≤ 105).Во второй строке входа записано два целых числа s и t (1 ≤ s, t ≤ n, s ≠ t).В следующей строке записано n целых чисел p1, p2, ..., pn, разделенных пробелами (|pi| ≤ 109).В следующих m строках записаны дороги. В каждой строке записано три целых числа v, u, w, это означает, что есть дорога длины w между городами v и u (1 ≤ u, v ≤ n и 0 ≤ w ≤ 109). Дорога может вести из города в него же, между двумя городами может быть несколько дорог.\n\nВходные данные\n\nВыходные данныеЕсли победит Тавас, выведите \"Break a heart\". Если победит Нафас, выведите \"Cry\", а если никто не победит (то есть, если игра закончится ничьей), выведите \"Flowers\".\n\nВыходные данные\n\nВходные данныеСкопировать4 41 23 2 5 -111 4 23 4 23 1 53 2 1Выходные данныеСкопироватьCryВходные данныеСкопировать5 41 22 2 -5 -4 61 2 42 3 52 4 24 5 2Выходные данныеСкопироватьBreak a heartВходные данныеСкопировать2 11 2-5 -51 2 10Выходные данныеСкопироватьFlowers\n\nВходные данныеСкопировать4 41 23 2 5 -111 4 23 4 23 1 53 2 1\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьCry\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать5 41 22 2 -5 -4 61 2 42 3 52 4 24 5 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьBreak a heart\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать2 11 2-5 -51 2 10\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопироватьFlowers\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 536\\s*D"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2000;\nconst int MAX_M = 100000;\nconst int MAX_P = 1000000000;  // 1e9\n\nint n, m;\nint s, t;\nvector<int> p;\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(n - 1, 100000, \"m\");\n    inf.readEoln();\n\n    s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    ensuref(s != t, \"s (%d) should not be equal to t (%d)\", s, t);\n\n    p = inf.readInts(n, -1000000000, 1000000000, \"p\");\n    inf.readEoln();\n\n    adj.resize(n + 1);  // Using 1-based indexing\n    for (int i = 0; i < m; i++) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int w = inf.readInt(0, 1000000000, \"w\");\n        inf.readEoln();\n\n        adj[v].push_back(u);\n        adj[u].push_back(v);  // Since the graph is bidirectional\n    }\n\n    // Check that the graph is connected\n    visited.resize(n + 1, false);\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2000;\nconst int MAX_M = 100000;\nconst int MAX_P = 1000000000;  // 1e9\n\nint n, m;\nint s, t;\nvector<int> p;\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(n - 1, 100000, \"m\");\n    inf.readEoln();\n\n    s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    ensuref(s != t, \"s (%d) should not be equal to t (%d)\", s, t);\n\n    p = inf.readInts(n, -1000000000, 1000000000, \"p\");\n    inf.readEoln();\n\n    adj.resize(n + 1);  // Using 1-based indexing\n    for (int i = 0; i < m; i++) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int w = inf.readInt(0, 1000000000, \"w\");\n        inf.readEoln();\n\n        adj[v].push_back(u);\n        adj[u].push_back(v);  // Since the graph is bidirectional\n    }\n\n    // Check that the graph is connected\n    visited.resize(n + 1, false);\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 2000;\nconst int MAX_M = 100000;\nconst int MAX_P = 1000000000;  // 1e9\n\nint n, m;\nint s, t;\nvector<int> p;\nvector<vector<int>> adj;\nvector<bool> visited;\n\nvoid dfs(int u) {\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    n = inf.readInt(2, 2000, \"n\");\n    inf.readSpace();\n    m = inf.readInt(n - 1, 100000, \"m\");\n    inf.readEoln();\n\n    s = inf.readInt(1, n, \"s\");\n    inf.readSpace();\n    t = inf.readInt(1, n, \"t\");\n    inf.readEoln();\n\n    ensuref(s != t, \"s (%d) should not be equal to t (%d)\", s, t);\n\n    p = inf.readInts(n, -1000000000, 1000000000, \"p\");\n    inf.readEoln();\n\n    adj.resize(n + 1);  // Using 1-based indexing\n    for (int i = 0; i < m; i++) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int w = inf.readInt(0, 1000000000, \"w\");\n        inf.readEoln();\n\n        adj[v].push_back(u);\n        adj[u].push_back(v);  // Since the graph is bidirectional\n    }\n\n    // Check that the graph is connected\n    visited.resize(n + 1, false);\n    dfs(1);\n    for (int i = 1; i <= n; i++) {\n        ensuref(visited[i], \"Graph is not connected, node %d is unreachable\", i);\n    }\n\n    inf.readEof();\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare sequences of tokens\");\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string j, p;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n\r\n        ans.readWordTo(j);\r\n        ouf.readWordTo(p);\r\n\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s words differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  compress(j).c_str(), compress(p).c_str());\r\n    }\r\n\r\n    if (ans.seekEof() && ouf.seekEof()) {\r\n        if (n == 1)\r\n            quitf(_ok, \"\\\"%s\\\"\", compress(j).c_str());\r\n        else\r\n            quitf(_ok, \"%d tokens\", n);\r\n    } else {\r\n        if (ans.seekEof())\r\n            quitf(_wa, \"Participant output contains extra tokens\");\r\n        else\r\n            quitf(_wa, \"Unexpected EOF in the participants output\");\r\n    }\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = opt<int>(\"s\", -1);\n    int t = opt<int>(\"t\", -1);\n\n    ensure(2 <= n && n <= 2000);\n    ensure(n - 1 <= m && m <= (int)1e5);\n\n    if (s == -1) s = rnd.next(1, n);\n    if (t == -1) {\n        do {\n            t = rnd.next(1, n);\n        } while (t == s);\n    }\n    ensure(1 <= s && s <= n);\n    ensure(1 <= t && t <= n);\n    ensure(s != t);\n\n    vector<int> p(n + 1);\n\n    if (type == \"negative_p\" || type == \"negative_p_loops\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = -rnd.next(1, (int)1e9);\n        }\n    } else if (type == \"zero_p\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = 0;\n        }\n    } else if (type == \"large_p\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = rnd.next(2) ? (int)1e9 : -(int)1e9;\n        }\n    } else if (type == \"small_positive_p\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = rnd.next(1, 10);\n        }\n    } else {\n        // random\n        for (int i = 1; i <= n; ++i) {\n            p[i] = rnd.next(-(int)1e9, (int)1e9);\n        }\n    }\n\n    vector<pair<int,int>> edges;\n    set<pair<int,int>> edge_set;\n\n    if (type == \"chain\" || type == \"chain_loops\" || type == \"chain_multi\") {\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = i -1;\n            edges.push_back(make_pair(u, v));\n        }\n        if (type == \"chain_loops\") {\n            for (int i = 1; i <= n; ++i) {\n                edges.push_back(make_pair(i, i));\n            }\n        }\n        if (type == \"chain_multi\") {\n            while ((int)edges.size() < m) {\n                int u = rnd.next(1, n);\n                int v = u - 1;\n                if (v < 1) v = u + 1;\n                if (v > n) v = rnd.next(1, n);\n                edges.push_back(make_pair(u, v));\n            }\n        } else {\n            // Add random edges if m > n - 1\n            while ((int)edges.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"star\") {\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                edges.push_back(make_pair(center, i));\n            }\n        }\n        // Add random edges if m > n - 1\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back(make_pair(u, v));\n        }\n    } else {\n        // random or other types\n        // Build a random tree first\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n            int a = min(u, v);\n            int b = max(u, v);\n            edge_set.insert(make_pair(a, b));\n        }\n        // Now add extra edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n\n            if (type == \"loops\" || type == \"negative_p_loops\") {\n                if (rnd.next(100) < 20) {\n                    // Increase chance of loops\n                    u = v;\n                }\n            }\n            if (type == \"multi\" || type == \"loops\" || type == \"negative_p_loops\" || type == \"loops_multi\") {\n                // Allow multiple edges and loops\n                edges.push_back(make_pair(u, v));\n            } else {\n                if (u == v) continue;\n\n                int a = min(u, v);\n                int b = max(u, v);\n                if (edge_set.count(make_pair(a, b)) == 0) {\n                    edges.push_back(make_pair(u, v));\n                    edge_set.insert(make_pair(a, b));\n                }\n            }\n        }\n    }\n\n    vector<int> weights((int)edges.size());\n\n    if (type == \"zero_weights\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = 0;\n        }\n    } else if (type == \"large_weights\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = (int)1e9;\n        }\n    } else {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(0, (int)1e9);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d\\n\", s, t);\n\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", p[i], i == n ? '\\n' : ' ');\n    }\n\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int w = weights[i];\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n\n    registerGen(argc, argv, 1);\n\n    int n = opt<int>(\"n\");\n    int m = opt<int>(\"m\");\n    string type = opt<string>(\"type\", \"random\");\n    int s = opt<int>(\"s\", -1);\n    int t = opt<int>(\"t\", -1);\n\n    ensure(2 <= n && n <= 2000);\n    ensure(n - 1 <= m && m <= (int)1e5);\n\n    if (s == -1) s = rnd.next(1, n);\n    if (t == -1) {\n        do {\n            t = rnd.next(1, n);\n        } while (t == s);\n    }\n    ensure(1 <= s && s <= n);\n    ensure(1 <= t && t <= n);\n    ensure(s != t);\n\n    vector<int> p(n + 1);\n\n    if (type == \"negative_p\" || type == \"negative_p_loops\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = -rnd.next(1, (int)1e9);\n        }\n    } else if (type == \"zero_p\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = 0;\n        }\n    } else if (type == \"large_p\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = rnd.next(2) ? (int)1e9 : -(int)1e9;\n        }\n    } else if (type == \"small_positive_p\") {\n        for (int i = 1; i <= n; ++i) {\n            p[i] = rnd.next(1, 10);\n        }\n    } else {\n        // random\n        for (int i = 1; i <= n; ++i) {\n            p[i] = rnd.next(-(int)1e9, (int)1e9);\n        }\n    }\n\n    vector<pair<int,int>> edges;\n    set<pair<int,int>> edge_set;\n\n    if (type == \"chain\" || type == \"chain_loops\" || type == \"chain_multi\") {\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = i -1;\n            edges.push_back(make_pair(u, v));\n        }\n        if (type == \"chain_loops\") {\n            for (int i = 1; i <= n; ++i) {\n                edges.push_back(make_pair(i, i));\n            }\n        }\n        if (type == \"chain_multi\") {\n            while ((int)edges.size() < m) {\n                int u = rnd.next(1, n);\n                int v = u - 1;\n                if (v < 1) v = u + 1;\n                if (v > n) v = rnd.next(1, n);\n                edges.push_back(make_pair(u, v));\n            }\n        } else {\n            // Add random edges if m > n - 1\n            while ((int)edges.size() < m) {\n                int u = rnd.next(1, n);\n                int v = rnd.next(1, n);\n                edges.push_back(make_pair(u, v));\n            }\n        }\n    } else if (type == \"star\") {\n        int center = rnd.next(1, n);\n        for (int i = 1; i <= n; ++i) {\n            if (i != center) {\n                edges.push_back(make_pair(center, i));\n            }\n        }\n        // Add random edges if m > n - 1\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            edges.push_back(make_pair(u, v));\n        }\n    } else {\n        // random or other types\n        // Build a random tree first\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back(make_pair(u, v));\n            int a = min(u, v);\n            int b = max(u, v);\n            edge_set.insert(make_pair(a, b));\n        }\n        // Now add extra edges\n        while ((int)edges.size() < m) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n\n            if (type == \"loops\" || type == \"negative_p_loops\") {\n                if (rnd.next(100) < 20) {\n                    // Increase chance of loops\n                    u = v;\n                }\n            }\n            if (type == \"multi\" || type == \"loops\" || type == \"negative_p_loops\" || type == \"loops_multi\") {\n                // Allow multiple edges and loops\n                edges.push_back(make_pair(u, v));\n            } else {\n                if (u == v) continue;\n\n                int a = min(u, v);\n                int b = max(u, v);\n                if (edge_set.count(make_pair(a, b)) == 0) {\n                    edges.push_back(make_pair(u, v));\n                    edge_set.insert(make_pair(a, b));\n                }\n            }\n        }\n    }\n\n    vector<int> weights((int)edges.size());\n\n    if (type == \"zero_weights\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = 0;\n        }\n    } else if (type == \"large_weights\") {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = (int)1e9;\n        }\n    } else {\n        for (size_t i = 0; i < edges.size(); ++i) {\n            weights[i] = rnd.next(0, (int)1e9);\n        }\n    }\n\n    // Output\n    printf(\"%d %d\\n\", n, m);\n    printf(\"%d %d\\n\", s, t);\n\n    for (int i = 1; i <= n; ++i) {\n        printf(\"%d%c\", p[i], i == n ? '\\n' : ' ');\n    }\n\n    for (size_t i = 0; i < edges.size(); ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int w = weights[i];\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n\n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "./gen -n 2 -m 1 -type random\n\n./gen -n 10 -m 9 -type random\n\n./gen -n 100 -m 99 -type chain\n\n./gen -n 2000 -m 1999 -type chain -s 1 -t 2000\n\n./gen -n 1000 -m 999 -type star\n\n./gen -n 2000 -m 100000 -type loops\n\n./gen -n 2000 -m 100000 -type multi\n\n./gen -n 2000 -m 100000 -type loops_multi\n\n./gen -n 2000 -m 50000 -type zero_p\n\n./gen -n 2000 -m 50000 -type negative_p\n\n./gen -n 2000 -m 50000 -type large_p\n\n./gen -n 2000 -m 50000 -type small_positive_p\n\n./gen -n 2000 -m 1999 -type chain_loops\n\n./gen -n 2000 -m 1999 -type chain_multi\n\n./gen -n 2000 -m 100000 -type negative_p_loops\n\n./gen -n 2000 -m 100000 -type random_s_far_t\n\n./gen -n 2000 -m 100000 -type random -s 1 -t 2\n\n./gen -n 2000 -m 100000 -type random\n\n./gen -n 2000 -m 50000 -type random\n\n./gen -n 2000 -m 50000 -type tricky\n\n./gen -n 2000 -m 100000 -type zero_weights\n\n./gen -n 2000 -m 100000 -type large_weights\n\n./gen -n 2 -m 1 -type random\n\n./gen -n 5 -m 10 -type random\n\n./gen -n 10 -m 45 -type complete\n\n./gen -n 2000 -m 100000 -type dense\n\n./gen -n 1000 -m 50000 -type random\n\n./gen -n 2000 -m 1999 -type chain -s 1 -t 2000\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:13.289943",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    },
    {
      "problem_id": "536/E",
      "title": "E. Тавас в пути",
      "difficulty": "Easy",
      "category": "Algorithm",
      "time_limit": "ограничение по времени на тест3 секунды",
      "memory_limit": "ограничение по памяти на тест256 мегабайт",
      "input_spec": "Входные данныеВ первой строке ввода записаны целые числа n и q (2 ≤ n ≤ 105 и 1 ≤ q ≤ 105).В следующей строке записано n - 1 целых чисел через пробел f1, f2, ..., fn - 1 (|fi| ≤ 1000).В следующих n - 1 строках записана информация про дороги. В каждой строке содержатся целые числа v, u и w, означающие, что между городами v и u есть дорога длины w (1 ≤ v, u ≤ n и 1 ≤ w ≤ 109).В следующих q строках записана информация о запросах. В каждой строке записаны целые числа v, u, l (1 ≤ v, u ≤ n, v ≠ u и 1 ≤ l ≤ 109).",
      "output_spec": "Выходные данныеВыведите ответ на каждый запрос на отдельной строке.",
      "sample_tests": "ПримерыВходные данныеСкопировать2 3101 2 31 2 21 2 31 2 4Выходные данныеСкопировать10100Входные данныеСкопировать6 6-5 0 0 2 101 2 12 3 23 4 54 5 15 6 51 6 11 6 21 6 53 6 54 6 41 4 2Выходные данныеСкопировать10-5-10-10-50",
      "description": "E. Тавас в пути\n\nограничение по времени на тест3 секунды\n\nограничение по времени на тест\n\nограничение по памяти на тест256 мегабайт\n\nограничение по памяти на тест\n\nвводстандартный ввод\n\nвыводстандартный вывод\n\nВходные данныеВ первой строке ввода записаны целые числа n и q (2 ≤ n ≤ 105 и 1 ≤ q ≤ 105).В следующей строке записано n - 1 целых чисел через пробел f1, f2, ..., fn - 1 (|fi| ≤ 1000).В следующих n - 1 строках записана информация про дороги. В каждой строке содержатся целые числа v, u и w, означающие, что между городами v и u есть дорога длины w (1 ≤ v, u ≤ n и 1 ≤ w ≤ 109).В следующих q строках записана информация о запросах. В каждой строке записаны целые числа v, u, l (1 ≤ v, u ≤ n, v ≠ u и 1 ≤ l ≤ 109).\n\nВходные данные\n\nВыходные данныеВыведите ответ на каждый запрос на отдельной строке.\n\nВыходные данные\n\nВходные данныеСкопировать2 3101 2 31 2 21 2 31 2 4Выходные данныеСкопировать10100Входные данныеСкопировать6 6-5 0 0 2 101 2 12 3 23 4 54 5 15 6 51 6 11 6 21 6 53 6 54 6 41 4 2Выходные данныеСкопировать10-5-10-10-50\n\nВходные данныеСкопировать2 3101 2 31 2 21 2 31 2 4\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10100\n\nВыходные данныеСкопировать\n\nСкопировать\n\nВходные данныеСкопировать6 6-5 0 0 2 101 2 12 3 23 4 54 5 15 6 51 6 11 6 21 6 53 6 54 6 41 4 2\n\nВходные данныеСкопировать\n\nСкопировать\n\nВыходные данныеСкопировать10-5-10-10-50\n\nВыходные данныеСкопировать\n\nСкопировать",
      "solutions": [
        {
          "title": "Codeforces Round #299 - Codeforces",
          "content": "Hi.Codeforces round #299 is gonna take place soon(exact time) and I'm the writer. I'm lucky to be the first Iranian author in Codeforces, in your and our new year (2015 and 1394).Now, I wanna thank: myself(PrinceOfPersia) for writing the problems(:P), MikeMirzayanov for great Codeforces and Polygon platform, Zlobober and Damon and sobhan.miryoosefi for helping me prepare this round, Haghani and SoroushE for testing this round, Delinur for translating problem statements into Russian and big thanks to my great buddy, HosseinYousefi for problem legends and the pictures.Also, I wanna thank MinakoKojima for teaching me how to use polygon and testlib and so much other things about it (about a year ago).This is my first official contest(after all those contests in Gym :D). I hope you enjoy it. The main character of all problems is Tavas, well-known by eating CoffeeMix without water! Trust me, when he does that it smells awful.Also, you'll meet his friends.I hope you enjoy the problems. I wish you all high ratings, many Accepted solutions and Successful hacking attempts. And Hacked instead of Failed System Test.Scoring will be posted later.GL & HF ;)UPD: Scoring will be standard for both divisions (500-1000-1500-2000-2500).UPD2: Contest is over. We're waiting for system testing. Editorial is published.UPD3: System test is done. Congratulations to all winners.Div.1 winners: jcvb rng_58 vepifanov mmaxio flydutchman And Div.2 winners are: l1n4r 0e352a vintage_Vlad_Makeev wilcot boray Good job everyone, see you ;)",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17371",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": false,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.4,
            "reason": "包含解题关键词，可能是相关解决方案"
          },
          "content_length": 1527
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces",
          "content": "535A - Tavas and NafasFirst of all check if n is one of the values 0, 10, 11, …, 19. Then, let’s have array x[] = {\"\", \"\", \"twenty\", \"thirty\", …, \"ninety\"} and y[] = {\"\", \"one\", …, \"nine\"}.Let and b = n modulo 10.If n is not one of the values above, then if a = 0, print y[b], else if b = 0 print x[a] otherwise print x[a]-y[b].Time complexity: O(1)Code by SoroushEAnother Code by PrinceOfPersiaAnother Code by HaghaniPython Code by Zlobober535B - Tavas and SaDDasSol1: Consider n has x digits, f(i) =  decimal representation of binary string i, m is a binary string of size x and its i - th digit is 0 if and only if the i - th digit of n is 4. Finally, answer equals to 21 + 22 + … + 2x - 1 + f(m) + 1.Time complexity: O(log(n))Sol2: Count the number of lucky numbers less than or equal to n using bitmask (assign a binary string to each lucky number by replacing 4s with 0 and 7s with 1).Time complexity: O(2log(n))Code by PrinceOfPersiaAnother Code by SoroushEAnother Code by Haghani Python Code by Zlobober536A - Tavas and KarafsLemma: Sequence h1, h2, …, hn is (m, t) - Tavas-Eatable if and only if max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t.Proof: only if is obvious (if the sequence is Tavas-Eatable, then it fulfills the condition).So we should prove that if the conditions are fulfilled, then the sequence is Tavas-Eatable.Use induction on h1 + h2 + ... + hn. Induction definition: the lemma above is true for every sequence h with sum of elements at most k. So now we should prove it for h1 + h2 + ... + hn = k + 1. There are two cases:1- There are at least m non-zero elements in the sequence. So, the number of elements equal to t is at most m (otherwise sum will exceed m × t). So, we decrease m maximum elements by 1. Maximum element will be at most t - 1 and sum will be at least m × t - m = m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.2- There are less than m non-zero elements in the sequence. We decrease them all by 1. Obviously, the new sequence has maximum element at most equal to t - 1 so its sum will be at most m(t - 1). So according to the induction definition, the new sequence is (m, t - 1) -  Tavas-Eatable, so h is (m, t) -  Tavas-Eatable.For this problem, use binary search on r and use the fact that the sequence is non-decreasing and .Time complexity: O(qlog(mt))Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536B - Tavas and MalekasFirst of all you need to find uncovered positions in s (because rest of them will determine uniquely). If there is no parados in covered positions (a position should have more than one value), then the answer will be 0, otherwise it’s 26uncovered. To check this, you just need to check that no two consecutive matches in s have parados. So, for this purpose, you need to check if a prefix of t is equal to one of its suffixes in O(1). You can easily check this with prefix function (or Z function).Time complexity: O(n + m)Code by PrinceOfPersiaAnother Code by HaghaniJava Code by Zlobober536C - Tavas and PashmaksFor each competitor put the point in the Cartesian plane. So, the time a competitor finishes the match is .Determine their convex hull(with maximum number of points. i.e it doesn’t matter to have π radians angle). Let L be the leftmost point on this convex hull (if there are more than one, choose the one with minimum y component). Similarly, let D be the point with minimum y component on this convex hull (if there are more than one, consider the leftmost).Proof: is the scalar product that is smaller if the point is farther in the direction of (S, R). It's obvious that the farthest points in some direction among the given set lie on a convex hull. (S, R) can get any value that is vector in first quadrant. So we need the points on the convex hull that we actually calculate (also we know that the points on the right or top of the convex hull, are not in the answer, because they're always losers).It’s easy to see that the answer is the points on the path from D to L on the convex hull (bottom-left arc). i.e the bottom-left part of the convex hull.Time complexity: O(nlog(n))In this problem, we recommend you to use integers. How ? Look at the code belowCode by PrinceOfPersiaIn this code, function CROSS returns (it's from order of 1016, so there won't be any overflows.)In double version, you should have a very small epsilon.Code of double version by PrinceOfPersiaAnother Code With Lower Envelope of Lines by HaghaniJava Code by Zlobober536D - Tavas in KansasFor each vertex v, put a point (dis(s, v), dis(v, t)) with its point (score) in the Cartesian plane. The first player in his/her turn chooses a vertical line and erases all the points on its left side. Second player in his/her turn chooses a horizontal line and erases all the point below it.Each player tries to maximize his/her score.Obviously, each time a player chooses a line on the right/upper side of his/her last choice. Imagine that there are A different x components x1 < x2 < … < xA and B different y components y1 < y2 < … < yB among all these lines. So, we can show each state before the game ends with a pair (a, b) (1 ≤ a ≤ A, 1 ≤ b ≤ B It means that in this state a point (X, Y) is not erased yet if and only if xa ≤ X and yb ≤ Y).So, using dp, dp[a][b][i] (1 ≤ i ≤ 2) is the maximum score of i - th player in state (a, b) and it’s i - th player’s turn. So, consider s[a][b] is the sum of the scores of all valid points in state (a, b) and t[a][b] is the amount of them. So, If i = 1 then, dp[a][b][i] = max(s[a][b] - dp[c][b][2]) (a ≤ c ≤ A, t[c][b] < t[a][b]).Otherwise dp[a][b][i] = max(s[a][b] - dp[a][c][1]) (b ≤ c ≤ B, t[a][c] < t[a][b]). So we need two backward fors for our dp and another for on i. So, now the only thing that matters is updating the dp. For this purpose, we need two more arrays QA and QB.QA[b][1] =  the minimum value of pairs (dp[j][b][2], t[j][b]) and QA[b][2] =  minimum value of pairs (dp[j][b][2], t[j][b]) such that t[j][b] > QA[b][1].second in the states we’ve seen so far. Similarly, QB[a][1] =  the minimum value of pairs (dp[a][j][1], t[a][j]) and QB[a][2] =  minimum value of pairs (dp[a][j][1], t[a][j]) such that t[a][j] > QB[a][1].second in the states we’ve seen so far. Now updating dp is pretty easy :dp[a][b][1] = s[a][b] - (t[a][b] ≤ QA[b][1].second?QA[b][2].first: QA[b][1].first).dp[a][b][2] = s[a][b] - (t[a][b] ≤ QB[a][1].second?QB[a][2].first: QB[a][1].first).And updating QA and QB is super easy.Now, let f = dp[1][1][1] and S be the sum of scores of all points. So, the score of first player is f and the second one is S - f.Time complexity: O(n2)Code by sobhan.miryoosefiAnother Code by HaghaniJava Code by Zlobober536E - Tavas on the PathLet's call the answer for vertices v and u with edges e1, e2, ..., ek on the path, score of sequence w(e1), w(e2), ..., w(ek).Use heavy-light decomposition. Decompose the edges into chains. So, for each Query, decompose the path into subchains. After solving the problem for them, combine them. Problem for subchains is :We have an array a1, a2, …, an and q queries. Each query gives numbers x, y, l (1 ≤ x ≤ y ≤ n) and we should print the goodness of subarray ax, ax + 1, …, ay.For this problem, we have too choices: 1.Solve offline with a normal segment tree. 2.Solve online using persistent segment tree. Now, I prefer to use the first approach. Sort the array to have a permutation of 1, 2, …, n: p1, p2, …, pn and ap1 ≥ ap2 ≥ … ≥ apn. Also sort the queries in the decreasing order of l. No for i - th query (in the sorted order) we have information: x, y, l, index. Then, use two pointers. Keep a pointer = n and Initially we have a binary string b, of length n with all indices set to 0. Then in each query: for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)Now, we should fins T(bx…Ty). For this purpose, we need a segment tree. In each node of the segment tree, we need to keep a package named node. struct node{\n\tint p, s, cnt, tot;\n};A package node is used for calculating T of a binary string c. p =  the number of leading 1s, s =  the number of trading 1s, cnt =  the total number of 1s, tot =  the T value of the binary string after deleting its leading and trading 1s.Merging two nodes is really easy. Also after reversing c, we just need to swap p and s.So, we can determine the node of this subarray in subchains. After solving these offline for subchains it's time for combining.Merge the node of subchains in the path from v to LCA(v, u) then merge the result with the reverse of the nodes of answers in the subchains in path from LCA(v, u) to u.Time complexity: O((n + m)log2(n))Code by PrinceOfPersia (This was one of the hardest codes I ever wrote in competitive programming :D)Shorter Code by HaghaniJava Code by ZloboberIf there's any suggestion or error, just let me know.",
          "author": "jiangly",
          "url": "https://codeforces.com/blog/entry/17401",
          "ai_judgment": {
            "ai_judgment": false,
            "contains_title": true,
            "is_relevant": true,
            "is_solution": true,
            "confidence": 0.8,
            "reason": "规则匹配到模式: 536\\s*E"
          },
          "content_length": 8999
        }
      ],
      "code_examples": [
        {
          "title": "Codeforces Round #299 - Codeforces - Code 1",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 2",
          "code": "action = \"none\"\nprediction = \"-1\"\nif action == prediction:\n  vote(+1)\nelse:\n  vote(-1)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 3",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 4",
          "code": "#include <bits/stdc++.h>\n// I love bits/stdc++.h\n#define int long long\n// I love define int long long\nusing namespace std;main() // I love messy code\n{while (true){int vote=0;int prediction;cin >> prediction;if(prediction==1)vote++;else vote--;}}",
          "language": "C++",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 5",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 6",
          "code": "for(int i=1;i<n;i++)\n  power[i] = (power[i - 1] * 26LL) % mod;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 7",
          "code": "int count = m == 0 ? 0 : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 8",
          "code": "int count = m == 0 ? n : (y[0] - 1);",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 9",
          "code": "\"444444444\"",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 10",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 11",
          "code": "boolean canByLargest = last <= t;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 12",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 13",
          "code": "3\n2 6\n3 3\n6 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 14",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 15",
          "code": "0: 2 3 4 5 6\n1: 2 2 3 4 6\n2: 1 2 2 3 6\n3: 1 1 1 2 6\n4: 0 0 1 1 6\n5: 0 0 0 0 6",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 16",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 17",
          "code": "4 2\naab\n1 2",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 18",
          "code": "mid=lef+rig>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 - Codeforces - Code 19",
          "code": "mid=(lef+rig)>>1;",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17371",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 1",
          "code": "pointer = n",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 2",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 3",
          "code": "for i = 1 to q\n\twhile (pointer > 1 and l[i] >= a[pointer])\n\t\tSet p[pointer]-th bit of b (from left) to 1\n\t\tpointer = pointer - 1\n\tanswer to query number index[i] = T(bx…by)",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 4",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 5",
          "code": "struct node{\n\tint p, s, cnt, tot;\n};",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 6",
          "code": "max(h1, h2, …, hn) ≤ t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 7",
          "code": "max(h1, h2, …, hn) ≤ t and h1 + h2 + … + hn ≤ m × t",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 8",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        },
        {
          "title": "Codeforces Round #299 Editorial - Codeforces - Code 9",
          "code": "20 2\nabacabac\n1 7",
          "language": "Unknown",
          "source": "https://codeforces.com/blog/entry/17401",
          "author": "jiangly"
        }
      ],
      "code_files": {
        "validator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(n - 1, -1000, 1000, \"f\");\n    inf.readEoln();\n\n    // Initialize Union-Find\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, \"w\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge cannot be a loop: edge from %d to %d\", v, u);\n\n        int pv = find(v);\n        int pu = find(u);\n        ensuref(pv != pu, \"Graph contains a cycle involving nodes %d and %d\", v, u);\n\n        unite(pv, pu);\n    }\n\n    // After reading edges, check that all nodes are connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not connected to node 1\", i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int v = inf.readInt(1, n, \"query_v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"query_u\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000000000, \"l\");\n        inf.readEoln();\n\n        ensuref(v != u, \"In query %d, v and u must be different, but both are %d\", i + 1, v);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
          "language": "C++",
          "type": "validator",
          "full_data": {
            "input_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(n - 1, -1000, 1000, \"f\");\n    inf.readEoln();\n\n    // Initialize Union-Find\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, \"w\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge cannot be a loop: edge from %d to %d\", v, u);\n\n        int pv = find(v);\n        int pu = find(u);\n        ensuref(pv != pu, \"Graph contains a cycle involving nodes %d and %d\", v, u);\n\n        unite(pv, pu);\n    }\n\n    // After reading edges, check that all nodes are connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not connected to node 1\", i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int v = inf.readInt(1, n, \"query_v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"query_u\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000000000, \"l\");\n        inf.readEoln();\n\n        ensuref(v != u, \"In query %d, v and u must be different, but both are %d\", i + 1, v);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "output_validator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 100005;\n\nint parent[MAXN];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid unite(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if (u != v) {\n        parent[v] = u;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = inf.readInt(2, 100000, \"n\");\n    inf.readSpace();\n    int q = inf.readInt(1, 100000, \"q\");\n    inf.readEoln();\n\n    vector<int> f = inf.readInts(n - 1, -1000, 1000, \"f\");\n    inf.readEoln();\n\n    // Initialize Union-Find\n    for (int i = 1; i <= n; ++i)\n        parent[i] = i;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int v = inf.readInt(1, n, \"v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"u\");\n        inf.readSpace();\n        int w = inf.readInt(1, 1000000000, \"w\");\n        inf.readEoln();\n\n        ensuref(v != u, \"Edge cannot be a loop: edge from %d to %d\", v, u);\n\n        int pv = find(v);\n        int pu = find(u);\n        ensuref(pv != pu, \"Graph contains a cycle involving nodes %d and %d\", v, u);\n\n        unite(pv, pu);\n    }\n\n    // After reading edges, check that all nodes are connected\n    int root = find(1);\n    for (int i = 2; i <= n; ++i) {\n        ensuref(find(i) == root, \"Graph is not connected, node %d is not connected to node 1\", i);\n    }\n\n    for (int i = 0; i < q; ++i) {\n        int v = inf.readInt(1, n, \"query_v\");\n        inf.readSpace();\n        int u = inf.readInt(1, n, \"query_u\");\n        inf.readSpace();\n        int l = inf.readInt(1, 1000000000, \"l\");\n        inf.readEoln();\n\n        ensuref(v != u, \"In query %d, v and u must be different, but both are %d\", i + 1, v);\n    }\n\n    inf.readEof();\n\n    return 0;\n}\n",
            "checker": "#include \"testlib.h\"\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char *argv[]) {\r\n    setName(\"compare ordered sequences of signed int%d numbers\", 8 * int(sizeof(long long)));\r\n\r\n    registerTestlibCmd(argc, argv);\r\n\r\n    int n = 0;\r\n    string firstElems;\r\n\r\n    while (!ans.seekEof() && !ouf.seekEof()) {\r\n        n++;\r\n        long long j = ans.readLong();\r\n        long long p = ouf.readLong();\r\n        if (j != p)\r\n            quitf(_wa, \"%d%s numbers differ - expected: '%s', found: '%s'\", n, englishEnding(n).c_str(),\r\n                  vtos(j).c_str(), vtos(p).c_str());\r\n        else if (n <= 5) {\r\n            if (firstElems.length() > 0)\r\n                firstElems += \" \";\r\n            firstElems += vtos(j);\r\n        }\r\n    }\r\n\r\n    int extraInAnsCount = 0;\r\n\r\n    while (!ans.seekEof()) {\r\n        ans.readLong();\r\n        extraInAnsCount++;\r\n    }\r\n\r\n    int extraInOufCount = 0;\r\n\r\n    while (!ouf.seekEof()) {\r\n        ouf.readLong();\r\n        extraInOufCount++;\r\n    }\r\n\r\n    if (extraInAnsCount > 0)\r\n        quitf(_wa, \"Answer contains longer sequence [length = %d], but output contains %d elements\",\r\n              n + extraInAnsCount, n);\r\n\r\n    if (extraInOufCount > 0)\r\n        quitf(_wa, \"Output contains longer sequence [length = %d], but answer contains %d elements\",\r\n              n + extraInOufCount, n);\r\n\r\n    if (n <= 5)\r\n        quitf(_ok, \"%d number(s): \\\"%s\\\"\", n, compress(firstElems).c_str());\r\n    else\r\n        quitf(_ok, \"%d numbers\", n);\r\n}",
            "status": "implemented"
          }
        },
        "generator": {
          "code": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", 10);\n    int q = opt<int>(\"q\", 10);\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string edgeWeightPattern = opt<string>(\"edgeWeightPattern\", \"random\");\n    string fiPattern = opt<string>(\"fiPattern\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n    int fiValue = opt<int>(\"fiValue\", 0); // For fiPattern = \"same\"\n    int edgeWeight = opt<int>(\"edgeWeight\", 1); // For edgeWeightPattern = \"same\"\n    int lvalue = opt<int>(\"lvalue\", 1); // For queryType = \"fixed\"\n    \n    // Limit checks\n    n = max(2, n);\n    n = min(100000, n);\n    \n    q = max(1, q);\n    q = min(100000, q);\n    \n    vector<pair<int, int>> edges;\n    \n    // Generate tree edges\n    if (treeType == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (treeType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (treeType == \"balanced\") {\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = i / 2;\n            edges.push_back({u, v});\n        }\n    } else { // \"random\" or default\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n    }\n    \n    // Shuffle node labels\n    vector<int> perm(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n    // Apply permutation to edges\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    \n    // Generate edge weights\n    vector<int> weights(n - 1);\n    if (edgeWeightPattern == \"max\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = 1000000000;\n        }\n    } else if (edgeWeightPattern == \"min\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = 1;\n        }\n    } else if (edgeWeightPattern == \"ascending\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = i + 1;\n        }\n    } else if (edgeWeightPattern == \"descending\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = 1000000000 - i;\n        }\n    } else if (edgeWeightPattern == \"same\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = edgeWeight;\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(1, 1000000000);\n        }\n    }\n    \n    // Generate fi values\n    vector<int> fi(n - 1);\n    if (fiPattern == \"zero\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = 0;\n        }\n    } else if (fiPattern == \"same\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = fiValue;\n        }\n    } else if (fiPattern == \"max\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = 1000;\n        }\n    } else if (fiPattern == \"min\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = -1000;\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = rnd.next(-1000, 1000);\n        }\n    }\n    \n    // Generate queries\n    vector<tuple<int, int, int>> queries;\n    if (queryType == \"max_l\") {\n        // l = 1e9, random nodes\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, 1000000000));\n        }\n    } else if (queryType == \"min_l\") {\n        // l = 1, random nodes\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, 1));\n        }\n    } else if (queryType == \"fixed\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, lvalue));\n        }\n    } else if (queryType == \"leaf_to_root\") {\n        // Find leaf nodes\n        vector<int> degree(n + 1, 0);\n        for (auto &edge : edges) {\n            degree[edge.first]++;\n            degree[edge.second]++;\n        }\n        vector<int> leaves;\n        int root = perm[1];\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != root) {\n                leaves.push_back(i);\n            }\n        }\n        for (int i = 0; i < q; ++i) {\n            int leaf = leaves[rnd.next(0, (int)leaves.size() - 1)];\n            queries.push_back(make_tuple(leaf, root, rnd.next(1, 1000000000)));\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, rnd.next(1, 1000000000)));\n        }\n    }\n    \n    // Output\n    // First line: n and q\n    printf(\"%d %d\\n\", n, q);\n    // Second line: fi values (n - 1 numbers)\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", fi[i]);\n        if (i + 1 < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Next n - 1 lines: edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int w = weights[i];\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n    // Next q lines: queries\n    for (int i = 0; i < q; ++i) {\n        int u = get<0>(queries[i]);\n        int v = get<1>(queries[i]);\n        int l = get<2>(queries[i]);\n        printf(\"%d %d %d\\n\", u, v, l);\n    }\n    \n    return 0;\n}\n",
          "language": "C++",
          "type": "generator",
          "full_data": {
            "input_generator": "#include \"testlib.h\"\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n    \n    int n = opt<int>(\"n\", 10);\n    int q = opt<int>(\"q\", 10);\n    string treeType = opt<string>(\"treeType\", \"random\");\n    string edgeWeightPattern = opt<string>(\"edgeWeightPattern\", \"random\");\n    string fiPattern = opt<string>(\"fiPattern\", \"random\");\n    string queryType = opt<string>(\"queryType\", \"random\");\n    int fiValue = opt<int>(\"fiValue\", 0); // For fiPattern = \"same\"\n    int edgeWeight = opt<int>(\"edgeWeight\", 1); // For edgeWeightPattern = \"same\"\n    int lvalue = opt<int>(\"lvalue\", 1); // For queryType = \"fixed\"\n    \n    // Limit checks\n    n = max(2, n);\n    n = min(100000, n);\n    \n    q = max(1, q);\n    q = min(100000, q);\n    \n    vector<pair<int, int>> edges;\n    \n    // Generate tree edges\n    if (treeType == \"chain\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({i - 1, i});\n        }\n    } else if (treeType == \"star\") {\n        for (int i = 2; i <= n; ++i) {\n            edges.push_back({1, i});\n        }\n    } else if (treeType == \"balanced\") {\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = i / 2;\n            edges.push_back({u, v});\n        }\n    } else { // \"random\" or default\n        for (int i = 2; i <= n; ++i) {\n            int u = i;\n            int v = rnd.next(1, i - 1);\n            edges.push_back({u, v});\n        }\n    }\n    \n    // Shuffle node labels\n    vector<int> perm(n + 1); // 1-based indexing\n    for (int i = 1; i <= n; ++i) {\n        perm[i] = i;\n    }\n    shuffle(perm.begin() + 1, perm.end());\n    // Apply permutation to edges\n    for (auto &edge : edges) {\n        edge.first = perm[edge.first];\n        edge.second = perm[edge.second];\n    }\n    // Shuffle edges\n    shuffle(edges.begin(), edges.end());\n    \n    // Generate edge weights\n    vector<int> weights(n - 1);\n    if (edgeWeightPattern == \"max\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = 1000000000;\n        }\n    } else if (edgeWeightPattern == \"min\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = 1;\n        }\n    } else if (edgeWeightPattern == \"ascending\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = i + 1;\n        }\n    } else if (edgeWeightPattern == \"descending\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = 1000000000 - i;\n        }\n    } else if (edgeWeightPattern == \"same\") {\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = edgeWeight;\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < n - 1; ++i) {\n            weights[i] = rnd.next(1, 1000000000);\n        }\n    }\n    \n    // Generate fi values\n    vector<int> fi(n - 1);\n    if (fiPattern == \"zero\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = 0;\n        }\n    } else if (fiPattern == \"same\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = fiValue;\n        }\n    } else if (fiPattern == \"max\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = 1000;\n        }\n    } else if (fiPattern == \"min\") {\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = -1000;\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < n - 1; ++i) {\n            fi[i] = rnd.next(-1000, 1000);\n        }\n    }\n    \n    // Generate queries\n    vector<tuple<int, int, int>> queries;\n    if (queryType == \"max_l\") {\n        // l = 1e9, random nodes\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, 1000000000));\n        }\n    } else if (queryType == \"min_l\") {\n        // l = 1, random nodes\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, 1));\n        }\n    } else if (queryType == \"fixed\") {\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, lvalue));\n        }\n    } else if (queryType == \"leaf_to_root\") {\n        // Find leaf nodes\n        vector<int> degree(n + 1, 0);\n        for (auto &edge : edges) {\n            degree[edge.first]++;\n            degree[edge.second]++;\n        }\n        vector<int> leaves;\n        int root = perm[1];\n        for (int i = 1; i <= n; ++i) {\n            if (degree[i] == 1 && i != root) {\n                leaves.push_back(i);\n            }\n        }\n        for (int i = 0; i < q; ++i) {\n            int leaf = leaves[rnd.next(0, (int)leaves.size() - 1)];\n            queries.push_back(make_tuple(leaf, root, rnd.next(1, 1000000000)));\n        }\n    } else { // \"random\" or default\n        for (int i = 0; i < q; ++i) {\n            int u = rnd.next(1, n);\n            int v = rnd.next(1, n);\n            while (u == v) v = rnd.next(1, n);\n            queries.push_back(make_tuple(u, v, rnd.next(1, 1000000000)));\n        }\n    }\n    \n    // Output\n    // First line: n and q\n    printf(\"%d %d\\n\", n, q);\n    // Second line: fi values (n - 1 numbers)\n    for (int i = 0; i < n - 1; ++i) {\n        printf(\"%d\", fi[i]);\n        if (i + 1 < n - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    // Next n - 1 lines: edges\n    for (int i = 0; i < n - 1; ++i) {\n        int u = edges[i].first;\n        int v = edges[i].second;\n        int w = weights[i];\n        printf(\"%d %d %d\\n\", u, v, w);\n    }\n    // Next q lines: queries\n    for (int i = 0; i < q; ++i) {\n        int u = get<0>(queries[i]);\n        int v = get<1>(queries[i]);\n        int l = get<2>(queries[i]);\n        printf(\"%d %d %d\\n\", u, v, l);\n    }\n    \n    return 0;\n}\n",
            "output_generator": "",
            "test_cases": [],
            "generator_cmd": "# Small chain tree, small q\n./gen -n 5 -q 5 -treeType chain -edgeWeightPattern same -edgeWeight 1 -fiPattern same -fiValue 10 -queryType random\n\n# Small star tree, small q\n./gen -n 5 -q 5 -treeType star -edgeWeightPattern same -edgeWeight 2 -fiPattern zero -queryType random\n\n# Random tree, small q\n./gen -n 10 -q 5 -treeType random -edgeWeightPattern random -fiPattern random -queryType random\n\n# Chain tree, max edge weights\n./gen -n 100000 -q 100000 -treeType chain -edgeWeightPattern max -fiPattern max -queryType min_l\n\n# Star tree, min edge weights\n./gen -n 100000 -q 100000 -treeType star -edgeWeightPattern min -fiPattern min -queryType max_l\n\n# Random tree, random edge weights\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern random -queryType random\n\n# Balanced tree, ascending edge weights\n./gen -n 100000 -q 100000 -treeType balanced -edgeWeightPattern ascending -fiPattern random -queryType random\n\n# Chain tree, descending edge weights\n./gen -n 100000 -q 100000 -treeType chain -edgeWeightPattern descending -fiPattern random -queryType random\n\n# Random tree, fi values zero\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern zero -queryType random\n\n# Random tree, fi values same value\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern same -fiValue 10 -queryType random\n\n# Random tree, fi values negative\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern min -queryType random\n\n# Random tree, queryType leaf_to_root\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern random -queryType leaf_to_root\n\n# Random tree, lvalue is maximum\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern random -queryType fixed -lvalue 1000000000\n\n# Random tree, lvalue is minimum\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern random -queryType fixed -lvalue 1\n\n# Random tree, edge weights same\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern same -edgeWeight 1000000000 -fiPattern random -queryType random\n\n# Star tree, fixed lvalue\n./gen -n 100000 -q 100000 -treeType star -edgeWeightPattern random -fiPattern random -queryType fixed -lvalue 500000000\n\n# Chain tree, fixed lvalue\n./gen -n 100000 -q 100000 -treeType chain -edgeWeightPattern random -fiPattern random -queryType fixed -lvalue 500000000\n\n# Balanced tree, queries leaf to root\n./gen -n 100000 -q 100000 -treeType balanced -edgeWeightPattern random -fiPattern random -queryType leaf_to_root\n\n# Small test case\n./gen -n 2 -q 1 -treeType chain -edgeWeightPattern same -edgeWeight 1 -fiPattern same -fiValue 10 -queryType fixed -lvalue 3\n\n# Edge test case, n=2\n./gen -n 2 -q 3 -treeType chain -edgeWeightPattern same -edgeWeight 3 -fiPattern same -fiValue 10 -queryType fixed -lvalue 2\n\n# Edge test case, varied lvalue\n./gen -n 6 -q 6 -treeType chain -edgeWeightPattern random -fiPattern random -queryType fixed -lvalue 5\n\n# Random small tree\n./gen -n 10 -q 10 -treeType random -edgeWeightPattern random -fiPattern random -queryType random\n\n# Chain with negative fi\n./gen -n 100000 -q 100000 -treeType chain -edgeWeightPattern random -fiPattern min -queryType random\n\n# Random tree with maximum edge weights and minimum lvalues\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern max -fiPattern random -queryType min_l\n\n# Random tree with minimum edge weights and maximum lvalues\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern min -fiPattern random -queryType max_l\n\n# Random tree with descending fi values\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern descending -queryType random\n\n# Random tree with ascending fi values\n./gen -n 100000 -q 100000 -treeType random -edgeWeightPattern random -fiPattern ascending -queryType random\n\n# Small balanced tree\n./gen -n 15 -q 10 -treeType balanced -edgeWeightPattern random -fiPattern random -queryType random\n",
            "status": "implemented"
          }
        }
      },
      "metadata": {
        "sources": [
          "standardized_dataset",
          "enhanced_results"
        ],
        "merge_time": "2025-08-28T20:45:15.059984",
        "total_tutorials": 2,
        "has_ai_judgment": true,
        "has_code_files": true
      }
    }
  ]
}